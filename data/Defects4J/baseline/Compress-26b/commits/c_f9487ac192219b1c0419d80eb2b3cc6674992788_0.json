{"sha": "f9487ac192219b1c0419d80eb2b3cc6674992788", "log": "Explode support for ZipFile and ZipArchiveInputStream (COMPRESS-115)  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/BinaryTree.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+\n+/**\n+ * Binary tree of positive values.\n+ * \n+ * @author Emmanuel Bourg\n+ * @since 1.7\n+ */\n+class BinaryTree {\n+\n+    /** Value in the array indicating an undefined node */\n+    private static final int UNDEFINED = -1;\n+    \n+    /** Value in the array indicating a non leaf node */\n+    private static final int NODE = -2;\n+\n+    /** \n+     * The array representing the binary tree. The root is at index 0,\n+     * the left children are at 2*i+1 and the right children at 2*i+2.\n+     */\n+    private final int[] tree;\n+\n+    public BinaryTree(int depth) {\n+        tree = new int[(1 << (depth + 1)) - 1];\n+        Arrays.fill(tree, UNDEFINED);\n+    }\n+\n+    /**\n+     * Adds a leaf to the tree.\n+     * \n+     * @param node   the index of the node where the path is appended\n+     * @param path   the path to the leaf (bits are parsed from the right to the left)\n+     * @param depth  the number of nodes in the path\n+     * @param value  the value of the leaf (must be positive)\n+     */\n+    public void addLeaf(int node, int path, int depth, int value) {\n+        if (depth == 0) {\n+            // end of the path reached, add the value to the current node\n+            if (tree[node] == UNDEFINED) {\n+                tree[node] = value;\n+            } else {\n+                throw new IllegalArgumentException(\"Tree value at index \" + node + \" has already been assigned (\" + tree[node] + \")\");\n+            }\n+        } else {\n+            // mark the current node as a non leaf node\n+            tree[node] = NODE;\n+            \n+            // move down the path recursively\n+            int nextChild = 2 * node + 1 + (path & 1);\n+            addLeaf(nextChild, path >>> 1, depth - 1, value);\n+        }\n+    }\n+\n+    /**\n+     * Reads a value from the specified bit stream.\n+     * \n+     * @param stream\n+     * @return the value decoded, or -1 if the end of the stream is reached\n+     */\n+    public int read(BitStream stream) throws IOException {\n+        short currentIndex = 0;\n+\n+        while (true) {\n+            int bit = stream.nextBit();\n+            if (bit == -1) {\n+                return -1;\n+            }\n+\n+            short childIndex = (short) (2 * currentIndex + 1 + bit);\n+            int value = tree[childIndex];\n+            if (value == NODE) {\n+                // consume the next bit\n+                currentIndex = childIndex;\n+            } else if (value != UNDEFINED) {\n+                return value;\n+            } else {\n+                throw new IOException(\"The child \" + bit + \" of node at index \" + currentIndex + \" is not defined\");\n+            }\n+        }\n+    }\n+    \n+\n+    /**\n+     * Decodes the packed binary tree from the specified stream.\n+     */\n+    static BinaryTree decode(InputStream in, final int totalNumberOfValues) throws IOException {\n+        // the first byte contains the size of the structure minus one\n+        int size = in.read() + 1;\n+        if (size == 0) {\n+            throw new IOException(\"Cannot read the size of the encoded tree, unexpected end of stream\");\n+        }\n+\n+        byte[] encodedTree = new byte[size];\n+        new DataInputStream(in).readFully(encodedTree);\n+\n+        /** The maximum bit length for a value (16 or lower) */\n+        int maxLength = 0;\n+        \n+        int[] originalBitLengths = new int[totalNumberOfValues];\n+        int pos = 0;\n+        for (byte b : encodedTree) {\n+            // each byte encodes the number of values (upper 4 bits) for a bit length (lower 4 bits)\n+            int numberOfValues = ((b & 0xF0) >> 4) + 1;\n+            int bitLength = (b & 0x0F) + 1;\n+\n+            for (int j = 0; j < numberOfValues; j++) {\n+                originalBitLengths[pos++] = bitLength;\n+            }\n+            \n+            maxLength = Math.max(maxLength, bitLength);\n+        }\n+\n+        // sort the array of bit lengths and memorize the permutation used to restore the order of the codes\n+        int[] permutation = new int[originalBitLengths.length];\n+        for (int k = 0; k < permutation.length; k++) {\n+            permutation[k] = k;\n+        }\n+        \n+        int c = 0;\n+        int[] sortedBitLengths = new int[originalBitLengths.length];\n+        for (int k = 0; k < originalBitLengths.length; k++) {\n+            // iterate over the values\n+            for (int l = 0; l < originalBitLengths.length; l++) {\n+                // look for the value in the original array\n+                if (originalBitLengths[l] == k) {\n+                    // put the value at the current position in the sorted array...\n+                    sortedBitLengths[c] = k;\n+                    \n+                    // ...and memorize the permutation\n+                    permutation[c] = l; \n+                    \n+                    c++;\n+                }\n+            }\n+        }\n+\n+        // decode the values of the tree\n+        int code = 0;\n+        int codeIncrement = 0;\n+        int lastBitLength = 0;\n+\n+        int[] codes = new int[totalNumberOfValues];\n+\n+        for (int i = totalNumberOfValues - 1; i >= 0; i--) {\n+            code = code + codeIncrement;\n+            if (sortedBitLengths[i] != lastBitLength) {\n+                lastBitLength = sortedBitLengths[i];\n+                codeIncrement = 1 << (16 - lastBitLength);\n+            }\n+            codes[permutation[i]] = code;\n+        }\n+        \n+        // build the tree\n+        BinaryTree tree = new BinaryTree(maxLength);\n+        \n+        for (int k = 0; k < codes.length; k++) {\n+            int bitLength = originalBitLengths[k];\n+            if (bitLength > 0) {\n+                tree.addLeaf(0, Integer.reverse(codes[k] << 16), bitLength, k);\n+            }\n+        }\n+\n+        return tree;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/BitStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+/**\n+ * Iterates over the bits of an InputStream. For each byte the bits\n+ * are read from the right to the left.\n+ *\n+ * @since 1.7\n+ */\n+class BitStream {\n+\n+    private final InputStream in;\n+\n+    /** The bits read from the underlying stream but not consumed by nextBits() */\n+    private long bitCache;\n+\n+    /** The number of bits available in the bit cache */\n+    private int bitCacheSize;\n+\n+    /** Bit masks for extracting the right most bits from a byte */\n+    private static final int[] MASKS = new int[]{ \n+            0x00, // 00000000\n+            0x01, // 00000001\n+            0x03, // 00000011\n+            0x07, // 00000111\n+            0x0F, // 00001111\n+            0x1F, // 00011111\n+            0x3F, // 00111111\n+            0x7F, // 01111111\n+            0xFF  // 11111111\n+    };\n+\n+    BitStream(InputStream in) {\n+        this.in = in;\n+    }\n+\n+    private boolean fillCache() throws IOException {\n+        boolean filled = false;\n+        \n+        while (bitCacheSize <= 56) {\n+            long nextByte = in.read();\n+            if (nextByte == -1) {\n+                break;\n+            }\n+            \n+            filled = true;\n+            bitCache = bitCache | (nextByte << bitCacheSize);\n+            bitCacheSize += 8;\n+        }\n+\n+        return filled;\n+    }\n+\n+    /**\n+     * Returns the next bit.\n+     * \n+     * @return The next bit (0 or 1) or -1 if the end of the stream has been reached\n+     */\n+    int nextBit() throws IOException {\n+        if (bitCacheSize == 0) {\n+            if (!fillCache()) {\n+                return -1;\n+            }\n+        }\n+\n+        int bit = (int) (bitCache & 1); // extract the right most bit\n+\n+        bitCache = (bitCache >>> 1); // shift the remaning bits to the right\n+        bitCacheSize--;\n+\n+        return bit;\n+    }\n+\n+    /**\n+     * Returns the integer value formed by the n next bits (up to 8 bits).\n+     *\n+     * @param n the number of bits read (up to 8)\n+     * @return The value formed by the n bits, or -1 if the end of the stream has been reached\n+     */\n+    int nextBits(final int n) throws IOException {\n+        if (bitCacheSize < n) {\n+            if (!fillCache()) {\n+                return -1;\n+            }\n+        }\n+\n+        final int bits = (int) (bitCache & MASKS[n]); // extract the right most bits\n+\n+        bitCache = (bitCache >>> n); // shift the remaning bits to the right\n+        bitCacheSize = bitCacheSize - n;\n+\n+        return bits;\n+    }\n+\n+    int nextByte() throws IOException {\n+        return nextBits(8);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/CircularBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+/**\n+ * Circular byte buffer.\n+ * \n+ * @author Emmanuel Bourg\n+ * @since 1.7\n+ */\n+class CircularBuffer {\n+\n+    /** Size of the buffer */\n+    private final int size;\n+    \n+    /** The buffer */\n+    private final byte[] buffer;\n+\n+    /** Index of the next data to be read from the buffer */\n+    private int readIndex;\n+\n+    /** Index of the next data written in the buffer */\n+    private int writeIndex;\n+\n+    CircularBuffer(int size) {\n+        this.size = size;\n+        buffer = new byte[size];\n+    }\n+\n+    /**\n+     * Tells if a new byte can be read from the buffer.\n+     */\n+    public boolean available() {\n+        return readIndex != writeIndex;\n+    }\n+\n+    /**\n+     * Writes a byte to the buffer.\n+     */\n+    public void put(int value) {\n+        buffer[writeIndex] = (byte) value;\n+        writeIndex = (writeIndex + 1) % size;\n+    }\n+\n+    /**\n+     * Reads a byte from the buffer.\n+     */\n+    public int get() {\n+        if (available()) {\n+            int value = buffer[readIndex];\n+            readIndex = (readIndex + 1) % size;\n+            return value & 0xFF;\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Copy a previous interval in the buffer to the current position.\n+     * \n+     * @param distance the distance from the current write position\n+     * @param length   the number of bytes to copy\n+     */\n+    public void copy(int distance, int length) {\n+        int pos1 = writeIndex - distance;\n+        int pos2 = pos1 + length;\n+        for (int i = pos1; i < pos2; i++) {\n+            buffer[writeIndex] = buffer[(i + size) % size];\n+            writeIndex = (writeIndex + 1) % size;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExplodingInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+/**\n+ * The implode compression method was added to PKZIP 1.01 released in 1989.\n+ * It was then dropped from PKZIP 2.0 released in 1993 in favor of the deflate\n+ * method.\n+ * <p>\n+ * The algorithm is described in the ZIP File Format Specification.\n+ * \n+ * @see <a href=\"http://www.pkware.com/documents/casestudies/APPNOTE.TXT\">ZIP File Format Specification</a>\n+ * \n+ * @author Emmanuel Bourg\n+ * @since 1.7\n+ */\n+class ExplodingInputStream extends InputStream {\n+\n+    /** The underlying stream containing the compressed data */\n+    private final InputStream in;\n+    \n+    /** The stream of bits read from the input stream */\n+    private BitStream bits;\n+\n+    /** The size of the sliding dictionary (4K or 8K) */\n+    private final int dictionarySize;\n+\n+    /** The number of Shannon-Fano trees (2 or 3) */\n+    private final int numberOfTrees;\n+\n+    private final int minimumMatchLength;\n+\n+    /** The binary tree containing the 256 encoded literals (null when only two trees are used) */\n+    private BinaryTree literalTree;\n+\n+    /** The binary tree containing the 64 encoded lengths */\n+    private BinaryTree lengthTree;\n+\n+    /** The binary tree containing the 64 encoded distances */\n+    private BinaryTree distanceTree;\n+\n+    /** Output buffer holding the decompressed data */\n+    private final CircularBuffer buffer = new CircularBuffer(32 * 1024);\n+\n+    /**\n+     * Create a new stream decompressing the content of the specified stream\n+     * using the explode algorithm.\n+     *\n+     * @param dictionarySize the size of the sliding dictionary (4096 or 8192)\n+     * @param numberOfTrees  the number of trees (2 or 3)\n+     * @param in             the compressed data stream\n+     */\n+    public ExplodingInputStream(int dictionarySize, int numberOfTrees, InputStream in) {\n+        if (dictionarySize != 4096 && dictionarySize != 8192) {\n+            throw new IllegalArgumentException(\"The dictionary size must be 4096 or 8192\");\n+        }\n+        if (numberOfTrees != 2 && numberOfTrees != 3) {\n+            throw new IllegalArgumentException(\"The number of trees must be 2 or 3\");\n+        }\n+        this.dictionarySize = dictionarySize;\n+        this.numberOfTrees = numberOfTrees;\n+        this.minimumMatchLength = numberOfTrees;\n+        this.in = in;\n+    }\n+\n+    /**\n+     * Reads the encoded binary trees and prepares the bit stream.\n+     * \n+     * @throws IOException\n+     */\n+    private void init() throws IOException {\n+        if (bits == null) {\n+            if (numberOfTrees == 3) {\n+                literalTree = BinaryTree.decode(in, 256);\n+            }\n+\n+            lengthTree = BinaryTree.decode(in, 64);\n+            distanceTree = BinaryTree.decode(in, 64);\n+            \n+            bits = new BitStream(in);\n+        }\n+    }\n+\n+    @Override\n+    public int read() throws IOException {\n+        if (!buffer.available()) {\n+            fillBuffer();\n+        }\n+\n+        return buffer.get();\n+    }\n+\n+    /**\n+     * Fill the sliding dictionary with more data.\n+     * @throws IOException\n+     */\n+    private void fillBuffer() throws IOException {\n+        init();\n+        \n+        int bit = bits.nextBit();\n+        if (bit == 1) {\n+            // literal value\n+            int literal;\n+            if (literalTree != null) {\n+                literal = literalTree.read(bits);\n+            } else {\n+                literal = bits.nextBits(8);\n+            }\n+\n+            if (literal == -1) {\n+                // end of stream reached, nothing left to decode\n+                return;\n+            }\n+            \n+            buffer.put(literal);\n+\n+        } else if (bit == 0) {\n+            // back reference\n+            int distanceLowSize = dictionarySize == 4096 ? 6 : 7;\n+            int distanceLow = bits.nextBits(distanceLowSize);\n+            int distanceHigh = distanceTree.read(bits);\n+            if (distanceHigh == -1 && distanceLow <= 0) {\n+                // end of stream reached, nothing left to decode\n+                return;\n+            }\n+            int distance = distanceHigh << distanceLowSize | distanceLow;\n+            \n+            int length = lengthTree.read(bits);\n+            if (length == 63) {\n+                length += bits.nextBits(8);\n+            }\n+            length += minimumMatchLength;\n+\n+            buffer.copy(distance + 1, length);\n+        }\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n /**\n  * Parser/encoder for the \"general purpose bit\" field in ZIP's local\n  * file and central directory headers.\n+ * \n  * @since 1.1\n  * @NotThreadSafe\n  */\n public final class GeneralPurposeBit {\n+\n     /**\n      * Indicates that the file is encrypted.\n      */\n     private static final int ENCRYPTION_FLAG = 1 << 0;\n+\n+    /**\n+     * Indicates the size of the sliding dictionary used by the compression method 6 (imploding).\n+     * <ul>\n+     *   <li>0: 4096 bytes</li>\n+     *   <li>1: 8192 bytes</li>\n+     * </ul>\n+     */\n+    private static final int SLIDING_DICTIONARY_SIZE_FLAG = 1 << 1;\n+\n+    /**\n+     * Indicates the number of Shannon-Fano trees used by the compression method 6 (imploding).\n+     * <ul>\n+     *   <li>0: 2 trees (lengths, distances)</li>\n+     *   <li>1: 3 trees (literals, lengths, distances)</li>\n+     * </ul>\n+     */\n+    private static final int NUMBER_OF_SHANNON_FANO_TREES_FLAG = 1 << 2;\n \n     /**\n      * Indicates that a data descriptor stored after the file contents\n     private boolean dataDescriptorFlag = false;\n     private boolean encryptionFlag = false;\n     private boolean strongEncryptionFlag = false;\n+    private int slidingDictionarySize;\n+    private int numberOfShannonFanoTrees;\n \n     public GeneralPurposeBit() {\n     }\n         if (b) {\n             useEncryption(true);\n         }\n+    }\n+\n+    /**\n+     * Returns the sliding dictionary size used by the compression method 6 (imploding).\n+     */\n+    int getSlidingDictionarySize() {\n+        return slidingDictionarySize;\n+    }\n+\n+    /**\n+     * Returns the number of trees used by the compression method 6 (imploding).\n+     */\n+    int getNumberOfShannonFanoTrees() {\n+        return numberOfShannonFanoTrees;\n     }\n \n     /**\n \n     /**\n      * Parses the supported flags from the given archive data.\n+     * \n      * @param data local file header or a central directory entry.\n      * @param offset offset at which the general purpose bit starts\n      */\n         GeneralPurposeBit b = new GeneralPurposeBit();\n         b.useDataDescriptor((generalPurposeFlag & DATA_DESCRIPTOR_FLAG) != 0);\n         b.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\n-        b.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG)\n-                              != 0);\n+        b.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG) != 0);\n         b.useEncryption((generalPurposeFlag & ENCRYPTION_FLAG) != 0);\n+        b.slidingDictionarySize = ((generalPurposeFlag & SLIDING_DICTIONARY_SIZE_FLAG) != 0) ? 8192 : 4096;\n+        b.numberOfShannonFanoTrees = ((generalPurposeFlag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) != 0) ? 3 : 2;\n         return b;\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n         }\n \n         processZip64Extra(size, cSize);\n-        \n-        if (current.entry.getCompressedSize() != -1 \n-                && current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n-            current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n+\n+        if (current.entry.getCompressedSize() != -1) {\n+            if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n+                current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n+            } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n+                current.in = new ExplodingInputStream(\n+                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n+                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n+                        new BoundedInputStream(in, current.entry.getCompressedSize()));\n+            }\n         }\n         \n         entriesRead++;\n             read = readStored(buffer, offset, length);\n         } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n             read = readDeflated(buffer, offset, length);\n-        } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n+        } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n+                || current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n             read = current.in.read(buffer, offset, length);\n         } else {\n             throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()),\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n     @Override\n     public boolean canWriteEntryData(ArchiveEntry ae) {\n         if (ae instanceof ZipArchiveEntry) {\n-            return ZipUtil.canHandleEntryData((ZipArchiveEntry) ae);\n+            ZipArchiveEntry zae = (ZipArchiveEntry) ae;\n+            return zae.getMethod() != ZipMethod.IMPLODING.getCode() && ZipUtil.canHandleEntryData(zae);\n         }\n         return false;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n  */\n package org.apache.commons.compress.archivers.zip;\n \n+import java.io.BufferedInputStream;\n import java.io.EOFException;\n import java.io.File;\n import java.io.IOException;\n                 return bis;\n             case UNSHRINKING:\n                 return new UnshrinkingInputStream(bis);\n+            case IMPLODING:\n+                return new ExplodingInputStream(ze.getGeneralPurposeBit().getSlidingDictionarySize(),\n+                        ze.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), new BufferedInputStream(bis));\n             case DEFLATED:\n                 bis.addDummy();\n                 final Inflater inflater = new Inflater(true);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n     private static boolean supportsMethodOf(ZipArchiveEntry entry) {\n         return entry.getMethod() == ZipEntry.STORED\n             || entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n+            || entry.getMethod() == ZipMethod.IMPLODING.getCode()\n             || entry.getMethod() == ZipEntry.DEFLATED;\n     }\n \n--- a/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\n import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;\n import org.apache.commons.compress.archivers.zip.ZipFile;\n+import org.apache.commons.compress.archivers.zip.ZipMethod;\n import org.apache.commons.compress.utils.IOUtils;\n \n public final class ZipTestCase extends AbstractTestCase {\n      * >COMPRESS-93</a>.\n      */\n     public void testSupportedCompressionMethod() throws IOException {\n+        /*\n         ZipFile bla = new ZipFile(getFile(\"bla.zip\"));\n         assertTrue(bla.canReadEntryData(bla.getEntry(\"test1.xml\")));\n         bla.close();\n-\n+        */\n+        \n         ZipFile moby = new ZipFile(getFile(\"moby.zip\"));\n-        assertFalse(moby.canReadEntryData(moby.getEntry(\"README\")));\n+        ZipArchiveEntry entry = moby.getEntry(\"README\");\n+        assertEquals(\"method\", ZipMethod.TOKENIZATION.getCode(), entry.getMethod());\n+        assertFalse(moby.canReadEntryData(entry));\n         moby.close();\n     }\n \n             new ZipArchiveInputStream(new FileInputStream(getFile(\"moby.zip\")));\n         try {\n             ZipArchiveEntry entry = zip.getNextZipEntry();\n+            assertEquals(\"method\", ZipMethod.TOKENIZATION.getCode(), entry.getMethod());\n             assertEquals(\"README\", entry.getName());\n             assertFalse(zip.canReadEntryData(entry));\n             try {\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/BinaryTreeTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import junit.framework.TestCase;\n+\n+public class BinaryTreeTest extends TestCase {\n+\n+    public void testDecode() throws IOException {\n+        InputStream in = new ByteArrayInputStream(new byte[] { 0x02, 0x42, 0x01, 0x13 });\n+        \n+        BinaryTree tree = BinaryTree.decode(in, 8);\n+        \n+        assertNotNull(tree);\n+        \n+        BitStream stream = new BitStream(new ByteArrayInputStream(new byte[] { (byte) 0x8D, (byte) 0xC5, (byte) 0x11, 0x00 }));\n+        assertEquals(0, tree.read(stream));\n+        assertEquals(1, tree.read(stream));\n+        assertEquals(2, tree.read(stream));\n+        assertEquals(3, tree.read(stream));\n+        assertEquals(4, tree.read(stream));\n+        assertEquals(5, tree.read(stream));\n+        assertEquals(6, tree.read(stream));\n+        assertEquals(7, tree.read(stream));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/BitStreamTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.ByteArrayInputStream;\n+\n+import junit.framework.TestCase;\n+\n+public class BitStreamTest extends TestCase {\n+\n+    public void testEmptyStream() throws Exception {\n+        BitStream stream = new BitStream(new ByteArrayInputStream(new byte[0]));\n+        assertEquals(\"next bit\", -1, stream.nextBit());\n+        assertEquals(\"next bit\", -1, stream.nextBit());\n+        assertEquals(\"next bit\", -1, stream.nextBit());\n+    }\n+\n+    public void testStream() throws Exception {\n+        BitStream stream = new BitStream(new ByteArrayInputStream(new byte[] { (byte) 0xEA, 0x03 }));\n+\n+        assertEquals(\"bit 0\", 0, stream.nextBit());\n+        assertEquals(\"bit 1\", 1, stream.nextBit());\n+        assertEquals(\"bit 2\", 0, stream.nextBit());\n+        assertEquals(\"bit 3\", 1, stream.nextBit());\n+        assertEquals(\"bit 4\", 0, stream.nextBit());\n+        assertEquals(\"bit 5\", 1, stream.nextBit());\n+        assertEquals(\"bit 6\", 1, stream.nextBit());\n+        assertEquals(\"bit 7\", 1, stream.nextBit());\n+\n+        assertEquals(\"bit 8\", 1, stream.nextBit());\n+        assertEquals(\"bit 9\", 1, stream.nextBit());\n+        assertEquals(\"bit 10\", 0, stream.nextBit());\n+        assertEquals(\"bit 11\", 0, stream.nextBit());\n+        assertEquals(\"bit 12\", 0, stream.nextBit());\n+        assertEquals(\"bit 13\", 0, stream.nextBit());\n+        assertEquals(\"bit 14\", 0, stream.nextBit());\n+        assertEquals(\"bit 15\", 0, stream.nextBit());\n+        \n+        assertEquals(\"next bit\", -1, stream.nextBit());\n+    }\n+\n+    public void testNextByteFromEmptyStream() throws Exception {\n+        BitStream stream = new BitStream(new ByteArrayInputStream(new byte[0]));\n+        assertEquals(\"next byte\", -1, stream.nextByte());\n+        assertEquals(\"next byte\", -1, stream.nextByte());\n+    }\n+\n+    public void testReadAlignedBytes() throws Exception {\n+        BitStream stream = new BitStream(new ByteArrayInputStream(new byte[] { (byte) 0xEA, 0x35 }));\n+        assertEquals(\"next byte\", 0xEA, stream.nextByte());\n+        assertEquals(\"next byte\", 0x35, stream.nextByte());\n+        assertEquals(\"next byte\", -1, stream.nextByte());\n+    }\n+\n+    public void testNextByte() throws Exception {\n+        BitStream stream = new BitStream(new ByteArrayInputStream(new byte[] { (byte) 0xEA, 0x35 }));\n+        assertEquals(\"bit 0\", 0, stream.nextBit());\n+        assertEquals(\"bit 1\", 1, stream.nextBit());\n+        assertEquals(\"bit 2\", 0, stream.nextBit());\n+        assertEquals(\"bit 3\", 1, stream.nextBit());\n+        \n+        assertEquals(\"next byte\", 0x5E, stream.nextByte());\n+        assertEquals(\"next byte\", -1, stream.nextByte()); // not enough bits left to read a byte\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/CircularBufferTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import junit.framework.TestCase;\n+\n+public class CircularBufferTest extends TestCase {\n+\n+    public void testPutAndGet() throws Exception {\n+        int size = 16;\n+        CircularBuffer buffer = new CircularBuffer(size);\n+        for (int i = 0; i < size / 2; i++) {\n+            buffer.put(i);\n+        }\n+\n+        assertTrue(\"available\", buffer.available());\n+\n+        for (int i = 0; i < size / 2; i++) {\n+            assertEquals(\"buffer[\" + i + \"]\", i, buffer.get());\n+        }\n+\n+        assertEquals(-1, buffer.get());\n+        assertFalse(\"available\", buffer.available());\n+    }\n+\n+    public void testCopy() throws Exception {\n+        CircularBuffer buffer = new CircularBuffer(16);\n+        \n+        buffer.put(1);\n+        buffer.put(2);\n+        buffer.get();\n+        buffer.get();\n+        \n+        // copy uninitialized data\n+        buffer.copy(6, 8);\n+        \n+        for (int i = 2; i < 6; i++) {\n+            assertEquals(\"buffer[\" + i + \"]\", 0, buffer.get());\n+        }\n+        assertEquals(\"buffer[\" + 6 + \"]\", 1, buffer.get());\n+        assertEquals(\"buffer[\" + 7 + \"]\", 2, buffer.get());\n+        assertEquals(\"buffer[\" + 8 + \"]\", 0, buffer.get());\n+        assertEquals(\"buffer[\" + 9 + \"]\", 0, buffer.get());\n+        \n+        for (int i = 10; i < 14; i++) {\n+            buffer.put(i);\n+            buffer.get();\n+        }\n+        \n+        assertFalse(\"available\", buffer.available());\n+        \n+        // copy data and wrap\n+        buffer.copy(2, 8);\n+        \n+        for (int i = 14; i < 18; i++) {\n+            assertEquals(\"buffer[\" + i + \"]\", i % 2 == 0 ? 12 : 13, buffer.get());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ExplodeSupportTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.CheckedOutputStream;\n+\n+import junit.framework.TestCase;\n+import org.apache.commons.compress.utils.BoundedInputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+\n+public class ExplodeSupportTest extends TestCase {\n+\n+    private void testArchiveWithImplodeCompression(String filename, String entryName) throws IOException {\n+        ZipFile zip = new ZipFile(new File(filename));\n+        ZipArchiveEntry entry = zip.getEntries().nextElement();\n+        assertEquals(\"entry name\", entryName, entry.getName());\n+        assertTrue(\"entry can't be read\", zip.canReadEntryData(entry));\n+        assertEquals(\"method\", ZipMethod.IMPLODING.getCode(), entry.getMethod());\n+\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        CheckedOutputStream out = new CheckedOutputStream(bout, new CRC32());\n+        IOUtils.copy(zip.getInputStream(entry), out);\n+\n+        out.flush();\n+\n+        assertEquals(\"CRC32\", entry.getCrc(), out.getChecksum().getValue());\n+    }\n+\n+    public void testArchiveWithImplodeCompression4K2Trees() throws IOException {\n+        testArchiveWithImplodeCompression(\"target/test-classes/archives/imploding-4Kdict-2trees.zip\", \"HEADER.TXT\");\n+    }\n+\n+    public void testArchiveWithImplodeCompression8K3Trees() throws IOException {\n+        testArchiveWithImplodeCompression(\"target/test-classes/archives/imploding-8Kdict-3trees.zip\", \"LICENSE.TXT\");\n+    }\n+\n+    private void testZipStreamWithImplodeCompression(String filename, String entryName) throws IOException {\n+        ZipArchiveInputStream zin = new ZipArchiveInputStream(new FileInputStream(new File(filename)));\n+        ZipArchiveEntry entry = zin.getNextZipEntry();\n+        assertEquals(\"entry name\", entryName, entry.getName());\n+        assertTrue(\"entry can't be read\", zin.canReadEntryData(entry));\n+        assertEquals(\"method\", ZipMethod.IMPLODING.getCode(), entry.getMethod());\n+\n+        InputStream bio = new BoundedInputStream(zin, entry.getSize());\n+        \n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        CheckedOutputStream out = new CheckedOutputStream(bout, new CRC32());\n+        IOUtils.copy(bio, out);\n+\n+        out.flush();\n+\n+        assertEquals(\"CRC32\", entry.getCrc(), out.getChecksum().getValue());\n+    }\n+\n+    public void testZipStreamWithImplodeCompression4K2Trees() throws IOException {\n+        testZipStreamWithImplodeCompression(\"target/test-classes/archives/imploding-4Kdict-2trees.zip\", \"HEADER.TXT\");\n+    }\n+\n+    public void testZipStreamWithImplodeCompression8K3Trees() throws IOException {\n+        testZipStreamWithImplodeCompression(\"target/test-classes/archives/imploding-8Kdict-3trees.zip\", \"LICENSE.TXT\");\n+    }\n+}", "timestamp": 1387469394, "metainfo": ""}