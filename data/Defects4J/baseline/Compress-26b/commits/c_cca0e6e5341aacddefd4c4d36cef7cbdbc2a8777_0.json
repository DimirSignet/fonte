{"sha": "cca0e6e5341aacddefd4c4d36cef7cbdbc2a8777", "log": "just moving stuff around to closer match source code layout of libbzip2 1.0.6  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BlockSort.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BlockSort.java\n      * algorithm.\n      */\n \n-    private static final int SETMASK = (1 << 21);\n-    private static final int CLEARMASK = (~SETMASK);\n-    private static final int SMALL_THRESH = 20;\n-    private static final int DEPTH_THRESH = 10;\n-    private static final int WORK_FACTOR = 30;\n-\n     /*\n      * LBZ2: If you are ever unlucky/improbable enough to get a stack\n      * overflow whilst sorting, increase the following constant and\n      * elems, so the following limit seems very generous.\n      */\n     private static final int QSORT_STACK_SIZE = 1000;\n+\n+    private boolean blockRandomised;\n+\n+    /*\n+     * Used when sorting. If too many long comparisons happen, we stop sorting,\n+     * randomise the block slightly, and try again.\n+     */\n+    private int workDone;\n+    private int workLimit;\n+    private boolean firstAttempt;\n+\n+    private final int[] stack_ll = new int[QSORT_STACK_SIZE]; // 4000 byte\n+    private final int[] stack_hh = new int[QSORT_STACK_SIZE]; // 4000 byte\n+    private final int[] stack_dd = new int[QSORT_STACK_SIZE]; // 4000 byte\n+\n+    private final int[] mainSort_runningOrder = new int[256]; // 1024 byte\n+    private final int[] mainSort_copy = new int[256]; // 1024 byte\n+    private final boolean[] mainSort_bigDone = new boolean[256]; // 256 byte\n+\n+    private final int[] ftab = new int[65537]; // 262148 byte\n+\n+    /**\n+     * Array instance identical to Data's sfmap, both are used only\n+     * temporarily and indepently, so we do not need to allocate\n+     * additional memory.\n+     */\n+    private final char[] quadrant;\n+\n+    BlockSort(final BZip2CompressorOutputStream.Data data) {\n+        this.quadrant = data.sfmap;\n+    }\n+\n+    boolean blockSort(final BZip2CompressorOutputStream.Data data, final int last) {\n+        this.workLimit = WORK_FACTOR * last;\n+        this.workDone = 0;\n+        this.blockRandomised = false;\n+        this.firstAttempt = true;\n+        mainSort(data, last);\n+\n+        if (this.firstAttempt && (this.workDone > this.workLimit)) {\n+            randomiseBlock(data, last);\n+            this.workLimit = this.workDone = 0;\n+            this.firstAttempt = false;\n+            mainSort(data, last);\n+        }\n+\n+        final int[] fmap = data.fmap;\n+        data.origPtr = -1;\n+        for (int i = 0; i <= last; i++) {\n+            if (fmap[i] == 0) {\n+                data.origPtr = i;\n+                break;\n+            }\n+        }\n+\n+        // assert (data.origPtr != -1) : data.origPtr;\n+        return blockRandomised;\n+    }\n+\n+/*---------------------------------------------*/\n \n     /*\n      * LBZ2: Knuth's increments seem to work better than Incerpi-Sedgewick here.\n     private static final int[] INCS = { 1, 4, 13, 40, 121, 364, 1093, 3280,\n                                         9841, 29524, 88573, 265720, 797161,\n                                         2391484 };\n-\n-    private boolean blockRandomised;\n-\n-    /*\n-     * Used when sorting. If too many long comparisons happen, we stop sorting,\n-     * randomise the block slightly, and try again.\n-     */\n-    private int workDone;\n-    private int workLimit;\n-    private boolean firstAttempt;\n-\n-    private final int[] stack_ll = new int[QSORT_STACK_SIZE]; // 4000 byte\n-    private final int[] stack_hh = new int[QSORT_STACK_SIZE]; // 4000 byte\n-    private final int[] stack_dd = new int[QSORT_STACK_SIZE]; // 4000 byte\n-\n-    private final int[] mainSort_runningOrder = new int[256]; // 1024 byte\n-    private final int[] mainSort_copy = new int[256]; // 1024 byte\n-    private final boolean[] mainSort_bigDone = new boolean[256]; // 256 byte\n-\n-    private final int[] ftab = new int[65537]; // 262148 byte\n-\n-    /**\n-     * Array instance identical to Data's sfmap, both are used only\n-     * temporarily and indepently, so we do not need to allocate\n-     * additional memory.\n-     */\n-    private final char[] quadrant;\n-\n-    BlockSort(final BZip2CompressorOutputStream.Data data) {\n-        this.quadrant = data.sfmap;\n-    }\n-\n-/*---------------------------------------------*/\n-/*--\n-   LBZ2: The following is an implementation of\n-   an elegant 3-way quicksort for strings,\n-   described in a paper \"Fast Algorithms for\n-   Sorting and Searching Strings\", by Robert\n-   Sedgewick and Jon L. Bentley.\n---*/\n \n     /**\n      * This is the most hammered method of this class.\n         return firstAttemptShadow && (workDoneShadow > workLimitShadow);\n     }\n \n+/*--\n+   LBZ2: The following is an implementation of\n+   an elegant 3-way quicksort for strings,\n+   described in a paper \"Fast Algorithms for\n+   Sorting and Searching Strings\", by Robert\n+   Sedgewick and Jon L. Bentley.\n+--*/\n+\n     private static void vswap(int[] fmap, int p1, int p2, int n) {\n         n += p1;\n         while (p1 < n) {\n                                                         : a);\n     }\n \n-    boolean blockSort(final BZip2CompressorOutputStream.Data data, final int last) {\n-        this.workLimit = WORK_FACTOR * last;\n-        this.workDone = 0;\n-        this.blockRandomised = false;\n-        this.firstAttempt = true;\n-        mainSort(data, last);\n-\n-        if (this.firstAttempt && (this.workDone > this.workLimit)) {\n-            randomiseBlock(data, last);\n-            this.workLimit = this.workDone = 0;\n-            this.firstAttempt = false;\n-            mainSort(data, last);\n-        }\n-\n-        final int[] fmap = data.fmap;\n-        data.origPtr = -1;\n-        for (int i = 0; i <= last; i++) {\n-            if (fmap[i] == 0) {\n-                data.origPtr = i;\n-                break;\n-            }\n-        }\n-\n-        // assert (data.origPtr != -1) : data.origPtr;\n-        return blockRandomised;\n-    }\n+    private static final int SMALL_THRESH = 20;\n+    private static final int DEPTH_THRESH = 10;\n+    private static final int WORK_FACTOR = 30;\n \n     /**\n      * Method \"mainQSort3\", file \"blocksort.c\", BZip2 1.0.2\n             }\n         }\n     }\n+\n+    private static final int SETMASK = (1 << 21);\n+    private static final int CLEARMASK = (~SETMASK);\n \n     private void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n                           final int lastShadow) {", "timestamp": 1337522486, "metainfo": ""}