{"sha": "f235f6b0c4c29492406d57ff9a6c630d9414ce68", "log": "Simplify code by using getXXXPadCount() methods Align variable names (was entry and cpioEntry)  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n         return this.entry;\n     }\n \n-    private long skip(final long count, final int border) throws IOException {\n-        long skip = count % border;\n-        if (skip > 0) {\n-            skip = this.in.skip(border - skip);\n-            // TODO - what if not enough bytes are skipped?\n-        }\n-        return skip;\n+    private void skip(int bytes) throws IOException{\n+        final byte[] buff = new byte[4]; // Cannot be more than 3 bytes\n+        if (bytes > 0) {\n+            readFully(buff, 0, bytes);\n+        }\n     }\n \n     /**\n         if (this.entry == null || this.entryEOF) {\n             return -1;\n         }\n-        // N.B. These checks assume format is not 0 - otherwise condition is always true\n         if (this.entryBytesRead == this.entry.getSize()) {\n-            if ((this.entry.getFormat() | FORMAT_NEW_MASK) == FORMAT_NEW_MASK) {\n-                skip(this.entry.getSize(), 4);\n-            } else if ((this.entry.getFormat() | FORMAT_OLD_BINARY) == FORMAT_OLD_BINARY) {\n-                skip(this.entry.getSize(), 2);\n-            } // No need to skip for FORMAT_OLD_ASCII\n+            skip(entry.getDataPadCount());\n             this.entryEOF = true;\n-            if ((this.entry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\n+            if (this.entry.getFormat() == FORMAT_NEW_CRC) {\n                 if (this.crc != this.entry.getChksum()) {\n                     throw new IOException(\"CRC Error\");\n                 }\n             // TODO - change this to throw\n             new IOException(\"Mode 0 only allowed in the trailer. Found: \"+name).printStackTrace();\n         }\n-        skip(ret.getHeaderSize() + namesize, 4);\n+        skip(ret.getHeaderPadCount());\n \n         return ret;\n     }\n         long namesize = readBinaryLong(2, swapHalfWord);\n         ret.setSize(readBinaryLong(4, swapHalfWord));\n         ret.setName(readCString((int) namesize));\n-        skip(ret.getHeaderSize() + namesize, 2);\n+        skip(ret.getHeaderPadCount());\n \n         return ret;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n public class CpioArchiveOutputStream extends ArchiveOutputStream implements\n         CpioConstants {\n \n-    private CpioArchiveEntry cpioEntry;\n+    private CpioArchiveEntry entry;\n \n     private boolean closed = false;\n \n      */\n     public void putNextEntry(final CpioArchiveEntry e) throws IOException {\n         ensureOpen();\n-        if (this.cpioEntry != null) {\n+        if (this.entry != null) {\n             closeArchiveEntry(); // close previous entry\n         }\n         if (e.getTime() == -1) {\n         }\n \n         writeHeader(e);\n-        this.cpioEntry = e;\n+        this.entry = e;\n         this.written = 0;\n     }\n \n         writeAsciiLong(entry.getName().length() + 1, 8, 16);\n         writeAsciiLong(entry.getChksum(), 8, 16);\n         writeCString(entry.getName());\n-        pad(entry.getHeaderSize() + entry.getName().length() + 1, 4);\n+        pad(entry.getHeaderPadCount());\n     }\n \n     private void writeOldAsciiEntry(final CpioArchiveEntry entry)\n         writeBinaryLong(entry.getName().length() + 1, 2, swapHalfWord);\n         writeBinaryLong(entry.getSize(), 4, swapHalfWord);\n         writeCString(entry.getName());\n-        pad(entry.getHeaderSize() + entry.getName().length() + 1, 2);\n+        pad(entry.getHeaderPadCount());\n     }\n \n     /*(non-Javadoc)\n     public void closeArchiveEntry() throws IOException {\n         ensureOpen();\n \n-        if (this.cpioEntry.getSize() != this.written) {\n+        if (this.entry.getSize() != this.written) {\n             throw new IOException(\"invalid entry size (expected \"\n-                    + this.cpioEntry.getSize() + \" but got \" + this.written\n+                    + this.entry.getSize() + \" but got \" + this.written\n                     + \" bytes)\");\n         }\n-        // N.B. These checks assume format is not 0\n-        if ((this.cpioEntry.getFormat() | FORMAT_NEW_MASK) == FORMAT_NEW_MASK) {\n-            pad(this.cpioEntry.getSize(), 4);\n-        } else if ((this.cpioEntry.getFormat() | FORMAT_OLD_BINARY) == FORMAT_OLD_BINARY) {\n-            pad(this.cpioEntry.getSize(), 2);\n-        } // No need to pad for FORMAT_OLD_ASCII\n-        if ((this.cpioEntry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\n-            if (this.crc != this.cpioEntry.getChksum()) {\n+        pad(this.entry.getDataPadCount());\n+        if (this.entry.getFormat() == FORMAT_NEW_CRC) {\n+            if (this.crc != this.entry.getChksum()) {\n                 throw new IOException(\"CRC Error\");\n             }\n         }\n-        this.cpioEntry = null;\n+        this.entry = null;\n         this.crc = 0;\n         this.written = 0;\n     }\n             return;\n         }\n \n-        if (this.cpioEntry == null) {\n+        if (this.entry == null) {\n             throw new IOException(\"no current CPIO entry\");\n         }\n-        if (this.written + len > this.cpioEntry.getSize()) {\n+        if (this.written + len > this.entry.getSize()) {\n             throw new IOException(\"attempt to write past end of STORED entry\");\n         }\n         out.write(b, off, len);\n         this.written += len;\n-        // format is assumed non-zero here, otherwise the condition is always true\n-        if ((this.cpioEntry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\n+        if (this.entry.getFormat() == FORMAT_NEW_CRC) {\n             for (int pos = 0; pos < len; pos++) {\n                 this.crc += b[pos] & 0xFF;\n             }\n         if (this.finished) {\n             return;\n         }\n-        if (this.cpioEntry != null) {\n+        if (this.entry != null) {\n             closeArchiveEntry();\n         }\n-        this.cpioEntry = new CpioArchiveEntry(this.entryFormat);\n-        this.cpioEntry.setName(CPIO_TRAILER);\n-        this.cpioEntry.setNumberOfLinks(1);\n-        writeHeader(this.cpioEntry);\n+        this.entry = new CpioArchiveEntry(this.entryFormat);\n+        this.entry.setName(CPIO_TRAILER);\n+        this.entry.setNumberOfLinks(1);\n+        writeHeader(this.entry);\n         closeArchiveEntry();\n     }\n \n         }\n     }\n \n-    private void pad(final long count, final int border) throws IOException {\n-        long pad = count % border;\n-        if (pad > 0) {\n-            byte tmp[] = new byte[(int) (border - pad)];\n-            out.write(tmp);\n+    private void pad(int count) throws IOException{\n+        if (count > 0){\n+            byte buff[] = new byte[count];\n+            out.write(buff);\n         }\n     }\n ", "timestamp": 1238176263, "metainfo": ""}