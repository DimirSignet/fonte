{"sha": "aa9d0bc38203cdf072f964dfdf5c72f3960d7093", "log": "detect sparse entries in tar and allow users to skip them.  Submitted by Patrick Dreyer.  COMPRESS-145 (forgot to save two buffers, oops)  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n package org.apache.commons.compress.archivers.tar;\n \n import java.io.File;\n+import java.nio.ByteBuffer;\n import java.util.Date;\n import java.util.Locale;\n \n  * New-style GNU tar files are slightly different from the above.\n  * </pre>\n  * \n+ * <p>\n+ * The C structure for a old GNU Tar Entry's header is:\n+ * <pre>\n+ * struct oldgnu_header {\n+ * char unused_pad1[345]; // TarConstants.PAD1LEN_GNU       - offset 0\n+ * char atime[12];        // TarConstants.ATIMELEN_GNU      - offset 345\n+ * char ctime[12];        // TarConstants.CTIMELEN_GNU      - offset 357\n+ * char offset[12];       // TarConstants.OFFSETLEN_GNU     - offset 369\n+ * char longnames[4];     // TarConstants.LONGNAMESLEN_GNU  - offset 381\n+ * char unused_pad2;      // TarConstants.PAD2LEN_GNU       - offset 385\n+ * struct sparse sp[4];   // TarConstants.SPARSELEN_GNU     - offset 386\n+ * char isextended;       // TarConstants.ISEXTENDEDLEN_GNU - offset 482\n+ * char realsize[12];     // TarConstants.REALSIZELEN_GNU   - offset 483\n+ * char unused_pad[17];   // TarConstants.PAD3LEN_GNU       - offset 495\n+ * };\n+ * </pre>\n+ * Whereas, \"struct sparse\" is:\n+ * <pre>\n+ * struct sparse {\n+ * char offset[12];   // offset 0\n+ * char numbytes[12]; // offset 12\n+ * };\n+ * </pre>\n+ *\n  * @NotThreadSafe\n  */\n \n \n     /** The entry's minor device number. */\n     private int devMinor;\n+\n+    /** If an extension sparse header follows. */\n+    private boolean isExtended;\n+\n+    /** The entry's real size in case of a sparse file. */\n+    private long realSize;\n \n     /** The entry's file reference */\n     private File file;\n     public TarArchiveEntry(File file) {\n         this(file, normalizeFileName(file.getPath(), false));\n     }\n-    \n+\n     /**\n      * Construct an entry for a file. File is set to file, and the\n      * header is constructed from information from the file.\n             if (nameLength == 0 || fileName.charAt(nameLength - 1) != '/') {\n                 this.name = fileName + \"/\";\n             } else {\n-                this.name = fileName;                \n+                this.name = fileName;\n             }\n             this.size = 0;\n         } else {\n         this.size = size;\n     }\n \n+    /**\n+     * Indicates in case of a sparse file if an extension sparse header\n+     * follows.\n+     *\n+     * @return true if an extension sparse header follows.\n+     */\n+    public boolean isExtended() {\n+        return isExtended;\n+    }\n+\n+    /**\n+     * Get this entry's real file size in case of a sparse file.\n+     *\n+     * @return This entry's real file size.\n+     */\n+    public long getRealSize() {\n+        return realSize;\n+    }\n+\n+    /**\n+     * Indicate if this entry is a GNU sparse block \n+     *\n+     * @return true if this is a sparse extension provided by GNU tar\n+     */\n+    public boolean isGNUSparse() {\n+        return linkFlag == LF_GNUTYPE_SPARSE;\n+    }\n \n     /**\n      * Indicate if this entry is a GNU long name block\n         offset += DEVLEN;\n         devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n         offset += DEVLEN;\n-        String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n-        // SunOS tar -E does not add / to directory names, so fix up to be consistent\n-        if (isDirectory() && !name.endsWith(\"/\")){\n-            name = name + \"/\";\n-        }\n-        if (prefix.length() >0){\n-            name = prefix + \"/\" + name;\n+\n+        int type = evaluateType(header);\n+        switch (type) {\n+        case FORMAT_OLDGNU: {\n+            offset += ATIMELEN_GNU;\n+            offset += CTIMELEN_GNU;\n+            offset += OFFSETLEN_GNU;\n+            offset += LONGNAMESLEN_GNU;\n+            offset += PAD2LEN_GNU;\n+            offset += SPARSELEN_GNU;\n+            isExtended = TarUtils.parseBoolean(header, offset);\n+            offset += ISEXTENDEDLEN_GNU;\n+            realSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\n+            offset += REALSIZELEN_GNU;\n+            break;\n+        }\n+        case FORMAT_POSIX:\n+        default: {\n+            String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n+            // SunOS tar -E does not add / to directory names, so fix\n+            // up to be consistent\n+            if (isDirectory() && !name.endsWith(\"/\")){\n+                name = name + \"/\";\n+            }\n+            if (prefix.length() > 0){\n+                name = prefix + \"/\" + name;\n+            }\n+        }\n         }\n     }\n \n         }\n         return fileName;\n     }\n+\n+    /**\n+     * Evaluate an entry's header format from a header buffer.\n+     *\n+     * @param header The tar entry header buffer to evaluate the format for.\n+     * @return format type\n+     */\n+    private int evaluateType(byte[] header) {\n+        final ByteBuffer magic = ByteBuffer.wrap(header, MAGIC_OFFSET, MAGICLEN);\n+        if (magic.compareTo(ByteBuffer.wrap(MAGIC_GNU.getBytes())) == 0)\n+            return FORMAT_OLDGNU;\n+        if (magic.compareTo(ByteBuffer.wrap(MAGIC_POSIX.getBytes())) == 0)\n+            return FORMAT_POSIX;\n+        return 0;\n+    }\n }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n             readBuf = null;\n         }\n \n-        byte[] headerBuf = buffer.readRecord();\n-\n-        if (headerBuf == null) {\n-            hasHitEOF = true;\n-        } else if (buffer.isEOFRecord(headerBuf)) {\n-            hasHitEOF = true;\n-        }\n+        byte[] headerBuf = getRecord();\n \n         if (hasHitEOF) {\n             currEntry = null;\n-        } else {\n-            currEntry = new TarArchiveEntry(headerBuf);\n-            entryOffset = 0;\n-            entrySize = currEntry.getSize();\n-        }\n-\n-        if (currEntry != null && currEntry.isGNULongNameEntry()) {\n+            return null;\n+        }\n+\n+        currEntry = new TarArchiveEntry(headerBuf);\n+        entryOffset = 0;\n+        entrySize = currEntry.getSize();\n+\n+        if (currEntry.isGNULongNameEntry()) {\n             // read in the name\n             StringBuffer longName = new StringBuffer();\n             byte[] buf = new byte[SMALL_BUFFER_SIZE];\n             currEntry.setName(longName.toString());\n         }\n \n-        if (currEntry != null && currEntry.isPaxHeader()){ // Process Pax headers\n+        if (currEntry.isPaxHeader()){ // Process Pax headers\n             paxHeaders();\n         }\n \n+        if (currEntry.isGNUSparse()){ // Process sparse files\n+            readGNUSparse();\n+        }\n+\n         return currEntry;\n+    }\n+\n+    /**\n+     * Get the next record in this tar archive. This will skip\n+     * over any remaining data in the current entry, if there\n+     * is one, and place the input stream at the header of the\n+     * next entry.\n+     * If there are no more entries in the archive, null will\n+     * be returned to indicate that the end of the archive has\n+     * been reached.\n+     *\n+     * @return The next header in the archive, or null.\n+     * @throws IOException on error\n+     */\n+    private byte[] getRecord() throws IOException {\n+        if (hasHitEOF) {\n+            return null;\n+        }\n+\n+        byte[] headerBuf = buffer.readRecord();\n+\n+        if (headerBuf == null) {\n+            hasHitEOF = true;\n+        } else if (buffer.isEOFRecord(headerBuf)) {\n+            hasHitEOF = true;\n+        }\n+\n+        return hasHitEOF ? null : headerBuf;\n     }\n \n     private void paxHeaders() throws IOException{\n         }\n     }\n \n+    /**\n+     * Adds the sparse chunks from the current entry to the sparse chunks,\n+     * including any additional sparse entries following the current entry.\n+     * \n+     * @throws IOException on error \n+     * \n+     * @todo Sparse files get not yet really processed. \n+     */\n+    private void readGNUSparse() throws IOException {\n+        /* we do not really process sparse files yet\n+        sparses = new ArrayList();\n+        sparses.addAll(currEntry.getSparses());\n+        */\n+        if (currEntry.isExtended()) {\n+            TarArchiveSparseEntry entry;\n+            do {\n+                byte[] headerBuf = getRecord();\n+                if (hasHitEOF) {\n+                    currEntry = null;\n+                    break;\n+                }\n+                entry = new TarArchiveSparseEntry(headerBuf);\n+                /* we do not really process sparse files yet\n+                sparses.addAll(entry.getSparses());\n+                */\n+            } while (entry.isExtended());\n+        }\n+    }\n+\n     public ArchiveEntry getNextEntry() throws IOException {\n         return getNextTarEntry();\n     }\n         entryOffset += totalRead;\n \n         return totalRead;\n+    }\n+\n+    /**\n+     * Whether this class is able to read the given entry.\n+     *\n+     * <p>May return false if the current entry is a sparse file.</p>\n+     */\n+    public boolean canReadEntryData(ArchiveEntry ae) {\n+        if (ae instanceof TarArchiveEntry) {\n+            TarArchiveEntry te = (TarArchiveEntry) ae;\n+            return !te.isGNUSparse();\n+        }\n+        return false;\n     }\n \n     protected final TarArchiveEntry getCurrentEntry() {", "timestamp": 1311397432, "metainfo": ""}