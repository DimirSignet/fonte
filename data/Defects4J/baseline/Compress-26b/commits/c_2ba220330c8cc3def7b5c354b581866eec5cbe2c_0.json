{"sha": "2ba220330c8cc3def7b5c354b581866eec5cbe2c", "log": "COMPRESS-237 properly write TAR entries with long link names.  Patch by Emmanuel Bourg  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n         TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n         Map<String, String> paxHeaders = new HashMap<String, String>();\n         final String entryName = entry.getName();\n-        final ByteBuffer encodedName = encoding.encode(entryName);\n-        final int nameLen = encodedName.limit() - encodedName.position();\n-        boolean paxHeaderContainsPath = false;\n-        if (nameLen >= TarConstants.NAMELEN) {\n-\n-            if (longFileMode == LONGFILE_POSIX) {\n-                paxHeaders.put(\"path\", entryName);\n-                paxHeaderContainsPath = true;\n-            } else if (longFileMode == LONGFILE_GNU) {\n-                // create a TarEntry for the LongLink, the contents\n-                // of which are the entry's name\n-                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n-                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n-\n-                longLinkEntry.setSize(nameLen + 1); // +1 for NUL\n-                putArchiveEntry(longLinkEntry);\n-                write(encodedName.array(), encodedName.arrayOffset(), nameLen);\n-                write(0); // NUL terminator\n-                closeArchiveEntry();\n-            } else if (longFileMode != LONGFILE_TRUNCATE) {\n-                throw new RuntimeException(\"file name '\" + entryName\n-                                           + \"' is too long ( > \"\n-                                           + TarConstants.NAMELEN + \" bytes)\");\n-            }\n-        }\n+        boolean paxHeaderContainsPath = handleLongName(entryName, paxHeaders, \"path\",\n+                                                       TarConstants.LF_GNUTYPE_LONGNAME);\n+\n+        final String linkName = entry.getLinkName();\n+        boolean paxHeaderContainsLinkPath = linkName != null\n+            && handleLongName(linkName, paxHeaders, \"linkpath\",\n+                              TarConstants.LF_GNUTYPE_LONGLINK);\n \n         if (bigNumberMode == BIGNUMBER_POSIX) {\n             addPaxHeadersForBigNumbers(paxHeaders, entry);\n             paxHeaders.put(\"path\", entryName);\n         }\n \n-        if (addPaxHeadersForNonAsciiNames\n+        if (addPaxHeadersForNonAsciiNames && !paxHeaderContainsLinkPath\n             && (entry.isLink() || entry.isSymbolicLink())\n-            && !ASCII.canEncode(entry.getLinkName())) {\n-            paxHeaders.put(\"linkpath\", entry.getLinkName());\n+            && !ASCII.canEncode(linkName)) {\n+            paxHeaders.put(\"linkpath\", linkName);\n         }\n \n         if (paxHeaders.size() > 0) {\n                                        + maxValue + \" )\");\n         }\n     }\n+\n+    /**\n+     * Handles long file or link names according to the longFileMode setting.\n+     *\n+     * <p>I.e. if the given name is too long to be written to a plain\n+     * tar header then\n+     * <ul>\n+     *   <li>it creates a pax header who's name is given by the\n+     *   paxHeaderName parameter if longFileMode is POSIX</li>\n+     *   <li>it creates a GNU longlink entry who's type is given by\n+     *   the linkType parameter if longFileMode is GNU</li>\n+     *   <li>throws an exception othewise.</li>\n+     * </ul></p>\n+     *\n+     * @param name the name to write\n+     * @param paxHeaders current map of pax headers\n+     * @param paxHeaderName name of the pax header to write\n+     * @param linkType type of the GNU entry to write\n+     * @return whether a pax header has been written.\n+     */\n+    private boolean handleLongName(String name,\n+                                   Map<String, String> paxHeaders,\n+                                   String paxHeaderName, byte linkType)\n+        throws IOException {\n+        final ByteBuffer encodedName = encoding.encode(name);\n+        final int len = encodedName.limit() - encodedName.position();\n+        if (len >= TarConstants.NAMELEN) {\n+\n+            if (longFileMode == LONGFILE_POSIX) {\n+                paxHeaders.put(paxHeaderName, name);\n+                return true;\n+            } else if (longFileMode == LONGFILE_GNU) {\n+                // create a TarEntry for the LongLink, the contents\n+                // of which are the link's name\n+                TarArchiveEntry longLinkEntry =\n+                    new TarArchiveEntry(TarConstants.GNU_LONGLINK, linkType);\n+\n+                longLinkEntry.setSize(len + 1); // +1 for NUL\n+                putArchiveEntry(longLinkEntry);\n+                write(encodedName.array(), encodedName.arrayOffset(), len);\n+                write(0); // NUL terminator\n+                closeArchiveEntry();\n+            } else if (longFileMode != LONGFILE_TRUNCATE) {\n+                throw new RuntimeException(paxHeaderName + \" '\" + name\n+                                           + \"' is too long ( > \"\n+                                           + TarConstants.NAMELEN + \" bytes)\");\n+            }\n+        }\n+        return false;\n+    }\n }", "timestamp": 1376031078, "metainfo": ""}