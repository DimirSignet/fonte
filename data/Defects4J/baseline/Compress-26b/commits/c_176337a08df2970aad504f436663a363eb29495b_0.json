{"sha": "176337a08df2970aad504f436663a363eb29495b", "log": "Javadoc improvements submitted by Christian Grobmeier, SANDBOX-305  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n /**\n  * A cpio archive consists of a sequence of files. There are several types of\n  * headers defided in two categories of new and old format. The headers are\n- * recognized by magic numbers: \"070701\" ascii for \"new\" portable format\n- * \"070702\" ascii for \"new\" portable format with CRC format \"070707\" ascii for\n- * old ascii \"070707\" short for old binary CPIO 2.5 knows also about tar, but it\n- * is not recognized here.\n- * \n- * OLD FORMAT: Each file has a 76(ascii)/26(binary) byte header, a variable\n- * length, NUL terminated filename, and variable length file data. A header for\n- * a filename \"TRAILER!!!\" indicates the end of the archive.\n- * \n- * All the fields in the header are ISO 646 (approximately ASCII) strings of\n- * octal numbers, left padded, not NUL terminated.\n- * \n- * Field Name Length in Bytes Notes ASCII / BINARY c_magic 6 / 2 c_dev 6 / 2\n- * Device that contains a directory entry for this file c_ino 6 / 2 I-node\n- * number that identifies the input file to the file system c_mode 6 / 2 Mode of\n- * the input file c_uid 6 / 2 User ID of the owner of the input file c_gid 6 / 2\n- * Group ID of the owner of the input file c_nlink 6 / 2 Number of links that\n- * are connected to the input file c_rdev 6 / 2 ID of the remote device from\n- * which the input file is taken only valid for chr and blk special files\n- * c_mtime 11 / 4 Time when data was last modified. For remote files, this field\n- * contains the time at the server c_namesize 6 / 2 Length of the path name,\n- * including the terminating null byte c_filesize 11 / 4 Length of the file in\n- * bytes. This is the length of the data section that follows the header\n- * structure. Must be 0 for FIFOs and directories\n- * \n- * Special files, directories, and the trailer are recorded with the h_filesize\n- * field equal to 0.\n- * \n- * NEW FORMAT: Each file has a 110 byte header, a variable length, NUL\n- * terminated filename, and variable length file data. A header for a filename\n- * \"TRAILER!!!\" indicates the end of the archive. All the fields in the header\n- * are ISO 646 (approximately ASCII) strings of hexadecimal numbers, left\n- * padded, not NUL terminated.\n- * \n- * Field Name Length in Bytes Notes c_magic 6 c_ino 8 c_mode 8 c_uid 8 c_gid 8\n- * c_nlink 8 c_mtime 8 c_filesize 8 must be 0 for FIFOs and directories c_maj 8\n- * c_min 8 c_rmaj 8 only valid for chr and blk special files c_rmin 8 only valid\n- * for chr and blk special files c_namesize 8 count includes terminating NUL in\n- * pathname c_chksum 8 0 for \"new\" portable format; for CRC format the sum of\n- * all the bytes in the file\n- * \n- * This class uses mutable fields and is not considered to be threadsafe.\n- * \n- * based on code from the jRPM project (jrpm.sourceforge.net)\n+ * recognized by magic numbers:\n+ * \n+ * <ul>\n+ * <li>\"070701\" ASCII for new portable format</li>\n+ * <li>\"070702\" ASCII for new portable format with CRC format</li>\n+ * <li>\"070707\" ASCII for old ascii (also known as Portable ASCII, odc or old\n+ * character format</li>\n+ * <li>\"070707\" ASCII for old binary</li>\n+ * </ul>\n+ * \n+ * <p>The old binary format is limited to 16 bits for user id, group\n+ * id, device, and inode numbers. It is limited to 4 gigabyte file\n+ * sizes.\n+ * \n+ * The old ASCII format is limited to 18 bits for the user id, group\n+ * id, device, and inode numbers. It is limited to 8 gigabyte file\n+ * sizes.\n+ * \n+ * The new ASCII format is limited to 4 gigabyte file sizes.\n+ * \n+ * CPIO 2.5 knows also about tar, but it is not recognized here.</p>\n+ * \n+ * \n+ * <h3>OLD FORMAT</h3>\n+ * \n+ * <p>Each file has a 76 (ascii) / 26 (binary) byte header, a variable\n+ * length, NUL terminated filename, and variable length file data. A\n+ * header for a filename \"TRAILER!!!\" indicates the end of the\n+ * archive.</p>\n+ * \n+ * <p>All the fields in the header are ISO 646 (approximately ASCII)\n+ * strings of octal numbers, left padded, not NUL terminated.</p>\n+ * \n+ * <pre>\n+ * FIELDNAME        NOTES \n+ * c_magic          The integer value octal 070707.  This value can be used to deter-\n+ *                  mine whether this archive is written with little-endian or big-\n+ *                  endian integers.\n+ * c_dev            Device that contains a directory entry for this file \n+ * c_ino            I-node number that identifies the input file to the file system \n+ * c_mode           The mode specifies both the regular permissions and the file type.\n+ * c_uid            Numeric User ID of the owner of the input file \n+ * c_gid            Numeric Group ID of the owner of the input file \n+ * c_nlink          Number of links that are connected to the input file \n+ * c_rdev           For block special and character special entries, this field \n+ *                  contains the associated device number.  For all other entry types,\n+ *                  it should be set to zero by writers and ignored by readers.\n+ * c_mtime[2]       Modification time of the file, indicated as the number of seconds\n+ *                  since the start of the epoch, 00:00:00 UTC January 1, 1970.  The\n+ *                  four-byte integer is stored with the most-significant 16 bits\n+ *                  first followed by the least-significant 16 bits.  Each of the two\n+ *                  16 bit values are stored in machine-native byte order.\n+ * c_namesize       Length of the path name, including the terminating null byte \n+ * c_filesize[2]    Length of the file in bytes. This is the length of the data \n+ *                  section that follows the header structure. Must be 0 for \n+ *                  FIFOs and directories\n+ *               \n+ * All fields are unsigned short fields with 16-bit integer values\n+ * </pre>\n+ * \n+ * <p>Special files, directories, and the trailer are recorded with\n+ * the h_filesize field equal to 0.</p>\n+ * \n+ * \n+ * <h3>NEW FORMAT</h3>\n+ * \n+ * <p>Each file has a 110 byte header, a variable length, NUL\n+ * terminated filename, and variable length file data. A header for a\n+ * filename \"TRAILER!!!\" indicates the end of the archive. All the\n+ * fields in the header are ISO 646 (approximately ASCII) strings of\n+ * hexadecimal numbers, left padded, not NUL terminated.</p>\n+ * \n+ * <pre>\n+ * FIELDNAME        NOTES \n+ * c_magic[6]       The string 070701 for new ASCII, the string 070702 for new ASCII with CRC\n+ * c_ino[8]\n+ * c_mode[8]\n+ * c_uid[8]\n+ * c_gid[8]\n+ * c_nlink[8]\n+ * c_mtim[8]\n+ * c_filesize[8]    must be 0 for FIFOs and directories \n+ * c_maj[8]\n+ * c_min[8] \n+ * c_rmaj[8]        only valid for chr and blk special files \n+ * c_rmin[8]        only valid for chr and blk special files \n+ * c_namesize[8]    count includes terminating NUL in pathname \n+ * c_check[8]       0 for \"new\" portable format; for CRC format\n+ *                  the sum of all the bytes in the file\n+ * </pre>\n+ * \n+ * <p>New ASCII Format The \"new\" ASCII format uses 8-byte hexadecimal\n+ * fields for all numbers and separates device numbers into separate\n+ * fields for major and minor numbers.</p>\n+ * \n+ * <p>The pathname is followed by NUL bytes so that the total size of\n+ * the fixed header plus pathname is a multiple of four. Likewise, the\n+ * file data is padded to a multiple of four bytes.</p>\n+ * \n+ * <p>This class uses mutable fields and is not considered to be\n+ * threadsafe.</p>\n+ * \n+ * <p>Based on code from the jRPM project (http://jrpm.sourceforge.net).\n+ *\n+ * @see http://people.freebsd.org/~kientzle/libarchive/man/cpio.5.txt\n  */\n public class CpioArchiveEntry implements CpioConstants, ArchiveEntry {\n \n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n  * specified by the entry.\n  * <p/>\n  * <code><pre>\n- * CPIOArchiveInputStream cpioIn = new CPIOArchiveInputStream(new BufferedInputStream(\n- *         new FileInputStream(new File(&quot;test.cpio&quot;))));\n+ * CPIOArchiveInputStream cpioIn = new CPIOArchiveInputStream(\n+ *         new FileInputStream(new File(&quot;test.cpio&quot;)));\n  * CPIOArchiveEntry cpioEntry;\n  * <p/>\n  * while ((cpioEntry = cpioIn.getNextEntry()) != null) {\n  * \n  * This class uses mutable fields and is not considered to be threadsafe.\n  * \n- * based on code from the jRPM project (jrpm.sourceforge.net)\n+ * Based on code from the jRPM project (jrpm.sourceforge.net)\n  */\n \n public class CpioArchiveInputStream extends ArchiveInputStream implements\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n import org.apache.commons.compress.archivers.ArchiveOutputStream;\n \n /**\n- * CPIOArchiveOutputStream is a stream for writting cpio streams. All formats of\n- * cpio are supported (old ascii, old binary, new portable format and the new\n- * portable format with crc).\n+ * CPIOArchiveOutputStream is a stream for writing CPIO streams. All formats of\n+ * CPIO are supported (old ASCII, old binary, new portable format and the new\n+ * portable format with CRC).\n  * <p/>\n  * <p/>\n- * An entry can be written by creating an instance of CPIOArchiveEntry and fill\n- * it with the necessary values and put it into the cpio stream. Afterwards\n- * write the contents of the file into the cpio stream. Either close the stream\n+ * An entry can be written by creating an instance of CpioArchiveEntry and fill\n+ * it with the necessary values and put it into the CPIO stream. Afterwards\n+ * write the contents of the file into the CPIO stream. Either close the stream\n  * by calling finish() or put a next entry into the cpio stream.\n  * <p/>\n  * <code><pre>\n- * CPIOArchiveOutputStream cpioOut = new CPIOArchiveOutputStream(new BufferedOutputStream(\n- *         new FileOutputStream(new File(&quot;test.cpio&quot;))));\n- * CPIOArchiveEntry cpioEntry = new CPIOArchiveEntry();\n- * cpioEntry.setName(&quot;testfile&quot;);\n- * String testContents = &quot;12345&quot;;\n- * cpioEntry.setFileSize(testContents.length());\n- * cpioOut.putNextEntry(cpioEntry);\n- * cpioOut.write(testContents.getBytes());\n- * cpioOut.finish();\n- * cpioOut.close();\n+ * CpioArchiveOutputStream out = new CpioArchiveOutputStream(\n+ *         new FileOutputStream(new File(&quot;test.cpio&quot;)));\n+ * CpioArchiveEntry entry = new CpioArchiveEntry();\n+ * entry.setName(&quot;testfile&quot;);\n+ * String contents = &quot;12345&quot;;\n+ * entry.setFileSize(contents.length());\n+ * out.putNextEntry(entry);\n+ * out.write(testContents.getBytes());\n+ * out.finish();\n+ * out.close();\n  * </pre></code>\n  * <p/>\n  * Note: This implementation should be compatible to cpio 2.5", "timestamp": 1237799450, "metainfo": ""}