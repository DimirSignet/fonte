{"sha": "ab9ebfc83e6e741b1a4296c4c651ac2798f467f7", "log": "applied patch by Christian Grobmeier  updated zip support  https://issues.apache.org/jira/browse/SANDBOX-248    ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/AsiExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/AsiExtraField.java\n import java.util.zip.ZipException;\n \n /**\n- * Adds Unix file permission and UID/GID fields as well as symbolic link\n- * handling. <p>\n- *\n- * This class uses the ASi extra field in the format: <pre>\n+ * Adds Unix file permission and UID/GID fields as well as symbolic\n+ * link handling.\n+ *\n+ * <p>This class uses the ASi extra field in the format:\n+ * <pre>\n  *         Value         Size            Description\n  *         -----         ----            -----------\n  * (Unix3) 0x756e        Short           tag for this extra block type\n  *         UID           Short           user ID\n  *         GID           Short           group ID\n  *         (var.)        variable        symbolic link filename\n- * </pre> taken from appnote.iz (Info-ZIP note, 981119) found at <a\n- * href=\"ftp://ftp.uu.net/pub/archiving/zip/doc/\">\n- * ftp://ftp.uu.net/pub/archiving/zip/doc/</a> </p> <p>\n- *\n- * Short is two bytes and Long is four bytes in big endian byte and word order,\n- * device numbers are currently not supported.</p>\n+ * </pre>\n+ * taken from appnote.iz (Info-ZIP note, 981119) found at <a\n+ * href=\"ftp://ftp.uu.net/pub/archiving/zip/doc/\">ftp://ftp.uu.net/pub/archiving/zip/doc/</a></p>\n+\n+ *\n+ * <p>Short is two bytes and Long is four bytes in big endian byte and\n+ * word order, device numbers are currently not supported.</p>\n+ *\n  */\n-public class AsiExtraField\n-    implements ZipExtraField, UnixStat, Cloneable\n-{\n-    private static final ZipShort HEADER_ID = new ZipShort( 0x756E );\n-\n+public class AsiExtraField implements ZipExtraField, UnixStat, Cloneable {\n+\n+    private static final ZipShort HEADER_ID = new ZipShort(0x756E);\n+    private static final int      WORD = 4;\n     /**\n      * Standard Unix stat(2) file mode.\n      *\n      * @since 1.1\n      */\n-    private int m_mode;\n-\n+    private int mode = 0;\n     /**\n      * User ID.\n      *\n      * @since 1.1\n      */\n-    private int m_uid;\n-\n+    private int uid = 0;\n     /**\n      * Group ID.\n      *\n      * @since 1.1\n      */\n-    private int m_gid;\n-\n-    /**\n-     * File this entry points to, if it is a symbolic link. <p>\n-     *\n-     * empty string - if entry is not a symbolic link.</p>\n-     *\n-     * @since 1.1\n-     */\n-    private String m_link = \"\";\n-\n+    private int gid = 0;\n+    /**\n+     * File this entry points to, if it is a symbolic link.\n+     *\n+     * <p>empty string - if entry is not a symbolic link.</p>\n+     *\n+     * @since 1.1\n+     */\n+    private String link = \"\";\n     /**\n      * Is this an entry for a directory?\n      *\n      * @since 1.1\n      */\n-    private boolean m_dirFlag;\n+    private boolean dirFlag = false;\n \n     /**\n      * Instance used to calculate checksums.\n      *\n      * @since 1.1\n      */\n-    private CRC32 m_crc = new CRC32();\n+    private CRC32 crc = new CRC32();\n+\n+    /** Constructor for AsiExtraField. */\n+    public AsiExtraField() {\n+    }\n+\n+    /**\n+     * The Header-ID.\n+     * @return the value for the header id for this extrafield\n+     * @since 1.1\n+     */\n+    public ZipShort getHeaderId() {\n+        return HEADER_ID;\n+    }\n+\n+    /**\n+     * Length of the extra field in the local file data - without\n+     * Header-ID or length specifier.\n+     * @return a <code>ZipShort</code> for the length of the data of this extra field\n+     * @since 1.1\n+     */\n+    public ZipShort getLocalFileDataLength() {\n+        return new ZipShort(WORD         // CRC\n+                          + 2         // Mode\n+                          + WORD         // SizDev\n+                          + 2         // UID\n+                          + 2         // GID\n+                          + getLinkedFile().getBytes().length);\n+    }\n+\n+    /**\n+     * Delegate to local file data.\n+     * @return the centralDirectory length\n+     * @since 1.1\n+     */\n+    public ZipShort getCentralDirectoryLength() {\n+        return getLocalFileDataLength();\n+    }\n+\n+    /**\n+     * The actual data to put into local file data - without Header-ID\n+     * or length specifier.\n+     * @return get the data\n+     * @since 1.1\n+     */\n+    public byte[] getLocalFileDataData() {\n+        // CRC will be added later\n+        byte[] data = new byte[getLocalFileDataLength().getValue() - WORD];\n+        System.arraycopy(ZipShort.getBytes(getMode()), 0, data, 0, 2);\n+\n+        byte[] linkArray = getLinkedFile().getBytes();\n+        // CheckStyle:MagicNumber OFF\n+        System.arraycopy(ZipLong.getBytes(linkArray.length),\n+                         0, data, 2, WORD);\n+\n+        System.arraycopy(ZipShort.getBytes(getUserId()),\n+                         0, data, 6, 2);\n+        System.arraycopy(ZipShort.getBytes(getGroupId()),\n+                         0, data, 8, 2);\n+\n+        System.arraycopy(linkArray, 0, data, 10, linkArray.length);\n+        // CheckStyle:MagicNumber ON\n+\n+        crc.reset();\n+        crc.update(data);\n+        long checksum = crc.getValue();\n+\n+        byte[] result = new byte[data.length + WORD];\n+        System.arraycopy(ZipLong.getBytes(checksum), 0, result, 0, WORD);\n+        System.arraycopy(data, 0, result, WORD, data.length);\n+        return result;\n+    }\n+\n+    /**\n+     * Delegate to local file data.\n+     * @return the local file data\n+     * @since 1.1\n+     */\n+    public byte[] getCentralDirectoryData() {\n+        return getLocalFileDataData();\n+    }\n+\n+    /**\n+     * Set the user id.\n+     * @param uid the user id\n+     * @since 1.1\n+     */\n+    public void setUserId(int uid) {\n+        this.uid = uid;\n+    }\n+\n+    /**\n+     * Get the user id.\n+     * @return the user id\n+     * @since 1.1\n+     */\n+    public int getUserId() {\n+        return uid;\n+    }\n+\n+    /**\n+     * Set the group id.\n+     * @param gid the group id\n+     * @since 1.1\n+     */\n+    public void setGroupId(int gid) {\n+        this.gid = gid;\n+    }\n+\n+    /**\n+     * Get the group id.\n+     * @return the group id\n+     * @since 1.1\n+     */\n+    public int getGroupId() {\n+        return gid;\n+    }\n+\n+    /**\n+     * Indicate that this entry is a symbolic link to the given filename.\n+     *\n+     * @param name Name of the file this entry links to, empty String\n+     *             if it is not a symbolic link.\n+     *\n+     * @since 1.1\n+     */\n+    public void setLinkedFile(String name) {\n+        link = name;\n+        mode = getMode(mode);\n+    }\n+\n+    /**\n+     * Name of linked file\n+     *\n+     * @return name of the file this entry links to if it is a\n+     *         symbolic link, the empty string otherwise.\n+     *\n+     * @since 1.1\n+     */\n+    public String getLinkedFile() {\n+        return link;\n+    }\n+\n+    /**\n+     * Is this entry a symbolic link?\n+     * @return true if this is a symbolic link\n+     * @since 1.1\n+     */\n+    public boolean isLink() {\n+        return getLinkedFile().length() != 0;\n+    }\n+\n+    /**\n+     * File mode of this file.\n+     * @param mode the file mode\n+     * @since 1.1\n+     */\n+    public void setMode(int mode) {\n+        this.mode = getMode(mode);\n+    }\n+\n+    /**\n+     * File mode of this file.\n+     * @return the file mode\n+     * @since 1.1\n+     */\n+    public int getMode() {\n+        return mode;\n+    }\n \n     /**\n      * Indicate whether this entry is a directory.\n-     *\n-     * @param dirFlag The new Directory value\n-     * @since 1.1\n-     */\n-    public void setDirectory( final boolean dirFlag )\n-    {\n-        m_dirFlag = dirFlag;\n-        m_mode = getMode( m_mode );\n-    }\n-\n-    /**\n-     * Set the group id.\n-     *\n-     * @param gid The new GroupId value\n-     * @since 1.1\n-     */\n-    public void setGroupId( int gid )\n-    {\n-        m_gid = gid;\n-    }\n-\n-    /**\n-     * Indicate that this entry is a symbolic link to the given filename.\n-     *\n-     * @param name Name of the file this entry links to, empty String if it is\n-     *      not a symbolic link.\n-     * @since 1.1\n-     */\n-    public void setLinkedFile( final String name )\n-    {\n-        m_link = name;\n-        m_mode = getMode( m_mode );\n-    }\n-\n-    /**\n-     * File mode of this file.\n-     *\n-     * @param mode The new Mode value\n-     * @since 1.1\n-     */\n-    public void setMode( final int mode )\n-    {\n-        m_mode = getMode( mode );\n-    }\n-\n-    /**\n-     * Set the user id.\n-     *\n-     * @param uid The new UserId value\n-     * @since 1.1\n-     * @deprecated Use setUserID(int)\n-     * @see #setUserID(int)\n-     */\n-    public void setUserId( final int uid )\n-    {\n-        m_uid = uid;\n-    }\n-\n-    /**\n-     * Set the user id.\n-     *\n-     * @param uid The new UserId value\n-     */\n-    public void setUserID( final int uid )\n-    {\n-        m_uid = uid;\n-    }\n-\n-    /**\n-     * Delegate to local file data.\n-     *\n-     * @return The CentralDirectoryData value\n-     * @since 1.1\n-     */\n-    public byte[] getCentralDirectoryData()\n-    {\n-        return getLocalFileDataData();\n-    }\n-\n-    /**\n-     * Delegate to local file data.\n-     *\n-     * @return The CentralDirectoryLength value\n-     * @since 1.1\n-     */\n-    public ZipShort getCentralDirectoryLength()\n-    {\n-        return getLocalFileDataLength();\n-    }\n-\n-    /**\n-     * Get the group id.\n-     *\n-     * @return The GroupId value\n-     * @since 1.1\n-     */\n-    public int getGroupID()\n-    {\n-        return m_gid;\n-    }\n-\n-    /**\n-     * Get the group id.\n-     *\n-     * @return The GroupId value\n-     * @since 1.1\n-     * @deprecated Use getGroupID() instead\n-     * @see #getGroupID()\n-     */\n-    public int getGroupId()\n-    {\n-        return m_gid;\n-    }\n-\n-    /**\n-     * The Header-ID.\n-     *\n-     * @return The HeaderId value\n-     * @since 1.1\n-     */\n-    public ZipShort getHeaderID()\n-    {\n-        return HEADER_ID;\n-    }\n-\n-    /**\n-     * Name of linked file\n-     *\n-     * @return name of the file this entry links to if it is a symbolic link,\n-     *      the empty string otherwise.\n-     * @since 1.1\n-     */\n-    public String getLinkedFile()\n-    {\n-        return m_link;\n-    }\n-\n-    /**\n-     * The actual data to put into local file data - without Header-ID or length\n-     * specifier.\n-     *\n-     * @return The LocalFileDataData value\n-     * @since 1.1\n-     */\n-    public byte[] getLocalFileDataData()\n-    {\n-        // CRC will be added later\n-        byte[] data = new byte[ getLocalFileDataLength().getValue() - 4 ];\n-        System.arraycopy( ( new ZipShort( getMode() ) ).getBytes(), 0, data, 0, 2 );\n-\n-        byte[] linkArray = getLinkedFile().getBytes();\n-        System.arraycopy( ( new ZipLong( linkArray.length ) ).getBytes(),\n-                          0, data, 2, 4 );\n-\n-        System.arraycopy( ( new ZipShort( getUserID() ) ).getBytes(),\n-                          0, data, 6, 2 );\n-        System.arraycopy( ( new ZipShort( getGroupID() ) ).getBytes(),\n-                          0, data, 8, 2 );\n-\n-        System.arraycopy( linkArray, 0, data, 10, linkArray.length );\n-\n-        m_crc.reset();\n-        m_crc.update( data );\n-        long checksum = m_crc.getValue();\n-\n-        byte[] result = new byte[ data.length + 4 ];\n-        System.arraycopy( ( new ZipLong( checksum ) ).getBytes(), 0, result, 0, 4 );\n-        System.arraycopy( data, 0, result, 4, data.length );\n-        return result;\n-    }\n-\n-    /**\n-     * Length of the extra field in the local file data - without Header-ID or\n-     * length specifier.\n-     *\n-     * @return The LocalFileDataLength value\n-     * @since 1.1\n-     */\n-    public ZipShort getLocalFileDataLength()\n-    {\n-        return new ZipShort( 4 + // CRC\n-                             2 + // Mode\n-                             4 + // SizDev\n-                             2 + // UID\n-                             2 + // GID\n-                             getLinkedFile().getBytes().length );\n-    }\n-\n-    /**\n-     * File mode of this file.\n-     *\n-     * @return The Mode value\n-     * @since 1.1\n-     */\n-    public int getMode()\n-    {\n-        return m_mode;\n-    }\n-\n-    /**\n-     * Get the user id.\n-     *\n-     * @return The UserId value\n-     * @since 1.1\n-     * @deprecated Use getUserID()\n-     * @see #getUserID()\n-     */\n-    public int getUserId()\n-    {\n-        return m_uid;\n-    }\n-\n-    /**\n-     * Get the user id.\n-     *\n-     * @return The UserID value\n-     */\n-    public int getUserID()\n-    {\n-        return m_uid;\n+     * @param dirFlag if true, this entry is a directory\n+     * @since 1.1\n+     */\n+    public void setDirectory(boolean dirFlag) {\n+        this.dirFlag = dirFlag;\n+        mode = getMode(mode);\n     }\n \n     /**\n      * Is this entry a directory?\n-     *\n-     * @return The Directory value\n-     * @since 1.1\n-     */\n-    public boolean isDirectory()\n-    {\n-        return m_dirFlag && !isLink();\n-    }\n-\n-    /**\n-     * Is this entry a symbolic link?\n-     *\n-     * @return The Link value\n-     * @since 1.1\n-     */\n-    public boolean isLink()\n-    {\n-        return getLinkedFile().length() != 0;\n+     * @return true if this entry is a directory\n+     * @since 1.1\n+     */\n+    public boolean isDirectory() {\n+        return dirFlag && !isLink();\n     }\n \n     /**\n      * Populate data from this array as if it was in local file data.\n-     *\n-     * @param buffer the buffer\n-     * @param offset the offset into buffer\n-     * @param length the length of data in buffer\n+     * @param data an array of bytes\n+     * @param offset the start offset\n+     * @param length the number of bytes in the array from offset\n+     * @since 1.1\n      * @throws ZipException on error\n-     * @since 1.1\n-     */\n-    public void parseFromLocalFileData( final byte[] buffer,\n-                                        final int offset,\n-                                        final int length )\n-        throws ZipException\n-    {\n-\n-        long givenChecksum = ( new ZipLong( buffer, offset ) ).getValue();\n-        byte[] tmp = new byte[ length - 4 ];\n-        System.arraycopy( buffer, offset + 4, tmp, 0, length - 4 );\n-        m_crc.reset();\n-        m_crc.update( tmp );\n-        long realChecksum = m_crc.getValue();\n-        if( givenChecksum != realChecksum )\n-        {\n-            throw new ZipException( \"bad CRC checksum \" + Long.toHexString( givenChecksum ) +\n-                                    \" instead of \" + Long.toHexString( realChecksum ) );\n+     */\n+    public void parseFromLocalFileData(byte[] data, int offset, int length)\n+        throws ZipException {\n+\n+        long givenChecksum = ZipLong.getValue(data, offset);\n+        byte[] tmp = new byte[length - WORD];\n+        System.arraycopy(data, offset + WORD, tmp, 0, length - WORD);\n+        crc.reset();\n+        crc.update(tmp);\n+        long realChecksum = crc.getValue();\n+        if (givenChecksum != realChecksum) {\n+            throw new ZipException(\"bad CRC checksum \"\n+                                   + Long.toHexString(givenChecksum)\n+                                   + \" instead of \"\n+                                   + Long.toHexString(realChecksum));\n         }\n \n-        int newMode = ( new ZipShort( tmp, 0 ) ).getValue();\n-        byte[] linkArray = new byte[ (int)( new ZipLong( tmp, 2 ) ).getValue() ];\n-        m_uid = ( new ZipShort( tmp, 6 ) ).getValue();\n-        m_gid = ( new ZipShort( tmp, 8 ) ).getValue();\n-\n-        if( linkArray.length == 0 )\n-        {\n-            m_link = \"\";\n+        int newMode = ZipShort.getValue(tmp, 0);\n+        // CheckStyle:MagicNumber OFF\n+        byte[] linkArray = new byte[(int) ZipLong.getValue(tmp, 2)];\n+        uid = ZipShort.getValue(tmp, 6);\n+        gid = ZipShort.getValue(tmp, 8);\n+\n+        if (linkArray.length == 0) {\n+            link = \"\";\n+        } else {\n+            System.arraycopy(tmp, 10, linkArray, 0, linkArray.length);\n+            link = new String(linkArray);\n         }\n-        else\n-        {\n-            System.arraycopy( tmp, 10, linkArray, 0, linkArray.length );\n-            m_link = new String( linkArray );\n-        }\n-        setDirectory( ( newMode & DIR_FLAG ) != 0 );\n-        setMode( newMode );\n+        // CheckStyle:MagicNumber ON\n+        setDirectory((newMode & DIR_FLAG) != 0);\n+        setMode(newMode);\n     }\n \n     /**\n      * Get the file mode for given permissions with the correct file type.\n-     *\n-     * @param mode Description of Parameter\n-     * @return The Mode value\n-     * @since 1.1\n-     */\n-    protected int getMode( final int mode )\n-    {\n+     * @param mode the mode\n+     * @return the type with the mode\n+     * @since 1.1\n+     */\n+    protected int getMode(int mode) {\n         int type = FILE_FLAG;\n-        if( isLink() )\n-        {\n+        if (isLink()) {\n             type = LINK_FLAG;\n-        }\n-        else if( isDirectory() )\n-        {\n+        } else if (isDirectory()) {\n             type = DIR_FLAG;\n         }\n-        return type | ( mode & PERM_MASK );\n-    }\n+        return type | (mode & PERM_MASK);\n+    }\n+\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n /*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n  *\n- * http://www.apache.org/licenses/LICENSE-2.0\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n  *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n  */\n package org.apache.commons.compress.archivers.zip;\n \n-import java.util.ArrayList;\n import java.util.Hashtable;\n+import java.util.Vector;\n import java.util.zip.ZipException;\n \n /**\n  * ZipExtraField related methods\n+ *\n  */\n-public class ExtraFieldUtils\n-{\n+// CheckStyle:HideUtilityClassConstructorCheck OFF (bc)\n+public class ExtraFieldUtils {\n+\n+    private static final int WORD = 4;\n+\n     /**\n      * Static registry of known extra fields.\n      *\n      * @since 1.1\n      */\n-    private static final Hashtable c_implementations;\n+    private static Hashtable implementations;\n \n-    static\n-    {\n-        c_implementations = new Hashtable();\n-        register( AsiExtraField.class );\n+    static {\n+        implementations = new Hashtable();\n+        register(AsiExtraField.class);\n+        register(JarMarker.class);\n     }\n \n     /**\n-     * Create an instance of the approriate ExtraField, falls back to {@link\n-     * UnrecognizedExtraField UnrecognizedExtraField}.\n+     * Register a ZipExtraField implementation.\n      *\n-     * Throws java.lang.IllegalAccessException if cant create implementation.\n+     * <p>The given class must have a no-arg constructor and implement\n+     * the {@link ZipExtraField ZipExtraField interface}.</p>\n+     * @param c the class to register\n      *\n-     * @param headerID the header ID\n-     * @return the extra field implementation\n-     * @throws InstantiationException if cant create implementation\n-     * @throws IllegalAccessException if cant create implementation\n      * @since 1.1\n      */\n-    public static ZipExtraField createExtraField( final ZipShort headerID )\n-        throws InstantiationException, IllegalAccessException\n-    {\n-        final Class clazz =\n-            (Class)c_implementations.get( headerID );\n-        if( clazz != null )\n-        {\n-            return (ZipExtraField)clazz.newInstance();\n+    public static void register(Class c) {\n+        try {\n+            ZipExtraField ze = (ZipExtraField) c.newInstance();\n+            implementations.put(ze.getHeaderId(), c);\n+        } catch (ClassCastException cc) {\n+            throw new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n+        } catch (InstantiationException ie) {\n+            throw new RuntimeException(c + \" is not a concrete class\");\n+        } catch (IllegalAccessException ie) {\n+            throw new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n         }\n-        final UnrecognizedExtraField unrecognized = new UnrecognizedExtraField();\n-        unrecognized.setHeaderID( headerID );\n-        return unrecognized;\n     }\n \n     /**\n-     * Merges the central directory fields of the given ZipExtraFields.\n-     *\n-     * @param data the central directory data\n-     * @return the merged data\n+     * Create an instance of the approriate ExtraField, falls back to\n+     * {@link UnrecognizedExtraField UnrecognizedExtraField}.\n+     * @param headerId the header identifier\n+     * @return an instance of the appropiate ExtraField\n+     * @exception InstantiationException if unable to instantiate the class\n+     * @exception IllegalAccessException if not allowed to instatiate the class\n      * @since 1.1\n      */\n-    public static byte[] mergeCentralDirectoryData( final ZipExtraField[] data )\n-    {\n-        int sum = 4 * data.length;\n-        for( int i = 0; i < data.length; i++ )\n-        {\n-            sum += data[ i ].getCentralDirectoryLength().getValue();\n+    public static ZipExtraField createExtraField(ZipShort headerId)\n+        throws InstantiationException, IllegalAccessException {\n+        Class c = (Class) implementations.get(headerId);\n+        if (c != null) {\n+            return (ZipExtraField) c.newInstance();\n         }\n-        byte[] result = new byte[ sum ];\n+        UnrecognizedExtraField u = new UnrecognizedExtraField();\n+        u.setHeaderId(headerId);\n+        return u;\n+    }\n+\n+    /**\n+     * Split the array into ExtraFields and populate them with the\n+     * give data.\n+     * @param data an array of bytes\n+     * @return an array of ExtraFields\n+     * @since 1.1\n+     * @throws ZipException on error\n+     */\n+    public static ZipExtraField[] parse(byte[] data) throws ZipException {\n+        Vector v = new Vector();\n         int start = 0;\n-        for( int i = 0; i < data.length; i++ )\n-        {\n-            System.arraycopy( data[ i ].getHeaderID().getBytes(),\n-                              0, result, start, 2 );\n-            System.arraycopy( data[ i ].getCentralDirectoryLength().getBytes(),\n-                              0, result, start + 2, 2 );\n-            byte[] local = data[ i ].getCentralDirectoryData();\n-            System.arraycopy( local, 0, result, start + 4, local.length );\n-            start += ( local.length + 4 );\n+        while (start <= data.length - WORD) {\n+            ZipShort headerId = new ZipShort(data, start);\n+            int length = (new ZipShort(data, start + 2)).getValue();\n+            if (start + WORD + length > data.length) {\n+                throw new ZipException(\"data starting at \" + start\n+                    + \" is in unknown format\");\n+            }\n+            try {\n+                ZipExtraField ze = createExtraField(headerId);\n+                ze.parseFromLocalFileData(data, start + WORD, length);\n+                v.addElement(ze);\n+            } catch (InstantiationException ie) {\n+                throw new ZipException(ie.getMessage());\n+            } catch (IllegalAccessException iae) {\n+                throw new ZipException(iae.getMessage());\n+            }\n+            start += (length + WORD);\n+        }\n+        if (start != data.length) { // array not exhausted\n+            throw new ZipException(\"data starting at \" + start\n+                + \" is in unknown format\");\n+        }\n+\n+        ZipExtraField[] result = new ZipExtraField[v.size()];\n+        v.copyInto(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Merges the local file data fields of the given ZipExtraFields.\n+     * @param data an array of ExtraFiles\n+     * @return an array of bytes\n+     * @since 1.1\n+     */\n+    public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\n+        int sum = WORD * data.length;\n+        for (int i = 0; i < data.length; i++) {\n+            sum += data[i].getLocalFileDataLength().getValue();\n+        }\n+        byte[] result = new byte[sum];\n+        int start = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            System.arraycopy(data[i].getHeaderId().getBytes(),\n+                             0, result, start, 2);\n+            System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n+                             0, result, start + 2, 2);\n+            byte[] local = data[i].getLocalFileDataData();\n+            System.arraycopy(local, 0, result, start + WORD, local.length);\n+            start += (local.length + WORD);\n         }\n         return result;\n     }\n \n     /**\n-     * Merges the local file data fields of the given ZipExtraFields.\n-     *\n-     * @param data the data\n-     * @return the merged data\n+     * Merges the central directory fields of the given ZipExtraFields.\n+     * @param data an array of ExtraFields\n+     * @return an array of bytes\n      * @since 1.1\n      */\n-    public static byte[] mergeLocalFileDataData( final ZipExtraField[] data )\n-    {\n-        int sum = 4 * data.length;\n-        for( int i = 0; i < data.length; i++ )\n-        {\n-            sum += data[ i ].getLocalFileDataLength().getValue();\n+    public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\n+        int sum = WORD * data.length;\n+        for (int i = 0; i < data.length; i++) {\n+            sum += data[i].getCentralDirectoryLength().getValue();\n         }\n-        byte[] result = new byte[ sum ];\n+        byte[] result = new byte[sum];\n         int start = 0;\n-        for( int i = 0; i < data.length; i++ )\n-        {\n-            System.arraycopy( data[ i ].getHeaderID().getBytes(),\n-                              0, result, start, 2 );\n-            System.arraycopy( data[ i ].getLocalFileDataLength().getBytes(),\n-                              0, result, start + 2, 2 );\n-            byte[] local = data[ i ].getLocalFileDataData();\n-            System.arraycopy( local, 0, result, start + 4, local.length );\n-            start += ( local.length + 4 );\n+        for (int i = 0; i < data.length; i++) {\n+            System.arraycopy(data[i].getHeaderId().getBytes(),\n+                             0, result, start, 2);\n+            System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n+                             0, result, start + 2, 2);\n+            byte[] local = data[i].getCentralDirectoryData();\n+            System.arraycopy(local, 0, result, start + WORD, local.length);\n+            start += (local.length + WORD);\n         }\n         return result;\n     }\n-\n-    /**\n-     * Split the array into ExtraFields and populate them with the give data.\n-     *\n-     * @param data the data to parse\n-     * @return the parsed fields\n-     * @exception ZipException on error\n-     * @since 1.1\n-     */\n-    public static ZipExtraField[] parse( final byte[] data )\n-        throws ZipException\n-    {\n-        ArrayList v = new ArrayList();\n-        int start = 0;\n-        while( start <= data.length - 4 )\n-        {\n-            final ZipShort headerID = new ZipShort( data, start );\n-            int length = ( new ZipShort( data, start + 2 ) ).getValue();\n-            if( start + 4 + length > data.length )\n-            {\n-                throw new ZipException( \"data starting at \" + start + \" is in unknown format\" );\n-            }\n-            try\n-            {\n-                ZipExtraField ze = createExtraField( headerID );\n-                ze.parseFromLocalFileData( data, start + 4, length );\n-                v.add( ze );\n-            }\n-            catch( InstantiationException ie )\n-            {\n-                throw new ZipException( ie.getMessage() );\n-            }\n-            catch( IllegalAccessException iae )\n-            {\n-                throw new ZipException( iae.getMessage() );\n-            }\n-            start += ( length + 4 );\n-        }\n-        if( start != data.length )\n-        {// array not exhausted\n-            throw new ZipException( \"data starting at \" + start + \" is in unknown format\" );\n-        }\n-\n-        final ZipExtraField[] result = new ZipExtraField[ v.size() ];\n-        return (ZipExtraField[])v.toArray( result );\n-    }\n-\n-    /**\n-     * Register a ZipExtraField implementation. <p>\n-     *\n-     * The given class must have a no-arg constructor and implement the {@link\n-     * ZipExtraField ZipExtraField interface}.</p>\n-     *\n-     * @param clazz The Class for particular implementation\n-     * @since 1.1\n-     */\n-    public static void register( final Class clazz )\n-    {\n-        try\n-        {\n-            ZipExtraField ze = (ZipExtraField)clazz.newInstance();\n-            c_implementations.put( ze.getHeaderID(), clazz );\n-        }\n-        catch( ClassCastException cc )\n-        {\n-            throw new RuntimeException( clazz +\n-                                        \" doesn\\'t implement ZipExtraField\" );\n-        }\n-        catch( InstantiationException ie )\n-        {\n-            throw new RuntimeException( clazz + \" is not a concrete class\" );\n-        }\n-        catch( IllegalAccessException ie )\n-        {\n-            throw new RuntimeException( clazz +\n-                                        \"\\'s no-arg constructor is not public\" );\n-        }\n-    }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnrecognizedExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnrecognizedExtraField.java\n      *\n      * @param headerID the header ID\n      */\n-    public void setHeaderID( final ZipShort headerID )\n+    public void setHeaderId( final ZipShort headerID )\n     {\n         m_headerID = headerID;\n     }\n      *\n      * @return the HeaderID\n      */\n-    public ZipShort getHeaderID()\n+    public ZipShort getHeaderId()\n     {\n         return m_headerID;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n      */\n     public void addExtraField( final ZipExtraField extraField )\n     {\n-        final ZipShort type = extraField.getHeaderID();\n+        final ZipShort type = extraField.getHeaderId();\n         boolean done = false;\n         for( int i = 0; !done && i < m_extraFields.size(); i++ )\n         {\n             final ZipExtraField other = (ZipExtraField)m_extraFields.get( i );\n-            if( other.getHeaderID().equals( type ) )\n+            if( other.getHeaderId().equals( type ) )\n             {\n                 m_extraFields.set( i, extraField );\n                 done = true;\n         boolean done = false;\n         for( int i = 0; !done && i < m_extraFields.size(); i++ )\n         {\n-            if( ( (ZipExtraField)m_extraFields.get( i ) ).getHeaderID().equals( type ) )\n+            if( ( (ZipExtraField)m_extraFields.get( i ) ).getHeaderId().equals( type ) )\n             {\n                 m_extraFields.remove( i );\n                 done = true;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEntry.java\n /*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n  *\n- * http://www.apache.org/licenses/LICENSE-2.0\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n  *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n  */\n package org.apache.commons.compress.archivers.zip;\n \n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n+import java.util.Vector;\n import java.util.zip.ZipException;\n \n /**\n- * Extension that adds better handling of extra fields and provides access to\n- * the internal and external file attributes.\n+ * Extension that adds better handling of extra fields and provides\n+ * access to the internal and external file attributes.\n+ *\n  */\n-public class ZipEntry\n-    extends java.util.zip.ZipEntry\n-{\n-    /**\n-     * Helper for JDK 1.1\n-     *\n-     * @since 1.2\n-     */\n-    private static Method c_setCompressedSizeMethod;\n-\n-    /**\n-     * Helper for JDK 1.1\n-     *\n-     * @since 1.2\n-     */\n-    private static final Object c_lockReflection = new Object();\n-\n-    /**\n-     * Helper for JDK 1.1\n-     *\n-     * @since 1.2\n-     */\n-    private static boolean c_triedToGetMethod;\n-\n-    private final ArrayList m_extraFields = new ArrayList();\n-\n-    private int m_internalAttributes;\n-    private long m_externalAttributes;\n-\n-    /**\n-     * Helper for JDK 1.1 <-> 1.2 incompatibility.\n-     *\n-     * @since 1.2\n-     */\n-    private Long m_compressedSize;\n+public class ZipEntry extends java.util.zip.ZipEntry implements Cloneable {\n+\n+    public static final int PLATFORM_UNIX = 3;\n+    public static final int PLATFORM_FAT  = 0;\n+    private static final int SHORT_MASK = 0xFFFF;\n+    private static final int SHORT_SHIFT = 16;\n+\n+    private int internalAttributes = 0;\n+    private int platform = PLATFORM_FAT;\n+    private long externalAttributes = 0;\n+    private Vector/*<ZipExtraField>*/ extraFields = null;\n+    private String name = null;\n \n     /**\n      * Creates a new zip entry with the specified name.\n-     *\n-     * @param name the name of entry\n-     * @since 1.1\n-     */\n-    public ZipEntry( final String name )\n-    {\n-        super( name );\n+     * @param name the name of the entry\n+     * @since 1.1\n+     */\n+    public ZipEntry(String name) {\n+        super(name);\n     }\n \n     /**\n      * Creates a new zip entry with fields taken from the specified zip entry.\n-     *\n-     * @param entry the JDK ZipEntry to adapt\n-     * @exception ZipException if can not create entry\n-     * @since 1.1\n-     */\n-    public ZipEntry( java.util.zip.ZipEntry entry )\n-        throws ZipException\n-    {\n-        /*\n-         * REVISIT: call super(entry) instead of this stuff in Ant2,\n-         * \"copy constructor\" has not been available in JDK 1.1\n-         */\n-        super( entry.getName() );\n-\n-        setComment( entry.getComment() );\n-        setMethod( entry.getMethod() );\n-        setTime( entry.getTime() );\n-\n-        final long size = entry.getSize();\n-        if( size > 0 )\n-        {\n-            setSize( size );\n-        }\n-\n-        final long cSize = entry.getCompressedSize();\n-        if( cSize > 0 )\n-        {\n-            setComprSize( cSize );\n-        }\n-\n-        final long crc = entry.getCrc();\n-        if( crc > 0 )\n-        {\n-            setCrc( crc );\n-        }\n-\n-        final byte[] extra = entry.getExtra();\n-        if( extra != null )\n-        {\n-            setExtraFields( ExtraFieldUtils.parse( extra ) );\n-        }\n-        else\n-        {\n+     * @param entry the entry to get fields from\n+     * @since 1.1\n+     * @throws ZipException on error\n+     */\n+    public ZipEntry(java.util.zip.ZipEntry entry) throws ZipException {\n+        super(entry);\n+        byte[] extra = entry.getExtra();\n+        if (extra != null) {\n+            setExtraFields(ExtraFieldUtils.parse(extra));\n+        } else {\n             // initializes extra data to an empty byte array\n             setExtra();\n         }\n \n     /**\n      * Creates a new zip entry with fields taken from the specified zip entry.\n-     *\n-     * @param entry the entry to adapt\n-     * @exception ZipException if can not create entry\n-     * @since 1.1\n-     */\n-    public ZipEntry( final ZipEntry entry )\n-        throws ZipException\n-    {\n-        this( (java.util.zip.ZipEntry)entry );\n-        setInternalAttributes( entry.getInternalAttributes() );\n-        setExternalAttributes( entry.getExternalAttributes() );\n-        setExtraFields( entry.getExtraFields() );\n-    }\n-\n-    /**\n-     * Try to get a handle to the setCompressedSize method.\n-     *\n-     * @since 1.2\n-     */\n-    private static void checkSCS()\n-    {\n-        if( !c_triedToGetMethod )\n-        {\n-            synchronized( c_lockReflection )\n-            {\n-                c_triedToGetMethod = true;\n-                try\n-                {\n-                    c_setCompressedSizeMethod =\n-                        java.util.zip.ZipEntry.class.getMethod( \"setCompressedSize\",\n-                                                                new Class[]{Long.TYPE} );\n-                }\n-                catch( NoSuchMethodException nse )\n-                {\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Are we running JDK 1.2 or higher?\n-     *\n-     * @return Description of the Returned Value\n-     * @since 1.2\n-     */\n-    private static boolean haveSetCompressedSize()\n-    {\n-        checkSCS();\n-        return c_setCompressedSizeMethod != null;\n-    }\n-\n-    /**\n-     * Invoke setCompressedSize via reflection.\n-     *\n-     * @param entry Description of Parameter\n-     * @param size Description of Parameter\n-     * @since 1.2\n-     */\n-    private static void performSetCompressedSize( final ZipEntry entry,\n-                                                  final long size )\n-    {\n-        final Long[] s = {new Long( size )};\n-        try\n-        {\n-            c_setCompressedSizeMethod.invoke( entry, s );\n-        }\n-        catch( final InvocationTargetException ite )\n-        {\n-            final Throwable nested = ite.getTargetException();\n-            final String message = \"Exception setting the compressed size \" +\n-                \"of \" + entry + \": \" + nested.getMessage();\n-            throw new RuntimeException( message );\n-        }\n-        catch( final Throwable t )\n-        {\n-            final String message = \"Exception setting the compressed size \" +\n-                \"of \" + entry + \": \" + t.getMessage();\n-            throw new RuntimeException( message );\n-        }\n-    }\n-\n-    /**\n-     * Make this class work in JDK 1.1 like a 1.2 class. <p>\n-     *\n-     * This either stores the size for later usage or invokes setCompressedSize\n-     * via reflection.</p>\n-     *\n-     * @param size The new ComprSize value\n-     * @since 1.2\n-     */\n-    public void setComprSize( final long size )\n-    {\n-        if( haveSetCompressedSize() )\n-        {\n-            performSetCompressedSize( this, size );\n-        }\n-        else\n-        {\n-            m_compressedSize = new Long( size );\n-        }\n+     * @param entry the entry to get fields from\n+     * @throws ZipException on error\n+     * @since 1.1\n+     */\n+    public ZipEntry(ZipEntry entry) throws ZipException {\n+        this((java.util.zip.ZipEntry) entry);\n+        setInternalAttributes(entry.getInternalAttributes());\n+        setExternalAttributes(entry.getExternalAttributes());\n+        setExtraFields(entry.getExtraFields());\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    protected ZipEntry() {\n+        super(\"\");\n+    }\n+\n+    /**\n+     * Overwrite clone.\n+     * @return a cloned copy of this ZipEntry\n+     * @since 1.1\n+     */\n+    public Object clone() {\n+        ZipEntry e = (ZipEntry) super.clone();\n+\n+        e.extraFields = extraFields != null ? (Vector) extraFields.clone() : null;\n+        e.setInternalAttributes(getInternalAttributes());\n+        e.setExternalAttributes(getExternalAttributes());\n+        e.setExtraFields(getExtraFields());\n+        return e;\n+    }\n+\n+    /**\n+     * Retrieves the internal file attributes.\n+     *\n+     * @return the internal file attributes\n+     * @since 1.1\n+     */\n+    public int getInternalAttributes() {\n+        return internalAttributes;\n+    }\n+\n+    /**\n+     * Sets the internal file attributes.\n+     * @param value an <code>int</code> value\n+     * @since 1.1\n+     */\n+    public void setInternalAttributes(int value) {\n+        internalAttributes = value;\n+    }\n+\n+    /**\n+     * Retrieves the external file attributes.\n+     * @return the external file attributes\n+     * @since 1.1\n+     */\n+    public long getExternalAttributes() {\n+        return externalAttributes;\n     }\n \n     /**\n      * Sets the external file attributes.\n-     *\n-     * @param externalAttributes The new ExternalAttributes value\n-     * @since 1.1\n-     */\n-    public void setExternalAttributes( final long externalAttributes )\n-    {\n-        m_externalAttributes = externalAttributes;\n-    }\n-\n-    /**\n-     * Throws an Exception if extra data cannot be parsed into extra fields.\n-     *\n-     * @param extra The new Extra value\n-     * @throws RuntimeException if fail to set extra data\n-     * @since 1.1\n-     */\n-    public void setExtra( final byte[] extra )\n-        throws RuntimeException\n-    {\n-        try\n-        {\n-            setExtraFields( ExtraFieldUtils.parse( extra ) );\n-        }\n-        catch( final Exception e )\n-        {\n-            throw new RuntimeException( e.getMessage() );\n-        }\n+     * @param value an <code>long</code> value\n+     * @since 1.1\n+     */\n+    public void setExternalAttributes(long value) {\n+        externalAttributes = value;\n+    }\n+\n+    /**\n+     * Sets Unix permissions in a way that is understood by Info-Zip's\n+     * unzip command.\n+     * @param mode an <code>int</code> value\n+     * @since Ant 1.5.2\n+     */\n+    public void setUnixMode(int mode) {\n+        // CheckStyle:MagicNumberCheck OFF - no point\n+        setExternalAttributes((mode << SHORT_SHIFT)\n+                              // MS-DOS read-only attribute\n+                              | ((mode & 0200) == 0 ? 1 : 0)\n+                              // MS-DOS directory flag\n+                              | (isDirectory() ? 0x10 : 0));\n+        // CheckStyle:MagicNumberCheck ON\n+        platform = PLATFORM_UNIX;\n+    }\n+\n+    /**\n+     * Unix permission.\n+     * @return the unix permissions\n+     * @since Ant 1.6\n+     */\n+    public int getUnixMode() {\n+        return platform != PLATFORM_UNIX ? 0 :\n+            (int) ((getExternalAttributes() >> SHORT_SHIFT) & SHORT_MASK);\n+    }\n+\n+    /**\n+     * Platform specification to put into the &quot;version made\n+     * by&quot; part of the central file header.\n+     *\n+     * @return PLATFORM_FAT unless {@link #setUnixMode setUnixMode}\n+     * has been called, in which case PLATORM_UNIX will be returned.\n+     *\n+     * @since Ant 1.5.2\n+     */\n+    public int getPlatform() {\n+        return platform;\n+    }\n+\n+    /**\n+     * Set the platform (UNIX or FAT).\n+     * @param platform an <code>int</code> value - 0 is FAT, 3 is UNIX\n+     * @since 1.9\n+     */\n+    protected void setPlatform(int platform) {\n+        this.platform = platform;\n     }\n \n     /**\n      * Replaces all currently attached extra fields with the new array.\n-     *\n-     * @param fields The new ExtraFields value\n-     * @since 1.1\n-     */\n-    public void setExtraFields( final ZipExtraField[] fields )\n-    {\n-        m_extraFields.clear();\n-        for( int i = 0; i < fields.length; i++ )\n-        {\n-            m_extraFields.add( fields[ i ] );\n+     * @param fields an array of extra fields\n+     * @since 1.1\n+     */\n+    public void setExtraFields(ZipExtraField[] fields) {\n+        extraFields = new Vector();\n+        for (int i = 0; i < fields.length; i++) {\n+            extraFields.addElement(fields[i]);\n         }\n         setExtra();\n     }\n \n     /**\n-     * Sets the internal file attributes.\n-     *\n-     * @param value The new InternalAttributes value\n-     * @since 1.1\n-     */\n-    public void setInternalAttributes( final int value )\n-    {\n-        m_internalAttributes = value;\n-    }\n-\n-    /**\n-     * Retrieves the extra data for the central directory.\n-     *\n-     * @return The CentralDirectoryExtra value\n-     * @since 1.1\n-     */\n-    public byte[] getCentralDirectoryExtra()\n-    {\n-        return ExtraFieldUtils.mergeCentralDirectoryData( getExtraFields() );\n-    }\n-\n-    /**\n-     * Override to make this class work in JDK 1.1 like a 1.2 class.\n-     *\n-     * @return The CompressedSize value\n-     * @since 1.2\n-     */\n-    public long getCompressedSize()\n-    {\n-        if( m_compressedSize != null )\n-        {\n-            // has been set explicitly and we are running in a 1.1 VM\n-            return m_compressedSize.longValue();\n-        }\n-        return super.getCompressedSize();\n-    }\n-\n-    /**\n-     * Retrieves the external file attributes.\n-     *\n-     * @return The ExternalAttributes value\n-     * @since 1.1\n-     */\n-    public long getExternalAttributes()\n-    {\n-        return m_externalAttributes;\n-    }\n-\n-    /**\n      * Retrieves extra fields.\n-     *\n-     * @return The ExtraFields value\n-     * @since 1.1\n-     */\n-    public ZipExtraField[] getExtraFields()\n-    {\n-        final ZipExtraField[] result = new ZipExtraField[ m_extraFields.size() ];\n-        return (ZipExtraField[])m_extraFields.toArray( result );\n-    }\n-\n-    /**\n-     * Retrieves the internal file attributes.\n-     *\n-     * @return The InternalAttributes value\n-     * @since 1.1\n-     */\n-    public int getInternalAttributes()\n-    {\n-        return m_internalAttributes;\n-    }\n-\n-    /**\n-     * Retrieves the extra data for the local file data.\n-     *\n-     * @return The LocalFileDataExtra value\n-     * @since 1.1\n-     */\n-    public byte[] getLocalFileDataExtra()\n-    {\n-        byte[] extra = getExtra();\n-        return extra != null ? extra : new byte[ 0 ];\n-    }\n-\n-    /**\n-     * Adds an extra fields - replacing an already present extra field of the\n-     * same type.\n-     *\n-     * @param extraField The feature to be added to the ExtraField attribute\n-     * @since 1.1\n-     */\n-    public void addExtraField( final ZipExtraField extraField )\n-    {\n-        final ZipShort type = extraField.getHeaderID();\n+     * @return an array of the extra fields\n+     * @since 1.1\n+     */\n+    public ZipExtraField[] getExtraFields() {\n+        if (extraFields == null) {\n+            return new ZipExtraField[0];\n+        }\n+        ZipExtraField[] result = new ZipExtraField[extraFields.size()];\n+        extraFields.copyInto(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Adds an extra fields - replacing an already present extra field\n+     * of the same type.\n+     * @param ze an extra field\n+     * @since 1.1\n+     */\n+    public void addExtraField(ZipExtraField ze) {\n+        if (extraFields == null) {\n+            extraFields = new Vector();\n+        }\n+        ZipShort type = ze.getHeaderId();\n         boolean done = false;\n-        for( int i = 0; !done && i < m_extraFields.size(); i++ )\n-        {\n-            final ZipExtraField other = (ZipExtraField)m_extraFields.get( i );\n-            if( other.getHeaderID().equals( type ) )\n-            {\n-                m_extraFields.set( i, extraField );\n+        for (int i = 0, fieldsSize = extraFields.size(); !done && i < fieldsSize; i++) {\n+            if (((ZipExtraField) extraFields.elementAt(i)).getHeaderId().equals(type)) {\n+                extraFields.setElementAt(ze, i);\n                 done = true;\n             }\n         }\n-        if( !done )\n-        {\n-            m_extraFields.add( extraField );\n+        if (!done) {\n+            extraFields.addElement(ze);\n         }\n         setExtra();\n     }\n \n     /**\n-     * Overwrite clone\n-     *\n-     * @return Description of the Returned Value\n-     * @since 1.1\n-     */\n-    public Object clone()\n-    {\n-        ZipEntry entry = null;\n-        try\n-        {\n-            entry = new ZipEntry( (java.util.zip.ZipEntry)super.clone() );\n-        }\n-        catch( final Exception e )\n-        {\n-            // impossible as extra data is in correct format\n-            e.printStackTrace();\n-            return null;\n-        }\n-\n-        entry.setInternalAttributes( getInternalAttributes() );\n-        entry.setExternalAttributes( getExternalAttributes() );\n-        entry.setExtraFields( getExtraFields() );\n-        return entry;\n-    }\n-\n-    /**\n      * Remove an extra fields.\n-     *\n-     * @param type Description of Parameter\n-     * @since 1.1\n-     */\n-    public void removeExtraField( final ZipShort type )\n-    {\n+     * @param type the type of extra field to remove\n+     * @since 1.1\n+     */\n+    public void removeExtraField(ZipShort type) {\n+        if (extraFields == null) {\n+            extraFields = new Vector();\n+        }\n         boolean done = false;\n-        for( int i = 0; !done && i < m_extraFields.size(); i++ )\n-        {\n-            if( ( (ZipExtraField)m_extraFields.get( i ) ).getHeaderID().equals( type ) )\n-            {\n-                m_extraFields.remove( i );\n+        for (int i = 0, fieldsSize = extraFields.size(); !done && i < fieldsSize; i++) {\n+            if (((ZipExtraField) extraFields.elementAt(i)).getHeaderId().equals(type)) {\n+                extraFields.removeElementAt(i);\n                 done = true;\n             }\n         }\n-        if( !done )\n-        {\n+        if (!done) {\n             throw new java.util.NoSuchElementException();\n         }\n         setExtra();\n     }\n \n     /**\n+     * Throws an Exception if extra data cannot be parsed into extra fields.\n+     * @param extra an array of bytes to be parsed into extra fields\n+     * @throws RuntimeException if the bytes cannot be parsed\n+     * @since 1.1\n+     * @throws RuntimeException on error\n+     */\n+    public void setExtra(byte[] extra) throws RuntimeException {\n+        try {\n+            setExtraFields(ExtraFieldUtils.parse(extra));\n+        } catch (Exception e) {\n+            throw new RuntimeException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n      * Unfortunately {@link java.util.zip.ZipOutputStream\n-     * java.util.zip.ZipOutputStream} seems to access the extra data directly,\n-     * so overriding getExtra doesn't help - we need to modify super's data\n-     * directly.\n-     *\n-     * @since 1.1\n-     */\n-    protected void setExtra()\n-    {\n-        super.setExtra( ExtraFieldUtils.mergeLocalFileDataData( getExtraFields() ) );\n-    }\n+     * java.util.zip.ZipOutputStream} seems to access the extra data\n+     * directly, so overriding getExtra doesn't help - we need to\n+     * modify super's data directly.\n+     *\n+     * @since 1.1\n+     */\n+    protected void setExtra() {\n+        super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n+    }\n+\n+    /**\n+     * Retrieves the extra data for the local file data.\n+     * @return the extra data for local file\n+     * @since 1.1\n+     */\n+    public byte[] getLocalFileDataExtra() {\n+        byte[] extra = getExtra();\n+        return extra != null ? extra : new byte[0];\n+    }\n+\n+    /**\n+     * Retrieves the extra data for the central directory.\n+     * @return the central directory extra data\n+     * @since 1.1\n+     */\n+    public byte[] getCentralDirectoryExtra() {\n+        return ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n+    }\n+\n+    /**\n+     * Make this class work in JDK 1.1 like a 1.2 class.\n+     *\n+     * <p>This either stores the size for later usage or invokes\n+     * setCompressedSize via reflection.</p>\n+     * @param size the size to use\n+     * @deprecated since 1.7.\n+     *             Use setCompressedSize directly.\n+     * @since 1.2\n+     */\n+    public void setComprSize(long size) {\n+        setCompressedSize(size);\n+    }\n+\n+    /**\n+     * Get the name of the entry.\n+     * @return the entry name\n+     * @since 1.9\n+     */\n+    public String getName() {\n+        return name == null ? super.getName() : name;\n+    }\n+\n+    /**\n+     * Is this entry a directory?\n+     * @return true if the entry is a directory\n+     * @since 1.10\n+     */\n+    public boolean isDirectory() {\n+        return getName().endsWith(\"/\");\n+    }\n+\n+    /**\n+     * Set the name of the entry.\n+     * @param name the name to use\n+     */\n+    protected void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    /**\n+     * Get the hashCode of the entry.\n+     * This uses the name as the hashcode.\n+     * @return a hashcode.\n+     * @since Ant 1.7\n+     */\n+    public int hashCode() {\n+        // this method has severe consequences on performance. We cannot rely\n+        // on the super.hashCode() method since super.getName() always return\n+        // the empty string in the current implemention (there's no setter)\n+        // so it is basically draining the performance of a hashmap lookup\n+        return getName().hashCode();\n+    }\n+\n+    /**\n+     * The equality method. In this case, the implementation returns 'this == o'\n+     * which is basically the equals method of the Object class.\n+     * @param o the object to compare to\n+     * @return true if this object is the same as <code>o</code>\n+     * @since Ant 1.7\n+     */\n+    public boolean equals(Object o) {\n+        return (this == o);\n+    }\n+\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipExtraField.java\n      * @return The HeaderId value\n      * @since 1.1\n      */\n-    ZipShort getHeaderID();\n+    ZipShort getHeaderId();\n \n     /**\n      * Length of the extra field in the local file data - without Header-ID or\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n /*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n  *\n- * http://www.apache.org/licenses/LICENSE-2.0\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n  *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n  */\n package org.apache.commons.compress.archivers.zip;\n \n /**\n- * Utility class that represents a four byte integer with conversion rules for\n- * the big endian byte order of ZIP files.\n+ * Utility class that represents a four byte integer with conversion\n+ * rules for the big endian byte order of ZIP files.\n+ *\n  */\n-public final class ZipLong implements Cloneable\n-{\n-    private long m_value;\n+public final class ZipLong implements Cloneable {\n+\n+    private static final int WORD = 4;\n+    //private static final int BYTE_BIT_SIZE = 8;\n+    private static final int BYTE_MASK = 0xFF;\n+\n+    private static final int BYTE_1 = 1;\n+    private static final int BYTE_1_MASK = 0xFF00;\n+    private static final int BYTE_1_SHIFT = 8;\n+\n+    private static final int BYTE_2 = 2;\n+    private static final int BYTE_2_MASK = 0xFF0000;\n+    private static final int BYTE_2_SHIFT = 16;\n+\n+    private static final int BYTE_3 = 3;\n+    private static final long BYTE_3_MASK = 0xFF000000L;\n+    private static final int BYTE_3_SHIFT = 24;\n+\n+    private long value;\n \n     /**\n      * Create instance from a number.\n-     *\n-     * @param value the value\n+     * @param value the long to store as a ZipLong\n      * @since 1.1\n      */\n-    public ZipLong( final long value )\n-    {\n-        m_value = value;\n+    public ZipLong(long value) {\n+        this.value = value;\n     }\n \n     /**\n      * Create instance from bytes.\n-     *\n-     * @param buffer the buffer to read data from\n+     * @param bytes the bytes to store as a ZipLong\n      * @since 1.1\n      */\n-    public ZipLong( final byte[] buffer )\n-    {\n-        this( buffer, 0 );\n+    public ZipLong (byte[] bytes) {\n+        this(bytes, 0);\n     }\n \n     /**\n      * Create instance from the four bytes starting at offset.\n-     *\n-     * @param buffer buffer to read data from\n-     * @param offset offset into buffer\n+     * @param bytes the bytes to store as a ZipLong\n+     * @param offset the offset to start\n      * @since 1.1\n      */\n-    public ZipLong( final byte[] buffer, final int offset )\n-    {\n-        m_value = ( buffer[ offset + 3 ] << 24 ) & 0xFF000000l;\n-        m_value += ( buffer[ offset + 2 ] << 16 ) & 0xFF0000;\n-        m_value += ( buffer[ offset + 1 ] << 8 ) & 0xFF00;\n-        m_value += ( buffer[ offset ] & 0xFF );\n+    public ZipLong (byte[] bytes, int offset) {\n+        value = ZipLong.getValue(bytes, offset);\n     }\n \n     /**\n-     * Get value as two bytes in big endian byte order.\n-     *\n-     * @return The value as bytes\n+     * Get value as four bytes in big endian byte order.\n      * @since 1.1\n+     * @return value as four bytes in big endian order\n      */\n-    public byte[] getBytes()\n-    {\n-        byte[] result = new byte[ 4 ];\n-        result[ 0 ] = (byte)( ( m_value & 0xFF ) );\n-        result[ 1 ] = (byte)( ( m_value & 0xFF00 ) >> 8 );\n-        result[ 2 ] = (byte)( ( m_value & 0xFF0000 ) >> 16 );\n-        result[ 3 ] = (byte)( ( m_value & 0xFF000000l ) >> 24 );\n+    public byte[] getBytes() {\n+        return ZipLong.getBytes(value);\n+    }\n+\n+    /**\n+     * Get value as Java long.\n+     * @since 1.1\n+     * @return value as a long\n+     */\n+    public long getValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Get value as four bytes in big endian byte order.\n+     * @param value the value to convert\n+     * @return value as four bytes in big endian byte order\n+     */\n+    public static byte[] getBytes(long value) {\n+        byte[] result = new byte[WORD];\n+        result[0] = (byte) ((value & BYTE_MASK));\n+        result[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\n+        result[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\n+        result[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n         return result;\n     }\n \n     /**\n-     * Get value as Java int.\n-     *\n-     * @return The value\n-     * @since 1.1\n+     * Helper method to get the value as a Java long from four bytes starting at given array offset\n+     * @param bytes the array of bytes\n+     * @param offset the offset to start\n+     * @return the correspondanding Java long value\n      */\n-    public long getValue()\n-    {\n-        return m_value;\n+    public static long getValue(byte[] bytes, int offset) {\n+        long value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\n+        value += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\n+        value += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\n+        value += (bytes[offset] & BYTE_MASK);\n+        return value;\n+    }\n+\n+    /**\n+     * Helper method to get the value as a Java long from a four-byte array\n+     * @param bytes the array of bytes\n+     * @return the correspondanding Java long value\n+     */\n+    public static long getValue(byte[] bytes) {\n+        return getValue(bytes, 0);\n     }\n \n     /**\n      * Override to make two instances with same value equal.\n-     *\n-     * @param o the object to compare against\n-     * @return true if equyal, false otherwise\n+     * @param o an object to compare\n+     * @return true if the objects are equal\n      * @since 1.1\n      */\n-    public boolean equals( final Object o )\n-    {\n-        if( o == null || !( o instanceof ZipLong ) )\n-        {\n+    public boolean equals(Object o) {\n+        if (o == null || !(o instanceof ZipLong)) {\n             return false;\n         }\n-        return m_value == ( (ZipLong)o ).getValue();\n+        return value == ((ZipLong) o).getValue();\n     }\n \n     /**\n      * Override to make two instances with same value equal.\n-     *\n-     * @return the hashcode\n+     * @return the value stored in the ZipLong\n      * @since 1.1\n      */\n-    public int hashCode()\n-    {\n-        return (int)m_value;\n+    public int hashCode() {\n+        return (int) value;\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipOutputStream.java\n /*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n  *\n- * http://www.apache.org/licenses/LICENSE-2.0\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n  *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n  */\n package org.apache.commons.compress.archivers.zip;\n \n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FilterOutputStream;\n import java.io.IOException;\n import java.io.OutputStream;\n+import java.io.RandomAccessFile;\n import java.io.UnsupportedEncodingException;\n-import java.util.ArrayList;\n-import java.util.Calendar;\n import java.util.Date;\n import java.util.Hashtable;\n+import java.util.Vector;\n import java.util.zip.CRC32;\n import java.util.zip.Deflater;\n-import java.util.zip.DeflaterOutputStream;\n import java.util.zip.ZipException;\n \n /**\n  * Reimplementation of {@link java.util.zip.ZipOutputStream\n- * java.util.zip.ZipOutputStream} that does handle the extended functionality of\n- * this package, especially internal/external file attributes and extra fields\n- * with different layouts for local file data and central directory entries. <p>\n+ * java.util.zip.ZipOutputStream} that does handle the extended\n+ * functionality of this package, especially internal/external file\n+ * attributes and extra fields with different layouts for local file\n+ * data and central directory entries.\n  *\n- * This implementation will use a Data Descriptor to store size and CRC\n- * information for DEFLATED entries, this means, you don't need to calculate\n- * them yourself. Unfortunately this is not possible for the STORED method, here\n- * setting the CRC and uncompressed size information is required before {@link\n- * #putNextEntry putNextEntry} will be called.</p>\n+ * <p>This class will try to use {@link java.io.RandomAccessFile\n+ * RandomAccessFile} when you know that the output is going to go to a\n+ * file.</p>\n+ *\n+ * <p>If RandomAccessFile cannot be used, this implementation will use\n+ * a Data Descriptor to store size and CRC information for {@link\n+ * #DEFLATED DEFLATED} entries, this means, you don't need to\n+ * calculate them yourself.  Unfortunately this is not possible for\n+ * the {@link #STORED STORED} method, here setting the CRC and\n+ * uncompressed size information is required before {@link\n+ * #putNextEntry putNextEntry} can be called.</p>\n+ *\n  */\n-public class ZipOutputStream\n-    extends DeflaterOutputStream\n-{\n+public class ZipOutputStream extends FilterOutputStream {\n+\n+    private static final int BYTE_MASK = 0xFF;\n+    private static final int SHORT = 2;\n+    private static final int WORD = 4;\n+    private static final int BUFFER_SIZE = 512;\n+    /* \n+     * Apparently Deflater.setInput gets slowed down a lot on Sun JVMs\n+     * when it gets handed a really big buffer.  See\n+     * https://issues.apache.org/bugzilla/show_bug.cgi?id=45396\n+     *\n+     * Using a buffer size of 8 kB proved to be a good compromise\n+     */\n+    private static final int DEFLATER_BLOCK_SIZE = 8192;\n+\n+    /**\n+     * Compression method for deflated entries.\n+     *\n+     * @since 1.1\n+     */\n+    public static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n+\n+    /**\n+     * Default compression level for deflated entries.\n+     *\n+     * @since Ant 1.7\n+     */\n+    public static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n+\n+    /**\n+     * Compression method for stored entries.\n+     *\n+     * @since 1.1\n+     */\n+    public static final int STORED = java.util.zip.ZipEntry.STORED;\n+\n+    /**\n+     * Current entry.\n+     *\n+     * @since 1.1\n+     */\n+    private ZipEntry entry;\n+\n+    /**\n+     * The file comment.\n+     *\n+     * @since 1.1\n+     */\n+    private String comment = \"\";\n+\n+    /**\n+     * Compression level for next entry.\n+     *\n+     * @since 1.1\n+     */\n+    private int level = DEFAULT_COMPRESSION;\n+\n+    /**\n+     * Has the compression level changed when compared to the last\n+     * entry?\n+     *\n+     * @since 1.5\n+     */\n+    private boolean hasCompressionLevelChanged = false;\n+\n+    /**\n+     * Default compression method for next entry.\n+     *\n+     * @since 1.1\n+     */\n+    private int method = java.util.zip.ZipEntry.DEFLATED;\n+\n+    /**\n+     * List of ZipEntries written so far.\n+     *\n+     * @since 1.1\n+     */\n+    private Vector entries = new Vector();\n+\n+    /**\n+     * CRC instance to avoid parsing DEFLATED data twice.\n+     *\n+     * @since 1.1\n+     */\n+    private CRC32 crc = new CRC32();\n+\n+    /**\n+     * Count the bytes written to out.\n+     *\n+     * @since 1.1\n+     */\n+    private long written = 0;\n+\n+    /**\n+     * Data for local header data\n+     *\n+     * @since 1.1\n+     */\n+    private long dataStart = 0;\n+\n+    /**\n+     * Offset for CRC entry in the local file header data for the\n+     * current entry starts here.\n+     *\n+     * @since 1.15\n+     */\n+    private long localDataStart = 0;\n+\n+    /**\n+     * Start of central directory.\n+     *\n+     * @since 1.1\n+     */\n+    private long cdOffset = 0;\n+\n+    /**\n+     * Length of central directory.\n+     *\n+     * @since 1.1\n+     */\n+    private long cdLength = 0;\n+\n     /**\n      * Helper, a 0 as ZipShort.\n      *\n     private static final byte[] LZERO = {0, 0, 0, 0};\n \n     /**\n-     * Compression method for deflated entries.\n-     *\n-     * @since 1.1\n-     */\n-    public static final int DEFLATED = ZipEntry.DEFLATED;\n-\n-    /**\n-     * Compression method for deflated entries.\n-     *\n-     * @since 1.1\n-     */\n-    public static final int STORED = ZipEntry.STORED;\n+     * Holds the offsets of the LFH starts for each entry.\n+     *\n+     * @since 1.1\n+     */\n+    private Hashtable offsets = new Hashtable();\n+\n+    /**\n+     * The encoding to use for filenames and the file comment.\n+     *\n+     * <p>For a list of possible values see <a\n+     * href=\"http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html\">http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html</a>.\n+     * Defaults to the platform's default character encoding.</p>\n+     *\n+     * @since 1.3\n+     */\n+    private String encoding = null;\n+\n+    // CheckStyle:VisibilityModifier OFF - bc\n+\n+    /**\n+     * This Deflater object is used for output.\n+     *\n+     * <p>This attribute is only protected to provide a level of API\n+     * backwards compatibility.  This class used to extend {@link\n+     * java.util.zip.DeflaterOutputStream DeflaterOutputStream} up to\n+     * Revision 1.13.</p>\n+     *\n+     * @since 1.14\n+     */\n+    protected Deflater def = new Deflater(level, true);\n+\n+    /**\n+     * This buffer servers as a Deflater.\n+     *\n+     * <p>This attribute is only protected to provide a level of API\n+     * backwards compatibility.  This class used to extend {@link\n+     * java.util.zip.DeflaterOutputStream DeflaterOutputStream} up to\n+     * Revision 1.13.</p>\n+     *\n+     * @since 1.14\n+     */\n+    protected byte[] buf = new byte[BUFFER_SIZE];\n+\n+    // CheckStyle:VisibilityModifier ON\n+\n+    /**\n+     * Optional random access output.\n+     *\n+     * @since 1.14\n+     */\n+    private RandomAccessFile raf = null;\n+\n+    /**\n+     * Creates a new ZIP OutputStream filtering the underlying stream.\n+     * @param out the outputstream to zip\n+     * @since 1.1\n+     */\n+    public ZipOutputStream(OutputStream out) {\n+        super(out);\n+    }\n+\n+    /**\n+     * Creates a new ZIP OutputStream writing to a File.  Will use\n+     * random access if possible.\n+     * @param file the file to zip to\n+     * @since 1.14\n+     * @throws IOException on error\n+     */\n+    public ZipOutputStream(File file) throws IOException {\n+        super(null);\n+\n+        try {\n+            raf = new RandomAccessFile(file, \"rw\");\n+            raf.setLength(0);\n+        } catch (IOException e) {\n+            if (raf != null) {\n+                try {\n+                    raf.close();\n+                } catch (IOException inner) {\n+                    // ignore\n+                }\n+                raf = null;\n+            }\n+            out = new FileOutputStream(file);\n+        }\n+    }\n+\n+    /**\n+     * This method indicates whether this archive is writing to a seekable stream (i.e., to a random\n+     * access file).\n+     *\n+     * <p>For seekable streams, you don't need to calculate the CRC or\n+     * uncompressed size for {@link #STORED} entries before\n+     * invoking {@link #putNextEntry}.\n+     * @return true if seekable\n+     * @since 1.17\n+     */\n+    public boolean isSeekable() {\n+        return raf != null;\n+    }\n+\n+    /**\n+     * The encoding to use for filenames and the file comment.\n+     *\n+     * <p>For a list of possible values see <a\n+     * href=\"http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html\">http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html</a>.\n+     * Defaults to the platform's default character encoding.</p>\n+     * @param encoding the encoding value\n+     * @since 1.3\n+     */\n+    public void setEncoding(String encoding) {\n+        this.encoding = encoding;\n+    }\n+\n+    /**\n+     * The encoding to use for filenames and the file comment.\n+     *\n+     * @return null if using the platform's default character encoding.\n+     *\n+     * @since 1.3\n+     */\n+    public String getEncoding() {\n+        return encoding;\n+    }\n+\n+    /**\n+     * Finishs writing the contents and closes this as well as the\n+     * underlying stream.\n+     *\n+     * @since 1.1\n+     * @throws IOException on error\n+     */\n+    public void finish() throws IOException {\n+        closeEntry();\n+        cdOffset = written;\n+        for (int i = 0, entriesSize = entries.size(); i < entriesSize; i++) {\n+            writeCentralFileHeader((ZipEntry) entries.elementAt(i));\n+        }\n+        cdLength = written - cdOffset;\n+        writeCentralDirectoryEnd();\n+        offsets.clear();\n+        entries.removeAllElements();\n+    }\n+\n+    /**\n+     * Writes all necessary data for this entry.\n+     *\n+     * @since 1.1\n+     * @throws IOException on error\n+     */\n+    public void closeEntry() throws IOException {\n+        if (entry == null) {\n+            return;\n+        }\n+\n+        long realCrc = crc.getValue();\n+        crc.reset();\n+\n+        if (entry.getMethod() == DEFLATED) {\n+            def.finish();\n+            while (!def.finished()) {\n+                deflate();\n+            }\n+\n+            entry.setSize(adjustToLong(def.getTotalIn()));\n+            entry.setCompressedSize(adjustToLong(def.getTotalOut()));\n+            entry.setCrc(realCrc);\n+\n+            def.reset();\n+\n+            written += entry.getCompressedSize();\n+        } else if (raf == null) {\n+            if (entry.getCrc() != realCrc) {\n+                throw new ZipException(\"bad CRC checksum for entry \"\n+                                       + entry.getName() + \": \"\n+                                       + Long.toHexString(entry.getCrc())\n+                                       + \" instead of \"\n+                                       + Long.toHexString(realCrc));\n+            }\n+\n+            if (entry.getSize() != written - dataStart) {\n+                throw new ZipException(\"bad size for entry \"\n+                                       + entry.getName() + \": \"\n+                                       + entry.getSize()\n+                                       + \" instead of \"\n+                                       + (written - dataStart));\n+            }\n+        } else { /* method is STORED and we used RandomAccessFile */\n+            long size = written - dataStart;\n+\n+            entry.setSize(size);\n+            entry.setCompressedSize(size);\n+            entry.setCrc(realCrc);\n+        }\n+\n+        // If random access output, write the local file header containing\n+        // the correct CRC and compressed/uncompressed sizes\n+        if (raf != null) {\n+            long save = raf.getFilePointer();\n+\n+            raf.seek(localDataStart);\n+            writeOut(ZipLong.getBytes(entry.getCrc()));\n+            writeOut(ZipLong.getBytes(entry.getCompressedSize()));\n+            writeOut(ZipLong.getBytes(entry.getSize()));\n+            raf.seek(save);\n+        }\n+\n+        writeDataDescriptor(entry);\n+        entry = null;\n+    }\n+\n+    /**\n+     * Begin writing next entry.\n+     * @param ze the entry to write\n+     * @since 1.1\n+     * @throws IOException on error\n+     */\n+    public void putNextEntry(ZipEntry ze) throws IOException {\n+        closeEntry();\n+\n+        entry = ze;\n+        entries.addElement(entry);\n+\n+        if (entry.getMethod() == -1) { // not specified\n+            entry.setMethod(method);\n+        }\n+\n+        if (entry.getTime() == -1) { // not specified\n+            entry.setTime(System.currentTimeMillis());\n+        }\n+\n+        // Size/CRC not required if RandomAccessFile is used\n+        if (entry.getMethod() == STORED && raf == null) {\n+            if (entry.getSize() == -1) {\n+                throw new ZipException(\"uncompressed size is required for\"\n+                                       + \" STORED method when not writing to a\"\n+                                       + \" file\");\n+            }\n+            if (entry.getCrc() == -1) {\n+                throw new ZipException(\"crc checksum is required for STORED\"\n+                                       + \" method when not writing to a file\");\n+            }\n+            entry.setCompressedSize(entry.getSize());\n+        }\n+\n+        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n+            def.setLevel(level);\n+            hasCompressionLevelChanged = false;\n+        }\n+        writeLocalFileHeader(entry);\n+    }\n+\n+    /**\n+     * Set the file comment.\n+     * @param comment the comment\n+     * @since 1.1\n+     */\n+    public void setComment(String comment) {\n+        this.comment = comment;\n+    }\n+\n+    /**\n+     * Sets the compression level for subsequent entries.\n+     *\n+     * <p>Default is Deflater.DEFAULT_COMPRESSION.</p>\n+     * @param level the compression level.\n+     * @throws IllegalArgumentException if an invalid compression level is specified.\n+     * @since 1.1\n+     */\n+    public void setLevel(int level) {\n+        if (level < Deflater.DEFAULT_COMPRESSION\n+            || level > Deflater.BEST_COMPRESSION) {\n+            throw new IllegalArgumentException(\n+                \"Invalid compression level: \" + level);\n+        }\n+        hasCompressionLevelChanged = (this.level != level);\n+        this.level = level;\n+    }\n+\n+    /**\n+     * Sets the default compression method for subsequent entries.\n+     *\n+     * <p>Default is DEFLATED.</p>\n+     * @param method an <code>int</code> from java.util.zip.ZipEntry\n+     * @since 1.1\n+     */\n+    public void setMethod(int method) {\n+        this.method = method;\n+    }\n+\n+    /**\n+     * Writes bytes to ZIP entry.\n+     * @param b the byte array to write\n+     * @param offset the start position to write from\n+     * @param length the number of bytes to write\n+     * @throws IOException on error\n+     */\n+    public void write(byte[] b, int offset, int length) throws IOException {\n+        if (entry.getMethod() == DEFLATED) {\n+            if (length > 0) {\n+                if (!def.finished()) {\n+                    if (length <= DEFLATER_BLOCK_SIZE) {\n+                        def.setInput(b, offset, length);\n+                        deflateUntilInputIsNeeded();\n+                    } else {\n+                        final int fullblocks = length / DEFLATER_BLOCK_SIZE;\n+                        for (int i = 0; i < fullblocks; i++) {\n+                            def.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,\n+                                         DEFLATER_BLOCK_SIZE);\n+                            deflateUntilInputIsNeeded();\n+                        }\n+                        final int done = fullblocks * DEFLATER_BLOCK_SIZE;\n+                        if (done < length) {\n+                            def.setInput(b, offset + done, length - done);\n+                            deflateUntilInputIsNeeded();\n+                        }\n+                    }\n+                }\n+            }\n+        } else {\n+            writeOut(b, offset, length);\n+            written += length;\n+        }\n+        crc.update(b, offset, length);\n+    }\n+\n+    /**\n+     * Writes a single byte to ZIP entry.\n+     *\n+     * <p>Delegates to the three arg method.</p>\n+     * @param b the byte to write\n+     * @since 1.14\n+     * @throws IOException on error\n+     */\n+    public void write(int b) throws IOException {\n+        byte[] buff = new byte[1];\n+        buff[0] = (byte) (b & BYTE_MASK);\n+        write(buff, 0, 1);\n+    }\n+\n+    /**\n+     * Closes this output stream and releases any system resources\n+     * associated with the stream.\n+     *\n+     * @exception  IOException  if an I/O error occurs.\n+     * @since 1.14\n+     */\n+    public void close() throws IOException {\n+        finish();\n+\n+        if (raf != null) {\n+            raf.close();\n+        }\n+        if (out != null) {\n+            out.close();\n+        }\n+    }\n+\n+    /**\n+     * Flushes this output stream and forces any buffered output bytes\n+     * to be written out to the stream.\n+     *\n+     * @exception  IOException  if an I/O error occurs.\n+     * @since 1.14\n+     */\n+    public void flush() throws IOException {\n+        if (out != null) {\n+            out.flush();\n+        }\n+    }\n \n     /*\n      * Various ZIP constants\n      *\n      * @since 1.1\n      */\n-    protected static final ZipLong LFH_SIG = new ZipLong( 0X04034B50L );\n+    protected static final byte[] LFH_SIG = ZipLong.getBytes(0X04034B50L);\n     /**\n      * data descriptor signature\n      *\n      * @since 1.1\n      */\n-    protected static final ZipLong DD_SIG = new ZipLong( 0X08074B50L );\n+    protected static final byte[] DD_SIG = ZipLong.getBytes(0X08074B50L);\n     /**\n      * central file header signature\n      *\n      * @since 1.1\n      */\n-    protected static final ZipLong CFH_SIG = new ZipLong( 0X02014B50L );\n+    protected static final byte[] CFH_SIG = ZipLong.getBytes(0X02014B50L);\n     /**\n      * end of central dir signature\n      *\n      * @since 1.1\n      */\n-    protected static final ZipLong EOCD_SIG = new ZipLong( 0X06054B50L );\n-\n-    /**\n-     * Smallest date/time ZIP can handle.\n-     *\n-     * @since 1.1\n-     */\n-    private static final ZipLong DOS_TIME_MIN = new ZipLong( 0x00002100L );\n-\n-    /**\n-     * The file comment.\n-     *\n-     * @since 1.1\n-     */\n-    private String m_comment = \"\";\n-\n-    /**\n-     * Compression level for next entry.\n-     *\n-     * @since 1.1\n-     */\n-    private int m_level = Deflater.DEFAULT_COMPRESSION;\n-\n-    /**\n-     * Default compression method for next entry.\n-     *\n-     * @since 1.1\n-     */\n-    private int m_method = DEFLATED;\n-\n-    /**\n-     * List of ZipEntries written so far.\n-     *\n-     * @since 1.1\n-     */\n-    private final ArrayList m_entries = new ArrayList();\n-\n-    /**\n-     * CRC instance to avoid parsing DEFLATED data twice.\n-     *\n-     * @since 1.1\n-     */\n-    private final CRC32 m_crc = new CRC32();\n-\n-    /**\n-     * Count the bytes written to out.\n-     *\n-     * @since 1.1\n-     */\n-    private long m_written;\n-\n-    /**\n-     * Data for current entry started here.\n-     *\n-     * @since 1.1\n-     */\n-    private long m_dataStart;\n-\n-    /**\n-     * Start of central directory.\n-     *\n-     * @since 1.1\n-     */\n-    private ZipLong m_cdOffset = new ZipLong( 0 );\n-\n-    /**\n-     * Length of central directory.\n-     *\n-     * @since 1.1\n-     */\n-    private ZipLong m_cdLength = new ZipLong( 0 );\n-\n-    /**\n-     * Holds the offsets of the LFH starts for each entry\n-     *\n-     * @since 1.1\n-     */\n-    private final Hashtable m_offsets = new Hashtable();\n-\n-    /**\n-     * The encoding to use for filenames and the file comment. <p>\n-     *\n-     * For a list of possible values see <a\n-     * href=\"http://java.sun.com/products/jdk/1.2/docs/guide/internat/encoding.doc.html\">\n-     * http://java.sun.com/products/jdk/1.2/docs/guide/internat/encoding.doc.html\n-     * </a>. Defaults to the platform's default character encoding.</p>\n-     *\n-     * @since 1.3\n-     */\n-    private String m_encoding;\n-\n-    /**\n-     * Current entry.\n-     *\n-     * @since 1.1\n-     */\n-    private ZipArchiveEntry m_entry;\n-\n-    /**\n-     * Creates a new ZIP OutputStream filtering the underlying stream.\n-     *\n-     * @param output the output stream to write to\n-     * @since 1.1\n-     */\n-    public ZipOutputStream( final OutputStream output )\n-    {\n-        super( output, new Deflater( Deflater.DEFAULT_COMPRESSION, true ) );\n-    }\n-\n-    /**\n-     * Convert a Date object to a DOS date/time field. <p>\n-     *\n-     * Stolen from InfoZip's <code>fileio.c</code></p>\n-     *\n-     * @param time Description of Parameter\n-     * @return Description of the Returned Value\n-     * @since 1.1\n-     */\n-    protected static ZipLong toDosTime( Date time )\n-    {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime( time );\n-        int year = cal.get(Calendar.YEAR);\n-        int month = cal.get(Calendar.MONTH) + 1;\n-        if( year < 1980 )\n-        {\n-            return DOS_TIME_MIN;\n-        }\n-        long value = ( ( year - 1980 ) << 25 )\n-            | ( month << 21 )\n-            | ( cal.get(Calendar.DAY_OF_MONTH) << 16 )\n-            | ( cal.get(Calendar.HOUR_OF_DAY) << 11 )\n-            | ( cal.get(Calendar.MINUTE) << 5 )\n-            | ( cal.get(Calendar.SECOND) >> 1 );\n-\n-        byte[] result = new byte[ 4 ];\n-        result[ 0 ] = (byte)( ( value & 0xFF ) );\n-        result[ 1 ] = (byte)( ( value & 0xFF00 ) >> 8 );\n-        result[ 2 ] = (byte)( ( value & 0xFF0000 ) >> 16 );\n-        result[ 3 ] = (byte)( ( value & 0xFF000000l ) >> 24 );\n-        return new ZipLong( result );\n-    }\n-\n-    /**\n-     * Set the file comment.\n-     *\n-     * @param comment The new Comment value\n-     * @since 1.1\n-     */\n-    public void setComment( String comment )\n-    {\n-        m_comment = comment;\n-    }\n-\n-    /**\n-     * The encoding to use for filenames and the file comment. <p>\n-     *\n-     * For a list of possible values see <a\n-     * href=\"http://java.sun.com/products/jdk/1.2/docs/guide/internat/encoding.doc.html\">\n-     * http://java.sun.com/products/jdk/1.2/docs/guide/internat/encoding.doc.html\n-     * </a>. Defaults to the platform's default character encoding.</p>\n-     *\n-     * @param encoding The new Encoding value\n-     * @since 1.3\n-     */\n-    public void setEncoding( String encoding )\n-    {\n-        m_encoding = encoding;\n-    }\n-\n-    /**\n-     * Sets the compression level for subsequent entries. <p>\n-     *\n-     * Default is Deflater.DEFAULT_COMPRESSION.</p>\n-     *\n-     * @param level The new Level value\n-     * @since 1.1\n-     */\n-    public void setLevel( int level )\n-    {\n-        m_level = level;\n-    }\n-\n-    /**\n-     * Sets the default compression method for subsequent entries. <p>\n-     *\n-     * Default is DEFLATED.</p>\n-     *\n-     * @param method The new Method value\n-     * @since 1.1\n-     */\n-    public void setMethod( final int method )\n-    {\n-        m_method = method;\n-    }\n-\n-    /**\n-     * The encoding to use for filenames and the file comment.\n-     *\n-     * @return null if using the platform's default character encoding.\n-     * @since 1.3\n-     */\n-    public String getEncoding()\n-    {\n-        return m_encoding;\n-    }\n-\n-    /**\n-     * Writes all necessary data for this entry.\n-     *\n-     * @throws IOException if an IO failure causes operation to fail\n-     * @since 1.1\n-     */\n-    public void closeEntry()\n-        throws IOException\n-    {\n-        if( m_entry == null )\n-        {\n-            return;\n-        }\n-\n-        long realCrc = m_crc.getValue();\n-        m_crc.reset();\n-\n-        if( m_entry.getMethod() == DEFLATED )\n-        {\n-            def.finish();\n-            while( !def.finished() )\n-            {\n-                deflate();\n-            }\n-\n-            m_entry.setSize( def.getTotalIn() );\n-            m_entry.setComprSize( def.getTotalOut() );\n-            m_entry.setCrc( realCrc );\n-\n-            def.reset();\n-\n-            m_written += m_entry.getCompressedSize();\n-        }\n-        else\n-        {\n-            if( m_entry.getCrc() != realCrc )\n-            {\n-                throw new ZipException( \"bad CRC checksum for entry \"\n-                                        + m_entry.getName() + \": \"\n-                                        + Long.toHexString( m_entry.getCrc() )\n-                                        + \" instead of \"\n-                                        + Long.toHexString( realCrc ) );\n-            }\n-\n-            if( m_entry.getSize() != m_written - m_dataStart )\n-            {\n-                throw new ZipException( \"bad size for entry \"\n-                                        + m_entry.getName() + \": \"\n-                                        + m_entry.getSize()\n-                                        + \" instead of \"\n-                                        + ( m_written - m_dataStart ) );\n-            }\n-\n-        }\n-\n-        writeDataDescriptor( m_entry );\n-        m_entry = null;\n-    }\n-\n-    /*\n-     * Found out by experiment, that DeflaterOutputStream.close()\n-     * will call finish() - so we don't need to override close\n-     * ourselves.\n-     */\n-    /**\n-     * Finishs writing the contents and closes this as well as the underlying\n-     * stream.\n-     *\n-     * @throws IOException if an IO failure causes operation to fail\n-     * @since 1.1\n-     */\n-    public void finish()\n-        throws IOException\n-    {\n-        closeEntry();\n-        m_cdOffset = new ZipLong( m_written );\n-        final int size = m_entries.size();\n-        for( int i = 0; i < size; i++ )\n-        {\n-            final ZipArchiveEntry entry = (ZipArchiveEntry)m_entries.get( i );\n-            writeCentralFileHeader( entry );\n-        }\n-        m_cdLength = new ZipLong( m_written - m_cdOffset.getValue() );\n-        writeCentralDirectoryEnd();\n-        m_offsets.clear();\n-        m_entries.clear();\n-    }\n-\n-    /**\n-     * Begin writing next entry.\n-     *\n-     * @param entry the entry\n-     * @throws IOException if an IO failure causes operation to fail\n-     * @since 1.1\n-     */\n-    public void putNextEntry( final ZipArchiveEntry entry )\n-        throws IOException\n-    {\n-        closeEntry();\n-\n-        m_entry = entry;\n-        m_entries.add( m_entry );\n-\n-        if( m_entry.getMethod() == -1 )\n-        {// not specified\n-            m_entry.setMethod( m_method );\n-        }\n-\n-        if( m_entry.getTime() == -1 )\n-        {// not specified\n-            m_entry.setTime( System.currentTimeMillis() );\n-        }\n-\n-        if( m_entry.getMethod() == STORED )\n-        {\n-            if( m_entry.getSize() == -1 )\n-            {\n-                throw new ZipException( \"uncompressed size is required for STORED method\" );\n-            }\n-            if( m_entry.getCrc() == -1 )\n-            {\n-                throw new ZipException( \"crc checksum is required for STORED method\" );\n-            }\n-            m_entry.setComprSize( m_entry.getSize() );\n-        }\n-        else\n-        {\n-            def.setLevel( m_level );\n-        }\n-        writeLocalFileHeader( m_entry );\n-    }\n-\n-    /**\n-     * Writes bytes to ZIP entry. <p>\n-     *\n-     * Override is necessary to support STORED entries, as well as calculationg\n-     * CRC automatically for DEFLATED entries.</p>\n-     *\n-     * @param buffer the buffer to write to\n-     * @param offset the offset to write to\n-     * @param length the length of data to write\n-     * @exception IOException if an IO error causes operation to fail\n-     */\n-    public void write( final byte[] buffer,\n-                       final int offset,\n-                       final int length )\n-        throws IOException\n-    {\n-        if( m_entry.getMethod() == DEFLATED )\n-        {\n-            super.write( buffer, offset, length );\n-        }\n-        else\n-        {\n-            out.write( buffer, offset, length );\n-            m_written += length;\n-        }\n-        m_crc.update( buffer, offset, length );\n-    }\n-\n-    /**\n-     * Retrieve the bytes for the given String in the encoding set for this\n-     * Stream.\n-     *\n-     * @param name the name to decode\n-     * @return the bytes for string\n-     * @exception ZipException if fail to retrieve bytes for specified string\n-     * @since 1.3\n-     */\n-    protected byte[] getBytes( String name )\n-        throws ZipException\n-    {\n-        if( m_encoding == null )\n-        {\n-            return name.getBytes();\n-        }\n-        else\n-        {\n-            try\n-            {\n-                return name.getBytes( m_encoding );\n-            }\n-            catch( UnsupportedEncodingException uee )\n-            {\n-                throw new ZipException( uee.getMessage() );\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Writes the &quot;End of central dir record&quot;\n-     *\n-     * @exception IOException when an IO erro causes operation to fail\n-     * @since 1.1\n-     */\n-    protected void writeCentralDirectoryEnd()\n-        throws IOException\n-    {\n-        out.write( EOCD_SIG.getBytes() );\n-\n-        // disk numbers\n-        out.write( ZERO );\n-        out.write( ZERO );\n-\n-        // number of entries\n-        byte[] num = ( new ZipShort( m_entries.size() ) ).getBytes();\n-        out.write( num );\n-        out.write( num );\n-\n-        // length and location of CD\n-        out.write( m_cdLength.getBytes() );\n-        out.write( m_cdOffset.getBytes() );\n-\n-        // ZIP file comment\n-        byte[] data = getBytes( m_comment );\n-        out.write( ( new ZipShort( data.length ) ).getBytes() );\n-        out.write( data );\n-    }\n-\n-    /**\n-     * Writes the central file header entry\n-     *\n-     * @param entry the zip entry\n-     * @throws IOException when an IO error causes operation to fail\n-     * @since 1.1\n-     */\n-    protected void writeCentralFileHeader( final ZipArchiveEntry entry )\n-        throws IOException\n-    {\n-        out.write( CFH_SIG.getBytes() );\n-        m_written += 4;\n-\n-        // version made by\n-        out.write( ( new ZipShort( 20 ) ).getBytes() );\n-        m_written += 2;\n+    protected static final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\n+\n+    /**\n+     * Writes next block of compressed data to the output stream.\n+     * @throws IOException on error\n+     *\n+     * @since 1.14\n+     */\n+    protected final void deflate() throws IOException {\n+        int len = def.deflate(buf, 0, buf.length);\n+        if (len > 0) {\n+            writeOut(buf, 0, len);\n+        }\n+    }\n+\n+    /**\n+     * Writes the local file header entry\n+     * @param ze the entry to write\n+     * @throws IOException on error\n+     *\n+     * @since 1.1\n+     */\n+    protected void writeLocalFileHeader(ZipEntry ze) throws IOException {\n+        offsets.put(ze, ZipLong.getBytes(written));\n+\n+        writeOut(LFH_SIG);\n+        written += WORD;\n+\n+        //store method in local variable to prevent multiple method calls\n+        final int zipMethod = ze.getMethod();\n \n         // version needed to extract\n         // general purpose bit flag\n-        if( entry.getMethod() == DEFLATED )\n-        {\n+        // CheckStyle:MagicNumber OFF\n+        if (zipMethod == DEFLATED && raf == null) {\n             // requires version 2 as we are going to store length info\n             // in the data descriptor\n-            out.write( ( new ZipShort( 20 ) ).getBytes() );\n+            writeOut(ZipShort.getBytes(20));\n \n             // bit3 set to signal, we use a data descriptor\n-            out.write( ( new ZipShort( 8 ) ).getBytes() );\n-        }\n-        else\n-        {\n-            out.write( ( new ZipShort( 10 ) ).getBytes() );\n-            out.write( ZERO );\n-        }\n-        m_written += 4;\n+            writeOut(ZipShort.getBytes(8));\n+        } else {\n+            writeOut(ZipShort.getBytes(10));\n+            writeOut(ZERO);\n+        }\n+        // CheckStyle:MagicNumber ON\n+        written += WORD;\n \n         // compression method\n-        out.write( ( new ZipShort( entry.getMethod() ) ).getBytes() );\n-        m_written += 2;\n+        writeOut(ZipShort.getBytes(zipMethod));\n+        written += SHORT;\n \n         // last mod. time and date\n-        out.write( toDosTime( new Date( entry.getTime() ) ).getBytes() );\n-        m_written += 4;\n+        writeOut(toDosTime(ze.getTime()));\n+        written += WORD;\n \n         // CRC\n         // compressed length\n         // uncompressed length\n-        out.write( ( new ZipLong( entry.getCrc() ) ).getBytes() );\n-        out.write( ( new ZipLong( entry.getCompressedSize() ) ).getBytes() );\n-        out.write( ( new ZipLong( entry.getSize() ) ).getBytes() );\n-        m_written += 12;\n+        localDataStart = written;\n+        if (zipMethod == DEFLATED || raf != null) {\n+            writeOut(LZERO);\n+            writeOut(LZERO);\n+            writeOut(LZERO);\n+        } else {\n+            writeOut(ZipLong.getBytes(ze.getCrc()));\n+            writeOut(ZipLong.getBytes(ze.getSize()));\n+            writeOut(ZipLong.getBytes(ze.getSize()));\n+        }\n+        // CheckStyle:MagicNumber OFF\n+        written += 12;\n+        // CheckStyle:MagicNumber ON\n \n         // file name length\n-        byte[] name = getBytes( entry.getName() );\n-        out.write( ( new ZipShort( name.length ) ).getBytes() );\n-        m_written += 2;\n+        byte[] name = getBytes(ze.getName());\n+        writeOut(ZipShort.getBytes(name.length));\n+        written += SHORT;\n \n         // extra field length\n-        byte[] extra = entry.getCentralDirectoryExtra();\n-        out.write( ( new ZipShort( extra.length ) ).getBytes() );\n-        m_written += 2;\n-\n-        // file comment length\n-        String comm = entry.getComment();\n-        if( comm == null )\n-        {\n-            comm = \"\";\n-        }\n-        byte[] comment = getBytes( comm );\n-        out.write( ( new ZipShort( comment.length ) ).getBytes() );\n-        m_written += 2;\n-\n-        // disk number start\n-        out.write( ZERO );\n-        m_written += 2;\n-\n-        // internal file attributes\n-        out.write( ( new ZipShort( entry.getInternalAttributes() ) ).getBytes() );\n-        m_written += 2;\n-\n-        // external file attributes\n-        out.write( ( new ZipLong( entry.getExternalAttributes() ) ).getBytes() );\n-        m_written += 4;\n-\n-        // relative offset of LFH\n-        out.write( ( (ZipLong)m_offsets.get( entry ) ).getBytes() );\n-        m_written += 4;\n+        byte[] extra = ze.getLocalFileDataExtra();\n+        writeOut(ZipShort.getBytes(extra.length));\n+        written += SHORT;\n \n         // file name\n-        out.write( name );\n-        m_written += name.length;\n+        writeOut(name);\n+        written += name.length;\n \n         // extra field\n-        out.write( extra );\n-        m_written += extra.length;\n-\n-        // file comment\n-        out.write( comment );\n-        m_written += comment.length;\n-    }\n-\n-    /**\n-     * Writes the data descriptor entry\n-     *\n-     * @param ze Description of Parameter\n-     * @throws IOException if an IO failure causes operation to fail\n-     * @since 1.1\n-     */\n-    protected void writeDataDescriptor( ZipArchiveEntry ze )\n-        throws IOException\n-    {\n-        if( ze.getMethod() != DEFLATED )\n-        {\n+        writeOut(extra);\n+        written += extra.length;\n+\n+        dataStart = written;\n+    }\n+\n+    /**\n+     * Writes the data descriptor entry.\n+     * @param ze the entry to write\n+     * @throws IOException on error\n+     *\n+     * @since 1.1\n+     */\n+    protected void writeDataDescriptor(ZipEntry ze) throws IOException {\n+        if (ze.getMethod() != DEFLATED || raf != null) {\n             return;\n         }\n-        out.write( DD_SIG.getBytes() );\n-        out.write( ( new ZipLong( m_entry.getCrc() ) ).getBytes() );\n-        out.write( ( new ZipLong( m_entry.getCompressedSize() ) ).getBytes() );\n-        out.write( ( new ZipLong( m_entry.getSize() ) ).getBytes() );\n-        m_written += 16;\n-    }\n-\n-    /**\n-     * Writes the local file header entry\n-     *\n-     * @param entry the zip entry\n-     * @exception IOException when an IO error causes operation to fail\n-     * @since 1.1\n-     */\n-    protected void writeLocalFileHeader( final ZipArchiveEntry entry )\n-        throws IOException\n-    {\n-        m_offsets.put( entry, new ZipLong( m_written ) );\n-\n-        out.write( LFH_SIG.getBytes() );\n-        m_written += 4;\n+        writeOut(DD_SIG);\n+        writeOut(ZipLong.getBytes(entry.getCrc()));\n+        writeOut(ZipLong.getBytes(entry.getCompressedSize()));\n+        writeOut(ZipLong.getBytes(entry.getSize()));\n+        // CheckStyle:MagicNumber OFF\n+        written += 16;\n+        // CheckStyle:MagicNumber ON\n+    }\n+\n+    /**\n+     * Writes the central file header entry.\n+     * @param ze the entry to write\n+     * @throws IOException on error\n+     *\n+     * @since 1.1\n+     */\n+    protected void writeCentralFileHeader(ZipEntry ze) throws IOException {\n+        writeOut(CFH_SIG);\n+        written += WORD;\n+\n+        // version made by\n+        // CheckStyle:MagicNumber OFF\n+        writeOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\n+        written += SHORT;\n \n         // version needed to extract\n         // general purpose bit flag\n-        if( entry.getMethod() == DEFLATED )\n-        {\n+        if (ze.getMethod() == DEFLATED && raf == null) {\n             // requires version 2 as we are going to store length info\n             // in the data descriptor\n-            out.write( ( new ZipShort( 20 ) ).getBytes() );\n+            writeOut(ZipShort.getBytes(20));\n \n             // bit3 set to signal, we use a data descriptor\n-            out.write( ( new ZipShort( 8 ) ).getBytes() );\n-        }\n-        else\n-        {\n-            out.write( ( new ZipShort( 10 ) ).getBytes() );\n-            out.write( ZERO );\n-        }\n-        m_written += 4;\n+            writeOut(ZipShort.getBytes(8));\n+        } else {\n+            writeOut(ZipShort.getBytes(10));\n+            writeOut(ZERO);\n+        }\n+        // CheckStyle:MagicNumber ON\n+        written += WORD;\n \n         // compression method\n-        out.write( ( new ZipShort( entry.getMethod() ) ).getBytes() );\n-        m_written += 2;\n+        writeOut(ZipShort.getBytes(ze.getMethod()));\n+        written += SHORT;\n \n         // last mod. time and date\n-        out.write( toDosTime( new Date( entry.getTime() ) ).getBytes() );\n-        m_written += 4;\n+        writeOut(toDosTime(ze.getTime()));\n+        written += WORD;\n \n         // CRC\n         // compressed length\n         // uncompressed length\n-        if( entry.getMethod() == DEFLATED )\n-        {\n-            out.write( LZERO );\n-            out.write( LZERO );\n-            out.write( LZERO );\n-        }\n-        else\n-        {\n-            out.write( ( new ZipLong( entry.getCrc() ) ).getBytes() );\n-            out.write( ( new ZipLong( entry.getSize() ) ).getBytes() );\n-            out.write( ( new ZipLong( entry.getSize() ) ).getBytes() );\n-        }\n-        m_written += 12;\n+        writeOut(ZipLong.getBytes(ze.getCrc()));\n+        writeOut(ZipLong.getBytes(ze.getCompressedSize()));\n+        writeOut(ZipLong.getBytes(ze.getSize()));\n+        // CheckStyle:MagicNumber OFF\n+        written += 12;\n+        // CheckStyle:MagicNumber ON\n \n         // file name length\n-        byte[] name = getBytes( entry.getName() );\n-        out.write( ( new ZipShort( name.length ) ).getBytes() );\n-        m_written += 2;\n+        byte[] name = getBytes(ze.getName());\n+        writeOut(ZipShort.getBytes(name.length));\n+        written += SHORT;\n \n         // extra field length\n-        byte[] extra = entry.getLocalFileDataExtra();\n-        out.write( ( new ZipShort( extra.length ) ).getBytes() );\n-        m_written += 2;\n+        byte[] extra = ze.getCentralDirectoryExtra();\n+        writeOut(ZipShort.getBytes(extra.length));\n+        written += SHORT;\n+\n+        // file comment length\n+        String comm = ze.getComment();\n+        if (comm == null) {\n+            comm = \"\";\n+        }\n+        byte[] commentB = getBytes(comm);\n+        writeOut(ZipShort.getBytes(commentB.length));\n+        written += SHORT;\n+\n+        // disk number start\n+        writeOut(ZERO);\n+        written += SHORT;\n+\n+        // internal file attributes\n+        writeOut(ZipShort.getBytes(ze.getInternalAttributes()));\n+        written += SHORT;\n+\n+        // external file attributes\n+        writeOut(ZipLong.getBytes(ze.getExternalAttributes()));\n+        written += WORD;\n+\n+        // relative offset of LFH\n+        writeOut((byte[]) offsets.get(ze));\n+        written += WORD;\n \n         // file name\n-        out.write( name );\n-        m_written += name.length;\n+        writeOut(name);\n+        written += name.length;\n \n         // extra field\n-        out.write( extra );\n-        m_written += extra.length;\n-\n-        m_dataStart = m_written;\n+        writeOut(extra);\n+        written += extra.length;\n+\n+        // file comment\n+        writeOut(commentB);\n+        written += commentB.length;\n+    }\n+\n+    /**\n+     * Writes the &quot;End of central dir record&quot;.\n+     * @throws IOException on error\n+     *\n+     * @since 1.1\n+     */\n+    protected void writeCentralDirectoryEnd() throws IOException {\n+        writeOut(EOCD_SIG);\n+\n+        // disk numbers\n+        writeOut(ZERO);\n+        writeOut(ZERO);\n+\n+        // number of entries\n+        byte[] num = ZipShort.getBytes(entries.size());\n+        writeOut(num);\n+        writeOut(num);\n+\n+        // length and location of CD\n+        writeOut(ZipLong.getBytes(cdLength));\n+        writeOut(ZipLong.getBytes(cdOffset));\n+\n+        // ZIP file comment\n+        byte[] data = getBytes(comment);\n+        writeOut(ZipShort.getBytes(data.length));\n+        writeOut(data);\n+    }\n+\n+    /**\n+     * Smallest date/time ZIP can handle.\n+     *\n+     * @since 1.1\n+     */\n+    private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n+\n+    /**\n+     * Convert a Date object to a DOS date/time field.\n+     * @param time the <code>Date</code> to convert\n+     * @return the date as a <code>ZipLong</code>\n+     * @since 1.1\n+     */\n+    protected static ZipLong toDosTime(Date time) {\n+        return new ZipLong(toDosTime(time.getTime()));\n+    }\n+\n+    /**\n+     * Convert a Date object to a DOS date/time field.\n+     *\n+     * <p>Stolen from InfoZip's <code>fileio.c</code></p>\n+     * @param t number of milliseconds since the epoch\n+     * @return the date as a byte array\n+     * @since 1.26\n+     */\n+    protected static byte[] toDosTime(long t) {\n+        Date time = new Date(t);\n+        // CheckStyle:MagicNumberCheck OFF - I do not think that using constants\n+        //                                   here will improve the readablity\n+        int year = time.getYear() + 1900;\n+        if (year < 1980) {\n+            return DOS_TIME_MIN;\n+        }\n+        int month = time.getMonth() + 1;\n+        long value =  ((year - 1980) << 25)\n+            |         (month << 21)\n+            |         (time.getDate() << 16)\n+            |         (time.getHours() << 11)\n+            |         (time.getMinutes() << 5)\n+            |         (time.getSeconds() >> 1);\n+        return ZipLong.getBytes(value);\n+        // CheckStyle:MagicNumberCheck ON\n+    }\n+\n+    /**\n+     * Retrieve the bytes for the given String in the encoding set for\n+     * this Stream.\n+     * @param name the string to get bytes from\n+     * @return the bytes as a byte array\n+     * @throws ZipException on error\n+     *\n+     * @since 1.3\n+     */\n+    protected byte[] getBytes(String name) throws ZipException {\n+        if (encoding == null) {\n+            return name.getBytes();\n+        } else {\n+            try {\n+                return name.getBytes(encoding);\n+            } catch (UnsupportedEncodingException uee) {\n+                throw new ZipException(uee.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write bytes to output or random access file.\n+     * @param data the byte array to write\n+     * @throws IOException on error\n+     *\n+     * @since 1.14\n+     */\n+    protected final void writeOut(byte[] data) throws IOException {\n+        writeOut(data, 0, data.length);\n+    }\n+\n+    /**\n+     * Write bytes to output or random access file.\n+     * @param data the byte array to write\n+     * @param offset the start position to write from\n+     * @param length the number of bytes to write\n+     * @throws IOException on error\n+     *\n+     * @since 1.14\n+     */\n+    protected final void writeOut(byte[] data, int offset, int length)\n+        throws IOException {\n+        if (raf != null) {\n+            raf.write(data, offset, length);\n+        } else {\n+            out.write(data, offset, length);\n+        }\n+    }\n+\n+    /**\n+     * Assumes a negative integer really is a positive integer that\n+     * has wrapped around and re-creates the original value.\n+     * @param i the value to treat as unsigned int.\n+     * @return the unsigned int as a long.\n+     * @since 1.34\n+     */\n+    protected static long adjustToLong(int i) {\n+        if (i < 0) {\n+            return 2 * ((long) Integer.MAX_VALUE) + 2 + i;\n+        } else {\n+            return i;\n+        }\n+    }\n+\n+    private void deflateUntilInputIsNeeded() throws IOException {\n+        while (!def.needsInput()) {\n+            deflate();\n+        }\n     }\n \n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n /*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n  *\n- * http://www.apache.org/licenses/LICENSE-2.0\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n  *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n  */\n package org.apache.commons.compress.archivers.zip;\n \n /**\n- * Utility class that represents a two byte integer with conversion rules for\n- * the big endian byte order of ZIP files.\n+ * Utility class that represents a two byte integer with conversion\n+ * rules for the big endian byte order of ZIP files.\n+ *\n  */\n-public final class ZipShort implements Cloneable\n-{\n-    private int m_value;\n+public final class ZipShort implements Cloneable {\n+    private static final int BYTE_MASK = 0xFF;\n+    private static final int BYTE_1_MASK = 0xFF00;\n+    private static final int BYTE_1_SHIFT = 8;\n+\n+    private int value;\n \n     /**\n      * Create instance from a number.\n-     *\n-     * @param value Description of Parameter\n+     * @param value the int to store as a ZipShort\n      * @since 1.1\n      */\n-    public ZipShort( int value )\n-    {\n-        this.m_value = value;\n+    public ZipShort (int value) {\n+        this.value = value;\n     }\n \n     /**\n      * Create instance from bytes.\n-     *\n-     * @param bytes Description of Parameter\n+     * @param bytes the bytes to store as a ZipShort\n      * @since 1.1\n      */\n-    public ZipShort( byte[] bytes )\n-    {\n-        this( bytes, 0 );\n+    public ZipShort (byte[] bytes) {\n+        this(bytes, 0);\n     }\n \n     /**\n      * Create instance from the two bytes starting at offset.\n-     *\n-     * @param bytes Description of Parameter\n-     * @param offset Description of Parameter\n+     * @param bytes the bytes to store as a ZipShort\n+     * @param offset the offset to start\n      * @since 1.1\n      */\n-    public ZipShort( byte[] bytes, int offset )\n-    {\n-        m_value = ( bytes[ offset + 1 ] << 8 ) & 0xFF00;\n-        m_value += ( bytes[ offset ] & 0xFF );\n+    public ZipShort (byte[] bytes, int offset) {\n+        value = ZipShort.getValue(bytes, offset);\n     }\n \n     /**\n      * Get value as two bytes in big endian byte order.\n-     *\n-     * @return The Bytes value\n+     * @return the value as a a two byte array in big endian byte order\n      * @since 1.1\n      */\n-    public byte[] getBytes()\n-    {\n-        byte[] result = new byte[ 2 ];\n-        result[ 0 ] = (byte)( m_value & 0xFF );\n-        result[ 1 ] = (byte)( ( m_value & 0xFF00 ) >> 8 );\n+    public byte[] getBytes() {\n+        byte[] result = new byte[2];\n+        result[0] = (byte) (value & BYTE_MASK);\n+        result[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\n         return result;\n     }\n \n     /**\n      * Get value as Java int.\n-     *\n-     * @return The Value value\n+     * @return value as a Java int\n      * @since 1.1\n      */\n-    public int getValue()\n-    {\n-        return m_value;\n+    public int getValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Get value as two bytes in big endian byte order.\n+     * @param value the Java int to convert to bytes\n+     * @return the converted int as a byte array in big endian byte order\n+     */\n+    public static byte[] getBytes(int value) {\n+        byte[] result = new byte[2];\n+        result[0] = (byte) (value & BYTE_MASK);\n+        result[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\n+        return result;\n+    }\n+\n+    /**\n+     * Helper method to get the value as a java int from two bytes starting at given array offset\n+     * @param bytes the array of bytes\n+     * @param offset the offset to start\n+     * @return the correspondanding java int value\n+     */\n+    public static int getValue(byte[] bytes, int offset) {\n+        int value = (bytes[offset + 1] << BYTE_1_SHIFT) & BYTE_1_MASK;\n+        value += (bytes[offset] & BYTE_MASK);\n+        return value;\n+    }\n+\n+    /**\n+     * Helper method to get the value as a java int from a two-byte array\n+     * @param bytes the array of bytes\n+     * @return the correspondanding java int value\n+     */\n+    public static int getValue(byte[] bytes) {\n+        return getValue(bytes, 0);\n     }\n \n     /**\n      * Override to make two instances with same value equal.\n-     *\n-     * @param o Description of Parameter\n-     * @return Description of the Returned Value\n+     * @param o an object to compare\n+     * @return true if the objects are equal\n      * @since 1.1\n      */\n-    public boolean equals( Object o )\n-    {\n-        if( o == null || !( o instanceof ZipShort ) )\n-        {\n+    public boolean equals(Object o) {\n+        if (o == null || !(o instanceof ZipShort)) {\n             return false;\n         }\n-        return m_value == ( (ZipShort)o ).getValue();\n+        return value == ((ZipShort) o).getValue();\n     }\n \n     /**\n      * Override to make two instances with same value equal.\n-     *\n-     * @return Description of the Returned Value\n+     * @return the value stored in the ZipShort\n      * @since 1.1\n      */\n-    public int hashCode()\n-    {\n-        return m_value;\n+    public int hashCode() {\n+        return value;\n     }\n }", "timestamp": 1231758934, "metainfo": ""}