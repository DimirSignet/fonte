{"sha": "39c93f49db5bc064eba73478c339c5aee61de3fd", "log": "Trailing spaces  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveInputStream.java\n \n     private byte[] SINGLE = new byte[1];\n     private static final int BYTE_MASK = 0xFF;\n-    \n+\n     /** holds the number of bytes read in this stream */\n     private long bytesRead = 0;\n \n         int num = read(SINGLE, 0, 1);\n         return num == -1 ? -1 : SINGLE[0] & BYTE_MASK;\n     }\n-    \n+\n     /**\n      * Increments the counter of already read bytes.\n      * Doesn't increment if the EOF has been hit (read == -1)\n             bytesRead = bytesRead + read;\n         }\n     }\n-    \n+\n     /**\n      * Decrements the counter of already read bytes.\n      * \n     protected void pushedBackBytes(long pushedBack) {\n         bytesRead -= pushedBack;\n     }\n-    \n+\n     /**\n      * Returns the current number of bytes read from this stream.\n      * @return the number of read bytes\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveOutputStream.java\n  * </p>\n  */\n public abstract class ArchiveOutputStream extends OutputStream {\n-    \n+\n     /** Temporary buffer used for the {@link #write(int)} method */\n     private final byte[] oneByte = new byte[1];\n     static final int BYTE_MASK = 0xFF;\n     /** holds the number of bytes written to this stream */\n     private long bytesWritten = 0;\n     // Methods specific to ArchiveOutputStream\n-    \n+\n     /**\n      * Writes the headers for an archive entry to the output stream.\n      * The caller must then write the content to the stream and call\n      * @throws IOException\n      */\n     public abstract void closeArchiveEntry() throws IOException;\n-    \n+\n     /**\n      * Finishes the addition of entries to this stream, without closing it.\n      * Additional data can be written, if the format supports it.\n      * @throws IOException\n      */\n     public abstract ArchiveEntry createArchiveEntry(File inputFile, String entryName) throws IOException;\n-    \n+\n     // Generic implementations of OutputStream methods that may be useful to sub-classes\n-    \n+\n     /**\n      * Writes a byte to the current archive entry.\n      *\n             bytesWritten = bytesWritten + written;\n         }\n     }\n-    \n+\n     /**\n      * Returns the current number of bytes written to this stream.\n      * @return the number of written bytes\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n     public ArchiveInputStream createArchiveInputStream(\n             final String archiverName, final InputStream in)\n             throws ArchiveException {\n-        \n+\n         if (archiverName == null) {\n             throw new IllegalArgumentException(\"Archivername must not be null.\");\n         }\n-        \n+\n         if (in == null) {\n             throw new IllegalArgumentException(\"InputStream must not be null.\");\n         }\n         if (DUMP.equalsIgnoreCase(archiverName)) {\n             return new DumpArchiveInputStream(in);\n         }\n-        \n+\n         throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/Lister.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/Lister.java\n  */\n public final class Lister {\n     private static final ArchiveStreamFactory factory = new ArchiveStreamFactory();\n-    \n+\n     public static void main(String[] args) throws Exception {\n         if (args.length == 0) {\n             usage();\n \n     private static void usage() {\n         System.out.println(\"Parameters: archive-name [archive-type]\");\n-        \n     }\n \n }\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n         ret.setInode(readBinaryLong(2, swapHalfWord));\n         final long mode = readBinaryLong(2, swapHalfWord);\n         if (mode != 0){\n-            ret.setMode(mode);            \n+            ret.setMode(mode);\n         }\n         ret.setUID(readBinaryLong(2, swapHalfWord));\n         ret.setGID(readBinaryLong(2, swapHalfWord));\n      * Checks if the signature matches one of the following magic values:\n      * \n      * Strings:\n-     *  \n+     *\n      * \"070701\" - MAGIC_NEW\n      * \"070702\" - MAGIC_NEW_CRC\n      * \"070707\" - MAGIC_OLD_ASCII\n         if (length < 6) {\n             return false;\n         }\n-        \n+\n         // Check binary values\n         if (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) {\n             return true;\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n      *            The format of the stream\n      * @param blockSize\n      *            The block size of the archive.\n-     *            \n+     * \n      * @since Apache Commons Compress 1.1\n      */\n     public CpioArchiveOutputStream(final OutputStream out, final short format,\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioConstants.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioConstants.java\n     final int MAGIC_OLD_BINARY = 070707;\n \n     // These FORMAT_ constants are internal to the code\n-    \n+\n     /** write/read a CPIOArchiveEntry in the new format */\n     final short FORMAT_NEW = 1;\n \n     /*\n      * Constants for the MODE bits\n      */\n-    \n+\n     /** Mask for all file type bits. */\n     final int S_IFMT   = 0170000;\n \n \n     /** Permits others to execute the file or to search the directory */\n     final int C_IXOTH  = 0000001;\n-    \n \n     /** The special trailer marker */\n     final String CPIO_TRAILER = \"TRAILER!!!\";\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioUtil.java\n      * \n      * @param number \n      *            the input long number to be converted\n-     *            \n+     * \n      * @param length\n      *            The length of the returned array\n      * @param swapHalfWord\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveConstants.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveConstants.java\n         ADDR(4),\n         END(5),\n         CLRI(6);\n-   \n+\n         int code;\n \n         private SEGMENT_TYPE(int code) {\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveEntry.java\n             return type;\n         }\n     }\n-    \n+\n     public enum PERMISSION {\n         SETUID(04000),\n         SETGUI(02000),\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n \n     /** Indicates if putArchiveEntry has been called without closeArchiveEntry */\n     private boolean haveUnclosedEntry = false;\n-    \n+\n     /** indicates if this archive is finished */\n     private boolean finished = false;\n-    \n+\n     private final OutputStream out;\n \n     private final ZipEncoding encoding;\n         if (finished) {\n             throw new IOException(\"This archive has already been finished\");\n         }\n-        \n+\n         if(haveUnclosedEntry) {\n             throw new IOException(\"This archives contains unclosed entries.\");\n         }\n         if(!finished) {\n             finish();\n         }\n-        \n+\n         if (!closed) {\n             buffer.close();\n             out.close();\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarBuffer.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarBuffer.java\n \n     private int             currBlkIdx;\n     private int             currRecIdx;\n-    \n+\n     /**\n      * Constructor for a TarBuffer on an input stream.\n      * @param inStream the input stream to use\n      */\n     private TarBuffer(InputStream inStream, OutputStream outStream, int blockSize, int recordSize) {\n         this.inStream = inStream;\n-        this.outStream = outStream;        \n+        this.outStream = outStream;\n         this.blockSize = blockSize;\n         this.recordSize = recordSize;\n         this.recsPerBlock = (this.blockSize / this.recordSize);\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarConstants.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarConstants.java\n      * @since Apache Commons Compress 1.1\n      */\n     byte LF_PAX_EXTENDED_HEADER_UC = (byte) 'X';\n-    \n+\n     /**\n      * Identifies the entry as a Pax global extended header.\n      *\n      * @since Apache Commons Compress 1.1\n      */\n     byte LF_PAX_GLOBAL_EXTENDED_HEADER = (byte) 'g';\n-    \n+\n     /**\n      * The magic tag representing a POSIX tar archive.\n      */\n      * @since Apache Commons Compress 1.1\n      */\n     String MAGIC_ANT = \"ustar\\0\";\n-    \n+\n     /**\n      * The \"version\" representing an Ant tar archive.\n      *\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n         };\n \n     /** Private constructor to prevent instantiation of this utility class. */\n-    private TarUtils(){    \n+    private TarUtils(){\n     }\n \n     /**\n     public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n \n         int idx=length-1; // For space\n-        \n+\n         formatUnsignedOctalString(value, buf, offset, idx);\n         buf[offset + idx] = (byte) ' '; // Trailing space\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnsupportedZipFeatureException.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnsupportedZipFeatureException.java\n          * The entry uses a data descriptor.\n          */\n         public static final Feature DATA_DESCRIPTOR = new Feature(\"data descriptor\");\n-        \n+\n         private final String name;\n \n         private Feature(String name) {\n--- a/src/main/java/org/apache/commons/compress/changes/ChangeSet.java\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSet.java\n     public void deleteDir(final String dirName) {\n         addDeletion(new Change(dirName, Change.TYPE_DELETE_DIR));\n     }\n-    \n+\n     /**\n      * Adds a new archive entry to the archive.\n      * \n     public void add(final ArchiveEntry pEntry, final InputStream pInput) {\n         this.add(pEntry, pInput, true);\n     }\n-    \n+\n     /**\n      * Adds a new archive entry to the archive.\n      * If replace is set to true, this change will replace all other additions\n      * @param pInput\n      *            the datastream to add\n      * @param replace\n-     *            indicates the this change should replace existing entries            \n+     *            indicates the this change should replace existing entries\n      */\n     public void add(final ArchiveEntry pEntry, final InputStream pInput, final boolean replace) {\n         addAddition(new Change(pEntry, pInput, replace));\n      *            the change which should result in an addition\n      */\n     private void addAddition(Change pChange) {\n-        if (Change.TYPE_ADD != pChange.type() ||    \n+        if (Change.TYPE_ADD != pChange.type() ||\n             pChange.getInput() == null) {\n             return;\n         }\n         }\n         changes.add(pChange);\n     }\n-    \n+\n     /**\n      * Adds an delete change.\n      * \n      */\n     private void addDeletion(Change pChange) {\n         if ((Change.TYPE_DELETE != pChange.type() &&\n-            Change.TYPE_DELETE_DIR != pChange.type()) ||    \n+            Change.TYPE_DELETE_DIR != pChange.type()) ||\n             pChange.targetFile() == null) {\n             return;\n         }\n--- a/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java\n  */\n public class ChangeSetPerformer {\n     private final Set<Change> changes;\n-    \n+\n     /**\n      * Constructs a ChangeSetPerformer with the changes from this ChangeSet\n      * @param changeSet the ChangeSet which operations are used for performing\n     public ChangeSetPerformer(final ChangeSet changeSet) {\n         changes = changeSet.getChanges();\n     }\n-    \n+\n     /**\n      * Performs all changes collected in this ChangeSet on the input stream and\n      * streams the result to the output stream. Perform may be called more than once.\n     public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n             throws IOException {\n         ChangeSetResults results = new ChangeSetResults();\n-        \n+\n         Set<Change> workingSet = new LinkedHashSet<Change>(changes);\n-        \n+\n         for (Iterator<Change> it = workingSet.iterator(); it.hasNext();) {\n             Change change = it.next();\n \n                 results.addedFromStream(entry.getName());\n             }\n         }\n-        \n+\n         // Adds files which hasn't been added from the original and do not have replace mode on\n         for (Iterator<Change> it = workingSet.iterator(); it.hasNext();) {\n             Change change = it.next();\n--- a/src/main/java/org/apache/commons/compress/changes/ChangeSetResults.java\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSetResults.java\n     private final List<String> addedFromChangeSet = new ArrayList<String>();\n     private final List<String> addedFromStream = new ArrayList<String>();\n     private final List<String> deleted = new ArrayList<String>();\n-    \n+\n     /**\n      * Adds the filename of a recently deleted file to the result list.\n      * @param fileName the file which has been deleted\n     void deleted(String fileName) {\n         deleted.add(fileName);\n     }\n-    \n+\n     /**\n      * Adds the name of a file to the result list which has been \n      * copied from the source stream to the target stream.\n     void addedFromStream(String fileName) {\n         addedFromStream.add(fileName);\n     }\n-    \n+\n     /**\n      * Adds the name of a file to the result list which has been\n      * copied from the changeset to the target stream\n     public List<String> getDeleted() {\n         return deleted;\n     }\n-    \n+\n     /**\n      * Checks if an filename already has been added to the result list\n      * @param filename the filename to check\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorInputStream.java\n \n public abstract class CompressorInputStream extends InputStream {\n     private long bytesRead = 0;\n-    \n+\n     /**\n      * Increments the counter of already read bytes.\n      * Doesn't increment if the EOF has been hit (read == -1)\n     protected void count(int read) {\n         count((long) read);\n     }\n-    \n+\n     /**\n      * Increments the counter of already read bytes.\n      * Doesn't increment if the EOF has been hit (read == -1)\n--- a/src/main/java/org/apache/commons/compress/compressors/FileNameUtil.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/FileNameUtil.java\n      * versions of those file types. For example: from \".tar\" to \".tgz\".\n      */\n     private final Map<String, String> compressSuffix =\n-        new HashMap<String, String>();        \n+        new HashMap<String, String>();\n \n     /**\n      * Map from common filename suffixes of compressed files to the\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n         if (length < 3) {\n             return false;\n         }\n-        \n+\n         if (signature[0] != 'B') {\n             return false;\n         }\n         if (signature[2] != 'h') {\n             return false;\n         }\n-        \n+\n         return true;\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java\n+++ b/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java\n  * Generic Archive utilities\n  */\n public class ArchiveUtils {\n-    \n+\n     /** Private constructor to prevent instantiation of this utility class. */\n-    private ArchiveUtils(){    \n+    private ArchiveUtils(){\n     }\n \n     /**\n         }\n         return isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n     }\n-    \n+\n     /**\n      * Check if buffer contents matches Ascii String.\n      * \n     public static boolean matchAsciiBuffer(String expected, byte[] buffer){\n         return matchAsciiBuffer(expected, buffer, 0, buffer.length);\n     }\n-    \n+\n     /**\n      * Convert a string to Ascii bytes.\n      * Used for comparing \"magic\" strings which need to be independent of the default Locale.\n                     if (buffer2[offset2+i] != 0){\n                         return false;\n                     }\n-                }                \n+                }\n             }\n             return true;\n         }\n         return false;\n     }\n-    \n+\n     /**\n      * Compare byte buffers\n      * \n             final byte[] buffer2, final int offset2, final int length2){\n         return isEqual(buffer1, offset1, length1, buffer2, offset2, length2, false);\n     }\n-    \n+\n     /**\n      * Compare byte buffers\n      * \n     public static boolean isEqual(final byte[] buffer1, final byte[] buffer2 ){\n         return isEqual(buffer1, 0, buffer1.length, buffer2, 0, buffer2.length, false);\n     }\n-    \n+\n     /**\n      * Compare byte buffers, optionally ignoring trailing nulls\n      * \n     public static boolean isEqual(final byte[] buffer1, final byte[] buffer2, boolean ignoreTrailingNulls){\n         return isEqual(buffer1, 0, buffer1.length, buffer2, 0, buffer2.length, ignoreTrailingNulls);\n     }\n-    \n+\n     /**\n      * Compare byte buffers, ignoring trailing nulls\n      * \n             final byte[] buffer2, final int offset2, final int length2){\n         return isEqual(buffer1, offset1, length1, buffer2, offset2, length2, true);\n     }\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/compress/utils/CountingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/CountingInputStream.java\n             bytesRead += read;\n         }\n     }\n-    \n+\n     /**\n      * Returns the current number of bytes read from this stream.\n      * @return the number of read bytes\n--- a/src/main/java/org/apache/commons/compress/utils/CountingOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/CountingOutputStream.java\n             bytesWritten += written;\n         }\n     }\n-    \n+\n     /**\n      * Returns the current number of bytes written to this stream.\n      * @return the number of written bytes\n--- a/src/test/java/org/apache/commons/compress/AbstractTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/AbstractTestCase.java\n \n     private File archive; // used to delete the archive in tearDown\n     protected List<String> archiveList; // Lists the content of the archive as originally created\n-    \n+\n     protected ArchiveStreamFactory factory = new ArchiveStreamFactory();\n \n     public AbstractTestCase() {\n             throws Exception {\n         checkArchiveContent(in, expected, true);\n     }\n-    \n+\n     /**\n      * Checks that an archive input stream can be read, and that the file data matches file sizes.\n      * \n                         copied=IOUtils.copy(in, out);\n                     } finally {\n                         out.close();\n-                    }                    \n+                    }\n                 }\n                 final long size = entry.getSize();\n                 if (size != ArchiveEntry.SIZE_UNKNOWN) {\n             return new File[] {tmpDir, tmpFile};\n         } finally {\n             fos.close();\n-        }            \n+        }\n     }\n }\n--- a/src/test/java/org/apache/commons/compress/ArchiveReadTests.java\n+++ b/src/test/java/org/apache/commons/compress/ArchiveReadTests.java\n  * as JUnit does not allow one to change the display name of a test.\n  */\n public class ArchiveReadTests extends AbstractTestCase {\n-    \n+\n     final static ClassLoader classLoader = ArchiveReadTests.class.getClassLoader();\n \n     private File file;\n     private static final ArrayList<String> fileList = new ArrayList<String>();\n-    \n+\n     public ArchiveReadTests(String name) {\n         super(name);\n     }\n-    \n+\n     private ArchiveReadTests(String name, File file){\n         super(name);\n         this.file = file;\n     }\n-    \n+\n     public static TestSuite suite() throws IOException{\n         TestSuite suite = new TestSuite(\"ArchiveReadTests\");\n         File arcdir =new File(classLoader.getResource(\"archives\").getFile());\n             Test test = new ArchiveReadTests(\"testArchive\", file);\n             namedSuite.addTest(test);\n             suite.addTest(namedSuite);\n-        }        \n+        }\n         return suite;\n     }\n-    \n+\n     // files.txt contains size and filename\n     @Override\n     protected String getExpectedString(ArchiveEntry entry) {\n--- a/src/test/java/org/apache/commons/compress/ArchiveUtilsTest.java\n+++ b/src/test/java/org/apache/commons/compress/ArchiveUtilsTest.java\n         assertTrue(ArchiveUtils.isEqual(buffer1, buffer3));\n         assertTrue(ArchiveUtils.isEqual(buffer3, buffer1));\n     }\n-    \n+\n     public void testCompareAscii(){\n         byte[] buffer1 = {'a','b','c'};\n         byte[] buffer2 = {'d','e','f',0};\n         assertTrue(ArchiveUtils.matchAsciiBuffer(\"abc\", buffer1));\n         assertFalse(ArchiveUtils.matchAsciiBuffer(\"abc\\0\", buffer1));\n-        assertTrue(ArchiveUtils.matchAsciiBuffer(\"def\\0\", buffer2));        \n+        assertTrue(ArchiveUtils.matchAsciiBuffer(\"def\\0\", buffer2));\n         assertFalse(ArchiveUtils.matchAsciiBuffer(\"def\", buffer2));\n     }\n-    \n+\n     public void testAsciiConversions() {\n         asciiToByteAndBackOK(\"\");\n         asciiToByteAndBackOK(\"abcd\");\n--- a/src/test/java/org/apache/commons/compress/DetectArchiverTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/DetectArchiverTestCase.java\n         assertNotNull(cpio);\n         assertTrue(cpio instanceof CpioArchiveInputStream);\n \n-// Not yet implemented        \n+// Not yet implemented\n //        final ArchiveInputStream tgz = getStreamFor(\"bla.tgz\");\n //        assertNotNull(tgz);\n //        assertTrue(tgz instanceof TarArchiveInputStream);\n                    new BufferedInputStream(new FileInputStream(\n                        new File(rsc.getFile()))));\n     }\n-    \n+\n     // Check that the empty archives created by the code are readable\n-    \n+\n     // Not possible to detect empty \"ar\" archive as it is completely empty\n //    public void testEmptyArArchive() throws Exception {\n //        emptyArchive(\"ar\");\n--- a/src/test/java/org/apache/commons/compress/DetectCompressorTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/DetectCompressorTestCase.java\n                    new BufferedInputStream(new FileInputStream(\n                        new File(rsc.getFile()))));\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/compress/IOMethodsTest.java\n+++ b/src/test/java/org/apache/commons/compress/IOMethodsTest.java\n             i += 2;\n         }\n     }\n-    \n+\n     public void testWriteAr() throws Exception {\n         ArchiveEntry entry = new ArArchiveEntry(\"dummy\", bytesToTest);\n         compareWrites(\"ar\", entry);\n         ArchiveOutputStream aos3 = factory.createArchiveOutputStream(archiverName, out3);\n         aos3.putArchiveEntry(entry);\n         for (int i=0; i<byteTest.length; i++){\n-            aos1.write(byteTest[i]);            \n+            aos1.write(byteTest[i]);\n         }\n         aos1.closeArchiveEntry();\n         aos1.close();\n         aos2.write(byteTest);\n         aos2.closeArchiveEntry();\n         aos2.close();\n-        \n+\n         aos3.write(byteTest, 0, byteTest.length);\n         aos3.closeArchiveEntry();\n         aos3.close();\n         assertEquals(\"out1!=out2\",out1.toString(),out2.toString());\n         assertEquals(\"out1!=out3\",out1.toString(),out3.toString());\n     }\n-    \n+\n     private void compareReads(String archiverName) throws Exception {\n         OutputStream out1 = new ByteArrayOutputStream();\n         OutputStream out2 = new ByteArrayOutputStream();\n         OutputStream out3 = new ByteArrayOutputStream();\n         File file = createSingleEntryArchive(archiverName);\n         file.deleteOnExit();\n-        \n+\n         InputStream is1 = new FileInputStream(file);\n         ArchiveInputStream ais1 = factory.createArchiveInputStream(archiverName, is1);\n         final ArchiveEntry nextEntry = ais1.getNextEntry();\n         assertNotNull(nextEntry);\n-        \n+\n         byte [] buff = new byte[10]; // small so multiple reads are needed;\n         long size = nextEntry.getSize();\n         if (size != ArchiveEntry.SIZE_UNKNOWN) {\n             assertTrue(\"Size should be > 0, found: \"+size, size > 0);\n         }\n-        \n+\n         InputStream is2 = new FileInputStream(file);\n         ArchiveInputStream ais2 = factory.createArchiveInputStream(archiverName, is2);\n         final ArchiveEntry nextEntry2 = ais2.getNextEntry();\n             out2.write(buff, 0, bytes);\n         }\n         ais2.close();\n-        \n+\n         while((bytes=ais3.read(buff, 0 , buff.length)) > 0){\n             out3.write(buff, 0, bytes);\n         }\n--- a/src/test/java/org/apache/commons/compress/archivers/ArchiveOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ArchiveOutputStreamTest.java\n \n     public void testFinish() throws Exception {\n         OutputStream out1 = new ByteArrayOutputStream();\n-        \n+\n         ArchiveOutputStream aos1 = factory.createArchiveOutputStream(\"zip\", out1);\n         aos1.putArchiveEntry(new ZipArchiveEntry(\"dummy\"));\n         try {\n         } catch (IOException io) {\n             // Exception expected\n         }\n-        \n+\n         aos1 = factory.createArchiveOutputStream(\"jar\", out1);\n         aos1.putArchiveEntry(new JarArchiveEntry(\"dummy\"));\n         try {\n         } catch (IOException io) {\n             // Exception expected\n         }\n-        \n+\n         aos1 = factory.createArchiveOutputStream(\"ar\", out1);\n         aos1.putArchiveEntry(new ArArchiveEntry(\"dummy\", 100));\n         try {\n         } catch (IOException io) {\n             // Exception expected\n         }\n-        \n+\n         aos1 = factory.createArchiveOutputStream(\"cpio\", out1);\n         aos1.putArchiveEntry(new CpioArchiveEntry(\"dummy\"));\n         try {\n         } catch (IOException io) {\n             // Exception expected\n         }\n-        \n+\n         aos1 = factory.createArchiveOutputStream(\"tar\", out1);\n         aos1.putArchiveEntry(new TarArchiveEntry(\"dummy\"));\n         try {\n \n     public void testOptionalFinish() throws Exception {\n         OutputStream out1 = new ByteArrayOutputStream();\n-        \n+\n         ArchiveOutputStream aos1 = factory.createArchiveOutputStream(\"zip\", out1);\n         aos1.putArchiveEntry(new ZipArchiveEntry(\"dummy\"));\n         aos1.closeArchiveEntry();\n         aos1.close();\n-        \n+\n         aos1 = factory.createArchiveOutputStream(\"jar\", out1);\n         aos1.putArchiveEntry(new JarArchiveEntry(\"dummy\"));\n         aos1.closeArchiveEntry();\n             // Exception expected\n         }\n     }\n-    \n+\n     public void testCallSequenceAr() throws Exception{\n         doCallSequence(\"Ar\");\n     }\n     private void doCallSequence(String archiveType) throws Exception {\n         OutputStream out1 = new ByteArrayOutputStream();\n         File dummy = getFile(\"test1.xml\"); // need a real file\n-        \n+\n         ArchiveOutputStream aos1;\n         aos1 = factory.createArchiveOutputStream(archiveType, out1);\n         aos1.putArchiveEntry(aos1.createArchiveEntry(dummy, \"dummy\"));\n         aos1.close(); // omitted finish\n \n         // TODO - check if archives ensure that data has been written to the stream?\n-        \n+\n         aos1 = factory.createArchiveOutputStream(archiveType, out1);\n         try {\n             aos1.closeArchiveEntry();\n         is.close();\n \n         // TODO check if second putArchiveEntry() can follow without closeAE?\n-        \n+\n         try {\n             aos1.finish();\n             fail(\"Should have raised IOException - finish() called before closeArchiveEntry()\");\n--- a/src/test/java/org/apache/commons/compress/archivers/CpioTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/CpioTestCase.java\n         final File file2 = getFile(\"test2.xml\");\n         final long file1Length = file1.length();\n         final long file2Length = file2.length();\n-        \n+\n         {\n             final OutputStream out = new FileOutputStream(output);\n             final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\"cpio\", out);\n--- a/src/test/java/org/apache/commons/compress/archivers/ExceptionMessageTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ExceptionMessageTest.java\n public class ExceptionMessageTest extends TestCase {\n \n     private static final String ARCHIVER_NULL_MESSAGE = \"Archivername must not be null.\";\n-    \n+\n     private static final String INPUTSTREAM_NULL_MESSAGE = \"InputStream must not be null.\";\n-    \n+\n     private static final String OUTPUTSTREAM_NULL_MESSAGE = \"OutputStream must not be null.\";\n \n \n--- a/src/test/java/org/apache/commons/compress/archivers/LongPathTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/LongPathTest.java\n  * as JUnit does not allow one to change the display name of a test.\n  */\n public class LongPathTest extends AbstractTestCase {\n-    \n+\n     private static final ClassLoader classLoader = LongPathTest.class.getClassLoader();\n \n     private File file;\n     public LongPathTest(String name) {\n         super(name);\n     }\n-    \n+\n     private LongPathTest(String name, File file){\n         super(name);\n         this.file = file;\n     }\n-    \n+\n     public static TestSuite suite() throws IOException{\n         TestSuite suite = new TestSuite(\"LongPathTests\");\n         URL resource = classLoader.getResource(\"longpath\");\n             Test test = new LongPathTest(\"testArchive\", file);\n             namedSuite.addTest(test);\n             suite.addTest(namedSuite);\n-        }        \n+        }\n         return suite;\n     }\n-    \n+\n     public void testArchive() throws Exception {\n         @SuppressWarnings(\"unchecked\") // fileList is of correct type\n         ArrayList<String> expected = (ArrayList<String>) fileList.clone();\n                 if (!ent.endsWith(\"/\")){// not a directory\n                     final int lastSlash = ent.lastIndexOf('/');\n                     if (lastSlash >= 0) { // extract path name\n-                        expected.add(ent.substring(lastSlash+1, ent.length()));                        \n+                        expected.add(ent.substring(lastSlash+1, ent.length()));\n                     } else {\n                         expected.add(ent);\n                     }\n--- a/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n      */\n     public void testListAllFilesWithNestedArchive() throws Exception {\n         final File input = getFile(\"OSX_ArchiveWithNestedArchive.zip\");\n-       \n+\n         List<String> results = new ArrayList<String>();\n \n         final InputStream is = new FileInputStream(input);\n             }\n         }\n         is.close();\n-        \n+\n         results.contains(\"NestedArchiv.zip\");\n         results.contains(\"test1.xml\");\n         results.contains(\"test2.xml\");\n--- a/src/test/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStreamTest.java\n         expected.append(\"./test1.xml<?xml version=\\\"1.0\\\"?>\\n\");\n         expected.append(\"<empty/>./test2.xml<?xml version=\\\"1.0\\\"?>\\n\");\n         expected.append(\"<empty/>\\n\");\n-        \n+\n \n         CpioArchiveInputStream in = \n                 new CpioArchiveInputStream(new FileInputStream(getFile(\"bla.cpio\")));\n         CpioArchiveEntry entry= null;\n-        \n+\n         StringBuffer result = new StringBuffer();\n         while ((entry = (CpioArchiveEntry) in.getNextEntry()) != null) {\n             result.append(entry.getName());\n          }\n          in.close();\n          assertEquals(result.toString(), expected.toString());\n-    }    \n+    }\n }\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveEntryTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveEntryTest.java\n             AbstractTestCase.tryHardToDelete(f);\n         }\n     }\n-    \n+\n     public void testMaxFileSize(){\n         TarArchiveEntry t = new TarArchiveEntry(\"\");\n         t.setSize(0);\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStreamTest.java\n                 in.close();\n             }\n         }\n-    }        \n+    }\n \n     @Test\n     public void datePriorToEpochInGNUFormat() throws Exception {\n                 in.close();\n             }\n         }\n-    }        \n+    }\n \n }\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarUtilsTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarUtilsTest.java\n \n public class TarUtilsTest extends TestCase {\n \n-    \n+\n     public void testName(){\n         byte [] buff = new byte[20];\n         String sb1 = \"abcdefghijklmnopqrstuvwxyz\";\n         sb2 = TarUtils.parseName(buff, 1, buff.length-1);\n         assertEquals(sb1, sb2);\n     }\n-    \n+\n     public void testParseOctal() throws Exception{\n         long value; \n         byte [] buffer;\n         assertEquals(MAX_OCTAL, value);\n         buffer=new byte[]{0,0};\n         value = TarUtils.parseOctal(buffer,0, buffer.length);\n-        assertEquals(0, value);        \n+        assertEquals(0, value);\n         buffer=new byte[]{0,' '};\n         value = TarUtils.parseOctal(buffer,0, buffer.length);\n-        assertEquals(0, value);        \n+        assertEquals(0, value);\n     }\n \n     public void testParseOctalInvalid() throws Exception{\n         parseValue = TarUtils.parseOctal(buffer,0, buffer.length);\n         assertEquals(value,parseValue);\n     }\n-    \n+\n     private void checkRoundTripOctal(final long value) {\n         checkRoundTripOctal(value, TarConstants.SIZELEN);\n     }\n         checkRoundTripOctalOrBinary(-1, length); // will need binary format\n         checkRoundTripOctalOrBinary(0xff00000000000001l, length);\n     }\n-    \n+\n     // Check correct trailing bytes are generated\n     public void testTrailers() {\n         byte [] buffer = new byte[12];\n         assertEquals(0  , buffer[buffer.length-2]);\n         assertEquals('3', buffer[buffer.length-3]); // end of number\n     }\n-    \n+\n     public void testNegative() throws Exception {\n         byte [] buffer = new byte[22];\n         TarUtils.formatUnsignedOctalString(-1, buffer, 0, buffer.length);\n     public void testOverflow() throws Exception {\n         byte [] buffer = new byte[8-1]; // a lot of the numbers have 8-byte buffers (nul term)\n         TarUtils.formatUnsignedOctalString(07777777L, buffer, 0, buffer.length);\n-        assertEquals(\"7777777\", new String(buffer, \"UTF-8\"));        \n+        assertEquals(\"7777777\", new String(buffer, \"UTF-8\"));\n         try {\n             TarUtils.formatUnsignedOctalString(017777777L, buffer, 0, buffer.length);\n             fail(\"Should have cause IllegalArgumentException\");\n         } catch (IllegalArgumentException expected) {\n         }\n     }\n-    \n+\n     public void testRoundTripNames(){\n         checkName(\"\");\n         checkName(\"The quick brown fox\\n\");\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java\n             zos.putArchiveEntry(ze);\n             zos.write(\"ascii\".getBytes(\"US-ASCII\"));\n             zos.closeArchiveEntry();\n-            \n+\n             zos.finish();\n         } finally {\n             if (zos != null) {\n--- a/src/test/java/org/apache/commons/compress/changes/ChangeSetTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/changes/ChangeSetTestCase.java\n  * Checks several ChangeSet business logics.\n  */\n public final class ChangeSetTestCase extends AbstractTestCase {\n-    \n+\n     // Delete a directory tree\n     private void archiveListDeleteDir(String prefix){\n         Iterator<String> it = archiveList.iterator();\n         try {\n             in = new FileInputStream(getFile(\"test.txt\"));\n             in2 = new FileInputStream(getFile(\"test2.xml\"));\n-       \n+\n             ArchiveEntry e = new ZipArchiveEntry(\"test.txt\");\n             ArchiveEntry e2 = new ZipArchiveEntry(\"test.txt\");\n-            \n+\n             ChangeSet changes = new ChangeSet();\n             changes.add(e, in);\n             changes.add(e2, in2);\n-            \n+\n             assertEquals(1, changes.getChanges().size());\n             Change c = changes.getChanges().iterator().next();\n             assertEquals(in2, c.getInput());\n                 in2.close();\n         }\n     }\n-    \n+\n     /**\n      * Adds an ArchiveEntry with the same name two times.\n      * Only the first addition should be found in the ChangeSet,\n         try {\n             in = new FileInputStream(getFile(\"test.txt\"));\n             in2 = new FileInputStream(getFile(\"test2.xml\"));\n-       \n+\n             ArchiveEntry e = new ZipArchiveEntry(\"test.txt\");\n             ArchiveEntry e2 = new ZipArchiveEntry(\"test.txt\");\n-            \n+\n             ChangeSet changes = new ChangeSet();\n             changes.add(e, in, true);\n             changes.add(e2, in2, false);\n-            \n+\n             assertEquals(1, changes.getChanges().size());\n             Change c = changes.getChanges().iterator().next();\n             assertEquals(in, c.getInput());\n                 in2.close();\n         }\n     }\n-    \n+\n     /**\n      * Tries to delete the folder \"bla\" from an archive file. This should result in\n      * the deletion of bla/*, which actually means bla/test4.xml should be\n             ChangeSet changes = new ChangeSet();\n             changes.delete(\"bla/test5.xml\");\n             archiveListDelete(\"bla/test5.xml\");\n-            \n+\n             ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n             is.close();\n             ChangeSet changes = new ChangeSet();\n             changes.delete(\"bla\");\n             //archiveListDelete(\"bla\");\n-            \n+\n             ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n             is.close();\n         ArchiveInputStream ais = null;\n         File result = File.createTempFile(\"test\", \".\"+archivename);\n         result.deleteOnExit();\n-        \n+\n         File testtxt = null;\n         try {\n \n             check = this.checkArchiveContent(in, archiveList, false);\n             File test3xml = new File(check,\"result/test/test3.xml\");\n             assertEquals(testtxt.length(), test3xml.length());\n-            \n+\n             BufferedReader reader = new BufferedReader(new FileReader(test3xml));\n             String str;\n             while ((str = reader.readLine()) != null) {\n             rmdir(check);\n         } \n     }\n-    \n+\n     /**\n      * Checks for the correct ChangeSetResults\n      * \n             assertTrue(results.getDeleted().contains(\"bla/test4.xml\"));\n             assertTrue(results.getDeleted().contains(\"bla/test5.xml\"));\n             assertTrue(results.getDeleted().contains(\"bla/blubber/test6.xml\"));\n-            \n+\n             assertTrue(results.getAddedFromStream().contains(\"testdata/test1.xml\"));\n             assertTrue(results.getAddedFromStream().contains(\"testdata/test2.xml\"));\n             assertTrue(results.getAddedFromStream().contains(\"test/test3.xml\"));\n \n         this.checkArchiveContent(result, archiveList);\n     }\n-    \n+\n     /**\n      * Tries to delete a directory with a file and adds a new directory with a\n      * new file and with the same name. Should delete dir1/* and add\n \n             ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n-            \n+\n             is.close();\n \n         } finally {\n \n             ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n-            \n+\n             is.close();\n \n         } finally {\n \n             ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n-            \n+\n         } finally {\n             if (out != null)\n                 out.close();\n \n             ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n-            \n+\n         } finally {\n             if (out != null)\n                 out.close();\n \n             ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n-            \n+\n         } finally {\n             if (out != null)\n                 out.close();\n \n             ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n-            \n+\n         } finally {\n             if (out != null)\n                 out.close();\n \n             ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n-            \n+\n         } finally {\n             if (out != null)\n                 out.close();\n \n             ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n-            \n+\n         } finally {\n             if (out != null)\n                 out.close();\n \n             ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n-            \n+\n         } finally {\n             if (out != null)\n                 out.close();\n      */\n     public void testAddMoveDelete() throws Exception {\n     }\n-    \n+\n     /**\n      * Check can add a file to an empty archive.\n      * \n                     new FileOutputStream(result));\n             changes.delete(\"test1.xml\");\n             archiveListDelete(\"test1.xml\");\n-            \n+\n             final File file = getFile(\"test.txt\");\n             ArchiveEntry entry = out.createArchiveEntry(file,\"bla/test.txt\");\n             changes.add(entry, new FileInputStream(file));\n             archiveList.add(\"bla/test.txt\");\n-            \n+\n             ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n             is.close();\n \n             changes.delete(\"test1.xml\");\n             archiveListDelete(\"test1.xml\");\n-            \n+\n             ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n             is.close();\n \n         this.checkArchiveContent(result, archiveList);\n     }\n-    \n+\n     /**\n      * Adds a file with the same filename as an existing file from the stream.\n      * Should lead to a replacement.\n             final File file1 = getFile(\"test.txt\");\n             ArchiveEntry entry = new ZipArchiveEntry(\"testdata/test1.xml\");\n             changes.add(entry, new FileInputStream(file1), true);\n-            \n+\n             ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             ChangeSetResults results = performer.perform(ais, out);\n             assertTrue(results.getAddedFromChangeSet().contains(\"testdata/test1.xml\"));\n \n         this.checkArchiveContent(result, archiveList);\n     }\n-    \n+\n     /**\n      * Adds a file with the same filename as an existing file from the stream.\n      * Should lead to a replacement.\n             final File file1 = getFile(\"test.txt\");\n             ArchiveEntry entry = new ZipArchiveEntry(\"testdata/test1.xml\");\n             changes.add(entry, new FileInputStream(file1), false);\n-            \n+\n             ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             ChangeSetResults results = performer.perform(ais, out);\n             assertTrue(results.getAddedFromStream().contains(\"testdata/test1.xml\"));\n \n         this.checkArchiveContent(result, archiveList);\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/compress/compressors/BZip2TestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/BZip2TestCase.java\n             is.close();\n         }\n     }\n-    \n+\n }", "timestamp": 1333197009, "metainfo": ""}