{"sha": "ed1e171c2007b96afc2f99cab97aed0b211e57a3", "log": "When I was investigating stack sizes, I realized that we're allocating a whole bunch of threads for no good reason. Clean up the threading code a bit, and make sure we only allocate one thread for the compiler.  R=dimvar DELTA=76  (38 added, 19 deleted, 19 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5248   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import java.util.ResourceBundle;\n import java.util.Set;\n import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n import java.util.regex.Matcher;\n    */\n   private int uniqueNameId = 0;\n \n-  /** Whether to use threads. */\n-  private boolean useThreads = true;\n-\n   /**\n    * Whether to assume there are references to the RegExp Global object\n    * properties.\n   // We use many recursive algorithms that use O(d) memory in the depth\n   // of the tree.\n   private static final long COMPILER_STACK_SIZE = (1 << 21); // About 2MB\n+\n+  /**\n+   * Under JRE 1.6, the JS Compiler overflows the stack when running on some\n+   * large or complex JS code. When threads are available, we run all compile\n+   * jobs on a separate thread with a larger stack.\n+   *\n+   * That way, we don't have to increase the stack size for *every* thread\n+   * (which is what -Xss does).\n+   *\n+   * TODO(nicksantos): Add thread pool support for clients that compile a lot.\n+   */\n+  private ExecutorService compilerExecutor =\n+      Executors.newCachedThreadPool(new ThreadFactory() {\n+    @Override public Thread newThread(Runnable r) {\n+      return new Thread(null, r, \"jscompiler\", COMPILER_STACK_SIZE);\n+    }\n+  });\n+\n+  /**\n+   * Use a dedicated compiler thread per Compiler instance.\n+   */\n+  private Thread compilerThread = null;\n+\n+  /** Whether to use threads. */\n+  private boolean useThreads = true;\n \n \n   /**\n     useThreads = false;\n   }\n \n-  private <T> T runInCompilerThread(final Callable<T> callable) {\n-    return runCallable(callable, useThreads, options.tracer.isOn());\n-  }\n-\n-  static <T> T runCallableWithLargeStack(final Callable<T> callable) {\n-    return runCallable(callable, true, false);\n-  }\n-\n   @SuppressWarnings(\"unchecked\")\n-  static <T> T runCallable(\n-      final Callable<T> callable, boolean useLargeStackThread, boolean trace) {\n-\n-    // Under JRE 1.6, the JS Compiler overflows the stack when running on some\n-    // large or complex JS code. Here we start a new thread with a larger\n-    // stack in order to let the compiler do its thing, without having to\n-    // increase the stack size for *every* thread (which is what -Xss does).\n-    // Might want to add thread pool support for clients that compile a lot.\n-\n-    final boolean dumpTraceReport = trace;\n-    final Object[] result = new Object[1];\n+  <T> T runInCompilerThread(final Callable<T> callable) {\n+    final boolean dumpTraceReport = options != null && options.tracer.isOn();\n+    T result = null;\n     final Throwable[] exception = new Throwable[1];\n-    Runnable runnable = new Runnable() {\n+    Callable<T> bootCompilerThread = new Callable<T>() {\n       @Override\n-      public void run() {\n+      public T call() {\n         try {\n+          compilerThread = Thread.currentThread();\n           if (dumpTraceReport) {\n             Tracer.initCurrentThreadTrace();\n           }\n-          result[0] = callable.call();\n+          return callable.call();\n         } catch (Throwable e) {\n           exception[0] = e;\n         } finally {\n+          compilerThread = null;\n           if (dumpTraceReport) {\n             Tracer.logAndClearCurrentThreadTrace();\n           }\n         }\n+        return null;\n       }\n     };\n \n-    if (useLargeStackThread) {\n-      Thread th = new Thread(null, runnable, \"jscompiler\", COMPILER_STACK_SIZE);\n-      th.start();\n-      while (true) {\n-        try {\n-          th.join();\n-          break;\n-        } catch (InterruptedException ignore) {\n-          // ignore\n-        }\n+    Preconditions.checkState(\n+        compilerThread == null || compilerThread == Thread.currentThread(),\n+        \"Please do not share the Compiler across threads\");\n+\n+    // If the compiler thread is available, use it.\n+    if (useThreads && compilerThread == null) {\n+      try {\n+        result = compilerExecutor.submit(bootCompilerThread).get();\n+      } catch (InterruptedException e) {\n+        throw Throwables.propagate(e);\n+      } catch (ExecutionException e) {\n+        throw Throwables.propagate(e);\n       }\n     } else {\n-      runnable.run();\n+      try {\n+        result = callable.call();\n+      } catch (Exception e) {\n+        exception[0] = e;\n+      }\n     }\n \n     // Pass on any exception caught by the runnable object.\n       throw new RuntimeException(exception[0]);\n     }\n \n-    return (T) result[0];\n+    return result;\n   }\n \n   private void compileInternal() {", "timestamp": 1343416917, "metainfo": ""}