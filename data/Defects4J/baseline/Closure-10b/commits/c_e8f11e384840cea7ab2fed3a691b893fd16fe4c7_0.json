{"sha": "e8f11e384840cea7ab2fed3a691b893fd16fe4c7", "log": "Make constant expression reordering a peephole optimization.  R=johnlenz DELTA=28  (4 added, 8 deleted, 16 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3134   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ReorderConstantExpression.java\n+++ b/src/com/google/javascript/jscomp/ReorderConstantExpression.java\n  * compression together than their original counterparts.\n  *\n  */\n-class ReorderConstantExpression implements CompilerPass {\n+class ReorderConstantExpression extends AbstractPeepholeOptimization {\n \n   private AbstractCompiler compiler;\n \n+  // TODO(user): Rename this pass to PeepholeReorderConstantExpression\n+  // to follow our naming convention.\n   ReorderConstantExpression(AbstractCompiler compiler) {\n     this.compiler = compiler;\n   }\n \n   @Override\n-  public void process(Node externs, Node node) {\n+  Node optimizeSubtree(Node subtree) {\n     // if the operator is symertric\n-    if (NodeUtil.isSymmetricOperation(node)\n-        || NodeUtil.isRelationalOperation(node)) {\n+    if (NodeUtil.isSymmetricOperation(subtree)\n+        || NodeUtil.isRelationalOperation(subtree)) {\n       // right value is immutable and left is not\n-      if (NodeUtil.isImmutableValue(node.getLastChild())\n-          && !NodeUtil.isImmutableValue(node.getFirstChild())) {\n+      if (NodeUtil.isImmutableValue(subtree.getLastChild())\n+          && !NodeUtil.isImmutableValue(subtree.getFirstChild())) {\n \n         // if relational, get the inverse operator.\n-        if (NodeUtil.isRelationalOperation(node)){\n-          int inverseOperator = NodeUtil.getInverseOperator(node.getType());\n-          node.setType(inverseOperator);\n+        if (NodeUtil.isRelationalOperation(subtree)){\n+          int inverseOperator = NodeUtil.getInverseOperator(subtree.getType());\n+          subtree.setType(inverseOperator);\n         }\n \n         // swap them\n-        Node firstNode = node.getFirstChild().detachFromParent();\n-        Node lastNode = node.getLastChild().detachFromParent();\n+        Node firstNode = subtree.getFirstChild().detachFromParent();\n+        Node lastNode = subtree.getLastChild().detachFromParent();\n \n-        node.addChildrenToFront(lastNode);\n-        node.addChildrenToBack(firstNode);\n+        subtree.addChildrenToFront(lastNode);\n+        subtree.addChildrenToBack(firstNode);\n         this.compiler.reportCodeChange();\n       }\n     }\n-\n-    // process children then siblings.\n-    if (node.hasChildren()) {\n-      Node child = node.getFirstChild();\n-      while (child != null) {\n-        process(externs, child);\n-        child = child.getNext();\n-      }\n-    }\n+    return subtree;\n   }\n }\n--- a/test/com/google/javascript/jscomp/ReorderConstantExpressionTest.java\n+++ b/test/com/google/javascript/jscomp/ReorderConstantExpressionTest.java\n public class ReorderConstantExpressionTest extends CompilerTestCase {\n \n   @Override\n-  protected CompilerPass getProcessor(Compiler compiler) {\n-    return new ReorderConstantExpression(compiler);\n+  protected CompilerPass getProcessor(final Compiler compiler) {\n+    return new PeepholeOptimizationsPass(compiler,\n+        new ReorderConstantExpression(compiler));\n   }\n \n   @Override", "timestamp": 1314234039, "metainfo": ""}