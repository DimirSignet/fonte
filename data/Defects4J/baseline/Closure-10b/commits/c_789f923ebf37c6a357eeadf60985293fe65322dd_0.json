{"sha": "789f923ebf37c6a357eeadf60985293fe65322dd", "log": "Peephole folding of literal comparisons to null.  R=acleung DELTA=230  (213 added, 8 deleted, 9 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3457   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n    */\n   @SuppressWarnings(\"fallthrough\")\n   private Node tryFoldComparison(Node n, Node left, Node right) {\n-    if (!NodeUtil.isLiteralValue(left, false) ||\n-        !NodeUtil.isLiteralValue(right, false)) {\n-      // We only handle non-literal operands for LT and GT.\n+    boolean leftLiteral = NodeUtil.isLiteralValue(left, true);\n+    boolean rightLiteral = NodeUtil.isLiteralValue(right, true);\n+\n+    if (!leftLiteral || !rightLiteral) {\n+      // We only handle literal operands for LT and GT.\n       if (n.getType() != Token.GT && n.getType() != Token.LT) {\n         return n;\n       }\n     int op = n.getType();\n     boolean result;\n \n-    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n-\n-    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n-    boolean undefinedRight = ((Token.NAME == right.getType()\n-          && right.getString().equals(\"undefined\"))\n-          || (Token.VOID == right.getType()\n-              && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n+    boolean undefinedRight = NodeUtil.isUndefined(right) && rightLiteral;\n+    boolean nullRight = NodeUtil.isNull(right);\n     int lhType = getNormalizedNodeType(left);\n     int rhType = getNormalizedNodeType(right);\n     switch (lhType) {\n       case Token.VOID:\n-        if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n+        if (!leftLiteral) {\n           return n;\n         } else if (!rightLiteral) {\n           return n;\n           result = compareToUndefined(right, op);\n         }\n         break;\n-\n       case Token.NULL:\n+        if (rightLiteral && isEqualityOp(op)) {\n+          result = compareToNull(right, op);\n+          break;\n+        }\n+        // fallthrough\n       case Token.TRUE:\n       case Token.FALSE:\n         if (undefinedRight) {\n           result = compareToUndefined(left, op);\n           break;\n         }\n+        if (nullRight && isEqualityOp(op)) {\n+          result = compareToNull(left, op);\n+          break;\n+        }\n         if (Token.STRING != right.getType()) {\n           return n;  // Only eval if they are the same type\n         }\n           result = compareToUndefined(left, op);\n           break;\n         }\n+        if (nullRight && isEqualityOp(op)) {\n+          result = compareToNull(left, op);\n+          break;\n+        }\n         if (Token.NUMBER != right.getType()) {\n           return n;  // Only eval if they are the same type\n         }\n         break;\n \n       case Token.NAME:\n-        if (undefinedRight) {\n+        if (leftLiteral && undefinedRight) {\n           result = compareToUndefined(left, op);\n           break;\n         }\n           boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n           if (undefinedLeft) {\n             result = compareToUndefined(right, op);\n+            break;\n+          }\n+          if (leftLiteral && nullRight && isEqualityOp(op)) {\n+            result = compareToNull(left, op);\n             break;\n           }\n         }\n         }\n         break;\n \n+      case Token.NEG:\n+        if (leftLiteral) {\n+          if (undefinedRight) {\n+            result = compareToUndefined(left, op);\n+            break;\n+          }\n+          if (nullRight && isEqualityOp(op)) {\n+            result = compareToNull(left, op);\n+            break;\n+          }\n+        }\n+        // Nothing else for now.\n+        return n;\n+\n+      case Token.ARRAYLIT:\n+      case Token.OBJECTLIT:\n+      case Token.REGEXP:\n+      case Token.FUNCTION:\n+        if (leftLiteral) {\n+          if (undefinedRight) {\n+            result = compareToUndefined(left, op);\n+            break;\n+          }\n+          if (nullRight && isEqualityOp(op)) {\n+            result = compareToNull(left, op);\n+            break;\n+          }\n+        }\n+        // ignore the rest for now.\n+        return n;\n+\n       default:\n         // assert, this should cover all consts\n         return n;\n    * @return Whether the boolean op is true or false\n    */\n   private boolean compareToUndefined(Node value, int op) {\n-    boolean valueUndefined = ((Token.NAME == value.getType()\n-        && value.getString().equals(\"undefined\"))\n-        || (Token.VOID == value.getType()\n-            && NodeUtil.isLiteralValue(value.getFirstChild(), false)));\n+    Preconditions.checkState(NodeUtil.isLiteralValue(value, true));\n+    boolean valueUndefined = NodeUtil.isUndefined(value);\n     boolean valueNull = (Token.NULL == value.getType());\n     boolean equivalent = valueUndefined || valueNull;\n     switch (op) {\n     }\n   }\n \n+  private boolean isEqualityOp(int op) {\n+    switch (op) {\n+      case Token.EQ:\n+      case Token.NE:\n+      case Token.SHEQ:\n+      case Token.SHNE:\n+        return true;\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * @param value The value to compare to \"null\"\n+   * @param op The boolean op to compare with\n+   * @return Whether the boolean op is true or false\n+   */\n+  private boolean compareToNull(Node value, int op) {\n+    boolean valueUndefined = NodeUtil.isUndefined(value);\n+    boolean valueNull = (Token.NULL == value.getType());\n+    boolean equivalent = valueUndefined || valueNull;\n+    switch (op) {\n+      case Token.EQ:\n+        // undefined is only equal to null or an undefined value\n+        return equivalent;\n+      case Token.NE:\n+        return !equivalent;\n+      case Token.SHEQ:\n+        return valueNull;\n+      case Token.SHNE:\n+        return !valueNull;\n+      default:\n+        throw new IllegalStateException(\"unexpected.\");\n+    }\n+  }\n+\n   /**\n    * Try to fold away unnecessary object instantiation.\n    * e.g. this[new String('eval')] -> this.eval\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     fold(\"null === undefined\", \"false\");\n     fold(\"void 0 === undefined\", \"true\");\n \n+    fold(\"undefined == NaN\", \"false\");\n+    fold(\"NaN == undefined\", \"false\");\n+    fold(\"undefined == Infinity\", \"false\");\n+    fold(\"Infinity == undefined\", \"false\");\n+    fold(\"undefined == -Infinity\", \"false\");\n+    fold(\"-Infinity == undefined\", \"false\");\n+    fold(\"({}) == undefined\", \"false\");\n+    fold(\"undefined == ({})\", \"false\");\n+    fold(\"([]) == undefined\", \"false\");\n+    fold(\"undefined == ([])\", \"false\");\n+    fold(\"(/a/g) == undefined\", \"false\");\n+    fold(\"undefined == (/a/g)\", \"false\");\n+    fold(\"(function(){}) == undefined\", \"false\");\n+    fold(\"undefined == (function(){})\", \"false\");\n+\n+    fold(\"undefined != NaN\", \"true\");\n+    fold(\"NaN != undefined\", \"true\");\n+    fold(\"undefined != Infinity\", \"true\");\n+    fold(\"Infinity != undefined\", \"true\");\n+    fold(\"undefined != -Infinity\", \"true\");\n+    fold(\"-Infinity != undefined\", \"true\");\n+    fold(\"({}) != undefined\", \"true\");\n+    fold(\"undefined != ({})\", \"true\");\n+    fold(\"([]) != undefined\", \"true\");\n+    fold(\"undefined != ([])\", \"true\");\n+    fold(\"(/a/g) != undefined\", \"true\");\n+    fold(\"undefined != (/a/g)\", \"true\");\n+    fold(\"(function(){}) != undefined\", \"true\");\n+    fold(\"undefined != (function(){})\", \"true\");\n+\n     foldSame(\"this == undefined\");\n     foldSame(\"x == undefined\");\n   }\n \n     fold(\"undefined !== void 0\", \"false\");\n     fold(\"undefined === void 0\", \"true\");\n+  }\n+\n+  public void testNullComparison1() {\n+    fold(\"null == undefined\", \"true\");\n+    fold(\"null == null\", \"true\");\n+    fold(\"null == void 0\", \"true\");\n+\n+    fold(\"null == 0\", \"false\");\n+    fold(\"null == 1\", \"false\");\n+    fold(\"null == 'hi'\", \"false\");\n+    fold(\"null == true\", \"false\");\n+    fold(\"null == false\", \"false\");\n+\n+    fold(\"null === undefined\", \"false\");\n+    fold(\"null === null\", \"true\");\n+    fold(\"null === void 0\", \"false\");\n+\n+    foldSame(\"null == this\");\n+    foldSame(\"null == x\");\n+\n+    fold(\"null != undefined\", \"false\");\n+    fold(\"null != null\", \"false\");\n+    fold(\"null != void 0\", \"false\");\n+\n+    fold(\"null != 0\", \"true\");\n+    fold(\"null != 1\", \"true\");\n+    fold(\"null != 'hi'\", \"true\");\n+    fold(\"null != true\", \"true\");\n+    fold(\"null != false\", \"true\");\n+\n+    fold(\"null !== undefined\", \"true\");\n+    fold(\"null !== void 0\", \"true\");\n+    fold(\"null !== null\", \"false\");\n+\n+    foldSame(\"null != this\");\n+    foldSame(\"null != x\");\n+\n+    fold(\"null < null\", \"false\");\n+    fold(\"null > null\", \"false\");\n+    fold(\"null >= null\", \"true\");\n+    fold(\"null <= null\", \"true\");\n+\n+    foldSame(\"0 < null\"); // foldable\n+    fold(\"true > null\", \"true\");\n+    foldSame(\"'hi' >= null\"); // foldable\n+    fold(\"null <= null\", \"true\");\n+\n+    foldSame(\"null < 0\");  // foldable\n+    fold(\"null > true\", \"false\");\n+    foldSame(\"null >= 'hi'\"); // foldable\n+    fold(\"null <= null\", \"true\");\n+\n+    fold(\"null == null\", \"true\");\n+    fold(\"0 == null\", \"false\");\n+    fold(\"1 == null\", \"false\");\n+    fold(\"'hi' == null\", \"false\");\n+    fold(\"true == null\", \"false\");\n+    fold(\"false == null\", \"false\");\n+    fold(\"null === null\", \"true\");\n+    fold(\"void 0 === null\", \"false\");\n+\n+    fold(\"null == NaN\", \"false\");\n+    fold(\"NaN == null\", \"false\");\n+    fold(\"null == Infinity\", \"false\");\n+    fold(\"Infinity == null\", \"false\");\n+    fold(\"null == -Infinity\", \"false\");\n+    fold(\"-Infinity == null\", \"false\");\n+    fold(\"({}) == null\", \"false\");\n+    fold(\"null == ({})\", \"false\");\n+    fold(\"([]) == null\", \"false\");\n+    fold(\"null == ([])\", \"false\");\n+    fold(\"(/a/g) == null\", \"false\");\n+    fold(\"null == (/a/g)\", \"false\");\n+    fold(\"(function(){}) == null\", \"false\");\n+    fold(\"null == (function(){})\", \"false\");\n+\n+    fold(\"null != NaN\", \"true\");\n+    fold(\"NaN != null\", \"true\");\n+    fold(\"null != Infinity\", \"true\");\n+    fold(\"Infinity != null\", \"true\");\n+    fold(\"null != -Infinity\", \"true\");\n+    fold(\"-Infinity != null\", \"true\");\n+    fold(\"({}) != null\", \"true\");\n+    fold(\"null != ({})\", \"true\");\n+    fold(\"([]) != null\", \"true\");\n+    fold(\"null != ([])\", \"true\");\n+    fold(\"(/a/g) != null\", \"true\");\n+    fold(\"null != (/a/g)\", \"true\");\n+    fold(\"(function(){}) != null\", \"true\");\n+    fold(\"null != (function(){})\", \"true\");\n+\n+    foldSame(\"({a:f()}) == null\");\n+    foldSame(\"null == ({a:f()})\");\n+    foldSame(\"([f()]) == null\");\n+    foldSame(\"null == ([f()])\");\n+\n+    foldSame(\"this == null\");\n+    foldSame(\"x == null\");\n   }\n \n   public void testUnaryOps() {", "timestamp": 1318464012, "metainfo": ""}