{"sha": "bea4e626a55e934ee9a81897069d4a05414c9c57", "log": "Change on 2010/04/16 by nick          Move the topological dependency sort into jscomp/deps          R=alan         DELTA=246  (161 added, 75 deleted, 10 changed)  Change on 2010/04/16 by john          Enable decompose expressions the open source compiler.          R=alan         DELTA=2  (2 added, 0 deleted, 0 changed)  Change on 2010/04/16 by alan          Update flow sensitive inlining flow to be tri state. This should not change the behavior            of the compiler.          R=john,nassar         DELTA=11  (1 added, 2 deleted, 8 changed)  Change on 2010/04/16 by nick          treat goog.addSingletonGetter as a class-defining function.          R=antonio         DELTA=39  (26 added, 5 deleted, 8 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=olbuid   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n \n   @Override\n   public String getSingletonGetterClassName(Node callNode) {\n-    Node callName = callNode.getFirstChild();\n-    if (!\"goog.addSingletonGetter\".equals(callName.getQualifiedName()) ||\n-        callName.getChildCount() != 2) {\n+    Node callArg = callNode.getFirstChild();\n+    String callName = callArg.getQualifiedName();\n+\n+    // Use both the original name and the post-CollapseProperties name.\n+    if (!(\"goog.addSingletonGetter\".equals(callName) ||\n+          \"goog$addSingletonGetter\".equals(callName)) ||\n+        callNode.getChildCount() != 2) {\n       return null;\n     }\n \n-    Node classNode = callName.getNext();\n-    if (!classNode.isQualifiedName()) {\n-      return null;\n-    }\n-\n-    return callName.getNext().getQualifiedName();\n+    return callArg.getNext().getQualifiedName();\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/CompilationLevel.java\n+++ b/src/com/google/javascript/jscomp/CompilationLevel.java\n     options.variableRenaming = VariableRenamingPolicy.LOCAL;\n     options.inlineLocalVariables = true;\n     options.inlineLocalFunctions = true;\n-    options.inlineAnonymousFunctionExpressions = true;    \n+    options.inlineAnonymousFunctionExpressions = true;\n+    options.decomposeExpressions = true;\n     options.checkGlobalThisLevel = CheckLevel.OFF;\n     options.foldConstants = true;\n     options.removeConstantExpressions = true;\n     options.inlineFunctions = true;\n     options.inlineLocalFunctions = true;\n     options.inlineAnonymousFunctionExpressions = true;\n+    options.decomposeExpressions = true;\n     options.inlineGetters = true;\n     options.inlineVariables = true;\n     options.removeConstantExpressions = true;\n--- a/src/com/google/javascript/jscomp/JSModule.java\n+++ b/src/com/google/javascript/jscomp/JSModule.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n-import com.google.common.collect.ArrayListMultimap;\n-import com.google.common.collect.HashMultimap;\n-import com.google.common.collect.HashMultiset;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n-import com.google.common.collect.Maps;\n-import com.google.common.collect.Multimap;\n-import com.google.common.collect.Multimaps;\n-import com.google.common.collect.Multiset;\n import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.deps.DependencyInfo;\n+import com.google.javascript.jscomp.deps.SortedDependencies;\n \n import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.Comparator;\n+import java.util.Collections;\n import java.util.Iterator;\n import java.util.List;\n-import java.util.Map;\n-import java.util.PriorityQueue;\n import java.util.Set;\n \n /**\n *\n *\n  */\n-public class JSModule {\n+public class JSModule implements DependencyInfo {\n   /** Module name */\n   private final String name;\n \n   /** Gets the module name. */\n   public String getName() {\n     return name;\n+  }\n+\n+  @Override\n+  public List<String> getProvides() {\n+    return ImmutableList.<String>of(name);\n+  }\n+\n+  @Override\n+  public List<String> getRequires() {\n+    ImmutableList.Builder<String> builder = ImmutableList.builder();\n+    for (JSModule m : deps) {\n+      builder.add(m.getName());\n+    }\n+    return builder.build();\n+  }\n+\n+  @Override\n+  public String getPathRelativeToClosureBase() {\n+    throw new UnsupportedOperationException();\n   }\n \n   /** Adds a source file input to this module. */\n    * Puts the JS files into a topologically sorted order by their dependencies.\n    */\n   public void sortInputsByDeps(Compiler compiler) {\n-    final Map<String, CompilerInput> provides = Maps.newHashMap();\n-    // Collect all symbols provided in these files.\n+    // Set the compiler, so that we can parse requires/provides and report\n+    // errors properly.\n     for (CompilerInput input : inputs) {\n       input.setCompiler(compiler);\n-      for (String provide : input.getProvides()) {\n-        provides.put(provide, input);\n-      }\n-    }\n-\n-    // Get the direct dependencies.\n-    final Multimap<CompilerInput, CompilerInput> deps =\n-        HashMultimap.create();\n-    for (CompilerInput input : inputs) {\n-      for (String req : input.getRequires()) {\n-        CompilerInput dep = provides.get(req);\n-        if (dep != null) {\n-          deps.put(input, dep);\n-        }\n-      }\n     }\n \n     // Sort the JSModule in this order.\n-    List<CompilerInput> sortedList = topologicalStableSort(\n-        inputs, deps);\n+    List<CompilerInput> sortedList =\n+        (new SortedDependencies<CompilerInput>(\n+            Collections.<CompilerInput>unmodifiableList(inputs)))\n+        .getSortedList();\n     inputs.clear();\n     inputs.addAll(sortedList);\n   }\n    * the modules do not properly specify all dependencies.\n    */\n   public static JSModule[] sortJsModules(Collection<JSModule> modules) {\n-    final Multimap<JSModule, JSModule> deps = HashMultimap.create();\n-    for (JSModule module : modules) {\n-      for (JSModule dep : module.getDependencies()) {\n-        deps.put(module, dep);\n-      }\n-    }\n-\n     // Sort the JSModule in this order.\n-    List<JSModule> sortedList = topologicalStableSort(\n-        Lists.newArrayList(modules), deps);\n+    List<JSModule> sortedList = (new SortedDependencies<JSModule>(\n+            Lists.newArrayList(modules))).getSortedList();\n     return sortedList.toArray(new JSModule[sortedList.size()]);\n   }\n-\n-  private static <T> List<T> topologicalStableSort(\n-      List<T> items, Multimap<T, T> deps) {\n-    final Map<T, Integer> originalIndex = Maps.newHashMap();\n-    for (int i = 0; i < items.size(); i++) {\n-      originalIndex.put(items.get(i), i);\n-    }\n-\n-    PriorityQueue<T> inDegreeZero = new PriorityQueue<T>(items.size(),\n-        new Comparator<T>() {\n-      @Override\n-      public int compare(T a, T b) {\n-        return originalIndex.get(a).intValue() -\n-            originalIndex.get(b).intValue();\n-      }\n-    });\n-    List<T> result = Lists.newArrayList();\n-\n-    Multiset<T> inDegree = HashMultiset.create();\n-    Multimap<T, T> reverseDeps = ArrayListMultimap.create();\n-    Multimaps.invertFrom(deps, reverseDeps);\n-\n-    // First, add all the inputs with in-degree 0.\n-    for (T item : items) {\n-      Collection<T> itemDeps = deps.get(item);\n-      inDegree.add(item, itemDeps.size());\n-      if (itemDeps.isEmpty()) {\n-        inDegreeZero.add(item);\n-      }\n-    }\n-\n-    // Then, iterate to a fixed point over the reverse dependency graph.\n-    while (!inDegreeZero.isEmpty()) {\n-      T item = inDegreeZero.remove();\n-      result.add(item);\n-      for (T inWaiting : reverseDeps.get(item)) {\n-        inDegree.remove(inWaiting, 1);\n-        if (inDegree.count(inWaiting) == 0) {\n-          inDegreeZero.add(inWaiting);\n-        }\n-      }\n-    }\n-\n-    return result;\n-  }\n }\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n       }\n \n       if (nameInfo.onlyAffectsClassDef) {\n-        recordReference(\n-            nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n+        if (nameInfo.superclass != null) {\n+          recordReference(\n+              nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n+        }\n \n         // Make sure that we record a reference to the function that does\n         // the inheritance, so that the inherits() function itself does\n     // Check whether this is a class-defining call. Classes may only be defined\n     // in the global scope.\n     if (NodeUtil.isCall(parent) && t.inGlobalScope()) {\n-      SubclassRelationship classes =\n-          compiler.getCodingConvention().getClassesDefinedByCall(parent);\n+      CodingConvention convention = compiler.getCodingConvention();\n+      SubclassRelationship classes = convention.getClassesDefinedByCall(parent);\n       if (classes != null) {\n         NameInformation nameInfo = new NameInformation();\n         nameInfo.name = classes.subclassName;\n         nameInfo.onlyAffectsClassDef = true;\n         nameInfo.superclass = classes.superclassName;\n+        return nameInfo;\n+      }\n+\n+      String singletonGetterClass =\n+          convention.getSingletonGetterClassName(parent);\n+      if (singletonGetterClass != null) {\n+        NameInformation nameInfo = new NameInformation();\n+        nameInfo.name = singletonGetterClass;\n+        nameInfo.onlyAffectsClassDef = true;\n         return nameInfo;\n       }\n     }\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/deps/SortedDependencies.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.deps;\n+\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.HashMultiset;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.Multiset;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+\n+/**\n+ * A sorted list of inputs with dependency information. Uses a stable\n+ * topological sort to make sure that an input always comes after its\n+ * dependencies.\n+ *\n+ * Also exposes other information about the inputs, like which inputs\n+ * do not provide symbols.\n+ *\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public class SortedDependencies<INPUT extends DependencyInfo> {\n+\n+  // A topologically sorted list of the inputs.\n+  private final List<INPUT> sortedList;\n+\n+  // A list of all the inputs that do not have provides.\n+  private final List<INPUT> noProvides;\n+\n+  public SortedDependencies(List<INPUT> inputs) {\n+    final Map<String, INPUT> provides = Maps.newHashMap();\n+    noProvides = Lists.newArrayList();\n+\n+    // Collect all symbols provided in these files.\n+    for (INPUT input : inputs) {\n+      Collection<String> currentProvides = input.getProvides();\n+      if (currentProvides.isEmpty()) {\n+        noProvides.add(input);\n+      }\n+\n+      for (String provide : currentProvides) {\n+        provides.put(provide, input);\n+      }\n+    }\n+\n+    // Get the direct dependencies.\n+    final Multimap<INPUT, INPUT> deps = HashMultimap.create();\n+    for (INPUT input : inputs) {\n+      for (String req : input.getRequires()) {\n+        INPUT dep = provides.get(req);\n+        if (dep != null) {\n+          deps.put(input, dep);\n+        }\n+      }\n+    }\n+\n+    // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n+    sortedList = topologicalStableSort(inputs, deps);\n+  }\n+\n+  public List<INPUT> getSortedList() {\n+    return Collections.<INPUT>unmodifiableList(sortedList);\n+  }\n+\n+  public List<INPUT> getInputsWithoutProvides() {\n+    return Collections.<INPUT>unmodifiableList(noProvides);\n+  }\n+\n+  private static <T> List<T> topologicalStableSort(\n+      List<T> items, Multimap<T, T> deps) {\n+    final Map<T, Integer> originalIndex = Maps.newHashMap();\n+    for (int i = 0; i < items.size(); i++) {\n+      originalIndex.put(items.get(i), i);\n+    }\n+\n+    PriorityQueue<T> inDegreeZero = new PriorityQueue<T>(items.size(),\n+        new Comparator<T>() {\n+      @Override\n+      public int compare(T a, T b) {\n+        return originalIndex.get(a).intValue() -\n+            originalIndex.get(b).intValue();\n+      }\n+    });\n+    List<T> result = Lists.newArrayList();\n+\n+    Multiset<T> inDegree = HashMultiset.create();\n+    Multimap<T, T> reverseDeps = ArrayListMultimap.create();\n+    Multimaps.invertFrom(deps, reverseDeps);\n+\n+    // First, add all the inputs with in-degree 0.\n+    for (T item : items) {\n+      Collection<T> itemDeps = deps.get(item);\n+      inDegree.add(item, itemDeps.size());\n+      if (itemDeps.isEmpty()) {\n+        inDegreeZero.add(item);\n+      }\n+    }\n+\n+    // Then, iterate to a fixed point over the reverse dependency graph.\n+    while (!inDegreeZero.isEmpty()) {\n+      T item = inDegreeZero.remove();\n+      result.add(item);\n+      for (T inWaiting : reverseDeps.get(item)) {\n+        inDegree.remove(inWaiting, 1);\n+        if (inDegree.count(inWaiting) == 0) {\n+          inDegreeZero.add(inWaiting);\n+        }\n+      }\n+    }\n+\n+    return result;\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/NameAnalyzerTest.java\n+++ b/test/com/google/javascript/jscomp/NameAnalyzerTest.java\n          \"var a = {b: {}}; a.d = 3; a.d;\");\n   }\n \n+  public void testSingletonGetter1() {\n+    test(\"function Foo() {} goog.addSingletonGetter(Foo);\", \"\");\n+  }\n+\n+  public void testSingletonGetter2() {\n+    test(\"function Foo() {} goog$addSingletonGetter(Foo);\", \"\");\n+  }\n+\n+  public void testSingletonGetter3() {\n+    // addSingletonGetter adds a getInstance method to a class.\n+    testSame(\"function Foo() {} goog$addSingletonGetter(Foo);\" +\n+        \"this.x = Foo.getInstance();\");\n+  }\n+\n   // TODO(user): Make NameAnalyzer handle this. The OR subexpressions may\n   // modify global state.\n   // public void testConditionallyDefinedFunction2() {", "timestamp": 1271699123, "metainfo": ""}