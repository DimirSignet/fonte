{"sha": "6924915efab89f921fd0779fe200fecc1bf80847", "log": "don't try to inline properties that we don't recognize, because they may be prototype properties. This isn't a perfect fix, but should get most cases. Fixes issue 724  R=acleung DELTA=82  (47 added, 21 deleted, 14 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4758   ", "commit": "\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n         Var v = it.next();\n \n         if (isVarInlineForbidden(v)) {\n-            continue;\n+          continue;\n         }\n \n         ReferenceCollection referenceInfo = referenceMap.getReferences(v);\n \n         if (isInlinableObject(referenceInfo.references)) {\n-            // Blacklist the object itself, as well as any other values\n-            // that it refers to, since they will have been moved around.\n-            staleVars.add(v);\n-\n-            Reference declaration = referenceInfo.references.get(0);\n-            Reference init = referenceInfo.getInitializingReference();\n-\n-            // Split up the object into individual variables if the object\n-            // is never referenced directly in full.\n-            splitObject(v, declaration, init, referenceInfo);\n+          // Blacklist the object itself, as well as any other values\n+          // that it refers to, since they will have been moved around.\n+          staleVars.add(v);\n+\n+          Reference declaration = referenceInfo.references.get(0);\n+          Reference init = referenceInfo.getInitializingReference();\n+\n+          // Split up the object into individual variables if the object\n+          // is never referenced directly in full.\n+          splitObject(v, declaration, init, referenceInfo);\n         }\n       }\n     }\n      */\n     private boolean isInlinableObject(List<Reference> refs) {\n       boolean ret = false;\n+      Set<String> validProperties = Sets.newHashSet();\n       for (Reference ref : refs) {\n         Node name = ref.getNode();\n         Node parent = ref.getParent();\n           if (gramps.isCall()\n               && gramps.getFirstChild() == parent) {\n             return false;\n+          }\n+\n+          // NOTE(nicksantos): This pass's object-splitting algorithm has\n+          // a blind spot. It assumes that if a property isn't defined on an\n+          // object, then the value is undefined. This is not true, because\n+          // Object.prototype can have arbitrary properties on it.\n+          //\n+          // We short-circuit this problem by bailing out if we see a reference\n+          // to a property that isn't defined on the object literal. This\n+          // isn't a perfect algorithm, but it should catch most cases.\n+          String propName = parent.getLastChild().getString();\n+          if (!validProperties.contains(propName)) {\n+            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n+              validProperties.add(propName);\n+            } else {\n+              return false;\n+            }\n           }\n           continue;\n         }\n             // ES5 get/set not supported.\n             return false;\n           }\n+\n+          validProperties.add(child.getString());\n+\n           Node childVal = child.getFirstChild();\n           // Check if childVal is the parent of any of the passed in\n           // references, as that is how self-referential assignments\n--- a/test/com/google/javascript/jscomp/InlineObjectLiteralsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineObjectLiteralsTest.java\n          \"JSCompiler_object_inline_a_0=a,JSCompiler_object_inline_b_1=b,true;\" +\n          \"if(JSCompiler_object_inline_a_0) g(JSCompiler_object_inline_b_1)\");\n     testLocal(\"var x = {}; var b = f(); x = {a:a, b:b}; if(x.a) g(x.b) + x.c\",\n-         \"var JSCompiler_object_inline_a_0;\" +\n-         \"var JSCompiler_object_inline_b_1;\" +\n-         \"var JSCompiler_object_inline_c_2;\" +\n-         \"var b=f();\" +\n-         \"JSCompiler_object_inline_a_0=a,JSCompiler_object_inline_b_1=b,\" +\n-         \"  JSCompiler_object_inline_c_2=void 0,true;\" +\n-         \"if(JSCompiler_object_inline_a_0) \" +\n-         \"  g(JSCompiler_object_inline_b_1) + JSCompiler_object_inline_c_2\");\n+         \"var x = {}; var b = f(); x = {a:a, b:b}; if(x.a) g(x.b) + x.c\");\n     testLocal(\"var x; var b = f(); x = {a:a, b:b}; x.c = c; if(x.a) g(x.b) + x.c\",\n          \"var JSCompiler_object_inline_a_0;\" +\n          \"var JSCompiler_object_inline_b_1;\" +\n \n   public void testObject12() {\n     testLocal(\"var a; a = {x:1, y:2}; f(a.x, a.y2);\",\n-         \"var JSCompiler_object_inline_x_0;\" +\n-         \"var JSCompiler_object_inline_y_1;\" +\n-         \"var JSCompiler_object_inline_y2_2;\" +\n-         \"JSCompiler_object_inline_x_0=1,\" +\n-         \"JSCompiler_object_inline_y_1=2,\" +\n-         \"JSCompiler_object_inline_y2_2=void 0,\" +\n-         \"true;\" +\n-         \"f(JSCompiler_object_inline_x_0, JSCompiler_object_inline_y2_2);\");\n+        \"var a; a = {x:1, y:2}; f(a.x, a.y2);\");\n   }\n \n   public void testObject13() {\n       \"}\");\n \n     testLocal(\"var a; while (1) { f(a.x, a.y); a = {x:1, y:1};}\",\n-      \"var JSCompiler_object_inline_x_0;\" +\n-      \"var JSCompiler_object_inline_y_1;\" +\n-      \"for(;1;) {\" +\n-      \" f(JSCompiler_object_inline_x_0,JSCompiler_object_inline_y_1);\" +\n-      \" JSCompiler_object_inline_x_0=1,\" +\n-      \" JSCompiler_object_inline_y_1=1,\" +\n-      \" true\" +\n-      \"}\");\n+        \"var a; while (1) { f(a.x, a.y); a = {x:1, y:1};}\");\n   }\n \n   public void testObject23() {\n     testLocal(\"var a; a = {}\", \"true\");\n   }\n \n+  public void testIssue724() {\n+    testSameLocal(\n+        \"var getType; getType = {};\" +\n+        \"return functionToCheck && \" +\n+        \"   getType.toString.apply(functionToCheck) === \" +\n+        \"   '[object Function]';\");\n+  }\n+\n   private final String LOCAL_PREFIX = \"function local(){\";\n   private final String LOCAL_POSTFIX = \"}\";\n \n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n     assertEquals(result, lastCompiler.toSource());\n   }\n \n+  public void testIssue724() {\n+    CompilerOptions options = createCompilerOptions();\n+    CompilationLevel.ADVANCED_OPTIMIZATIONS\n+        .setOptionsForCompilationLevel(options);\n+    String code =\n+        \"isFunction = function(functionToCheck) {\" +\n+        \"  var getType = {};\" +\n+        \"  return functionToCheck && \" +\n+        \"      getType.toString.apply(functionToCheck) === \" +\n+        \"     '[object Function]';\" +\n+        \"};\";\n+    String result =\n+        \"isFunction=function(a){var b={};\" +\n+        \"return a&&\\\"[object Function]\\\"===b.b.a(a)}\";\n+\n+    test(options, code, result);\n+  }\n+\n   public void testCoaleseVariables() {\n     CompilerOptions options = createCompilerOptions();\n ", "timestamp": 1336768550, "metainfo": ""}