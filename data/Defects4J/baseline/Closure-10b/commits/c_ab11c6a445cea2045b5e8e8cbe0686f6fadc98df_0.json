{"sha": "ab11c6a445cea2045b5e8e8cbe0686f6fadc98df", "log": "Limit the cases where InlineObjectLiterals performs its work.  R=fmeawad DELTA=88  (59 added, 22 deleted, 7 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2198   ", "commit": "\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n-import com.google.common.base.Predicates;\n import com.google.common.base.Supplier;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n   @Override\n   public void process(Node externs, Node root) {\n     ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n-        compiler, new InliningBehavior(), Predicates.<Var>alwaysTrue());\n+        compiler, new InliningBehavior());\n     callback.process(externs, root);\n   }\n \n         // Ignore indirect references, like x.y (except x.y(), since\n         // the function referenced by y might reference 'this').\n         //\n-        // TODO: If a function is called, figure out if it references\n-        // 'this', and if not, then inlining the object should be OK.\n-        if (parent.getType() == Token.GETPROP &&\n-            (gramps.getType() != Token.CALL ||\n-             gramps.getFirstChild() != parent) &&\n-            parent.getFirstChild().isEquivalentTo(name)) {\n-          continue;\n-        }\n-\n-        // Full references mean that we can't inline the object.\n-        if (!ref.isLvalue() && !ref.isInitializingDeclaration()) {\n-          if (parent.getType() != Token.VAR) {\n-            // This is a full reference to the object, we can't inline.\n+        if (parent.getType() == Token.GETPROP) {\n+          Preconditions.checkState(parent.getFirstChild() == name);\n+          // A call target maybe using the object as a 'this' value.\n+          if (gramps.getType() == Token.CALL\n+              && gramps.getFirstChild() == parent) {\n             return false;\n           }\n-\n-          // var x; We can ignore safely.\n           continue;\n+        }\n+\n+        // Only rewrite VAR declarations or simple assignment statements\n+        if (!isVarOrAssignExprLhs(name)) {\n+           return false;\n         }\n \n         Node val = ref.getAssignedValue();\n         if (val == null) {\n-          // Var with no assignment. Keep going.\n+          // A var with no assignment.\n           continue;\n         }\n \n           }\n         }\n \n-        // This is an assignment to an object literal. Make sure that\n-        // this isn't inside some giant GETPROP thing, e.g.\n-        // (x = {}).c = 5 (even though technically we could work out the\n-        // (x = {}).c case without the assignment, that's a sufficiently odd\n-        // case to not worry about it.\n-        Node p = parent;\n-        while ((p = p.getParent()) != null) {\n-          if (p.getType() == Token.GETPROP) {\n-            return false;\n-          }\n-        }\n \n         // We have found an acceptable object literal assignment. As\n         // long as there are no other assignments that mess things up,\n         ret = true;\n       }\n       return ret;\n+    }\n+\n+    private boolean isVarOrAssignExprLhs(Node n) {\n+      Node parent = n.getParent();\n+      return parent.getType() == Token.VAR ||\n+          (parent.getType() == Token.ASSIGN\n+              && parent.getFirstChild() == n\n+              && parent.getParent().getType() == Token.EXPR_RESULT);\n     }\n \n     /**\n--- a/test/com/google/javascript/jscomp/InlineObjectLiteralsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineObjectLiteralsTest.java\n       \"a = {a1: 100};\" +\n       \"print(a.a1);\");\n   }\n+\n+  public void testObject18() {\n+    testSame(\"var a,b; b=a={x:x, y:y}; f(b.x);\");\n+  }\n+\n+  public void testObject19() {\n+    testSame(\"var a,b; if(c) { b=a={x:x, y:y}; } else { b=a={x:y}; } f(b.x);\");\n+  }\n+\n+  public void testObject20() {\n+    testSame(\"var a,b; if(c) { b=a={x:x, y:y}; } else { b=a={x:y}; } f(a.x);\");\n+  }\n+\n+  public void testObject21() {\n+    testSame(\"var a,b; b=a={x:x, y:y};\");\n+    testSame(\"var a,b; if(c) { b=a={x:x, y:y}; }\" +\n+             \"else { b=a={x:y}; } f(a.x); f(b.x)\");\n+    testSame(\"var a, b; if(c) { if (a={x:x, y:y}) f(); } \" +\n+             \"else { b=a={x:y}; } f(a.x);\");\n+    testSame(\"var a,b; b = (a = {x:x, y:x});\");\n+    testSame(\"var a,b; a = {x:x, y:x}; b = a\");\n+    testSame(\"var a,b; a = {x:x, y:x}; b = x || a\");\n+    testSame(\"var a,b; a = {x:x, y:x}; b = y && a\");\n+    testSame(\"var a,b; a = {x:x, y:x}; b = y ? a : a\");\n+    testSame(\"var a,b; a = {x:x, y:x}; b = y , a\");\n+    testSame(\"b = x || (a = {x:1, y:2});\");\n+  }\n+\n+  public void testObject22() {\n+    test(\"while(1) { var a = {y:1}; if (b) a.x = 2; f(a.y, a.x);}\",\n+      \"for(;1;){\" +\n+      \" var JSCompiler_object_inline_y_0=1;\" +\n+      \" var JSCompiler_object_inline_x_1;\" +\n+      \" if(b) JSCompiler_object_inline_x_1=2;\" +\n+      \" f(JSCompiler_object_inline_y_0,JSCompiler_object_inline_x_1)\" +\n+      \"}\");\n+    test(\"var a; while (1) { f(a.x, a.y); a = {x:1, y:1};}\",\n+      \"var JSCompiler_object_inline_y_1;\" +\n+      \"var JSCompiler_object_inline_x_0;\" +\n+      \"for(;1;) {\" +\n+      \" f(JSCompiler_object_inline_x_0,JSCompiler_object_inline_y_1);\" +\n+      \" JSCompiler_object_inline_x_0=1,\" +\n+      \" JSCompiler_object_inline_y_1=1,\" +\n+      \" true\" +\n+      \"}\");\n+  }\n }", "timestamp": 1307463386, "metainfo": ""}