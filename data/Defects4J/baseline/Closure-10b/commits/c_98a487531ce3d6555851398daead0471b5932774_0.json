{"sha": "98a487531ce3d6555851398daead0471b5932774", "log": "Fix incosistent internal state caused by when multiple functions are inlined into the same expression.  R=nicksantos DELTA=300  (131 added, 51 deleted, 118 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5029   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n+++ b/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n    * @param expression The expression to be exposed.\n    * @see #canExposeExpression\n    */\n-  void maybeDecomposeExpression(Node expression) {\n+  void maybeExposeExpression(Node expression) {\n     // If the expression needs to exposed.\n     int i = 0;\n     while (DecompositionType.DECOMPOSABLE == canExposeExpression(expression)) {\n    * @see #canExposeExpression\n    */\n   void moveExpression(Node expression) {\n-    String resultName = getTempValueName();  // Should this be constant?\n+    String resultName = getResultValueName();\n     Node injectionPoint = findInjectionPoint(expression);\n     Preconditions.checkNotNull(injectionPoint);\n     Node injectionPointParent = injectionPoint.getParent();\n   }\n \n   private String tempNamePrefix = \"JSCompiler_temp\";\n+  private String resultNamePrefix = \"JSCompiler_inline_result\";\n \n   /**\n    * Allow the temp name to be overridden to make tests more readable.\n    */\n   @VisibleForTesting\n-  public void setTempNamePrefix(String tempNamePrefix) {\n-    this.tempNamePrefix = tempNamePrefix;\n+  public void setTempNamePrefix(String prefix) {\n+    this.tempNamePrefix = prefix;\n   }\n \n   /**\n   private String getTempValueName(){\n     return tempNamePrefix + ContextualRenamer.UNIQUE_ID_SEPARATOR\n         + safeNameIdSupplier.get();\n+  }\n+\n+  /**\n+   * Allow the temp name to be overridden to make tests more readable.\n+   */\n+  @VisibleForTesting\n+  public void setResultNamePrefix(String prefix) {\n+    this.resultNamePrefix = prefix;\n+  }\n+\n+  /**\n+   * Create a unique name for call results.\n+   */\n+  private String getResultValueName() {\n+    return resultNamePrefix\n+        + ContextualRenamer.UNIQUE_ID_SEPARATOR + safeNameIdSupplier.get();\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n import com.google.common.base.Supplier;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.ExpressionDecomposer.DecompositionType;\n-import com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenamer;\n-import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n      * Used for a call site for which there does not exist a method\n      * to inline it.\n      */\n-    UNSUPPORTED,\n+    UNSUPPORTED() {\n+      @Override\n+      public void prepare(FunctionInjector injector, Node callNode) {\n+        throw new IllegalStateException(\"unexpected\");\n+      }\n+    },\n \n     /**\n      * A call as a statement. For example: \"foo();\".\n      *   EXPR_RESULT\n      *     CALL\n      */\n-    SIMPLE_CALL,\n+    SIMPLE_CALL() {\n+      @Override\n+      public void prepare(FunctionInjector injector, Node callNode) {\n+        // Nothing to do.\n+      }\n+    },\n \n     /**\n      * An assignment, where the result of the call is assigned to a simple\n      *     CALL\n      *       FOO\n      */\n-    SIMPLE_ASSIGNMENT,\n-\n+    SIMPLE_ASSIGNMENT() {\n+      @Override\n+      public void prepare(FunctionInjector injector, Node callNode) {\n+        // Nothing to do.\n+      }\n+    },\n     /**\n      * An var declaration and initialization, where the result of the call is\n      * assigned to the declared name\n      *       CALL\n      *         FOO\n      */\n-    VAR_DECL_SIMPLE_ASSIGNMENT,\n-\n+    VAR_DECL_SIMPLE_ASSIGNMENT() {\n+      @Override\n+      public void prepare(FunctionInjector injector, Node callNode) {\n+        // Nothing to do.\n+      }\n+    },\n     /**\n      * An arbitrary expression, the root of which is a EXPR_RESULT, IF,\n      * RETURN, SWITCH or VAR.  The call must be the first side-effect in\n      *   \"foo() ? 1:0\"\n      *   \"foo() && x\"\n      */\n-    EXPRESSION,\n+    EXPRESSION() {\n+      @Override\n+      public void prepare(FunctionInjector injector, Node callNode) {\n+        injector.getDecomposer().moveExpression(callNode);\n+\n+        // Reclassify after move\n+        CallSiteType callSiteType = injector.classifyCallSite(callNode);\n+        Preconditions.checkState(this != callSiteType);\n+        callSiteType.prepare(injector, callNode);\n+      }\n+    },\n \n     /**\n      * An arbitrary expression, the root of which is a EXPR_RESULT, IF,\n      * RETURN, SWITCH or VAR.  Where the call is not the first side-effect in\n      * the expression.\n      */\n-    DECOMPOSABLE_EXPRESSION,\n+    DECOMPOSABLE_EXPRESSION() {\n+      @Override\n+      public void prepare(FunctionInjector injector, Node callNode) {\n+        injector.getDecomposer().maybeExposeExpression(callNode);\n+\n+        // Reclassify after decomposition\n+        CallSiteType callSiteType = injector.classifyCallSite(callNode);\n+        Preconditions.checkState(this != callSiteType);\n+        callSiteType.prepare(injector, callNode);\n+      }\n+    };\n+\n+    public abstract void prepare(FunctionInjector injector, Node callNode);\n   }\n \n   /**\n         && grandParent.hasOneChild()) {\n       // This is a var declaration.  Example: \"var x = foo();\"\n       // TODO(johnlenz): Should we be checking for constants on the\n-      // left-hand-side of the assignments (and handling them as EXPRESSION?\n+      // left-hand-side of the assignments and handling them as EXPRESSION?\n       return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT;\n     } else {\n       Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode);\n     return CallSiteType.UNSUPPORTED;\n   }\n \n+  private ExpressionDecomposer getDecomposer() {\n+    return new ExpressionDecomposer(\n+        compiler, safeNameIdSupplier, knownConstants);\n+  }\n+\n+  /**\n+   * If required, rewrite the statement containing the call expression.\n+   * @see ExpressionDecomposer#canExposeExpression\n+   */\n+  void maybePrepareCall(Node callNode) {\n+    CallSiteType callSiteType = classifyCallSite(callNode);\n+    callSiteType.prepare(this, callNode);\n+  }\n+\n   /**\n    * Inline a function which fulfills the requirements of\n    * canInlineReferenceAsStatementBlock into the call site, replacing the\n         break;\n \n       case EXPRESSION:\n-        resultName = getUniqueResultName();\n-        // The intermediary result has a default value of \"undefined\", so\n-        // we only need to set the implicit return value if we are in a loop\n-        // and the variable maybe reused.\n-        needsDefaultReturnResult = isCallInLoop;\n-        break;\n+        throw new IllegalStateException(\n+            \"Movable expressions must be moved before inlining.\");\n \n       case DECOMPOSABLE_EXPRESSION:\n         throw new IllegalStateException(\n-            \"Decomposable expressions must decomposed before inlining.\");\n+            \"Decomposable expressions must be decomposed before inlining.\");\n \n       default:\n         throw new IllegalStateException(\"Unexpected call site type.\");\n         grandParent.replaceChild(parent, newBlock);\n         break;\n \n-      case EXPRESSION:\n-        // TODO(johnlenz): Maybe change this so that movable and decomposable\n-        // expressions are handled the same way: The call is moved and\n-        // then handled by one the three basic cases, rather than\n-        // introducing a new case.\n-        Node injectionPoint = ExpressionDecomposer.findInjectionPoint(callNode);\n-        Preconditions.checkNotNull(injectionPoint);\n-        Node injectionPointParent = injectionPoint.getParent();\n-        Preconditions.checkNotNull(injectionPointParent);\n-        Preconditions.checkState(\n-            NodeUtil.isStatementBlock(injectionPointParent));\n-\n-        // Declare the intermediate result name.\n-        newBlock.addChildrenToFront(\n-            NodeUtil.newVarNode(resultName, null)\n-                 .copyInformationFromForTree(callNode));\n-        // Inline the function before the selected injection point (before\n-        // the call).\n-        injectionPointParent.addChildBefore(newBlock, injectionPoint);\n-        // Replace the call site with a reference to the intermediate\n-        // result name.\n-        parent.replaceChild(callNode, IR.name(resultName));\n-        break;\n-\n       default:\n         throw new IllegalStateException(\"Unexpected call site type.\");\n     }\n \n   enum CanInlineResult {\n     YES,\n-    AFTER_DECOMPOSITION,\n+    AFTER_PREPARATION,\n     NO\n   }\n \n     }\n \n     if (!allowDecomposition\n-        && callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION) {\n+        && (callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION\n+            || callSiteType == CallSiteType.EXPRESSION)) {\n       return CanInlineResult.NO;\n     }\n \n       return CanInlineResult.NO;\n     }\n \n-    if (callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION)  {\n-      return CanInlineResult.AFTER_DECOMPOSITION;\n+    if (callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION\n+        || callSiteType == CallSiteType.EXPRESSION) {\n+      return CanInlineResult.AFTER_PREPARATION;\n     } else {\n       return CanInlineResult.YES;\n     }\n   }\n \n   /**\n-   * Parameter names will be name unique when at a later time.\n-   */\n-  private String getUniqueResultName() {\n-    return \"JSCompiler_inline_result\"\n-        + ContextualRenamer.UNIQUE_ID_SEPARATOR + safeNameIdSupplier.get();\n-  }\n-\n-  /**\n    * Determine if inlining the function is likely to reduce the code size.\n    * @param namesToAlias\n    */\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n       if (result != CanInlineResult.NO) {\n         // Yeah!\n         boolean decompose =\n-          (result == CanInlineResult.AFTER_DECOMPOSITION);\n+          (result == CanInlineResult.AFTER_PREPARATION);\n         fs.addReference(new Reference(callNode, module, mode, decompose));\n         return true;\n       }\n    */\n   private void resolveInlineConflictsForFunction(FunctionState fs) {\n     // Functions that aren't referenced don't cause conflicts.\n-    if (!fs.hasReferences()) {\n+    if (!fs.hasReferences() || !fs.canInline()) {\n       return;\n     }\n \n       if (fs.canInline()) {\n         for (Reference ref : fs.getReferences()) {\n           if (ref.requiresDecomposition) {\n-            decomposer.maybeDecomposeExpression(ref.callNode);\n+            injector.maybePrepareCall(ref.callNode);\n           }\n         }\n       }\n--- a/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java\n+++ b/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java\n         \"HangoutStarter.prototype.launchHangout = function() {\" +\n         \"  var self=a.b;\" +\n         \"  var temp_const$$0=goog.Uri;\" +\n-        \"  var temp$$0=getDomServices_(self);\" +\n-        \"  var myUrl=new temp_const$$0(temp$$0.getDomHelper().\" +\n+        \"  var result$$0=getDomServices_(self);\" +\n+        \"  var myUrl=new temp_const$$0(result$$0.getDomHelper().\" +\n         \"      getWindow().location.href)}\");\n   }\n \n   public void testMoveExpression1() {\n     // There isn't a reason to do this, but it works.\n-    helperMoveExpression(\"foo()\", \"foo\", \"var temp$$0 = foo(); temp$$0;\");\n+    helperMoveExpression(\"foo()\", \"foo\", \"var result$$0 = foo(); result$$0;\");\n   }\n \n   public void testMoveExpression2() {\n     helperMoveExpression(\n         \"x = foo()\",\n         \"foo\",\n-        \"var temp$$0 = foo(); x = temp$$0;\");\n+        \"var result$$0 = foo(); x = result$$0;\");\n   }\n \n   public void testMoveExpression3() {\n     helperMoveExpression(\n         \"var x = foo()\",\n         \"foo\",\n-        \"var temp$$0 = foo(); var x = temp$$0;\");\n+        \"var result$$0 = foo(); var x = result$$0;\");\n   }\n \n   public void testMoveExpression4() {\n     helperMoveExpression(\n         \"if(foo()){}\",\n         \"foo\",\n-        \"var temp$$0 = foo(); if (temp$$0);\");\n+        \"var result$$0 = foo(); if (result$$0);\");\n   }\n \n   public void testMoveExpression5() {\n     helperMoveExpression(\n         \"switch(foo()){}\",\n         \"foo\",\n-        \"var temp$$0 = foo(); switch(temp$$0){}\");\n+        \"var result$$0 = foo(); switch(result$$0){}\");\n   }\n \n   public void testMoveExpression6() {\n     helperMoveExpression(\n         \"switch(1 + foo()){}\",\n         \"foo\",\n-        \"var temp$$0 = foo(); switch(1 + temp$$0){}\");\n+        \"var result$$0 = foo(); switch(1 + result$$0){}\");\n   }\n \n   public void testMoveExpression7() {\n     helperMoveExpression(\n         \"function f(){ return foo();}\",\n         \"foo\",\n-        \"function f(){ var temp$$0 = foo(); return temp$$0;}\");\n+        \"function f(){ var result$$0 = foo(); return result$$0;}\");\n   }\n \n   public void testMoveExpression8() {\n     helperMoveExpression(\n         \"x = foo() && 1\",\n         \"foo\",\n-        \"var temp$$0 = foo(); x = temp$$0 && 1\");\n+        \"var result$$0 = foo(); x = result$$0 && 1\");\n   }\n \n   public void testMoveExpression9() {\n     helperMoveExpression(\n         \"x = foo() || 1\",\n         \"foo\",\n-        \"var temp$$0 = foo(); x = temp$$0 || 1\");\n+        \"var result$$0 = foo(); x = result$$0 || 1\");\n   }\n \n   public void testMoveExpression10() {\n     helperMoveExpression(\n         \"x = foo() ? 0 : 1\",\n         \"foo\",\n-        \"var temp$$0 = foo(); x = temp$$0 ? 0 : 1\");\n+        \"var result$$0 = foo(); x = result$$0 ? 0 : 1\");\n   }\n \n   /* Decomposition tests. */\n     helperMoveExpression(\n         \"var x = {get a() {}, b: foo()};\",\n         \"foo\",\n-        \"var temp$$0=foo();var x = {get a() {}, b: temp$$0};\");\n+        \"var result$$0=foo();var x = {get a() {}, b: result$$0};\");\n \n     helperMoveExpression(\n         \"var x = {set a(p) {}, b: foo()};\",\n         \"foo\",\n-        \"var temp$$0=foo();var x = {set a(p) {}, b: temp$$0};\");\n+        \"var result$$0=foo();var x = {set a(p) {}, b: result$$0};\");\n   }\n \n   /** Test case helpers. */\n     ExpressionDecomposer decomposer = new ExpressionDecomposer(\n         compiler, compiler.getUniqueNameIdSupplier(), knownConstants);\n     decomposer.setTempNamePrefix(\"temp\");\n+    decomposer.setResultNamePrefix(\"result\");\n     Node expectedRoot = parse(compiler, expectedResult);\n     Node tree = parse(compiler, code);\n     assertNotNull(tree);\n     ExpressionDecomposer decomposer = new ExpressionDecomposer(\n         compiler, compiler.getUniqueNameIdSupplier(), knownConstants);\n     decomposer.setTempNamePrefix(\"temp\");\n+    decomposer.setResultNamePrefix(\"result\");\n     Node expectedRoot = parse(compiler, expectedResult);\n     Node tree = parse(compiler, code);\n     assertNotNull(tree);\n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n     // \"foo\" is not known to be side-effect free, it might change the value\n     // of \"x\", so it can't be inlined.\n     helperCanInlineReferenceToFunction(\n-        CanInlineResult.AFTER_DECOMPOSITION,\n+        CanInlineResult.AFTER_PREPARATION,\n         \"function foo(){return true;}; var x; x=x+foo();\",\n         \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testCanInlineReferenceToFunctionInExpression1() {\n     // Call in if condition\n-    helperCanInlineReferenceToFunction(CanInlineResult.YES,\n+    helperCanInlineReferenceToFunction(CanInlineResult.AFTER_PREPARATION,\n         \"function foo(a){return true;}; \" +\n         \"function x() { if (foo(1)) throw 'test'; }\",\n-        \"foo\", INLINE_BLOCK);\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testCanInlineReferenceToFunctionInExpression2() {\n     // Call in return expression\n-    helperCanInlineReferenceToFunction(CanInlineResult.YES,\n+    helperCanInlineReferenceToFunction(CanInlineResult.AFTER_PREPARATION,\n         \"function foo(a){return true;}; \" +\n         \"function x() { return foo(1); }\",\n-        \"foo\", INLINE_BLOCK);\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testCanInlineReferenceToFunctionInExpression3() {\n     // Call in switch expression\n-    helperCanInlineReferenceToFunction(CanInlineResult.YES,\n+    helperCanInlineReferenceToFunction(CanInlineResult.AFTER_PREPARATION,\n         \"function foo(a){return true;}; \" +\n         \"function x() { switch(foo(1)) { default:break; } }\",\n-        \"foo\", INLINE_BLOCK);\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testCanInlineReferenceToFunctionInExpression4() {\n     // Call in hook condition\n-    helperCanInlineReferenceToFunction(CanInlineResult.YES,\n+    helperCanInlineReferenceToFunction(CanInlineResult.AFTER_PREPARATION,\n         \"function foo(a){return true;}; \" +\n         \"function x() {foo(1)?0:1 }\",\n-        \"foo\", INLINE_BLOCK);\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testCanInlineReferenceToFunctionInExpression5() {\n  public void testCanInlineReferenceToFunctionInExpression5a() {\n     // Call in hook side-effect free condition\n     helperCanInlineReferenceToFunction(\n-        CanInlineResult.AFTER_DECOMPOSITION,\n+        CanInlineResult.AFTER_PREPARATION,\n         \"function foo(a){return true;}; \" +\n         \"function x() {true?foo(1):1 }\",\n         \"foo\", INLINE_BLOCK, true);\n \n   public void testCanInlineReferenceToFunctionInExpression6() {\n     // Call in expression statement \"condition\"\n-    helperCanInlineReferenceToFunction(CanInlineResult.YES,\n+    helperCanInlineReferenceToFunction(CanInlineResult.AFTER_PREPARATION,\n         \"function foo(a){return true;}; \" +\n         \"function x() {foo(1) && 1 }\",\n-        \"foo\", INLINE_BLOCK);\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testCanInlineReferenceToFunctionInExpression7() {\n   public void testCanInlineReferenceToFunctionInExpression7a() {\n     // Call in expression statement after side-effect free \"condition\"\n     helperCanInlineReferenceToFunction(\n-        CanInlineResult.AFTER_DECOMPOSITION,\n+        CanInlineResult.AFTER_PREPARATION,\n         \"function foo(a){return true;}; \" +\n         \"function x() {1 && foo(1) }\",\n         \"foo\", INLINE_BLOCK, true);\n \n   public void testCanInlineReferenceToFunctionInExpression8() {\n     // Call in expression statement after side-effect free operator\n-    helperCanInlineReferenceToFunction(CanInlineResult.YES,\n+    helperCanInlineReferenceToFunction(CanInlineResult.AFTER_PREPARATION,\n         \"function foo(a){return true;}; \" +\n         \"function x() {1 + foo(1) }\",\n-        \"foo\", INLINE_BLOCK);\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testCanInlineReferenceToFunctionInExpression9() {\n     // Call in VAR expression.\n-    helperCanInlineReferenceToFunction(CanInlineResult.YES,\n+    helperCanInlineReferenceToFunction(CanInlineResult.AFTER_PREPARATION,\n         \"function foo(a){return true;}; \" +\n         \"function x() {var b = 1 + foo(1)}\",\n-        \"foo\", INLINE_BLOCK);\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testCanInlineReferenceToFunctionInExpression10() {\n   public void testCanInlineReferenceToFunctionInExpression10a() {\n     // Call in assignment expression.\n     helperCanInlineReferenceToFunction(\n-        CanInlineResult.AFTER_DECOMPOSITION,\n+        CanInlineResult.AFTER_PREPARATION,\n         \"function foo(a){return true;}; \" +\n         \"function x() {var b; b += 1 + foo(1) }\",\n         \"foo\", INLINE_BLOCK, true);\n //   }\n \n   public void testCanInlineReferenceToFunctionInExpression12() {\n-    helperCanInlineReferenceToFunction(CanInlineResult.YES,\n+    helperCanInlineReferenceToFunction(CanInlineResult.AFTER_PREPARATION,\n         \"function foo(a){return true;}; \" +\n         \"function x() {var a,b,c; a = b = c = foo(1) }\",\n-        \"foo\", INLINE_BLOCK);\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testCanInlineReferenceToFunctionInExpression13() {\n-    helperCanInlineReferenceToFunction(CanInlineResult.YES,\n+    helperCanInlineReferenceToFunction(CanInlineResult.AFTER_PREPARATION,\n         \"function foo(a){return true;}; \" +\n         \"function x() {var a,b,c; a = b = c = 1 + foo(1) }\",\n-        \"foo\", INLINE_BLOCK);\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testCanInlineReferenceToFunctionInExpression14() {\n   public void testCanInlineReferenceToFunctionInExpression14a() {\n     // ... foo can be inlined despite possible changes to \"c\".\n     helperCanInlineReferenceToFunction(\n-        CanInlineResult.AFTER_DECOMPOSITION,\n+        CanInlineResult.AFTER_PREPARATION,\n         \"var a = {}, b = {}, c;\" +\n         \"a.test = 'a';\" +\n         \"b.test = 'b';\" +\n \n   public void testCanInlineReferenceToFunctionInExpression18() {\n     // Call in within a call\n-    helperCanInlineReferenceToFunction(CanInlineResult.YES,\n+    helperCanInlineReferenceToFunction(CanInlineResult.AFTER_PREPARATION,\n         \"function foo(){return _g();}; \" +\n         \"function x() {1 + foo()() }\",\n-        \"foo\", INLINE_BLOCK);\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testCanInlineReferenceToFunctionInExpression19() {\n     // change the value of \"_g\" which would unfortunately change the behavior,\n     // so we can't inline here.\n     helperCanInlineReferenceToFunction(\n-        CanInlineResult.AFTER_DECOMPOSITION,\n+        CanInlineResult.AFTER_PREPARATION,\n         \"function foo(){return a;}; \" +\n         \"function x() {1 + _g(foo()) }\",\n         \"foo\", INLINE_BLOCK, true);\n     // Note: This could be changed be inlined if we in some way make \"z\"\n     // as not escaping from the local scope.\n     helperCanInlineReferenceToFunction(\n-        CanInlineResult.AFTER_DECOMPOSITION,\n+        CanInlineResult.AFTER_PREPARATION,\n         \"var z = {};\" +\n         \"function foo(a){z = {};return true;}; \" +\n         \"function x() { z.gack = foo(1) }\",\n   public void testCanInlineReferenceToFunctionInExpression22a() {\n     // ... foo() is after a side-effect\n     helperCanInlineReferenceToFunction(\n-        CanInlineResult.AFTER_DECOMPOSITION,\n+        CanInlineResult.AFTER_PREPARATION,\n         \"function foo(){return a;}; \" +\n         \"function x() {1 + _g(_a(), foo()) }\",\n         \"foo\", INLINE_BLOCK, true);\n   public void testCanInlineReferenceToFunctionInExpression23a() {\n     // ... foo() is after a side-effect\n     helperCanInlineReferenceToFunction(\n-        CanInlineResult.AFTER_DECOMPOSITION,\n+        CanInlineResult.AFTER_PREPARATION,\n         \"function foo(){return a;}; \" +\n         \"function x() {1 + _g(_a(), foo.call(this)) }\",\n         \"foo\", INLINE_BLOCK, true);\n         \"function foo(a){return true;}; \" +\n         \"function x() { if (foo(1)) throw 'test'; }\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { {var JSCompiler_inline_result$$0; \" +\n-        \"JSCompiler_inline_result$$0=true;}\" +\n+        \"function x() { var JSCompiler_inline_result$$0; \" +\n+        \"{JSCompiler_inline_result$$0=true;}\" +\n         \"if (JSCompiler_inline_result$$0) throw 'test'; }\",\n-        \"foo\", INLINE_BLOCK);\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testInlineReferenceInExpression2() {\n         \"function foo(a){return true;}; \" +\n         \"function x() { return foo(1); }\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { {var JSCompiler_inline_result$$0; \" +\n-        \"JSCompiler_inline_result$$0=true;}\" +\n+        \"function x() { var JSCompiler_inline_result$$0; \" +\n+        \"{JSCompiler_inline_result$$0=true;}\" +\n         \"return JSCompiler_inline_result$$0; }\",\n-        \"foo\", INLINE_BLOCK);\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testInlineReferenceInExpression3() {\n         \"function foo(a){return true;}; \" +\n         \"function x() { switch(foo(1)) { default:break; } }\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { {var JSCompiler_inline_result$$0; \" +\n-        \"JSCompiler_inline_result$$0=true;}\" +\n+        \"function x() { var JSCompiler_inline_result$$0; \" +\n+        \"{JSCompiler_inline_result$$0=true;}\" +\n         \"switch(JSCompiler_inline_result$$0) { default:break; } }\",\n-        \"foo\", INLINE_BLOCK);\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testInlineReferenceInExpression4() {\n         \"function foo(a){return true;}; \" +\n         \"function x() {foo(1)?0:1 }\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { {var JSCompiler_inline_result$$0; \" +\n-        \"JSCompiler_inline_result$$0=true;}\" +\n+        \"function x() { var JSCompiler_inline_result$$0; \" +\n+        \"{JSCompiler_inline_result$$0=true;}\" +\n         \"JSCompiler_inline_result$$0?0:1 }\",\n-        \"foo\", INLINE_BLOCK);\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testInlineReferenceInExpression5() {\n         \"function foo(a){return true;}; \" +\n         \"function x() {foo(1)&&1 }\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { {var JSCompiler_inline_result$$0; \" +\n-        \"JSCompiler_inline_result$$0=true;}\" +\n+        \"function x() { var JSCompiler_inline_result$$0; \" +\n+        \"{JSCompiler_inline_result$$0=true;}\" +\n         \"JSCompiler_inline_result$$0&&1 }\",\n-        \"foo\", INLINE_BLOCK);\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testInlineReferenceInExpression6() {\n         \"function foo(a){return true;}; \" +\n         \"function x() {1 + foo(1) }\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { {var JSCompiler_inline_result$$0; \" +\n-        \"JSCompiler_inline_result$$0=true;}\" +\n+        \"function x() { var JSCompiler_inline_result$$0; \" +\n+        \"{JSCompiler_inline_result$$0=true;}\" +\n         \"1 + JSCompiler_inline_result$$0 }\",\n-        \"foo\", INLINE_BLOCK);\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testInlineReferenceInExpression7() {\n         \"function foo(a){return true;}; \" +\n         \"function x() {foo(1) && 1 }\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { {var JSCompiler_inline_result$$0; \" +\n-        \"JSCompiler_inline_result$$0=true;}\" +\n+        \"function x() { var JSCompiler_inline_result$$0; \" +\n+        \"{JSCompiler_inline_result$$0=true;}\" +\n         \"JSCompiler_inline_result$$0&&1 }\",\n-        \"foo\", INLINE_BLOCK);\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testInlineReferenceInExpression8() {\n         \"function foo(a){return true;}; \" +\n         \"function x() {1 + foo(1) }\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { {var JSCompiler_inline_result$$0; \" +\n-        \"JSCompiler_inline_result$$0=true;}\" +\n+        \"function x() { var JSCompiler_inline_result$$0;\" +\n+        \"{JSCompiler_inline_result$$0=true;}\" +\n         \"1 + JSCompiler_inline_result$$0 }\",\n-        \"foo\", INLINE_BLOCK);\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testInlineReferenceInExpression9() {\n         \"function foo(a){return true;}; \" +\n         \"function x() {var b = 1 + foo(1)}\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { {var JSCompiler_inline_result$$0; \" +\n-        \"JSCompiler_inline_result$$0=true;}\" +\n-        \"var b = 1 + JSCompiler_inline_result$$0 }\",\n-        \"foo\", INLINE_BLOCK);\n+        \"function x() { \" +\n+        \"var JSCompiler_inline_result$$0;\" +\n+        \"{JSCompiler_inline_result$$0=true;}\" +\n+        \"var b = 1 + JSCompiler_inline_result$$0 \" +\n+        \"}\",\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n // TODO(nicksantos): Re-enable with side-effect detection.\n         \"function foo(a){return true;}; \" +\n         \"function x() {a:foo(1)?0:1 }\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { a:{{var JSCompiler_inline_result$$0; \" +\n-        \"JSCompiler_inline_result$$0=true;}\" +\n-        \"JSCompiler_inline_result$$0?0:1 }}\",\n-        \"foo\", INLINE_BLOCK);\n+        \"function x() {\" +\n+        \"  a:{\" +\n+        \"    var JSCompiler_inline_result$$0; \" +\n+        \"    {JSCompiler_inline_result$$0=true;}\" +\n+        \"    JSCompiler_inline_result$$0?0:1 \" +\n+        \"  }\" +\n+        \"}\",\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testInlineReferenceInExpression12() {\n     helperInlineReferenceToFunction(\n-        \"function foo(a){return true;}; \" +\n-        \"function x() {1?foo(1):1 }\",\n-        \"function foo(a){return true;}; \" +\n-        \"function x() { if(1) { {true;} } else { 1 }}\",\n+        \"function foo(a){return true;}\" +\n+        \"function x() { 1?foo(1):1; }\",\n+        \"function foo(a){return true}\" +\n+        \"function x() {\" +\n+        \"  if(1) {\" +\n+        \"    {true;}\" +\n+        \"  } else {\" +\n+        \"    1;\" +\n+        \"  }\" +\n+        \"}\",\n         \"foo\", INLINE_BLOCK, true);\n   }\n \n         \"function foo(a){z = {};return true;}; \" +\n         \"function x() {\" +\n             \"var JSCompiler_temp_const$$0=z;\" +\n+            \"var JSCompiler_inline_result$$1;\" +\n             \"{\" +\n-             \"var JSCompiler_inline_result$$1;\" +\n              \"z= {};\" +\n              \"JSCompiler_inline_result$$1 = true;\" +\n             \"}\" +\n         \"function foo(a){z = {};return true;}; \" +\n         \"function x() {\" +\n             \"var JSCompiler_temp_const$$0=z;\" +\n+            \"var JSCompiler_inline_result$$1;\" +\n             \"{\" +\n-             \"var JSCompiler_inline_result$$1;\" +\n              \"z= {};\" +\n              \"JSCompiler_inline_result$$1 = true;\" +\n             \"}\" +\n         \"function x() {\" +\n             \"var JSCompiler_temp_const$$1=z;\" +\n             \"var JSCompiler_temp_const$$0=bar();\" +\n+            \"var JSCompiler_inline_result$$2;\" +\n             \"{\" +\n-             \"var JSCompiler_inline_result$$2;\" +\n              \"z= {};\" +\n              \"JSCompiler_inline_result$$2 = true;\" +\n             \"}\" +\n         \"function foo(a){z = {};return true;}; \" +\n         \"function x() {\" +\n             \"var JSCompiler_temp_const$$0=z.y.x;\" +\n+            \"var JSCompiler_inline_result$$1;\" +\n             \"{\" +\n-             \"var JSCompiler_inline_result$$1;\" +\n              \"z= {};\" +\n              \"JSCompiler_inline_result$$1 = true;\" +\n             \"}\" +\n         \"function foo(){return _g;}; \" +\n         \"function x() {1 + foo()() }\",\n         \"function foo(){return _g;}; \" +\n-        \"function x() { {var JSCompiler_inline_result$$0; \" +\n-        \"JSCompiler_inline_result$$0=_g;}\" +\n+        \"function x() { var JSCompiler_inline_result$$0;\" +\n+        \"{JSCompiler_inline_result$$0=_g;}\" +\n         \"1 + JSCompiler_inline_result$$0() }\",\n-        \"foo\", INLINE_BLOCK);\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n // TODO(nicksantos): Re-enable with side-effect detection.\n //         \"function x() { {var JSCompiler_inline_result$$0; \" +\n //         \"JSCompiler_inline_result$$0=true;}\" +\n //         \"1 + _g(JSCompiler_inline_result$$0) }\",\n-//         \"foo\", INLINE_BLOCK);\n+//         \"foo\", INLINE_BLOCK, true);\n //   }\n \n   public void testInlineAssignmentToConstant() {\n \n         \"function foo(){return _g;}; \" +\n         \"function x() {\" +\n-        \"  {var JSCompiler_inline_result$$0; JSCompiler_inline_result$$0=_g;}\" +\n+        \"  var JSCompiler_inline_result$$0;\" +\n+        \"  {JSCompiler_inline_result$$0=_g;}\" +\n         \"  var CONSTANT_RESULT = JSCompiler_inline_result$$0;\" +\n         \"}\",\n-        \"foo\", INLINE_BLOCK);\n+        \"foo\", INLINE_BLOCK, true);\n   }\n \n   public void testBug1897706() {\n         if (decompose) {\n           assertTrue(\"canInlineReferenceToFunction \" +\n               \"should be CAN_INLINE_AFTER_DECOMPOSITION\",\n-              CanInlineResult.AFTER_DECOMPOSITION == canInline);\n+              CanInlineResult.AFTER_PREPARATION == canInline);\n \n           Set<String> knownConstants = Sets.newHashSet();\n+          ExpressionDecomposer decomposer = new ExpressionDecomposer(\n+              compiler, compiler.getUniqueNameIdSupplier(), knownConstants);\n           injector.setKnownConstants(knownConstants);\n-          new ExpressionDecomposer(\n-              compiler, compiler.getUniqueNameIdSupplier(), knownConstants)\n-                  .maybeDecomposeExpression(n);\n+          injector.maybePrepareCall(n);\n+\n           assertTrue(\"canInlineReferenceToFunction \" +\n               \"should be CAN_INLINE\",\n               CanInlineResult.YES != canInline);\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n          \"var d=b()+foo()\",\n \n          \"var JSCompiler_temp_const$$0 = c;\\n\" +\n+         \"var JSCompiler_inline_result$$1;\\n\" +\n          \"{\\n\" +\n-         \"var JSCompiler_inline_result$$1;\\n\" +\n          \"var x$$inline_2;\\n\" +\n          \"JSCompiler_inline_result$$1 = \" +\n          \"    function(a$$inline_3){ return a$$inline_3+1 };\\n\" +\n \n          \"function _x() { \\n\" +\n          \"  var JSCompiler_temp_const$$0 = c;\\n\" +\n+         \"  var JSCompiler_inline_result$$1;\\n\" +\n          \"  {\\n\" +\n-         \"  var JSCompiler_inline_result$$1;\\n\" +\n          \"  var x$$inline_2;\\n\" +\n          \"  JSCompiler_inline_result$$1 = \" +\n          \"      function(a$$inline_3) {return a$$inline_3+1};\\n\" +\n     test(\"var window = {}; function foo(){window.bar++; return 3;}\" +\n         \"var x = {y: 1, z: foo(2)};\",\n         \"var window={};\" +\n+        \"var JSCompiler_inline_result$$0;\" +\n         \"{\" +\n-        \"  var JSCompiler_inline_result$$0;\" +\n         \"  window.bar++;\" +\n         \"  JSCompiler_inline_result$$0 = 3;\" +\n         \"}\" +\n         \"var x = {y: alert(), z: foo(2)};\",\n         \"var window = {};\" +\n         \"var JSCompiler_temp_const$$0 = alert();\" +\n+        \"var JSCompiler_inline_result$$1;\" +\n         \"{\" +\n-        \" var JSCompiler_inline_result$$1;\" +\n         \" window.bar++;\" +\n         \" JSCompiler_inline_result$$1 = 3;}\" +\n         \"var x = {\" +\n         \"var window = {};\" +\n         \"var JSCompiler_temp_const$$1 = alert();\" +\n         \"var JSCompiler_temp_const$$0 = alert2();\" +\n+        \"var JSCompiler_inline_result$$2;\" +\n         \"{\" +\n-        \" var JSCompiler_inline_result$$2;\" +\n         \" window.bar++;\" +\n         \" JSCompiler_inline_result$$2 = 3;}\" +\n         \"var x = {\" +\n \n   public void testComplexInlineInExpresssions2() {\n     test(\"function f(){a()}c=z=f()\",\n-         \"{var JSCompiler_inline_result$$0;a();}\" +\n+         \"var JSCompiler_inline_result$$0;\" +\n+         \"{a();JSCompiler_inline_result$$0=void 0;}\" +\n          \"c=z=JSCompiler_inline_result$$0\");\n   }\n \n   public void testComplexInlineInExpresssions3() {\n     test(\"function f(){a()}c=z=f()\",\n-        \"{var JSCompiler_inline_result$$0;a();}\" +\n+        \"var JSCompiler_inline_result$$0;\" +\n+        \"{a();JSCompiler_inline_result$$0=void 0;}\" +\n         \"c=z=JSCompiler_inline_result$$0\");\n   }\n \n   public void testComplexInlineInExpresssions4() {\n     test(\"function f(){a()}if(z=f());\",\n-        \"{var JSCompiler_inline_result$$0;a();}\" +\n+        \"var JSCompiler_inline_result$$0;\" +\n+        \"{a();JSCompiler_inline_result$$0=void 0;}\" +\n         \"if(z=JSCompiler_inline_result$$0);\");\n   }\n \n   public void testComplexInlineInExpresssions5() {\n     test(\"function f(){a()}if(z.y=f());\",\n          \"var JSCompiler_temp_const$$0=z;\" +\n-         \"{var JSCompiler_inline_result$$1;a()}\" +\n+         \"var JSCompiler_inline_result$$1;\" +\n+         \"{a();JSCompiler_inline_result$$1=void 0;}\" +\n          \"if(JSCompiler_temp_const$$0.y=JSCompiler_inline_result$$1);\");\n   }\n \n     test(\"function f(){a=1;return 1} var x = 1; x += f()\",\n         \"var x = 1;\" +\n         \"var JSCompiler_temp_const$$0 = x;\" +\n-        \"{var JSCompiler_inline_result$$1; a=1;\" +\n+        \"var JSCompiler_inline_result$$1;\" +\n+        \"{a=1;\" +\n         \" JSCompiler_inline_result$$1=1}\" +\n         \"x = JSCompiler_temp_const$$0 + JSCompiler_inline_result$$1;\");\n   }\n               \"return ret\\n\" +\n            \"}()\\n\" +\n         \");\",\n+        \"var JSCompiler_inline_result$$0;\" +\n         \"{\" +\n-        \"var JSCompiler_inline_result$$0;\" +\n         \"var ret$$inline_1={};\\n\" +\n         \"ret$$inline_1[ONE]='a';\\n\" +\n         \"ret$$inline_1[TWO]='b';\\n\" +\n     test(\n         \"((function(){var a; return function(){foo()}})())();\",\n \n-        \"{var JSCompiler_inline_result$$0;\" +\n-        \"var a$$inline_1;\" +\n+        \"var JSCompiler_inline_result$$0;\" +\n+        \"{var a$$inline_1;\" +\n         \"JSCompiler_inline_result$$0=function(){foo()};}\" +\n         \"JSCompiler_inline_result$$0()\");\n \n     test(\"function f() { if (x()) return y() }\\n\" +\n          \"while(1){ var m = f() || z() }\",\n          \"for(;1;) {\" +\n+         \"  var JSCompiler_inline_result$$0;\" +\n          \"  {\" +\n-         \"    var JSCompiler_inline_result$$0;\" +\n          \"    JSCompiler_inline_label_f_1: {\" +\n          \"      if(x()) {\" +\n          \"        JSCompiler_inline_result$$0 = y();\" +\n         \"HangoutStarter.prototype.launchHangout = function() { \" +\n         \"  var self$$2 = a.b;\" +\n         \"  var JSCompiler_temp_const$$0 = goog.Uri;\" +\n+        \"  var JSCompiler_inline_result$$1;\" +\n         \"  {\" +\n-        \"  var JSCompiler_inline_result$$1;\" +\n         \"  var self$$inline_2 = self$$2;\" +\n         \"  if (!self$$inline_2.domServices_) {\" +\n         \"    self$$inline_2.domServices_ = goog$component$DomServices.get(\" +\n             }\n          );\n   }\n+  \n+  public void test6671158() {\n+    test(\n+        \"function f() {return g()}\" +\n+        \"function Y(a){a.loader_()}\" +\n+        \"function _Z(){}\" +\n+        \"function _X() { new _Z(a,b, Y(singleton), f()) }\",\n+\n+        \"function _Z(){}\" +\n+        \"function _X(){\" +\n+        \"  var JSCompiler_temp_const$$2=_Z;\" +\n+        \"  var JSCompiler_temp_const$$1=a;\" +\n+        \"  var JSCompiler_temp_const$$0=b;\" +\n+        \"  var JSCompiler_inline_result$$3;\" +\n+        \"  {\" +\n+        \"    singleton.loader_();\" +\n+        \"    JSCompiler_inline_result$$3=void 0;\" +\n+        \"  }\" +\n+        \"  new JSCompiler_temp_const$$2(\" +\n+        \"    JSCompiler_temp_const$$1,\" +\n+        \"    JSCompiler_temp_const$$0,\" +\n+        \"    JSCompiler_inline_result$$3,\" +\n+        \"    g())}\");\n+  }\n \n }", "timestamp": 1340038688, "metainfo": ""}