{"sha": "3151687714c55d57eb007d456e684f786fd67f3f", "log": "Add doc-only parameters  R=jschorr DELTA=109  (101 added, 0 deleted, 8 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3790   ", "commit": "\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicates;\n import com.google.common.collect.HashBasedTable;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n         new JSDocInfoCollector(compiler.getTypeRegistry()));\n \n     // Create references to parameters in the JSDoc.\n-    for (Symbol sym : getAllSymbols()) {\n+    for (Symbol sym : getAllSymbolsSorted()) {\n       JSDocInfo info = sym.getJSDocInfo();\n       if (info == null) {\n         continue;\n         }\n \n         Node paramNode = pos.getItem();\n-        Symbol param = getParameterInFunction(sym, paramNode.getString());\n-        if (param != null) {\n+        String name = paramNode.getString();\n+        Symbol param = getParameterInFunction(sym, name);\n+        if (param == null) {\n+          // There is no reference to this parameter in the actual JavaScript\n+          // code, so we'll try to create a special jsdoc-only symbol in\n+          // a jsdoc-only scope.\n+          SourcePosition<Node> typePos = marker.getType();\n+          JSType type = null;\n+          if (typePos != null) {\n+            type = typePos.getItem().getJSType();\n+          }\n+\n+          if (sym.docScope == null) {\n+            sym.docScope = new SymbolScope(null /* root */,\n+                null /* parent scope */, null /* type of this */, sym);\n+          }\n+\n+          // Check to make sure there's no existing symbol. In theory, this\n+          // should never happen, but we check anyway and fail silently\n+          // if our assumptions are wrong. (We do not want to put the symbol\n+          // table into an invalid state).\n+          Symbol existingSymbol =\n+              isAnySymbolDeclared(name, paramNode, sym.docScope);\n+          if (existingSymbol == null) {\n+            declareSymbol(name, type, type == null, sym.docScope, paramNode,\n+                null /* info */);\n+          }\n+        } else {\n           param.defineReferenceAt(paramNode);\n         }\n       }\n \n     private JSDocInfo docInfo = null;\n \n+    // A scope for symbols that are only documented in JSDoc.\n+    private SymbolScope docScope = null;\n+\n     Symbol(String name, JSType type, boolean inferred, SymbolScope scope) {\n       super(name, type, inferred);\n       this.scope = scope;\n       return scope.isLexicalScope();\n     }\n \n+    /** Whether this is a variable that's only in JSDoc. */\n+    public boolean isDocOnlyParameter() {\n+      return scope.isDocScope();\n+    }\n+\n     @Override\n     public String toString() {\n       Node n = getDeclarationNode();\n     private final Node rootNode;\n     private final SymbolScope parent;\n     private final JSType typeOfThis;\n-    private final Map<String, Symbol> ownSymbols = Maps.newHashMap();\n+    private final Map<String, Symbol> ownSymbols = Maps.newLinkedHashMap();\n     private final int scopeDepth;\n \n     // The number of inner anonymous functions that we've given names to.\n     private int innerAnonFunctionsWithNames = 0;\n \n-    // The symbol associated with a property scope.\n+    // The symbol associated with a property scope or doc scope.\n     private Symbol mySymbol;\n \n     SymbolScope(\n       this.mySymbol = sym;\n     }\n \n+    /** Gets a unique index for the symbol in this scope. */\n+    public int getIndexOfSymbol(Symbol sym) {\n+      return Iterables.indexOf(\n+          ownSymbols.values(), Predicates.equalTo(sym));\n+    }\n+\n     @Override\n     public Node getRootNode() {\n       return rootNode;\n       return getParentScope() == null && getRootNode() != null;\n     }\n \n+    /**\n+     * Returns whether this is a doc scope. A doc scope is a table for symbols\n+     * that are documented solely within a JSDoc comment.\n+     */\n+    public boolean isDocScope() {\n+      return getRootNode() == null && mySymbol != null &&\n+          mySymbol.docScope == this;\n+    }\n+\n     public boolean isPropertyScope() {\n-      return getRootNode() == null;\n+      return getRootNode() == null && !isDocScope();\n     }\n \n     public boolean isLexicalScope() {\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     assertEquals(\"function (): undefined\", abc.getType().toString());\n   }\n \n+  public void testJSDocOnlySymbol() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"/**\\n\"\n+        + \" * @param {number} x\\n\"\n+        + \" * @param y\\n\"\n+        + \" */\\n\"\n+        + \"var a;\");\n+    Symbol x = getDocVar(table, \"x\");\n+    assertNotNull(x);\n+    assertEquals(\"number\", x.getType().toString());\n+    assertEquals(1, table.getReferenceList(x).size());\n+\n+    Symbol y = getDocVar(table, \"y\");\n+    assertNotNull(x);\n+    assertEquals(null, y.getType());\n+    assertEquals(1, table.getReferenceList(y).size());\n+  }\n+\n   private void assertSymmetricOrdering(\n       Ordering<Symbol> ordering, Symbol first, Symbol second) {\n     assertTrue(ordering.compare(first, first) == 0);\n \n   private Symbol getGlobalVar(SymbolTable table, String name) {\n     return table.getGlobalScope().getSlot(name);\n+  }\n+\n+  private Symbol getDocVar(SymbolTable table, String name) {\n+    for (Symbol sym : table.getAllSymbols()) {\n+      if (sym.isDocOnlyParameter() && sym.getName().equals(name)) {\n+        return sym;\n+      }\n+    }\n+    return null;\n   }\n \n   private Symbol getLocalVar(SymbolTable table, String name) {", "timestamp": 1321914898, "metainfo": ""}