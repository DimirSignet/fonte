{"sha": "1bd8d2f0f4f3edcc11aa441f50223967a98bf85d", "log": "type-check the @lends annotation  R=acleung DELTA=207  (163 added, 42 deleted, 2 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=751020   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n       UNKNOWN_EXPR_TYPE,\n       UNRESOLVED_TYPE,\n       WRONG_ARGUMENT_COUNT,\n-      ILLEGAL_IMPLICIT_CAST);\n+      ILLEGAL_IMPLICIT_CAST,\n+      TypedScopeCreator.UNKNOWN_LENDS,\n+      TypedScopeCreator.LENDS_ON_NON_OBJECT);\n \n   private final AbstractCompiler compiler;\n   private final TypeValidator validator;\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n     // TODO(nicksantos): There should be an \"anonymous object\" type that\n     // we can check for here.\n     ObjectType objectType = ObjectType.cast(type);\n-    if (objectType == null || objectType.hasReferenceName()) {\n+    if (objectType == null) {\n+      return scope;\n+    }\n+\n+    boolean hasLendsName = n.getJSDocInfo() != null &&\n+        n.getJSDocInfo().getLendsName() != null;\n+    if (objectType.hasReferenceName() && !hasLendsName) {\n       return scope;\n     }\n \n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n           \"JSC_REFLECT_CONSTRUCTOR_EXPECTED\",\n           \"Constructor expected as first argument\");\n \n+  static final DiagnosticType UNKNOWN_LENDS =\n+      DiagnosticType.warning(\n+          \"JSC_UNKNOWN_LENDS\",\n+          \"Variable {0} not declared before @lends annotation.\");\n+\n+  static final DiagnosticType LENDS_ON_NON_OBJECT =\n+      DiagnosticType.warning(\n+          \"JSC_LENDS_ON_NON_OBJECT\",\n+          \"May only lend properties to object types. {0} has type {1}.\");\n+\n   private final AbstractCompiler compiler;\n   private final ErrorReporter typeParsingErrorReporter;\n   private final TypeValidator validator;\n     return null;\n   }\n \n-  private void attachLiteralTypes(Node n) {\n-    switch (n.getType()) {\n-      case Token.NULL:\n-        n.setJSType(getNativeType(NULL_TYPE));\n-        break;\n-\n-      case Token.VOID:\n-        n.setJSType(getNativeType(VOID_TYPE));\n-        break;\n-\n-      case Token.STRING:\n-        n.setJSType(getNativeType(STRING_TYPE));\n-        break;\n-\n-      case Token.NUMBER:\n-        n.setJSType(getNativeType(NUMBER_TYPE));\n-        break;\n-\n-      case Token.TRUE:\n-      case Token.FALSE:\n-        n.setJSType(getNativeType(BOOLEAN_TYPE));\n-        break;\n-\n-      case Token.REGEXP:\n-        n.setJSType(getNativeType(REGEXP_TYPE));\n-        break;\n-\n-      case Token.REF_SPECIAL:\n-        n.setJSType(getNativeType(UNKNOWN_TYPE));\n-        break;\n-\n-      case Token.OBJECTLIT:\n-        if (n.getJSType() == null) {\n-          n.setJSType(typeRegistry.createAnonymousObjectType());\n-        }\n-        break;\n-\n-      // NOTE(nicksantos): If we ever support Array tuples,\n-      // we will need to put ARRAYLIT here as well.\n-    }\n-  }\n-\n   private JSType getNativeType(JSTypeNative nativeType) {\n     return typeRegistry.getNativeType(nativeType);\n   }\n             maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n           }\n           break;\n+      }\n+    }\n+\n+    private void attachLiteralTypes(Node n) {\n+      switch (n.getType()) {\n+        case Token.NULL:\n+          n.setJSType(getNativeType(NULL_TYPE));\n+          break;\n+\n+        case Token.VOID:\n+          n.setJSType(getNativeType(VOID_TYPE));\n+          break;\n+\n+        case Token.STRING:\n+          n.setJSType(getNativeType(STRING_TYPE));\n+          break;\n+\n+        case Token.NUMBER:\n+          n.setJSType(getNativeType(NUMBER_TYPE));\n+          break;\n+\n+        case Token.TRUE:\n+        case Token.FALSE:\n+          n.setJSType(getNativeType(BOOLEAN_TYPE));\n+          break;\n+\n+        case Token.REGEXP:\n+          n.setJSType(getNativeType(REGEXP_TYPE));\n+          break;\n+\n+        case Token.REF_SPECIAL:\n+          n.setJSType(getNativeType(UNKNOWN_TYPE));\n+          break;\n+\n+        case Token.OBJECTLIT:\n+          processObjectLit(n);\n+          break;\n+\n+          // NOTE(nicksantos): If we ever support Array tuples,\n+          // we will need to put ARRAYLIT here as well.\n+      }\n+    }\n+\n+    private void processObjectLit(Node objectLit) {\n+      JSDocInfo info = objectLit.getJSDocInfo();\n+      if (info != null &&\n+          info.getLendsName() != null) {\n+        String lendsName = info.getLendsName();\n+        Var lendsVar = scope.getVar(lendsName);\n+        if (lendsVar == null) {\n+          compiler.report(\n+              JSError.make(sourceName, objectLit, UNKNOWN_LENDS, lendsName));\n+        } else {\n+          JSType type = lendsVar.getType();\n+          if (type == null) {\n+            type = typeRegistry.getNativeType(UNKNOWN_TYPE);\n+          }\n+          if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n+            compiler.report(\n+                JSError.make(sourceName, objectLit, LENDS_ON_NON_OBJECT,\n+                    lendsName, type.toString()));\n+          } else {\n+            objectLit.setJSType(type);\n+          }\n+        }\n+      }\n+\n+      if (objectLit.getJSType() == null) {\n+        objectLit.setJSType(typeRegistry.createAnonymousObjectType());\n       }\n     }\n \n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"/** @param {{bar: number}} x */ function f(x) { return x.baz; }\");\n   }\n \n+  public void testLends1() throws Exception {\n+    testTypes(\n+        \"function extend(x, y) {}\" +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"extend(Foo, /** @lends */ ({bar: 1}));\",\n+        \"Parse error. missing object name in @lends tag\");\n+  }\n+\n+  public void testLends2() throws Exception {\n+    testTypes(\n+        \"function extend(x, y) {}\" +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"extend(Foo, /** @lends {Foob} */ ({bar: 1}));\",\n+        \"Variable Foob not declared before @lends annotation.\");\n+  }\n+\n+  public void testLends3() throws Exception {\n+    testTypes(\n+        \"function extend(x, y) {}\" +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"extend(Foo, {bar: 1});\" +\n+        \"alert(Foo.bar);\",\n+        \"Property bar never defined on Foo\");\n+  }\n+\n+  public void testLends4() throws Exception {\n+    testTypes(\n+        \"function extend(x, y) {}\" +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"extend(Foo, /** @lends {Foo} */ ({bar: 1}));\" +\n+        \"alert(Foo.bar);\");\n+  }\n+\n+  public void testLends5() throws Exception {\n+    testTypes(\n+        \"function extend(x, y) {}\" +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"extend(Foo, {bar: 1});\" +\n+        \"alert((new Foo()).bar);\",\n+        \"Property bar never defined on Foo\");\n+  }\n+\n+  public void testLends6() throws Exception {\n+    testTypes(\n+        \"function extend(x, y) {}\" +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"extend(Foo, /** @lends {Foo.prototype} */ ({bar: 1}));\" +\n+        \"alert((new Foo()).bar);\");\n+  }\n+\n+  public void testLends7() throws Exception {\n+    testTypes(\n+        \"function extend(x, y) {}\" +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"extend(Foo, /** @lends {Foo.prototype|Foo} */ ({bar: 1}));\",\n+        \"Parse error. expected closing }\");\n+  }\n+\n+  public void testLends8() throws Exception {\n+    testTypes(\n+        \"function extend(x, y) {}\" +\n+        \"/** @type {number} */ var Foo = 3;\" +\n+        \"extend(Foo, /** @lends {Foo} */ ({bar: 1}));\",\n+        \"May only lend properties to object types. Foo has type number.\");\n+  }\n+\n+  public void testLends9() throws Exception {\n+    testClosureTypesMultipleWarnings(\n+        \"function extend(x, y) {}\" +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"extend(Foo, /** @lends {!Foo} */ ({bar: 1}));\",\n+        Lists.newArrayList(\n+            \"Parse error. expected closing }\",\n+            \"Parse error. missing object name in @lends tag\"));\n+  }\n+\n   public void testDeclaredNativeTypeEquality() throws Exception {\n     Node n = parseAndTypeCheck(\"/** @constructor */ function Object() {};\");\n     assertEquals(registry.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE),", "timestamp": 1288105621, "metainfo": ""}