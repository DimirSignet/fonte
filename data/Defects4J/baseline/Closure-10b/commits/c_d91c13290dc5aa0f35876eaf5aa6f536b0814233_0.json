{"sha": "d91c13290dc5aa0f35876eaf5aa6f536b0814233", "log": "Don't allow RETURN nodes as SCRIPT children and couple additional helpers and some tests.  R=nicksantos DELTA=154  (149 added, 1 deleted, 4 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4856   ", "commit": "\n--- a/src/com/google/javascript/rhino/IR.java\n+++ b/src/com/google/javascript/rhino/IR.java\n   }\n \n   public static Node block(Node ... stmts) {\n-    Node block = new Node(Token.BLOCK);\n+    Node block = block();\n     for (Node stmt : stmts) {\n       Preconditions.checkState(mayBeStatement(stmt));\n       block.addChildToBack(stmt);\n     return block;\n   }\n \n+  public static Node block(List<Node> stmts) {\n+    Node paramList = block();\n+    for (Node stmt : stmts) {\n+      Preconditions.checkState(mayBeStatement(stmt));\n+      paramList.addChildToBack(stmt);\n+    }\n+    return paramList;\n+  }\n+\n   private static Node blockUnchecked(Node stmt) {\n     return new Node(Token.BLOCK, stmt);\n   }\n \n-  public static Node script(Node ... stmts) {\n+  public static Node script() {\n     // TODO(johnlenz): finish setting up the SCRIPT node\n     Node block = new Node(Token.SCRIPT);\n+    return block;\n+  }\n+\n+  public static Node script(Node ... stmts) {\n+    Node block = script();\n     for (Node stmt : stmts) {\n-      Preconditions.checkState(mayBeStatement(stmt));\n+      Preconditions.checkState(mayBeStatementNoReturn(stmt));\n       block.addChildToBack(stmt);\n     }\n     return block;\n+  }\n+\n+  public static Node script(List<Node> stmts) {\n+    Node paramList = script();\n+    for (Node stmt : stmts) {\n+      Preconditions.checkState(mayBeStatementNoReturn(stmt));\n+      paramList.addChildToBack(stmt);\n+    }\n+    return paramList;\n   }\n \n   public static Node var(Node name, Node value) {\n    * It isn't possible to always determine if a detached node is a expression,\n    * so make a best guess.\n    */\n-  private static boolean mayBeStatement(Node n) {\n+  private static boolean mayBeStatementNoReturn(Node n) {\n     switch (n.getType()) {\n       case Token.EMPTY:\n       case Token.FUNCTION:\n       case Token.FOR:\n       case Token.IF:\n       case Token.LABEL:\n-      case Token.RETURN:\n       case Token.SWITCH:\n       case Token.THROW:\n       case Token.TRY:\n       default:\n         return false;\n     }\n+  }\n+\n+  /**\n+   * It isn't possible to always determine if a detached node is a expression,\n+   * so make a best guess.\n+   */\n+  private static boolean mayBeStatement(Node n) {\n+    if (!mayBeStatementNoReturn(n)) {\n+      return n.isReturn();\n+    }\n+    return true;\n   }\n \n   /**\n--- a/test/com/google/javascript/rhino/IRTest.java\n+++ b/test/com/google/javascript/rhino/IRTest.java\n \n package com.google.javascript.rhino;\n \n+import com.google.common.collect.Lists;\n+\n import junit.framework.TestCase;\n \n /**\n  * @author johnlenz@google.com (John Lenz)\n  */\n public class IRTest extends TestCase {\n+\n+  public void testEmpty() {\n+    testIR(IR.empty(), \"EMPTY\\n\");\n+  }\n+\n+  public void testFunction() {\n+    testIR(IR.function(IR.name(\"hi\"), IR.paramList(), IR.block()),\n+        \"FUNCTION hi\\n\" +\n+        \"    NAME hi\\n\" +\n+        \"    PARAM_LIST\\n\" +\n+        \"    BLOCK\\n\");\n+  }\n+\n+  public void testParamList() {\n+    testIR(IR.paramList(),\n+        \"PARAM_LIST\\n\");\n+\n+    testIR(IR.paramList(IR.name(\"a\"), IR.name(\"b\")),\n+        \"PARAM_LIST\\n\" +\n+        \"    NAME a\\n\" +\n+        \"    NAME b\\n\");\n+\n+    testIR(IR.paramList(Lists.newArrayList(IR.name(\"a\"), IR.name(\"b\"))),\n+        \"PARAM_LIST\\n\" +\n+        \"    NAME a\\n\" +\n+        \"    NAME b\\n\");\n+  }\n+\n+  public void testBlock() {\n+    testIR(IR.block(),\n+        \"BLOCK\\n\");\n+\n+    testIR(IR.block(IR.empty(), IR.empty()),\n+        \"BLOCK\\n\" +\n+        \"    EMPTY\\n\" +\n+        \"    EMPTY\\n\");\n+\n+    testIR(IR.block(Lists.newArrayList(IR.empty(), IR.empty())),\n+        \"BLOCK\\n\" +\n+        \"    EMPTY\\n\" +\n+        \"    EMPTY\\n\");\n+  }\n+\n+  public void testScript() {\n+    testIR(IR.script(),\n+        \"SCRIPT\\n\");\n+\n+    testIR(IR.script(IR.empty(), IR.empty()),\n+        \"SCRIPT\\n\" +\n+        \"    EMPTY\\n\" +\n+        \"    EMPTY\\n\");\n+\n+    testIR(IR.script(Lists.newArrayList(IR.empty(), IR.empty())),\n+        \"SCRIPT\\n\" +\n+        \"    EMPTY\\n\" +\n+        \"    EMPTY\\n\");\n+  }\n+\n+  public void testScriptThrows() {\n+    boolean caught = false;\n+    try {\n+      IR.script(IR.returnNode());\n+    } catch(IllegalStateException e) {\n+      caught = true;\n+    }\n+    assertTrue(\"expected exception was not seen\", caught);\n+  }\n+\n+  public void testVar() {\n+    testIR(IR.var(IR.name(\"a\")),\n+        \"VAR\\n\" +\n+        \"    NAME a\\n\");\n+\n+    testIR(IR.var(IR.name(\"a\"), IR.trueNode()),\n+        \"VAR\\n\" +\n+        \"    NAME a\\n\" +\n+        \"        TRUE\\n\");\n+  }\n+\n+  public void testReturn() {\n+    testIR(IR.returnNode(),\n+        \"RETURN\\n\");\n+\n+    testIR(IR.returnNode(IR.name(\"a\")),\n+        \"RETURN\\n\" +\n+        \"    NAME a\\n\");\n+  }\n+\n+  public void testThrow() {\n+    testIR(IR.throwNode(IR.name(\"a\")),\n+        \"THROW\\n\" +\n+        \"    NAME a\\n\");\n+  }\n+\n+  public void testExprResult() {\n+    testIR(IR.exprResult(IR.name(\"a\")),\n+        \"EXPR_RESULT\\n\" +\n+        \"    NAME a\\n\");\n+  }\n+\n+  public void testIf() {\n+    testIR(IR.ifNode(IR.name(\"a\"), IR.block()),\n+        \"IF\\n\" +\n+        \"    NAME a\\n\" +\n+        \"    BLOCK\\n\");\n+\n+    testIR(IR.ifNode(IR.name(\"a\"), IR.block(), IR.block()),\n+        \"IF\\n\" +\n+        \"    NAME a\\n\" +\n+        \"    BLOCK\\n\" +\n+        \"    BLOCK\\n\");\n+  }\n+\n   public void testIssue727_1() {\n     testIR(\n         IR.tryFinally(", "timestamp": 1337880890, "metainfo": ""}