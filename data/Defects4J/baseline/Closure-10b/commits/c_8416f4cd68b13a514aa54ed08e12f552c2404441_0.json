{"sha": "8416f4cd68b13a514aa54ed08e12f552c2404441", "log": "General eliminations of redundant returns and throws.  R=nicksantos DELTA=416  (314 added, 82 deleted, 20 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=164   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n   @SuppressWarnings(\"fallthrough\")\n   public Node optimizeSubtree(Node node) {\n     switch(node.getType()) {\n-      case Token.RETURN:\n+      case Token.RETURN: {\n+        Node result = tryRemoveRedundantExit(node);\n+        if (result != node) {\n+          return result;\n+        }\n+        result = tryReplaceExitWithBreak(node);\n+        if (result != node) {\n+          return result;\n+        }\n         return tryReduceReturn(node);\n+      }\n+\n+      case Token.THROW: {\n+        Node result = tryRemoveRedundantExit(node);\n+        if (result != node) {\n+          return result;\n+        }\n+        return tryReplaceExitWithBreak(node);\n+      }\n+\n+      // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps\n+      // with MinimizeExitPoints.\n \n       case Token.NOT:\n         tryMinimizeCondition(node.getFirstChild());\n   /**\n    * Reduce \"return undefined\" or \"return void 0\" to simply \"return\".\n    *\n-   * Returns the replacement for n, or the original if no change was made.\n+   * @return The original node, maybe simplified.\n    */\n   private Node tryReduceReturn(Node n) {\n     Node result = n.getFirstChild();\n-\n-    boolean possibleException = result != null &&\n-        ControlFlowAnalysis.mayThrowException(result);\n-\n-    // Try to use a substitute that with a break because it is shorter.\n-\n-    // First lets pretend it is a break with no labels.\n-    Node breakTarget = n;\n-    boolean safe = true;\n-\n-    for (;!ControlFlowAnalysis.isBreakTarget(breakTarget, null /* no label */);\n-        breakTarget = breakTarget.getParent()) {\n-      if (NodeUtil.isFunction(breakTarget) ||\n-          breakTarget.getType() == Token.SCRIPT) {\n-\n-          // We can switch the return to a break if the return value has\n-          // side effect and it must encounter a finally.\n-\n-          // example: return alert('a') -> finally { alert('b') } ->\n-          //          return alert('a')\n-          // prints a then b. If the first return is a break,\n-          // it prints b then a.\n-        safe = false;\n-        break;\n-      }\n-    }\n-\n-    Node follow = ControlFlowAnalysis.computeFollowNode(breakTarget);\n-\n-    // Skip pass all the finally blocks because both the break and return will\n-    // also trigger all the finally blocks. However, the order of execution is\n-    // slightly changed. Consider:\n-    //\n-    // return a() -> finally { b() } -> return a()\n-    //\n-    // which would call a() first. However, changing the first return to a\n-    // break will result in calling b().\n-    while (follow != null &&\n-        NodeUtil.isTryFinallyNode(follow.getParent(), follow)) {\n-      if (result != null &&\n-          // TODO(user): Use the new side effects API for more accuracy.\n-          (NodeUtil.canBeSideEffected(result) ||\n-           NodeUtil.mayHaveSideEffects(result))) {\n-        safe = false;\n-        break;\n-      }\n-      follow = ControlFlowAnalysis.computeFollowNode(follow);\n-    }\n-\n-    if (safe) {\n-      if (follow == null) {\n-        // When follow is null, this mean the follow of a break target is the\n-        // end of a function. This means a break is same as return.\n-        if (result == null) {\n-          n.setType(Token.BREAK);\n-          reportCodeChange();\n-          return n;\n-        }\n-\n-      } else if (follow.getType() == Token.RETURN &&\n-          (result == follow.getFirstChild() ||\n-           (result != null && follow.hasChildren() &&\n-            result.checkTreeEqualsSilent(follow.getFirstChild())) &&\n-            ControlFlowAnalysis.getExceptionHandler(n) ==\n-            ControlFlowAnalysis.getExceptionHandler(follow)\n-           )) {\n-        // When the follow is a return, if both doesn't return anything\n-        // or both returns the same thing. This mean we can replace it with a\n-        // break.\n-        n.removeChildren();\n-        n.setType(Token.BREAK);\n-        reportCodeChange();\n-        return n;\n-      }\n-      // If any of the above is executed, we must return because n is no longer\n-      // a \"return\" node.\n-    }\n-\n-    // TODO(user): consider cases such as if (x) { return 1} return 1;\n \n     if (result != null) {\n       switch (result.getType()) {\n             reportCodeChange();\n           }\n           break;\n-        default:\n-          //Do nothing\n-            break;\n       }\n     }\n \n     return n;\n+  }\n+\n+  /**\n+   * Replace duplicate exits in control structures.  If the node following\n+   * the exit node expression has the same effect as exit node, the node can\n+   * be replaced or removed.\n+   * For example:\n+   *   \"while (a) {return f()} return f();\" ==> \"while (a) {break} return f();\"\n+   *   \"while (a) {throw 'ow'} throw 'ow';\" ==> \"while (a) {break} throw 'ow';\"\n+   *\n+   * @param n An follow control exit expression (a THROW or RETURN node)\n+   * @return The replacement for n, or the original if no change was made.\n+   */\n+  private Node tryReplaceExitWithBreak(Node n) {\n+    Node result = n.getFirstChild();\n+\n+    // Find the enclosing control structure, if any, that a \"break\" would exit\n+    // from.\n+    Node breakTarget = n;\n+    for (;!ControlFlowAnalysis.isBreakTarget(breakTarget, null /* no label */);\n+        breakTarget = breakTarget.getParent()) {\n+      if (NodeUtil.isFunction(breakTarget) ||\n+          breakTarget.getType() == Token.SCRIPT) {\n+        // No break target.\n+        return n;\n+      }\n+    }\n+\n+    Node follow = ControlFlowAnalysis.computeFollowNode(breakTarget);\n+\n+    // Skip pass all the finally blocks because both the break and return will\n+    // also trigger all the finally blocks. However, the order of execution is\n+    // slightly changed. Consider:\n+    //\n+    // return a() -> finally { b() } -> return a()\n+    //\n+    // which would call a() first. However, changing the first return to a\n+    // break will result in calling b().\n+\n+    Node prefinallyFollows = follow;\n+    follow = skipFinallyNodes(follow);\n+\n+    if (prefinallyFollows != follow) {\n+      // There were finally clauses\n+      if (!isPure(result)) {\n+        // Can't defer the exit\n+        return n;\n+      }\n+    }\n+\n+    if (follow == null && (n.getType() == Token.THROW || result != null)) {\n+      // Can't complete remove a throw here or a return with a result.\n+      return n;\n+    }\n+\n+    // When follow is null, this mean the follow of a break target is the\n+    // end of a function. This means a break is same as return.\n+    if (follow == null || areMatchingExits(n, follow)) {\n+      Node replacement = new Node(Token.BREAK);\n+      n.getParent().replaceChild(n, replacement);\n+      this.reportCodeChange();\n+      return replacement;\n+    }\n+\n+    return n;\n+  }\n+\n+  /**\n+   * Remove duplicate exits.  If the node following the exit node expression\n+   * has the same effect as exit node, the node can be removed.\n+   * For example:\n+   *   \"if (a) {return f()} return f();\" ==> \"if (a) {} return f();\"\n+   *   \"if (a) {throw 'ow'} throw 'ow';\" ==> \"if (a) {} throw 'ow';\"\n+   *\n+   * @param n An follow control exit expression (a THROW or RETURN node)\n+   * @return The replacement for n, or the original if no change was made.\n+   */\n+  private Node tryRemoveRedundantExit(Node n) {\n+    Node exitExpr = n.getFirstChild();\n+\n+    Node follow = ControlFlowAnalysis.computeFollowNode(n);\n+\n+    // Skip pass all the finally blocks because both the fall through and return\n+    // will also trigger all the finally blocks.\n+    Node prefinallyFollows = follow;\n+    follow = skipFinallyNodes(follow);\n+    if (prefinallyFollows != follow) {\n+      // There were finally clauses\n+      if (!isPure(exitExpr)) {\n+        // Can't replace the return\n+        return n;\n+      }\n+    }\n+\n+    if (follow == null && (n.getType() == Token.THROW || exitExpr != null)) {\n+      // Can't complete remove a throw here or a return with a result.\n+      return n;\n+    }\n+\n+    // When follow is null, this mean the follow of a break target is the\n+    // end of a function. This means a break is same as return.\n+    if (follow == null || areMatchingExits(n, follow)) {\n+      n.detachFromParent();\n+      reportCodeChange();\n+      return null;\n+    }\n+\n+    return n;\n+  }\n+\n+  /**\n+   * @return Whether the expression does not produces and can not be affected\n+   * by side-effects.\n+   */\n+  boolean isPure(Node n) {\n+    return n == null\n+        || (!NodeUtil.canBeSideEffected(n)\n+            && !NodeUtil.mayHaveSideEffects(n));\n+  }\n+\n+  /**\n+   * @return n or the node following any following finally nodes.\n+   */\n+  Node skipFinallyNodes(Node n) {\n+    while (n != null && NodeUtil.isTryFinallyNode(n.getParent(), n)) {\n+      n = ControlFlowAnalysis.computeFollowNode(n);\n+    }\n+    return n;\n+  }\n+\n+  /**\n+   * Check whether one exit can be replaced with another. Verify:\n+   * 1) They are identical expressions\n+   * 2) If an exception is possible that the statements, the original\n+   * and the potential replacement are in the same exception handler.\n+   */\n+  boolean areMatchingExits(Node nodeThis, Node nodeThat) {\n+    return nodeThis.checkTreeEqualsSilent(nodeThat)\n+        && (!isExceptionPossible(nodeThis)\n+            || getExceptionHandler(nodeThis) == getExceptionHandler(nodeThat));\n+  }\n+\n+  boolean isExceptionPossible(Node n) {\n+    // TODO(johnlenz): maybe use ControlFlowAnalysis.mayThrowException?\n+    Preconditions.checkState(n.getType() == Token.RETURN\n+        || n.getType() == Token.THROW);\n+    return n.getType() == Token.THROW\n+        || (n.hasChildren()\n+            && !NodeUtil.isLiteralValue(n.getLastChild(), true));\n+  }\n+\n+  Node getExceptionHandler(Node n) {\n+    return ControlFlowAnalysis.getExceptionHandler(n);\n   }\n \n   /**\n       reportCodeChange();\n     }\n   }\n+\n   /**\n    * @return Whether the node is a block with a single statement that is\n    *     an expression.\n--- a/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n   public void testFoldReturnsIntegration() {\n     // if-then-else duplicate statement removal handles this case:\n     fold(\"function(){if(x)return;else return}\",\n-         \"function(){return}\");\n+         \"function(){}\");\n   }\n \n   public void testBug1059649() {\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n     fold(\"function(){if(x)return y += 1;else return y += 2}\",\n          \"function(){return x?(y+=1):(y+=2)}\");\n \n-    // don't touch cases where either side doesn't return a value\n-    foldSame(\"function(){if(x)return;else return 2-x}\");\n-    foldSame(\"function(){if(x)return x;else return}\");\n+    fold(\"function(){if(x)return;else return 2-x}\",\n+         \"function(){if(x);else return 2-x}\");\n+    fold(\"function(){if(x)return x;else return}\",\n+         \"function(){if(x)return x;else;}\");\n \n     foldSame(\"function(){for(var x in y) { return x.y; } return k}\");\n   }\n     foldSame(\"function f(){return false;}\");\n     foldSame(\"function f(){return null;}\");\n     fold(\"function f(){return void 0;}\",\n-         \"function f(){return}\");\n+         \"function f(){}\");\n     foldSame(\"function f(){return void foo();}\");\n     fold(\"function f(){return undefined;}\",\n-         \"function f(){return}\");\n+         \"function f(){}\");\n     fold(\"function(){if(a()){return undefined;}}\",\n-         \"function(){if(a()){return}}\");\n+         \"function(){if(a()){}}\");\n   }\n \n   public void testFoldStandardConstructors() {\n     fold(\"function f() { while(x) { return x}  return x}\",\n          \"function f() { while(x) { break }    return x}\");\n \n-    fold(\"function f() { while(x) { if (y) { return }}} \",\n-         \"function f() { while(x) { if (y) { break  }}} \");\n-\n-    fold(\"function f() { while(x) { if (y) { return }} return} \",\n-         \"function f() { while(x) { if (y) { break  }} return} \");\n-\n-    fold(\"function f() { while(x) { if (y) { return 5 }} return 5} \",\n-         \"function f() { while(x) { if (y) { break    }} return 5} \");\n+    fold(\"function f() { while(x) { if (y) { return }}}\",\n+         \"function f() { while(x) { if (y) { break  }}}\");\n+\n+    fold(\"function f() { while(x) { if (y) { return }} return}\",\n+         \"function f() { while(x) { if (y) { break  }}}\");\n+\n+    fold(\"function f() { while(x) { if (y) { return 5 }} return 5}\",\n+         \"function f() { while(x) { if (y) { break    }} return 5}\");\n \n     // It doesn't matter if x is changed between them. We are still returning\n     // x at whatever x value current holds. The whole x = 1 is skipped.\n-    fold(\"function f() { while(x) { if (y) { return x } x = 1} return x} \",\n-         \"function f() { while(x) { if (y) { break    } x = 1} return x} \");\n+    fold(\"function f() { while(x) { if (y) { return x } x = 1} return x}\",\n+         \"function f() { while(x) { if (y) { break    } x = 1} return x}\");\n \n     // RemoveUnreachableCode would take care of the useless breaks.\n     fold(\"function f() { while(x) { if (y) { return x } return x} return x}\",\n-         \"function f() { while(x) { if (y) { break    } break   } return x}\");\n+         \"function f() { while(x) { if (y) {} break }return x}\");\n \n     // A break here only breaks out of the inner loop.\n     foldSame(\"function f() { while(x) { while (y) { return } } }\");\n          );\n \n     foldSame(\"function f() { try{ return a } finally { a = 2 } return a; }\");\n+\n+    fold(\n+      \"function f() { switch(a){ case 1: return a; default: g();} return a;}\",\n+      \"function f() { switch(a){ case 1: break; default: g();} return a; }\");\n+  }\n+\n+  public void testSubsituteBreakForThrow() {\n+\n+    foldSame(\"function f() { while(x) { throw Error }}\");\n+\n+    fold(\"function f() { while(x) { throw Error } throw Error }\",\n+         \"function f() { while(x) { break } throw Error}\");\n+    foldSame(\"function f() { while(x) { throw Error(1) } throw Error(2)}\");\n+    foldSame(\"function f() { while(x) { throw Error(1) } return Error(2)}\");\n+\n+    foldSame(\"function f() { while(x) { throw 5 } }\");\n+\n+    foldSame(\"function f() { a: { throw 5 } }\");\n+\n+    fold(\"function f() { while(x) { throw 5}  throw 5}\",\n+         \"function f() { while(x) { break }   throw 5}\");\n+\n+    fold(\"function f() { while(x) { throw x}  throw x}\",\n+         \"function f() { while(x) { break }   throw x}\");\n+\n+    foldSame(\"function f() { while(x) { if (y) { throw Error }}}\");\n+\n+    fold(\"function f() { while(x) { if (y) { throw Error }} throw Error}\",\n+         \"function f() { while(x) { if (y) { break }} throw Error}\");\n+\n+    fold(\"function f() { while(x) { if (y) { throw 5 }} throw 5}\",\n+         \"function f() { while(x) { if (y) { break    }} throw 5}\");\n+\n+    // It doesn't matter if x is changed between them. We are still throwing\n+    // x at whatever x value current holds. The whole x = 1 is skipped.\n+    fold(\"function f() { while(x) { if (y) { throw x } x = 1} throw x}\",\n+         \"function f() { while(x) { if (y) { break    } x = 1} throw x}\");\n+\n+    // RemoveUnreachableCode would take care of the useless breaks.\n+    fold(\"function f() { while(x) { if (y) { throw x } throw x} throw x}\",\n+         \"function f() { while(x) { if (y) {} break }throw x}\");\n+\n+    // A break here only breaks out of the inner loop.\n+    foldSame(\"function f() { while(x) { while (y) { throw Error } } }\");\n+\n+    foldSame(\"function f() { while(1) { throw 7}  throw 5}\");\n+\n+\n+    foldSame(\"function f() {\" +\n+             \"  try { while(x) {throw f()}} catch (e) { } throw f()}\");\n+\n+    foldSame(\"function f() {\" +\n+             \"  try { while(x) {throw f()}} finally {alert(1)} throw f()}\");\n+\n+\n+    // Both throws has the same handler\n+    fold(\"function f() {\" +\n+         \"  try { while(x) { throw f() } throw f() } catch (e) { } }\",\n+         \"function f() {\" +\n+         \"  try { while(x) { break } throw f() } catch (e) { } }\");\n+\n+    // We can't fold this because it'll change the order of when foo is called.\n+    foldSame(\"function f() {\" +\n+             \"  try { while(x) { throw foo() } } finally { alert(1) } \"  +\n+             \"  throw foo()}\");\n+\n+    // This is fine, we have no side effect in the throw value.\n+    fold(\"function f() {\" +\n+         \"  try { while(x) { throw 1 } } finally { alert(1) } throw 1}\",\n+         \"function f() {\" +\n+         \"  try { while(x) { break    } } finally { alert(1) } throw 1}\"\n+         );\n+\n+    foldSame(\"function f() { try{ throw a } finally { a = 2 } throw a; }\");\n+\n+    fold(\n+      \"function f() { switch(a){ case 1: throw a; default: g();} throw a;}\",\n+      \"function f() { switch(a){ case 1: break; default: g();} throw a; }\");\n+  }\n+\n+\n+  public void testRemoveDuplicateReturn() {\n+    fold(\"function f() { return; }\",\n+         \"function f(){}\");\n+    foldSame(\"function f() { return a; }\");\n+    fold(\"function f() { if (x) { return a } return a; }\",\n+         \"function f() { if (x) {} return a; }\");\n+    foldSame(\n+      \"function f() { try { if (x) { return a } } catch(e) {} return a; }\");\n+    foldSame(\n+      \"function f() { try { if (x) {} } catch(e) {} return 1; }\");\n+\n+    // finally clauses may have side effects\n+    foldSame(\n+      \"function f() { try { if (x) { return a } } finally { a++ } return a; }\");\n+    // but they don't matter if the result doesn't have side effects and can't\n+    // be affect by side-effects.\n+    fold(\"function f() { try { if (x) { return 1 } } finally {} return 1; }\",\n+         \"function f() { try { if (x) {} } finally {} return 1; }\");\n+\n+    fold(\"function f() { switch(a){ case 1: return a; } return a; }\",\n+         \"function f() { switch(a){ case 1: } return a; }\");\n+\n+    fold(\"function f() { switch(a){ \" +\n+         \"  case 1: return a; case 2: return a; } return a; }\",\n+         \"function f() { switch(a){ \" +\n+         \"  case 1: break; case 2: } return a; }\");\n+  }\n+\n+  public void testRemoveDuplicateThrow() {\n+    foldSame(\"function f() { throw a; }\");\n+    fold(\"function f() { if (x) { throw a } throw a; }\",\n+         \"function f() { if (x) {} throw a; }\");\n+    foldSame(\n+      \"function f() { try { if (x) {throw a} } catch(e) {} throw a; }\");\n+    foldSame(\n+      \"function f() { try { if (x) {throw 1} } catch(e) {f()} throw 1; }\");\n+    foldSame(\n+      \"function f() { try { if (x) {throw 1} } catch(e) {f()} throw 1; }\");\n+    foldSame(\n+      \"function f() { try { if (x) {throw 1} } catch(e) {throw 1}}\");\n+    fold(\n+      \"function f() { try { if (x) {throw 1} } catch(e) {throw 1} throw 1; }\",\n+      \"function f() { try { if (x) {throw 1} } catch(e) {} throw 1; }\");\n+\n+    // finally clauses may have side effects\n+    foldSame(\n+      \"function f() { try { if (x) { throw a } } finally { a++ } throw a; }\");\n+    // but they don't matter if the result doesn't have side effects and can't\n+    // be affect by side-effects.\n+    fold(\"function f() { try { if (x) { throw 1 } } finally {} throw 1; }\",\n+         \"function f() { try { if (x) {} } finally {} throw 1; }\");\n+\n+    fold(\"function f() { switch(a){ case 1: throw a; } throw a; }\",\n+         \"function f() { switch(a){ case 1: } throw a; }\");\n+\n+    fold(\"function f() { switch(a){ \" +\n+             \"case 1: throw a; case 2: throw a; } throw a; }\",\n+         \"function f() { switch(a){ case 1: break; case 2: } throw a; }\");\n   }\n \n   public void testIssue291() {", "timestamp": 1292873710, "metainfo": ""}