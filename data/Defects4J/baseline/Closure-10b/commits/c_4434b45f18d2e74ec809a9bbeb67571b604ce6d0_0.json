{"sha": "4434b45f18d2e74ec809a9bbeb67571b604ce6d0", "log": "Unforgiven types. Now that you can suppress type-parsing warnings by simply turning off type checking, we should just get rid of all the old forgiving logic.  R=acleung DELTA=128  (5 added, 86 deleted, 37 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=812   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n       // /** @type {Function} */ x.prototype.y;\n       // then we should not give it a @this type.\n       String ownerTypeName = owner.getQualifiedName();\n-      ObjectType ownerType = ObjectType.cast(\n-          typeRegistry.getForgivingType(\n-              scope, ownerTypeName, sourceName,\n-              owner.getLineno(), owner.getCharno()));\n-      if (ownerType != null) {\n-        thisType = ownerType;\n+      Var ownerVar = scope.getVar(ownerTypeName);\n+      JSType ownerType = ownerVar == null ? null : ownerVar.getType();\n+      FunctionType ownerFnType = ownerType instanceof FunctionType ?\n+          (FunctionType) ownerType : null;\n+      ObjectType instType =\n+          ownerFnType == null || ownerFnType.isOrdinaryFunction() ?\n+          null : ownerFnType.getInstanceType();\n+      if (instType != null) {\n+        thisType = instType;\n       }\n     }\n \n--- a/src/com/google/javascript/rhino/JSTypeExpression.java\n+++ b/src/com/google/javascript/rhino/JSTypeExpression.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino;\n \n import com.google.javascript.rhino.jstype.JSType;\n    * Evaluates the type expression into a {@code JSType} object.\n    */\n   public JSType evaluate(StaticScope<JSType> scope, JSTypeRegistry registry) {\n-    return registry.createFromTypeNodes(root, sourceName, scope,\n-        root.getBooleanProp(Node.BRACELESS_TYPE));\n+    return registry.createFromTypeNodes(root, sourceName, scope);\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n     String displayName = getDisplayName();\n     return displayName != null && !displayName.isEmpty();\n   }\n-\n-  /**\n-   * If we see a type name without braces, it might be legacy jsdoc.\n-   * So we shouldn't emit warnings about it. This method is how we skip\n-   * those warnings.\n-   */\n-  void forgiveUnknownNames() {}\n \n   public boolean isNoType() {\n     return false;\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n   }\n \n   /**\n-   * Try to resolve a type name, but forgive the user and don't emit\n-   * a warning if this doesn't resolve.\n-   */\n-  public JSType getForgivingType(StaticScope<JSType> scope, String jsTypeName,\n-      String sourceName, int lineno, int charno) {\n-    JSType type = getType(\n-        scope, jsTypeName, sourceName, lineno, charno);\n-    type.forgiveUnknownNames();\n-    return type;\n-  }\n-\n-  /**\n    * Looks up a type by name. To allow for forward references to types, an\n    * unrecognized string has to be bound to a NamedType object that will be\n    * resolved later.\n    */\n   public JSType createFromTypeNodes(Node n, String sourceName,\n       StaticScope<JSType> scope) {\n-    return createFromTypeNodes(n, sourceName, scope, false);\n-  }\n-\n-  /**\n-   * Creates a JSType from the nodes representing a type.\n-   * @param n The node with type info.\n-   * @param sourceName The source file name.\n-   * @param scope A scope for doing type name lookups.\n-   * @param forgiving Whether we should be forgiving about type names\n-   *     that we can't find.\n-   */\n-  public JSType createFromTypeNodes(Node n, String sourceName,\n-      StaticScope<JSType> scope, boolean forgiving) {\n     if (resolveMode == ResolveMode.LAZY_EXPRESSIONS) {\n       // If the type expression doesn't contain any names, just\n       // resolve it anyway.\n       boolean hasNames = hasTypeName(n);\n       if (hasNames) {\n-        return new UnresolvedTypeExpression(this, n, sourceName, forgiving);\n+        return new UnresolvedTypeExpression(this, n, sourceName);\n       }\n     }\n-    return createFromTypeNodesInternal(n, sourceName, scope, forgiving);\n+    return createFromTypeNodesInternal(n, sourceName, scope);\n   }\n \n   private boolean hasTypeName(Node n) {\n \n   /** @see #createFromTypeNodes(Node, String, StaticScope, boolean) */\n   private JSType createFromTypeNodesInternal(Node n, String sourceName,\n-      StaticScope<JSType> scope, boolean forgiving) {\n+      StaticScope<JSType> scope) {\n     switch (n.getType()) {\n       case Token.LC: // Record type.\n         return createRecordTypeFromNodes(\n \n       case Token.BANG: // Not nullable\n         return createFromTypeNodesInternal(\n-            n.getFirstChild(), sourceName, scope, forgiving)\n+            n.getFirstChild(), sourceName, scope)\n             .restrictByNotNullOrUndefined();\n \n       case Token.QMARK: // Nullable or unknown\n         }\n         return createDefaultObjectUnion(\n             createFromTypeNodesInternal(\n-                firstChild, sourceName, scope, forgiving));\n+                firstChild, sourceName, scope));\n \n       case Token.EQUALS: // Optional\n         return createOptionalType(\n             createFromTypeNodesInternal(\n-                n.getFirstChild(), sourceName, scope, false));\n+                n.getFirstChild(), sourceName, scope));\n \n       case Token.ELLIPSIS: // Var args\n         return createOptionalType(\n             createFromTypeNodesInternal(\n-                n.getFirstChild(), sourceName, scope, false));\n+                n.getFirstChild(), sourceName, scope));\n \n       case Token.STAR: // The AllType\n         return getNativeType(ALL_TYPE);\n         for (Node child = n.getFirstChild(); child != null;\n              child = child.getNext()) {\n           builder.addAlternate(\n-              createFromTypeNodesInternal(child, sourceName, scope, false));\n+              createFromTypeNodesInternal(child, sourceName, scope));\n         }\n         return builder.build();\n \n       case Token.STRING:\n         JSType namedType = getType(scope, n.getString(), sourceName,\n             n.getLineno(), n.getCharno());\n-        if (forgiving) {\n-          namedType.forgiveUnknownNames();\n-        }\n         if (resolveMode != ResolveMode.LAZY_NAMES) {\n           namedType = namedType.resolveInternal(reporter, scope);\n         }\n                \"Object\".equals(n.getString()))) {\n             JSType parameterType =\n                 createFromTypeNodesInternal(\n-                    typeList.getLastChild(), sourceName, scope, false);\n+                    typeList.getLastChild(), sourceName, scope);\n             namedType = new ParameterizedType(\n                 this, (ObjectType) namedType, parameterType);\n             if (typeList.hasMoreThanOneChild()) {\n               JSType indexType =\n                   createFromTypeNodesInternal(\n-                      typeList.getFirstChild(), sourceName, scope, false);\n+                      typeList.getFirstChild(), sourceName, scope);\n               namedType = new IndexedType(\n                   this, (ObjectType) namedType, indexType);\n             }\n           thisType =\n               ObjectType.cast(\n                   createFromTypeNodesInternal(\n-                      contextNode, sourceName, scope, false)\n+                      contextNode, sourceName, scope)\n                   .restrictByNotNullOrUndefined());\n           if (thisType == null) {\n             reporter.warning(\n               } else {\n                 paramBuilder.addVarArgs(\n                     createFromTypeNodesInternal(\n-                        arg.getFirstChild(), sourceName, scope, false));\n+                        arg.getFirstChild(), sourceName, scope));\n               }\n             } else {\n               JSType type = createFromTypeNodesInternal(\n-                  arg, sourceName, scope, false);\n+                  arg, sourceName, scope);\n               if (arg.getType() == Token.EQUALS) {\n                 boolean addSuccess = paramBuilder.addOptionalParams(type);\n                 if (!addSuccess) {\n         }\n \n         JSType returnType =\n-            createFromTypeNodesInternal(current, sourceName, scope, false);\n+            createFromTypeNodesInternal(current, sourceName, scope);\n \n         return new FunctionBuilder(this)\n             .withParams(paramBuilder)\n       if (hasType) {\n         // We have a declared type.\n         fieldType = createFromTypeNodesInternal(\n-            fieldTypeNode.getLastChild(), sourceName, scope, false);\n+            fieldTypeNode.getLastChild(), sourceName, scope);\n       } else {\n         // Otherwise, the type is UNKNOWN.\n         fieldType = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n   private Predicate<JSType> validator;\n \n   /**\n-   * If true, don't warn about unresolveable type names.\n-   *\n-   * NOTE(nicksantos): A lot of third-party code doesn't use our type syntax.\n-   * They have code like\n-   * {@code @return} the bus.\n-   * and they clearly don't mean that \"the\" is a type. In these cases, we're\n-   * forgiving and try to guess whether or not \"the\" is a type when it's not\n-   * clear.\n-   */\n-  private boolean forgiving = false;\n-\n-  /**\n    * Property-defining continuations.\n    */\n   private List<PropertyContinuation> propertyContinuations = null;\n     this.sourceName = sourceName;\n     this.lineno = lineno;\n     this.charno = charno;\n-  }\n-\n-  @Override\n-  void forgiveUnknownNames() {\n-    forgiving = true;\n   }\n \n   @Override\n       boolean isForwardDeclared =\n           ignoreForwardReferencedTypes &&\n           registry.isForwardDeclaredType(reference);\n-      boolean beForgiving = forgiving || isForwardDeclared;\n-      if (!beForgiving && registry.isLastGeneration()) {\n+      if (!isForwardDeclared && registry.isLastGeneration()) {\n         t.warning(\"Bad type annotation. Unknown type \" + reference,\n             sourceName, lineno, null, charno);\n       } else {\n-        if (isForwardDeclared) {\n-          setReferencedType(\n-              registry.getNativeObjectType(\n-                  JSTypeNative.NO_RESOLVED_TYPE));\n-        } else {\n-          setReferencedType(\n-              registry.getNativeObjectType(\n-                  JSTypeNative.CHECKED_UNKNOWN_TYPE));\n-        }\n+        setReferencedType(\n+            registry.getNativeObjectType(\n+                JSTypeNative.NO_RESOLVED_TYPE));\n \n         if (registry.isLastGeneration() && validator != null) {\n           validator.apply(getReferencedType());\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n     return alternates;\n   }\n \n-  @Override\n-  void forgiveUnknownNames() {\n-    for (JSType type : getAlternates()) {\n-      type.forgiveUnknownNames();\n-    }\n-  }\n-\n   /**\n    * This predicate is used to test whether a given type can appear in a\n    * numeric context, such as an operand of a multiply operator.\n--- a/src/com/google/javascript/rhino/jstype/UnresolvedTypeExpression.java\n+++ b/src/com/google/javascript/rhino/jstype/UnresolvedTypeExpression.java\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n import com.google.common.base.Preconditions;\n   private final String sourceName;\n \n   /**\n-   * If true, don't warn about unresolveable type names.\n-   *\n-   * NOTE(nicksantos): A lot of third-party code doesn't use our type syntax.\n-   * They have code like\n-   * {@code @return} the bus.\n-   * and they clearly don't mean that \"the\" is a type. In these cases, we're\n-   * forgiving and try to guess whether or not \"the\" is a type when it's not\n-   * clear.\n-   */\n-  private boolean forgiving = false;\n-\n-  /**\n    * Create a named type based on the reference.\n    */\n   UnresolvedTypeExpression(JSTypeRegistry registry, Node typeExpr,\n-      String sourceName, boolean forgiving) {\n+      String sourceName) {\n     super(registry, false);\n \n     Preconditions.checkNotNull(typeExpr);\n     this.typeExpr = typeExpr;\n     this.sourceName = sourceName;\n-    this.forgiving = forgiving;\n   }\n \n   /**\n    */\n   @Override\n   JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n-    return registry.createFromTypeNodes(typeExpr, sourceName, enclosing,\n-        forgiving);\n+    return registry.createFromTypeNodes(typeExpr, sourceName, enclosing);\n   }\n }\n--- a/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n   }\n \n   public void testUnresolvedType() {\n+    // NOTE(nicksantos): This behavior seems very wrong to me.\n     String js = \"\"\n         + \"var g = {};\"\n-        + \"/** @constructor \\n @extends g.NotHere */ var Foo = function() {}\\n\"\n+        + \"/** @constructor \\n @extends {?} */ \"\n+        + \"var Foo = function() {};\\n\"\n         + \"Foo.prototype.a = 0;\"\n-        + \"/** @constructor */ var Bar = function() {}\\n\"\n+        + \"/** @constructor */ var Bar = function() {};\\n\"\n         + \"Bar.prototype.a = 0;\";\n     String output = \"\"\n         + \"var g={};\"\n         + \"var Bar=function(){};\"\n         + \"Bar.prototype.Bar_prototype$a=0;\";\n     testSets(false, BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES,\n-        js, js, \"{}\", FunctionTypeBuilder.RESOLVED_TAG_EMPTY,\n-        \"Could not resolve type in @extends tag of Foo\");\n+        js, output, \"{a=[[Bar.prototype], [Foo.prototype]]}\");\n     testSets(true, BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES,\n-        js, output, \"{a=[[Bar.prototype], [Foo.prototype]]}\",\n-        FunctionTypeBuilder.RESOLVED_TAG_EMPTY,\n-        \"Could not resolve type in @extends tag of Foo\");\n+        js, output, \"{a=[[Bar.prototype], [Foo.prototype]]}\");\n   }\n \n   public void testNamedType() {\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n   }\n \n   public void testNoForwardTypeDeclarationAndNoBraces() throws Exception {\n-    // To better support third-party code, we do not warn when\n-    // there are no braces around an unknown type name.\n-    testTypes(\"/** @return The result. */ function f() {}\");\n+    testTypes(\"/** @return The result. */ function f() {}\",\n+        \"Bad type annotation. Unknown type The\");\n   }\n \n   public void testForwardTypeDeclaration1() throws Exception {\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n   public void testScopedConstructors2() throws Exception {\n     testTypes(\n         \"/** @param {Function} f */\" +\n-        \"function foo1(f) { \" +\n+        \"function foo1(f) {\" +\n         \"  /** @param {Function} g */\" +\n         \"  f.prototype.bar = function(g) {};\" +\n         \"}\");\n   }\n \n   public void testNoForwardTypeDeclarationAndNoBraces() throws Exception {\n-    // To better support third-party code, we do not warn when\n-    // there are no braces around an unknown type name.\n-    testTypes(\"/** @return The result. */ function f() {}\");\n+    testTypes(\"/** @return The result. */ function f() {}\",\n+        \"Bad type annotation. Unknown type The\");\n   }\n \n   public void testForwardTypeDeclaration1() throws Exception {", "timestamp": 1299774363, "metainfo": ""}