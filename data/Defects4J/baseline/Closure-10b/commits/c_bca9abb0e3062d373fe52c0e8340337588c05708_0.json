{"sha": "bca9abb0e3062d373fe52c0e8340337588c05708", "log": "Make sure that InlineVariables can inline variables that are never defined.  Create a function-inlining blacklist.  Some minor type inference fixes.  Start re-architecting type resolution to happen differently.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n \n   @FlagSpec(help = \"If specified, a source map file mapping the generated \" +\n             \"source files back to the original source file will be \" +\n-            \"output to the specified path. If %module% is added, \" +\n-            \"a source map will be generated for each module, with the \" +\n-            \" module's name placed into the path at that spot\")\n+            \"output to the specified path. The %outname% placeholder will \" +\n+            \"expand to the name of the output file that the source map \" +\n+            \"corresponds to.\")\n   public static final Flag<String> FLAG_create_source_map =\n       Flag.value(\"\");\n \n         PrintStream mapOut = null;\n \n         if (!shouldGenerateMapPerModule(options)) {\n-          mapOut = openSourceMapStream(options, moduleFilePrefix, null);\n+          mapOut = openSourceMapStream(options, moduleFilePrefix);\n         }\n \n         for (JSModule m : modules) {\n           if (shouldGenerateMapPerModule(options)) {\n-            mapOut =\n-                openSourceMapStream(options, moduleFilePrefix, m.getName());\n+            mapOut = openSourceMapStream(\n+                options, moduleFilePrefix + m.getName() + \".js\");\n           }\n \n           PrintStream ps =\n   /**\n    * Returns true if and only if a source map file should be generated for each\n    * module, as opposed to one unified map. This is specified by having the\n-   * source map pattern include the %module% variable.\n+   * source map pattern include the %outname% variable.\n    */\n   private boolean shouldGenerateMapPerModule(B options) {\n     return options.sourceMapOutputPath != null\n-        && options.sourceMapOutputPath.contains(\"%module%\");\n+        && options.sourceMapOutputPath.contains(\"%outname%\");\n   }\n \n   /**\n    * @param options The options to the Compiler.\n    * @param path The directory or a file in the directory in which to place the\n    *        source map.\n-   * @param module If modules are being generated, the name of the current\n-   *        module.\n-   */\n-  private PrintStream openSourceMapStream(B options, String path,\n-      String module) throws IOException {\n+   */\n+  private PrintStream openSourceMapStream(B options, String path)\n+      throws IOException {\n     if (options.sourceMapOutputPath == null) {\n       return null;\n     }\n \n     String sourceMapPath = options.sourceMapOutputPath;\n-\n-    // Replace the %module% \"variable\" with the name of the module.\n-    if (module != null) {\n-      sourceMapPath = sourceMapPath.replace(\"%module%\", module);\n-    }\n+    sourceMapPath = sourceMapPath.replace(\"%outname%\", path);\n \n     String mapPath = null;\n \n     }\n \n     File outputFile = new File(path);\n-    PrintStream out = openSourceMapStream(options, path, null);\n+    PrintStream out = openSourceMapStream(options, path + \".js\");\n     compiler.getSourceMap().appendTo(out, outputFile.getName());\n     out.close();\n   }\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n       // by external definitions.\n       return false;\n     }\n+    \n+    // Don't inline this special function\n+    if (RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(fnName)) {\n+      return false;\n+    }\n \n     Node fnNode = fn.getFunctionNode();\n     return injector.doesFunctionMeetMinimumRequirements(fnName, fnNode);\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n           isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n         // if the variable is referenced more than once, we can only\n         // inline it if it's immutable and never defined before referenced.\n-        Node value = init.getAssignedValue();\n+        Node value;\n+        if (init != null) {\n+          value = init.getAssignedValue();\n+        } else {\n+          // Create a new node for variable that is never initialized.\n+          value = NodeUtil.newUndefinedNode();\n+        }\n         Preconditions.checkNotNull(value);\n         inlineWellDefinedVariable(v, value, referenceInfo.references);\n         staleVars.add(v);\n       // 2) A reference to the variable has been inlined. We're downstream\n       //    of the mechanism that creates variable references, so we don't\n       //    have a good way to update the reference. Just punt on it.\n-      return compiler.getCodingConvention().isExported(var.name) ||\n-          staleVars.contains(var);\n+      // 3) Don't inline the special RENAME_PROPERTY_FUNCTION_NAME\n+      return compiler.getCodingConvention().isExported(var.name)\n+          || RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name)\n+          || staleVars.contains(var);\n     }\n \n     /**\n         return false;\n       }\n \n-      Reference refInit = refInfo.getInitializingReference();\n-      if (!isValidInitialization(refInit)) {\n-        return false;\n-      }\n-\n-      if (refDecl != refInit) {\n-        Preconditions.checkState(refInit == refSet.get(1));\n-        startingReadRef = 2;\n+      boolean isNeverAssigned = refInfo.isNeverAssigned();\n+      // For values that are never assigned, only the references need to be \n+      // checked.\n+      if (!isNeverAssigned) {\n+        Reference refInit = refInfo.getInitializingReference();\n+        if (!isValidInitialization(refInit)) {\n+          return false;\n+        }\n+\n+        if (refDecl != refInit) {\n+          Preconditions.checkState(refInit == refSet.get(1));\n+          startingReadRef = 2;\n+        }\n+\n+        if (!refInfo.isWellDefined()) {\n+          return false;\n+        }\n+        \n+        Node value = refInit.getAssignedValue();\n+        Preconditions.checkNotNull(value);\n+        if (!(NodeUtil.isImmutableValue(value) &&\n+            (value.getType() != Token.STRING ||\n+             isStringWorthInlining(v, refInfo.references)))) {\n+          return false;\n+        }\n+\n       }\n \n       for (int i = startingReadRef; i < refSet.size(); i++) {\n         }\n       }\n \n-      if (!refInfo.isWellDefined()) {\n-        return false;\n-      }\n-\n-      Node value = refInit.getAssignedValue();\n-      Preconditions.checkNotNull(value);\n-      return NodeUtil.isImmutableValue(value) &&\n-          (value.getType() != Token.STRING ||\n-           isStringWorthInlining(v, refInfo.references));\n+      return true;\n     }\n   }\n }\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n     }\n \n     /**\n-     * @param index The index into the references array to look for an \n+     * @param index The index into the references array to look for an\n      * assigning declaration.\n      *\n      * This is either the declaration if a value is assigned (such as\n     private boolean isInitializingDeclarationAt(int index) {\n       Reference maybeInit = references.get(index);\n       if (maybeInit.isInitializingDeclaration()) {\n-        // This is a declaration that represents the initial value. \n+        // This is a declaration that represents the initial value.\n         // Specifically, var declarations without assignments such as \"var a;\"\n         // are not.\n         return true;\n       }\n       return false;\n     }\n-    \n-    /**\n-     * @param index The index into the references array to look for an \n+\n+    /**\n+     * @param index The index into the references array to look for an\n      * initialized assignment reference. That is, an assignment immediately\n      * follow a variable declaration that itself does not initialize the\n      * variable.\n         }\n       }\n       return false;\n-    }    \n+    }\n \n     /**\n      * @return The reference that provides the value for the variable at the\n       return assigned;\n     }\n \n+    /**\n+     * @return Whether the variable is never assigned a value.\n+     */\n+    boolean isNeverAssigned() {\n+      int size = references.size();\n+      for (int i = 0; i < size; i++) {\n+        Reference ref = references.get(i);\n+        if (ref.isLvalue() || ref.isInitializingDeclaration()) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    }\n+\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n--- a/src/com/google/javascript/rhino/jstype/AllType.java\n+++ b/src/com/google/javascript/rhino/jstype/AllType.java\n \n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n+import com.google.javascript.rhino.ErrorReporter;\n \n /**\n  * All type, representing all values.\n   public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n     return BooleanLiteralSet.BOTH;\n   }\n+\n+  @Override\n+  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    return this;\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/ArrowType.java\n+++ b/src/com/google/javascript/rhino/jstype/ArrowType.java\n \n package com.google.javascript.rhino.jstype;\n \n+import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.Node;\n-\n-\n \n /**\n  * The arrow type is an internal type that models the functional arrow type\n   private static final long serialVersionUID = 1L;\n \n   final Node parameters;\n-  final JSType returnType;\n+  JSType returnType;\n \n   ArrowType(JSTypeRegistry registry, Node parameters,\n       JSType returnType) {\n   public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n     return BooleanLiteralSet.TRUE;\n   }\n+\n+  @Override\n+  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    returnType = safeResolve(returnType, t, scope);\n+    if (parameters != null) {\n+      for (Node paramNode = parameters.getFirstChild();\n+           paramNode != null; paramNode = paramNode.getNext()) {\n+        paramNode.setJSType(paramNode.getJSType().resolve(t, scope));\n+      }\n+    }\n+    return this;\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/EnumElementType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumElementType.java\n \n \n \n+import com.google.javascript.rhino.ErrorReporter;\n+\n import java.util.Set;\n \n /**\n    * <pre>var LOCAL_CODES = {A: 3, B: 9, C: 8}</pre>\n    * the primitive type of the the constants is {@code number}.\n    */\n-  private final JSType primitiveType;\n+  private JSType primitiveType;\n \n   // The primitive type, if it is an object.\n-  private final ObjectType primitiveObjectType;\n+  private ObjectType primitiveObjectType;\n \n   private final String name;\n \n   public JSType getPrimitiveType() {\n     return primitiveType;\n   }\n+\n+  @Override\n+  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    primitiveType = primitiveType.resolve(t, scope);\n+    primitiveObjectType =\n+        (ObjectType) safeResolve(primitiveObjectType, t, scope);\n+    return this;\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/EnumType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumType.java\n import static com.google.javascript.rhino.jstype.TernaryValue.FALSE;\n import static com.google.javascript.rhino.jstype.TernaryValue.TRUE;\n \n+import com.google.javascript.rhino.ErrorReporter;\n+\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.Set;\n-\n \n /**\n  * An enum type representing a branded collection of elements. Each element\n   private static final long serialVersionUID = 1L;\n \n   // the type of the individual elements\n-  private final EnumElementType elementsType;\n+  private EnumElementType elementsType;\n   // the elements' names (they all have the same type)\n   private final Set<String> elements = new HashSet<String>();\n \n   public boolean matchesObjectContext() {\n     return true;\n   }\n+\n+  @Override\n+  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    elementsType = (EnumElementType) elementsType.resolve(t, scope);\n+    return super.resolveInternal(t, scope);\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/FunctionPrototypeType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionPrototypeType.java\n \n package com.google.javascript.rhino.jstype;\n \n+import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.jstype.ObjectType;\n \n import java.util.List;\n   public Iterable<ObjectType> getCtorImplementedInterfaces() {\n     return getOwnerFunction().getImplementedInterfaces();\n   }\n+\n+  // The owner will always be a resolved type, so there's no need to set\n+  // the ownerFunction in resolveInternal.\n+  // (it would lead to infinite loops if we did).\n+  // JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope);\n }\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n+import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n   /**\n    * {@code [[Call]]} property.\n    */\n-  private final ArrowType call;\n+  private ArrowType call;\n \n   /**\n    * The {@code prototype} property. This field is lazily initialized by\n   public String getTemplateTypeName() {\n     return templateTypeName;\n   }\n+\n+  @Override\n+  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    call = (ArrowType) safeResolve(call, t, scope);\n+    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n+    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+\n+    boolean changed = false;\n+    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n+        ImmutableList.builder();\n+    for (ObjectType iface : implementedInterfaces) {\n+      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n+      resolvedInterfaces.add(resolvedIface);\n+      changed |= (resolvedIface != iface);\n+    }\n+    if (changed) {\n+      implementedInterfaces = resolvedInterfaces.build();\n+    }\n+\n+    if (subTypes != null) {\n+      for (int i = 0; i < subTypes.size(); i++) {\n+        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+      }\n+    }\n+\n+    return super.resolveInternal(t, scope);\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n \n \n import com.google.common.base.Preconditions;\n+import com.google.javascript.rhino.ErrorReporter;\n \n import java.util.List;\n import java.util.Set;\n   public Iterable<ObjectType> getCtorImplementedInterfaces() {\n     return getConstructor().getImplementedInterfaces();\n   }\n+  \n+  // The owner will always be a resolved type, so there's no need to set\n+  // the constructor in resolveInternal.\n+  // (it would lead to infinite loops if we did).\n+  // JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope);\n }\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n \n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n+import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n+import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n \n import java.io.Serializable;\n  */\n public abstract class JSType implements Serializable {\n   private static final long serialVersionUID = 1L;\n+\n+  private boolean resolved = false;\n+  private JSType resolveResult = null;\n \n   public static final String UNKNOWN_NAME =\n       \"Unknown class name\";\n    */\n   public abstract <T> T visit(Visitor<T> visitor);\n \n+  /**\n+   * Resolve this type in the given scope.\n+   *\n+   * The returned value must be equal to {@code this}, as defined by\n+   * {@link Object#equals}. It may or may not be the same object. This method\n+   * may modify the internal state of {@code this}, as long as it does\n+   * so in a way that preserves Object equality.\n+   *\n+   * For efficiency, we should only resolve a type once per compilation job.\n+   * For incremental compilations, one compilation job may need the\n+   * artifacts from a previous generation, so we will eventually need\n+   * a generational flag instead of a boolean one.\n+   */\n+  public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) {\n+    if (resolved) {\n+      // TODO(nicksantos): Check to see if resolve() looped back on itself.\n+      // Preconditions.checkNotNull(resolveResult);\n+      if (resolveResult == null) {\n+        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n+      }\n+      return resolveResult;\n+    }\n+    resolved = true;\n+    resolveResult = resolveInternal(t, scope);\n+    return resolveResult;\n+  }\n+\n+  /**\n+   * @see #resolve\n+   */\n+  abstract JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope);\n+\n+  void setResolvedTypeInternal(JSType type) {\n+    resolveResult = type;\n+    resolved = true;\n+  }\n+\n+  /** Whether the type has been resolved. */\n+  public final boolean isResolved() {\n+    return resolved;\n+  }\n+\n+  /** Clears the resolved field. */\n+  public final void clearResolved() {\n+    resolved = false;\n+    resolveResult = null;\n+  }\n+\n+  /**\n+   * A null-safe resolve.\n+   * @see #resolve\n+   */\n+  static final JSType safeResolve(\n+      JSType type, ErrorReporter t, StaticScope<JSType> scope) {\n+    return type == null ? null : type.resolve(t, scope);\n+  }\n+\n   public static class TypePair {\n     public final JSType typeA;\n     public final JSType typeB;\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n   private final String sourceName;\n   private final int lineno;\n   private final int charno;\n-  private boolean isResolved = false;\n \n   /**\n    * If true, don't warn about unresolveable type names.\n   @Override\n   public void forgiveUnknownNames() {\n     forgiving = true;\n-  }\n-\n-  /** Whether the type name has been resolved to an enum or object. */\n-  public boolean isResolved() {\n-    return isResolved;\n-  }\n-\n-  /** Clears the resolved field. */\n-  public void clearResolved() {\n-    isResolved = false;\n   }\n \n   /** Returns the type to which this refers (which is unknown if unresolved). */\n   /**\n    * Resolve the referenced type within the enclosing scope.\n    */\n-  public void resolve(ErrorReporter t, StaticScope<JSType> enclosing) {\n+  @Override\n+  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n     // TODO(user): Investigate whether it is really necessary to keep two\n     // different mechanisms for resolving named types, and if so, which order\n     // makes more sense. Now, resolution via registry is first in order to\n     // avoid triggering the warnings built into the resolution via properties.\n-    if (isResolved()) return;\n-\n-    resolveViaRegistry(t, enclosing);\n+    boolean resolved = resolveViaRegistry(t, enclosing);\n     if (detectImplicitPrototypeCycle()) {\n       handleTypeCycle(t);\n     }\n \n-    if (isResolved()) return;\n+    if (resolved) {\n+      super.resolveInternal(t, enclosing);\n+      return referencedType;\n+    }\n \n     resolveViaProperties(t, enclosing);\n     if (detectImplicitPrototypeCycle()) {\n       handleTypeCycle(t);\n     }\n+\n+    super.resolveInternal(t, enclosing);\n+    return referencedType;\n   }\n \n   /**\n    * Resolves a named type by looking it up in the registry.\n-   */\n-  private void resolveViaRegistry(\n+   * @return True if we resolved successfully.\n+   */\n+  private boolean resolveViaRegistry(\n       ErrorReporter t, StaticScope<JSType> enclosing) {\n     ObjectType type = ObjectType.cast(registry.getType(reference));\n     if (type != null) {\n       setReferencedType(type, t, enclosing);\n-    }\n+      return true;\n+    }\n+    return false;\n   }\n \n   /**\n       StaticScope<JSType> enclosing) {\n     referencedType = type;\n     checkEnumElementCycle(t);\n-    isResolved = true;\n+    setResolvedTypeInternal(referencedType);\n   }\n \n   private void handleTypeCycle(ErrorReporter t) {\n     referencedType = registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n     t.warning(\"Cycle detected in inheritance chain of type \" + reference,\n         sourceName, lineno, null, charno);\n-    isResolved = true;\n+    setResolvedTypeInternal(referencedType);\n   }\n \n   private void checkEnumElementCycle(ErrorReporter t) {\n           JSTypeNative.CHECKED_UNKNOWN_TYPE);\n     }\n \n-    isResolved = true;\n+    setResolvedTypeInternal(referencedType);\n   }\n \n   JSType getTypedefType(ErrorReporter t, StaticSlot<JSType> slot, String name) {\n--- a/src/com/google/javascript/rhino/jstype/NoObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/NoObjectType.java\n \n package com.google.javascript.rhino.jstype;\n \n+import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n \n import java.io.Serializable;\n-\n \n /**\n  * The bottom Object type, representing the subclass of all objects.\n   public FunctionType getConstructor() {\n     return null;\n   }\n+\n+  @Override\n+  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    return this;\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n import static com.google.common.base.Preconditions.checkState;\n \n import com.google.common.collect.Maps;\n+import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n \n import java.io.Serializable;\n     /**\n      * Property's type.\n      */\n-    private final JSType type;\n+    private JSType type;\n \n     /**\n      * Whether the property's type is inferred.\n   public boolean isNativeObjectType() {\n     return nativeType;\n   }\n+\n+  @Override\n+  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    // Don't try to resolve native types, because it's unnecessary and\n+    // there are infinite loops between native types.\n+    if (implicitPrototype != null && !implicitPrototype.isNativeObjectType()) {\n+      implicitPrototype = (ObjectType) implicitPrototype.resolve(t, scope);\n+    }\n+    for (Property prop : properties.values()) {\n+      prop.type = safeResolve(prop.type, t, scope);\n+    }\n+    return this;\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n  \n package com.google.javascript.rhino.jstype;\n \n+import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n \n import java.util.List;\n   @Override\n   public boolean isEnumType() {\n     return referencedType.isEnumType();\n+  }\n+\n+  @Override\n+  public boolean isEnumElementType() {\n+    return referencedType.isEnumElementType();\n   }\n \n   @Override\n   public <T> T visit(Visitor<T> visitor) {\n     return referencedType.visit(visitor);\n   }\n+\n+  @Override\n+  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    referencedType = (ObjectType) referencedType.resolve(t, scope);\n+    return this;\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n  \n package com.google.javascript.rhino.jstype;\n \n+import com.google.javascript.rhino.ErrorReporter;\n+\n import java.util.HashMap;\n import java.util.Map;\n \n public class RecordType extends PrototypeObjectType {\n   private static final long serialVersionUID = 1L;\n \n-  private final Map<String, JSType> properties = new HashMap<String, JSType>();\n+  private Map<String, JSType> properties = new HashMap<String, JSType>();\n   private boolean isFrozen = false;\n \n   /**\n     sb.append(\" }\");\n     return sb.toString();\n   }\n+\n+  @Override\n+  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    for (Map.Entry<String, JSType> entry : properties.entrySet()) {\n+      JSType type = entry.getValue();\n+      JSType resolvedType = type.resolve(t, scope);\n+      if (type != resolvedType) {\n+        properties.put(entry.getKey(), resolvedType);\n+      }\n+    }\n+    return super.resolveInternal(t, scope);\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java\n  \n package com.google.javascript.rhino.jstype;\n \n+import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.Maps;\n \n import java.util.Map;\n *\n  */\n public class RecordTypeBuilder {\n+  private boolean isEmpty = true;\n   private JSTypeRegistry registry;\n-  private final Map<String, JSType> properties = Maps.newHashMap();\n+  private final ImmutableMap.Builder<String, JSType> properties =\n+      ImmutableMap.builder();\n \n   public RecordTypeBuilder(JSTypeRegistry registry) {\n     this.registry = registry;\n    * @return The builder itself for chaining purposes.\n    */\n   public RecordTypeBuilder addProperty(String name, JSType type) {\n+    isEmpty = false;\n     properties.put(name, type);\n     return this;\n   }\n    */\n   public JSType build() {\n      // If we have an empty record, simply return the object type.\n-    if (properties.size() == 0) {\n+    if (isEmpty) {\n        return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n     }\n \n-    return registry.createRecordType(properties);\n+    return registry.createRecordType(properties.build());\n   }\n }\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n \n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n+import com.google.common.collect.ImmutableSet;\n+import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.jstype.JSType.TypePair;\n \n import java.util.Set;\n import java.util.SortedSet;\n import java.util.TreeSet;\n-\n \n /**\n  * The {@code UnionType} implements a common JavaScript idiom in which the\n public class UnionType extends JSType {\n   private static final long serialVersionUID = 1L;\n \n-  final Set<JSType> alternates;\n+  Set<JSType> alternates;\n \n   /**\n    * Creates a union type.\n   public <T> T visit(Visitor<T> visitor) {\n     return visitor.caseUnionType(this);\n   }\n+\n+  @Override\n+  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this); // for circularly defined types.\n+\n+    boolean changed = false;\n+    ImmutableSet.Builder<JSType> resolvedTypes = ImmutableSet.builder();\n+    for (JSType alternate : alternates) {\n+      JSType newAlternate = alternate.resolve(t, scope);\n+      changed |= (alternate != newAlternate);\n+      resolvedTypes.add(alternate);\n+    }\n+    if (changed) {\n+      alternates = resolvedTypes.build();\n+    }\n+    return this;\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/UnknownType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnknownType.java\n package com.google.javascript.rhino.jstype;\n \n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n+\n+import com.google.javascript.rhino.ErrorReporter;\n \n import java.util.Set;\n \n   public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n     return BooleanLiteralSet.BOTH;\n   }\n+\n+  @Override\n+  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    return this;\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/ValueType.java\n+++ b/src/com/google/javascript/rhino/jstype/ValueType.java\n  \n package com.google.javascript.rhino.jstype;\n \n+import com.google.javascript.rhino.ErrorReporter;\n+\n /**\n  * Value types (null, void, number, boolean, string).\n  */\n   public boolean isSubtype(JSType that) {\n     return JSType.isSubtype(this, that);\n   }\n+\n+  @Override\n+  final JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    return this;\n+  }\n }\n--- /dev/null\n+++ b/src/com/google/javascript/rhino/testing/Asserts.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *   Google Inc.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.testing;\n+\n+import com.google.javascript.rhino.ErrorReporter;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.StaticScope;\n+\n+import junit.framework.Assert;\n+\n+/**\n+ * Helper methods for making assertions about the validity of types.\n+*\n+ */\n+public class Asserts {\n+  private Asserts() {} // all static\n+\n+  public static JSType assertResolvesToSame(JSType type) {\n+    Assert.assertSame(type, assertValidResolve(type));\n+    return type;\n+  }\n+\n+  /** @return The resolved type */\n+  public static JSType assertValidResolve(JSType type) {\n+    return assertValidResolve(type, new EmptyScope());\n+  }\n+\n+  /** @return The resolved type */\n+  public static JSType assertValidResolve(\n+      JSType type, StaticScope<JSType> scope) {\n+    ErrorReporter t = TestErrorReporter.forNoExpectedReports();\n+    JSType resolvedType = type.resolve(t, scope);\n+    Assert.assertEquals(\"JSType#resolve should not affect object equality\",\n+        type, resolvedType);\n+    Assert.assertEquals(\"JSType#resolve should not affect hash codes\",\n+        type.hashCode(), resolvedType.hashCode());\n+    return resolvedType;\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/rhino/testing/EmptyScope.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.testing;\n+\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.StaticScope;\n+import com.google.javascript.rhino.jstype.StaticSlot;\n+\n+/**\n+ * An empty scope implementation.\n+*\n+ */\n+public class EmptyScope implements StaticScope<JSType> {\n+  @Override\n+  public StaticScope<JSType> getParentScope() {\n+    return null;\n+  }\n+\n+  @Override\n+  public StaticSlot<JSType> getSlot(String name) {\n+    return null;\n+  }\n+\n+  @Override\n+  public StaticSlot<JSType> getOwnSlot(String name) {\n+    return null;\n+  }\n+\n+  @Override\n+  public JSType getTypeOfThis() {\n+    return null;\n+  }\n+}\n--- a/src/com/google/javascript/rhino/testing/TestErrorReporter.java\n+++ b/src/com/google/javascript/rhino/testing/TestErrorReporter.java\n     this.warnings = warnings;\n   }\n \n+  public static TestErrorReporter forNoExpectedReports() {\n+    return new TestErrorReporter(null, null);\n+  }\n+\n   public void setErrors(String[] errors) {\n     this.errors = errors;\n     errorsIndex = 0;\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n         \"\\n\" +\n         \"factorial(5)\\n\");\n   }\n+  \n+  public void testRenamePropertyFunction() {\n+    testSame(\"function JSCompiler_renameProperty(x) {return x} \" +\n+             \"JSCompiler_renameProperty('foo')\");\n+  }\n \n   // Inline a single reference function into deeper modules\n   public void testCrossModuleInlining1() {\n--- a/test/com/google/javascript/jscomp/InlineVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/InlineVariablesTest.java\n         \"}\",\n         \"var X=1; X; function f() {1;}\");\n   }\n+\n+  public void testInlineUndefined1() {\n+    test(\"var x; x;\",\n+         \"void 0;\");\n+  }\n+\n+  public void testInlineUndefined2() {\n+    testSame(\"var x; x++;\");\n+  }\n+\n+  public void testInlineUndefined3() {\n+    testSame(\"var x; var x;\");\n+  }\n+\n+  public void testInlineUndefined4() {\n+    test(\"var x; x; x;\",\n+         \"void 0; void 0;\");\n+  }\n+\n+  public void testInlineUndefined5() {\n+    test(\"var x; for(x in a) {}\",\n+         \"var x; for(x in a) {}\");\n+  }  \n+  \n+  public void testIssue90() {\n+    test(\"var x; x && alert(1)\",\n+         \"void 0 && alert(1)\");\n+  }\n+  \n+  public void testRenamePropertyFunction() {\n+    testSame(\"var JSCompiler_renameProperty; \" +\n+             \"JSCompiler_renameProperty('foo')\");\n+  }\n }\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n import static com.google.javascript.rhino.jstype.TernaryValue.TRUE;\n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Sets;\n-import com.google.javascript.rhino.jstype.JSType.TypePair;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.JSDocInfo.Visibility;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.JSType.TypePair;\n+import com.google.javascript.rhino.testing.Asserts;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n+import com.google.javascript.rhino.testing.EmptyScope;\n \n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+// TODO(nicksantos): Split some of this up into per-class unit tests.\n public class JSTypeTest extends BaseJSTypeTestCase {\n   private FunctionType dateMethod;\n   private FunctionType functionType;\n   private EnumType enumType;\n   private EnumElementType elementsType;\n \n-  private static final StaticScope<JSType> EMPTY_SCOPE =\n-      new StaticScope<JSType>() {\n-    @Override\n-    public StaticScope<JSType> getParentScope() { return null; }\n-\n-    @Override\n-    public StaticSlot<JSType> getSlot(String name) { return null; }\n-\n-    @Override\n-    public StaticSlot<JSType> getOwnSlot(String name) { return null; }\n-\n-    @Override\n-    public JSType getTypeOfThis() { return null; }\n-  };\n+  private static final StaticScope<JSType> EMPTY_SCOPE = new EmptyScope();\n \n   /**\n    * A non exhaustive list of representative types used to test simple\n \n           public JSType getTypeOfThis() { return null; }\n         });\n+    assertNotNull(namedGoogBar.getImplicitPrototype());\n \n     types = ImmutableList.of(\n         NO_OBJECT_TYPE,\n \n     assertTrue(U2U_CONSTRUCTOR_TYPE.isNative());\n     assertTrue(U2U_CONSTRUCTOR_TYPE.isNativeObjectType());\n+\n+    Asserts.assertResolvesToSame(U2U_CONSTRUCTOR_TYPE);\n   }\n \n   /**\n     // getPropertyType\n     assertEquals(NO_TYPE,\n         NO_OBJECT_TYPE.getPropertyType(\"anyProperty\"));\n+\n+    Asserts.assertResolvesToSame(NO_OBJECT_TYPE);\n   }\n \n   /**\n     // getPropertyType\n     assertEquals(NO_TYPE,\n         NO_TYPE.getPropertyType(\"anyProperty\"));\n+\n+    Asserts.assertResolvesToSame(NO_TYPE);\n   }\n \n   /**\n     assertEquals(\"Array\", ARRAY_TYPE.toString());\n \n     assertTrue(ARRAY_TYPE.isNativeObjectType());\n+\n+    Asserts.assertResolvesToSame(ARRAY_TYPE);\n   }\n \n   /**\n \n     // toString\n     assertEquals(\"?\", UNKNOWN_TYPE.toString());\n+\n+    Asserts.assertResolvesToSame(UNKNOWN_TYPE);\n   }\n \n   /**\n \n     // toString\n     assertEquals(\"*\", ALL_TYPE.toString());\n+\n+    Asserts.assertResolvesToSame(ALL_TYPE);\n   }\n \n   /**\n \n     assertTrue(OBJECT_TYPE.isNativeObjectType());\n     assertTrue(OBJECT_TYPE.getImplicitPrototype().isNativeObjectType());\n+\n+    Asserts.assertResolvesToSame(OBJECT_TYPE);\n   }\n \n   /**\n     assertEquals(\"Number\", NUMBER_OBJECT_TYPE.toString());\n \n     assertTrue(NUMBER_OBJECT_TYPE.isNativeObjectType());\n+\n+    Asserts.assertResolvesToSame(NUMBER_OBJECT_TYPE);\n   }\n \n   /**\n \n     // toString\n     assertEquals(\"number\", NUMBER_TYPE.toString());\n+\n+    Asserts.assertResolvesToSame(NUMBER_TYPE);\n   }\n \n   /**\n \n     // toString\n     assertEquals(\"null\", NULL_TYPE.toString());\n+\n+    Asserts.assertResolvesToSame(NULL_TYPE);\n   }\n \n   /**\n     assertEquals(\"Date\", DATE_TYPE.toString());\n \n     assertTrue(DATE_TYPE.isNativeObjectType());\n+\n+    Asserts.assertResolvesToSame(DATE_TYPE);\n   }\n \n   /**\n     assertEquals(\"RegExp\", REGEXP_TYPE.toString());\n \n     assertTrue(REGEXP_TYPE.isNativeObjectType());\n+\n+    Asserts.assertResolvesToSame(REGEXP_TYPE);\n   }\n \n   /**\n     assertTrue(createNullableType(STRING_OBJECT_TYPE).isNullable());\n \n     assertTrue(STRING_OBJECT_TYPE.isNativeObjectType());\n+\n+    Asserts.assertResolvesToSame(STRING_OBJECT_TYPE);\n   }\n \n   /**\n     // findPropertyType\n     assertEquals(NUMBER_TYPE, STRING_TYPE.findPropertyType(\"length\"));\n     assertEquals(null, STRING_TYPE.findPropertyType(\"unknownProperty\"));\n+\n+    Asserts.assertResolvesToSame(STRING_TYPE);\n   }\n \n   private void assertPropertyTypeDeclared(ObjectType ownerType, String prop) {\n     assertTrue(recordType.matchesObjectContext());\n     assertFalse(recordType.matchesStringContext());\n     assertFalse(recordType.matchesUint32Context());\n+\n+    Asserts.assertResolvesToSame(recordType);\n   }\n \n   /**\n     assertEquals(FUNCTION_FUNCTION_TYPE, functionInst.getConstructor());\n     assertEquals(FUNCTION_PROTOTYPE, functionInst.getImplicitPrototype());\n     assertEquals(functionInst, FUNCTION_FUNCTION_TYPE.getInstanceType());\n+\n+    Asserts.assertResolvesToSame(functionInst);\n   }\n \n   /**\n     // hasProperty\n     assertTrue(functionType.hasProperty(\"prototype\"));\n     assertPropertyTypeInferred(functionType, \"prototype\");\n+\n+    Asserts.assertResolvesToSame(functionType);\n   }\n \n   /**\n     assertFalse(VOID_TYPE.matchesObjectContext());\n     assertTrue(VOID_TYPE.matchesStringContext());\n     assertFalse(VOID_TYPE.matchesUint32Context());\n+\n+    Asserts.assertResolvesToSame(VOID_TYPE);\n   }\n \n   /**\n \n     // toString\n     assertEquals(\"boolean\", BOOLEAN_TYPE.toString());\n+\n+    Asserts.assertResolvesToSame(BOOLEAN_TYPE);\n   }\n \n   /**\n     assertEquals(\"Boolean\", BOOLEAN_OBJECT_TYPE.toString());\n \n     assertTrue(BOOLEAN_OBJECT_TYPE.isNativeObjectType());\n+\n+    Asserts.assertResolvesToSame(BOOLEAN_OBJECT_TYPE);\n   }\n \n   /**\n \n     // toString\n     assertEquals(\"enum{Enum}\", enumType.toString());\n+\n+    Asserts.assertResolvesToSame(enumType);\n   }\n \n   /**\n \n     // toString\n     assertEquals(\"Enum.<number>\", elementsType.toString());\n+\n+    Asserts.assertResolvesToSame(elementsType);\n   }\n \n   public void testStringEnumType() throws Exception {\n     assertEquals(false, stringEnum.hasProperty(\"length\"));\n     assertEquals(STRING_OBJECT_TYPE, stringEnum.autoboxesTo());\n     assertNull(stringEnum.getConstructor());\n+\n+    Asserts.assertResolvesToSame(stringEnum);\n   }\n \n   public void testStringObjectEnumType() throws Exception {\n     // findPropertyType\n     assertEquals(NUMBER_TYPE, nullOrString.findPropertyType(\"length\"));\n     assertEquals(null, nullOrString.findPropertyType(\"lengthx\"));\n+\n+    Asserts.assertResolvesToSame(nullOrString);\n   }\n \n   /**\n \n     // toString\n     assertEquals(\"{...}\", objectType.toString());\n+\n+    Asserts.assertResolvesToSame(objectType);\n   }\n \n   /**\n     namedGoogBar.canAssignTo(googBar);\n     assertTrue(googBar.equals(googBar));\n     assertFalse(googBar.equals(googSubBar));\n+\n+    Asserts.assertResolvesToSame(googBar);\n+    Asserts.assertResolvesToSame(googSubBar);\n   }\n \n   /**\n \n     assertFalse(namedGoogBar.isNativeObjectType());\n     assertFalse(namedGoogBar.getImplicitPrototype().isNativeObjectType());\n+\n+    JSType resolvedNamedGoogBar = Asserts.assertValidResolve(namedGoogBar);\n+    assertNotSame(resolvedNamedGoogBar, namedGoogBar);\n+    assertSame(resolvedNamedGoogBar, googBar.getInstanceType());\n   }\n \n   /**\n     assertEquals(a, realA);\n     assertEquals(b.hashCode(), realB.hashCode());\n     assertEquals(b, realB);\n+\n+    JSType resolvedA = Asserts.assertValidResolve(a);\n+    assertNotSame(resolvedA, a);\n+    assertSame(resolvedA, realA);\n+\n+    JSType resolvedB = Asserts.assertValidResolve(b);\n+    assertNotSame(resolvedB, b);\n+    assertSame(resolvedB, realB);\n   }\n \n   /**", "timestamp": 1264543168, "metainfo": ""}