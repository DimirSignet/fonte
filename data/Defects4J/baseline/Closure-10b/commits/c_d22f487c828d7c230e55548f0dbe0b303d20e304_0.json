{"sha": "d22f487c828d7c230e55548f0dbe0b303d20e304", "log": "Automated g4 rollback.  *** Reason for rollback *** breaks gmail   *** Original change description ***  Rewrite binds immediately followed by calls.  DELTA=154  (0 added, 153 deleted, 1 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2197   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n+++ b/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n   }\n \n   /**\n-   * @return the current coding convention.\n-   */\n-  CodingConvention getCodingConvention() {\n-    // Note: this assumes a thread safe coding convention object.\n-    return currentTraversal.getCompiler().getCodingConvention();\n-  }\n-\n-  /**\n    * Check if the specified node is null or is still in the AST.\n    */\n   @VisibleForTesting\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n             JSTypeNative.OBJECT_TYPE)\n     );\n   }\n-\n-  @Override\n-  public Bind describeFunctionBind(Node n) {\n-    // It would be nice to be able to identify a fn.bind call\n-    // but that requires knowing the type of \"fn\".\n-\n-    if (n.getType() != Token.CALL) {\n-      return null;\n-    }\n-\n-    Node callTarget = n.getFirstChild();\n-    String name = callTarget.getQualifiedName();\n-    if (name != null) {\n-      if (name.equals(\"goog.bind\") || name.equals(\"goog$bind\")) {\n-        // goog.bind(fn, self, args...);\n-        Node fn = callTarget.getNext();\n-        Node thisValue = safeNext(fn);\n-        Node parameters = safeNext(thisValue);\n-        return new Bind(fn, thisValue, parameters);\n-      }\n-\n-      if (name.equals(\"goog.partial\") || name.equals(\"goog$partial\")) {\n-        // goog.partial(fn, args...);\n-        Node fn = callTarget.getNext();\n-        Node thisValue = null;\n-        Node parameters = safeNext(fn);\n-        return new Bind(fn, thisValue, parameters);\n-      }\n-    }\n-\n-    if (callTarget.getType() == Token.GETPROP\n-        && callTarget.getLastChild().getString().equals(\"bind\")\n-        && callTarget.getFirstChild().getType() == Token.FUNCTION) {\n-      // (function(){}).bind(self, args...);\n-      Node fn = callTarget.getFirstChild();\n-      Node thisValue = callTarget.getNext();\n-      Node parameters = safeNext(thisValue);\n-      return new Bind(fn, thisValue, parameters);\n-    }\n-\n-    return null;\n-  }\n-\n-  private Node safeNext(Node n) {\n-    if (n != null) {\n-      return n.getNext();\n-    }\n-    return null;\n-  }\n }\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n   public String getGlobalObject();\n \n   /**\n-   * A Bind instance or null.\n-   */\n-  public Bind describeFunctionBind(Node n);\n-\n-  public static class Bind {\n-    // The target of the bind action\n-    final Node target;\n-    // The node representing the \"this\" value, maybe null\n-    final Node thisValue;\n-    // The head of a Node list representing the parameters\n-    final Node parameters;\n-\n-    public Bind(Node target, Node thisValue, Node parameters) {\n-      this.target = target;\n-      this.thisValue = thisValue;\n-      this.parameters = parameters;\n-    }\n-  }\n-\n-  /**\n    * Whether this CALL function is testing for the existence of a property.\n    */\n   public boolean isPropertyTestFunction(Node call);\n--- a/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n   public Collection<AssertionFunctionSpec> getAssertionFunctions() {\n     return Collections.emptySet();\n   }\n-\n-  @Override\n-  public Bind describeFunctionBind(Node n) {\n-    return null;\n-  }\n }\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n import com.google.common.collect.ImmutableSet;\n-import com.google.javascript.jscomp.CodingConvention.Bind;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.TernaryValue;\n         // Fall through on purpose because tryFoldStandardConstructors() may\n         // convert a NEW node into a CALL node\n       case Token.CALL:\n-        Node result =  tryFoldLiteralConstructor(node);\n-        if (result == node) {\n-          result = tryFoldImmediateCallToBoundFunction(node);\n-        }\n-        return result;\n+        return tryFoldLiteralConstructor(node);\n \n       case Token.COMMA:\n         return tryFoldComma(node);\n \n       default:\n         return node; //Nothing changed\n-    }\n-  }\n-\n-  private Node tryFoldImmediateCallToBoundFunction(Node n) {\n-    // Rewriting \"(fn.bind(a,b))()\" to \"fn.call(a,b)\" makes it inlinable\n-    Preconditions.checkState(n.getType() == Token.CALL);\n-    Node callTarget = n.getFirstChild();\n-    Bind bind = getCodingConvention().describeFunctionBind(callTarget);\n-    if (bind != null) {\n-      // replace the call target\n-      bind.target.detachFromParent();\n-      n.replaceChild(callTarget, bind.target);\n-      callTarget = bind.target;\n-\n-      // push the parameters\n-      addParameterAfter(bind.parameters, callTarget);\n-\n-      // add the this value before the parameters if necessary\n-      if (bind.thisValue != null && !NodeUtil.isUndefined(bind.thisValue)) {\n-        // rewrite from \"fn(a, b)\" to \"fn.call(thisValue, a, b)\"\n-        Node newCallTarget = new Node(Token.GETPROP,\n-            callTarget.cloneTree(),\n-            Node.newString(\"call\").copyInformationFrom(callTarget));\n-        n.replaceChild(callTarget, newCallTarget);\n-        n.addChildAfter(bind.thisValue.cloneTree(), newCallTarget);\n-\n-      }\n-      reportCodeChange();\n-    }\n-    return n;\n-  }\n-\n-  private void addParameterAfter(Node parameterList, Node after) {\n-    if (parameterList != null) {\n-      // push the last parameter to the head of the list first.\n-      addParameterAfter(parameterList.getNext(), after);\n-      after.getParent().addChildAfter(parameterList.cloneTree(), after);\n     }\n   }\n \n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n     test(\"([a])\", \"1\");\n     testSame(\"([foo()])\");\n   }\n-\n-  public void testBindToCall() {\n-    test(\"(goog.bind(f))()\", \"f()\");\n-    test(\"(goog.bind(f,a))()\", \"f.call(a)\");\n-    test(\"(goog.bind(f,a,b))()\", \"f.call(a,b)\");\n-\n-    test(\"(goog.bind(f))(a)\", \"f(a)\");\n-    test(\"(goog.bind(f,a))(b)\", \"f.call(a,b)\");\n-    test(\"(goog.bind(f,a,b))(c)\", \"f.call(a,b,c)\");\n-\n-    test(\"(goog.partial(f))()\", \"f()\");\n-    test(\"(goog.partial(f,a))()\", \"f(a)\");\n-    test(\"(goog.partial(f,a,b))()\", \"f(a,b)\");\n-\n-    test(\"(goog.partial(f))(a)\", \"f(a)\");\n-    test(\"(goog.partial(f,a))(b)\", \"f(a,b)\");\n-    test(\"(goog.partial(f,a,b))(c)\", \"f(a,b,c)\");\n-\n-    test(\"((function(){}).bind())()\", \"((function(){}))()\");\n-    test(\"((function(){}).bind(a))()\", \"((function(){})).call(a)\");\n-    test(\"((function(){}).bind(a,b))()\", \"((function(){})).call(a,b)\");\n-\n-    test(\"((function(){}).bind())(a)\", \"((function(){}))(a)\");\n-    test(\"((function(){}).bind(a))(b)\", \"((function(){})).call(a,b)\");\n-    test(\"((function(){}).bind(a,b))(c)\", \"((function(){})).call(a,b,c)\");\n-\n-    // Don't rewrite if the bind isn't the immediate call target\n-    testSame(\"(goog.bind(f)).call(g)\");\n-  }\n }", "timestamp": 1307433283, "metainfo": ""}