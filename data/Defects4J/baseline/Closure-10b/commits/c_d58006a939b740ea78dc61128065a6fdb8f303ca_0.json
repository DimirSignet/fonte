{"sha": "d58006a939b740ea78dc61128065a6fdb8f303ca", "log": "Clean up the reverse abstract interpreter a bit so that we handle \"checked unknowns\" better, and don't have lots of spurious unknown slots during data flow-based type inference. fixes issue 783  Tested: yes  R=johnlenz DELTA=249  (87 added, 130 deleted, 32 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5297   ", "commit": "\n--- a/src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java\n     TypePair merged = merging.apply(new TypePair(leftType, rightType));\n \n     // creating new scope\n-    if (merged != null &&\n-        ((leftIsRefineable && merged.typeA != null) ||\n-         (rightIsRefineable && merged.typeB != null))) {\n-      FlowScope informed = blindScope.createChildFlowScope();\n-      if (leftIsRefineable && merged.typeA != null) {\n-        declareNameInScope(informed, left, merged.typeA);\n-      }\n-      if (rightIsRefineable && merged.typeB != null) {\n-        declareNameInScope(informed, right, merged.typeB);\n-      }\n-      return informed;\n+    if (merged != null) {\n+      return maybeRestrictTwoNames(\n+          blindScope,\n+          left, leftType, leftIsRefineable ? merged.typeA : null,\n+          right, rightType, rightIsRefineable ? merged.typeB : null);\n     }\n     return blindScope;\n   }\n     }\n \n     // restricting left type\n-    leftType = (leftType == null) ? null :\n+    JSType restrictedLeftType = (leftType == null) ? null :\n         leftType.getRestrictedTypeGivenToBooleanOutcome(condition);\n-    if (leftType == null) {\n+    if (restrictedLeftType == null) {\n       return firstPreciserScopeKnowingConditionOutcome(\n           right, blindScope, condition);\n     }\n     }\n \n     if (condition) {\n-      rightType = (rightType == null) ? null :\n+      JSType restrictedRightType = (rightType == null) ? null :\n           rightType.getRestrictedTypeGivenToBooleanOutcome(condition);\n \n       // creating new scope\n-      if ((leftType != null && leftIsRefineable) ||\n-          (rightType != null && rightIsRefineable)) {\n-        FlowScope informed = blindScope.createChildFlowScope();\n-        if (leftIsRefineable && leftType != null) {\n-          declareNameInScope(informed, left, leftType);\n-        }\n-        if (rightIsRefineable && rightType != null) {\n-          declareNameInScope(informed, right, rightType);\n-        }\n-        return informed;\n-      }\n+      return maybeRestrictTwoNames(\n+          blindScope,\n+          left, leftType, leftIsRefineable ? restrictedLeftType : null,\n+          right, rightType, rightIsRefineable ? restrictedRightType : null);\n     }\n     return blindScope;\n   }\n     return informed;\n   }\n \n+  /**\n+   * If the restrictedType differs from the originalType, then we should\n+   * branch the current flow scope and create a new flow scope with the name\n+   * declared with the new type.\n+   *\n+   * We try not to create spurious child flow scopes as this makes type\n+   * inference slower.\n+   *\n+   * We also do not want spurious slots around in type inference, because\n+   * we use these as a signal for \"checked unknown\" types. A \"checked unknown\"\n+   * type is a symbol that the programmer has already checked and verified that\n+   * it's defined, even if we don't know what it is.\n+   *\n+   * It is OK to pass non-name nodes into this method, as long as you pass\n+   * in {@code null} for a restricted type.\n+   */\n+  private FlowScope maybeRestrictName(\n+      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType) {\n+    if (restrictedType != null && restrictedType != originalType) {\n+      FlowScope informed = blindScope.createChildFlowScope();\n+      declareNameInScope(informed, node, restrictedType);\n+      return informed;\n+    }\n+    return blindScope;\n+  }\n+\n+  /**\n+   * @see maybeRestrictName\n+   */\n+  private FlowScope maybeRestrictTwoNames(\n+      FlowScope blindScope,\n+      Node left, JSType originalLeftType, JSType restrictedLeftType,\n+      Node right, JSType originalRightType, JSType restrictedRightType) {\n+    boolean shouldRefineLeft =\n+        restrictedLeftType != null && restrictedLeftType != originalLeftType;\n+    boolean shouldRefineRight =\n+        restrictedRightType != null && restrictedRightType != originalRightType;\n+    if (shouldRefineLeft || shouldRefineRight) {\n+      FlowScope informed = blindScope.createChildFlowScope();\n+      if (shouldRefineLeft) {\n+        declareNameInScope(informed, left, restrictedLeftType);\n+      }\n+      if (shouldRefineRight) {\n+        declareNameInScope(informed, right, restrictedRightType);\n+      }\n+      return informed;\n+    }\n+    return blindScope;\n+  }\n+\n   private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope,\n       boolean outcome) {\n     JSType type = getTypeIfRefinable(name, blindScope);\n     if (type != null) {\n-      JSType restrictedType =\n-          type.getRestrictedTypeGivenToBooleanOutcome(outcome);\n-      FlowScope informed = blindScope.createChildFlowScope();\n-      declareNameInScope(informed, name, restrictedType);\n-      return informed;\n+      return maybeRestrictName(\n+          blindScope, name, type,\n+          type.getRestrictedTypeGivenToBooleanOutcome(outcome));\n     }\n     return blindScope;\n   }\n \n   private FlowScope caseTypeOf(Node node, JSType type, String value,\n         boolean resultEqualsValue, FlowScope blindScope) {\n-    JSType restrictedType =\n-        getRestrictedByTypeOfResult(type, value, resultEqualsValue);\n-    if (restrictedType == null) {\n-      return blindScope;\n-    }\n-    FlowScope informed = blindScope.createChildFlowScope();\n-    declareNameInScope(informed, node, restrictedType);\n-    return informed;\n+    return maybeRestrictName(\n+        blindScope, node, type,\n+        getRestrictedByTypeOfResult(type, value, resultEqualsValue));\n   }\n \n   private FlowScope caseInstanceOf(Node left, Node right, FlowScope blindScope,\n     } else {\n       visitor = new RestrictByFalseInstanceOfResultVisitor(targetType);\n     }\n-    JSType restrictedLeftType = leftType.visit(visitor);\n-    if (restrictedLeftType != null && !restrictedLeftType.equals(leftType)) {\n-      FlowScope informed = blindScope.createChildFlowScope();\n-      declareNameInScope(informed, left, restrictedLeftType);\n-      return informed;\n-    }\n-    return blindScope;\n+    return maybeRestrictName(\n+        blindScope, left, leftType, leftType.visit(visitor));\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n    * method of types to get the restricted type.\n    */\n   public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {\n+    if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {\n+      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);\n+    }\n+\n     BooleanLiteralSet literals = getPossibleToBooleanOutcomes();\n     if (literals.contains(outcome)) {\n       return this;\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n         \"Property foo never defined on Object\");\n   }\n \n-  public void testMissingProperty20() throws Exception {\n-    // NOTE(nicksantos): In the else branch, we know that x.foo is a\n-    // CHECKED_UNKNOWN (UNKNOWN restricted to a falsey value). We could\n-    // do some more sophisticated analysis here. Obviously, if x.foo is false,\n-    // then x.foo cannot possibly be called. For example, you could imagine a\n-    // VagueType that was like UnknownType, but had some constraints on it\n-    // so that we knew it could never be a function.\n-    //\n-    // For now, we just punt on this issue.\n-    testTypes(\n-        \"/** @param {Object} x */\" +\n-        \"function f(x) { if (x.foo) { } else { x.foo(); } }\");\n-  }\n-\n   public void testMissingProperty21() throws Exception {\n     testTypes(\n         \"/** @param {Object} x */\" +\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"required: string\");\n   }\n \n+  public void testIssue783() throws Exception {\n+    testTypes(\n+        \"/** @constructor */\" +\n+        \"var Type = function () {\" +\n+        \"  /** @type {Type} */\" +\n+        \"  this.me_ = this;\" +\n+        \"};\" +\n+        \"Type.prototype.doIt = function() {\" +\n+        \"  var me = this.me_;\" +\n+        \"  for (var i = 0; i < me.unknownProp; i++) {}\" +\n+        \"};\",\n+        \"Property unknownProp never defined on Type\");\n+  }\n+\n   /**\n    * Tests that the || operator is type checked correctly, that is of\n    * the type of the first argument or of the second argument. See\n   }\n \n   public void testMissingProperty20() throws Exception {\n-    // NOTE(nicksantos): In the else branch, we know that x.foo is a\n-    // CHECKED_UNKNOWN (UNKNOWN restricted to a falsey value). We could\n-    // do some more sophisticated analysis here. Obviously, if x.foo is false,\n-    // then x.foo cannot possibly be called. For example, you could imagine a\n-    // VagueType that was like UnknownType, but had some constraints on it\n-    // so that we knew it could never be a function.\n-    //\n-    // For now, we just punt on this issue.\n     testTypes(\n         \"/** @param {Object} x */\" +\n-        \"function f(x) { if (x.foo) { } else { x.foo(); } }\");\n+        \"function f(x) { if (x.foo) { } else { x.foo(); } }\",\n+        \"Property foo never defined on Object\");\n   }\n \n   public void testMissingProperty21() throws Exception {\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n     assertTypeEquals(ALL_TYPE,\n         ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n \n-    assertTypeEquals(UNKNOWN_TYPE,\n+    assertTypeEquals(CHECKED_UNKNOWN_TYPE,\n         UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n     assertTypeEquals(UNKNOWN_TYPE,\n         UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));", "timestamp": 1343945142, "metainfo": ""}