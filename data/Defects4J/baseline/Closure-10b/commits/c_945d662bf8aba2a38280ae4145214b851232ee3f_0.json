{"sha": "945d662bf8aba2a38280ae4145214b851232ee3f", "log": "Fix an API bug in the symbol table. We need GlobalNamespace's getName() to point to the full name, not the base name, to be consistent with the other symbol tables  R=acleung DELTA=57  (29 added, 4 deleted, 24 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2851   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckGlobalNames.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalNames.java\n         compiler.report(\n             JSError.make(ref.source.getName(), ref.node,\n                 NAME_DEFINED_LATE_WARNING,\n-                name.fullName(),\n-                parent.fullName(),\n+                name.getFullName(),\n+                parent.getFullName(),\n                 parent.getDeclaration().source.getName(),\n                 String.valueOf(parent.getDeclaration().node.getLineno())));\n       }\n         JSError.make(ref.source.getName(), ref.node, STRICT_MODULE_DEP_QNAME,\n                      ref.getModule().getName(),\n                      name.getDeclaration().getModule().getName(),\n-                     name.fullName()));\n+                     name.getFullName()));\n   }\n \n   private void reportRefToUndefinedName(Name name, Ref ref) {\n \n     compiler.report(\n         JSError.make(ref.getSourceName(), ref.node, level,\n-            UNDEFINED_NAME_WARNING, name.fullName()));\n+            UNDEFINED_NAME_WARNING, name.getFullName()));\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n     checkNamespaces();\n \n     for (Name n : globalNames) {\n-      flattenReferencesToCollapsibleDescendantNames(n, n.getName());\n+      flattenReferencesToCollapsibleDescendantNames(n, n.getBaseName());\n     }\n \n     // We collapse property definitions after collapsing property references\n     // because this step can alter the parse tree above property references,\n     // invalidating the node ancestry stored with each reference.\n     for (Name n : globalNames) {\n-      collapseDeclarationOfNameAndDescendants(n, n.getName());\n+      collapseDeclarationOfNameAndDescendants(n, n.getBaseName());\n     }\n   }\n \n   private void warnAboutNamespaceAliasing(Name nameObj, Ref ref) {\n     compiler.report(\n         JSError.make(ref.getSourceName(), ref.node,\n-                     UNSAFE_NAMESPACE_WARNING, nameObj.fullName()));\n+                     UNSAFE_NAMESPACE_WARNING, nameObj.getFullName()));\n   }\n \n   /**\n   private void warnAboutNamespaceRedefinition(Name nameObj, Ref ref) {\n     compiler.report(\n         JSError.make(ref.getSourceName(), ref.node,\n-                     NAMESPACE_REDEFINED_WARNING, nameObj.fullName()));\n+                     NAMESPACE_REDEFINED_WARNING, nameObj.getFullName()));\n   }\n \n   /**\n     if (n.props == null) return;\n \n     for (Name p : n.props) {\n-      String propAlias = appendPropForAlias(alias, p.getName());\n+      String propAlias = appendPropForAlias(alias, p.getBaseName());\n \n       if (p.canCollapse()) {\n         flattenReferencesTo(p, propAlias);\n     Ref ref = Iterables.getOnlyElement(name.getRefs());\n     Node nameNode = NodeUtil.newName(\n         compiler.getCodingConvention(), alias, ref.node,\n-        name.fullName());\n+        name.getFullName());\n     Node varNode = new Node(Token.VAR, nameNode).copyInformationFrom(nameNode);\n \n     Preconditions.checkState(\n    * @param alias The flattened name (e.g. \"a$b\" or \"a$b$c$d\")\n    */\n   private void flattenReferencesTo(Name n, String alias) {\n-    String originalName = n.fullName();\n+    String originalName = n.getFullName();\n     for (Ref r : n.getRefs()) {\n       if (r == n.getDeclaration()) {\n         // Declarations are handled separately.\n   private void flattenPrefixes(String alias, Name n, int depth) {\n     // Only flatten the prefix of a name declaration if the name being\n     // initialized is fully qualified (i.e. not an object literal key).\n-    String originalName = n.fullName();\n+    String originalName = n.getFullName();\n     Ref decl = n.getDeclaration();\n     if (decl != null && decl.node != null &&\n         decl.node.getType() == Token.GETPROP) {\n       for (Name p : n.props) {\n         // Recurse first so that saved node ancestries are intact when needed.\n         collapseDeclarationOfNameAndDescendants(\n-            p, appendPropForAlias(alias, p.getName()));\n+            p, appendPropForAlias(alias, p.getBaseName()));\n \n         if (!p.inExterns && canCollapseChildNames &&\n             p.getDeclaration() != null &&\n             p.getDeclaration().node.getParent() != null &&\n             p.getDeclaration().node.getParent().getType() == Token.ASSIGN) {\n           updateSimpleDeclaration(\n-              appendPropForAlias(alias, p.getName()), p, p.getDeclaration());\n+              appendPropForAlias(alias, p.getBaseName()), p, p.getDeclaration());\n         }\n       }\n     }\n     // Create the new alias node.\n     Node nameNode = NodeUtil.newName(\n         compiler.getCodingConvention(), alias, gramps.getFirstChild(),\n-        refName.fullName());\n+        refName.getFullName());\n     NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n \n     if (gramps.getType() == Token.EXPR_RESULT) {\n \n       Node nameNode = NodeUtil.newName(\n           compiler.getCodingConvention(),\n-          alias, ref.node.getAncestor(2), n.fullName());\n+          alias, ref.node.getAncestor(2), n.getFullName());\n \n       JSDocInfo info = ref.node.getParent().getJSDocInfo();\n       if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME) ||\n               if (n.getType() == Token.THIS) {\n                 compiler.report(\n                     JSError.make(name.getDeclaration().getSourceName(), n,\n-                        UNSAFE_THIS, name.fullName()));\n+                        UNSAFE_THIS, name.getFullName()));\n               }\n             }\n           });\n           key.getString() : String.valueOf(++arbitraryNameCounter);\n \n       // If the name cannot be collapsed, skip it.\n-      String qName = objlitName.fullName() + '.' + propName;\n+      String qName = objlitName.getFullName() + '.' + propName;\n       Name p = nameMap.get(qName);\n       if (p != null && !p.canCollapse()) {\n         continue;\n     if (n.props != null) {\n       for (Name p : n.props) {\n         if (p.needsToBeStubbed()) {\n-          String propAlias = appendPropForAlias(alias, p.getName());\n+          String propAlias = appendPropForAlias(alias, p.getBaseName());\n           Node nameNode = Node.newString(Token.NAME, propAlias);\n           Node newVar = new Node(Token.VAR, nameNode)\n               .copyInformationFromForTree(addAfter);\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n       OTHER,\n     }\n \n-    private final String name;\n+    private final String baseName;\n     final Name parent;\n     List<Name> props;\n \n     JSDocInfo docInfo = null;\n \n     Name(String name, Name parent, boolean inExterns) {\n-      this.name = name;\n+      this.baseName = name;\n       this.parent = parent;\n       this.type = Type.OTHER;\n       this.inExterns = inExterns;\n       return node;\n     }\n \n+    String getBaseName() {\n+      return baseName;\n+    }\n+\n     @Override\n     public String getName() {\n-      return name;\n+      return getFullName();\n+    }\n+\n+    String getFullName() {\n+      return parent == null ? baseName : parent.getFullName() + '.' + baseName;\n     }\n \n     @Override\n     }\n \n     @Override public String toString() {\n-      return fullName() + \" (\" + type + \"): globalSets=\" + globalSets +\n+      return getFullName() + \" (\" + type + \"): globalSets=\" + globalSets +\n           \", localSets=\" + localSets + \", totalGets=\" + totalGets +\n           \", aliasingGets=\" + aliasingGets + \", callGets=\" + callGets;\n-    }\n-\n-    String fullName() {\n-      return parent == null ? name : parent.fullName() + '.' + name;\n     }\n \n     /**\n--- a/src/com/google/javascript/jscomp/ProcessDefines.java\n+++ b/src/com/google/javascript/jscomp/ProcessDefines.java\n       if (refInfo != null) {\n         Ref ref = refInfo.ref;\n         Name name = refInfo.name;\n-        String fullName = name.fullName();\n+        String fullName = name.getFullName();\n         switch (ref.type) {\n           case SET_FROM_GLOBAL:\n           case SET_FROM_LOCAL:\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.SymbolTable.Reference;\n import com.google.javascript.jscomp.SymbolTable.Symbol;\n     assertEquals(x.getDeclaration(), refs.get(0));\n     assertEquals(Token.LP, refs.get(0).getNode().getParent().getType());\n     assertEquals(Token.RETURN, refs.get(1).getNode().getParent().getType());\n+  }\n+\n+  public void testNamespacedReferences() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"var goog = {};\" +\n+        \"goog.dom = {};\" +\n+        \"goog.dom.DomHelper = function(){};\");\n+    Symbol goog = getGlobalVar(table, \"goog\");\n+    assertNotNull(goog);\n+    assertEquals(3, Iterables.size(table.getReferences(goog)));\n+\n+    Symbol googDom = getGlobalVar(table, \"goog.dom\");\n+    assertNotNull(googDom);\n+\n+    // TODO(nicksantos): Fill in the missing reference.\n+    assertEquals(1, Iterables.size(table.getReferences(googDom)));\n+\n+    Symbol googDomHelper = getGlobalVar(table, \"goog.dom.DomHelper\");\n+    assertNotNull(googDomHelper);\n+    assertEquals(1, Iterables.size(table.getReferences(googDomHelper)));\n   }\n \n   private Symbol getGlobalVar(SymbolTable table, String name) {", "timestamp": 1312215101, "metainfo": ""}