{"sha": "ae5ae60fb49108d4daa3f3e5dd2e1b135d305e9a", "log": "A symbol table for third-party clients  R=acleung DELTA=637  (574 added, 46 deleted, 17 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2682   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   }\n \n   @Override\n-  ScopeCreator getTypedScopeCreator() {\n+  MemoizedScopeCreator getTypedScopeCreator() {\n     return getPassConfig().getTypedScopeCreator();\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  DefaultPassConfig ensureDefaultPassConfig() {\n+    PassConfig passes = getPassConfig().getBasePassConfig();\n+    Preconditions.checkState(passes instanceof DefaultPassConfig,\n+        \"PassConfigs must eventually delegate to the DefaultPassConfig\");\n+    return (DefaultPassConfig) passes;\n+  }\n+\n+  SymbolTable buildKnownSymbolTable() {\n+    SymbolTable symbolTable = new SymbolTable();\n+\n+    MemoizedScopeCreator typedScopeCreator = getTypedScopeCreator();\n+    if (typedScopeCreator != null) {\n+      symbolTable.addSymbolsFrom(typedScopeCreator);\n+    }\n+\n+    GlobalNamespace globalNamespace =\n+        ensureDefaultPassConfig().getGlobalNamespace();\n+    if (globalNamespace != null) {\n+      symbolTable.addSymbolsFrom(globalNamespace);\n+    }\n+\n+    return symbolTable;\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n \n   /**\n    * A global namespace to share across checking passes.\n-   * TODO(nicksantos): This is a hack until I can get the namespace into\n-   * the symbol table.\n    */\n   private GlobalNamespace namespaceForChecks = null;\n \n     this.idGeneratorMap = state.idGeneratorMap;\n   }\n \n+  GlobalNamespace getGlobalNamespace() {\n+    return namespaceForChecks;\n+  }\n+\n   @Override\n   protected List<PassFactory> getChecks() {\n     List<PassFactory> checks = Lists.newArrayList();\n   @Override\n   protected List<PassFactory> getOptimizations() {\n     List<PassFactory> passes = Lists.newArrayList();\n+    passes.add(garbageCollectChecks);\n \n     // TODO(nicksantos): The order of these passes makes no sense, and needs\n     // to be re-arranged.\n \n           new ProcessDefines(compiler, replacements)\n               .injectNamespace(namespaceForChecks).process(externs, jsRoot);\n-\n-          // Kill the namespace in the other class\n-          // so that it can be garbage collected after all passes\n-          // are through with it.\n+        }\n+      };\n+    }\n+  };\n+\n+  /** Release references to data that is only needed during checks. */\n+  final PassFactory garbageCollectChecks =\n+      new PassFactory(\"garbageCollectChecks\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      return new CompilerPass() {\n+        @Override\n+        public void process(Node externs, Node jsRoot) {\n+          // Kill the global namespace so that it can be garbage collected\n+          // after all passes are through with it.\n           namespaceForChecks = null;\n         }\n       };\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n   }\n \n   @Override\n+  public Node getRootNode() {\n+    return root.getParent();\n+  }\n+\n+  @Override\n   public StaticScope<JSType> getParentScope() {\n     return null;\n   }\n   public Iterable<Ref> getReferences(Name slot) {\n     ensureGenerated();\n     return Collections.unmodifiableList(slot.getRefs());\n+  }\n+\n+  @Override\n+  public StaticScope<JSType> getScope(Name slot) {\n+    return this;\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/LinkedFlowScope.java\n+++ b/src/com/google/javascript/jscomp/LinkedFlowScope.java\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.SimpleSlot;\n import com.google.javascript.rhino.jstype.StaticScope;\n   @Override\n   public JSType getTypeOfThis() {\n     return cache.functionScope.getTypeOfThis();\n+  }\n+\n+  @Override\n+  public Node getRootNode() {\n+    return getFunctionScope().getRootNode();\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/MemoizedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/MemoizedScopeCreator.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.jstype.StaticSymbolTable;\n \n+import java.util.List;\n import java.util.Map;\n \n /**\n  *\n  * @author nicksantos@google.com (Nick Santos)\n  */\n-class MemoizedScopeCreator implements ScopeCreator {\n+class MemoizedScopeCreator\n+    implements ScopeCreator, StaticSymbolTable<Var, Var> {\n \n   private final Map<Node, Scope> scopes = Maps.newHashMap();\n   private final ScopeCreator delegate;\n    */\n   MemoizedScopeCreator(ScopeCreator delegate) {\n     this.delegate = delegate;\n+  }\n+\n+  @Override\n+  public Iterable<Var> getReferences(Var var) {\n+    return ImmutableList.of(var);\n+  }\n+\n+  @Override\n+  public Scope getScope(Var var) {\n+    return var.scope;\n+  }\n+\n+  @Override\n+  public Iterable<Var> getAllSymbols() {\n+    List<Var> vars = Lists.newArrayList();\n+    for (Scope s : scopes.values()) {\n+      Iterables.addAll(vars, s.getAllSymbols());\n+    }\n+    return vars;\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/PassConfig.java\n+++ b/src/com/google/javascript/jscomp/PassConfig.java\n   /**\n    * Gets the scope creator for typed scopes.\n    */\n-  ScopeCreator getTypedScopeCreator() {\n+  MemoizedScopeCreator getTypedScopeCreator() {\n     return typedScopeCreator;\n   }\n \n       return delegate.getOptimizations();\n     }\n \n-    @Override ScopeCreator getTypedScopeCreator() {\n+    @Override MemoizedScopeCreator getTypedScopeCreator() {\n       return delegate.getTypedScopeCreator();\n     }\n \n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n   @Override\n   public Iterable<Var> getAllSymbols() {\n     return referenceMap.keySet();\n+  }\n+\n+  @Override\n+  public Scope getScope(Var var) {\n+    return var.scope;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterators;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.jstype.StaticScope;\n import com.google.javascript.rhino.jstype.StaticSlot;\n import com.google.javascript.rhino.jstype.StaticSourceFile;\n-\n+import com.google.javascript.rhino.jstype.StaticSymbolTable;\n+\n+import java.util.Collections;\n import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.Map;\n  * @see DataFlowAnalysis\n  *\n  */\n-public class Scope implements StaticScope<JSType> {\n+public class Scope\n+    implements StaticScope<JSType>, StaticSymbolTable<Scope.Var, Scope.Var> {\n   private final Map<String, Var> vars = new LinkedHashMap<String, Var>();\n   private final Scope parent;\n   private final int depth;\n    * Gets the container node of the scope. This is typically the FUNCTION\n    * node or the global BLOCK/SCRIPT node.\n    */\n+  @Override\n   public Node getRootNode() {\n     return rootNode;\n   }\n     return vars.values().iterator();\n   }\n \n+  @Override\n+  public Iterable<Var> getReferences(Var var) {\n+    return ImmutableList.of(var);\n+  }\n+\n+  @Override\n+  public StaticScope<JSType> getScope(Var var) {\n+    return var.scope;\n+  }\n+\n+  @Override\n+  public Iterable<Var> getAllSymbols() {\n+    return Collections.unmodifiableCollection(vars.values());\n+  }\n+\n   /**\n    * Returns number of variables in this scope\n    */\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Maps;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.SimpleSlot;\n+import com.google.javascript.rhino.jstype.StaticReference;\n+import com.google.javascript.rhino.jstype.StaticScope;\n+import com.google.javascript.rhino.jstype.StaticSlot;\n+import com.google.javascript.rhino.jstype.StaticSourceFile;\n+import com.google.javascript.rhino.jstype.StaticSymbolTable;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A symbol table for people that want to use Closure Compiler as an indexer.\n+ *\n+ * Contains an index of all the symbols in the code within a compilation\n+ * job. The API is designed for people who want to visit all the symbols, rather\n+ * than people who want to lookup a specific symbol by a certain key.\n+ *\n+ * We can use this to combine different types of symbol tables. For example,\n+ * one class might have a {@code StaticSymbolTable} of all variable references,\n+ * and another class might have a {@code StaticSymbolTable} of all type names\n+ * in JSDoc comments. This class allows you to combine them into a unified\n+ * index.\n+ *\n+ * Most passes build their own \"partial\" symbol table that implements the same\n+ * interface (StaticSymbolTable, StaticSlot, and friends). Individual compiler\n+ * passes usually need more or less metadata about the certainty of symbol\n+ * information. Building a complete symbol table with all the necessary metadata\n+ * for all passes would be too slow. However, as long as these \"partial\" symbol\n+ * tables implement the proper interfaces, we should be able to add them to this\n+ * symbol table to make it more complete.\n+ *\n+ * If clients want fast lookup, they should build their own wrapper around\n+ * this symbol table that indexes symbols or references by the desired lookup\n+ * key.\n+ *\n+ * @see #addSymbolsFrom For more information on how to write plugins for this\n+ *    symbol table.\n+ *\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public final class SymbolTable\n+    implements StaticSymbolTable<SymbolTable.Symbol, SymbolTable.Reference> {\n+\n+  /**\n+   * All symbols in the program, uniquely identified by the node where\n+   * they're declared.\n+   */\n+  private final Map<Node, Symbol> symbols = Maps.newHashMap();\n+\n+  /**\n+   * All scopes in the program, uniquely identified by the node where\n+   * they're declared.\n+   */\n+  private final Map<Node, SymbolScope> scopes = Maps.newHashMap();\n+\n+  /**\n+   * Clients should get a symbol table by asking the compiler at the end\n+   * of a compilation job.\n+   */\n+  SymbolTable() {}\n+\n+  @Override\n+  public Iterable<Reference> getReferences(Symbol symbol) {\n+    return Collections.unmodifiableCollection(symbol.references.values());\n+  }\n+\n+  @Override\n+  public Iterable<Symbol> getAllSymbols() {\n+    return Collections.unmodifiableCollection(symbols.values());\n+  }\n+\n+  @Override\n+  public StaticScope<JSType> getScope(Symbol slot) {\n+    return slot.scope;\n+  }\n+\n+  /**\n+   * Make sure all the symbols and references in {@code otherSymbolTable}\n+   * are in this symbol table.\n+   *\n+   * Uniqueness of symbols and references is determined by the associated\n+   * node.\n+   *\n+   * If multiple symbol tables are mixed in, we do not check for consistency\n+   * between symbol tables. The first symbol we see dictates the type\n+   * information for that symbol.\n+   */\n+  <S extends StaticSlot<JSType>, R extends StaticReference<JSType>>\n+  void addSymbolsFrom(StaticSymbolTable<S, R> otherSymbolTable) {\n+    for (S otherSymbol : otherSymbolTable.getAllSymbols()) {\n+      SymbolScope myScope = createScopeFrom(\n+          otherSymbolTable.getScope(otherSymbol));\n+\n+      StaticReference<JSType> decl = otherSymbol.getDeclaration();\n+      if (decl == null) {\n+        continue;\n+      }\n+\n+      Node declNode = decl.getNode();\n+\n+      Symbol mySymbol = symbols.get(declNode);\n+      if (mySymbol == null) {\n+        mySymbol = new Symbol(\n+            otherSymbol.getName(),\n+            otherSymbol.getType(),\n+            otherSymbol.isTypeInferred(),\n+            myScope);\n+        symbols.put(declNode, mySymbol);\n+        myScope.ownSymbols.put(mySymbol.getName(), mySymbol);\n+\n+        mySymbol.setDeclaration(new Reference(mySymbol, declNode));\n+      }\n+\n+      for (R otherRef : otherSymbolTable.getReferences(otherSymbol)) {\n+        Node otherRefNode = otherRef.getNode();\n+        if (!mySymbol.references.containsKey(otherRefNode)) {\n+          mySymbol.references.put(\n+              otherRefNode, new Reference(mySymbol, otherRefNode));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Given a scope from another symbol table, returns the {@code SymbolScope}\n+   * rooted at the same node. Creates one if it doesn't exist yet.\n+   */\n+  private SymbolScope createScopeFrom(StaticScope<JSType> otherScope) {\n+    Node otherScopeRoot = otherScope.getRootNode();\n+    SymbolScope myScope = scopes.get(otherScopeRoot);\n+    if (myScope == null) {\n+      StaticScope<JSType> otherScopeParent = otherScope.getParentScope();\n+\n+      // If otherScope is a global scope, and we already have a global scope,\n+      // then something has gone seriously wrong.\n+      //\n+      // Not all symbol tables are rooted at the same global node, and\n+      // we do not want to mix and match symbol tables that are rooted\n+      // differently.\n+\n+      if (otherScopeParent == null) {\n+        // The global scope must be created before any local scopes.\n+        Preconditions.checkState(scopes.isEmpty());\n+      }\n+\n+      myScope = new SymbolScope(\n+          otherScopeRoot,\n+          otherScopeParent == null ? null : createScopeFrom(otherScopeParent),\n+          otherScope.getTypeOfThis());\n+      scopes.put(otherScopeRoot, myScope);\n+    }\n+    return myScope;\n+  }\n+\n+  public static final class Symbol extends SimpleSlot {\n+    // Use a linked hash map, so that the results are deterministic\n+    // (and so the declaration always comes first).\n+    private final Map<Node, Reference> references = Maps.newLinkedHashMap();\n+\n+    private final SymbolScope scope;\n+\n+    private Reference declaration = null;\n+\n+    Symbol(String name, JSType type, boolean inferred, SymbolScope scope) {\n+      super(name, type, inferred);\n+      this.scope = scope;\n+    }\n+\n+    @Override\n+    public Reference getDeclaration() {\n+      return declaration;\n+    }\n+\n+    /** Sets the declaration node. May only be called once. */\n+    void setDeclaration(Reference ref) {\n+      Preconditions.checkState(this.declaration == null);\n+      this.declaration = ref;\n+      references.put(ref.getNode(), ref);\n+    }\n+  }\n+\n+  public static final class Reference implements StaticReference<JSType> {\n+    private final Symbol symbol;\n+    private final Node node;\n+\n+    Reference(Symbol symbol, Node node) {\n+      this.symbol = symbol;\n+      this.node = node;\n+    }\n+\n+    @Override\n+    public Symbol getSymbol() {\n+      return symbol;\n+    }\n+\n+    @Override\n+    public Node getNode() {\n+      return node;\n+    }\n+\n+    @Override\n+    public StaticSourceFile getSourceFile() {\n+      return node.getStaticSourceFile();\n+    }\n+  }\n+\n+  public static final class SymbolScope implements StaticScope<JSType> {\n+    private final Node rootNode;\n+    private final SymbolScope parent;\n+    private final JSType typeOfThis;\n+    private final Map<String, Symbol> ownSymbols = Maps.newHashMap();\n+\n+    SymbolScope(\n+        Node rootNode,\n+        @Nullable SymbolScope parent,\n+        JSType typeOfThis) {\n+      this.rootNode = rootNode;\n+      this.parent = parent;\n+      this.typeOfThis = typeOfThis;\n+    }\n+\n+    @Override\n+    public Node getRootNode() {\n+      return rootNode;\n+    }\n+\n+    @Override\n+    public SymbolScope getParentScope() {\n+      return parent;\n+    }\n+\n+    @Override\n+    public Symbol getSlot(String name) {\n+      Symbol own = getOwnSlot(name);\n+      if (own != null) {\n+        return own;\n+      }\n+\n+      return parent == null ? null : parent.getSlot(name);\n+    }\n+\n+    @Override\n+    public Symbol getOwnSlot(String name) {\n+      return ownSymbols.get(name);\n+    }\n+\n+    @Override\n+    public JSType getTypeOfThis() {\n+      return typeOfThis;\n+    }\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/TightenTypes.java\n+++ b/src/com/google/javascript/jscomp/TightenTypes.java\n     }\n \n     @Override\n+    public Node getRootNode() { return null; }\n+\n+    @Override\n     public StaticScope<ConcreteType> getParentScope() { return parent; }\n \n     @Override\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n   ObjectType(JSTypeRegistry registry) {\n     super(registry);\n   }\n+\n+  @Override\n+  public Node getRootNode() { return null; }\n \n   @Override\n   public StaticScope<JSType> getParentScope() {\n--- a/src/com/google/javascript/rhino/jstype/StaticScope.java\n+++ b/src/com/google/javascript/rhino/jstype/StaticScope.java\n \n package com.google.javascript.rhino.jstype;\n \n+import com.google.javascript.rhino.Node;\n+\n /**\n  * The {@code StaticScope} interface must be implemented by any object that\n  * defines variables for the purposes of static analysis.  It is distinguished\n  * @param <T> The type of information stored about the slot\n  */\n public interface StaticScope<T> {\n+  /**\n+   * Returns the root node associated with this scope. May be null.\n+   */\n+  Node getRootNode();\n+\n   /** Returns the scope enclosing this one or null if none. */\n   StaticScope<T> getParentScope();\n \n--- a/src/com/google/javascript/rhino/jstype/StaticSymbolTable.java\n+++ b/src/com/google/javascript/rhino/jstype/StaticSymbolTable.java\n   Iterable<R> getReferences(S symbol);\n \n   /**\n+   * Returns the scope for a given symbol.\n+   */\n+  StaticScope<JSType> getScope(S symbol);\n+\n+  /**\n    * Returns all variables in this symbol table.\n    */\n   Iterable<S> getAllSymbols();\n--- /dev/null\n+++ b/src/com/google/javascript/rhino/testing/AbstractStaticScope.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.testing;\n+\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.jstype.StaticScope;\n+import com.google.javascript.rhino.jstype.StaticSlot;\n+\n+/**\n+ * A scope that just returns null for everything.\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public abstract class AbstractStaticScope<T> implements StaticScope<T> {\n+\n+  @Override\n+  public Node getRootNode() {\n+    return null;\n+  }\n+\n+  @Override\n+  public StaticScope<T> getParentScope() {\n+    return null;\n+  }\n+\n+  public abstract StaticSlot<T> getSlot(String name);\n+\n+  @Override\n+  public StaticSlot<T> getOwnSlot(String name) {\n+    return getSlot(name);\n+  }\n+\n+  @Override\n+  public T getTypeOfThis() {\n+    return null;\n+  }\n+}\n--- a/src/com/google/javascript/rhino/testing/MapBasedScope.java\n+++ b/src/com/google/javascript/rhino/testing/MapBasedScope.java\n import com.google.common.collect.Maps;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.SimpleSlot;\n-import com.google.javascript.rhino.jstype.StaticScope;\n import com.google.javascript.rhino.jstype.StaticSlot;\n \n import java.util.Map;\n  * A scope based on a simple hashmap.\n  * @author nicksantos@google.com (Nick Santos)\n  */\n-public class MapBasedScope implements StaticScope<JSType> {\n+public class MapBasedScope extends AbstractStaticScope<JSType> {\n   private final Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n \n   public MapBasedScope(Map<String, ? extends JSType> namesToTypes) {\n   }\n \n   @Override\n-  public StaticScope<JSType> getParentScope() {\n-    return null;\n-  }\n-\n-  @Override\n   public StaticSlot<JSType> getSlot(String name) {\n     return slots.get(name);\n   }\n-\n-  @Override\n-  public StaticSlot<JSType> getOwnSlot(String name) {\n-    return slots.get(name);\n-  }\n-\n-  @Override\n-  public JSType getTypeOfThis() {\n-    return null;\n-  }\n }\n--- a/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n+++ b/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n import com.google.javascript.rhino.jstype.StaticReference;\n import com.google.javascript.rhino.jstype.StaticScope;\n import com.google.javascript.rhino.jstype.StaticSlot;\n+import com.google.javascript.rhino.testing.AbstractStaticScope;\n import com.google.javascript.rhino.testing.TestErrorReporter;\n \n import junit.framework.TestCase;\n   }\n \n   // TODO(user): move to a common place if it can be used elsewhere\n-  private class FakeScope implements StaticScope<ConcreteType> {\n+  private class FakeScope extends AbstractStaticScope<ConcreteType> {\n     private final FakeScope parent;\n     private final Map<String, FakeSlot> slots = Maps.newHashMap();\n \n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.SymbolTable.Reference;\n+import com.google.javascript.jscomp.SymbolTable.Symbol;\n+import com.google.javascript.rhino.Token;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.List;\n+\n+/**\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public class SymbolTableTest extends TestCase {\n+\n+  public void testGlobalVar() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @type {number} */ var x = 5;\");\n+    assertNull(getGlobalVar(table, \"y\"));\n+    assertNotNull(getGlobalVar(table, \"x\"));\n+    assertEquals(\"number\", getGlobalVar(table, \"x\").getType().toString());\n+\n+    assertEquals(1, getVars(table).size());\n+  }\n+\n+  public void testGlobalVarReferences() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @type {number} */ var x = 5; x = 6;\");\n+    Symbol x = getGlobalVar(table, \"x\");\n+    List<Reference> refs = Lists.newArrayList(table.getReferences(x));\n+\n+    assertEquals(2, refs.size());\n+    assertEquals(x.getDeclaration(), refs.get(0));\n+    assertEquals(Token.VAR, refs.get(0).getNode().getParent().getType());\n+    assertEquals(Token.ASSIGN, refs.get(1).getNode().getParent().getType());\n+  }\n+\n+  private Symbol getGlobalVar(SymbolTable table, String name) {\n+    for (Symbol symbol : table.getAllSymbols()) {\n+      if (symbol.getName().equals(name) &&\n+          table.getScope(symbol).getParentScope() == null) {\n+        return symbol;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /** Returns all non-extern vars. */\n+  private List<Symbol> getVars(SymbolTable table) {\n+    List<Symbol> result = Lists.newArrayList();\n+    for (Symbol symbol : table.getAllSymbols()) {\n+      if (symbol.getDeclaration() != null &&\n+          !symbol.getDeclaration().getSourceFile().isExtern()) {\n+        result.add(symbol);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private SymbolTable createSymbolTable(String input) {\n+    List<JSSourceFile> inputs = Lists.newArrayList(\n+        JSSourceFile.fromCode(\"in1\", input));\n+    List<JSSourceFile> externs = Lists.newArrayList(\n+        JSSourceFile.fromCode(\n+            \"externs1\", CompilerTypeTestCase.DEFAULT_EXTERNS));\n+    CompilerOptions options = new CompilerOptions();\n+    CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(\n+        options);\n+    WarningLevel.VERBOSE.setOptionsForWarningLevel(options);\n+    options.ideMode = true;\n+\n+    Compiler compiler = new Compiler();\n+    compiler.compile(externs, inputs, options);\n+    return compiler.buildKnownSymbolTable();\n+  }\n+}\n--- a/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode;\n import com.google.javascript.rhino.testing.Asserts;\n+import com.google.javascript.rhino.testing.AbstractStaticScope;\n import com.google.javascript.rhino.testing.MapBasedScope;\n \n import junit.framework.TestCase;\n     SimpleErrorReporter reporter = new SimpleErrorReporter();\n     final JSTypeRegistry typeRegistry = new JSTypeRegistry(reporter);\n \n-    StaticScope<JSType> scope = new StaticScope<JSType>() {\n+    StaticScope<JSType> scope = new AbstractStaticScope<JSType>() {\n           public StaticSlot<JSType> getSlot(final String name) {\n             return new SimpleSlot(\n                 name,\n                 typeRegistry.getNativeType(JSTypeNative.UNKNOWN_TYPE),\n                 false);\n           }\n-          public StaticSlot<JSType> getOwnSlot(String name) {\n-            return getSlot(name);\n-          }\n-          public StaticScope<JSType> getParentScope() { return null; }\n-          public JSType getTypeOfThis() { return null; }\n         };\n \n     ObjectType namedType =\n     SimpleErrorReporter reporter = new SimpleErrorReporter();\n     final JSTypeRegistry typeRegistry = new JSTypeRegistry(reporter);\n \n-    StaticScope<JSType> scope = new StaticScope<JSType>() {\n+    StaticScope<JSType> scope = new AbstractStaticScope<JSType>() {\n           public StaticSlot<JSType> getSlot(final String name) {\n             return new SimpleSlot(\n                 name,\n                 typeRegistry.getNativeType(JSTypeNative.UNKNOWN_TYPE),\n                 false);\n           }\n-          public StaticSlot<JSType> getOwnSlot(String name) {\n-            return getSlot(name);\n-          }\n-          public StaticScope<JSType> getParentScope() { return null; }\n-          public JSType getTypeOfThis() { return null; }\n         };\n \n     ObjectType namedType =\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n import com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordProperty;\n import com.google.javascript.rhino.testing.Asserts;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n+import com.google.javascript.rhino.testing.AbstractStaticScope;\n import com.google.javascript.rhino.testing.MapBasedScope;\n \n import java.util.HashMap;\n     final ObjectType googObject = registry.createAnonymousObjectType();\n     googObject.defineDeclaredProperty(\"Bar\", googBar, null);\n \n-    namedGoogBar.resolve(null, new StaticScope<JSType>() {\n+    namedGoogBar.resolve(null, new AbstractStaticScope<JSType>() {\n           public StaticSlot<JSType> getSlot(String name) {\n             if (\"goog\".equals(name)) {\n               return new SimpleSlot(\"goog\", googObject, false);\n               return null;\n             }\n           }\n-\n-          public StaticSlot<JSType> getOwnSlot(String name) {\n-            return getSlot(name);\n-          }\n-\n-          public StaticScope<JSType> getParentScope() {\n-            return null;\n-          }\n-\n-          public JSType getTypeOfThis() { return null; }\n         });\n     assertNotNull(namedGoogBar.getImplicitPrototype());\n ", "timestamp": 1311174495, "metainfo": ""}