{"sha": "7efb21a25bb44dcfc513d584c6b191aeacfba367", "log": "Remove timestamps from the javadoc, because they screw up the diffs. Also, better error messages.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeTraversal.java\n+++ b/src/com/google/javascript/jscomp/NodeTraversal.java\n     // its parent is missing. We still have the scope stack in which it is still\n     // very useful to find out at least which function caused the exception.\n     if (!sourceName.isEmpty()) {\n-      int lineNumber = curNode == null ? -1 : curNode.getLineno();\n       message =\n           unexpectedException.getMessage() + \"\\n\" +\n-          \"  Node: \" + formatNodePosition(curNode) +\n-          (curNode == null ? \"\" :\n-            \"  Parent: \" + formatNodePosition(curNode.getParent()));\n+          formatNodeContext(\"Node\", curNode) +\n+          (curNode == null ?\n+              \"\" :\n+              formatNodeContext(\"Parent\", curNode.getParent()));\n     }\n     compiler.throwInternalError(message, unexpectedException);\n+  }\n+\n+  private String formatNodeContext(String label, Node n) {\n+    if (n == null) {\n+      return \"  \" + label + \": NULL\";\n+    }\n+    return \"  \" + label + \"(\" + n.toString(false, false, false) + \"): \"\n+        + formatNodePosition(n);\n   }\n \n   /**\n     }\n   }\n \n+  private static final String MISSING_SOURCE = \"[source unknown]\";\n+\n   private String formatNodePosition(Node n) {\n     if (n == null) {\n-      return \"[missing]\\n\";\n+      return MISSING_SOURCE + \"\\n\";\n     }\n \n     int lineNumber = n.getLineno();\n     int columnNumber = n.getCharno();\n-    return sourceName + \":\" + lineNumber + \":\" + columnNumber + \"\\n\" +\n-        compiler.getSourceLine(sourceName, lineNumber) + \"\\n\";\n+    String src = compiler.getSourceLine(sourceName, lineNumber);\n+    if (src == null) {\n+      src = MISSING_SOURCE;\n+    }\n+    return sourceName + \":\" + lineNumber + \":\" + columnNumber + \"\\n\"\n+        + src + \"\\n\";\n   }\n \n   /**\n \n     final Node fnName = n.getFirstChild();\n \n-    boolean anonymous = parent != null && NodeUtil.isFunctionAnonymous(n); \n+    boolean anonymous = parent != null && NodeUtil.isFunctionAnonymous(n);\n \n     if (!anonymous) {\n       // Named functions are parent of the containing scope.\n       // Anonymous function names are parent of the contained scope.\n       traverseBranch(fnName, n);\n     }\n-    \n+\n     final Node args = fnName.getNext();\n     final Node body = args.getNext();\n \n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n \n     @Override public String toString()\n     {\n+       return toString(true, true, true);\n+    }\n+\n+    public String toString(\n+        boolean printSource,\n+        boolean printAnnotations,\n+        boolean printType)\n+    {\n         if (Token.printTrees) {\n             StringBuilder sb = new StringBuilder();\n-            toString(sb);\n+            toString(sb, printSource, printAnnotations, printType);\n             return sb.toString();\n         }\n         return String.valueOf(type);\n     }\n \n-    private void toString(StringBuilder sb)\n+    private void toString(\n+        StringBuilder sb,\n+        boolean printSource,\n+        boolean printAnnotations,\n+        boolean printType)\n     {\n         if (Token.printTrees) {\n             sb.append(Token.name(type));\n                     sb.append(' ');\n                     sb.append(fn.getFunctionName());\n                 }\n-                sb.append(\" [source name: \");\n-                sb.append(sof.getSourceName());\n-                sb.append(\"] [encoded source length: \");\n-                sb.append(sof.getEncodedSourceEnd()\n-                          - sof.getEncodedSourceStart());\n-                sb.append(\"] [base line: \");\n-                sb.append(sof.getBaseLineno());\n-                sb.append(\"] [end line: \");\n-                sb.append(sof.getEndLineno());\n-                sb.append(']');\n+                if (printSource) {\n+                  sb.append(\" [source name: \");\n+                  sb.append(sof.getSourceName());\n+                  sb.append(\"] [encoded source length: \");\n+                  sb.append(sof.getEncodedSourceEnd()\n+                            - sof.getEncodedSourceStart());\n+                  sb.append(\"] [base line: \");\n+                  sb.append(sof.getBaseLineno());\n+                  sb.append(\"] [end line: \");\n+                  sb.append(sof.getEndLineno());\n+                  sb.append(']');\n+                }\n             } else if (type == Token.NUMBER) {\n                 sb.append(' ');\n                 sb.append(getDouble());\n             }\n-            int lineno = getLineno();\n-            if (lineno != -1) {\n-                sb.append(' ');\n-                sb.append(lineno);\n-            }\n-\n-            int[] keys = getSortedPropTypes();\n-            for (int i = 0; i < keys.length; i++) {\n-                int type = keys[i];\n-                PropListItem x = lookupProperty(type);\n-                sb.append(\" [\");\n-                sb.append(propToString(type));\n-                sb.append(\": \");\n-                String value;\n-                switch (type) {\n-                  case TARGETBLOCK_PROP : // can't add this as it recurses\n-                    value = \"target block property\";\n-                    break;\n-                  case LOCAL_BLOCK_PROP :     // can't add this as it is dull\n-                    value = \"last local block\";\n-                    break;\n-                  case ISNUMBER_PROP:\n-                    switch (x.intValue) {\n-                      case BOTH:\n-                        value = \"both\";\n-                        break;\n-                      case RIGHT:\n-                        value = \"right\";\n-                        break;\n-                      case LEFT:\n-                        value = \"left\";\n-                        break;\n-                      default:\n-                        throw Kit.codeBug();\n-                    }\n-                    break;\n-                  case SPECIALCALL_PROP:\n-                    switch (x.intValue) {\n-                      case SPECIALCALL_EVAL:\n-                        value = \"eval\";\n-                        break;\n-                      case SPECIALCALL_WITH:\n-                        value = \"with\";\n-                        break;\n-                      default:\n-                        // NON_SPECIALCALL should not be stored\n-                        throw Kit.codeBug();\n-                    }\n-                    break;\n-                  default :\n-                    Object obj = x.objectValue;\n-                    if (obj != null) {\n-                        value = obj.toString();\n-                    } else {\n-                        value = String.valueOf(x.intValue);\n-                    }\n-                    break;\n-                }\n-                sb.append(value);\n-                sb.append(']');\n-            }\n-\n-            if (jsType != null) {\n-                String jsTypeString = jsType.toString();\n-                if (jsTypeString != null) {\n-                    sb.append(\" : \");\n-                    sb.append(jsTypeString);\n-                }\n-            }\n-        }\n-    }\n+            if (printSource) {\n+              int lineno = getLineno();\n+              if (lineno != -1) {\n+                  sb.append(' ');\n+                  sb.append(lineno);\n+              }\n+            }\n+\n+            if (printAnnotations) {\n+              int[] keys = getSortedPropTypes();\n+              for (int i = 0; i < keys.length; i++) {\n+                  int type = keys[i];\n+                  PropListItem x = lookupProperty(type);\n+                  sb.append(\" [\");\n+                  sb.append(propToString(type));\n+                  sb.append(\": \");\n+                  String value;\n+                  switch (type) {\n+                    case TARGETBLOCK_PROP : // can't add this as it recurses\n+                      value = \"target block property\";\n+                      break;\n+                    case LOCAL_BLOCK_PROP :     // can't add this as it is dull\n+                      value = \"last local block\";\n+                      break;\n+                    case ISNUMBER_PROP:\n+                      switch (x.intValue) {\n+                        case BOTH:\n+                          value = \"both\";\n+                          break;\n+                        case RIGHT:\n+                          value = \"right\";\n+                          break;\n+                        case LEFT:\n+                          value = \"left\";\n+                          break;\n+                        default:\n+                          throw Kit.codeBug();\n+                      }\n+                      break;\n+                    case SPECIALCALL_PROP:\n+                      switch (x.intValue) {\n+                        case SPECIALCALL_EVAL:\n+                          value = \"eval\";\n+                          break;\n+                        case SPECIALCALL_WITH:\n+                          value = \"with\";\n+                          break;\n+                        default:\n+                          // NON_SPECIALCALL should not be stored\n+                          throw Kit.codeBug();\n+                      }\n+                      break;\n+                    default :\n+                      Object obj = x.objectValue;\n+                      if (obj != null) {\n+                          value = obj.toString();\n+                      } else {\n+                          value = String.valueOf(x.intValue);\n+                      }\n+                      break;\n+                  }\n+                  sb.append(value);\n+                  sb.append(']');\n+              }\n+            }\n+\n+            if (printType) {\n+              if (jsType != null) {\n+                  String jsTypeString = jsType.toString();\n+                  if (jsTypeString != null) {\n+                      sb.append(\" : \");\n+                      sb.append(jsTypeString);\n+                  }\n+              }\n+            }\n+        }\n+    }\n+\n \n     public String toStringTree() {\n         return toStringTreeImpl();\n--- a/test/com/google/javascript/jscomp/SanityCheckTest.java\n+++ b/test/com/google/javascript/jscomp/SanityCheckTest.java\n     try {\n       test(\"while(1){}\", \"while(1){}\");\n     } catch (RuntimeException e) {\n-      assertEquals(\n-          \"INTERNAL COMPILER ERROR.\\n\" +\n-          \"Please report this problem.\\n\" +\n-          \"Normalize constraints violated:\\n\" +\n-          \"WHILE node\\n\" +\n-          \"  Node: testcode:1:0\\n\" +\n-          \"null\\n\" +\n-          \"  Parent: testcode:1:0\\n\" +\n-          \"null\\n\",\n-          e.getMessage());\n+      assertTrue(e.getMessage().contains(\n+          \"Normalize constraints violated:\\nWHILE node\"));\n       exceptionCaught = true;\n     }\n     assert(exceptionCaught);", "timestamp": 1257799570, "metainfo": ""}