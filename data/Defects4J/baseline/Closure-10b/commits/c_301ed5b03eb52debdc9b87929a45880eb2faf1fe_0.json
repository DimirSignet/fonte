{"sha": "301ed5b03eb52debdc9b87929a45880eb2faf1fe", "log": "Change on 2010/05/11 by robby          Support aliases in JsDoc + some additional tests.          R=nick         DELTA=311  (294 added, 2 deleted, 15 changed)  Change on 2010/05/11 by nick          forward-declare type names that are dropped from the input.          R=alan         DELTA=31  (31 added, 0 deleted, 0 changed)  Change on 2010/05/11 by nick          Verify that closure-compiler issue 157 is invalid.          R=robert         DELTA=4  (4 added, 0 deleted, 0 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=vflmak   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n       if (options.manageClosureDependencies) {\n         for (CompilerInput input : inputs) {\n           input.setCompiler(this);\n+\n+          // Forward-declare all the provided types, so that they\n+          // are not flagged even if they are dropped from the process.\n+          for (String provide : input.getProvides()) {\n+            getTypeRegistry().forwardDeclareType(provide);\n+          }\n         }\n \n         inputs =\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n \n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n \n     if (!traversal.hasErrors()) {\n       // Apply the aliases.\n-      for (AliasedNode entry : traversal.getAliasUsages()) {\n-        entry.getAliasReference().getParent().replaceChild(\n-            entry.getAliasReference(),\n-            entry.getAliasDefinition().cloneTree());\n+      for (AliasUsage aliasUsage : traversal.getAliasUsages()) {\n+        aliasUsage.applyAlias();\n       }\n \n       // Remove the alias definitions.\n     }\n   }\n \n-  private class AliasedNode {\n+  private interface AliasUsage {\n+    public void applyAlias();\n+  }\n+\n+  private class AliasedNode implements AliasUsage {\n     private final Node aliasReference;\n \n     private final Node aliasDefinition;\n       this.aliasDefinition = aliasDefinition;\n     }\n \n-    public Node getAliasReference() {\n-      return aliasReference;\n-    }\n-\n-    public Node getAliasDefinition() {\n-      return aliasDefinition;\n-    }\n-  }\n+    public void applyAlias() {\n+      aliasReference.getParent().replaceChild(\n+          aliasReference, aliasDefinition.cloneTree());\n+    }\n+  }\n+\n+  private class AliasedTypeNode implements AliasUsage {\n+    private final Node aliasReference;\n+\n+    private final String correctedType;\n+\n+    AliasedTypeNode(Node aliasReference, String correctedType) {\n+      this.aliasReference = aliasReference;\n+      this.correctedType = correctedType;\n+    }\n+\n+    public void applyAlias() {\n+      aliasReference.setString(correctedType);\n+    }\n+  }\n+\n \n   private class Traversal implements NodeTraversal.ScopedCallback {\n     // The job of this class is to collect these three data sets.\n \n     private List<Node> scopeCalls = Lists.newArrayList();\n \n-    private List<AliasedNode> aliasUsages = Lists.newArrayList();\n+    private List<AliasUsage> aliasUsages = Lists.newArrayList();\n \n     // This map is temporary and cleared for each scope.\n     private Map<String, Node> aliases = Maps.newHashMap();\n       return aliasDefinitions;\n     }\n \n-    private List<AliasedNode> getAliasUsages() {\n+    private List<AliasUsage> getAliasUsages() {\n       return aliasUsages;\n     }\n \n         if (n.getType() == Token.NAME && parent.getType() == Token.VAR) {\n           if (n.hasChildren() && n.isQualifiedName()) {\n             // TODO(robbyw): What other checks go here?\n+            // TODO(robbyw): Emit errors about non-alias local variables.\n \n             aliases.put(n.getString(), n.getFirstChild());\n             aliasDefinitions.add(n);\n         if (n.getType() == Token.THIS) {\n           report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n         }\n+\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+          for (Node node : info.getTypeNodes()) {\n+            fixTypeNode(node);\n+          }\n+        }\n+\n+        // TODO(robbyw): Error for goog.scope not at root.\n+      }\n+    }\n+\n+    private void fixTypeNode(Node typeNode) {\n+      if (typeNode.getType() == Token.STRING) {\n+        String name = typeNode.getString();\n+        int endIndex = name.indexOf('.');\n+        if (endIndex == -1) {\n+          endIndex = name.length();\n+        }\n+        String baseName = name.substring(0, endIndex);\n+        Node aliasedNode = aliases.get(baseName);\n+        if (aliasedNode != null) {\n+          aliasUsages.add(new AliasedTypeNode(typeNode,\n+              aliasedNode.getQualifiedName() + name.substring(endIndex)));\n+        }\n+      }\n+\n+      for (Node child = typeNode.getFirstChild(); child != null;\n+           child = child.getNext()) {\n+        fixTypeNode(child);\n       }\n     }\n   }\n--- a/src/com/google/javascript/rhino/JSDocInfo.java\n+++ b/src/com/google/javascript/rhino/JSDocInfo.java\n     }\n     return info.templateTypeName;\n   }\n+\n+  /**\n+   * Returns a collection of all type nodes that are a part of this JSDocInfo.\n+   * This includes @type, @this, @extends, @implements, @param, @throws,\n+   * and @return.  Any future type specific JSDoc should make sure to add the\n+   * appropriate nodes here.\n+   * @return collection of all type nodes\n+   */\n+  public Collection<Node> getTypeNodes() {\n+    List<Node> nodes = Lists.newArrayList();\n+\n+    if (type != null) {\n+      nodes.add(type.getRoot());\n+    }\n+\n+    if (thisType != null) {\n+      nodes.add(thisType.getRoot());\n+    }\n+\n+    if (info != null) {\n+      if (info.baseType != null) {\n+        nodes.add(info.baseType.getRoot());\n+      }\n+\n+      if (info.implementedInterfaces != null) {\n+        for (JSTypeExpression interfaceType : info.implementedInterfaces) {\n+          nodes.add(interfaceType.getRoot());\n+        }\n+      }\n+\n+      if (info.parameters != null) {\n+        for (JSTypeExpression parameterType : info.parameters.values()) {\n+          nodes.add(parameterType.getRoot());\n+        }\n+      }\n+\n+      if (info.thrownTypes != null) {\n+        for (JSTypeExpression thrownType : info.thrownTypes) {\n+          nodes.add(thrownType.getRoot());\n+        }\n+      }\n+    }\n+\n+    return nodes;    \n+  }\n }\n--- a/src/com/google/javascript/rhino/JSTypeExpression.java\n+++ b/src/com/google/javascript/rhino/JSTypeExpression.java\n   public int hashCode() {\n     return root.toStringTree().hashCode();\n   }\n+\n+  Node getRoot() {\n+    return root;\n+  }\n }\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n         sb.append(getString());\n       } else if (type == Token.FUNCTION) {\n         sb.append(' ');\n-        sb.append(first.getString());\n+        // In the case of JsDoc trees, the first child is often not a string\n+        // which causes exceptions to be thrown when calling toString or\n+        // toStringTree.\n+        if (first.getType() == Token.STRING) {\n+          sb.append(first.getString());\n+        }\n       } else if (this instanceof ScriptOrFnNode) {\n         ScriptOrFnNode sof = (ScriptOrFnNode) this;\n         if (this instanceof FunctionNode) {\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n          });\n   }\n \n+  public void testForwardDeclareDroppedTypes() {\n+    args.add(\"--manage_closure_dependencies=true\");\n+\n+    args.add(\"--warning_level=VERBOSE\");\n+    test(new String[] {\n+          \"goog.require('beer');\",\n+          \"goog.provide('beer'); /** @param {Scotch} x */ function f(x) {}\",\n+          \"goog.provide('Scotch'); var x = 3;\"\n+         },\n+         new String[] {\n+           \"var beer = {}; function f() {}\",\n+           \"\"\n+         });\n+\n+    test(new String[] {\n+          \"goog.require('beer');\",\n+          \"goog.provide('beer'); /** @param {Scotch} x */ function f(x) {}\"\n+         },\n+         new String[] {\n+           \"var beer = {}; function f() {}\",\n+           \"\"\n+         },\n+         RhinoErrorReporter.PARSE_ERROR);\n+  }\n+\n   /* Helper functions */\n \n   private void testSame(String original) {\n--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.Lists;\n+import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.Node;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n /**\n  * Tests for {@link ScopedAliases}\n  *\n         \"goog.method();g.method();\");\n   }\n \n-  // TODO(robbyw): Test JsDoc aliasing.\n+  public void testPropertiesNotChanged() {\n+    testScopedNoChanges(\"var x = goog.dom;\", \"y.x();\");\n+  }\n+\n+  private void testTypes(String aliases, String code) {\n+    testScopedNoChanges(aliases, code);\n+    Compiler lastCompiler = getLastCompiler();\n+    new TypeVerifyingPass(lastCompiler).process(lastCompiler.externsRoot,\n+        lastCompiler.jsRoot);\n+  }\n+\n+  public void testJsDocType() {\n+    testTypes(\n+        \"var x = goog.Timer;\",\n+        \"\"\n+        + \"/** @type {x} */ types.actual;\"\n+        + \"/** @type {goog.Timer} */ types.expected;\");\n+  }\n+\n+  public void testJsDocParameter() {\n+    testTypes(\n+        \"var x = goog.Timer;\",\n+        \"\"\n+        + \"/** @param {x} a */ types.actual;\"\n+        + \"/** @param {goog.Timer} a */ types.expected;\");\n+  }\n+\n+  public void testJsDocExtends() {\n+    testTypes(\n+        \"var x = goog.Timer;\",\n+        \"\"\n+        + \"/** @extends {x} */ types.actual;\"\n+        + \"/** @extends {goog.Timer} */ types.expected;\");\n+  }\n+\n+  public void testJsDocImplements() {\n+    testTypes(\n+        \"var x = goog.Timer;\",\n+        \"\"\n+        + \"/** @implements {x} */ types.actual;\"\n+        + \"/** @implements {goog.Timer} */ types.expected;\");\n+  }\n+\n+  public void testJsDocEnum() {\n+    testTypes(\n+        \"var x = goog.Timer;\",\n+        \"\"\n+        + \"/** @enum {x} */ types.actual;\"\n+        + \"/** @enum {goog.Timer} */ types.expected;\");\n+  }\n+\n+  public void testJsDocReturn() {\n+    testTypes(\n+        \"var x = goog.Timer;\",\n+        \"\"\n+        + \"/** @return {x} */ types.actual;\"\n+        + \"/** @return {goog.Timer} */ types.expected;\");\n+  }\n+\n+  public void testJsDocThis() {\n+    testTypes(\n+        \"var x = goog.Timer;\",\n+        \"\"\n+        + \"/** @this {x} */ types.actual;\"\n+        + \"/** @this {goog.Timer} */ types.expected;\");\n+  }\n+\n+  public void testJsDocThrows() {\n+    testTypes(\n+        \"var x = goog.Timer;\",\n+        \"\"\n+        + \"/** @throws {x} */ types.actual;\"\n+        + \"/** @throws {goog.Timer} */ types.expected;\");\n+  }\n+\n+  public void testJsDocSubType() {\n+    testTypes(\n+        \"var x = goog.Timer;\",\n+        \"\"\n+        + \"/** @type {x.Enum} */ types.actual;\"\n+        + \"/** @type {goog.Timer.Enum} */ types.expected;\");\n+  }\n+\n+  public void testJsDocTypedef() {\n+    testTypes(\n+        \"var x = goog.Timer;\",\n+        \"\"\n+        + \"/** @typedef {x} */ types.actual;\"\n+        + \"/** @typedef {goog.Timer} */ types.expected;\");\n+  }\n+\n+  public void testArrayJsDoc() {\n+    testTypes(\n+        \"var x = goog.Timer;\",\n+        \"\"\n+        + \"/** @type {Array.<x>} */ types.actual;\"\n+        + \"/** @type {Array.<goog.Timer>} */ types.expected;\");\n+  }\n+\n+  public void testObjectJsDoc() {\n+    testTypes(\n+        \"var x = goog.Timer;\",\n+        \"\"\n+        + \"/** @type {{someKey: x}} */ types.actual;\"\n+        + \"/** @type {{someKey: goog.Timer}} */ types.expected;\");\n+    testTypes(\n+        \"var x = goog.Timer;\",\n+        \"\"\n+        + \"/** @type {{x: number}} */ types.actual;\"\n+        + \"/** @type {{x: number}} */ types.expected;\");\n+  }\n+\n+  public void testUnionJsDoc() {\n+    testTypes(\n+        \"var x = goog.Timer;\",\n+        \"\"\n+        + \"/** @type {x|Object} */ types.actual;\"\n+        + \"/** @type {goog.Timer|Object} */ types.expected;\");\n+  }\n+\n+  public void testFunctionJsDoc() {\n+    testTypes(\n+        \"var x = goog.Timer;\",\n+        \"\"\n+        + \"/** @type {function(x) : void} */ types.actual;\"\n+        + \"/** @type {function(goog.Timer) : void} */ types.expected;\");\n+    testTypes(\n+        \"var x = goog.Timer;\",\n+        \"\"\n+        + \"/** @type {function() : x} */ types.actual;\"\n+        + \"/** @type {function() : goog.Timer} */ types.expected;\");\n+  }\n+\n+  public void testTestTypes() {\n+    try {\n+      testTypes(\n+          \"var x = goog.Timer;\",\n+          \"\"\n+          + \"/** @type {function() : x} */ types.actual;\"\n+          + \"/** @type {function() : wrong.wrong} */ types.expected;\");\n+      fail(\"Test types should fail here.\");\n+    } catch (AssertionError e) {\n+    }\n+  }\n+\n   // TODO(robbyw): What if it's recursive?  var goog = goog.dom;\n \n   // FAILURE CASES\n   protected ScopedAliases getProcessor(Compiler compiler) {\n     return new ScopedAliases(compiler);\n   }\n+\n+  private static class TypeVerifyingPass\n+      implements CompilerPass, NodeTraversal.Callback {\n+    private final Compiler compiler;\n+    private List<String> actualTypes = null;\n+\n+    public TypeVerifyingPass(Compiler compiler) {\n+      this.compiler = compiler;\n+    }\n+\n+    public void process(Node externs, Node root) {\n+      NodeTraversal.traverse(compiler, root, this);\n+    }\n+\n+    public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n+        Node parent) {\n+      return true;\n+    }\n+\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      JSDocInfo info = n.getJSDocInfo();\n+      if (info != null) {\n+        Collection<Node> typeNodes = info.getTypeNodes();\n+        if (typeNodes.size() > 0) {\n+          if (actualTypes != null) {\n+            List<String> expectedTypes = Lists.newArrayList();\n+            for (Node typeNode : info.getTypeNodes()) {\n+              expectedTypes.add(typeNode.toStringTree());\n+            }\n+            assertEquals(expectedTypes, actualTypes);\n+          } else {\n+            actualTypes = Lists.newArrayList();\n+            for (Node typeNode : info.getTypeNodes()) {\n+              actualTypes.add(typeNode.toStringTree());\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n }\n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n     parse(\"var x = /** @type {void} */ (y);\");\n   }\n \n+  public void testUnfinishedComment() {\n+    parseError(\"/** this is a comment \", \"unterminated comment\");\n+  }\n+\n   public void testParseBlockDescription() {\n     Node n = parse(\"/** This is a variable. */ var x;\");\n     Node var = n.getFirstChild();", "timestamp": 1273628740, "metainfo": ""}