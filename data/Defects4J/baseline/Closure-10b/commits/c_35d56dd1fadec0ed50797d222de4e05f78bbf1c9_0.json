{"sha": "35d56dd1fadec0ed50797d222de4e05f78bbf1c9", "log": "Change on 2010/07/02 17:44:46 by nicksantos          fix RAI when comparing two types that are always equal.         Fixes issue 172          R=acleung         DELTA=20  (19 added, 0 deleted, 1 changed)  Change on 2010/07/03 08:52:08 by johnlenz          Prefer the use of the unsyncronized StringBuilder over StringBuffer. This is just a code style change, this are no uses that should have any performance impact.          R=acleung         DELTA=30  (0 added, 2 deleted, 28 changed)  Change on 2010/07/07 11:56:02 by johnlenz          Reduce the memory cost of generating source maps by reducing the number         of property structure objects that are created.  We do this by taking         advantage of the fact the property list objects are immutable and can be         shared between Nodes.  The source file prop is then shared between         every Node in the AST for a given source file, reducing the the number         of property nodes used to store this information from O(ast-nodes) to         O(source-files).          R=bowdidge         DELTA=122  (68 added, 1 deleted, 53 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=49002   ", "commit": "\n--- a/gen/com/google/javascript/jscomp/FunctionInfo.java\n+++ b/gen/com/google/javascript/jscomp/FunctionInfo.java\n         }, assigner);\n   }\n   \n-  public static void internalForceInit() {}\n-  \n   // @@protoc_insertion_point(outer_class_scope)\n }\n--- a/gen/com/google/javascript/jscomp/FunctionInformationMap.java\n+++ b/gen/com/google/javascript/jscomp/FunctionInformationMap.java\n       compiledSource_ = \"\";\n     }\n     public final boolean isInitialized() {\n-      if (!hasId) return false;\n-      if (!hasSourceName) return false;\n-      if (!hasLineNumber) return false;\n-      if (!hasModuleName) return false;\n-      if (!hasSize) return false;\n-      if (!hasName) return false;\n-      if (!hasCompiledSource) return false;\n+      if (!hasId()) return false;\n+      if (!hasSourceName()) return false;\n+      if (!hasLineNumber()) return false;\n+      if (!hasModuleName()) return false;\n+      if (!hasSize()) return false;\n+      if (!hasName()) return false;\n+      if (!hasCompiledSource()) return false;\n       return true;\n     }\n     \n     }\n     public Builder toBuilder() { return newBuilder(this); }\n     \n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n     public static final class Builder extends\n         com.google.protobuf.GeneratedMessage.Builder<Builder> {\n       public static final com.google.protobuf.Descriptors.Descriptor\n       \n       // Construct using com.google.javascript.jscomp.FunctionInformationMap.Entry.newBuilder()\n       private Builder() {\n-      }\n-      \n+        maybeForceBuilderInitialization();\n+      }\n+      \n+      private Builder(BuilderParent parent) {\n+        super(parent);\n+        maybeForceBuilderInitialization();\n+      }\n+      private void maybeForceBuilderInitialization() {\n+        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {\n+        }\n+      }\n       private static Builder create() {\n         return new Builder();\n       }\n         result.name_ = name_;\n         result.hasCompiledSource = hasCompiledSource;\n         result.compiledSource_ = compiledSource_;\n+        onBuilt();\n         return result;\n       }\n       \n       }\n       \n       public final boolean isInitialized() {\n-        if (!hasId) return false;\n-        if (!hasSourceName) return false;\n-        if (!hasLineNumber) return false;\n-        if (!hasModuleName) return false;\n-        if (!hasSize) return false;\n-        if (!hasName) return false;\n-        if (!hasCompiledSource) return false;\n+        if (!hasId()) return false;\n+        if (!hasSourceName()) return false;\n+        if (!hasLineNumber()) return false;\n+        if (!hasModuleName()) return false;\n+        if (!hasSize()) return false;\n+        if (!hasName()) return false;\n+        if (!hasCompiledSource()) return false;\n         return true;\n       }\n       \n       public Builder setId(int value) {\n         hasId = true;\n         id_ = value;\n+        onChanged();\n         return this;\n       }\n       public Builder clearId() {\n         hasId = false;\n         id_ = 0;\n+        onChanged();\n         return this;\n       }\n       \n   }\n   hasSourceName = true;\n         sourceName_ = value;\n+        onChanged();\n         return this;\n       }\n       public Builder clearSourceName() {\n         hasSourceName = false;\n         sourceName_ = getDefaultInstance().getSourceName();\n+        onChanged();\n         return this;\n       }\n       \n       public Builder setLineNumber(int value) {\n         hasLineNumber = true;\n         lineNumber_ = value;\n+        onChanged();\n         return this;\n       }\n       public Builder clearLineNumber() {\n         hasLineNumber = false;\n         lineNumber_ = 0;\n+        onChanged();\n         return this;\n       }\n       \n   }\n   hasModuleName = true;\n         moduleName_ = value;\n+        onChanged();\n         return this;\n       }\n       public Builder clearModuleName() {\n         hasModuleName = false;\n         moduleName_ = getDefaultInstance().getModuleName();\n+        onChanged();\n         return this;\n       }\n       \n       public Builder setSize(int value) {\n         hasSize = true;\n         size_ = value;\n+        onChanged();\n         return this;\n       }\n       public Builder clearSize() {\n         hasSize = false;\n         size_ = 0;\n+        onChanged();\n         return this;\n       }\n       \n   }\n   hasName = true;\n         name_ = value;\n+        onChanged();\n         return this;\n       }\n       public Builder clearName() {\n         hasName = false;\n         name_ = getDefaultInstance().getName();\n+        onChanged();\n         return this;\n       }\n       \n   }\n   hasCompiledSource = true;\n         compiledSource_ = value;\n+        onChanged();\n         return this;\n       }\n       public Builder clearCompiledSource() {\n         hasCompiledSource = false;\n         compiledSource_ = getDefaultInstance().getCompiledSource();\n+        onChanged();\n         return this;\n       }\n       \n     \n     static {\n       defaultInstance = new Entry(true);\n-      com.google.javascript.jscomp.FunctionInfo.internalForceInit();\n       defaultInstance.initFields();\n     }\n     \n       compiledSource_ = \"\";\n     }\n     public final boolean isInitialized() {\n-      if (!hasName) return false;\n-      if (!hasCompiledSource) return false;\n+      if (!hasName()) return false;\n+      if (!hasCompiledSource()) return false;\n       return true;\n     }\n     \n     }\n     public Builder toBuilder() { return newBuilder(this); }\n     \n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n     public static final class Builder extends\n         com.google.protobuf.GeneratedMessage.Builder<Builder> {\n       public static final com.google.protobuf.Descriptors.Descriptor\n       \n       // Construct using com.google.javascript.jscomp.FunctionInformationMap.Module.newBuilder()\n       private Builder() {\n-      }\n-      \n+        maybeForceBuilderInitialization();\n+      }\n+      \n+      private Builder(BuilderParent parent) {\n+        super(parent);\n+        maybeForceBuilderInitialization();\n+      }\n+      private void maybeForceBuilderInitialization() {\n+        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {\n+        }\n+      }\n       private static Builder create() {\n         return new Builder();\n       }\n         result.name_ = name_;\n         result.hasCompiledSource = hasCompiledSource;\n         result.compiledSource_ = compiledSource_;\n+        onBuilt();\n         return result;\n       }\n       \n       }\n       \n       public final boolean isInitialized() {\n-        if (!hasName) return false;\n-        if (!hasCompiledSource) return false;\n+        if (!hasName()) return false;\n+        if (!hasCompiledSource()) return false;\n         return true;\n       }\n       \n   }\n   hasName = true;\n         name_ = value;\n+        onChanged();\n         return this;\n       }\n       public Builder clearName() {\n         hasName = false;\n         name_ = getDefaultInstance().getName();\n+        onChanged();\n         return this;\n       }\n       \n   }\n   hasCompiledSource = true;\n         compiledSource_ = value;\n+        onChanged();\n         return this;\n       }\n       public Builder clearCompiledSource() {\n         hasCompiledSource = false;\n         compiledSource_ = getDefaultInstance().getCompiledSource();\n+        onChanged();\n         return this;\n       }\n       \n     \n     static {\n       defaultInstance = new Module(true);\n-      com.google.javascript.jscomp.FunctionInfo.internalForceInit();\n       defaultInstance.initFields();\n     }\n     \n   }\n   public Builder toBuilder() { return newBuilder(this); }\n   \n+  @java.lang.Override\n+  protected Builder newBuilderForType(\n+      com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+    Builder builder = new Builder(parent);\n+    return builder;\n+  }\n   public static final class Builder extends\n       com.google.protobuf.GeneratedMessage.Builder<Builder> {\n     public static final com.google.protobuf.Descriptors.Descriptor\n     \n     // Construct using com.google.javascript.jscomp.FunctionInformationMap.newBuilder()\n     private Builder() {\n-    }\n-    \n+      maybeForceBuilderInitialization();\n+    }\n+    \n+    private Builder(BuilderParent parent) {\n+      super(parent);\n+      maybeForceBuilderInitialization();\n+    }\n+    private void maybeForceBuilderInitialization() {\n+      if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {\n+        getEntryFieldBuilder();\n+        getModuleFieldBuilder();\n+      }\n+    }\n     private static Builder create() {\n       return new Builder();\n     }\n     \n     public Builder clear() {\n       super.clear();\n-      entry_ = java.util.Collections.emptyList();\n-      isEntryMutable = false;\n-      module_ = java.util.Collections.emptyList();\n-      isModuleMutable = false;\n+      if (entryBuilder_ == null) {\n+        entry_ = java.util.Collections.emptyList();\n+        isEntryMutable = false;\n+      } else {\n+        entryBuilder_.clear();\n+      }\n+      if (moduleBuilder_ == null) {\n+        module_ = java.util.Collections.emptyList();\n+        isModuleMutable = false;\n+      } else {\n+        moduleBuilder_.clear();\n+      }\n       return this;\n     }\n     \n     \n     public com.google.javascript.jscomp.FunctionInformationMap buildPartial() {\n       com.google.javascript.jscomp.FunctionInformationMap result = new com.google.javascript.jscomp.FunctionInformationMap(this);\n-      if (isEntryMutable) {\n-        entry_ = java.util.Collections.unmodifiableList(entry_);\n-        isEntryMutable = false;\n-      }\n-      result.entry_ = entry_;\n-      if (isModuleMutable) {\n-        module_ = java.util.Collections.unmodifiableList(module_);\n-        isModuleMutable = false;\n-      }\n-      result.module_ = module_;\n+      if (entryBuilder_ == null) {\n+        if (isEntryMutable) {\n+          entry_ = java.util.Collections.unmodifiableList(entry_);\n+          isEntryMutable = false;\n+        }\n+        result.entry_ = entry_;\n+      } else {\n+        result.entry_ = entryBuilder_.build();\n+      }\n+      if (moduleBuilder_ == null) {\n+        if (isModuleMutable) {\n+          module_ = java.util.Collections.unmodifiableList(module_);\n+          isModuleMutable = false;\n+        }\n+        result.module_ = module_;\n+      } else {\n+        result.module_ = moduleBuilder_.build();\n+      }\n+      onBuilt();\n       return result;\n     }\n     \n     \n     public Builder mergeFrom(com.google.javascript.jscomp.FunctionInformationMap other) {\n       if (other == com.google.javascript.jscomp.FunctionInformationMap.getDefaultInstance()) return this;\n-      if (!other.entry_.isEmpty()) {\n-        if (entry_.isEmpty()) {\n-          entry_ = other.entry_;\n-          isEntryMutable = false;\n-        } else {\n-          ensureEntryIsMutable();\n-          entry_.addAll(other.entry_);\n-        }\n-      }\n-      if (!other.module_.isEmpty()) {\n-        if (module_.isEmpty()) {\n-          module_ = other.module_;\n-          isModuleMutable = false;\n-        } else {\n-          ensureModuleIsMutable();\n-          module_.addAll(other.module_);\n+      if (entryBuilder_ == null) {\n+        if (!other.entry_.isEmpty()) {\n+          if (entry_.isEmpty()) {\n+            entry_ = other.entry_;\n+            isEntryMutable = false;\n+          } else {\n+            ensureEntryIsMutable();\n+            entry_.addAll(other.entry_);\n+          }\n+          onChanged();\n+        }\n+      } else {\n+        if (!other.entry_.isEmpty()) {\n+          if (entryBuilder_.isEmpty()) {\n+            entryBuilder_.dispose();\n+            entryBuilder_ = null;\n+            entry_ = other.entry_;\n+            isEntryMutable = false;\n+            entryBuilder_ = \n+              com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                 getEntryFieldBuilder() : null;\n+          } else {\n+            entryBuilder_.addAllMessages(other.entry_);\n+          }\n+        }\n+      }\n+      if (moduleBuilder_ == null) {\n+        if (!other.module_.isEmpty()) {\n+          if (module_.isEmpty()) {\n+            module_ = other.module_;\n+            isModuleMutable = false;\n+          } else {\n+            ensureModuleIsMutable();\n+            module_.addAll(other.module_);\n+          }\n+          onChanged();\n+        }\n+      } else {\n+        if (!other.module_.isEmpty()) {\n+          if (moduleBuilder_.isEmpty()) {\n+            moduleBuilder_.dispose();\n+            moduleBuilder_ = null;\n+            module_ = other.module_;\n+            isModuleMutable = false;\n+            moduleBuilder_ = \n+              com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                 getModuleFieldBuilder() : null;\n+          } else {\n+            moduleBuilder_.addAllMessages(other.module_);\n+          }\n         }\n       }\n       this.mergeUnknownFields(other.getUnknownFields());\n         isEntryMutable = true;\n        }\n     }\n+    \n+    private com.google.protobuf.RepeatedFieldBuilder<\n+        com.google.javascript.jscomp.FunctionInformationMap.Entry, com.google.javascript.jscomp.FunctionInformationMap.Entry.Builder> entryBuilder_;\n+    \n     public java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Entry> getEntryList() {\n-      return java.util.Collections.unmodifiableList(entry_);\n+      if (entryBuilder_ == null) {\n+        return java.util.Collections.unmodifiableList(entry_);\n+      } else {\n+        return entryBuilder_.getMessageList();\n+      }\n     }\n     public int getEntryCount() {\n-      return entry_.size();\n+      if (entryBuilder_ == null) {\n+        return entry_.size();\n+      } else {\n+        return entryBuilder_.getCount();\n+      }\n     }\n     public com.google.javascript.jscomp.FunctionInformationMap.Entry getEntry(int index) {\n-      return entry_.get(index);\n+      if (entryBuilder_ == null) {\n+        return entry_.get(index);\n+      } else {\n+        return entryBuilder_.getMessage(index);\n+      }\n     }\n     public Builder setEntry(\n         int index, com.google.javascript.jscomp.FunctionInformationMap.Entry value) {\n-      if (value == null) {\n-        throw new NullPointerException();\n-      }\n-      ensureEntryIsMutable();\n-      entry_.set(index, value);\n+      if (entryBuilder_ == null) {\n+        if (value == null) {\n+          throw new NullPointerException();\n+        }\n+        ensureEntryIsMutable();\n+        entry_.set(index, value);\n+        onChanged();\n+      } else {\n+        entryBuilder_.setMessage(index, value);\n+      }\n       return this;\n     }\n     public Builder setEntry(\n         int index, com.google.javascript.jscomp.FunctionInformationMap.Entry.Builder builderForValue) {\n-      ensureEntryIsMutable();\n-      entry_.set(index, builderForValue.build());\n+      if (entryBuilder_ == null) {\n+        ensureEntryIsMutable();\n+        entry_.set(index, builderForValue.build());\n+        onChanged();\n+      } else {\n+        entryBuilder_.setMessage(index, builderForValue.build());\n+      }\n       return this;\n     }\n     public Builder addEntry(com.google.javascript.jscomp.FunctionInformationMap.Entry value) {\n-      if (value == null) {\n-        throw new NullPointerException();\n-      }\n-      ensureEntryIsMutable();\n-      entry_.add(value);\n+      if (entryBuilder_ == null) {\n+        if (value == null) {\n+          throw new NullPointerException();\n+        }\n+        ensureEntryIsMutable();\n+        entry_.add(value);\n+        onChanged();\n+      } else {\n+        entryBuilder_.addMessage(value);\n+      }\n+      return this;\n+    }\n+    public Builder addEntry(\n+        int index, com.google.javascript.jscomp.FunctionInformationMap.Entry value) {\n+      if (entryBuilder_ == null) {\n+        if (value == null) {\n+          throw new NullPointerException();\n+        }\n+        ensureEntryIsMutable();\n+        entry_.add(index, value);\n+        onChanged();\n+      } else {\n+        entryBuilder_.addMessage(index, value);\n+      }\n       return this;\n     }\n     public Builder addEntry(\n         com.google.javascript.jscomp.FunctionInformationMap.Entry.Builder builderForValue) {\n-      ensureEntryIsMutable();\n-      entry_.add(builderForValue.build());\n+      if (entryBuilder_ == null) {\n+        ensureEntryIsMutable();\n+        entry_.add(builderForValue.build());\n+        onChanged();\n+      } else {\n+        entryBuilder_.addMessage(builderForValue.build());\n+      }\n+      return this;\n+    }\n+    public Builder addEntry(\n+        int index, com.google.javascript.jscomp.FunctionInformationMap.Entry.Builder builderForValue) {\n+      if (entryBuilder_ == null) {\n+        ensureEntryIsMutable();\n+        entry_.add(index, builderForValue.build());\n+        onChanged();\n+      } else {\n+        entryBuilder_.addMessage(index, builderForValue.build());\n+      }\n       return this;\n     }\n     public Builder addAllEntry(\n         java.lang.Iterable<? extends com.google.javascript.jscomp.FunctionInformationMap.Entry> values) {\n-      ensureEntryIsMutable();\n-      super.addAll(values, entry_);\n+      if (entryBuilder_ == null) {\n+        ensureEntryIsMutable();\n+        super.addAll(values, entry_);\n+        onChanged();\n+      } else {\n+        entryBuilder_.addAllMessages(values);\n+      }\n       return this;\n     }\n     public Builder clearEntry() {\n-      entry_ = java.util.Collections.emptyList();\n-      isEntryMutable = false;\n-      return this;\n+      if (entryBuilder_ == null) {\n+        entry_ = java.util.Collections.emptyList();\n+        isEntryMutable = false;\n+        onChanged();\n+      } else {\n+        entryBuilder_.clear();\n+      }\n+      return this;\n+    }\n+    public Builder removeEntry(int index) {\n+      if (entryBuilder_ == null) {\n+        ensureEntryIsMutable();\n+        entry_.remove(index);\n+        onChanged();\n+      } else {\n+        entryBuilder_.remove(index);\n+      }\n+      return this;\n+    }\n+    public com.google.javascript.jscomp.FunctionInformationMap.Entry.Builder getEntryBuilder(\n+        int index) {\n+      return getEntryFieldBuilder().getBuilder(index);\n+    }\n+    public com.google.javascript.jscomp.FunctionInformationMap.Entry.Builder addEntryBuilder() {\n+      return getEntryFieldBuilder().addBuilder(\n+          com.google.javascript.jscomp.FunctionInformationMap.Entry.getDefaultInstance());\n+    }\n+    public com.google.javascript.jscomp.FunctionInformationMap.Entry.Builder addEntryBuilder(\n+        int index) {\n+      return getEntryFieldBuilder().addBuilder(\n+          index, com.google.javascript.jscomp.FunctionInformationMap.Entry.getDefaultInstance());\n+    }\n+    public java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Entry.Builder> \n+         getEntryBuilderList() {\n+      return getEntryFieldBuilder().getBuilderList();\n+    }\n+    private com.google.protobuf.RepeatedFieldBuilder<\n+        com.google.javascript.jscomp.FunctionInformationMap.Entry, com.google.javascript.jscomp.FunctionInformationMap.Entry.Builder> getEntryFieldBuilder() {\n+      if (entryBuilder_ == null) {\n+        entryBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+            com.google.javascript.jscomp.FunctionInformationMap.Entry, com.google.javascript.jscomp.FunctionInformationMap.Entry.Builder>(\n+                entry_,\n+                isEntryMutable,\n+                getParentForChildren(),\n+                isClean());\n+        entry_ = null;\n+      }\n+      return entryBuilder_;\n     }\n     \n     // repeated group Module = 101 {\n         isModuleMutable = true;\n        }\n     }\n+    \n+    private com.google.protobuf.RepeatedFieldBuilder<\n+        com.google.javascript.jscomp.FunctionInformationMap.Module, com.google.javascript.jscomp.FunctionInformationMap.Module.Builder> moduleBuilder_;\n+    \n     public java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Module> getModuleList() {\n-      return java.util.Collections.unmodifiableList(module_);\n+      if (moduleBuilder_ == null) {\n+        return java.util.Collections.unmodifiableList(module_);\n+      } else {\n+        return moduleBuilder_.getMessageList();\n+      }\n     }\n     public int getModuleCount() {\n-      return module_.size();\n+      if (moduleBuilder_ == null) {\n+        return module_.size();\n+      } else {\n+        return moduleBuilder_.getCount();\n+      }\n     }\n     public com.google.javascript.jscomp.FunctionInformationMap.Module getModule(int index) {\n-      return module_.get(index);\n+      if (moduleBuilder_ == null) {\n+        return module_.get(index);\n+      } else {\n+        return moduleBuilder_.getMessage(index);\n+      }\n     }\n     public Builder setModule(\n         int index, com.google.javascript.jscomp.FunctionInformationMap.Module value) {\n-      if (value == null) {\n-        throw new NullPointerException();\n-      }\n-      ensureModuleIsMutable();\n-      module_.set(index, value);\n+      if (moduleBuilder_ == null) {\n+        if (value == null) {\n+          throw new NullPointerException();\n+        }\n+        ensureModuleIsMutable();\n+        module_.set(index, value);\n+        onChanged();\n+      } else {\n+        moduleBuilder_.setMessage(index, value);\n+      }\n       return this;\n     }\n     public Builder setModule(\n         int index, com.google.javascript.jscomp.FunctionInformationMap.Module.Builder builderForValue) {\n-      ensureModuleIsMutable();\n-      module_.set(index, builderForValue.build());\n+      if (moduleBuilder_ == null) {\n+        ensureModuleIsMutable();\n+        module_.set(index, builderForValue.build());\n+        onChanged();\n+      } else {\n+        moduleBuilder_.setMessage(index, builderForValue.build());\n+      }\n       return this;\n     }\n     public Builder addModule(com.google.javascript.jscomp.FunctionInformationMap.Module value) {\n-      if (value == null) {\n-        throw new NullPointerException();\n-      }\n-      ensureModuleIsMutable();\n-      module_.add(value);\n+      if (moduleBuilder_ == null) {\n+        if (value == null) {\n+          throw new NullPointerException();\n+        }\n+        ensureModuleIsMutable();\n+        module_.add(value);\n+        onChanged();\n+      } else {\n+        moduleBuilder_.addMessage(value);\n+      }\n+      return this;\n+    }\n+    public Builder addModule(\n+        int index, com.google.javascript.jscomp.FunctionInformationMap.Module value) {\n+      if (moduleBuilder_ == null) {\n+        if (value == null) {\n+          throw new NullPointerException();\n+        }\n+        ensureModuleIsMutable();\n+        module_.add(index, value);\n+        onChanged();\n+      } else {\n+        moduleBuilder_.addMessage(index, value);\n+      }\n       return this;\n     }\n     public Builder addModule(\n         com.google.javascript.jscomp.FunctionInformationMap.Module.Builder builderForValue) {\n-      ensureModuleIsMutable();\n-      module_.add(builderForValue.build());\n+      if (moduleBuilder_ == null) {\n+        ensureModuleIsMutable();\n+        module_.add(builderForValue.build());\n+        onChanged();\n+      } else {\n+        moduleBuilder_.addMessage(builderForValue.build());\n+      }\n+      return this;\n+    }\n+    public Builder addModule(\n+        int index, com.google.javascript.jscomp.FunctionInformationMap.Module.Builder builderForValue) {\n+      if (moduleBuilder_ == null) {\n+        ensureModuleIsMutable();\n+        module_.add(index, builderForValue.build());\n+        onChanged();\n+      } else {\n+        moduleBuilder_.addMessage(index, builderForValue.build());\n+      }\n       return this;\n     }\n     public Builder addAllModule(\n         java.lang.Iterable<? extends com.google.javascript.jscomp.FunctionInformationMap.Module> values) {\n-      ensureModuleIsMutable();\n-      super.addAll(values, module_);\n+      if (moduleBuilder_ == null) {\n+        ensureModuleIsMutable();\n+        super.addAll(values, module_);\n+        onChanged();\n+      } else {\n+        moduleBuilder_.addAllMessages(values);\n+      }\n       return this;\n     }\n     public Builder clearModule() {\n-      module_ = java.util.Collections.emptyList();\n-      isModuleMutable = false;\n-      return this;\n+      if (moduleBuilder_ == null) {\n+        module_ = java.util.Collections.emptyList();\n+        isModuleMutable = false;\n+        onChanged();\n+      } else {\n+        moduleBuilder_.clear();\n+      }\n+      return this;\n+    }\n+    public Builder removeModule(int index) {\n+      if (moduleBuilder_ == null) {\n+        ensureModuleIsMutable();\n+        module_.remove(index);\n+        onChanged();\n+      } else {\n+        moduleBuilder_.remove(index);\n+      }\n+      return this;\n+    }\n+    public com.google.javascript.jscomp.FunctionInformationMap.Module.Builder getModuleBuilder(\n+        int index) {\n+      return getModuleFieldBuilder().getBuilder(index);\n+    }\n+    public com.google.javascript.jscomp.FunctionInformationMap.Module.Builder addModuleBuilder() {\n+      return getModuleFieldBuilder().addBuilder(\n+          com.google.javascript.jscomp.FunctionInformationMap.Module.getDefaultInstance());\n+    }\n+    public com.google.javascript.jscomp.FunctionInformationMap.Module.Builder addModuleBuilder(\n+        int index) {\n+      return getModuleFieldBuilder().addBuilder(\n+          index, com.google.javascript.jscomp.FunctionInformationMap.Module.getDefaultInstance());\n+    }\n+    public java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Module.Builder> \n+         getModuleBuilderList() {\n+      return getModuleFieldBuilder().getBuilderList();\n+    }\n+    private com.google.protobuf.RepeatedFieldBuilder<\n+        com.google.javascript.jscomp.FunctionInformationMap.Module, com.google.javascript.jscomp.FunctionInformationMap.Module.Builder> getModuleFieldBuilder() {\n+      if (moduleBuilder_ == null) {\n+        moduleBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+            com.google.javascript.jscomp.FunctionInformationMap.Module, com.google.javascript.jscomp.FunctionInformationMap.Module.Builder>(\n+                module_,\n+                isModuleMutable,\n+                getParentForChildren(),\n+                isClean());\n+        module_ = null;\n+      }\n+      return moduleBuilder_;\n     }\n     \n     // @@protoc_insertion_point(builder_scope:jscomp.FunctionInformationMap)\n   \n   static {\n     defaultInstance = new FunctionInformationMap(true);\n-    com.google.javascript.jscomp.FunctionInfo.internalForceInit();\n     defaultInstance.initFields();\n   }\n   \n--- a/gen/com/google/javascript/jscomp/Instrumentation.java\n+++ b/gen/com/google/javascript/jscomp/Instrumentation.java\n   }\n   public Builder toBuilder() { return newBuilder(this); }\n   \n+  @java.lang.Override\n+  protected Builder newBuilderForType(\n+      com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+    Builder builder = new Builder(parent);\n+    return builder;\n+  }\n   public static final class Builder extends\n       com.google.protobuf.GeneratedMessage.Builder<Builder> {\n     public static final com.google.protobuf.Descriptors.Descriptor\n     \n     // Construct using com.google.javascript.jscomp.Instrumentation.newBuilder()\n     private Builder() {\n-    }\n-    \n+      maybeForceBuilderInitialization();\n+    }\n+    \n+    private Builder(BuilderParent parent) {\n+      super(parent);\n+      maybeForceBuilderInitialization();\n+    }\n+    private void maybeForceBuilderInitialization() {\n+      if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {\n+      }\n+    }\n     private static Builder create() {\n       return new Builder();\n     }\n       result.init_ = init_;\n       result.hasAppNameSetter = hasAppNameSetter;\n       result.appNameSetter_ = appNameSetter_;\n+      onBuilt();\n       return result;\n     }\n     \n           ensureDeclarationToRemoveIsMutable();\n           declarationToRemove_.addAll(other.declarationToRemove_);\n         }\n+        onChanged();\n       }\n       if (!other.init_.isEmpty()) {\n         if (init_.isEmpty()) {\n           ensureInitIsMutable();\n           init_.addAll(other.init_);\n         }\n+        onChanged();\n       }\n       if (other.hasAppNameSetter()) {\n         setAppNameSetter(other.getAppNameSetter());\n   }\n   hasReportDefined = true;\n       reportDefined_ = value;\n+      onChanged();\n       return this;\n     }\n     public Builder clearReportDefined() {\n       hasReportDefined = false;\n       reportDefined_ = getDefaultInstance().getReportDefined();\n+      onChanged();\n       return this;\n     }\n     \n   }\n   hasReportCall = true;\n       reportCall_ = value;\n+      onChanged();\n       return this;\n     }\n     public Builder clearReportCall() {\n       hasReportCall = false;\n       reportCall_ = getDefaultInstance().getReportCall();\n+      onChanged();\n       return this;\n     }\n     \n   }\n   hasReportExit = true;\n       reportExit_ = value;\n+      onChanged();\n       return this;\n     }\n     public Builder clearReportExit() {\n       hasReportExit = false;\n       reportExit_ = getDefaultInstance().getReportExit();\n+      onChanged();\n       return this;\n     }\n     \n   }\n   ensureDeclarationToRemoveIsMutable();\n       declarationToRemove_.set(index, value);\n+      onChanged();\n       return this;\n     }\n     public Builder addDeclarationToRemove(java.lang.String value) {\n   }\n   ensureDeclarationToRemoveIsMutable();\n       declarationToRemove_.add(value);\n+      onChanged();\n       return this;\n     }\n     public Builder addAllDeclarationToRemove(\n         java.lang.Iterable<? extends java.lang.String> values) {\n       ensureDeclarationToRemoveIsMutable();\n       super.addAll(values, declarationToRemove_);\n+      onChanged();\n       return this;\n     }\n     public Builder clearDeclarationToRemove() {\n       declarationToRemove_ = java.util.Collections.emptyList();\n       isDeclarationToRemoveMutable = false;\n+      onChanged();\n       return this;\n     }\n     \n   }\n   ensureInitIsMutable();\n       init_.set(index, value);\n+      onChanged();\n       return this;\n     }\n     public Builder addInit(java.lang.String value) {\n   }\n   ensureInitIsMutable();\n       init_.add(value);\n+      onChanged();\n       return this;\n     }\n     public Builder addAllInit(\n         java.lang.Iterable<? extends java.lang.String> values) {\n       ensureInitIsMutable();\n       super.addAll(values, init_);\n+      onChanged();\n       return this;\n     }\n     public Builder clearInit() {\n       init_ = java.util.Collections.emptyList();\n       isInitMutable = false;\n+      onChanged();\n       return this;\n     }\n     \n   }\n   hasAppNameSetter = true;\n       appNameSetter_ = value;\n+      onChanged();\n       return this;\n     }\n     public Builder clearAppNameSetter() {\n       hasAppNameSetter = false;\n       appNameSetter_ = getDefaultInstance().getAppNameSetter();\n+      onChanged();\n       return this;\n     }\n     \n   \n   static {\n     defaultInstance = new Instrumentation(true);\n-    com.google.javascript.jscomp.InstrumentationTemplate.internalForceInit();\n     defaultInstance.initFields();\n   }\n   \n--- a/gen/com/google/javascript/jscomp/InstrumentationTemplate.java\n+++ b/gen/com/google/javascript/jscomp/InstrumentationTemplate.java\n         }, assigner);\n   }\n   \n-  public static void internalForceInit() {}\n-  \n   // @@protoc_insertion_point(outer_class_scope)\n }\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n           // Annotate the nodes in the tree with information from the\n           // input file. This information is used to construct the SourceMap.\n           SourceInformationAnnotator sia =\n-              new SourceInformationAnnotator(input.getName());\n+              new SourceInformationAnnotator(\n+                  input.getName(), options.devMode != DevMode.OFF);\n           NodeTraversal.traverse(this, n, sia);\n         }\n \n--- a/src/com/google/javascript/jscomp/ExportTestFunctions.java\n+++ b/src/com/google/javascript/jscomp/ExportTestFunctions.java\n           String functionName = NodeUtil.getFunctionName(functionNode);\n           if (isTestFunction(functionNode, functionName)) {\n             exportTestFunction(functionName, n, parent);\n-          }          \n+          }\n         }\n       }\n     }\n-    \n+\n     /**\n      * Whether node corresponds to a function expression declared with var,\n      * which is of the form:\n--- a/src/com/google/javascript/jscomp/SourceInformationAnnotator.java\n+++ b/src/com/google/javascript/jscomp/SourceInformationAnnotator.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n  */\n class SourceInformationAnnotator extends\n   NodeTraversal.AbstractPostOrderCallback {\n-  private String sourceFile = null;\n+  private final String sourceFile;\n+  private final boolean doSanityChecks;\n \n-  public SourceInformationAnnotator(String sourceFile) {\n+  public SourceInformationAnnotator(\n+      String sourceFile, boolean doSanityChecks) {\n     this.sourceFile = sourceFile;\n+    this.doSanityChecks = doSanityChecks;\n   }\n \n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n-    // Annotate with the source file.\n-    if (sourceFile != null) {\n-      n.putProp(Node.SOURCEFILE_PROP, sourceFile);\n+    // Verify the source file is annotated.\n+    if (doSanityChecks && sourceFile != null) {\n+      Preconditions.checkState(sourceFile.equals(\n+          n.getProp(Node.SOURCEFILE_PROP)));\n     }\n \n     // Annotate the original name.\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n   private final Multimap<String, NodeWithJsDoc> nodesWithJsDoc =\n       LinkedHashMultimap.create();\n \n+  // Use a template node for properties set on all nodes to minimize the\n+  // memory footprint associated with these.\n+  private Node templateNode;\n+\n+  // TODO(johnlenz): Consider creating a template pool for ORIGINALNAME_PROP.\n+\n   private IRFactory(String sourceString,\n                     String sourceName,\n                     Config config,\n     this.config = config;\n     this.errorReporter = errorReporter;\n     this.transformDispatcher = new TransformDispatcher();\n+    // The template node properties are applied to all nodes in this transform.\n+    this.templateNode = createTemplateNode();\n+  }\n+\n+  // Create a template node to use as a source of common attributes, this allows\n+  // the prop structure to be shared among all the node from this source file.\n+  // This reduces the cost of these properties to O(nodes) to O(files).\n+  private Node createTemplateNode() {\n+    // The Node type choice is arbitrary.\n+    Node templateNode = new Node(Token.SCRIPT);\n+    templateNode.putProp(Node.SOURCEFILE_PROP, sourceName);\n+    return templateNode;\n   }\n \n   public static Node transformTree(AstRoot node,\n         irNode.setType(Token.BLOCK);\n         irNode.setWasEmptyNode(true);\n       } else {\n-        Node newBlock = new Node(Token.BLOCK, irNode,\n-            irNode.getLineno(), irNode.getCharno());\n+        Node newBlock = newNode(Token.BLOCK, irNode);\n+        newBlock.setLineno(irNode.getLineno());\n+        newBlock.setCharno(irNode.getCharno());\n         irNode = newBlock;\n       }\n     }\n   private class TransformDispatcher extends TypeSafeDispatcher<Node> {\n     private Node processGeneric(\n         com.google.javascript.jscomp.mozilla.rhino.Node n) {\n-      Node node = new Node(transformTokenType(n.getType()));\n+      Node node = newNode(transformTokenType(n.getType()));\n       for (com.google.javascript.jscomp.mozilla.rhino.Node child : n) {\n         node.addChildToBack(transform((AstNode)child));\n       }\n         reportDestructuringAssign(literalNode);\n       }\n \n-      Node node = new Node(Token.ARRAYLIT);\n+      Node node = newNode(Token.ARRAYLIT);\n       int skipCount = 0;\n       for (AstNode child : literalNode.getElements()) {\n         Node c = transform(child);\n \n     @Override\n     Node processAstRoot(AstRoot rootNode) {\n-      Node node = new Node(Token.SCRIPT);\n+      Node node = newNode(Token.SCRIPT);\n       for (com.google.javascript.jscomp.mozilla.rhino.Node child : rootNode) {\n         node.addChildToBack(transform((AstNode)child));\n       }\n \n     @Override\n     Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = new Node(Token.BREAK);\n+      Node node = newNode(Token.BREAK);\n       if (statementNode.getBreakLabel() != null) {\n         Node labelName = transform(statementNode.getBreakLabel());\n         // Change the NAME to LABEL_NAME\n     @Override\n     Node processCatchClause(CatchClause clauseNode) {\n       AstNode catchVar = clauseNode.getVarName();\n-      Node node = new Node(Token.CATCH, transform(catchVar));\n+      Node node = newNode(Token.CATCH, transform(catchVar));\n       if (clauseNode.getCatchCondition() != null) {\n         node.addChildToBack(transform(clauseNode.getCatchCondition()));\n       } else {\n-        Node catchCondition = new Node(Token.EMPTY);\n+        Node catchCondition = newNode(Token.EMPTY);\n         // Old Rhino used the position of the catchVar as the position\n         // for the (nonexistent) error being caught.\n         catchCondition.setLineno(catchVar.getLineno());\n \n     @Override\n     Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return new Node(\n+      return newNode(\n           Token.HOOK,\n           transform(exprNode.getTestExpression()),\n           transform(exprNode.getTrueExpression()),\n \n     @Override\n     Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = new Node(Token.CONTINUE);\n+      Node node = newNode(Token.CONTINUE);\n       if (statementNode.getLabel() != null) {\n         Node labelName = transform(statementNode.getLabel());\n         // Change the NAME to LABEL_NAME\n \n     @Override\n     Node processDoLoop(DoLoop loopNode) {\n-      return new Node(\n+      return newNode(\n           Token.DO,\n           transformBlock(loopNode.getBody()),\n           transform(loopNode.getCondition()));\n \n     @Override\n     Node processElementGet(ElementGet getNode) {\n-      return new Node(\n+      return newNode(\n           Token.GETELEM,\n           transform(getNode.getTarget()),\n           transform(getNode.getElement()));\n \n     @Override\n     Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = new Node(Token.EMPTY);\n+      Node node = newNode(Token.EMPTY);\n       return node;\n     }\n \n     @Override\n     Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = new Node(transformTokenType(statementNode.getType()));\n+      Node node = newNode(transformTokenType(statementNode.getType()));\n       node.addChildToBack(transform(statementNode.getExpression()));\n       return node;\n     }\n \n     @Override\n     Node processForInLoop(ForInLoop loopNode) {\n-      return new Node(\n+      return newNode(\n           Token.FOR,\n           transform(loopNode.getIterator()),\n           transform(loopNode.getIteratedObject()),\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {\n-      Node node = new Node(\n+      Node node = newNode(\n           Token.FOR,\n           transform(loopNode.getInitializer()),\n           transform(loopNode.getCondition()),\n \n     @Override\n     Node processFunctionCall(FunctionCall callNode) {\n-      Node node = new Node(transformTokenType(callNode.getType()),\n+      Node node = newNode(transformTokenType(callNode.getType()),\n                            transform(callNode.getTarget()));\n       for (AstNode child : callNode.getArguments()) {\n         node.addChildToBack(transform(child));\n         name.setIdentifier(\"\");\n         isUnnamedFunction = true;\n       }\n-      Node node = new Node(Token.FUNCTION);\n+      Node node = newNode(Token.FUNCTION);\n       node.putProp(Node.SOURCENAME_PROP, functionNode.getSourceName());\n       Node newName = transform(name);\n       if (isUnnamedFunction) {\n       }\n \n       node.addChildToBack(newName);\n-      Node lp = new Node(Token.LP);\n+      Node lp = newNode(Token.LP);\n       // The left paren's complicated because it's not represented by an\n       // AstNode, so there's nothing that has the actual line number that it\n       // appeared on.  We know the paren has to appear on the same line as the\n \n     @Override\n     Node processIfStatement(IfStatement statementNode) {\n-      Node node = new Node(Token.IF);\n+      Node node = newNode(Token.IF);\n       node.addChildToBack(transform(statementNode.getCondition()));\n       node.addChildToBack(transformBlock(statementNode.getThenPart()));\n       if (statementNode.getElsePart() != null) {\n \n     @Override\n     Node processInfixExpression(InfixExpression exprNode) {\n-      Node n =  new Node(\n+      Node n =  newNode(\n           transformTokenType(exprNode.getType()),\n           transform(exprNode.getLeft()),\n           transform(exprNode.getRight()));\n \n     @Override\n     Node processKeywordLiteral(KeywordLiteral literalNode) {\n-      return new Node(transformTokenType(literalNode.getType()));\n+      return newNode(transformTokenType(literalNode.getType()));\n     }\n \n     @Override\n     Node processLabel(Label labelNode) {\n-      return Node.newString(Token.LABEL_NAME, labelNode.getName());\n+      return newStringNode(Token.LABEL_NAME, labelNode.getName());\n     }\n \n     @Override\n     Node processLabeledStatement(LabeledStatement statementNode) {\n-      Node node = new Node(Token.LABEL);\n+      Node node = newNode(Token.LABEL);\n       Node prev = null;\n       Node cur = node;\n       for (Label label : statementNode.getLabels()) {\n         cur.setCharno(clauseAbsolutePosition);\n \n         prev = cur;\n-        cur = new Node(Token.LABEL);\n+        cur = newNode(Token.LABEL);\n       }\n       prev.addChildToBack(transform(statementNode.getStatement()));\n       return node;\n \n     @Override\n     Node processName(Name nameNode) {\n-      return Node.newString(Token.NAME, nameNode.getIdentifier());\n+      return newStringNode(Token.NAME, nameNode.getIdentifier());\n     }\n \n     @Override\n \n     @Override\n     Node processNumberLiteral(NumberLiteral literalNode) {\n-      Node newNode = Node.newNumber(literalNode.getNumber());\n-      return newNode;\n+      return newNumberNode(literalNode.getNumber());\n     }\n \n     @Override\n         reportDestructuringAssign(literalNode);\n       }\n \n-      Node node = new Node(Token.OBJECTLIT);\n+      Node node = newNode(Token.OBJECTLIT);\n       for (ObjectProperty el : literalNode.getElements()) {\n         if (el.isGetter()) {\n           reportGetter(el);\n \n     @Override\n     Node processPropertyGet(PropertyGet getNode) {\n-      return new Node(\n+      return newNode(\n           Token.GETPROP,\n           transform(getNode.getTarget()),\n           transformAsString(getNode.getProperty()));\n \n     @Override\n     Node processRegExpLiteral(RegExpLiteral literalNode) {\n-      Node literalStringNode = Node.newString(literalNode.getValue());\n+      Node literalStringNode = newStringNode(literalNode.getValue());\n       // assume it's on the same line.\n       literalStringNode.setLineno(literalNode.getLineno());\n-      Node node = new Node(Token.REGEXP, literalStringNode);\n+      Node node = newNode(Token.REGEXP, literalStringNode);\n       String flags = literalNode.getFlags();\n       if (flags != null && !flags.isEmpty()) {\n-        Node flagsNode = Node.newString(flags);\n+        Node flagsNode = newStringNode(flags);\n         // Assume the flags are on the same line as the literal node.\n         flagsNode.setLineno(literalNode.getLineno());\n         node.addChildToBack(flagsNode);\n \n     @Override\n     Node processReturnStatement(ReturnStatement statementNode) {\n-      Node node = new Node(Token.RETURN);\n+      Node node = newNode(Token.RETURN);\n       if (statementNode.getReturnValue() != null) {\n         node.addChildToBack(transform(statementNode.getReturnValue()));\n       }\n \n     @Override\n     Node processStringLiteral(StringLiteral literalNode) {\n-      Node n = Node.newString(literalNode.getValue());\n+      Node n = newStringNode(literalNode.getValue());\n       return n;\n     }\n \n     Node processSwitchCase(SwitchCase caseNode) {\n       Node node;\n       if (caseNode.isDefault()) {\n-        node = new Node(Token.DEFAULT);\n+        node = newNode(Token.DEFAULT);\n       } else {\n         AstNode expr = caseNode.getExpression();\n-        node = new Node(Token.CASE, transform(expr));\n-      }\n-      Node block = new Node(Token.BLOCK);\n+        node = newNode(Token.CASE, transform(expr));\n+      }\n+      Node block = newNode(Token.BLOCK);\n       block.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n       block.setLineno(caseNode.getLineno());\n       block.setCharno(position2charno(caseNode.getAbsolutePosition()));\n \n     @Override\n     Node processSwitchStatement(SwitchStatement statementNode) {\n-      Node node = new Node(Token.SWITCH,\n+      Node node = newNode(Token.SWITCH,\n           transform(statementNode.getExpression()));\n       for (AstNode child : statementNode.getCases()) {\n         node.addChildToBack(transform(child));\n \n     @Override\n     Node processThrowStatement(ThrowStatement statementNode) {\n-      return new Node(Token.THROW,\n+      return newNode(Token.THROW,\n           transform(statementNode.getExpression()));\n     }\n \n     @Override\n     Node processTryStatement(TryStatement statementNode) {\n-      Node node = new Node(Token.TRY,\n+      Node node = newNode(Token.TRY,\n           transformBlock(statementNode.getTryBlock()));\n-      Node block = new Node(Token.BLOCK);\n+      Node block = newNode(Token.BLOCK);\n       boolean lineSet = false;\n \n       for (CatchClause cc : statementNode.getCatchClauses()) {\n         operand.setDouble(-operand.getDouble());\n         return operand;\n       } else {\n-        Node node = new Node(type, operand);\n+        Node node = newNode(type, operand);\n         if (exprNode.isPostfix()) {\n           node.putBooleanProp(Node.INCRDECR_PROP, true);\n         }\n \n     @Override\n     Node processVariableDeclaration(VariableDeclaration declarationNode) {\n-      Node node = new Node(Token.VAR);\n+      Node node = newNode(Token.VAR);\n       for (VariableInitializer child : declarationNode.getVariables()) {\n         node.addChildToBack(transform(child));\n       }\n \n     @Override\n     Node processWhileLoop(WhileLoop loopNode) {\n-      return new Node(\n+      return newNode(\n           Token.WHILE,\n           transform(loopNode.getCondition()),\n           transformBlock(loopNode.getBody()));\n \n     @Override\n     Node processWithStatement(WithStatement statementNode) {\n-      return new Node(\n+      return newNode(\n           Token.WITH,\n           transform(statementNode.getExpression()),\n           transformBlock(statementNode.getStatement()));\n               node.getType()),\n           sourceName,\n           node.getLineno(), \"\", 0);\n-      return new Node(Token.EMPTY);\n+      return newNode(Token.EMPTY);\n     }\n \n     void reportDestructuringAssign(AstNode node) {\n     throw new IllegalStateException(String.valueOf(token));\n   }\n \n+  // Simple helper to create nodes and set the initial node properties.\n+  private Node newNode(int type) {\n+    return new Node(type).clonePropsFrom(templateNode);\n+  }\n+\n+  private Node newNode(int type, Node child1) {\n+    return new Node(type, child1).clonePropsFrom(templateNode);\n+  }\n+\n+  private Node newNode(int type, Node child1, Node child2) {\n+    return new Node(type, child1, child2).clonePropsFrom(templateNode);\n+  }\n+\n+  private Node newNode(int type, Node child1, Node child2, Node child3) {\n+    return new Node(type, child1, child2, child3).clonePropsFrom(templateNode);\n+  }\n+\n+  private Node newStringNode(String value) {\n+    return Node.newString(value).clonePropsFrom(templateNode);\n+  }\n+\n+  private Node newStringNode(int type, String value) {\n+    return Node.newString(type, value).clonePropsFrom(templateNode);\n+  }\n+\n+  private Node newNumberNode(Double value) {\n+    return Node.newNumber(value).clonePropsFrom(templateNode);\n+  }\n+\n   /**\n    * A simple wrapper struct, so that we can put a Node in the collection\n    * first and populate it later.\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n       x = x.next;\n     }\n     return x;\n+  }\n+\n+  /**\n+   * Clone the properties from the provided node without copying\n+   * the property object.  The recieving node may not have any\n+   * existing properties.\n+   * @param other The node to clone properties from.\n+   * @return this node.\n+   */\n+  public Node clonePropsFrom(Node other) {\n+    Preconditions.checkState(this.propListHead == null,\n+        \"Node has existing properties.\");\n+    this.propListHead = other.propListHead;\n+    return this;\n   }\n \n   public void removeProp(int propType) {\n \n   private String toStringTreeImpl() {\n     try {\n-      StringBuffer s = new StringBuffer();\n+      StringBuilder s = new StringBuilder();\n       appendStringTree(s);\n       return s.toString();\n     } catch (IOException e) {\n--- a/src/com/google/javascript/rhino/RhinoException.java\n+++ b/src/com/google/javascript/rhino/RhinoException.java\n         if (sourceName == null || lineNumber <= 0) {\n             return details;\n         }\n-        StringBuffer buf = new StringBuffer(details);\n+        StringBuilder buf = new StringBuilder(details);\n         buf.append(\" (\");\n         if (sourceName != null) {\n             buf.append(sourceName);\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+        JSType noType = getNativeType(JSTypeNative.NO_TYPE);\n+        return new TypePair(noType, noType);\n \n       case FALSE:\n       case UNKNOWN:\n--- a/test/com/google/javascript/jscomp/AliasKeywordsTest.java\n+++ b/test/com/google/javascript/jscomp/AliasKeywordsTest.java\n    */\n   private static String generateCode(\n       String keyword, int numReps, String prepend) {\n-    StringBuffer sb = new StringBuffer(prepend);\n+    StringBuilder sb = new StringBuilder(prepend);\n     for (int i = 0; i < numReps; i++) {\n       sb.append(\"if (\");\n       sb.append(keyword);\n \n   private static String generatePreProcessThrowCode(int repititions,\n                                                     String whatToThrow) {\n-    StringBuffer sb = new StringBuffer();\n+    StringBuilder sb = new StringBuilder();\n     for (int i = 0; i < repititions; i++) {\n       sb.append(\"throw \");\n       sb.append(whatToThrow);\n   }\n \n   public void testAliasTrueFalseNull() {\n-    StringBuffer actual = new StringBuffer();\n+    StringBuilder actual = new StringBuilder();\n     actual.append(generateCode(\"true\", ENOUGH_TO_ALIAS_LITERAL));\n     actual.append(generateCode(\"false\", ENOUGH_TO_ALIAS_LITERAL));\n     actual.append(generateCode(\"null\", ENOUGH_TO_ALIAS_LITERAL));\n \n-    StringBuffer expected = new StringBuffer();\n+    StringBuilder expected = new StringBuilder();\n     expected.append(\n         \"var JSCompiler_alias_TRUE=true;\" +\n         \"var JSCompiler_alias_NULL=null;\" +\n--- a/test/com/google/javascript/jscomp/CombinedCompilerPassTest.java\n+++ b/test/com/google/javascript/jscomp/CombinedCompilerPassTest.java\n    * rooted with specified strings.\n    */\n   private static class ConcatTraversal implements Callback {\n-    private StringBuffer visited = new StringBuffer();\n-    private StringBuffer shouldTraversed = new StringBuffer();\n+    private StringBuilder visited = new StringBuilder();\n+    private StringBuilder shouldTraversed = new StringBuilder();\n     private Set<String> ignoring = Sets.newHashSet();\n \n     ConcatTraversal ignore(String s) {\n--- a/test/com/google/javascript/jscomp/FunctionRewriterTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionRewriterTest.java\n                                String expectedHdr,\n                                String expectedBody,\n                                int repetitions) {\n-    StringBuffer srcBuffer = new StringBuffer();\n-    StringBuffer expectedBuffer = new StringBuffer();\n+    StringBuilder srcBuffer = new StringBuilder();\n+    StringBuilder expectedBuffer = new StringBuilder();\n \n     expectedBuffer.append(expectedHdr);\n \n--- a/test/com/google/javascript/jscomp/ParallelCompilerPassTest.java\n+++ b/test/com/google/javascript/jscomp/ParallelCompilerPassTest.java\n   }\n \n   public void testManyFunctions() {\n-    StringBuffer sb = new StringBuffer(\"\\\"foo\\\";\");\n+    StringBuilder sb = new StringBuilder(\"\\\"foo\\\";\");\n     for (int i = 0; i < 20; i++) {\n       sb.append(\"function f\");\n       sb.append(i);\n--- a/test/com/google/javascript/jscomp/SemanticReverseAbstractInterpreterTest.java\n+++ b/test/com/google/javascript/jscomp/SemanticReverseAbstractInterpreterTest.java\n         createNull(),\n         Sets.newHashSet(new TypedName(\"a\", nullUndefined)),\n         Sets.newHashSet(new TypedName(\"a\", NUMBER_TYPE)));\n+  }\n+\n+  /**\n+   * Tests reverse interpretation of two undefineds.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public void testEqCondition4() throws Exception {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.EQ,\n+        createVar(blind, \"a\", VOID_TYPE),\n+        createVar(blind, \"b\", VOID_TYPE),\n+        Sets.newHashSet(\n+            new TypedName(\"a\", VOID_TYPE),\n+            new TypedName(\"b\", VOID_TYPE)),\n+        Sets.newHashSet(\n+            new TypedName(\"a\", NO_TYPE),\n+            new TypedName(\"b\", NO_TYPE)));\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java\n+++ b/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java\n       for (DefinitionSite defSite : passUnderTest.getDefinitionSites()) {\n         Node node = defSite.node;\n         Definition definition = defSite.definition;\n-        StringBuffer sb = new StringBuffer();\n+        StringBuilder sb = new StringBuilder();\n         sb.append(\"DEF \");\n         sb.append(Token.name(node.getType()));\n         sb.append(\" \");\n       Collection<Definition> defs =\n           passUnderTest.getDefinitionsReferencedAt(node);\n       if (defs != null) {\n-        StringBuffer sb = new StringBuffer();\n+        StringBuilder sb = new StringBuilder();\n         sb.append(\"USE \");\n         sb.append(Token.name(node.getType()));\n         sb.append(\" \");\n--- a/test/com/google/javascript/jscomp/deps/JsFileLineParserTest.java\n+++ b/test/com/google/javascript/jscomp/deps/JsFileLineParserTest.java\n \n package com.google.javascript.jscomp.deps;\n \n-import com.google.common.collect.ImmutableList;\n import com.google.javascript.jscomp.ErrorManager;\n import com.google.javascript.jscomp.PrintStreamErrorManager;\n \n import junit.framework.TestCase;\n \n import java.io.StringReader;\n-import java.util.Collections;\n \n /**\n  * Tests for {@link JsFileLineParser}.\n   }\n \n   private static class TestParser extends JsFileLineParser {\n-    StringBuffer sb = new StringBuffer();\n+    StringBuilder sb = new StringBuilder();\n \n     TestParser(ErrorManager errorManager) {\n       super(errorManager);", "timestamp": 1278540858, "metainfo": ""}