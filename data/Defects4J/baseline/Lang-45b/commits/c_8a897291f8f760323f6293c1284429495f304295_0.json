{"sha": "8a897291f8f760323f6293c1284429495f304295", "log": "http://issues.apache.org/bugzilla/show_bug.cgi?id=22692 : - added new splitPreserveAllTokens methods to mirror the split functionality, preserving empty tokens indicated by adjacent tokens; - refactored logic of existing split method into splitWorker for sharing by new splitPreserveAllTokens methods   ", "commit": "\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n  * @author Al Chou\n  * @author Michael Davey\n  * @since 1.0\n- * @version $Id: StringUtils.java,v 1.130 2004/05/24 20:15:44 fredrik Exp $\n+ * @version $Id: StringUtils.java,v 1.131 2004/07/11 16:48:31 stevencaswell Exp $\n  */\n public class StringUtils {\n     // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n      * @since 2.0\n      */\n     public static String[] split(String str, char separatorChar) {\n-        // Performance tuned for 2.0 (JDK1.4)\n-\n-        if (str == null) {\n-            return null;\n-        }\n-        int len = str.length();\n-        if (len == 0) {\n-            return ArrayUtils.EMPTY_STRING_ARRAY;\n-        }\n-        List list = new ArrayList();\n-        int i = 0, start = 0;\n-        boolean match = false;\n-        while (i < len) {\n-            if (str.charAt(i) == separatorChar) {\n-                if (match) {\n-                    list.add(str.substring(start, i));\n-                    match = false;\n-                }\n-                start = ++i;\n-                continue;\n-            }\n-            match = true;\n-            i++;\n-        }\n-        if (match) {\n-            list.add(str.substring(start, i));\n-        }\n-        return (String[]) list.toArray(new String[list.size()]);\n+        return splitWorker(str, separatorChar, false);\n     }\n \n     /**\n      * @return an array of parsed Strings, <code>null</code> if null String input\n      */\n     public static String[] split(String str, String separatorChars) {\n-        return split(str, separatorChars, -1);\n+        return splitWorker(str, separatorChars, -1, false);\n     }\n \n     /**\n      * @return an array of parsed Strings, <code>null</code> if null String input\n      */\n     public static String[] split(String str, String separatorChars, int max) {\n+        return splitWorker(str, separatorChars, max, false);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Splits the provided text into an array, using whitespace as the\n+     * separator, preserving all tokens, including empty tokens created by \n+     * adjacent separators. This is an alternative to using StringTokenizer.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * For more control over the split use the Tokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitPreserveAllTokens(null)       = null\n+     * StringUtils.splitPreserveAllTokens(\"\")         = []\n+     * StringUtils.splitPreserveAllTokens(\"abc def\")  = [\"abc\", \"def\"]\n+     * StringUtils.splitPreserveAllTokens(\"abc  def\") = [\"abc\", \"\", \"def\"]\n+     * StringUtils.splitPreserveAllTokens(\" abc \")    = [\"\", \"abc\", \"\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String[] splitPreserveAllTokens(String str) {\n+        return splitWorker(str, null, -1, true);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separator specified,\n+     * preserving all tokens, including empty tokens created by adjacent\n+     * separators. This is an alternative to using StringTokenizer.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * For more control over the split use the Tokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitPreserveAllTokens(null, *)         = null\n+     * StringUtils.splitPreserveAllTokens(\"\", *)           = []\n+     * StringUtils.splitPreserveAllTokens(\"a.b.c\", '.')    = [\"a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\"a..b.c\", '.')   = [\"a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\"a:b:c\", '.')    = [\"a:b:c\"]\n+     * StringUtils.splitPreserveAllTokens(\"a\\tb\\nc\", null) = [\"a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\"a b c\", ' ')    = [\"a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\"a b c \", ' ')   = [\"a\", \"b\", \"c\", \"\"]\n+     * StringUtils.splitPreserveAllTokens(\"a b c \", ' ')   = [\"a\", \"b\", \"c\", \"\", \"\"]\n+     * StringUtils.splitPreserveAllTokens(\" a b c\", ' ')   = [\"\", a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\"  a b c\", ' ')  = [\"\", \"\", a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\" a b c \", ' ')  = [\"\", a\", \"b\", \"c\", \"\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separatorChar  the character used as the delimiter,\n+     *  <code>null</code> splits on whitespace\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String[] splitPreserveAllTokens(String str, char separatorChar) {\n+        return splitWorker(str, separatorChar, true);\n+    }\n+\n+    /**\n+     * Performs the logic for the <code>split</code> and \n+     * <code>splitPreserveAllTokens</code> methods that do not return a\n+     * maximum array length.\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separatorChar the separate character\n+     * @param preserveAllTokens if <code>true</code>, adjacent separators are\n+     * treated as empty token separators; if <code>false</code>, adjacent\n+     * separators are treated as one separator.\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) {\n+        // Performance tuned for 2.0 (JDK1.4)\n+\n+        if (str == null) {\n+            return null;\n+        }\n+        int len = str.length();\n+        if (len == 0) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        List list = new ArrayList();\n+        int i = 0, start = 0;\n+        boolean match = false;\n+        boolean lastMatch = false;\n+        while (i < len) {\n+            if (str.charAt(i) == separatorChar) {\n+                if (match || preserveAllTokens) {\n+                    list.add(str.substring(start, i));\n+                    match = false;\n+                    lastMatch = true;\n+                }\n+                start = ++i;\n+                continue;\n+            } else {\n+                lastMatch = false;\n+            }\n+            match = true;\n+            i++;\n+        }\n+        if (match || (preserveAllTokens && lastMatch)) {\n+            list.add(str.substring(start, i));\n+        }\n+        return (String[]) list.toArray(new String[list.size()]);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separators specified, \n+     * preserving all tokens, including empty tokens created by adjacent\n+     * separators. This is an alternative to using StringTokenizer.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * For more control over the split use the Tokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separatorChars splits on whitespace.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitPreserveAllTokens(null, *)           = null\n+     * StringUtils.splitPreserveAllTokens(\"\", *)             = []\n+     * StringUtils.splitPreserveAllTokens(\"abc def\", null)   = [\"abc\", \"def\"]\n+     * StringUtils.splitPreserveAllTokens(\"abc def\", \" \")    = [\"abc\", \"def\"]\n+     * StringUtils.splitPreserveAllTokens(\"abc  def\", \" \")   = [\"abc\", \"\", def\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\")   = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef:\", \":\")  = [\"ab\", \"cd\", \"ef\", \"\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef::\", \":\") = [\"ab\", \"cd\", \"ef\", \"\", \"\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab::cd:ef\", \":\")  = [\"ab\", \"\", cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\":cd:ef\", \":\")     = [\"\", cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"::cd:ef\", \":\")    = [\"\", \"\", cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\":cd:ef:\", \":\")    = [\"\", cd\", \"ef\", \"\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separatorChars  the characters used as the delimiters,\n+     *  <code>null</code> splits on whitespace\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    public static String[] splitPreserveAllTokens(String str, String separatorChars) {\n+        return splitWorker(str, separatorChars, -1, true);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array with a maximum length,\n+     * separators specified, preserving all tokens, including empty tokens \n+     * created by adjacent separators.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * Adjacent separators are treated as one separator.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separatorChars splits on whitespace.</p>\n+     *\n+     * <p>If more than <code>max</code> delimited substrings are found, the last\n+     * returned string includes all characters after the first <code>max - 1</code>\n+     * returned strings (including separator characters).</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitPreserveAllTokens(null, *, *)            = null\n+     * StringUtils.splitPreserveAllTokens(\"\", *, *)              = []\n+     * StringUtils.splitPreserveAllTokens(\"ab de fg\", null, 0)   = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 0) = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\", 0)    = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\", 2)    = [\"ab\", \"cd:ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 2) = [\"ab\", \"  de fg\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 3) = [\"ab\", \"\", \" de fg\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 4) = [\"ab\", \"\", \"\", \"de fg\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separatorChars  the characters used as the delimiters,\n+     *  <code>null</code> splits on whitespace\n+     * @param max  the maximum number of elements to include in the\n+     *  array. A zero or negative value implies no limit\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {\n+        return splitWorker(str, separatorChars, max, true);\n+    }\n+\n+    /**\n+     * Performs the logic for the <code>split</code> and \n+     * <code>splitPreserveAllTokens</code> methods that return a maximum array \n+     * length.\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separatorChars the separate character\n+     * @param max  the maximum number of elements to include in the\n+     *  array. A zero or negative value implies no limit.\n+     * @param preserveAllTokens if <code>true</code>, adjacent separators are\n+     * treated as empty token separators; if <code>false</code>, adjacent\n+     * separators are treated as one separator.\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n         // Performance tuned for 2.0 (JDK1.4)\n         // Direct code is quicker than StringTokenizer.\n         // Also, StringTokenizer uses isSpace() not isWhitespace()\n         int sizePlus1 = 1;\n         int i = 0, start = 0;\n         boolean match = false;\n+        boolean lastMatch = false;\n         if (separatorChars == null) {\n             // Null separator means use whitespace\n             while (i < len) {\n                 if (Character.isWhitespace(str.charAt(i))) {\n-                    if (match) {\n+                    if (match || preserveAllTokens) {\n+                        lastMatch = true;\n                         if (sizePlus1++ == max) {\n                             i = len;\n+                            lastMatch = false;\n                         }\n                         list.add(str.substring(start, i));\n                         match = false;\n                     }\n                     start = ++i;\n                     continue;\n+                } else {\n+                    lastMatch = false;\n                 }\n                 match = true;\n                 i++;\n             char sep = separatorChars.charAt(0);\n             while (i < len) {\n                 if (str.charAt(i) == sep) {\n-                    if (match) {\n+                    if (match || preserveAllTokens) {\n+                        lastMatch = true;\n                         if (sizePlus1++ == max) {\n                             i = len;\n+                            lastMatch = false;\n                         }\n                         list.add(str.substring(start, i));\n                         match = false;\n                     }\n                     start = ++i;\n                     continue;\n+                } else {\n+                    lastMatch = false;\n                 }\n                 match = true;\n                 i++;\n             // standard case\n             while (i < len) {\n                 if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n-                    if (match) {\n+                    if (match || preserveAllTokens) {\n+                        lastMatch = true;\n                         if (sizePlus1++ == max) {\n                             i = len;\n+                            lastMatch = false;\n                         }\n                         list.add(str.substring(start, i));\n                         match = false;\n                     }\n                     start = ++i;\n                     continue;\n+                } else {\n+                    lastMatch = false;\n                 }\n                 match = true;\n                 i++;\n             }\n         }\n-        if (match) {\n+        if (match || (preserveAllTokens && lastMatch)) {\n             list.add(str.substring(start, i));\n         }\n         return (String[]) list.toArray(new String[list.size()]);", "timestamp": 1089564511, "metainfo": ""}