{"sha": "4dcba82f4fce40bf0ad7a74ade88e59e99252a49", "log": "CalendarUtils from the sandbox, for merger with DateUtils. Or parallel living.   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/CalendarUtils.java\n+package org.apache.commons.lang;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.text.*;\n+import java.util.*;\n+\n+/**\n+ * A suite of utilities surrounding the use of the Calendar and Date object.\n+ *\n+ * @author <a href=\"mailto:sergek@lokitech.com\">Serge Knystautas</a>\n+ */\n+public class CalendarUtils {\n+\n+    /**\n+     * This is half a month, so this represents whether a date is in the top\n+     * or bottom half of the month.\n+     */\n+    public final static int SEMI_MONTH = 1001;\n+\n+    private static final int[][] fields = {\n+            {Calendar.MILLISECOND},\n+            {Calendar.SECOND},\n+            {Calendar.MINUTE},\n+            {Calendar.HOUR_OF_DAY, Calendar.HOUR},\n+            {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */},\n+            {Calendar.MONTH, CalendarUtils.SEMI_MONTH},\n+            {Calendar.YEAR},\n+            {Calendar.ERA}};\n+\n+    private static DateFormat[] dateFormats = {\n+        //3/31/92 10:00:07 PST\n+        new SimpleDateFormat(\"M/dd/yy h:mm:ss z\"),\n+        //January 23, 1987 10:05pm\n+        new SimpleDateFormat(\"MMM d, yyyy h:mm a\"),\n+        //22:00 GMT\n+        new SimpleDateFormat(\"h:mm z\")};\n+\n+    /**\n+     * A week range, starting on Sunday.\n+     */\n+    public final static int RANGE_WEEK_SUNDAY = 1;\n+\n+    /**\n+     * A week range, starting on Monday.\n+     */\n+    public final static int RANGE_WEEK_MONDAY = 2;\n+\n+    /**\n+     * A week range, starting on the day focused.\n+     */\n+    public final static int RANGE_WEEK_RELATIVE = 3;\n+\n+    /**\n+     * A week range, centered around the day focused.\n+     */\n+    public final static int RANGE_WEEK_CENTER = 4;\n+\n+    /**\n+     * A month range, the week starting on Sunday.\n+     */\n+    public final static int RANGE_MONTH_SUNDAY = 5;\n+\n+    /**\n+     * A month range, the week starting on Monday.\n+     */\n+    public final static int RANGE_MONTH_MONDAY = 6;\n+\n+    /**\n+     * See the other round method.  Works with a Date object.\n+     */\n+    public static Date round(Date val, int field) {\n+        GregorianCalendar gval = new GregorianCalendar();\n+        gval.setTime(val);\n+        modify(gval, field, true);\n+        return gval.getTime();\n+    }\n+\n+    /**\n+     * Round this date, leaving the field specified as the most significant\n+     * field.  For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if this was passed with HOUR, it would return 28 Mar\n+     * 2002 14:00:00.000.  If this was passed with MONTH, it would return\n+     * 1 April 2002 0:00:00.000.\n+     */\n+    public static Calendar round(Calendar val, int field) {\n+        Calendar rounded = (Calendar) val.clone();\n+        modify(rounded, field, true);\n+        return rounded;\n+    }\n+\n+    /**\n+     * See the other round method.  Works with an Object, trying to\n+     * use it as either a Date or Calendar.\n+     */\n+    public static Date round(Object val, int field) {\n+        if (val instanceof Date) {\n+            return round((Date) val, field);\n+        } else if (val instanceof Calendar) {\n+            return round((Calendar) val, field).getTime();\n+        } else {\n+            throw new ClassCastException(\"Could not round \" + val);\n+        }\n+    }\n+\n+    /**\n+     * See the other trunc method.  Works with a Date.\n+     */\n+    public static Date trunc(Date val, int field) {\n+        GregorianCalendar gval = new GregorianCalendar();\n+        gval.setTime(val);\n+        modify(gval, field, false);\n+        return gval.getTime();\n+    }\n+\n+    /**\n+     * Truncate this date, leaving the field specified as the most significant\n+     * field.  For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would return\n+     * 1 Mar 2002 0:00:00.000.\n+     */\n+    public static Calendar trunc(Calendar val, int field) {\n+        Calendar truncated = (Calendar) val.clone();\n+        modify(truncated, field, false);\n+        return truncated;\n+    }\n+\n+    /**\n+     * See the other trunc method.  Works with an Object, trying to\n+     * use it as either a Date or Calendar.\n+     */\n+    public static Date trunc(Object val, int field) {\n+        if (val instanceof Date) {\n+            return trunc((Date) val, field);\n+        } else if (val instanceof Calendar) {\n+            return trunc((Calendar) val, field).getTime();\n+        } else {\n+            throw new ClassCastException(\"Could not trunc \" + val);\n+        }\n+    }\n+\n+    private static void modify(Calendar val, int field, boolean round) {\n+        boolean roundUp = false;\n+        for (int i = 0; i < fields.length; i++) {\n+            for (int j = 0; j < fields[i].length; j++) {\n+                if (fields[i][j] == field) {\n+                    //This is our field... we stop looping\n+                    if (round && roundUp) {\n+                        if (field == CalendarUtils.SEMI_MONTH) {\n+                            //This is a special case that's hard to generalize\n+                            //If the date is 1, we round up to 16, otherwise\n+                            //  we subtract 15 days and add 1 month\n+                            if (val.get(Calendar.DATE) == 1) {\n+                                val.add(Calendar.DATE, 15);\n+                            } else {\n+                                val.add(Calendar.DATE, -15);\n+                                val.add(Calendar.MONTH, 1);\n+                            }\n+                        } else {\n+                            //We need at add one to this field since the\n+                            //  last number causes us to round up\n+                            val.add(fields[i][0], 1);\n+                        }\n+                    }\n+                    return;\n+                }\n+            }\n+            //We have various fields that are not easy roundings\n+            int offset = 0;\n+            boolean offsetSet = false;\n+            //These are special types of fields that require different rounding rules\n+            switch (field) {\n+                case CalendarUtils.SEMI_MONTH:\n+                    if (fields[i][0] == Calendar.DATE) {\n+                        //If we're going to drop the DATE field's value,\n+                        //  we want to do this our own way.\n+                        //We need to subtrace 1 since the date has a minimum of 1\n+                        offset = val.get(Calendar.DATE) - 1;\n+                        //If we're above 15 days adjustment, that means we're in the\n+                        //  bottom half of the month and should stay accordingly.\n+                        if (offset >= 15) {\n+                            offset -= 15;\n+                        }\n+                        //Record whether we're in the top or bottom half of that range\n+                        roundUp = offset > 7;\n+                        offsetSet = true;\n+                    }\n+                    break;\n+                case Calendar.AM_PM:\n+                    if (fields[i][0] == Calendar.HOUR) {\n+                        //If we're going to drop the HOUR field's value,\n+                        //  we want to do this our own way.\n+                        offset = val.get(Calendar.HOUR);\n+                        if (offset >= 12) {\n+                            offset -= 12;\n+                        }\n+                        roundUp = offset > 6;\n+                        offsetSet = true;\n+                    }\n+                    break;\n+            }\n+            if (!offsetSet) {\n+                int min = val.getActualMinimum(fields[i][0]);\n+                int max = val.getActualMaximum(fields[i][0]);\n+                //Calculate the offset from the minimum allowed value\n+                offset = val.get(fields[i][0]) - min;\n+                //Set roundUp if this is more than half way between the minimum and maximum\n+                roundUp = offset > ((max - min) / 2);\n+            }\n+            //We need to remove this field\n+            val.add(fields[i][0], -offset);\n+        }\n+        throw new RuntimeException(\"We do not support that field.\");\n+\n+    }\n+\n+    /**\n+     * Parses strings the way that CVS supports it... very human readable\n+     */\n+    public static Calendar parse(String original) {\n+        return parse(original, Locale.getDefault());\n+    }\n+\n+    /**\n+     * Parses strings the way that CVS supports it... very human readable\n+     */\n+    public static Calendar parse(String original, Locale locale) {\n+        //Get the symbol names\n+        DateFormatSymbols symbols = new DateFormatSymbols(locale);\n+\n+        //Prep the string to parse\n+        String value = original.toLowerCase().trim();\n+\n+        //Get the current date/time\n+        Calendar now = Calendar.getInstance();\n+        if (value.endsWith(\" ago\")) {\n+            //If this was a date that was \"ago\" the current time...\n+            //Strip out the ' ago' part\n+            value = value.substring(0, value.length() - 4);\n+\n+            //Split the value and unit\n+            int start = value.indexOf(\" \");\n+            if (start < 0) {\n+                throw new RuntimeException(\"Could not find space in between value and unit\");\n+            }\n+            String unit = value.substring(start + 1);\n+            value = value.substring(0, start);\n+            //We support \"a week\", so we need to parse the value as \"a\"\n+            int val = 0;\n+            if (value.equals(\"a\") || value.equals(\"an\")) {\n+                val = 1;\n+            } else {\n+                val = Integer.parseInt(value);\n+            }\n+\n+            //Determine the unit\n+            if (unit.equals(\"milliseconds\") || unit.equals(\"millisecond\")) {\n+                now.add(Calendar.MILLISECOND, -val);\n+            } else if (unit.equals(\"seconds\") || unit.equals(\"second\")) {\n+                now.add(Calendar.SECOND, -val);\n+            } else if (unit.equals(\"minutes\") || unit.equals(\"minute\")) {\n+                now.add(Calendar.MINUTE, -val);\n+            } else if (unit.equals(\"hours\") || unit.equals(\"hour\")) {\n+                now.add(Calendar.HOUR, -val);\n+            } else if (unit.equals(\"days\") || unit.equals(\"day\")) {\n+                now.add(Calendar.DATE, -val);\n+            } else if (unit.equals(\"weeks\") || unit.equals(\"week\")) {\n+                now.add(Calendar.DATE, -val * 7);\n+            } else if (unit.equals(\"fortnights\") || unit.equals(\"fortnight\")) {\n+                now.add(Calendar.DATE, -val * 14);\n+            } else if (unit.equals(\"months\") || unit.equals(\"month\")) {\n+                now.add(Calendar.MONTH, -val);\n+            } else if (unit.equals(\"years\") || unit.equals(\"year\")) {\n+                now.add(Calendar.YEAR, -val);\n+            } else {\n+                throw new RuntimeException(\"We do not understand that many units ago\");\n+            }\n+            return now;\n+        } else if (value.startsWith(\"last \")) {\n+            //If this was the last time a certain field was met\n+            //Strip out the 'last ' part\n+            value = value.substring(5);\n+            //Get the current date/time\n+            String[] strings = symbols.getWeekdays();\n+            for (int i = 0; i < strings.length; i++) {\n+                if (value.equalsIgnoreCase(strings[i])) {\n+                    //How many days after Sunday\n+                    int daysAgo = now.get(Calendar.DAY_OF_WEEK) - i;\n+                    if (daysAgo <= 0) {\n+                        daysAgo += 7;\n+                    }\n+                    now.add(Calendar.DATE, -daysAgo);\n+                    return now;\n+                }\n+            }\n+            strings = symbols.getMonths();\n+            for (int i = 0; i < strings.length; i++) {\n+                if (value.equalsIgnoreCase(strings[i])) {\n+                    //How many days after January\n+                    int monthsAgo = now.get(Calendar.MONTH) - i;\n+                    if (monthsAgo <= 0) {\n+                        monthsAgo += 12;\n+                    }\n+                    now.add(Calendar.MONTH, -monthsAgo);\n+                    return now;\n+                }\n+            }\n+            if (value.equals(\"week\")) {\n+                now.add(Calendar.DATE, -7);\n+                return now;\n+            }\n+        } else if (value.equals(\"yesterday\")) {\n+            now.add(Calendar.DATE, -1);\n+            return now;\n+        } else if (value.equals(\"tomorrow\")) {\n+            now.add(Calendar.DATE, 1);\n+            return now;\n+        }\n+        //Try to parse the date a number of different ways\n+        for (int i = 0; i < dateFormats.length; i++) {\n+            try {\n+                Date datetime = dateFormats[i].parse(original);\n+                Calendar cal = Calendar.getInstance();\n+                cal.setTime(datetime);\n+                return cal;\n+            } catch (ParseException pe) {\n+                //we ignore this and just keep trying\n+            }\n+        }\n+\n+        throw new RuntimeException(\"Unable to parse '\" + original + \"'.\");\n+    }\n+\n+    /**\n+     * This constructs an Iterator that will start and stop over a date\n+     * range based on the focused date and the range style.  For instance,\n+     * passing Thursday, July 4, 2002 and a RANGE_MONTH_SUNDAY will return\n+     * an Iterator that starts with Sunday, June 30, 2002 and ends with\n+     * Saturday, August 3, 2002.\n+     */\n+    public static Iterator getCalendarIterator(Calendar focus, int rangeStyle) {\n+        Calendar start = null;\n+        Calendar end = null;\n+        int startCutoff = Calendar.SUNDAY;\n+        int endCutoff = Calendar.SATURDAY;\n+        switch (rangeStyle) {\n+            case RANGE_MONTH_SUNDAY:\n+            case RANGE_MONTH_MONDAY:\n+                //Set start to the first of the month\n+                start = trunc(focus, Calendar.MONTH);\n+                //Set end to the last of the month\n+                end = (Calendar) start.clone();\n+                end.add(Calendar.MONTH, 1);\n+                end.add(Calendar.DATE, -1);\n+                //Loop start back to the previous sunday or monday\n+                if (rangeStyle == RANGE_MONTH_MONDAY) {\n+                    startCutoff = Calendar.MONDAY;\n+                    endCutoff = Calendar.SUNDAY;\n+                }\n+                break;\n+            case RANGE_WEEK_SUNDAY:\n+            case RANGE_WEEK_MONDAY:\n+            case RANGE_WEEK_RELATIVE:\n+            case RANGE_WEEK_CENTER:\n+                //Set start and end to the current date\n+                start = trunc(focus, Calendar.DATE);\n+                end = trunc(focus, Calendar.DATE);\n+                switch (rangeStyle) {\n+                    case RANGE_WEEK_SUNDAY:\n+                        //already set by default\n+                        break;\n+                    case RANGE_WEEK_MONDAY:\n+                        startCutoff = Calendar.MONDAY;\n+                        endCutoff = Calendar.SUNDAY;\n+                        break;\n+                    case RANGE_WEEK_RELATIVE:\n+                        startCutoff = focus.get(Calendar.DAY_OF_WEEK);\n+                        endCutoff = startCutoff - 1;\n+                        break;\n+                    case RANGE_WEEK_CENTER:\n+                        startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3;\n+                        endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3;\n+                        break;\n+                }\n+                break;\n+            default:\n+                throw new RuntimeException(\"The range style \" + rangeStyle + \" is not valid.\");\n+        }\n+        if (startCutoff < Calendar.SUNDAY) {\n+            startCutoff += 7;\n+        }\n+        if (endCutoff > Calendar.SATURDAY) {\n+            endCutoff -= 7;\n+        }\n+        while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) {\n+            start.add(Calendar.DATE, -1);\n+        }\n+        while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {\n+            end.add(Calendar.DATE, 1);\n+        }\n+        final Calendar startFinal = start;\n+        final Calendar endFinal = end;\n+        Iterator it = new Iterator() {\n+            Calendar spot = null;\n+            {\n+                spot = startFinal;\n+                spot.add(Calendar.DATE, -1);\n+            }\n+\n+            public boolean hasNext() {\n+                return spot.before(endFinal);\n+            }\n+\n+            public Object next() {\n+                if (spot.equals(endFinal)) {\n+                    throw new NoSuchElementException();\n+                }\n+                spot.add(Calendar.DATE, 1);\n+                return spot.clone();\n+            }\n+\n+            public void remove() {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+        return it;\n+    }\n+\n+    /**\n+     * See the other getCalendarIterator.  Works with a Date.\n+     */\n+    public static Iterator getCalendarIterator(Date focus, int rangeStyle) {\n+        GregorianCalendar gval = new GregorianCalendar();\n+        gval.setTime(focus);\n+        return getCalendarIterator(gval, rangeStyle);\n+    }\n+\n+    /**\n+     * See the other getCalendarIterator.  Works with an Object, trying\n+     * to use it as a Date or Calendar.\n+     */\n+    public static Iterator getCalendarIterator(Object focus, int rangeStyle) {\n+        if (focus instanceof Date) {\n+            return getCalendarIterator((Date) focus, rangeStyle);\n+        } else if (focus instanceof Calendar) {\n+            return getCalendarIterator((Calendar) focus, rangeStyle);\n+        } else {\n+            throw new ClassCastException(\"Could not iterate based on \" + focus);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/CalendarUtilsTest.java\n+package org.apache.commons.lang;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.text.DateFormat;\n+import java.util.*;\n+\n+import junit.framework.AssertionFailedError;\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.CalendarUtils}.\n+ *\n+ * @author <a href=\"mailto:sergek@lokitech.com\">Serge Knystautas</a>\n+ */\n+public class CalendarUtilsTest extends TestCase {\n+    DateFormat parser = null;\n+    Date date1 = null;\n+    Date date2 = null;\n+\n+    public CalendarUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+    \tTestSuite suite = new TestSuite(CalendarUtilsTest.class);\n+    \tsuite.setName(\"CalendarUtilsTest Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+\n+        parser = new java.text.SimpleDateFormat(\"MMM dd, yyyy H:mm:ss.SSS\");\n+\n+        date1 = parser.parse(\"February 12, 2002 12:34:56.789\");\n+        date2 = parser.parse(\"November 18, 2001 1:23:11.321\");\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+\n+    /**\n+     * Tests various values with the round method\n+     */\n+    public void testRound() throws Exception {\n+        assertEquals(\"round year-1 failed\",\n+                new Date(\"2002 January 1\"),\n+                CalendarUtils.round(date1, Calendar.YEAR));\n+        assertEquals(\"round year-2 failed\",\n+                new Date(\"2002 January 1\"),\n+                CalendarUtils.round(date2, Calendar.YEAR));\n+        assertEquals(\"round month-1 failed\",\n+                new Date(\"2002 February 1\"),\n+                CalendarUtils.round(date1, Calendar.MONTH));\n+        assertEquals(\"round month-2 failed\",\n+                new Date(\"2001 December 1\"),\n+                CalendarUtils.round(date2, Calendar.MONTH));\n+        assertEquals(\"round semimonth-1 failed\",\n+                new Date(\"2002 February 16\"),\n+                CalendarUtils.round(date1, CalendarUtils.SEMI_MONTH));\n+        assertEquals(\"round semimonth-2 failed\",\n+                new Date(\"2001 November 16\"),\n+                CalendarUtils.round(date2, CalendarUtils.SEMI_MONTH));\n+        assertEquals(\"round date-1 failed\",\n+                new Date(\"2002 February 13\"),\n+                CalendarUtils.round(date1, Calendar.DATE));\n+        assertEquals(\"round date-2 failed\",\n+                new Date(\"2001 November 18\"),\n+                CalendarUtils.round(date2, Calendar.DATE));\n+        assertEquals(\"round hour-1 failed\",\n+                parser.parse(\"February 12, 2002 13:00:00.000\"),\n+                CalendarUtils.round(date1, Calendar.HOUR));\n+        assertEquals(\"round hour-2 failed\",\n+                parser.parse(\"November 18, 2001 1:00:00.000\"),\n+                CalendarUtils.round(date2, Calendar.HOUR));\n+        assertEquals(\"round minute-1 failed\",\n+                parser.parse(\"February 12, 2002 12:35:00.000\"),\n+                CalendarUtils.round(date1, Calendar.MINUTE));\n+        assertEquals(\"round minute-2 failed\",\n+                parser.parse(\"November 18, 2001 1:23:00.000\"),\n+                CalendarUtils.round(date2, Calendar.MINUTE));\n+        assertEquals(\"round second-1 failed\",\n+                parser.parse(\"February 12, 2002 12:34:57.000\"),\n+                CalendarUtils.round(date1, Calendar.SECOND));\n+        assertEquals(\"round second-2 failed\",\n+                parser.parse(\"November 18, 2001 1:23:11.000\"),\n+                CalendarUtils.round(date2, Calendar.SECOND));\n+    }\n+\n+    /**\n+     * Tests various values with the trunc method\n+     */\n+    public void testTrunc() throws Exception {\n+        assertEquals(\"trunc year-1 failed\",\n+                new Date(\"2002 January 1\"),\n+                CalendarUtils.trunc(date1, Calendar.YEAR));\n+        assertEquals(\"trunc year-2 failed\",\n+                new Date(\"2001 January 1\"),\n+                CalendarUtils.trunc(date2, Calendar.YEAR));\n+        assertEquals(\"trunc month-1 failed\",\n+                new Date(\"2002 February 1\"),\n+                CalendarUtils.trunc(date1, Calendar.MONTH));\n+        assertEquals(\"trunc month-2 failed\",\n+                new Date(\"2001 November 1\"),\n+                CalendarUtils.trunc(date2, Calendar.MONTH));\n+        assertEquals(\"trunc semimonth-1 failed\",\n+                new Date(\"2002 February 1\"),\n+                CalendarUtils.trunc(date1, CalendarUtils.SEMI_MONTH));\n+        assertEquals(\"trunc semimonth-2 failed\",\n+                new Date(\"2001 November 16\"),\n+                CalendarUtils.trunc(date2, CalendarUtils.SEMI_MONTH));\n+        assertEquals(\"trunc date-1 failed\",\n+                new Date(\"2002 February 12\"),\n+                CalendarUtils.trunc(date1, Calendar.DATE));\n+        assertEquals(\"trunc date-2 failed\",\n+                new Date(\"2001 November 18\"),\n+                CalendarUtils.trunc(date2, Calendar.DATE));\n+        assertEquals(\"trunc hour-1 failed\",\n+                parser.parse(\"February 12, 2002 12:00:00.000\"),\n+                CalendarUtils.trunc(date1, Calendar.HOUR));\n+        assertEquals(\"trunc hour-2 failed\",\n+                parser.parse(\"November 18, 2001 1:00:00.000\"),\n+                CalendarUtils.trunc(date2, Calendar.HOUR));\n+        assertEquals(\"trunc minute-1 failed\",\n+                parser.parse(\"February 12, 2002 12:34:00.000\"),\n+                CalendarUtils.trunc(date1, Calendar.MINUTE));\n+        assertEquals(\"trunc minute-2 failed\",\n+                parser.parse(\"November 18, 2001 1:23:00.000\"),\n+                CalendarUtils.trunc(date2, Calendar.MINUTE));\n+        assertEquals(\"trunc second-1 failed\",\n+                parser.parse(\"February 12, 2002 12:34:56.000\"),\n+                CalendarUtils.trunc(date1, Calendar.SECOND));\n+        assertEquals(\"trunc second-2 failed\",\n+                parser.parse(\"November 18, 2001 1:23:11.000\"),\n+                CalendarUtils.trunc(date2, Calendar.SECOND));\n+\n+    }\n+\n+    /**\n+     * Tests the parse method, which is supposed to handle various strings\n+     * as flexibly as CVS supports.\n+     */\n+    public void testParse() throws Exception {\n+        //This is difficult to test since the \"now\" used in the\n+        //  parse function cannot be controlled.  We could possibly control\n+        //  it by trying before and after and making sure the value we expect\n+        //  is between the two values calculated.\n+        //For now we're just using the custom assertEquals that takes a delta\n+\n+        Calendar now = null;\n+\n+        now = Calendar.getInstance();\n+        now.add(Calendar.MINUTE, -1);\n+        assertEquals(\"parse 1 minute ago\",\n+                now, CalendarUtils.parse(\"1 minute ago\"), 50);\n+        now = Calendar.getInstance();\n+        now.add(Calendar.MINUTE, -8);\n+        assertEquals(\"parse 8 minutes ago\",\n+                now, CalendarUtils.parse(\"8 minutes ago\"), 50);\n+\n+        now = Calendar.getInstance();\n+        now.add(Calendar.DATE, -1);\n+        assertEquals(\"parse yesterday\",\n+                now, CalendarUtils.parse(\"yesterday\"), 50);\n+\n+        now = Calendar.getInstance();\n+        now.add(Calendar.DATE, 1);\n+        assertEquals(\"parse tomorrow\",\n+                now, CalendarUtils.parse(\"tomorrow\"), 50);\n+\n+        now = Calendar.getInstance();\n+        //Sunday would be 1, Saturday would be 7, so we walk back up to 6 days.\n+        if (now.get(Calendar.DATE) == 1) {\n+            //If Sunday already, we go back a full week\n+            now.add(Calendar.DATE, -7);\n+        } else {\n+            now.add(Calendar.DATE, 1 - now.get(Calendar.DAY_OF_WEEK));\n+        }\n+        assertEquals(\"parse last Sunday\",\n+                now, CalendarUtils.parse(\"last Sunday\"), 50);\n+\n+        now = Calendar.getInstance();\n+        now.add(Calendar.DATE, -7);\n+        assertEquals(\"parse last week\",\n+                now, CalendarUtils.parse(\"last week\"), 50);\n+\n+        now = Calendar.getInstance();\n+        //January would be 0, December would be 11, so we walk back up to 11 months\n+        if (now.get(Calendar.MONTH) == 0) {\n+            //If January already, we go back a full year\n+            now.add(Calendar.MONTH, -12);\n+        } else {\n+            now.add(Calendar.MONTH, 0 - now.get(Calendar.MONTH));\n+        }\n+        assertEquals(\"parse last January\",\n+                now, CalendarUtils.parse(\"last January\"), 50);\n+    }\n+\n+    /**\n+     * Tests the calendar iterator for week ranges\n+     */\n+    public void testWeekIterator() throws Exception {\n+        Calendar now = Calendar.getInstance();\n+        Calendar today = CalendarUtils.trunc(now, Calendar.DATE);\n+        Calendar sunday = CalendarUtils.trunc(now, Calendar.DATE);\n+        sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK));\n+        Calendar monday = CalendarUtils.trunc(now, Calendar.DATE);\n+        if (monday.get(Calendar.DATE) == 1) {\n+            //This is sunday... roll back 6 days\n+            monday.add(Calendar.DATE, -6);\n+        } else {\n+            monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK));\n+        }\n+        Calendar centered = CalendarUtils.trunc(now, Calendar.DATE);\n+        centered.add(Calendar.DATE, -3);\n+\n+        Iterator it = CalendarUtils.getCalendarIterator(now, CalendarUtils.RANGE_WEEK_SUNDAY);\n+        assertWeekIterator(it, sunday);\n+        it = CalendarUtils.getCalendarIterator(now, CalendarUtils.RANGE_WEEK_MONDAY);\n+        assertWeekIterator(it, monday);\n+        it = CalendarUtils.getCalendarIterator(now, CalendarUtils.RANGE_WEEK_RELATIVE);\n+        assertWeekIterator(it, today);\n+        it = CalendarUtils.getCalendarIterator(now, CalendarUtils.RANGE_WEEK_CENTER);\n+        assertWeekIterator(it, centered);\n+    }\n+\n+    /**\n+     * Tests the calendar iterator for month-based ranges\n+     */\n+    public void testMonthIterator() throws Exception {\n+        Iterator it = CalendarUtils.getCalendarIterator(date1, CalendarUtils.RANGE_MONTH_SUNDAY);\n+        assertWeekIterator(it,\n+                new Date(\"January 27, 2002\"),\n+                new Date(\"March 2, 2002\"));\n+\n+        it = CalendarUtils.getCalendarIterator(date1, CalendarUtils.RANGE_MONTH_MONDAY);\n+        assertWeekIterator(it,\n+                new Date(\"January 28, 2002\"),\n+                new Date(\"March 3, 2002\"));\n+\n+        it = CalendarUtils.getCalendarIterator(date2, CalendarUtils.RANGE_MONTH_SUNDAY);\n+        assertWeekIterator(it,\n+                new Date(\"October 28, 2001\"),\n+                new Date(\"December 1, 2001\"));\n+\n+        it = CalendarUtils.getCalendarIterator(date2, CalendarUtils.RANGE_MONTH_MONDAY);\n+        assertWeekIterator(it,\n+                new Date(\"October 29, 2001\"),\n+                new Date(\"December 2, 2001\"));\n+    }\n+\n+    /**\n+     * This checks that this is a 7 element iterator of Calendar objects\n+     * that are dates (no time), and exactly 1 day spaced after each other.\n+     */\n+    private static void assertWeekIterator(Iterator it, Calendar start) {\n+        Calendar end = (Calendar) start.clone();\n+        end.add(Calendar.DATE, 6);\n+\n+        assertWeekIterator(it, start, end);\n+    }\n+\n+    /**\n+     * Convenience method for when working with Date objects\n+     */\n+    private static void assertWeekIterator(Iterator it, Date start, Date end) {\n+        Calendar calStart = Calendar.getInstance();\n+        calStart.setTime(start);\n+        Calendar calEnd = Calendar.getInstance();\n+        calEnd.setTime(end);\n+\n+        assertWeekIterator(it, calStart, calEnd);\n+    }\n+\n+    /**\n+     * This checks that this is a 7 divisble iterator of Calendar objects\n+     * that are dates (no time), and exactly 1 day spaced after each other\n+     * (in addition to the proper start and stop dates)\n+     */\n+    private static void assertWeekIterator(Iterator it, Calendar start, Calendar end) {\n+        Calendar cal = (Calendar) it.next();\n+        assertEquals(\"\", start, cal, 0);\n+        Calendar last = null;\n+        int count = 1;\n+        while (it.hasNext()) {\n+            //Check this is just a date (no time component)\n+            assertEquals(\"\", cal, CalendarUtils.trunc(cal, Calendar.DATE), 0);\n+\n+            last = cal;\n+            cal = (Calendar) it.next();\n+            count++;\n+\n+            //Check that this is one day more than the last date\n+            last.add(Calendar.DATE, 1);\n+            assertEquals(\"\", last, cal, 0);\n+        }\n+        if (count % 7 != 0) {\n+            throw new AssertionFailedError(\"There were \" + count + \" days in this iterator\");\n+        }\n+        assertEquals(\"\", end, cal, 0);\n+    }\n+\n+    /**\n+     * Used to check that Calendar objects are close enough\n+     * delta is in milliseconds\n+     */\n+    public static void assertEquals(String message, Calendar cal1, Calendar cal2, long delta) {\n+        if (Math.abs(cal1.getTime().getTime() - cal2.getTime().getTime()) > delta) {\n+            throw new AssertionFailedError(\n+                    message + \" expected \" + cal1.getTime() + \" but got \" + cal2.getTime());\n+        }\n+    }\n+}\n+\n--- a/src/test/org/apache/commons/lang/LangTestSuite.java\n+++ b/src/test/org/apache/commons/lang/LangTestSuite.java\n  *\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n  * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n- * @version $Id: LangTestSuite.java,v 1.9 2002/12/16 21:48:41 bayard Exp $\n+ * @version $Id: LangTestSuite.java,v 1.10 2002/12/16 21:55:20 bayard Exp $\n  */\n public class LangTestSuite extends TestCase {\n     \n         suite.setName(\"Commons-Lang Tests\");\n         suite.addTest(ArrayUtilsTest.suite());\n         suite.addTest(BooleanUtilsTest.suite());\n+        suite.addTest(CalendarUtilsTest.suite());\n         suite.addTest(CharSetUtilsTest.suite());\n         suite.addTest(ClassUtilsTest.suite());\n         suite.addTest(DateUtilsTest.suite());", "timestamp": 1040075720, "metainfo": ""}