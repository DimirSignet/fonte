{"sha": "695289c466e51ff7f211867dccbc755fd515fc43", "log": "[LANG-362] simplify ExtendedMessageFormat design; recycle as much of super implementation as possible  ", "commit": "\n--- a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n+++ b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n import java.text.MessageFormat;\n import java.text.ParsePosition;\n import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n import java.util.Locale;\n-\n-import org.apache.commons.lang.StringUtils;\n+import java.util.Map;\n+\n import org.apache.commons.lang.Validate;\n \n /**\n  * Extends <code>MessageFormat</code> to allow pluggable/additional formatting\n- * options for embedded format elements; requires a \"meta-format\", that is a\n- * <code>Format</code> capable of parsing and formatting other\n- * <code>Format</code>s.\n- * \n- * Limitations:\n- * <ul>\n- * <li><code>toPattern()</code> results are tailored to JDK 1.4+ output and\n- * will produce fairly drastically different results on earlier JDKs.</li>\n- * <li>Recursive choice formats do not inherit knowledge of the extended\n- * formatters and are limited to those available with\n- * <code>java.text.MessageFormat</code>.</li>\n- * </ul>\n+ * options for embedded format elements; requires elaboration.\n+ *\n+ * Note that the mutator methods for the replacement Formats are to be considered\n+ * unnecessary and thus have been disabled (UnsupportedOperationException).\n  * \n  * @author Matt Benson\n  * @since 2.4\n public class ExtendedMessageFormat extends MessageFormat {\n     private static final long serialVersionUID = -2362048321261811743L;\n \n-    /**\n-     * Get a default meta-format for the default Locale. This will produce\n-     * behavior identical to a <code>java.lang.MessageFormat</code> using the\n-     * default locale.\n-     * \n+    private static final String DUMMY_PATTERN = \"\";\n+    private static final String ESCAPED_QUOTE = \"''\";\n+    private static final char START_FMT = ',';\n+    private static final char END_FE = '}';\n+    private static final char START_FE = '{';\n+    private static final char QUOTE = '\\'';\n+\n+    private String toPattern;\n+    private Map registry;\n+\n+    /**\n+     * Create a new ExtendedMessageFormat for the default locale.\n+     * \n+     * @param pattern String\n+     * @throws IllegalArgumentException in case of a bad pattern.\n+     */\n+    public ExtendedMessageFormat(String pattern) {\n+        this(pattern, Locale.getDefault());\n+    }\n+\n+    /**\n+     * Create a new ExtendedMessageFormat.\n+     * \n+     * @param pattern String\n+     * @param locale Locale\n+     * @throws IllegalArgumentException in case of a bad pattern.\n+     */\n+    public ExtendedMessageFormat(String pattern, Locale locale) {\n+        this(pattern, locale, null);\n+    }\n+\n+    /**\n+     * Create a new ExtendedMessageFormat for the default locale.\n+     * \n+     * @param pattern String\n+     * @param registry Registry of format factories:  Map<String, FormatFactory>\n+     * @throws IllegalArgumentException in case of a bad pattern.\n+     */\n+    public ExtendedMessageFormat(String pattern, Map registry) {\n+        this(pattern, Locale.getDefault(), registry);\n+    }\n+\n+    /**\n+     * Create a new ExtendedMessageFormat.\n+     * \n+     * @param pattern String\n+     * @param locale Locale\n+     * @param registry Registry of format factories:  Map<String, FormatFactory>\n+     * @throws IllegalArgumentException in case of a bad pattern.\n+     */\n+    public ExtendedMessageFormat(String pattern, Locale locale, Map registry) {\n+        super(DUMMY_PATTERN, locale);\n+        this.registry = registry;\n+        applyPattern(pattern);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public String toPattern() {\n+        return toPattern;\n+    }\n+\n+    /**\n+     * Apply the specified pattern.\n+     * \n+     * @param pattern String\n+     */\n+    public final void applyPattern(String pattern) {\n+        if (registry == null) {\n+            super.applyPattern(pattern);\n+            toPattern = super.toPattern();\n+            return;\n+        }\n+        ArrayList foundFormats = new ArrayList();\n+        ArrayList foundDescriptions = new ArrayList();\n+        StringBuffer stripCustom = new StringBuffer(pattern.length());\n+\n+        ParsePosition pos = new ParsePosition(0);\n+        char[] c = pattern.toCharArray();\n+        int fmtCount = 0;\n+        while (pos.getIndex() < pattern.length()) {\n+            switch (c[pos.getIndex()]) {\n+            case QUOTE:\n+                appendQuotedString(pattern, pos, stripCustom, true);\n+                break;\n+            case START_FE:\n+                fmtCount++;\n+                seekNonWs(pattern, pos);\n+                int start = pos.getIndex();\n+                int index = readArgumentIndex(pattern, next(pos));\n+                stripCustom.append(START_FE).append(index);\n+                seekNonWs(pattern, pos);\n+                Format format = null;\n+                String formatDescription = null;\n+                if (c[pos.getIndex()] == START_FMT) {\n+                    formatDescription = parseFormatDescription(pattern,\n+                            next(pos));\n+                    format = getFormat(formatDescription);\n+                    if (format == null) {\n+                        stripCustom.append(START_FMT).append(formatDescription);\n+                    }\n+                }\n+                foundFormats.add(format);\n+                foundDescriptions.add(format == null ? null : formatDescription);\n+                Validate.isTrue(foundFormats.size() == fmtCount);\n+                Validate.isTrue(foundDescriptions.size() == fmtCount);\n+                if (c[pos.getIndex()] != END_FE) {\n+                    throw new IllegalArgumentException(\n+                            \"Unreadable format element at position \" + start);\n+                }\n+                // fall through\n+            default:\n+                stripCustom.append(c[pos.getIndex()]);\n+                next(pos);\n+            }\n+        }\n+        super.applyPattern(stripCustom.toString());\n+        toPattern = insertFormats(super.toPattern(), foundDescriptions);\n+        if (containsElements(foundFormats)) {\n+            Format[] origFormats = getFormats();\n+            for (int i = 0; i < origFormats.length; i++) {\n+                Format f = (Format) foundFormats.get(i);\n+                if (f != null) {\n+                    origFormats[i] = f;\n+                }\n+            }\n+            super.setFormats(origFormats);\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * UNSUPPORTED\n+     */\n+    public void setFormat(int formatElementIndex, Format newFormat) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * UNSUPPORTED\n+     */\n+    public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * UNSUPPORTED\n+     */\n+    public void setFormats(Format[] newFormats) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * UNSUPPORTED\n+     */\n+    public void setFormatsByArgumentIndex(Format[] newFormats) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Get a custom format from a format description.\n+     * \n+     * @param desc String\n      * @return Format\n      */\n-    public static Format createDefaultMetaFormat() {\n-        return createDefaultMetaFormat(Locale.getDefault());\n-    }\n-\n-    /**\n-     * Get a default meta-format for the specified Locale. This will produce\n-     * behavior identical to a <code>java.lang.MessageFormat</code> using\n-     * <code>locale</code>.\n-     * \n-     * @param locale the Locale for the resulting Format instance.\n-     * @return Format\n-     */\n-    public static Format createDefaultMetaFormat(Locale locale) {\n-        return DefaultMetaFormatFactory.getFormat(locale);\n-    }\n-\n-    /**\n-     * Conceptual demarcation of methods to parse the pattern.\n-     */\n-    private static class Parser {\n-        private static final String ESCAPED_QUOTE = \"''\";\n-        private static final char START_FMT = ',';\n-        private static final char END_FE = '}';\n-        private static final char START_FE = '{';\n-        private static final char QUOTE = '\\'';\n-\n-        /**\n-         * Strip all formats from the pattern.\n-         * \n-         * @param pattern String to strip\n-         * @return stripped pattern\n-         */\n-        private String stripFormats(String pattern) {\n-            StringBuffer sb = new StringBuffer(pattern.length());\n-            ParsePosition pos = new ParsePosition(0);\n-            char[] c = pattern.toCharArray();\n-            while (pos.getIndex() < pattern.length()) {\n-                switch (c[pos.getIndex()]) {\n-                case QUOTE:\n-                    appendQuotedString(pattern, pos, sb, true);\n-                    break;\n-                case START_FE:\n-                    int start = pos.getIndex();\n-                    readArgumentIndex(pattern, next(pos));\n-                    sb.append(c, start, pos.getIndex() - start);\n-                    if (c[pos.getIndex()] == START_FMT) {\n-                        eatFormat(pattern, next(pos));\n-                    }\n-                    if (c[pos.getIndex()] != END_FE) {\n-                        throw new IllegalArgumentException(\n-                                \"Unreadable format element at position \"\n-                                        + start);\n-                    }\n-                    // fall through\n-                default:\n-                    sb.append(c[pos.getIndex()]);\n-                    next(pos);\n-                }\n-            }\n-            return sb.toString();\n-        }\n-\n-        /**\n-         * Insert formats back into the pattern for toPattern() support.\n-         * \n-         * @param pattern source\n-         * @param formats the Formats to insert\n-         * @param metaFormat Format to format the Formats\n-         * @return full pattern\n-         */\n-        private String insertFormats(String pattern, Format[] formats,\n-                Format metaFormat) {\n-            if (formats == null || formats.length == 0) {\n-                return pattern;\n-            }\n-            StringBuffer sb = new StringBuffer(pattern.length() * 2);\n-            ParsePosition pos = new ParsePosition(0);\n-            int fe = -1;\n-            while (pos.getIndex() < pattern.length()) {\n-                char c = pattern.charAt(pos.getIndex());\n-                switch (c) {\n-                case QUOTE:\n-                    appendQuotedString(pattern, pos, sb, false);\n-                    break;\n-                case START_FE:\n+    private Format getFormat(String desc) {\n+        if (registry != null) {\n+            String name = desc;\n+            String args = null;\n+            int i = desc.indexOf(START_FMT);\n+            if (i > 0) {\n+                name = desc.substring(0, i).trim();\n+                args = desc.substring(i + 1).trim();\n+            }\n+            FormatFactory factory = (FormatFactory) registry.get(name);\n+            if (factory != null) {\n+                return factory.getFormat(name, args, getLocale());\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Read the argument index from the current format element\n+     * \n+     * @param pattern pattern to parse\n+     * @param pos current parse position\n+     * @return argument index\n+     */\n+    private int readArgumentIndex(String pattern, ParsePosition pos) {\n+        int start = pos.getIndex();\n+        seekNonWs(pattern, pos);\n+        StringBuffer result = new StringBuffer();\n+        boolean error = false;\n+        for (; !error && pos.getIndex() < pattern.length(); next(pos)) {\n+            char c = pattern.charAt(pos.getIndex());\n+            if (Character.isWhitespace(c)) {\n+                seekNonWs(pattern, pos);\n+                c = pattern.charAt(pos.getIndex());\n+                if (c != START_FMT && c != END_FE) {\n+                    error = true;\n+                    continue;\n+                }\n+            }\n+            if ((c == START_FMT || c == END_FE) && result.length() > 0) {\n+                try {\n+                    return Integer.parseInt(result.toString());\n+                } catch (NumberFormatException e) {\n+                    //we've already ensured only digits, so unless something outlandishly large was specified we should be okay.\n+                }\n+            }\n+            error = !Character.isDigit(c);\n+            result.append(c);\n+        }\n+        if (error) {\n+            throw new IllegalArgumentException(\n+                    \"Invalid format argument index at position \" + start + \": \"\n+                            + pattern.substring(start, pos.getIndex()));\n+        }\n+        throw new IllegalArgumentException(\n+                \"Unterminated format element at position \" + start);\n+    }\n+\n+    /**\n+     * Parse the format component of a format element.\n+     * \n+     * @param pattern string to parse\n+     * @param pos current parse position\n+     * @return Format description String\n+     */\n+    private String parseFormatDescription(String pattern, ParsePosition pos) {\n+        int start = pos.getIndex();\n+        seekNonWs(pattern, pos);\n+        int text = pos.getIndex();\n+        int depth = 1;\n+        for (; pos.getIndex() < pattern.length(); next(pos)) {\n+            switch (pattern.charAt(pos.getIndex())) {\n+            case START_FE:\n+                depth++;\n+                break;\n+            case END_FE:\n+                depth--;\n+                if (depth == 0) {\n+                    return pattern.substring(text, pos.getIndex());\n+                }\n+                break;\n+            case QUOTE:\n+                getQuotedString(pattern, pos, false);\n+                break;\n+            }\n+        }\n+        throw new IllegalArgumentException(\n+                \"Unterminated format element at position \" + start);\n+    }\n+\n+    /**\n+     * Insert formats back into the pattern for toPattern() support.\n+     *\n+     * @param pattern source\n+     * @param formats the Formats to insert\n+     * @param metaFormat Format to format the Formats\n+     * @return full pattern\n+     */\n+    private String insertFormats(String pattern, ArrayList customPatterns) {\n+        if (!containsElements(customPatterns)) {\n+            return pattern;\n+        }\n+        StringBuffer sb = new StringBuffer(pattern.length() * 2);\n+        ParsePosition pos = new ParsePosition(0);\n+        int fe = -1;\n+        int depth = 0;\n+        while (pos.getIndex() < pattern.length()) {\n+            char c = pattern.charAt(pos.getIndex());\n+            switch (c) {\n+            case QUOTE:\n+                appendQuotedString(pattern, pos, sb, false);\n+                break;\n+            case START_FE:\n+                depth++;\n+                if (depth == 1) {\n                     fe++;\n                     sb.append(START_FE).append(\n                             readArgumentIndex(pattern, next(pos)));\n-                    if (formats[fe] != null) {\n-                        String formatName = metaFormat.format(formats[fe]);\n-                        if (StringUtils.isNotEmpty(formatName)) {\n-                            sb.append(START_FMT).append(formatName);\n-                        }\n+                    String customPattern = (String) customPatterns.get(fe);\n+                    if (customPattern != null) {\n+                        sb.append(START_FMT).append(customPattern);\n                     }\n-                    break;\n-                default:\n-                    sb.append(pattern.charAt(pos.getIndex()));\n-                    next(pos);\n-                }\n-            }\n-            return sb.toString();\n-        }\n-\n-        /**\n-         * Parse the formats from the given pattern.\n-         * \n-         * @param pattern String to parse\n-         * @param metaFormat Format to parse the Formats\n-         * @return array of parsed Formats\n-         */\n-        private Format[] parseFormats(String pattern, Format metaFormat) {\n-            ArrayList result = new ArrayList();\n-            ParsePosition pos = new ParsePosition(0);\n-            while (pos.getIndex() < pattern.length()) {\n-                switch (pattern.charAt(pos.getIndex())) {\n-                case QUOTE:\n-                    getQuotedString(pattern, next(pos), true);\n-                    break;\n-                case START_FE:\n-                    int start = pos.getIndex();\n-                    readArgumentIndex(pattern, next(pos));\n-                    if (pattern.charAt(pos.getIndex()) == START_FMT) {\n-                        seekNonWs(pattern, next(pos));\n-                    }\n-                    result.add(metaFormat.parseObject(pattern, pos));\n-                    seekNonWs(pattern, pos);\n-                    if (pattern.charAt(pos.getIndex()) != END_FE) {\n-                        throw new IllegalArgumentException(\n-                                \"Unreadable format element at position \"\n-                                        + start);\n-                    }\n-                    // fall through\n-                default:\n-                    next(pos);\n-                }\n-            }\n-            return (Format[]) result.toArray(new Format[result.size()]);\n-        }\n-\n-        /**\n-         * Consume whitespace from the current parse position.\n-         * \n-         * @param pattern String to read\n-         * @param pos current position\n-         */\n-        private void seekNonWs(String pattern, ParsePosition pos) {\n-            int len = 0;\n-            char[] buffer = pattern.toCharArray();\n-            do {\n-                len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n-                pos.setIndex(pos.getIndex() + len);\n-            } while (len > 0 && pos.getIndex() < pattern.length());\n-        }\n-\n-        /**\n-         * Convenience method to advance parse position by 1\n-         * \n-         * @param pos ParsePosition\n-         * @return <code>pos</code>\n-         */\n-        private ParsePosition next(ParsePosition pos) {\n-            pos.setIndex(pos.getIndex() + 1);\n-            return pos;\n-        }\n-\n-        /**\n-         * Read the argument index from the current format element\n-         * \n-         * @param pattern pattern to parse\n-         * @param pos current parse position\n-         * @return argument index as string\n-         */\n-        private String readArgumentIndex(String pattern, ParsePosition pos) {\n-            int start = pos.getIndex();\n-            for (; pos.getIndex() < pattern.length(); next(pos)) {\n-                char c = pattern.charAt(pos.getIndex());\n-                if (c == START_FMT || c == END_FE) {\n-                    return pattern.substring(start, pos.getIndex());\n-                }\n-                if (!Character.isDigit(c)) {\n-                    throw new IllegalArgumentException(\n-                            \"Invalid format argument index at position \"\n-                                    + start);\n-                }\n-            }\n-            throw new IllegalArgumentException(\n-                    \"Unterminated format element at position \" + start);\n-        }\n-\n-        /**\n-         * Consume a quoted string, adding it to <code>appendTo</code> if\n-         * specified.\n-         * \n-         * @param pattern pattern to parse\n-         * @param pos current parse position\n-         * @param appendTo optional StringBuffer to append\n-         * @param escapingOn whether to process escaped quotes\n-         * @return <code>appendTo</code>\n-         */\n-        private StringBuffer appendQuotedString(String pattern,\n-                ParsePosition pos, StringBuffer appendTo, boolean escapingOn) {\n-            int start = pos.getIndex();\n-            char[] c = pattern.toCharArray();\n-            if (escapingOn && c[start] == QUOTE) {\n-                return appendTo == null ? null : appendTo.append(QUOTE);\n-            }\n-            int lastHold = start;\n-            for (int i = pos.getIndex(); i < pattern.length(); i++) {\n-                if (escapingOn\n-                        && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n-                    appendTo.append(c, lastHold, pos.getIndex() - lastHold)\n-                            .append(QUOTE);\n-                    pos.setIndex(i + ESCAPED_QUOTE.length());\n-                    lastHold = pos.getIndex();\n-                    continue;\n-                }\n-                switch (c[pos.getIndex()]) {\n-                case QUOTE:\n-                    next(pos);\n-                    return appendTo == null ? null : appendTo.append(c,\n-                            lastHold, pos.getIndex() - lastHold);\n-                default:\n-                    next(pos);\n-                }\n-            }\n-            throw new IllegalArgumentException(\n-                    \"Unterminated quoted string at position \" + start);\n-        }\n-\n-        /**\n-         * Consume quoted string only\n-         * \n-         * @param pattern pattern to parse\n-         * @param pos current parse position\n-         * @param escapingOn whether to process escaped quotes\n-         */\n-        private void getQuotedString(String pattern, ParsePosition pos,\n-                boolean escapingOn) {\n-            appendQuotedString(pattern, pos, null, escapingOn);\n-        }\n-\n-        /**\n-         * Consume the entire format found at the current position.\n-         * \n-         * @param pattern string to parse\n-         * @param pos current parse position\n-         */\n-        private void eatFormat(String pattern, ParsePosition pos) {\n-            int start = pos.getIndex();\n-            int depth = 1;\n-            for (; pos.getIndex() < pattern.length(); next(pos)) {\n-                switch (pattern.charAt(pos.getIndex())) {\n-                case START_FE:\n-                    depth++;\n-                    break;\n-                case END_FE:\n-                    depth--;\n-                    if (depth == 0) {\n-                        return;\n-                    }\n-                    break;\n-                case QUOTE:\n-                    getQuotedString(pattern, pos, false);\n-                    break;\n-                }\n-            }\n-            throw new IllegalArgumentException(\n-                    \"Unterminated format element at position \" + start);\n-        }\n-    }\n-\n-    private static final Parser PARSER = new Parser();\n-\n-    private Format metaFormat;\n-    private String strippedPattern;\n-\n-    /**\n-     * Create a new ExtendedMessageFormat for the default locale.\n-     * \n-     * @param pattern String\n-     * @param metaFormat Format\n-     * @throws IllegalArgumentException if <code>metaFormat</code> is\n-     *             <code>null</code> or in case of a bad pattern.\n-     */\n-    public ExtendedMessageFormat(String pattern, Format metaFormat) {\n-        this(pattern, Locale.getDefault(), metaFormat);\n-    }\n-\n-    /**\n-     * Create a new ExtendedMessageFormat.\n-     * \n-     * @param pattern String\n-     * @param locale Locale\n-     * @param metaFormat Format\n-     * @throws IllegalArgumentException if <code>metaFormat</code> is\n-     *             <code>null</code> or in case of a bad pattern.\n-     */\n-    public ExtendedMessageFormat(String pattern, Locale locale,\n-            Format metaFormat) {\n-        /*\n-         * We have to do some acrobatics here: the call to the super constructor\n-         * will invoke applyPattern(), but we don't want to apply the pattern\n-         * until we've installed our custom metaformat. So we check for that in\n-         * our (final) applyPattern implementation, and re-call at the end of\n-         * this constructor.\n-         */\n-        super(pattern);\n-        setLocale(locale);\n-        setMetaFormat(metaFormat);\n-        applyPattern(pattern);\n-    }\n-\n-    /**\n-     * Apply the specified pattern.\n-     * \n-     * @param pattern String\n-     */\n-    public final void applyPattern(String pattern) {\n-        if (metaFormat == null) {\n-            return;\n-        }\n-        applyPatternPre(pattern);\n-        strippedPattern = PARSER.stripFormats(pattern);\n-        super.applyPattern(strippedPattern);\n-        setFormats(PARSER.parseFormats(pattern, metaFormat));\n-        applyPatternPost(pattern);\n-    }\n-\n-    /**\n-     * Pre-execution hook by means of which a subclass can customize the\n-     * behavior of the final applyPattern implementation.\n-     * \n-     * @param pattern String\n-     */\n-    protected void applyPatternPre(String pattern) {\n-        // noop\n-    }\n-\n-    /**\n-     * Post-execution hook by means of which a subclass can customize the\n-     * behavior of the final applyPattern implementation.\n-     * \n-     * @param pattern String\n-     */\n-    protected void applyPatternPost(String pattern) {\n-        // noop\n-    }\n-\n-    /**\n-     * Render the pattern from the current state of the\n-     * <code>ExtendedMessageFormat</code>.\n-     * \n-     * @return pattern String\n-     */\n-    public String toPattern() {\n-        return PARSER.insertFormats(strippedPattern, getFormats(), metaFormat);\n-    }\n-\n-    /**\n-     * Get the meta-format currently configured.\n-     * \n-     * @return Format.\n-     */\n-    public synchronized Format getMetaFormat() {\n-        return metaFormat;\n-    }\n-\n-    /**\n-     * Set the meta-format. Has no effect until a subsequent call to\n-     * {@link #applyPattern(String)}.\n-     * \n-     * @param metaFormat the Format metaFormat to set.\n-     */\n-    public synchronized void setMetaFormat(Format metaFormat) {\n-        Validate.notNull(metaFormat, \"metaFormat is null\");\n-        this.metaFormat = metaFormat;\n-    }\n-\n+                }\n+                break;\n+            case END_FE:\n+                depth--;\n+                //fall through:\n+            default:\n+                sb.append(c);\n+                next(pos);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Consume whitespace from the current parse position.\n+     * \n+     * @param pattern String to read\n+     * @param pos current position\n+     */\n+    private void seekNonWs(String pattern, ParsePosition pos) {\n+        int len = 0;\n+        char[] buffer = pattern.toCharArray();\n+        do {\n+            len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n+            pos.setIndex(pos.getIndex() + len);\n+        } while (len > 0 && pos.getIndex() < pattern.length());\n+    }\n+\n+    /**\n+     * Convenience method to advance parse position by 1\n+     * \n+     * @param pos ParsePosition\n+     * @return <code>pos</code>\n+     */\n+    private ParsePosition next(ParsePosition pos) {\n+        pos.setIndex(pos.getIndex() + 1);\n+        return pos;\n+    }\n+\n+    /**\n+     * Consume a quoted string, adding it to <code>appendTo</code> if\n+     * specified.\n+     * \n+     * @param pattern pattern to parse\n+     * @param pos current parse position\n+     * @param appendTo optional StringBuffer to append\n+     * @param escapingOn whether to process escaped quotes\n+     * @return <code>appendTo</code>\n+     */\n+    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n+            StringBuffer appendTo, boolean escapingOn) {\n+        int start = pos.getIndex();\n+        char[] c = pattern.toCharArray();\n+        if (escapingOn && c[start] == QUOTE) {\n+            return appendTo == null ? null : appendTo.append(QUOTE);\n+        }\n+        int lastHold = start;\n+        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n+            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n+                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n+                        QUOTE);\n+                pos.setIndex(i + ESCAPED_QUOTE.length());\n+                lastHold = pos.getIndex();\n+                continue;\n+            }\n+            switch (c[pos.getIndex()]) {\n+            case QUOTE:\n+                next(pos);\n+                return appendTo == null ? null : appendTo.append(c, lastHold,\n+                        pos.getIndex() - lastHold);\n+            default:\n+                next(pos);\n+            }\n+        }\n+        throw new IllegalArgumentException(\n+                \"Unterminated quoted string at position \" + start);\n+    }\n+\n+    /**\n+     * Consume quoted string only\n+     * \n+     * @param pattern pattern to parse\n+     * @param pos current parse position\n+     * @param escapingOn whether to process escaped quotes\n+     */\n+    private void getQuotedString(String pattern, ParsePosition pos,\n+            boolean escapingOn) {\n+        appendQuotedString(pattern, pos, null, escapingOn);\n+    }\n+\n+    /**\n+     * Learn whether the specified Collection contains non-null elements.\n+     * @param coll to check\n+     * @return <code>true</code> if some Object was found, <code>false</code> otherwise.\n+     */\n+    private boolean containsElements(Collection coll) {\n+        if (coll == null || coll.size() == 0) {\n+            return false;\n+        }\n+        for (Iterator iter = coll.iterator(); iter.hasNext();) {\n+            if (iter.next() != null) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/FormatFactory.java\n+package org.apache.commons.lang.text;\n+\n+import java.text.Format;\n+import java.util.Locale;\n+\n+/**\n+ * Format factory.\n+ * @since 2.4\n+ * @author Niall Pemberton\n+ * @version $Id$\n+ */\n+public interface FormatFactory {\n+\n+    /**\n+     * Create or retrieve a format instance.\n+     *\n+     * @param name The format type name\n+     * @param arguments Arguments used to create the format instance\n+     * @param locale The locale, may be null\n+     * @return The format instance\n+     */\n+    Format getFormat(String name, String arguments, Locale locale);\n+\n+}\n--- a/src/test/org/apache/commons/lang/text/ExtendedMessageFormatBaselineTest.java\n+++ b/src/test/org/apache/commons/lang/text/ExtendedMessageFormatBaselineTest.java\n      * {@inheritDoc}\n      */\n     protected MessageFormat createMessageFormat(String pattern, Locale locale) {\n-        return new ExtendedMessageFormat(pattern, locale, ExtendedMessageFormat\n-                .createDefaultMetaFormat(locale));\n+        return new ExtendedMessageFormat(pattern, locale);\n     }\n \n }\n--- a/src/test/org/apache/commons/lang/text/MessageFormatExtensionTest.java\n+++ b/src/test/org/apache/commons/lang/text/MessageFormatExtensionTest.java\n import java.util.Calendar;\n import java.util.Date;\n import java.util.GregorianCalendar;\n+import java.util.HashMap;\n import java.util.Locale;\n \n /**\n      * {@inheritDoc}\n      */\n     protected MessageFormat createMessageFormat(String pattern, Locale locale) {\n-        return new ExtendedMessageFormat(pattern, locale,\n-                new MultiFormat.Builder().add(\n-                        new NameKeyedMetaFormat.Builder().put(\"properName\",\n-                                new ProperNameCapitalizationFormat())\n-                                .toNameKeyedMetaFormat()).add(\n-                        ExtendedMessageFormat.createDefaultMetaFormat(locale))\n-                        .toMultiFormat());\n+        final ProperNameCapitalizationFormat properNameCapitalizationFormat = new ProperNameCapitalizationFormat();\n+        final FormatFactory ff = new FormatFactory() {\n+            public Format getFormat(String name, String arguments, Locale locale) {\n+                return \"properName\".equals(name) ? properNameCapitalizationFormat : null;\n+            }\n+        };\n+        return new ExtendedMessageFormat(pattern, locale, new HashMap() { { put(\"properName\", ff); }});\n     }\n \n     public void testProperName() {", "timestamp": 1203969078, "metainfo": ""}