{"sha": "2ec05c490879d0bb96ca4a6d2e843fde9f533b06", "log": "merge [LANG-416] from LANG_POST_2_4 branch  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/reflect/ConstructorUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Modifier;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.ClassUtils;\n+\n+/**\n+ * <p> Utility reflection methods focussed on constructors, modelled after {@link MethodUtils}. </p>\n+ *\n+ * <h3>Known Limitations</h3>\n+ * <h4>Accessing Public Constructors In A Default Access Superclass</h4>\n+ * <p>There is an issue when invoking public constructors contained in a default access superclass.\n+ * Reflection locates these constructors fine and correctly assigns them as public.\n+ * However, an <code>IllegalAccessException</code> is thrown if the constructors is invoked.</p>\n+ *\n+ * <p><code>ConstructorUtils</code> contains a workaround for this situation.\n+ * It will attempt to call <code>setAccessible</code> on this constructor.\n+ * If this call succeeds, then the method can be invoked as normal.\n+ * This call will only succeed when the application has sufficient security privilages.\n+ * If this call fails then a warning will be logged and the method may fail.</p>\n+ *\n+ * @author Craig R. McClanahan\n+ * @author Ralph Schaer\n+ * @author Chris Audley\n+ * @author Rey Francois\n+ * @author Gregor Rayman\n+ * @author Jan Sorensen\n+ * @author Robert Burrell Donkin\n+ * @author Rodney Waldhoff\n+ * @since 2.5\n+ * @version $Id$\n+ */\n+public class ConstructorUtils {\n+\n+    /**\n+     * <p>ConstructorUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as\n+     * <code>ConstructorUtils.invokeConstructor(cls, args)</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public ConstructorUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * <p>Convenience method returning new instance of <code>klazz</code> using a single argument constructor.\n+     * The formal parameter type is inferred from the actual values of <code>arg</code>.\n+     * See {@link #invokeExactConstructor(Class, Object[], Class[])} for more details.</p>\n+     *\n+     * <p>The signatures should be assignment compatible.</p>\n+     *\n+     * @param cls the class to be constructed.\n+     * @param arg the actual argument\n+     * @return new instance of <code>klazz</code>\n+     *\n+     * @throws NoSuchMethodException If the constructor cannot be found\n+     * @throws IllegalAccessException If an error occurs accessing the constructor\n+     * @throws InvocationTargetException If an error occurs invoking the constructor\n+     * @throws InstantiationException If an error occurs instantiating the class\n+     *\n+     * @see #invokeConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])\n+     */\n+    public static Object invokeConstructor(Class cls, Object arg)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException, InstantiationException {\n+        return invokeConstructor(cls, new Object[] { arg });\n+    }\n+\n+    /**\n+     * <p>Returns new instance of <code>klazz</code> created using the actual arguments <code>args</code>.\n+     * The formal parameter types are inferred from the actual values of <code>args</code>.\n+     * See {@link #invokeExactConstructor(Class, Object[], Class[])} for more details.</p>\n+     *\n+     * <p>The signatures should be assignment compatible.</p>\n+     *\n+     * @param cls the class to be constructed.\n+     * @param args actual argument array\n+     * @return new instance of <code>klazz</code>\n+     *\n+     * @throws NoSuchMethodException If the constructor cannot be found\n+     * @throws IllegalAccessException If an error occurs accessing the constructor\n+     * @throws InvocationTargetException If an error occurs invoking the constructor\n+     * @throws InstantiationException If an error occurs instantiating the class\n+     *\n+     * @see #invokeConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])\n+     */\n+    public static Object invokeConstructor(Class cls, Object[] args)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException, InstantiationException {\n+        if (null == args) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        Class parameterTypes[] = new Class[args.length];\n+        for (int i = 0; i < args.length; i++) {\n+            parameterTypes[i] = args[i].getClass();\n+        }\n+        return invokeConstructor(cls, args, parameterTypes);\n+    }\n+\n+    /**\n+     * <p>Returns new instance of <code>klazz</code> created using constructor\n+     * with signature <code>parameterTypes</code> and actual arguments <code>args</code>.</p>\n+     *\n+     * <p>The signatures should be assignment compatible.</p>\n+     *\n+     * @param cls the class to be constructed.\n+     * @param args actual argument array\n+     * @param parameterTypes parameter types array\n+     * @return new instance of <code>klazz</code>\n+     *\n+     * @throws NoSuchMethodException if matching constructor cannot be found\n+     * @throws IllegalAccessException thrown on the constructor's invocation\n+     * @throws InvocationTargetException thrown on the constructor's invocation\n+     * @throws InstantiationException thrown on the constructor's invocation\n+     * @see Constructor#newInstance\n+     */\n+    public static Object invokeConstructor(Class cls, Object[] args,\n+            Class[] parameterTypes) throws NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException,\n+            InstantiationException {\n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        Constructor ctor = getMatchingAccessibleConstructor(cls, parameterTypes);\n+        if (null == ctor) {\n+            throw new NoSuchMethodException(\n+                    \"No such accessible constructor on object: \"\n+                            + cls.getName());\n+        }\n+        return ctor.newInstance(args);\n+    }\n+\n+    /**\n+     * <p>Convenience method returning new instance of <code>klazz</code> using a single argument constructor.\n+     * The formal parameter type is inferred from the actual values of <code>arg</code>.\n+     * See {@link #invokeExactConstructor(Class, Object[], Class[])} for more details.</p>\n+     *\n+     * <p>The signatures should match exactly.</p>\n+     *\n+     * @param cls the class to be constructed.\n+     * @param arg the actual argument\n+     * @return new instance of <code>klazz</code>\n+     *\n+     * @throws NoSuchMethodException If the constructor cannot be found\n+     * @throws IllegalAccessException If an error occurs accessing the constructor\n+     * @throws InvocationTargetException If an error occurs invoking the constructor\n+     * @throws InstantiationException If an error occurs instantiating the class\n+     *\n+     * @see #invokeExactConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])\n+     */\n+    public static Object invokeExactConstructor(Class cls, Object arg)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException, InstantiationException {\n+        return invokeExactConstructor(cls, new Object[] { arg });\n+    }\n+\n+    /**\n+     * <p>Returns new instance of <code>klazz</code> created using the actual arguments <code>args</code>.\n+     * The formal parameter types are inferred from the actual values of <code>args</code>.\n+     * See {@link #invokeExactConstructor(Class, Object[], Class[])} for more details.</p>\n+     *\n+     * <p>The signatures should match exactly.</p>\n+     *\n+     * @param cls the class to be constructed.\n+     * @param args actual argument array\n+     * @return new instance of <code>klazz</code>\n+     *\n+     * @throws NoSuchMethodException If the constructor cannot be found\n+     * @throws IllegalAccessException If an error occurs accessing the constructor\n+     * @throws InvocationTargetException If an error occurs invoking the constructor\n+     * @throws InstantiationException If an error occurs instantiating the class\n+     *\n+     * @see #invokeExactConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])\n+     */\n+    public static Object invokeExactConstructor(Class cls, Object[] args)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException, InstantiationException {\n+        if (null == args) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        int arguments = args.length;\n+        Class parameterTypes[] = new Class[arguments];\n+        for (int i = 0; i < arguments; i++) {\n+            parameterTypes[i] = args[i].getClass();\n+        }\n+        return invokeExactConstructor(cls, args, parameterTypes);\n+    }\n+\n+    /**\n+     * <p>Returns new instance of <code>klazz</code> created using constructor\n+     * with signature <code>parameterTypes</code> and actual arguments\n+     * <code>args</code>.</p>\n+     *\n+     * <p>The signatures should match exactly.</p>\n+     *\n+     * @param cls the class to be constructed.\n+     * @param args actual argument array\n+     * @param parameterTypes parameter types array\n+     * @return new instance of <code>klazz</code>\n+     *\n+     * @throws NoSuchMethodException if matching constructor cannot be found\n+     * @throws IllegalAccessException thrown on the constructor's invocation\n+     * @throws InvocationTargetException thrown on the constructor's invocation\n+     * @throws InstantiationException thrown on the constructor's invocation\n+     * @see Constructor#newInstance\n+     */\n+    public static Object invokeExactConstructor(Class cls, Object[] args,\n+            Class[] parameterTypes) throws NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException,\n+            InstantiationException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        Constructor ctor = getAccessibleConstructor(cls, parameterTypes);\n+        if (null == ctor) {\n+            throw new NoSuchMethodException(\n+                    \"No such accessible constructor on object: \"\n+                            + cls.getName());\n+        }\n+        return ctor.newInstance(args);\n+    }\n+\n+    /**\n+     * Returns a constructor with single argument.\n+     * @param cls the class to be constructed\n+     * @param parameterType The constructor parameter type\n+     * @return null if matching accessible constructor can not be found.\n+     * @see Class#getConstructor\n+     * @see #getAccessibleConstructor(java.lang.reflect.Constructor)\n+     */\n+    public static Constructor getAccessibleConstructor(Class cls,\n+            Class parameterType) {\n+        return getAccessibleConstructor(cls, new Class[] { parameterType });\n+    }\n+\n+    /**\n+     * Returns a constructor given a class and signature.\n+     * @param cls the class to be constructed\n+     * @param parameterTypes the parameter array\n+     * @return null if matching accessible constructor can not be found\n+     * @see Class#getConstructor\n+     * @see #getAccessibleConstructor(java.lang.reflect.Constructor)\n+     */\n+    public static Constructor getAccessibleConstructor(Class cls,\n+            Class[] parameterTypes) {\n+        try {\n+            return getAccessibleConstructor(cls.getConstructor(parameterTypes));\n+        } catch (NoSuchMethodException e) {\n+            return (null);\n+        }\n+    }\n+\n+    /**\n+     * Returns accessible version of the given constructor.\n+     * @param ctor prototype constructor object.\n+     * @return <code>null</code> if accessible constructor can not be found.\n+     * @see java.lang.SecurityManager\n+     */\n+    public static Constructor getAccessibleConstructor(Constructor ctor) {\n+        return MemberUtils.isAccessible(ctor)\n+                && Modifier.isPublic(ctor.getDeclaringClass().getModifiers()) ? ctor\n+                : null;\n+    }\n+\n+    /**\n+     * <p>Find an accessible constructor with compatible parameters.\n+     * Compatible parameters mean that every method parameter is assignable from\n+     * the given parameters. In other words, it finds constructor that will take\n+     * the parameters given.</p>\n+     *\n+     * <p>First it checks if there is constructor matching the exact signature.\n+     * If no such, all the constructors of the class are tested if their signatures\n+     * are assignment compatible with the parameter types.\n+     * The first matching constructor is returned.</p>\n+     *\n+     * @param cls find constructor for this class\n+     * @param parameterTypes find method with compatible parameters\n+     * @return a valid Constructor object. If there's no matching constructor, returns <code>null</code>.\n+     */\n+    public static Constructor getMatchingAccessibleConstructor(Class cls,\n+            Class[] parameterTypes) {\n+        // see if we can find the constructor directly\n+        // most of the time this works and it's much faster\n+        try {\n+            Constructor ctor = cls.getConstructor(parameterTypes);\n+            MemberUtils.setAccessibleWorkaround(ctor);\n+            return ctor;\n+        } catch (NoSuchMethodException e) { /* SWALLOW */\n+        }\n+        Constructor result = null;\n+        // search through all constructors\n+        Constructor[] ctors = cls.getConstructors();\n+        for (int i = 0; i < ctors.length; i++) {\n+            // compare parameters\n+            if (ClassUtils.isAssignable(parameterTypes, ctors[i]\n+                    .getParameterTypes(), true)) {\n+                // get accessible version of method\n+                Constructor ctor = getAccessibleConstructor(ctors[i]);\n+                if (ctor != null) {\n+                    MemberUtils.setAccessibleWorkaround(ctor);\n+                    if (result == null\n+                            || MemberUtils.compareParameterTypes(ctor\n+                                    .getParameterTypes(), result\n+                                    .getParameterTypes(), parameterTypes) < 0) {\n+                        result = ctor;\n+                    }\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/reflect/FieldUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+/**\n+ * Utilities for working with fields by reflection. Adapted and refactored\n+ * from the dormant [reflect] Commons sandbox component.\n+ * <p>\n+ * The ability is provided to break the scoping restrictions coded by the\n+ * programmer. This can allow fields to be changed that shouldn't be. This\n+ * facility should be used with care.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ * @since 2.5\n+ * @version $Id$\n+ */\n+public class FieldUtils {\n+\n+    /**\n+     * FieldUtils instances should NOT be constructed in standard programming.\n+     * <p>\n+     * This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.\n+     */\n+    public FieldUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Gets an accessible <code>Field</code> by name repecting scope.\n+     * Superclasses/interfaces will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     */\n+    public static Field getField(Class cls, String fieldName) {\n+        Field field = getField(cls, fieldName, false);\n+        MemberUtils.setAccessibleWorkaround(field);\n+        return field;\n+    }\n+\n+    /**\n+     * Gets an accessible <code>Field</code> by name breaking scope\n+     * if requested. Superclasses/interfaces will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     */\n+    public static Field getField(final Class cls, String fieldName, boolean forceAccess) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        if (fieldName == null) {\n+            throw new IllegalArgumentException(\"The field name must not be null\");\n+        }\n+        // Sun Java 1.3 has a bugged implementation of getField hence we write the\n+        // code ourselves\n+\n+        // getField() will return the Field object with the declaring class\n+        // set correctly to the class that declares the field. Thus requesting the\n+        // field on a subclass will return the field from the superclass.\n+        //\n+        // priority order for lookup:\n+        // searchclass private/protected/package/public\n+        // superclass protected/package/public\n+        //  private/different package blocks access to further superclasses\n+        // implementedinterface public\n+\n+        // check up the superclass hierarchy\n+        for (Class acls = cls; acls != null; acls = acls.getSuperclass()) {\n+            try {\n+                Field field = acls.getDeclaredField(fieldName);\n+                // getDeclaredField checks for non-public scopes as well\n+                // and it returns accurate results\n+                if (!Modifier.isPublic(field.getModifiers())) {\n+                    if (forceAccess) {\n+                        field.setAccessible(true);\n+                    } else {\n+                        continue;\n+                    }\n+                }\n+                return field;\n+            } catch (NoSuchFieldException ex) {\n+                // ignore\n+            }\n+        }\n+        // check the public interface case. This must be manually searched for\n+        // incase there is a public supersuperclass field hidden by a private/package\n+        // superclass field.\n+        Field match = null;\n+        for (Class acls = cls; acls != null; acls = acls.getSuperclass()) {\n+            Class[] ints = acls.getInterfaces();\n+            for (int i = 0; i < ints.length; i++) {\n+                // getField is fine here, because everything is public, and thus it works\n+                try {\n+                    Field test = ints[i].getField(fieldName);\n+                    if (match != null) {\n+                        if (match.getDeclaringClass().equals(test.getDeclaringClass())) {\n+                            continue;\n+                        }\n+                        throw new IllegalArgumentException(\n+                                \"Reference to field \"\n+                                        + fieldName\n+                                        + \" is ambiguous relative to \"\n+                                        + cls\n+                                        + \"; a matching field exists on two or more parent interfaces.\");\n+                    }\n+                    match = test;\n+                } catch (NoSuchFieldException ex) {\n+                    // ignore\n+                }\n+            }\n+        }\n+        return match;\n+    }\n+\n+    /**\n+     * Gets an accessible <code>Field</code> by name respecting scope.\n+     * Only the specified class will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     */\n+    public static Field getDeclaredField(Class cls, String fieldName) {\n+        return getDeclaredField(cls, fieldName, false);\n+    }\n+\n+    /**\n+     * Gets an accessible <code>Field</code> by name breaking scope\n+     * if requested. Only the specified class will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. False will only match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     */\n+    public static Field getDeclaredField(Class cls, String fieldName, boolean forceAccess) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        if (fieldName == null) {\n+            throw new IllegalArgumentException(\"The field name must not be null\");\n+        }\n+        try {\n+            // only consider the specified class by using getDeclaredField()\n+            Field field = cls.getDeclaredField(fieldName);\n+            if (!MemberUtils.isAccessible(field)) {\n+                if (forceAccess) {\n+                    field.setAccessible(true);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            return field;\n+        } catch (NoSuchFieldException e) {\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Read an accessible static Field.\n+     * @param field to read\n+     * @return the field value\n+     * @throws IllegalArgumentException if the field is null or not static\n+     * @throws IllegalAccessException if the field is not accessible\n+     */\n+    public static Object readStaticField(Field field) throws IllegalAccessException {\n+        return readStaticField(field, false);\n+    }\n+\n+    /**\n+     * Read a static Field.\n+     * @param field to read\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method.\n+     * @return the field value\n+     * @throws IllegalArgumentException if the field is null or not static\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static Object readStaticField(Field field, boolean forceAccess) throws IllegalAccessException {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (!Modifier.isStatic(field.getModifiers())) {\n+            throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n+        }\n+        return readField(field, (Object) null, forceAccess);\n+    }\n+\n+    /**\n+     * Read the named public static field. Superclasses will be considered.\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the value of the field\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the field is not accessible\n+     */\n+    public static Object readStaticField(Class cls, String fieldName) throws IllegalAccessException {\n+        return readStaticField(cls, fieldName, false);\n+    }\n+\n+    /**\n+     * Read the named static field. Superclasses will be considered.\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static Object readStaticField(Class cls, String fieldName, boolean forceAccess) throws IllegalAccessException {\n+        Field field = getField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n+        }\n+        //already forced access above, don't repeat it here:\n+        return readStaticField(field, false);\n+    }\n+\n+    /**\n+     * Gets a static Field value by name. The field must be public.\n+     * Only the specified class will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the value of the field\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the field is not accessible\n+     */\n+    public static Object readDeclaredStaticField(Class cls, String fieldName) throws IllegalAccessException {\n+        return readDeclaredStaticField(cls, fieldName, false);\n+    }\n+\n+    /**\n+     * Gets a static Field value by name. Only the specified class will\n+     * be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static Object readDeclaredStaticField(Class cls, String fieldName, boolean forceAccess)\n+            throws IllegalAccessException {\n+        Field field = getDeclaredField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n+        }\n+        //already forced access above, don't repeat it here:\n+        return readStaticField(field, false);\n+    }\n+\n+    /**\n+     * Read an accessible Field.\n+     * @param field  the field to use\n+     * @param target  the object to call on, may be null for static fields\n+     * @return the field value\n+     * @throws IllegalArgumentException if the field is null\n+     * @throws IllegalAccessException if the field is not accessible\n+     */\n+    public static Object readField(Field field, Object target) throws IllegalAccessException {\n+        return readField(field, target, false);\n+    }\n+\n+    /**\n+     * Read a Field.\n+     * @param field  the field to use\n+     * @param target  the object to call on, may be null for static fields\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method.\n+     * @return the field value\n+     * @throws IllegalArgumentException if the field is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static Object readField(Field field, Object target, boolean forceAccess) throws IllegalAccessException {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (forceAccess && !field.isAccessible()) {\n+            field.setAccessible(true);\n+        } else {\n+            MemberUtils.setAccessibleWorkaround(field);\n+        }\n+        return field.get(target);\n+    }\n+\n+    /**\n+     * Read the named public field. Superclasses will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the value of the field\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the named field is not public\n+     */\n+    public static Object readField(Object target, String fieldName) throws IllegalAccessException {\n+        return readField(target, fieldName, false);\n+    }\n+\n+    /**\n+     * Read the named field. Superclasses will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @return the field value\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the named field is not made accessible\n+     */\n+    public static Object readField(Object target, String fieldName, boolean forceAccess) throws IllegalAccessException {\n+        if (target == null) {\n+            throw new IllegalArgumentException(\"target object must not be null\");\n+        }\n+        Class cls = target.getClass();\n+        Field field = getField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n+        }\n+        //already forced access above, don't repeat it here:\n+        return readField(field, target);\n+    }\n+\n+    /**\n+     * Read the named public field. Only the class of the specified object will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the value of the field\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the named field is not public\n+     */\n+    public static Object readDeclaredField(Object target, String fieldName) throws IllegalAccessException {\n+        return readDeclaredField(target, fieldName, false);\n+    }\n+\n+    /**\n+     * <p<>Gets a Field value by name. Only the class of the specified\n+     * object will be considered.\n+     *\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static Object readDeclaredField(Object target, String fieldName, boolean forceAccess) throws IllegalAccessException {\n+        if (target == null) {\n+            throw new IllegalArgumentException(\"target object must not be null\");\n+        }\n+        Class cls = target.getClass();\n+        Field field = getDeclaredField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n+        }\n+        //already forced access above, don't repeat it here:\n+        return readField(field, target);\n+    }\n+\n+    /**\n+     * Write a public static Field.\n+     * @param field to write\n+     * @param value to set\n+     * @throws IllegalArgumentException if the field is null or not static\n+     * @throws IllegalAccessException if the field is not public or is final\n+     */\n+    public static void writeStaticField(Field field, Object value) throws IllegalAccessException {\n+        writeStaticField(field, value, false);\n+    }\n+\n+    /**\n+     * Write a static Field.\n+     * @param field to write\n+     * @param value to set\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @throws IllegalArgumentException if the field is null or not static\n+     * @throws IllegalAccessException if the field is not made accessible or is final\n+     */\n+    public static void writeStaticField(Field field, Object value, boolean forceAccess) throws IllegalAccessException {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (!Modifier.isStatic(field.getModifiers())) {\n+            throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n+        }\n+        writeField(field, (Object) null, value, forceAccess);\n+    }\n+\n+    /**\n+     * Write a named public static Field. Superclasses will be considered.\n+     * @param cls Class on which the Field is to be found\n+     * @param fieldName to write\n+     * @param value to set\n+     * @throws IllegalArgumentException if the field cannot be located or is not static\n+     * @throws IllegalAccessException if the field is not public or is final\n+     */\n+    public static void writeStaticField(Class cls, String fieldName, Object value) throws IllegalAccessException {\n+        writeStaticField(cls, fieldName, value, false);\n+    }\n+\n+    /**\n+     * Write a named static Field. Superclasses will be considered.\n+     * @param cls Class on which the Field is to be found\n+     * @param fieldName to write\n+     * @param value to set\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @throws IllegalArgumentException if the field cannot be located or is not static\n+     * @throws IllegalAccessException if the field is not made accessible or is final\n+     */\n+    public static void writeStaticField(Class cls, String fieldName, Object value, boolean forceAccess)\n+            throws IllegalAccessException {\n+        Field field = getField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n+        }\n+        //already forced access above, don't repeat it here:\n+        writeStaticField(field, value);\n+    }\n+\n+    /**\n+     * Write a named public static Field. Only the specified class will be considered.\n+     * @param cls Class on which the Field is to be found\n+     * @param fieldName to write\n+     * @param value to set\n+     * @throws IllegalArgumentException if the field cannot be located or is not static\n+     * @throws IllegalAccessException if the field is not public or is final\n+     */\n+    public static void writeDeclaredStaticField(Class cls, String fieldName, Object value)\n+            throws IllegalAccessException {\n+        writeDeclaredStaticField(cls, fieldName, value, false);\n+    }\n+\n+    /**\n+     * Write a named static Field. Only the specified class will be considered.\n+     * @param cls Class on which the Field is to be found\n+     * @param fieldName to write\n+     * @param value to set\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @throws IllegalArgumentException if the field cannot be located or is not static\n+     * @throws IllegalAccessException if the field is not made accessible or is final\n+      */\n+    public static void writeDeclaredStaticField(Class cls, String fieldName, Object value, boolean forceAccess)\n+            throws IllegalAccessException {\n+        Field field = getDeclaredField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n+        }\n+        //already forced access above, don't repeat it here:\n+        writeField(field, (Object) null, value);\n+    }\n+\n+    /**\n+     * Write an accessible field.\n+     * @param field to write\n+     * @param target  the object to call on, may be null for static fields\n+     * @param value to set\n+     * @throws IllegalArgumentException if the field is null\n+     * @throws IllegalAccessException if the field is not accessible or is final\n+     */\n+    public static void writeField(Field field, Object target, Object value) throws IllegalAccessException {\n+        writeField(field, target, value, false);\n+    }\n+\n+    /**\n+     * Write a field.\n+     * @param field to write\n+     * @param target  the object to call on, may be null for static fields\n+     * @param value to set\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @throws IllegalArgumentException if the field is null\n+     * @throws IllegalAccessException if the field is not made accessible or is final\n+     */\n+    public static void writeField(Field field, Object target, Object value, boolean forceAccess) throws IllegalAccessException {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (forceAccess && !field.isAccessible()) {\n+            field.setAccessible(true);\n+        } else {\n+            MemberUtils.setAccessibleWorkaround(field);\n+        }\n+        field.set(target, value);\n+    }\n+\n+    /**\n+     * Write a public field. Superclasses will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param value to set\n+     * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n+     * @throws IllegalAccessException if the field is not accessible\n+     */\n+    public static void writeField(Object target, String fieldName, Object value) throws IllegalAccessException {\n+        writeField(target, fieldName, value, false);\n+    }\n+\n+    /**\n+     * Write a field. Superclasses will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param value to set\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static void writeField(Object target, String fieldName, Object value, boolean forceAccess)\n+            throws IllegalAccessException {\n+        if (target == null) {\n+            throw new IllegalArgumentException(\"target object must not be null\");\n+        }\n+        Class cls = target.getClass();\n+        Field field = getField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n+        }\n+        //already forced access above, don't repeat it here:\n+        writeField(field, target, value);\n+    }\n+\n+    /**\n+     * Write a public field. Only the specified class will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param value to set\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static void writeDeclaredField(Object target, String fieldName, Object value) throws IllegalAccessException {\n+        writeDeclaredField(target, fieldName, value, false);\n+    }\n+\n+    /**\n+     * Write a public field. Only the specified class will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param value to set\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static void writeDeclaredField(Object target, String fieldName, Object value, boolean forceAccess)\n+            throws IllegalAccessException {\n+        if (target == null) {\n+            throw new IllegalArgumentException(\"target object must not be null\");\n+        }\n+        Class cls = target.getClass();\n+        Field field = getDeclaredField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n+        }\n+        //already forced access above, don't repeat it here:\n+        writeField(field, target, value);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/reflect/MemberUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.ClassUtils;\n+import org.apache.commons.lang.SystemUtils;\n+\n+/**\n+ * Contains common code for working with Methods/Constructors, extracted and\n+ * refactored from <code>MethodUtils</code> when it was imported from Commons BeanUtils.\n+ *\n+ * @author Steve Cohen\n+ * @author Matt Benson\n+ * @since 2.5\n+ * @version $Id$\n+ */\n+abstract class MemberUtils {\n+    // TODO extract an interface to implement compareParameterSets(...)?\n+\n+    private static final int ACCESS_TEST = Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE;\n+\n+    private static final Method IS_SYNTHETIC;\n+    static {\n+        Method isSynthetic = null;\n+        if (SystemUtils.isJavaVersionAtLeast(1.5f)) {\n+            // cannot call synthetic methods:\n+            try {\n+                isSynthetic = Member.class.getMethod(\"isSynthetic\",\n+                        ArrayUtils.EMPTY_CLASS_ARRAY);\n+            } catch (Exception e) {\n+            }\n+        }\n+        IS_SYNTHETIC = isSynthetic;\n+    }\n+\n+    /** Array of primitive number types ordered by \"promotability\" */\n+    private static final Class[] ORDERED_PRIMITIVE_TYPES = { Byte.TYPE,\n+            Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE,\n+            Double.TYPE };\n+\n+    /**\n+     * XXX Default access superclass workaround\n+     *\n+     * When a public class has a default access superclass with public\n+     * members, these members are accessible. Calling them from\n+     * compiled code works fine. Unfortunately, on some JVMs, using reflection to invoke these\n+     * members seems to (wrongly) to prevent access even when the\n+     * modifer is public. Calling setAccessible(true) solves the problem\n+     * but will only work from sufficiently privileged code. Better\n+     * workarounds would be gratefully accepted.\n+     * @param o the AccessibleObject to set as accessible\n+     */\n+    static void setAccessibleWorkaround(AccessibleObject o) {\n+        if (o == null || o.isAccessible()) {\n+            return;\n+        }\n+        Member m = (Member) o;\n+        if (Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) {\n+            try {\n+                o.setAccessible(true);\n+            } catch (SecurityException e) {\n+                // ignore in favor of subsequent IllegalAccessException\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Learn whether a given set of modifiers implies package access.\n+     * @param modifiers to test\n+     * @return true unless package/protected/private modifier detected\n+     */\n+    static boolean isPackageAccess(int modifiers) {\n+        return (modifiers & ACCESS_TEST) == 0;\n+    }\n+\n+    /**\n+     * Check a Member for basic accessibility.\n+     * @param m Member to check\n+     * @return true if <code>m</code> is accessible\n+     */\n+    static boolean isAccessible(Member m) {\n+        return m != null && Modifier.isPublic(m.getModifiers())\n+                && !isSynthetic(m);\n+    }\n+\n+    /**\n+     * Try to learn whether a given member, on JDK >= 1.5, is synthetic.\n+     * @param m Member to check\n+     * @return true if <code>m</code> was introduced by the compiler.\n+     */\n+    static boolean isSynthetic(Member m) {\n+        if (IS_SYNTHETIC != null) {\n+            try {\n+                return ((Boolean) IS_SYNTHETIC.invoke(m, null)).booleanValue();\n+            } catch (Exception e) {\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Compare the relative fitness of two sets of parameter types in terms of\n+     * matching a third set of runtime parameter types, such that a list ordered\n+     * by the results of the comparison would return the best match first (least).\n+     *\n+     * @param left the \"left\" parameter set\n+     * @param right the \"right\" parameter set\n+     * @param actual the runtime parameter types to match against <code>left</code>/<code>right</code>\n+     * @return int consistent with <code>compare</code> semantics\n+     */\n+    static int compareParameterTypes(Class[] left, Class[] right, Class[] actual) {\n+        float leftCost = getTotalTransformationCost(actual, left);\n+        float rightCost = getTotalTransformationCost(actual, right);\n+        return leftCost < rightCost ? -1 : rightCost < leftCost ? 1 : 0;\n+    }\n+\n+    /**\n+     * Returns the sum of the object transformation cost for each class in the source\n+     * argument list.\n+     * @param srcArgs The source arguments\n+     * @param destArgs The destination arguments\n+     * @return The total transformation cost\n+     */\n+    private static float getTotalTransformationCost(Class[] srcArgs,\n+            Class[] destArgs) {\n+        float totalCost = 0.0f;\n+        for (int i = 0; i < srcArgs.length; i++) {\n+            Class srcClass, destClass;\n+            srcClass = srcArgs[i];\n+            destClass = destArgs[i];\n+            totalCost += getObjectTransformationCost(srcClass, destClass);\n+        }\n+        return totalCost;\n+    }\n+\n+    /**\n+     * Gets the number of steps required needed to turn the source class into the \n+     * destination class. This represents the number of steps in the object hierarchy \n+     * graph.\n+     * @param srcClass The source class\n+     * @param destClass The destination class\n+     * @return The cost of transforming an object\n+     */\n+    private static float getObjectTransformationCost(Class srcClass,\n+            Class destClass) {\n+        if (destClass.isPrimitive()) {\n+            return getPrimitivePromotionCost(srcClass, destClass);\n+        }\n+        float cost = 0.0f;\n+        while (destClass != null && !destClass.equals(srcClass)) {\n+            if (destClass.isInterface()\n+                    && ClassUtils.isAssignable(srcClass, destClass)) {\n+                // slight penalty for interface match.\n+                // we still want an exact match to override an interface match,\n+                // but\n+                // an interface match should override anything where we have to\n+                // get a superclass.\n+                cost += 0.25f;\n+                break;\n+            }\n+            cost++;\n+            destClass = destClass.getSuperclass();\n+        }\n+        /*\n+         * If the destination class is null, we've travelled all the way up to\n+         * an Object match. We'll penalize this by adding 1.5 to the cost.\n+         */\n+        if (destClass == null) {\n+            cost += 1.5f;\n+        }\n+        return cost;\n+    }\n+\n+    /**\n+     * Get the number of steps required to promote a primitive number to another type.\n+     * @param srcClass the (primitive) source class\n+     * @param destClass the (primitive) destination class\n+     * @return The cost of promoting the primitive\n+     */\n+    private static float getPrimitivePromotionCost(final Class srcClass,\n+            final Class destClass) {\n+        float cost = 0.0f;\n+        Class cls = srcClass;\n+        if (!cls.isPrimitive()) {\n+            // slight unwrapping penalty\n+            cost += 0.1f;\n+            cls = ClassUtils.wrapperToPrimitive(cls);\n+        }\n+        for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) {\n+            if (cls == ORDERED_PRIMITIVE_TYPES[i]) {\n+                cost += 0.1f;\n+                if (i < ORDERED_PRIMITIVE_TYPES.length - 1) {\n+                    cls = ORDERED_PRIMITIVE_TYPES[i + 1];\n+                }\n+            }\n+        }\n+        return cost;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/reflect/MethodUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+import java.util.Arrays;\n+import java.util.WeakHashMap;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.ClassUtils;\n+\n+/**\n+ * <p> Utility reflection methods focused on methods, originally from Commons BeanUtils.\n+ * Differences from the BeanUtils version may be noted, especially where similar functionality\n+ * already existed within Lang.\n+ * </p>\n+ *\n+ * <h3>Known Limitations</h3>\n+ * <h4>Accessing Public Methods In A Default Access Superclass</h4>\n+ * <p>There is an issue when invoking public methods contained in a default access superclass on JREs prior to 1.4.\n+ * Reflection locates these methods fine and correctly assigns them as public.\n+ * However, an <code>IllegalAccessException</code> is thrown if the method is invoked.</p>\n+ *\n+ * <p><code>MethodUtils</code> contains a workaround for this situation. \n+ * It will attempt to call <code>setAccessible</code> on this method.\n+ * If this call succeeds, then the method can be invoked as normal.\n+ * This call will only succeed when the application has sufficient security privileges. \n+ * If this call fails then the method may fail.</p>\n+ *\n+ * @author Craig R. McClanahan\n+ * @author Ralph Schaer\n+ * @author Chris Audley\n+ * @author Rey Fran&#231;ois\n+ * @author Gregor Ra&#253;man\n+ * @author Jan Sorensen\n+ * @author Robert Burrell Donkin\n+ * @author Niall Pemberton\n+ * @author Matt Benson\n+ * @since 2.5\n+ * @version $Id$\n+ */\n+public class MethodUtils {\n+\n+    /**\n+     * Stores a cache of MethodDescriptor -> Method in a WeakHashMap.\n+     * <p>\n+     * The keys into this map only ever exist as temporary variables within\n+     * methods of this class, and are never exposed to users of this class.\n+     * This means that the WeakHashMap is used only as a mechanism for \n+     * limiting the size of the cache, ie a way to tell the garbage collector\n+     * that the contents of the cache can be completely garbage-collected \n+     * whenever it needs the memory. Whether this is a good approach to\n+     * this problem is doubtful; something like the commons-collections\n+     * LRUMap may be more appropriate (though of course selecting an\n+     * appropriate size is an issue).\n+     * <p>\n+     * This static variable is safe even when this code is deployed via a\n+     * shared classloader because it is keyed via a MethodDescriptor object\n+     * which has a Class as one of its members and that member is used in\n+     * the MethodDescriptor.equals method. So two components that load the same\n+     * class via different classloaders will generate non-equal MethodDescriptor\n+     * objects and hence end up with different entries in the map.\n+     */\n+    private static final WeakHashMap/* <MethodDescriptor, Method> */cache = new WeakHashMap();\n+\n+    /**\n+     * Indicates whether methods should be cached for improved performance.\n+     * <p>\n+     * Note that when this class is deployed via a shared classloader in\n+     * a container, this will affect all webapps. However making this\n+     * configurable per webapp would mean having a map keyed by context classloader\n+     * which may introduce memory-leak problems.\n+     */\n+    private static boolean cacheMethods = true;\n+\n+    /**\n+     * <p>MethodUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as\n+     * <code>MethodUtils.getAccessibleMethod(method)</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public MethodUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Set whether methods should be cached for greater performance or not,\n+     * default is <code>true</code>.\n+     *\n+     * @param cacheMethods <code>true</code> if methods should be\n+     * cached for greater performance, otherwise <code>false</code>\n+     */\n+    public static synchronized void setCacheMethods(boolean cacheMethods) {\n+        MethodUtils.cacheMethods = cacheMethods;\n+        if (!MethodUtils.cacheMethods) {\n+            clearCache();\n+        }\n+    }\n+\n+    /**\n+     * Clear the method cache.\n+     * @return the number of cached methods cleared\n+     */\n+    public static synchronized int clearCache() {\n+        int size = cache.size();\n+        cache.clear();\n+        return size;\n+    }\n+\n+    /**\n+     * <p>Invoke a named method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> object\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeMethod(Object object, String methodName, Object[] args)}.\n+     * </p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param arg use this argument\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible via reflection\n+     */\n+    public static Object invokeMethod(Object object, String methodName,\n+            Object arg) throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        return invokeMethod(object, methodName, new Object[] { arg });\n+    }\n+\n+    /**\n+     * <p>Invoke a named method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> object\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeMethod(Object object,String methodName, Object[] args, Class[] parameterTypes)}.\n+     * </p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible via reflection\n+     */\n+    public static Object invokeMethod(Object object, String methodName,\n+            Object[] args) throws NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        int arguments = args.length;\n+        Class[] parameterTypes = new Class[arguments];\n+        for (int i = 0; i < arguments; i++) {\n+            parameterTypes[i] = args[i].getClass();\n+        }\n+        return invokeMethod(object, methodName, args, parameterTypes);\n+    }\n+\n+    /**\n+     * <p>Invoke a named method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> object\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @param parameterTypes match these parameters - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible via reflection\n+     */\n+    public static Object invokeMethod(Object object, String methodName,\n+            Object[] args, Class[] parameterTypes)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        Method method = getMatchingAccessibleMethod(object.getClass(),\n+                methodName, parameterTypes);\n+        if (method == null) {\n+            throw new NoSuchMethodException(\"No such accessible method: \"\n+                    + methodName + \"() on object: \"\n+                    + object.getClass().getName());\n+        }\n+        return method.invoke(object, args);\n+    }\n+\n+    /**\n+     * <p>Invoke a method whose parameter type matches exactly the object\n+     * type.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeExactMethod(Object object,String methodName,Object [] args)}.\n+     * </p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param arg use this argument\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactMethod(Object object, String methodName,\n+            Object arg) throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        return invokeExactMethod(object, methodName, new Object[] { arg });\n+    }\n+\n+    /**\n+     * <p>Invoke a method whose parameter types match exactly the object\n+     * types.</p>\n+     *\n+     * <p> This uses reflection to invoke the method obtained from a call to\n+     * <code>getAccessibleMethod()</code>.</p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactMethod(Object object, String methodName,\n+            Object[] args) throws NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        int arguments = args.length;\n+        Class[] parameterTypes = new Class[arguments];\n+        for (int i = 0; i < arguments; i++) {\n+            parameterTypes[i] = args[i].getClass();\n+        }\n+        return invokeExactMethod(object, methodName, args, parameterTypes);\n+    }\n+\n+    /**\n+     * <p>Invoke a method whose parameter types match exactly the parameter\n+     * types given.</p>\n+     *\n+     * <p>This uses reflection to invoke the method obtained from a call to\n+     * <code>getAccessibleMethod()</code>.</p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @param parameterTypes match these parameters - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactMethod(Object object, String methodName,\n+            Object[] args, Class[] parameterTypes)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        Method method = getAccessibleMethod(object.getClass(), methodName,\n+                parameterTypes);\n+        if (method == null) {\n+            throw new NoSuchMethodException(\"No such accessible method: \"\n+                    + methodName + \"() on object: \"\n+                    + object.getClass().getName());\n+        }\n+        return method.invoke(object, args);\n+    }\n+\n+    /**\n+     * <p>Invoke a static method whose parameter types match exactly the parameter\n+     * types given.</p>\n+     *\n+     * <p>This uses reflection to invoke the method obtained from a call to\n+     * {@link #getAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * @param cls invoke static method on this class\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @param parameterTypes match these parameters - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactStaticMethod(Class cls, String methodName,\n+            Object[] args, Class[] parameterTypes)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        Method method = getAccessibleMethod(cls, methodName, parameterTypes);\n+        if (method == null) {\n+            throw new NoSuchMethodException(\"No such accessible method: \"\n+                    + methodName + \"() on class: \" + cls.getName());\n+        }\n+        return method.invoke(null, args);\n+    }\n+\n+    /**\n+     * <p>Invoke a named static method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeStaticMethod(Class objectClass,String methodName,Object [] args)}.\n+     * </p>\n+     *\n+     * @param cls invoke static method on this class\n+     * @param methodName get method with this name\n+     * @param arg use this argument\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeStaticMethod(Class cls, String methodName,\n+            Object arg) throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        return invokeStaticMethod(cls, methodName, new Object[] { arg });\n+    }\n+\n+    /**\n+     * <p>Invoke a named static method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeStaticMethod(Class objectClass,String methodName,Object [] args,Class[] parameterTypes)}.\n+     * </p>\n+     *\n+     * @param cls invoke static method on this class\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeStaticMethod(Class cls, String methodName,\n+            Object[] args) throws NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        int arguments = args.length;\n+        Class[] parameterTypes = new Class[arguments];\n+        for (int i = 0; i < arguments; i++) {\n+            parameterTypes[i] = args[i].getClass();\n+        }\n+        return invokeStaticMethod(cls, methodName, args, parameterTypes);\n+    }\n+\n+    /**\n+     * <p>Invoke a named static method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     *\n+     * @param cls invoke static method on this class\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @param parameterTypes match these parameters - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeStaticMethod(Class cls, String methodName,\n+            Object[] args, Class[] parameterTypes)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        Method method = getMatchingAccessibleMethod(cls, methodName,\n+                parameterTypes);\n+        if (method == null) {\n+            throw new NoSuchMethodException(\"No such accessible method: \"\n+                    + methodName + \"() on class: \" + cls.getName());\n+        }\n+        return method.invoke(null, args);\n+    }\n+\n+    /**\n+     * <p>Invoke a static method whose parameter type matches exactly the object\n+     * type.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeExactStaticMethod(Class objectClass,String methodName,Object [] args)}.\n+     * </p>\n+     *\n+     * @param cls invoke static method on this class\n+     * @param methodName get method with this name\n+     * @param arg use this argument\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactStaticMethod(Class cls, String methodName,\n+            Object arg) throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        return invokeExactStaticMethod(cls, methodName, new Object[] { arg });\n+    }\n+\n+    /**\n+     * <p>Invoke a static method whose parameter types match exactly the object\n+     * types.</p>\n+     *\n+     * <p> This uses reflection to invoke the method obtained from a call to\n+     * {@link #getAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * @param cls invoke static method on this class\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactStaticMethod(Class cls, String methodName,\n+            Object[] args) throws NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        int arguments = args.length;\n+        Class[] parameterTypes = new Class[arguments];\n+        for (int i = 0; i < arguments; i++) {\n+            parameterTypes[i] = args[i].getClass();\n+        }\n+        return invokeExactStaticMethod(cls, methodName, args, parameterTypes);\n+    }\n+\n+    /**\n+     * <p>Return an accessible method (that is, one that can be invoked via\n+     * reflection) with given name and a single parameter.  If no such method\n+     * can be found, return <code>null</code>.\n+     * Basically, a convenience wrapper that constructs a <code>Class</code>\n+     * array for you.</p>\n+     *\n+     * @param cls get method from this class\n+     * @param methodName get method with this name\n+     * @param parameterType taking this type of parameter\n+     * @return The accessible method\n+     */\n+    public static Method getAccessibleMethod(Class cls, String methodName,\n+            Class parameterType) {\n+        return getAccessibleMethod(cls, methodName,\n+                new Class[] { parameterType });\n+    }\n+\n+    /**\n+     * <p>Return an accessible method (that is, one that can be invoked via\n+     * reflection) with given name and parameters.  If no such method\n+     * can be found, return <code>null</code>.\n+     * This is just a convenient wrapper for\n+     * {@link #getAccessibleMethod(Method method)}.</p>\n+     *\n+     * @param cls get method from this class\n+     * @param methodName get method with this name\n+     * @param parameterTypes with these parameters types\n+     * @return The accessible method\n+     */\n+    public static Method getAccessibleMethod(Class cls, String methodName,\n+            Class[] parameterTypes) {\n+        try {\n+            MethodDescriptor md = new MethodDescriptor(cls, methodName,\n+                    parameterTypes, true);\n+            // Check the cache first\n+            Method method = getCachedMethod(md);\n+            if (method != null) {\n+                return method;\n+            }\n+            method = getAccessibleMethod(cls.getMethod(methodName,\n+                    parameterTypes));\n+            cacheMethod(md, method);\n+            return method;\n+        } catch (NoSuchMethodException e) {\n+            return (null);\n+        }\n+    }\n+\n+    /**\n+     * <p>Return an accessible method (that is, one that can be invoked via\n+     * reflection) that implements the specified Method.  If no such method\n+     * can be found, return <code>null</code>.</p>\n+     *\n+     * @param method The method that we wish to call\n+     * @return The accessible method\n+     */\n+    public static Method getAccessibleMethod(Method method) {\n+        if (!MemberUtils.isAccessible(method)) {\n+            return null;\n+        }\n+        // If the declaring class is public, we are done\n+        Class cls = method.getDeclaringClass();\n+        if (Modifier.isPublic(cls.getModifiers())) {\n+            return method;\n+        }\n+        String methodName = method.getName();\n+        Class[] parameterTypes = method.getParameterTypes();\n+\n+        // Check the implemented interfaces and subinterfaces\n+        method = getAccessibleMethodFromInterfaceNest(cls, methodName,\n+                parameterTypes);\n+\n+        // Check the superclass chain\n+        if (method == null) {\n+            method = getAccessibleMethodFromSuperclass(cls, methodName,\n+                    parameterTypes);\n+        }\n+        return method;\n+    }\n+\n+    /**\n+     * <p>Return an accessible method (that is, one that can be invoked via\n+     * reflection) by scanning through the superclasses. If no such method\n+     * can be found, return <code>null</code>.</p>\n+     *\n+     * @param cls Class to be checked\n+     * @param methodName Method name of the method we wish to call\n+     * @param parameterTypes The parameter type signatures\n+     */\n+    private static Method getAccessibleMethodFromSuperclass(Class cls,\n+            String methodName, Class[] parameterTypes) {\n+        Class parentClass = cls.getSuperclass();\n+        while (parentClass != null) {\n+            if (Modifier.isPublic(parentClass.getModifiers())) {\n+                try {\n+                    return parentClass.getMethod(methodName, parameterTypes);\n+                } catch (NoSuchMethodException e) {\n+                    return null;\n+                }\n+            }\n+            parentClass = parentClass.getSuperclass();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Return an accessible method (that is, one that can be invoked via\n+     * reflection) that implements the specified method, by scanning through\n+     * all implemented interfaces and subinterfaces.  If no such method\n+     * can be found, return <code>null</code>.</p>\n+     *\n+     * <p> There isn't any good reason why this method must be private.\n+     * It is because there doesn't seem any reason why other classes should\n+     * call this rather than the higher level methods.</p>\n+     *\n+     * @param cls Parent class for the interfaces to be checked\n+     * @param methodName Method name of the method we wish to call\n+     * @param parameterTypes The parameter type signatures\n+     */\n+    private static Method getAccessibleMethodFromInterfaceNest(Class cls,\n+            String methodName, Class[] parameterTypes) {\n+        Method method = null;\n+\n+        // Search up the superclass chain\n+        for (; cls != null; cls = cls.getSuperclass()) {\n+\n+            // Check the implemented interfaces of the parent class\n+            Class[] interfaces = cls.getInterfaces();\n+            for (int i = 0; i < interfaces.length; i++) {\n+                // Is this interface public?\n+                if (!Modifier.isPublic(interfaces[i].getModifiers())) {\n+                    continue;\n+                }\n+                // Does the method exist on this interface?\n+                try {\n+                    method = interfaces[i].getDeclaredMethod(methodName,\n+                            parameterTypes);\n+                } catch (NoSuchMethodException e) {\n+                    /*\n+                     * Swallow, if no method is found after the loop then this\n+                     * method returns null.\n+                     */\n+                }\n+                if (method != null) {\n+                    break;\n+                }\n+                // Recursively check our parent interfaces\n+                method = getAccessibleMethodFromInterfaceNest(interfaces[i],\n+                        methodName, parameterTypes);\n+                if (method != null) {\n+                    break;\n+                }\n+            }\n+        }\n+        return method;\n+    }\n+\n+    /**\n+     * <p>Find an accessible method that matches the given name and has compatible parameters.\n+     * Compatible parameters mean that every method parameter is assignable from \n+     * the given parameters.\n+     * In other words, it finds a method with the given name \n+     * that will take the parameters given.<p>\n+     *\n+     * <p>This method is used by \n+     * {@link \n+     * #invokeMethod(Object object, String methodName, Object[] args, Class[] parameterTypes)}.\n+     *\n+     * <p>This method can match primitive parameter by passing in wrapper classes.\n+     * For example, a <code>Boolean</code> will match a primitive <code>boolean</code>\n+     * parameter.\n+     *\n+     * @param cls find method in this class\n+     * @param methodName find method with this name\n+     * @param parameterTypes find method with most compatible parameters \n+     * @return The accessible method\n+     */\n+    public static Method getMatchingAccessibleMethod(Class cls,\n+            String methodName, Class[] parameterTypes) {\n+        MethodDescriptor md = new MethodDescriptor(cls, methodName,\n+                parameterTypes, false);\n+        // Check the cache first\n+        Method method = getCachedMethod(md);\n+        if (method != null) {\n+            return method;\n+        }\n+        // see if we can find the method directly\n+        // most of the time this works and it's much faster\n+        try {\n+            method = cls.getMethod(methodName, parameterTypes);\n+            MemberUtils.setAccessibleWorkaround(method);\n+            cacheMethod(md, method);\n+            return method;\n+        } catch (NoSuchMethodException e) { /* SWALLOW */\n+        }\n+        // search through all methods\n+        Method bestMatch = null;\n+        Method[] methods = cls.getMethods();\n+        for (int i = 0, size = methods.length; i < size; i++) {\n+            if (methods[i].getName().equals(methodName)) {\n+                // compare parameters\n+                if (ClassUtils.isAssignable(parameterTypes, methods[i]\n+                        .getParameterTypes(), true)) {\n+                    // get accessible version of method\n+                    Method accessibleMethod = getAccessibleMethod(methods[i]);\n+                    if (accessibleMethod != null) {\n+                        if (bestMatch == null\n+                                || MemberUtils.compareParameterTypes(\n+                                        accessibleMethod.getParameterTypes(),\n+                                        bestMatch.getParameterTypes(),\n+                                        parameterTypes) < 0) {\n+                            bestMatch = accessibleMethod;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if (bestMatch != null) {\n+            MemberUtils.setAccessibleWorkaround(bestMatch);\n+            cacheMethod(md, bestMatch);\n+        }\n+        return bestMatch;\n+    }\n+\n+    /**\n+     * Return the method from the cache, if present.\n+     *\n+     * @param md The method descriptor\n+     * @return The cached method\n+     */\n+    private static Method getCachedMethod(MethodDescriptor md) {\n+        if (cacheMethods) {\n+            return (Method) cache.get(md);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Add a method to the cache.\n+     *\n+     * @param md The method descriptor\n+     * @param method The method to cache\n+     */\n+    private static void cacheMethod(MethodDescriptor md, Method method) {\n+        if (cacheMethods) {\n+            if (method != null) {\n+                cache.put(md, method);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Represents the key to looking up a Method by reflection.\n+     */\n+    private static class MethodDescriptor {\n+        private Class cls;\n+        private String methodName;\n+        private Class[] paramTypes;\n+        private boolean exact;\n+        private int hashCode;\n+\n+        /**\n+         * The sole constructor.\n+         *\n+         * @param cls  the class to reflect, must not be null\n+         * @param methodName  the method name to obtain\n+         * @param paramTypes the array of classes representing the paramater types\n+         * @param exact whether the match has to be exact.\n+         */\n+        public MethodDescriptor(Class cls, String methodName,\n+                Class[] paramTypes, boolean exact) {\n+            if (cls == null) {\n+                throw new IllegalArgumentException(\"Class cannot be null\");\n+            }\n+            if (methodName == null) {\n+                throw new IllegalArgumentException(\"Method Name cannot be null\");\n+            }\n+            if (paramTypes == null) {\n+                paramTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+            }\n+            this.cls = cls;\n+            this.methodName = methodName;\n+            this.paramTypes = paramTypes;\n+            this.exact = exact;\n+            // is this adequate? :/\n+            this.hashCode = methodName.length();\n+        }\n+\n+        /**\n+         * Checks for equality.\n+         * @param obj object to be tested for equality\n+         * @return true, if the object describes the same Method.\n+         */\n+        public boolean equals(Object obj) {\n+            if (!(obj instanceof MethodDescriptor)) {\n+                return false;\n+            }\n+            MethodDescriptor md = (MethodDescriptor) obj;\n+\n+            return exact == md.exact && methodName.equals(md.methodName)\n+                    && cls.equals(md.cls)\n+                    && Arrays.equals(paramTypes, md.paramTypes);\n+        }\n+\n+        /**\n+         * Returns the string length of method name. I.e. if the\n+         * hashcodes are different, the objects are different. If the\n+         * hashcodes are the same, need to use the equals method to\n+         * determine equality.\n+         * @return the string length of method name.\n+         */\n+        public int hashCode() {\n+            return hashCode;\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/lang/AllLangTestSuite.java\n+++ b/src/test/org/apache/commons/lang/AllLangTestSuite.java\n import org.apache.commons.lang.exception.ExceptionTestSuite;\n import org.apache.commons.lang.math.MathTestSuite;\n import org.apache.commons.lang.mutable.MutableTestSuite;\n+import org.apache.commons.lang.reflect.ReflectTestSuite;\n import org.apache.commons.lang.text.TextTestSuite;\n import org.apache.commons.lang.time.TimeTestSuite;\n \n         suite.addTest(ExceptionTestSuite.suite());\n         suite.addTest(MathTestSuite.suite());\n         suite.addTest(MutableTestSuite.suite());\n+        suite.addTest(ReflectTestSuite.suite());\n         suite.addTest(TextTestSuite.suite());\n         suite.addTest(TimeTestSuite.suite());\n         return suite;\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/reflect/ConstructorUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import java.lang.reflect.Constructor;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.math.NumberUtils;\n+\n+/**\n+ * Unit tests ConstructorUtils\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public class ConstructorUtilsTest extends TestCase {\n+    public static class TestBean {\n+        private String toString;\n+\n+        public TestBean() {\n+            toString = \"()\";\n+        }\n+\n+        public TestBean(int i) {\n+            toString = \"(int)\";\n+        }\n+\n+        public TestBean(Integer i) {\n+            toString = \"(Integer)\";\n+        }\n+\n+        public TestBean(double d) {\n+            toString = \"(double)\";\n+        }\n+\n+        public TestBean(String s) {\n+            toString = \"(String)\";\n+        }\n+\n+        public TestBean(Object o) {\n+            toString = \"(Object)\";\n+        }\n+\n+        public String toString() {\n+            return toString;\n+        }\n+    }\n+\n+    private static class PrivateClass {\n+        public PrivateClass() {\n+        }\n+    }\n+\n+    private Map classCache;\n+\n+    public ConstructorUtilsTest(String name) {\n+        super(name);\n+        classCache = new HashMap();\n+    }\n+\n+    /**\n+     * Run the test cases as a suite.\n+     * @return the Test\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ConstructorUtilsTest.class);\n+        suite.setName(\"ConstructorUtils Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        classCache.clear();\n+    }\n+\n+    public void testConstructor() throws Exception {\n+        assertNotNull(MethodUtils.class.newInstance());\n+    }\n+\n+    public void testInvokeConstructor() throws Exception {\n+        assertEquals(\"()\", ConstructorUtils.invokeConstructor(TestBean.class,\n+                ArrayUtils.EMPTY_CLASS_ARRAY).toString());\n+        assertEquals(\"()\", ConstructorUtils.invokeConstructor(TestBean.class,\n+                (Class[]) null).toString());\n+        assertEquals(\"(String)\", ConstructorUtils.invokeConstructor(\n+                TestBean.class, \"\").toString());\n+        assertEquals(\"(Object)\", ConstructorUtils.invokeConstructor(\n+                TestBean.class, new Object()).toString());\n+        assertEquals(\"(Object)\", ConstructorUtils.invokeConstructor(\n+                TestBean.class, Boolean.TRUE).toString());\n+        assertEquals(\"(Integer)\", ConstructorUtils.invokeConstructor(\n+                TestBean.class, NumberUtils.INTEGER_ONE).toString());\n+        assertEquals(\"(int)\", ConstructorUtils.invokeConstructor(\n+                TestBean.class, NumberUtils.BYTE_ONE).toString());\n+        assertEquals(\"(double)\", ConstructorUtils.invokeConstructor(\n+                TestBean.class, NumberUtils.LONG_ONE).toString());\n+        assertEquals(\"(double)\", ConstructorUtils.invokeConstructor(\n+                TestBean.class, NumberUtils.DOUBLE_ONE).toString());\n+    }\n+\n+    public void testInvokeExactConstructor() throws Exception {\n+        assertEquals(\"()\", ConstructorUtils.invokeExactConstructor(\n+                TestBean.class, ArrayUtils.EMPTY_CLASS_ARRAY).toString());\n+        assertEquals(\"()\", ConstructorUtils.invokeExactConstructor(\n+                TestBean.class, (Class[]) null).toString());\n+        assertEquals(\"(String)\", ConstructorUtils.invokeExactConstructor(\n+                TestBean.class, \"\").toString());\n+        assertEquals(\"(Object)\", ConstructorUtils.invokeExactConstructor(\n+                TestBean.class, new Object()).toString());\n+        assertEquals(\"(Integer)\", ConstructorUtils.invokeExactConstructor(\n+                TestBean.class, NumberUtils.INTEGER_ONE).toString());\n+        assertEquals(\"(double)\", ConstructorUtils.invokeExactConstructor(\n+                TestBean.class, new Object[] { NumberUtils.DOUBLE_ONE },\n+                new Class[] { Double.TYPE }).toString());\n+\n+        try {\n+            ConstructorUtils.invokeExactConstructor(TestBean.class,\n+                    NumberUtils.BYTE_ONE);\n+            fail(\"should throw NoSuchMethodException\");\n+        } catch (NoSuchMethodException e) {\n+        }\n+        try {\n+            ConstructorUtils.invokeExactConstructor(TestBean.class,\n+                    NumberUtils.LONG_ONE);\n+            fail(\"should throw NoSuchMethodException\");\n+        } catch (NoSuchMethodException e) {\n+        }\n+        try {\n+            ConstructorUtils.invokeExactConstructor(TestBean.class,\n+                    Boolean.TRUE);\n+            fail(\"should throw NoSuchMethodException\");\n+        } catch (NoSuchMethodException e) {\n+        }\n+    }\n+\n+    public void testGetAccessibleConstructor() throws Exception {\n+        assertNotNull(ConstructorUtils.getAccessibleConstructor(Object.class\n+                .getConstructor(ArrayUtils.EMPTY_CLASS_ARRAY)));\n+        assertNull(ConstructorUtils.getAccessibleConstructor(PrivateClass.class\n+                .getConstructor(ArrayUtils.EMPTY_CLASS_ARRAY)));\n+    }\n+\n+    public void testGetAccessibleConstructorFromDescription() throws Exception {\n+        assertNotNull(ConstructorUtils.getAccessibleConstructor(Object.class,\n+                ArrayUtils.EMPTY_CLASS_ARRAY));\n+        assertNull(ConstructorUtils.getAccessibleConstructor(\n+                PrivateClass.class, ArrayUtils.EMPTY_CLASS_ARRAY));\n+    }\n+\n+    public void testGetMatchingAccessibleMethod() throws Exception {\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY);\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class, null,\n+                ArrayUtils.EMPTY_CLASS_ARRAY);\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(String.class), singletonArray(String.class));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Object.class), singletonArray(Object.class));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Boolean.class), singletonArray(Object.class));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Byte.class), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Byte.TYPE), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Short.class), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Short.TYPE), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Character.class), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Character.TYPE), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Integer.class), singletonArray(Integer.class));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Integer.TYPE), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Long.class), singletonArray(Double.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Long.TYPE), singletonArray(Double.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Float.class), singletonArray(Double.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Float.TYPE), singletonArray(Double.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Double.class), singletonArray(Double.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Double.TYPE), singletonArray(Double.TYPE));\n+    }\n+\n+    private void expectMatchingAccessibleConstructorParameterTypes(Class cls,\n+            Class[] requestTypes, Class[] actualTypes) {\n+        Constructor c = ConstructorUtils.getMatchingAccessibleConstructor(cls,\n+                requestTypes);\n+        assertTrue(Arrays.toString(c.getParameterTypes()) + \" not equals \"\n+                + Arrays.toString(actualTypes), Arrays.equals(actualTypes, c\n+                .getParameterTypes()));\n+    }\n+\n+    private Class[] singletonArray(Class c) {\n+        Class[] result = (Class[]) classCache.get(c);\n+        if (result == null) {\n+            result = new Class[] { c };\n+            classCache.put(c, result);\n+        }\n+        return result;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/reflect/FieldUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import java.lang.reflect.Field;\n+\n+import org.apache.commons.lang.reflect.testbed.Ambig;\n+import org.apache.commons.lang.reflect.testbed.Foo;\n+import org.apache.commons.lang.reflect.testbed.PrivatelyShadowedChild;\n+import org.apache.commons.lang.reflect.testbed.PublicChild;\n+import org.apache.commons.lang.reflect.testbed.PubliclyShadowedChild;\n+import org.apache.commons.lang.reflect.testbed.StaticContainer;\n+import org.apache.commons.lang.reflect.testbed.StaticContainerChild;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Unit tests FieldUtils\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public class FieldUtilsTest extends TestCase {\n+\n+    static final String S = \"s\";\n+    static final String SS = \"ss\";\n+    static final Integer I0 = new Integer(0);\n+    static final Integer I1 = new Integer(1);\n+    static final Double D0 = new Double(0.0);\n+    static final Double D1 = new Double(1.0);\n+\n+    private PublicChild publicChild;\n+    private PubliclyShadowedChild publiclyShadowedChild;\n+    private PrivatelyShadowedChild privatelyShadowedChild;\n+    private Class parentClass = PublicChild.class.getSuperclass();\n+\n+    /**\n+     * Run the test cases as a suite.\n+     * @return the Test\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(FieldUtilsTest.class);\n+        suite.setName(\"FieldUtils Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        StaticContainer.reset();\n+        publicChild = new PublicChild();\n+        publiclyShadowedChild = new PubliclyShadowedChild();\n+        privatelyShadowedChild = new PrivatelyShadowedChild();\n+    }\n+\n+    public void testGetField() {\n+        assertEquals(Foo.class, FieldUtils.getField(PublicChild.class, \"VALUE\").getDeclaringClass());\n+        assertEquals(parentClass, FieldUtils.getField(PublicChild.class, \"s\").getDeclaringClass());\n+        assertNull(FieldUtils.getField(PublicChild.class, \"b\"));\n+        assertNull(FieldUtils.getField(PublicChild.class, \"i\"));\n+        assertNull(FieldUtils.getField(PublicChild.class, \"d\"));\n+        assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, \"VALUE\").getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"s\")\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"b\")\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"i\")\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"d\")\n+                .getDeclaringClass());\n+        assertEquals(Foo.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"VALUE\").getDeclaringClass());\n+        assertEquals(parentClass, FieldUtils.getField(PrivatelyShadowedChild.class, \"s\").getDeclaringClass());\n+        assertNull(FieldUtils.getField(PrivatelyShadowedChild.class, \"b\"));\n+        assertNull(FieldUtils.getField(PrivatelyShadowedChild.class, \"i\"));\n+        assertNull(FieldUtils.getField(PrivatelyShadowedChild.class, \"d\"));\n+    }\n+\n+    public void testGetFieldForceAccess() {\n+        assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, \"VALUE\", true).getDeclaringClass());\n+        assertEquals(parentClass, FieldUtils.getField(PublicChild.class, \"s\", true).getDeclaringClass());\n+        assertEquals(parentClass, FieldUtils.getField(PublicChild.class, \"b\", true).getDeclaringClass());\n+        assertEquals(parentClass, FieldUtils.getField(PublicChild.class, \"i\", true).getDeclaringClass());\n+        assertEquals(parentClass, FieldUtils.getField(PublicChild.class, \"d\", true).getDeclaringClass());\n+        assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, \"VALUE\", true).getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"s\", true)\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"b\", true)\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"i\", true)\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"d\", true)\n+                .getDeclaringClass());\n+        assertEquals(Foo.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"VALUE\", true).getDeclaringClass());\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"s\", true)\n+                .getDeclaringClass());\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"b\", true)\n+                .getDeclaringClass());\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"i\", true)\n+                .getDeclaringClass());\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"d\", true)\n+                .getDeclaringClass());\n+    }\n+\n+    public void testGetDeclaredField() {\n+        assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"VALUE\"));\n+        assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"s\"));\n+        assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"b\"));\n+        assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"i\"));\n+        assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"d\"));\n+        assertNull(FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"VALUE\"));\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"s\")\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"b\")\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"i\")\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"d\")\n+                .getDeclaringClass());\n+        assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"VALUE\"));\n+        assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"s\"));\n+        assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"b\"));\n+        assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"i\"));\n+        assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"d\"));\n+    }\n+\n+    public void testGetDeclaredFieldForceAccess() {\n+        assertEquals(PublicChild.class, FieldUtils.getDeclaredField(PublicChild.class, \"VALUE\", true)\n+                .getDeclaringClass());\n+        assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"s\", true));\n+        assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"b\", true));\n+        assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"i\", true));\n+        assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"d\", true));\n+        assertNull(FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"VALUE\", true));\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"s\", true)\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"b\", true)\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"i\", true)\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"d\", true)\n+                .getDeclaringClass());\n+        assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"VALUE\", true));\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"s\", true)\n+                .getDeclaringClass());\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"b\", true)\n+                .getDeclaringClass());\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"i\", true)\n+                .getDeclaringClass());\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"d\", true)\n+                .getDeclaringClass());\n+    }\n+\n+    public void testReadStaticField() throws Exception {\n+        assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, \"VALUE\")));\n+    }\n+\n+    public void testReadStaticFieldForceAccess() throws Exception {\n+        assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, \"VALUE\")));\n+        assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(PublicChild.class, \"VALUE\")));\n+    }\n+\n+    public void testReadNamedStaticField() throws Exception {\n+        assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, \"VALUE\"));\n+        assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, \"VALUE\"));\n+        assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, \"VALUE\"));\n+        assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, \"VALUE\"));\n+    }\n+\n+    public void testReadNamedStaticFieldForceAccess() throws Exception {\n+        assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, \"VALUE\", true));\n+        assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, \"VALUE\", true));\n+        assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, \"VALUE\", true));\n+        assertEquals(\"child\", FieldUtils.readStaticField(PublicChild.class, \"VALUE\", true));\n+    }\n+\n+    public void testReadDeclaredNamedStaticField() throws Exception {\n+        assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(Foo.class, \"VALUE\"));\n+        try {\n+            assertEquals(\"child\", FieldUtils.readDeclaredStaticField(PublicChild.class, \"VALUE\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PubliclyShadowedChild.class, \"VALUE\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PrivatelyShadowedChild.class, \"VALUE\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testReadDeclaredNamedStaticFieldForceAccess() throws Exception {\n+        assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(Foo.class, \"VALUE\", true));\n+        assertEquals(\"child\", FieldUtils.readDeclaredStaticField(PublicChild.class, \"VALUE\", true));\n+        try {\n+            assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PubliclyShadowedChild.class, \"VALUE\", true));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PrivatelyShadowedChild.class, \"VALUE\", true));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testReadField() throws Exception {\n+        Field parentS = FieldUtils.getDeclaredField(parentClass, \"s\");\n+        assertEquals(\"s\", FieldUtils.readField(parentS, publicChild));\n+        assertEquals(\"s\", FieldUtils.readField(parentS, publiclyShadowedChild));\n+        assertEquals(\"s\", FieldUtils.readField(parentS, privatelyShadowedChild));\n+        Field parentB = FieldUtils.getDeclaredField(parentClass, \"b\", true);\n+        assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publicChild));\n+        assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publiclyShadowedChild));\n+        assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, privatelyShadowedChild));\n+        Field parentI = FieldUtils.getDeclaredField(parentClass, \"i\", true);\n+        assertEquals(I0, FieldUtils.readField(parentI, publicChild));\n+        assertEquals(I0, FieldUtils.readField(parentI, publiclyShadowedChild));\n+        assertEquals(I0, FieldUtils.readField(parentI, privatelyShadowedChild));\n+        Field parentD = FieldUtils.getDeclaredField(parentClass, \"d\", true);\n+        assertEquals(D0, FieldUtils.readField(parentD, publicChild));\n+        assertEquals(D0, FieldUtils.readField(parentD, publiclyShadowedChild));\n+        assertEquals(D0, FieldUtils.readField(parentD, privatelyShadowedChild));\n+    }\n+\n+    public void testReadFieldForceAccess() throws Exception {\n+        Field parentS = FieldUtils.getDeclaredField(parentClass, \"s\");\n+        parentS.setAccessible(false);\n+        assertEquals(\"s\", FieldUtils.readField(parentS, publicChild, true));\n+        assertEquals(\"s\", FieldUtils.readField(parentS, publiclyShadowedChild, true));\n+        assertEquals(\"s\", FieldUtils.readField(parentS, privatelyShadowedChild, true));\n+        Field parentB = FieldUtils.getDeclaredField(parentClass, \"b\", true);\n+        parentB.setAccessible(false);\n+        assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publicChild, true));\n+        assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publiclyShadowedChild, true));\n+        assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, privatelyShadowedChild, true));\n+        Field parentI = FieldUtils.getDeclaredField(parentClass, \"i\", true);\n+        parentI.setAccessible(false);\n+        assertEquals(I0, FieldUtils.readField(parentI, publicChild, true));\n+        assertEquals(I0, FieldUtils.readField(parentI, publiclyShadowedChild, true));\n+        assertEquals(I0, FieldUtils.readField(parentI, privatelyShadowedChild, true));\n+        Field parentD = FieldUtils.getDeclaredField(parentClass, \"d\", true);\n+        parentD.setAccessible(false);\n+        assertEquals(D0, FieldUtils.readField(parentD, publicChild, true));\n+        assertEquals(D0, FieldUtils.readField(parentD, publiclyShadowedChild, true));\n+        assertEquals(D0, FieldUtils.readField(parentD, privatelyShadowedChild, true));\n+    }\n+\n+    public void testReadNamedField() throws Exception {\n+        assertEquals(\"s\", FieldUtils.readField(publicChild, \"s\"));\n+        assertEquals(\"ss\", FieldUtils.readField(publiclyShadowedChild, \"s\"));\n+        assertEquals(\"s\", FieldUtils.readField(privatelyShadowedChild, \"s\"));\n+        try {\n+            assertEquals(Boolean.FALSE, FieldUtils.readField(publicChild, \"b\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(Boolean.TRUE, FieldUtils.readField(publiclyShadowedChild, \"b\"));\n+        try {\n+            assertEquals(Boolean.FALSE, FieldUtils.readField(privatelyShadowedChild, \"b\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            assertEquals(I0, FieldUtils.readField(publicChild, \"i\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(I1, FieldUtils.readField(publiclyShadowedChild, \"i\"));\n+        try {\n+            assertEquals(I0, FieldUtils.readField(privatelyShadowedChild, \"i\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            assertEquals(D0, FieldUtils.readField(publicChild, \"d\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(D1, FieldUtils.readField(publiclyShadowedChild, \"d\"));\n+        try {\n+            assertEquals(D0, FieldUtils.readField(privatelyShadowedChild, \"d\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testReadNamedFieldForceAccess() throws Exception {\n+        assertEquals(\"s\", FieldUtils.readField(publicChild, \"s\", true));\n+        assertEquals(\"ss\", FieldUtils.readField(publiclyShadowedChild, \"s\", true));\n+        assertEquals(\"ss\", FieldUtils.readField(privatelyShadowedChild, \"s\", true));\n+        assertEquals(Boolean.FALSE, FieldUtils.readField(publicChild, \"b\", true));\n+        assertEquals(Boolean.TRUE, FieldUtils.readField(publiclyShadowedChild, \"b\", true));\n+        assertEquals(Boolean.TRUE, FieldUtils.readField(privatelyShadowedChild, \"b\", true));\n+        assertEquals(I0, FieldUtils.readField(publicChild, \"i\", true));\n+        assertEquals(I1, FieldUtils.readField(publiclyShadowedChild, \"i\", true));\n+        assertEquals(I1, FieldUtils.readField(privatelyShadowedChild, \"i\", true));\n+        assertEquals(D0, FieldUtils.readField(publicChild, \"d\", true));\n+        assertEquals(D1, FieldUtils.readField(publiclyShadowedChild, \"d\", true));\n+        assertEquals(D1, FieldUtils.readField(privatelyShadowedChild, \"d\", true));\n+    }\n+\n+    public void testReadDeclaredNamedField() throws Exception {\n+        try {\n+            assertEquals(\"s\", FieldUtils.readDeclaredField(publicChild, \"s\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(\"ss\", FieldUtils.readDeclaredField(publiclyShadowedChild, \"s\"));\n+        try {\n+            assertEquals(\"s\", FieldUtils.readDeclaredField(privatelyShadowedChild, \"s\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publicChild, \"b\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(publiclyShadowedChild, \"b\"));\n+        try {\n+            assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(privatelyShadowedChild, \"b\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            assertEquals(I0, FieldUtils.readDeclaredField(publicChild, \"i\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(I1, FieldUtils.readDeclaredField(publiclyShadowedChild, \"i\"));\n+        try {\n+            assertEquals(I0, FieldUtils.readDeclaredField(privatelyShadowedChild, \"i\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            assertEquals(D0, FieldUtils.readDeclaredField(publicChild, \"d\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(D1, FieldUtils.readDeclaredField(publiclyShadowedChild, \"d\"));\n+        try {\n+            assertEquals(D0, FieldUtils.readDeclaredField(privatelyShadowedChild, \"d\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testReadDeclaredNamedFieldForceAccess() throws Exception {\n+        try {\n+            assertEquals(\"s\", FieldUtils.readDeclaredField(publicChild, \"s\", true));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(\"ss\", FieldUtils.readDeclaredField(publiclyShadowedChild, \"s\", true));\n+        assertEquals(\"ss\", FieldUtils.readDeclaredField(privatelyShadowedChild, \"s\", true));\n+        try {\n+            assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publicChild, \"b\", true));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(publiclyShadowedChild, \"b\", true));\n+        assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(privatelyShadowedChild, \"b\", true));\n+        try {\n+            assertEquals(I0, FieldUtils.readDeclaredField(publicChild, \"i\", true));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(I1, FieldUtils.readDeclaredField(publiclyShadowedChild, \"i\", true));\n+        assertEquals(I1, FieldUtils.readDeclaredField(privatelyShadowedChild, \"i\", true));\n+        try {\n+            assertEquals(D0, FieldUtils.readDeclaredField(publicChild, \"d\", true));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(D1, FieldUtils.readDeclaredField(publiclyShadowedChild, \"d\", true));\n+        assertEquals(D1, FieldUtils.readDeclaredField(privatelyShadowedChild, \"d\", true));\n+    }\n+\n+    public void testWriteStaticField() throws Exception {\n+        Field field = StaticContainer.class.getDeclaredField(\"mutablePublic\");\n+        FieldUtils.writeStaticField(field, \"new\");\n+        assertEquals(\"new\", StaticContainer.mutablePublic);\n+        field = StaticContainer.class.getDeclaredField(\"mutableProtected\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\");\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = StaticContainer.class.getDeclaredField(\"mutablePackage\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\");\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = StaticContainer.class.getDeclaredField(\"mutablePrivate\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\");\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PUBLIC\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\");\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PROTECTED\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\");\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PACKAGE\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\");\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PRIVATE\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\");\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testWriteStaticFieldForceAccess() throws Exception {\n+        Field field = StaticContainer.class.getDeclaredField(\"mutablePublic\");\n+        FieldUtils.writeStaticField(field, \"new\", true);\n+        assertEquals(\"new\", StaticContainer.mutablePublic);\n+        field = StaticContainer.class.getDeclaredField(\"mutableProtected\");\n+        FieldUtils.writeStaticField(field, \"new\", true);\n+        assertEquals(\"new\", StaticContainer.getMutableProtected());\n+        field = StaticContainer.class.getDeclaredField(\"mutablePackage\");\n+        FieldUtils.writeStaticField(field, \"new\", true);\n+        assertEquals(\"new\", StaticContainer.getMutablePackage());\n+        field = StaticContainer.class.getDeclaredField(\"mutablePrivate\");\n+        FieldUtils.writeStaticField(field, \"new\", true);\n+        assertEquals(\"new\", StaticContainer.getMutablePrivate());\n+        field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PUBLIC\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PROTECTED\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PACKAGE\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PRIVATE\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testWriteNamedStaticField() throws Exception {\n+        FieldUtils.writeStaticField(StaticContainerChild.class, \"mutablePublic\", \"new\");\n+        assertEquals(\"new\", StaticContainer.mutablePublic);\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"mutableProtected\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"mutablePackage\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"mutablePrivate\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PUBLIC\", \"new\");\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PROTECTED\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PACKAGE\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PRIVATE\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testWriteNamedStaticFieldForceAccess() throws Exception {\n+        FieldUtils.writeStaticField(StaticContainerChild.class, \"mutablePublic\", \"new\", true);\n+        assertEquals(\"new\", StaticContainer.mutablePublic);\n+        FieldUtils.writeStaticField(StaticContainerChild.class, \"mutableProtected\", \"new\", true);\n+        assertEquals(\"new\", StaticContainer.getMutableProtected());\n+        FieldUtils.writeStaticField(StaticContainerChild.class, \"mutablePackage\", \"new\", true);\n+        assertEquals(\"new\", StaticContainer.getMutablePackage());\n+        FieldUtils.writeStaticField(StaticContainerChild.class, \"mutablePrivate\", \"new\", true);\n+        assertEquals(\"new\", StaticContainer.getMutablePrivate());\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PUBLIC\", \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PROTECTED\", \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PACKAGE\", \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PRIVATE\", \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testWriteDeclaredNamedStaticField() throws Exception {\n+        FieldUtils.writeStaticField(StaticContainer.class, \"mutablePublic\", \"new\");\n+        assertEquals(\"new\", StaticContainer.mutablePublic);\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"mutableProtected\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"mutablePackage\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"mutablePrivate\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PUBLIC\", \"new\");\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PROTECTED\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PACKAGE\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PRIVATE\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testWriteDeclaredNamedStaticFieldForceAccess() throws Exception {\n+        FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"mutablePublic\", \"new\", true);\n+        assertEquals(\"new\", StaticContainer.mutablePublic);\n+        FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"mutableProtected\", \"new\", true);\n+        assertEquals(\"new\", StaticContainer.getMutableProtected());\n+        FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"mutablePackage\", \"new\", true);\n+        assertEquals(\"new\", StaticContainer.getMutablePackage());\n+        FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"mutablePrivate\", \"new\", true);\n+        assertEquals(\"new\", StaticContainer.getMutablePrivate());\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PUBLIC\", \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PROTECTED\", \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PACKAGE\", \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PRIVATE\", \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testWriteField() throws Exception {\n+        Field field = parentClass.getDeclaredField(\"s\");\n+        FieldUtils.writeField(field, publicChild, \"S\");\n+        assertEquals(\"S\", field.get(publicChild));\n+        field = parentClass.getDeclaredField(\"b\");\n+        try {\n+            FieldUtils.writeField(field, publicChild, Boolean.TRUE);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = parentClass.getDeclaredField(\"i\");\n+        try {\n+            FieldUtils.writeField(field, publicChild, new Integer(Integer.MAX_VALUE));\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = parentClass.getDeclaredField(\"d\");\n+        try {\n+            FieldUtils.writeField(field, publicChild, new Double(Double.MAX_VALUE));\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testWriteFieldForceAccess() throws Exception {\n+        Field field = parentClass.getDeclaredField(\"s\");\n+        FieldUtils.writeField(field, publicChild, \"S\", true);\n+        assertEquals(\"S\", field.get(publicChild));\n+        field = parentClass.getDeclaredField(\"b\");\n+        FieldUtils.writeField(field, publicChild, Boolean.TRUE, true);\n+        assertEquals(Boolean.TRUE, field.get(publicChild));\n+        field = parentClass.getDeclaredField(\"i\");\n+        FieldUtils.writeField(field, publicChild, new Integer(Integer.MAX_VALUE), true);\n+        assertEquals(new Integer(Integer.MAX_VALUE), field.get(publicChild));\n+        field = parentClass.getDeclaredField(\"d\");\n+        FieldUtils.writeField(field, publicChild, new Double(Double.MAX_VALUE), true);\n+        assertEquals(new Double(Double.MAX_VALUE), field.get(publicChild));\n+    }\n+\n+    public void testWriteNamedField() throws Exception {\n+        FieldUtils.writeField(publicChild, \"s\", \"S\");\n+        assertEquals(\"S\", FieldUtils.readField(publicChild, \"s\"));\n+        try {\n+            FieldUtils.writeField(publicChild, \"b\", Boolean.TRUE);\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeField(publicChild, \"i\", new Integer(1));\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeField(publicChild, \"d\", new Double(1.0));\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+\n+        FieldUtils.writeField(publiclyShadowedChild, \"s\", \"S\");\n+        assertEquals(\"S\", FieldUtils.readField(publiclyShadowedChild, \"s\"));\n+        FieldUtils.writeField(publiclyShadowedChild, \"b\", Boolean.FALSE);\n+        assertEquals(Boolean.FALSE, FieldUtils.readField(publiclyShadowedChild, \"b\"));\n+        FieldUtils.writeField(publiclyShadowedChild, \"i\", new Integer(0));\n+        assertEquals(new Integer(0), FieldUtils.readField(publiclyShadowedChild, \"i\"));\n+        FieldUtils.writeField(publiclyShadowedChild, \"d\", new Double(0.0));\n+        assertEquals(new Double(0.0), FieldUtils.readField(publiclyShadowedChild, \"d\"));\n+\n+        FieldUtils.writeField(privatelyShadowedChild, \"s\", \"S\");\n+        assertEquals(\"S\", FieldUtils.readField(privatelyShadowedChild, \"s\"));\n+        try {\n+            FieldUtils.writeField(privatelyShadowedChild, \"b\", Boolean.TRUE);\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeField(privatelyShadowedChild, \"i\", new Integer(1));\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeField(privatelyShadowedChild, \"d\", new Double(1.0));\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testWriteNamedFieldForceAccess() throws Exception {\n+        FieldUtils.writeField(publicChild, \"s\", \"S\", true);\n+        assertEquals(\"S\", FieldUtils.readField(publicChild, \"s\", true));\n+        FieldUtils.writeField(publicChild, \"b\", Boolean.TRUE, true);\n+        assertEquals(Boolean.TRUE, FieldUtils.readField(publicChild, \"b\", true));\n+        FieldUtils.writeField(publicChild, \"i\", new Integer(1), true);\n+        assertEquals(new Integer(1), FieldUtils.readField(publicChild, \"i\", true));\n+        FieldUtils.writeField(publicChild, \"d\", new Double(1.0), true);\n+        assertEquals(new Double(1.0), FieldUtils.readField(publicChild, \"d\", true));\n+\n+        FieldUtils.writeField(publiclyShadowedChild, \"s\", \"S\", true);\n+        assertEquals(\"S\", FieldUtils.readField(publiclyShadowedChild, \"s\", true));\n+        FieldUtils.writeField(publiclyShadowedChild, \"b\", Boolean.FALSE, true);\n+        assertEquals(Boolean.FALSE, FieldUtils.readField(publiclyShadowedChild, \"b\", true));\n+        FieldUtils.writeField(publiclyShadowedChild, \"i\", new Integer(0), true);\n+        assertEquals(new Integer(0), FieldUtils.readField(publiclyShadowedChild, \"i\", true));\n+        FieldUtils.writeField(publiclyShadowedChild, \"d\", new Double(0.0), true);\n+        assertEquals(new Double(0.0), FieldUtils.readField(publiclyShadowedChild, \"d\", true));\n+\n+        FieldUtils.writeField(privatelyShadowedChild, \"s\", \"S\", true);\n+        assertEquals(\"S\", FieldUtils.readField(privatelyShadowedChild, \"s\", true));\n+        FieldUtils.writeField(privatelyShadowedChild, \"b\", Boolean.FALSE, true);\n+        assertEquals(Boolean.FALSE, FieldUtils.readField(privatelyShadowedChild, \"b\", true));\n+        FieldUtils.writeField(privatelyShadowedChild, \"i\", new Integer(0), true);\n+        assertEquals(new Integer(0), FieldUtils.readField(privatelyShadowedChild, \"i\", true));\n+        FieldUtils.writeField(privatelyShadowedChild, \"d\", new Double(0.0), true);\n+        assertEquals(new Double(0.0), FieldUtils.readField(privatelyShadowedChild, \"d\", true));\n+    }\n+\n+    public void testWriteDeclaredNamedField() throws Exception {\n+        try {\n+            FieldUtils.writeDeclaredField(publicChild, \"s\", \"S\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredField(publicChild, \"b\", Boolean.TRUE);\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredField(publicChild, \"i\", new Integer(1));\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredField(publicChild, \"d\", new Double(1.0));\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+\n+        FieldUtils.writeDeclaredField(publiclyShadowedChild, \"s\", \"S\");\n+        assertEquals(\"S\", FieldUtils.readDeclaredField(publiclyShadowedChild, \"s\"));\n+        FieldUtils.writeDeclaredField(publiclyShadowedChild, \"b\", Boolean.FALSE);\n+        assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publiclyShadowedChild, \"b\"));\n+        FieldUtils.writeDeclaredField(publiclyShadowedChild, \"i\", new Integer(0));\n+        assertEquals(new Integer(0), FieldUtils.readDeclaredField(publiclyShadowedChild, \"i\"));\n+        FieldUtils.writeDeclaredField(publiclyShadowedChild, \"d\", new Double(0.0));\n+        assertEquals(new Double(0.0), FieldUtils.readDeclaredField(publiclyShadowedChild, \"d\"));\n+\n+        try {\n+            FieldUtils.writeDeclaredField(privatelyShadowedChild, \"s\", \"S\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredField(privatelyShadowedChild, \"b\", Boolean.TRUE);\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredField(privatelyShadowedChild, \"i\", new Integer(1));\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredField(privatelyShadowedChild, \"d\", new Double(1.0));\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testWriteDeclaredNamedFieldForceAccess() throws Exception {\n+        try {\n+            FieldUtils.writeDeclaredField(publicChild, \"s\", \"S\", true);\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredField(publicChild, \"b\", Boolean.TRUE, true);\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredField(publicChild, \"i\", new Integer(1), true);\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredField(publicChild, \"d\", new Double(1.0), true);\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+\n+        FieldUtils.writeDeclaredField(publiclyShadowedChild, \"s\", \"S\", true);\n+        assertEquals(\"S\", FieldUtils.readDeclaredField(publiclyShadowedChild, \"s\", true));\n+        FieldUtils.writeDeclaredField(publiclyShadowedChild, \"b\", Boolean.FALSE, true);\n+        assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publiclyShadowedChild, \"b\", true));\n+        FieldUtils.writeDeclaredField(publiclyShadowedChild, \"i\", new Integer(0), true);\n+        assertEquals(new Integer(0), FieldUtils.readDeclaredField(publiclyShadowedChild, \"i\", true));\n+        FieldUtils.writeDeclaredField(publiclyShadowedChild, \"d\", new Double(0.0), true);\n+        assertEquals(new Double(0.0), FieldUtils.readDeclaredField(publiclyShadowedChild, \"d\", true));\n+\n+        FieldUtils.writeDeclaredField(privatelyShadowedChild, \"s\", \"S\", true);\n+        assertEquals(\"S\", FieldUtils.readDeclaredField(privatelyShadowedChild, \"s\", true));\n+        FieldUtils.writeDeclaredField(privatelyShadowedChild, \"b\", Boolean.FALSE, true);\n+        assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(privatelyShadowedChild, \"b\", true));\n+        FieldUtils.writeDeclaredField(privatelyShadowedChild, \"i\", new Integer(0), true);\n+        assertEquals(new Integer(0), FieldUtils.readDeclaredField(privatelyShadowedChild, \"i\", true));\n+        FieldUtils.writeDeclaredField(privatelyShadowedChild, \"d\", new Double(0.0), true);\n+        assertEquals(new Double(0.0), FieldUtils.readDeclaredField(privatelyShadowedChild, \"d\", true));\n+    }\n+\n+    public void testAmbig() {\n+        try {\n+            FieldUtils.getField(Ambig.class, \"VALUE\");\n+            fail(\"should have failed on interface field ambiguity\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/reflect/MethodUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.math.NumberUtils;\n+import org.apache.commons.lang.mutable.Mutable;\n+import org.apache.commons.lang.mutable.MutableObject;\n+\n+/**\n+ * Unit tests MethodUtils\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public class MethodUtilsTest extends TestCase {\n+    public static class TestBean {\n+\n+        public static String bar() {\n+            return \"bar()\";\n+        }\n+\n+        public static String bar(int i) {\n+            return \"bar(int)\";\n+        }\n+\n+        public static String bar(Integer i) {\n+            return \"bar(Integer)\";\n+        }\n+\n+        public static String bar(double d) {\n+            return \"bar(double)\";\n+        }\n+\n+        public static String bar(String s) {\n+            return \"bar(String)\";\n+        }\n+\n+        public static String bar(Object o) {\n+            return \"bar(Object)\";\n+        }\n+\n+        public String foo() {\n+            return \"foo()\";\n+        }\n+\n+        public String foo(int i) {\n+            return \"foo(int)\";\n+        }\n+\n+        public String foo(Integer i) {\n+            return \"foo(Integer)\";\n+        }\n+\n+        public String foo(double d) {\n+            return \"foo(double)\";\n+        }\n+\n+        public String foo(String s) {\n+            return \"foo(String)\";\n+        }\n+\n+        public String foo(Object o) {\n+            return \"foo(Object)\";\n+        }\n+    }\n+\n+    private static class TestMutable implements Mutable {\n+        public Object getValue() {\n+            return null;\n+        }\n+\n+        public void setValue(Object value) {\n+        }\n+    }\n+\n+    private TestBean testBean;\n+    private Map classCache;\n+\n+    public MethodUtilsTest(String name) {\n+        super(name);\n+        classCache = new HashMap();\n+    }\n+\n+    /**\n+     * Run the test cases as a suite.\n+     * @return the Test\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(MethodUtilsTest.class);\n+        suite.setName(\"MethodUtils Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        testBean = new TestBean();\n+        classCache.clear();\n+    }\n+\n+    public void testConstructor() throws Exception {\n+        assertNotNull(MethodUtils.class.newInstance());\n+    }\n+\n+    public void testInvokeMethod() throws Exception {\n+        assertEquals(\"foo()\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                ArrayUtils.EMPTY_CLASS_ARRAY));\n+        assertEquals(\"foo()\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                (Class[]) null));\n+        assertEquals(\"foo(String)\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                \"\"));\n+        assertEquals(\"foo(Object)\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                new Object()));\n+        assertEquals(\"foo(Object)\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                Boolean.TRUE));\n+        assertEquals(\"foo(Integer)\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                NumberUtils.INTEGER_ONE));\n+        assertEquals(\"foo(int)\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                NumberUtils.BYTE_ONE));\n+        assertEquals(\"foo(double)\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                NumberUtils.LONG_ONE));\n+        assertEquals(\"foo(double)\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                NumberUtils.DOUBLE_ONE));\n+    }\n+\n+    public void testInvokeExactMethod() throws Exception {\n+        assertEquals(\"foo()\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                ArrayUtils.EMPTY_CLASS_ARRAY));\n+        assertEquals(\"foo()\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                (Class[]) null));\n+        assertEquals(\"foo(String)\", MethodUtils.invokeExactMethod(testBean,\n+                \"foo\", \"\"));\n+        assertEquals(\"foo(Object)\", MethodUtils.invokeExactMethod(testBean,\n+                \"foo\", new Object()));\n+        assertEquals(\"foo(Integer)\", MethodUtils.invokeExactMethod(testBean,\n+                \"foo\", NumberUtils.INTEGER_ONE));\n+        assertEquals(\"foo(double)\", MethodUtils.invokeExactMethod(testBean,\n+                \"foo\", new Object[] { NumberUtils.DOUBLE_ONE },\n+                new Class[] { Double.TYPE }));\n+\n+        try {\n+            MethodUtils\n+                    .invokeExactMethod(testBean, \"foo\", NumberUtils.BYTE_ONE);\n+            fail(\"should throw NoSuchMethodException\");\n+        } catch (NoSuchMethodException e) {\n+        }\n+        try {\n+            MethodUtils\n+                    .invokeExactMethod(testBean, \"foo\", NumberUtils.LONG_ONE);\n+            fail(\"should throw NoSuchMethodException\");\n+        } catch (NoSuchMethodException e) {\n+        }\n+        try {\n+            MethodUtils.invokeExactMethod(testBean, \"foo\", Boolean.TRUE);\n+            fail(\"should throw NoSuchMethodException\");\n+        } catch (NoSuchMethodException e) {\n+        }\n+    }\n+\n+    public void testInvokeStaticMethod() throws Exception {\n+        assertEquals(\"bar()\", MethodUtils.invokeStaticMethod(TestBean.class,\n+                \"bar\", ArrayUtils.EMPTY_CLASS_ARRAY));\n+        assertEquals(\"bar()\", MethodUtils.invokeStaticMethod(TestBean.class,\n+                \"bar\", (Class[]) null));\n+        assertEquals(\"bar(String)\", MethodUtils.invokeStaticMethod(\n+                TestBean.class, \"bar\", \"\"));\n+        assertEquals(\"bar(Object)\", MethodUtils.invokeStaticMethod(\n+                TestBean.class, \"bar\", new Object()));\n+        assertEquals(\"bar(Object)\", MethodUtils.invokeStaticMethod(\n+                TestBean.class, \"bar\", Boolean.TRUE));\n+        assertEquals(\"bar(Integer)\", MethodUtils.invokeStaticMethod(\n+                TestBean.class, \"bar\", NumberUtils.INTEGER_ONE));\n+        assertEquals(\"bar(int)\", MethodUtils.invokeStaticMethod(TestBean.class,\n+                \"bar\", NumberUtils.BYTE_ONE));\n+        assertEquals(\"bar(double)\", MethodUtils.invokeStaticMethod(\n+                TestBean.class, \"bar\", NumberUtils.LONG_ONE));\n+        assertEquals(\"bar(double)\", MethodUtils.invokeStaticMethod(\n+                TestBean.class, \"bar\", NumberUtils.DOUBLE_ONE));\n+    }\n+\n+    public void testInvokeExactStaticMethod() throws Exception {\n+        assertEquals(\"bar()\", MethodUtils.invokeStaticMethod(TestBean.class,\n+                \"bar\", ArrayUtils.EMPTY_CLASS_ARRAY));\n+        assertEquals(\"bar()\", MethodUtils.invokeStaticMethod(TestBean.class,\n+                \"bar\", (Class[]) null));\n+        assertEquals(\"bar(String)\", MethodUtils.invokeExactStaticMethod(\n+                TestBean.class, \"bar\", \"\"));\n+        assertEquals(\"bar(Object)\", MethodUtils.invokeExactStaticMethod(\n+                TestBean.class, \"bar\", new Object()));\n+        assertEquals(\"bar(Integer)\", MethodUtils.invokeExactStaticMethod(\n+                TestBean.class, \"bar\", NumberUtils.INTEGER_ONE));\n+        assertEquals(\"bar(double)\", MethodUtils.invokeExactStaticMethod(\n+                TestBean.class, \"bar\", new Object[] { NumberUtils.DOUBLE_ONE },\n+                new Class[] { Double.TYPE }));\n+\n+        try {\n+            MethodUtils.invokeExactStaticMethod(TestBean.class, \"bar\",\n+                    NumberUtils.BYTE_ONE);\n+            fail(\"should throw NoSuchMethodException\");\n+        } catch (NoSuchMethodException e) {\n+        }\n+        try {\n+            MethodUtils.invokeExactStaticMethod(TestBean.class, \"bar\",\n+                    NumberUtils.LONG_ONE);\n+            fail(\"should throw NoSuchMethodException\");\n+        } catch (NoSuchMethodException e) {\n+        }\n+        try {\n+            MethodUtils.invokeExactStaticMethod(TestBean.class, \"bar\",\n+                    Boolean.TRUE);\n+            fail(\"should throw NoSuchMethodException\");\n+        } catch (NoSuchMethodException e) {\n+        }\n+    }\n+\n+    public void testGetAccessibleInterfaceMethod() throws Exception {\n+\n+        Class[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null };\n+        for (int i = 0; i < p.length; i++) {\n+            Method method = TestMutable.class.getMethod(\"getValue\", p[i]);\n+            Method accessibleMethod = MethodUtils.getAccessibleMethod(method);\n+            assertNotSame(accessibleMethod, method);\n+            assertSame(Mutable.class, accessibleMethod.getDeclaringClass());\n+        }\n+    }\n+\n+    public void testGetAccessibleInterfaceMethodFromDescription()\n+            throws Exception {\n+        Class[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null };\n+        for (int i = 0; i < p.length; i++) {\n+            Method accessibleMethod = MethodUtils.getAccessibleMethod(\n+                    TestMutable.class, \"getValue\", p[i]);\n+            assertSame(Mutable.class, accessibleMethod.getDeclaringClass());\n+        }\n+    }\n+\n+    public void testGetAccessiblePublicMethod() throws Exception {\n+        assertSame(MutableObject.class, MethodUtils.getAccessibleMethod(\n+                MutableObject.class.getMethod(\"getValue\",\n+                        ArrayUtils.EMPTY_CLASS_ARRAY)).getDeclaringClass());\n+    }\n+\n+    public void testGetAccessiblePublicMethodFromDescription() throws Exception {\n+        assertSame(MutableObject.class, MethodUtils.getAccessibleMethod(\n+                MutableObject.class, \"getValue\", ArrayUtils.EMPTY_CLASS_ARRAY)\n+                .getDeclaringClass());\n+    }\n+\n+    public void testGetMatchingAccessibleMethod() throws Exception {\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY);\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                null, ArrayUtils.EMPTY_CLASS_ARRAY);\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(String.class), singletonArray(String.class));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Object.class), singletonArray(Object.class));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Boolean.class), singletonArray(Object.class));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Byte.class), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Byte.TYPE), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Short.class), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Short.TYPE), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Character.class), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Character.TYPE), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Integer.class), singletonArray(Integer.class));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Integer.TYPE), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Long.class), singletonArray(Double.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Long.TYPE), singletonArray(Double.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Float.class), singletonArray(Double.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Float.TYPE), singletonArray(Double.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Double.class), singletonArray(Double.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Double.TYPE), singletonArray(Double.TYPE));\n+    }\n+\n+    private void expectMatchingAccessibleMethodParameterTypes(Class cls,\n+            String methodName, Class[] requestTypes, Class[] actualTypes) {\n+        Method m = MethodUtils.getMatchingAccessibleMethod(cls, methodName,\n+                requestTypes);\n+        assertTrue(Arrays.toString(m.getParameterTypes()) + \" not equals \"\n+                + Arrays.toString(actualTypes), Arrays.equals(actualTypes, m\n+                .getParameterTypes()));\n+    }\n+\n+    public void testSetCacheMethods() throws Exception {\n+        MethodUtils.clearCache();\n+        MethodUtils.setCacheMethods(true);\n+        MethodUtils.invokeMethod(testBean, \"foo\", \"\");\n+        assertEquals(1, MethodUtils.clearCache());\n+        assertEquals(0, MethodUtils.clearCache());\n+        MethodUtils.setCacheMethods(false);\n+        MethodUtils.invokeMethod(testBean, \"foo\", \"\");\n+        assertEquals(0, MethodUtils.clearCache());\n+        MethodUtils.setCacheMethods(true);\n+    }\n+\n+    private Class[] singletonArray(Class c) {\n+        Class[] result = (Class[]) classCache.get(c);\n+        if (result == null) {\n+            result = new Class[] { c };\n+            classCache.put(c, result);\n+        }\n+        return result;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/reflect/ReflectTestSuite.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Test suite for the reflect package.\n+ *\n+ * @author Matt Benson\n+ * @version $Id$\n+ */\n+public class ReflectTestSuite extends TestCase {\n+    \n+    /**\n+     * Construct a new instance.\n+     */\n+    public ReflectTestSuite(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Command-line interface.\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Get the suite of tests\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite();\n+        suite.setName(\"Commons-Lang-Reflect Tests\");\n+        suite.addTest(ConstructorUtilsTest.suite());\n+        suite.addTest(FieldUtilsTest.suite());\n+        suite.addTest(MethodUtilsTest.suite());\n+        return suite;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/reflect/testbed/Ambig.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+/**\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public class Ambig implements Foo, Bar {\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/reflect/testbed/Bar.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+/**\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public interface Bar {\n+    public static final String VALUE = \"bar\";\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/reflect/testbed/Foo.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+/**\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public interface Foo {\n+    public static final String VALUE = \"foo\";\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/reflect/testbed/Parent.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+/**\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+class Parent implements Foo {\n+    public String s = \"s\";\n+    protected boolean b = false;\n+    int i = 0;\n+    private double d = 0.0;\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/reflect/testbed/PrivatelyShadowedChild.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+/**\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public class PrivatelyShadowedChild extends Parent {\n+    private String s = \"ss\";\n+    private boolean b = true;\n+    private int i = 1;\n+    private double d = 1.0;\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/reflect/testbed/PublicChild.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+/**\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public class PublicChild extends Parent {\n+    static final String VALUE = \"child\";\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/reflect/testbed/PubliclyShadowedChild.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+/**\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public class PubliclyShadowedChild extends Parent {\n+    public String s = \"ss\";\n+    public boolean b = true;\n+    public int i = 1;\n+    public double d = 1.0;\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/reflect/testbed/StaticContainer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+/**\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public class StaticContainer {\n+    public static final Object IMMUTABLE_PUBLIC = \"public\";\n+    protected static final Object IMMUTABLE_PROTECTED = \"protected\";\n+    static final Object IMMUTABLE_PACKAGE = \"\";\n+    private static final Object IMMUTABLE_PRIVATE = \"private\";\n+\n+    public static Object mutablePublic;\n+    protected static Object mutableProtected;\n+    static Object mutablePackage;\n+    private static Object mutablePrivate;\n+\n+    public static void reset() {\n+        mutablePublic = null;\n+        mutableProtected = null;\n+        mutablePackage = null;\n+        mutablePrivate = null;\n+    }\n+\n+    public static Object getMutableProtected() {\n+        return mutableProtected;\n+    }\n+\n+    public static Object getMutablePackage() {\n+        return mutablePackage;\n+    }\n+\n+    public static Object getMutablePrivate() {\n+        return mutablePrivate;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/reflect/testbed/StaticContainerChild.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+/**\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public class StaticContainerChild extends StaticContainer {\n+\n+}", "timestamp": 1210106711, "metainfo": ""}