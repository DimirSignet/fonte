{"sha": "d9afb9c60942ab0cf655311e1a992be6c926945d", "log": "Copying from Collections to Lang  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/compare/BulkTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * A {@link TestCase} that can define both simple and bulk test methods.\n+ * <p>\n+ * A <I>simple test method</I> is the type of test traditionally \n+ * supplied by by {@link TestCase}.  To define a simple test, create a public \n+ * no-argument method whose name starts with \"test\".  You can specify the\n+ * the name of simple test in the constructor of <code>BulkTest</code>;\n+ * a subsequent call to {@link TestCase#run} will run that simple test.\n+ * <p>\n+ * A <I>bulk test method</I>, on the other hand, returns a new instance\n+ * of <code>BulkTest</code>, which can itself define new simple and bulk\n+ * test methods.  By using the {@link #makeSuite} method, you can \n+ * automatically create a hierarchal suite of tests and child bulk tests.\n+ * <p>\n+ * For instance, consider the following two classes:\n+ *\n+ * <Pre>\n+ *  public class TestSet extends BulkTest {\n+ *\n+ *      private Set set;\n+ *\n+ *      public TestSet(Set set) {\n+ *          this.set = set;\n+ *      }\n+ *\n+ *      public void testContains() {\n+ *          boolean r = set.contains(set.iterator().next()));\n+ *          assertTrue(\"Set should contain first element, r);\n+ *      }\n+ *\n+ *      public void testClear() {\n+ *          set.clear();\n+ *          assertTrue(\"Set should be empty after clear\", set.isEmpty());\n+ *      }\n+ *  }\n+ *\n+ *\n+ *  public class TestHashMap extends BulkTest {\n+ *\n+ *      private Map makeFullMap() {\n+ *          HashMap result = new HashMap();\n+ *          result.put(\"1\", \"One\");\n+ *          result.put(\"2\", \"Two\");\n+ *          return result;\n+ *      }\n+ *\n+ *      public void testClear() {\n+ *          Map map = makeFullMap();\n+ *          map.clear();\n+ *          assertTrue(\"Map empty after clear\", map.isEmpty());\n+ *      }\n+ *\n+ *      public BulkTest bulkTestKeySet() {\n+ *          return new TestSet(makeFullMap().keySet());\n+ *      }\n+ *\n+ *      public BulkTest bulkTestEntrySet() {\n+ *          return new TestSet(makeFullMap().entrySet());\n+ *      }\n+ *  }\n+ *  </Pre>\n+ *\n+ *  In the above examples, <code>TestSet</code> defines two\n+ *  simple test methods and no bulk test methods; <code>TestHashMap</code>\n+ *  defines one simple test method and two bulk test methods.  When\n+ *  <code>makeSuite(TestHashMap.class).run</code> is executed, \n+ *  <I>five</I> simple test methods will be run, in this order:<P>\n+ *\n+ *  <Ol>\n+ *  <Li>TestHashMap.testClear()\n+ *  <Li>TestHashMap.bulkTestKeySet().testContains();\n+ *  <Li>TestHashMap.bulkTestKeySet().testClear();\n+ *  <Li>TestHashMap.bulkTestEntrySet().testContains();\n+ *  <Li>TestHashMap.bulkTestEntrySet().testClear();\n+ *  </Ol>\n+ *\n+ *  In the graphical junit test runners, the tests would be displayed in\n+ *  the following tree:<P>\n+ *\n+ *  <UL>\n+ *  <LI>TestHashMap</LI>\n+ *      <UL>\n+ *      <LI>testClear\n+ *      <LI>bulkTestKeySet\n+ *          <UL>\n+ *          <LI>testContains\n+ *          <LI>testClear\n+ *          </UL>\n+ *      <LI>bulkTestEntrySet\n+ *          <UL>\n+ *          <LI>testContains\n+ *          <LI>testClear\n+ *          </UL>\n+ *      </UL>\n+ *  </UL>\n+ *\n+ *  A subclass can override a superclass's bulk test by\n+ *  returning <code>null</code> from the bulk test method.  If you only\n+ *  want to override specific simple tests within a bulk test, use the\n+ *  {@link #ignoredTests} method.<P>\n+ *\n+ *  Note that if you want to use the bulk test methods, you <I>must</I>\n+ *  define your <code>suite()</code> method to use {@link #makeSuite}.\n+ *  The ordinary {@link TestSuite} constructor doesn't know how to \n+ *  interpret bulk test methods.\n+ *\n+ *  @author Paul Jack\n+ *  @version $Id$\n+ */\n+public class BulkTest extends TestCase implements Cloneable {\n+\n+\n+    // Note:  BulkTest is Cloneable to make it easier to construct \n+    // BulkTest instances for simple test methods that are defined in \n+    // anonymous inner classes.  Basically we don't have to worry about\n+    // finding weird constructors.  (And even if we found them, technically\n+    // it'd be illegal for anyone but the outer class to invoke them).  \n+    // Given one BulkTest instance, we can just clone it and reset the \n+    // method name for every simple test it defines.  \n+\n+\n+    /**\n+     *  The full name of this bulk test instance.  This is the full name\n+     *  that is compared to {@link #ignoredTests} to see if this\n+     *  test should be ignored.  It's also displayed in the text runner\n+     *  to ease debugging.\n+     */\n+    String verboseName;\n+\n+\n+    /**\n+     *  Constructs a new <code>BulkTest</code> instance that will run the\n+     *  specified simple test.\n+     *\n+     *  @param name  the name of the simple test method to run\n+     */\n+    public BulkTest(String name) {\n+        super(name);\n+        this.verboseName = getClass().getName();\n+    }\n+\n+\n+    /**\n+     *  Creates a clone of this <code>BulkTest</code>.<P>\n+     *\n+     *  @return  a clone of this <code>BulkTest</code>\n+     */\n+    @Override\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (CloneNotSupportedException e) {\n+            throw new Error(); // should never happen\n+        }\n+    }\n+\n+\n+    /**\n+     *  Returns an array of test names to ignore.<P>\n+     *\n+     *  If a test that's defined by this <code>BulkTest</code> or\n+     *  by one of its bulk test methods has a name that's in the returned\n+     *  array, then that simple test will not be executed.<P>\n+     *\n+     *  A test's name is formed by taking the class name of the\n+     *  root <code>BulkTest</code>, eliminating the package name, then\n+     *  appending the names of any bulk test methods that were invoked\n+     *  to get to the simple test, and then appending the simple test\n+     *  method name.  The method names are delimited by periods:\n+     *\n+     *  <pre>\n+     *  TestHashMap.bulkTestEntrySet.testClear\n+     *  </pre>\n+     *\n+     *  is the name of one of the simple tests defined in the sample classes\n+     *  described above.  If the sample <code>TestHashMap</code> class\n+     *  included this method:\n+     *\n+     *  <pre>\n+     *  public String[] ignoredTests() {\n+     *      return new String[] { \"TestHashMap.bulkTestEntrySet.testClear\" };\n+     *  }\n+     *  </pre>\n+     *\n+     *  then the entry set's clear method wouldn't be tested, but the key\n+     *  set's clear method would.\n+     *\n+     *  @return an array of the names of tests to ignore, or null if\n+     *   no tests should be ignored\n+     */\n+    public String[] ignoredTests() {\n+        return null;\n+    }\n+\n+\n+    /**\n+     *  Returns the display name of this <code>BulkTest</code>.\n+     *\n+     *  @return the display name of this <code>BulkTest</code>\n+     */\n+    @Override\n+    public String toString() {\n+        return getName() + \"(\" + verboseName + \") \";\n+    }\n+\n+\n+    /**\n+     *  Returns a {@link TestSuite} for testing all of the simple tests\n+     *  <I>and</I> all the bulk tests defined by the given class.<P>\n+     *\n+     *  The class is examined for simple and bulk test methods; any child\n+     *  bulk tests are also examined recursively; and the results are stored\n+     *  in a hierarchal {@link TestSuite}.<P>\n+     *\n+     *  The given class must be a subclass of <code>BulkTest</code> and must\n+     *  not be abstract.<P>\n+     *\n+     *  @param c  the class to examine for simple and bulk tests\n+     *  @return  a {@link TestSuite} containing all the simple and bulk tests\n+     *    defined by that class\n+     */\n+    public static TestSuite makeSuite(Class<? extends BulkTest> c) {\n+        if (Modifier.isAbstract(c.getModifiers())) {\n+            throw new IllegalArgumentException(\"Class must not be abstract.\");\n+        }\n+        if (!BulkTest.class.isAssignableFrom(c)) {\n+            throw new IllegalArgumentException(\"Class must extend BulkTest.\");\n+        }\n+        return new BulkTestSuiteMaker(c).make();\n+    }\n+\n+}\n+\n+\n+// It was easier to use a separate class to do all the reflection stuff\n+// for making the TestSuite instances.  Having permanent state around makes\n+// it easier to handle the recursion.\n+class BulkTestSuiteMaker {\n+\n+    /** The class that defines simple and bulk tests methods. */\n+    private Class<? extends BulkTest> startingClass;\n+\n+    /** List of ignored simple test names. */\n+    private List<String> ignored;\n+   \n+    /** The TestSuite we're currently populating.  Can change over time. */\n+    private TestSuite result;\n+\n+    /** \n+     *  The prefix for simple test methods.  Used to check if a test is in \n+     *  the ignored list.\n+     */ \n+    private String prefix;\n+\n+    /** \n+     *  Constructor.\n+     *\n+     *  @param startingClass  the starting class\n+     */     \n+    public BulkTestSuiteMaker(Class<? extends BulkTest> startingClass) {\n+        this.startingClass = startingClass;\n+    }\n+\n+    /**\n+     *  Makes a hierarchal TestSuite based on the starting class.\n+     *\n+     *  @return  the hierarchal TestSuite for startingClass\n+     */\n+    public TestSuite make() {\n+         this.result = new TestSuite();\n+         this.prefix = getBaseName(startingClass);\n+         result.setName(prefix);\n+\n+         BulkTest bulk = makeFirstTestCase(startingClass);\n+         ignored = new ArrayList<String>();\n+         String[] s = bulk.ignoredTests();\n+         if (s != null) {\n+             ignored.addAll(Arrays.asList(s));\n+         }\n+         make(bulk);\n+         return result;\n+    }\n+\n+    /**\n+     *  Appends all the simple tests and bulk tests defined by the given\n+     *  instance's class to the current TestSuite.\n+     *\n+     *  @param bulk  An instance of the class that defines simple and bulk\n+     *    tests for us to append\n+     */\n+    void make(BulkTest bulk) {\n+        Class<? extends BulkTest> c = bulk.getClass();\n+        Method[] all = c.getMethods();\n+        for (int i = 0; i < all.length; i++) {\n+            if (isTest(all[i])) addTest(bulk, all[i]);\n+            if (isBulk(all[i])) addBulk(bulk, all[i]);\n+        }\n+    }\n+\n+    /**\n+     *  Adds the simple test defined by the given method to the TestSuite.\n+     *\n+     *  @param bulk  The instance of the class that defined the method\n+     *   (I know it's weird.  But the point is, we can clone the instance\n+     *   and not have to worry about constructors.)\n+     *  @param m  The simple test method\n+     */\n+    void addTest(BulkTest bulk, Method m) {\n+        BulkTest bulk2 = (BulkTest)bulk.clone();\n+        bulk2.setName(m.getName());\n+        bulk2.verboseName = prefix + \".\" + m.getName();\n+        if (ignored.contains(bulk2.verboseName)) return;\n+        result.addTest(bulk2);\n+    }\n+\n+    /**\n+     *  Adds a whole new suite of tests that are defined by the result of\n+     *  the given bulk test method.  In other words, the given bulk test\n+     *  method is invoked, and the resulting BulkTest instance is examined\n+     *  for yet more simple and bulk tests.\n+     *\n+     *  @param bulk  The instance of the class that defined the method\n+     *  @param m  The bulk test method\n+     */\n+    void addBulk(BulkTest bulk, Method m) {\n+        String verboseName = prefix + \".\" + m.getName();\n+        if (ignored.contains(verboseName)) return;\n+        \n+        BulkTest bulk2;\n+        try {\n+            bulk2 = (BulkTest)m.invoke(bulk, (Object[]) null);\n+            if (bulk2 == null) return;\n+        } catch (InvocationTargetException ex) {\n+            ex.getTargetException().printStackTrace();\n+            throw new Error(); // FIXME;\n+        } catch (IllegalAccessException ex) {\n+            ex.printStackTrace();\n+            throw new Error(); // FIXME;\n+        }\n+\n+        // Save current state on the stack.\n+        String oldPrefix = prefix;\n+        TestSuite oldResult = result;\n+\n+        prefix = prefix + \".\" + m.getName();\n+        result = new TestSuite();\n+        result.setName(m.getName());\n+\n+        make(bulk2);\n+\n+        oldResult.addTest(result);\n+\n+        // Restore the old state\n+        prefix = oldPrefix;\n+        result = oldResult;\n+    }\n+\n+    /**\n+     *  Returns the base name of the given class.\n+     *\n+     *  @param c  the class\n+     *  @return the name of that class, minus any package names\n+     */\n+    private static String getBaseName(Class<?> c) {\n+        String name = c.getName();\n+        int p = name.lastIndexOf('.');\n+        if (p > 0) {\n+            name = name.substring(p + 1);\n+        }\n+        return name;\n+    }\n+\n+\n+    // These three methods are used to create a valid BulkTest instance\n+    // from a class.\n+\n+    private static <T> Constructor<T> getTestCaseConstructor(Class<T> c) {\n+        try {\n+            return c.getConstructor(new Class[] { String.class });\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalArgumentException(c + \" must provide \" +\n+             \"a (String) constructor\");\n+        }\n+    }\n+\n+    private static <T extends BulkTest> BulkTest makeTestCase(Class<T> c, Method m) {\n+        Constructor<T> con = getTestCaseConstructor(c);\n+        try {\n+            return con.newInstance(new Object[] { m.getName() });\n+        } catch (InvocationTargetException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(); // FIXME;\n+        } catch (IllegalAccessException e) {\n+            throw new Error(); // should never occur\n+        } catch (InstantiationException e) {\n+            throw new RuntimeException(); // FIXME;\n+        }\n+    }\n+\n+    private static <T extends BulkTest> BulkTest makeFirstTestCase(Class<T> c) {\n+        Method[] all = c.getMethods();\n+        for (int i = 0; i < all.length; i++) {\n+            if (isTest(all[i])) return makeTestCase(c, all[i]);\n+        }\n+        throw new IllegalArgumentException(c.getName() + \" must provide \" \n+          + \" at least one test method.\");\n+    }\n+\n+    /**\n+     *  Returns true if the given method is a simple test method.\n+     */\n+    private static boolean isTest(Method m) {\n+        if (!m.getName().startsWith(\"test\")) return false;\n+        if (m.getReturnType() != Void.TYPE) return false;\n+        if (m.getParameterTypes().length != 0) return false;\n+        int mods = m.getModifiers();\n+        if (Modifier.isStatic(mods)) return false;\n+        if (Modifier.isAbstract(mods)) return false;\n+        return true;\n+    }\n+\n+    /**\n+     *  Returns true if the given method is a bulk test method.\n+     */\n+    private static boolean isBulk(Method m) {\n+        if (!m.getName().startsWith(\"bulkTest\")) return false;\n+        if (m.getReturnType() != BulkTest.class) return false;\n+        if (m.getParameterTypes().length != 0) return false;\n+        int mods = m.getModifiers();\n+        if (Modifier.isStatic(mods)) return false;\n+        if (Modifier.isAbstract(mods)) return false;\n+        return true;\n+    }\n+\n+}", "timestamp": 1312780694, "metainfo": ""}