{"sha": "af1dde707f2dd615681d8358efe2a24016e5d18a", "log": "Moving lastIndexOf, contains, containsWhitespace, indexOfAny, containsAny, indexOfAnyBut, containsOnly, containsNone and substring over to using CharSequences for parameters. LANG-687  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n     // LastIndexOf\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Finds the last index within a String, handling {@code null}.\n-     * This method uses {@link String#lastIndexOf(int)}.</p>\n-     *\n-     * <p>A {@code null} or empty (\"\") String will return {@code -1}.</p>\n+     * <p>Finds the last index within a CharSequence, handling {@code null}.\n+     * This method uses {@link String#lastIndexOf(int)} if possible.</p>\n+     *\n+     * <p>A {@code null} or empty (\"\") CharSequence will return {@code -1}.</p>\n      *\n      * <pre>\n      * StringUtils.lastIndexOf(null, *)         = -1\n      * StringUtils.lastIndexOf(\"aabaabaa\", 'b') = 5\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param seq  the CharSequence to check, may be null\n      * @param searchChar  the character to find\n      * @return the last index of the search character,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int lastIndexOf(String str, int searchChar) {\n-        if (isEmpty(str)) {\n+    public static int lastIndexOf(CharSequence seq, int searchChar) {\n+        if (isEmpty(seq)) {\n             return INDEX_NOT_FOUND;\n         }\n-        return str.lastIndexOf(searchChar);\n-    }\n-\n-    /**\n-     * <p>Finds the last index within a String from a start position,\n+        return StringUtils.lastIndexOfSequence(seq, searchChar, seq.length());\n+    }\n+\n+    /**\n+     * <p>Finds the last index within a CharSequence from a start position,\n      * handling {@code null}.\n-     * This method uses {@link String#lastIndexOf(int, int)}.</p>\n-     *\n-     * <p>A {@code null} or empty (\"\") String will return {@code -1}.\n+     * This method uses {@link String#lastIndexOf(int, int)} if possible.</p>\n+     *\n+     * <p>A {@code null} or empty (\"\") CharSequence will return {@code -1}.\n      * A negative start position returns {@code -1}.\n      * A start position greater than the string length searches the whole string.</p>\n      *\n      * StringUtils.lastIndexOf(\"aabaabaa\", 'a', 0)  = 0\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param seq  the CharSequence to check, may be null\n      * @param searchChar  the character to find\n      * @param startPos  the start position\n      * @return the last index of the search character,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int lastIndexOf(String str, int searchChar, int startPos) {\n-        if (isEmpty(str)) {\n+    public static int lastIndexOf(CharSequence seq, int searchChar, int startPos) {\n+        if (isEmpty(seq)) {\n             return INDEX_NOT_FOUND;\n         }\n-        return str.lastIndexOf(searchChar, startPos);\n-    }\n-\n-    /**\n-     * <p>Finds the last index within a String, handling {@code null}.\n-     * This method uses {@link String#lastIndexOf(String)}.</p>\n-     *\n-     * <p>A {@code null} String will return {@code -1}.</p>\n+        return StringUtils.lastIndexOfSequence(seq, searchChar, startPos);\n+    }\n+\n+    /**\n+     * <p>Finds the last index within a CharSequence, handling {@code null}.\n+     * This method uses {@link String#lastIndexOf(String)} if possible.</p>\n+     *\n+     * <p>A {@code null} CharSequence will return {@code -1}.</p>\n      *\n      * <pre>\n      * StringUtils.lastIndexOf(null, *)          = -1\n      * StringUtils.lastIndexOf(\"aabaabaa\", \"\")   = 8\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n-     * @param searchStr  the String to find, may be null\n+     * @param seq  the CharSequence to check, may be null\n+     * @param searchSeq  the CharSequence to find, may be null\n      * @return the last index of the search String,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int lastIndexOf(String str, String searchStr) {\n-        if (str == null || searchStr == null) {\n+    public static int lastIndexOf(CharSequence seq, CharSequence searchSeq) {\n+        if (seq == null || searchSeq == null) {\n             return INDEX_NOT_FOUND;\n         }\n-        return str.lastIndexOf(searchStr);\n+        return StringUtils.lastIndexOfSequence(seq, searchSeq, seq.length());\n     }\n \n     /**\n     }\n \n     /**\n-     * <p>Finds the first index within a String, handling {@code null}.\n-     * This method uses {@link String#lastIndexOf(String, int)}.</p>\n-     *\n-     * <p>A {@code null} String will return {@code -1}.\n+     * <p>Finds the first index within a CharSequence, handling {@code null}.\n+     * This method uses {@link String#lastIndexOf(String, int)} if possible.</p>\n+     *\n+     * <p>A {@code null} CharSequence will return {@code -1}.\n      * A negative start position returns {@code -1}.\n-     * An empty (\"\") search String always matches unless the start position is negative.\n+     * An empty (\"\") search CharSequence always matches unless the start position is negative.\n      * A start position greater than the string length searches the whole string.</p>\n      *\n      * <pre>\n      * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 0)  = -1\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n-     * @param searchStr  the String to find, may be null\n+     * @param seq  the CharSequence to check, may be null\n+     * @param searchSeq  the CharSequence to find, may be null\n      * @param startPos  the start position, negative treated as zero\n-     * @return the first index of the search String,\n+     * @return the first index of the search CharSequence,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int lastIndexOf(String str, String searchStr, int startPos) {\n-        if (str == null || searchStr == null) {\n+    public static int lastIndexOf(CharSequence seq, CharSequence searchSeq, int startPos) {\n+        if (seq == null || searchSeq == null) {\n             return INDEX_NOT_FOUND;\n         }\n-        return str.lastIndexOf(searchStr, startPos);\n+        return StringUtils.lastIndexOfSequence(seq, searchSeq, startPos);\n     }\n \n     /**\n     }\n \n     /**\n-     * <p>Checks if String contains a search String, handling {@code null}.\n-     * This method uses {@link String#indexOf(String)}.</p>\n-     *\n-     * <p>A {@code null} String will return {@code false}.</p>\n+     * <p>Checks if CharSequence contains a search CharSequence, handling {@code null}.\n+     * This method uses {@link String#indexOf(String)} if possible.</p>\n+     *\n+     * <p>A {@code null} CharSequence will return {@code false}.</p>\n      *\n      * <pre>\n      * StringUtils.contains(null, *)     = false\n      * StringUtils.contains(\"abc\", \"z\")  = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n-     * @param searchStr  the String to find, may be null\n-     * @return true if the String contains the search String,\n+     * @param seq  the CharSequence to check, may be null\n+     * @param searchSeq  the CharSequence to find, may be null\n+     * @return true if the CharSequence contains the search CharSequence,\n      *  false if not or {@code null} string input\n      * @since 2.0\n      */\n-    public static boolean contains(String str, String searchStr) {\n-        if (str == null || searchStr == null) {\n+    public static boolean contains(CharSequence seq, CharSequence searchSeq) {\n+        if (seq == null || searchSeq == null) {\n             return false;\n         }\n-        return str.indexOf(searchStr) >= 0;\n+        return indexOfSequence(seq, searchSeq, 0) >= 0;\n     }\n \n     /**\n     }\n \n     /**\n-     * Check whether the given String contains any whitespace characters.\n-     * @param str the String to check (may be {@code null})\n-     * @return {@code true} if the String is not empty and\n+     * Check whether the given CharSequence contains any whitespace characters.\n+     * @param seq the CharSequence to check (may be {@code null})\n+     * @return {@code true} if the CharSequence is not empty and\n      * contains at least 1 whitespace character\n      * @see java.lang.Character#isWhitespace\n      * @since 3.0\n      */\n     // From org.springframework.util.StringUtils, under Apache License 2.0\n-    public static boolean containsWhitespace(String str) {\n-        if (isEmpty(str)) {\n+    public static boolean containsWhitespace(CharSequence seq) {\n+        if (isEmpty(seq)) {\n             return false;\n         }\n-        int strLen = str.length();\n+        int strLen = seq.length();\n         for (int i = 0; i < strLen; i++) {\n-            if (Character.isWhitespace(str.charAt(i))) {\n+            if (Character.isWhitespace(seq.charAt(i))) {\n                 return true;\n             }\n         }\n      * @param searchChars  the chars to search for, may be null\n      * @return the index of any of the chars, -1 if no match or null input\n      * @since 2.0\n-     * @since 3.0 Changed signature from indexOfAny(String, String) to indexOfAny(CharSequence, String)\n-     */\n-    public static int indexOfAny(CharSequence cs, String searchChars) {\n+     * @since 3.0 Changed signature from indexOfAny(String, String) to indexOfAny(CharSequence, CharSequence)\n+     */\n+    public static int indexOfAny(CharSequence cs, CharSequence searchChars) {\n         if (isEmpty(cs) || isEmpty(searchChars)) {\n             return INDEX_NOT_FOUND;\n         }\n-        return indexOfAny(cs, searchChars.toCharArray());\n+        return indexOfAny(cs, toCharArraySequence(searchChars));\n     }\n \n     // ContainsAny\n      * {@code false} if no match or null input\n      * @since 2.4\n      */\n-    public static boolean containsAny(String cs, char[] searchChars) {\n+    public static boolean containsAny(CharSequence cs, char[] searchChars) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return false;\n         }\n      * @return the {@code true} if any of the chars are found, {@code false} if no match or null input\n      * @since 2.4\n      */\n-    public static boolean containsAny(String cs, String searchChars) {\n+    public static boolean containsAny(CharSequence cs, CharSequence searchChars) {\n         if (searchChars == null) {\n             return false;\n         }\n-        return containsAny(cs, searchChars.toCharArray());\n+        return containsAny(cs, toCharArraySequence(searchChars));\n     }\n \n     // IndexOfAnyBut chars\n     }\n \n     /**\n-     * <p>Search a String to find the first index of any\n+     * <p>Search a CharSequence to find the first index of any\n      * character not in the given set of characters.</p>\n      *\n-     * <p>A {@code null} String will return {@code -1}.\n+     * <p>A {@code null} CharSequence will return {@code -1}.\n      * A {@code null} or empty search string will return {@code -1}.</p>\n      *\n      * <pre>\n      * StringUtils.indexOfAnyBut(\"aba\",\"ab\")         = -1\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param seq  the CharSequence to check, may be null\n      * @param searchChars  the chars to search for, may be null\n      * @return the index of any of the chars, -1 if no match or null input\n      * @since 2.0\n      */\n-    public static int indexOfAnyBut(String str, String searchChars) {\n-        if (isEmpty(str) || isEmpty(searchChars)) {\n+    public static int indexOfAnyBut(CharSequence seq, CharSequence searchChars) {\n+        if (isEmpty(seq) || isEmpty(searchChars)) {\n             return INDEX_NOT_FOUND;\n         }\n-        int strLen = str.length();\n+        int strLen = seq.length();\n         for (int i = 0; i < strLen; i++) {\n-            char ch = str.charAt(i);\n-            boolean chFound = searchChars.indexOf(ch) >= 0;\n+            char ch = seq.charAt(i);\n+            boolean chFound = indexOfSequence(searchChars, ch, 0) >= 0;\n             if (i + 1 < strLen && Character.isHighSurrogate(ch)) {\n-                char ch2 = str.charAt(i + 1);\n-                if (chFound && searchChars.indexOf(ch2) < 0) {\n+                char ch2 = seq.charAt(i + 1);\n+                if (chFound && indexOfSequence(searchChars, ch2, 0) < 0) {\n                     return i;\n                 }\n             } else {\n      * StringUtils.containsOnly(\"abz\", 'abc')  = false\n      * </pre>\n      *\n-     * @param cs  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @param valid  an array of valid chars, may be null\n      * @return true if it only contains valid chars and is non-null\n      * @since 3.0 Changed signature from containsOnly(String, char[]) to containsOnly(CharSequence, char[])\n      * </pre>\n      *\n      * @param cs  the CharSequence to check, may be null\n-     * @param validChars  a String of valid chars, may be null\n+     * @param validChars  a CharSequence of valid chars, may be null\n      * @return true if it only contains valid chars and is non-null\n      * @since 2.0\n-     * @since 3.0 Changed signature from containsOnly(String, String) to containsOnly(CharSequence, String)\n-     */\n-    public static boolean containsOnly(CharSequence cs, String validChars) {\n+     * @since 3.0 Changed signature from containsOnly(String, String) to containsOnly(CharSequence, CharSequence)\n+     */\n+    public static boolean containsOnly(CharSequence cs, CharSequence validChars) {\n         if (cs == null || validChars == null) {\n             return false;\n         }\n-        return containsOnly(cs, validChars.toCharArray());\n+        return containsOnly(cs, toCharArraySequence(validChars));\n     }\n \n     // ContainsNone\n      * </pre>\n      *\n      * @param cs  the CharSequence to check, may be null\n-     * @param invalidChars  a String of invalid chars, may be null\n+     * @param invalidChars  a CharSequence of invalid chars, may be null\n      * @return true if it contains none of the invalid chars, or is null\n      * @since 2.0\n-     * @since 3.0 Changed signature from containsNone(String, String) to containsNone(CharSequence, String)\n-     */\n-    public static boolean containsNone(CharSequence cs, String invalidChars) {\n+     * @since 3.0 Changed signature from containsNone(String, String) to containsNone(CharSequence, CharSequence)\n+     */\n+    public static boolean containsNone(CharSequence cs, CharSequence invalidChars) {\n         if (cs == null || invalidChars == null) {\n             return true;\n         }\n-        return containsNone(cs, invalidChars.toCharArray());\n+        return containsNone(cs, toCharArraySequence(invalidChars));\n     }\n \n     // IndexOfAny strings\n     /**\n      * <p>Find the first index of any of a set of potential substrings.</p>\n      *\n-     * <p>A {@code null} String will return {@code -1}.\n+     * <p>A {@code null} CharSequence will return {@code -1}.\n      * A {@code null} or zero length search array will return {@code -1}.\n      * A {@code null} search array entry will be ignored, but a search\n      * array containing \"\" will return {@code 0} if {@code str} is not\n-     * null. This method uses {@link String#indexOf(String)}.</p>\n+     * null. This method uses {@link String#indexOf(String)} if possible.</p>\n      *\n      * <pre>\n      * StringUtils.indexOfAny(null, *)                     = -1\n      * StringUtils.indexOfAny(\"\", [\"a\"])                   = -1\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n-     * @param searchStrs  the Strings to search for, may be null\n+     * @param str  the CharSequence to check, may be null\n+     * @param searchStrs  the CharSequences to search for, may be null\n      * @return the first index of any of the searchStrs in str, -1 if no match\n      */\n-    public static int indexOfAny(String str, String[] searchStrs) {\n+    public static int indexOfAny(CharSequence str, CharSequence[] searchStrs) {\n         if (str == null || searchStrs == null) {\n             return INDEX_NOT_FOUND;\n         }\n \n         int tmp = 0;\n         for (int i = 0; i < sz; i++) {\n-            String search = searchStrs[i];\n+            CharSequence search = searchStrs[i];\n             if (search == null) {\n                 continue;\n             }\n-            tmp = str.indexOf(search);\n+            tmp = indexOfSequence(str, search, 0);\n             if (tmp == INDEX_NOT_FOUND) {\n                 continue;\n             }\n     /**\n      * <p>Find the latest index of any of a set of potential substrings.</p>\n      *\n-     * <p>A {@code null} String will return {@code -1}.\n+     * <p>A {@code null} CharSequence will return {@code -1}.\n      * A {@code null} search array will return {@code -1}.\n      * A {@code null} or zero length search array entry will be ignored,\n      * but a search array containing \"\" will return the length of {@code str}\n-     * if {@code str} is not null. This method uses {@link String#indexOf(String)}</p>\n+     * if {@code str} is not null. This method uses {@link String#indexOf(String)} if possible</p>\n      *\n      * <pre>\n      * StringUtils.lastIndexOfAny(null, *)                   = -1\n      * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"\"])   = 10\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n-     * @param searchStrs  the Strings to search for, may be null\n-     * @return the last index of any of the Strings, -1 if no match\n-     */\n-    public static int lastIndexOfAny(String str, String[] searchStrs) {\n+     * @param str  the CharSequence to check, may be null\n+     * @param searchStrs  the CharSequences to search for, may be null\n+     * @return the last index of any of the CharSequences, -1 if no match\n+     */\n+    public static int lastIndexOfAny(CharSequence str, CharSequence[] searchStrs) {\n         if (str == null || searchStrs == null) {\n             return INDEX_NOT_FOUND;\n         }\n         int ret = INDEX_NOT_FOUND;\n         int tmp = 0;\n         for (int i = 0; i < sz; i++) {\n-            String search = searchStrs[i];\n+            CharSequence search = searchStrs[i];\n             if (search == null) {\n                 continue;\n             }\n-            tmp = str.lastIndexOf(search);\n+            tmp = lastIndexOfSequence(str, search, str.length());\n             if (tmp > ret) {\n                 ret = tmp;\n             }\n     // Substring\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Gets a substring from the specified String avoiding exceptions.</p>\n+     * <p>Gets a substring from the specified CharSequence avoiding exceptions.</p>\n      *\n      * <p>A negative start position can be used to start {@code n}\n-     * characters from the end of the String.</p>\n-     *\n-     * <p>A {@code null} String will return {@code null}.\n-     * An empty (\"\") String will return \"\".</p>\n+     * characters from the end of the CharSequence.</p>\n+     *\n+     * <p>A {@code null} CharSequence will return {@code null}.\n+     * An empty (\"\") CharSequence will return \"\".</p>\n      *\n      * <pre>\n      * StringUtils.substring(null, *)   = null\n      * StringUtils.substring(\"abc\", -4) = \"abc\"\n      * </pre>\n      *\n-     * @param str  the String to get the substring from, may be null\n+     * @param str  the CharSequence to get the substring from, may be null\n      * @param start  the position to start from, negative means\n-     *  count back from the end of the String by this many characters\n-     * @return substring from start position, {@code null} if null String input\n-     */\n-    public static String substring(String str, int start) {\n+     *  count back from the end of the CharSequence by this many characters\n+     * @return substring from start position, {@code null} if null CharSequence input\n+     */\n+    public static String substring(CharSequence str, int start) {\n         if (str == null) {\n             return null;\n         }\n             return EMPTY;\n         }\n \n-        return str.substring(start);\n-    }\n-\n-    /**\n-     * <p>Gets a substring from the specified String avoiding exceptions.</p>\n+        return sequenceToString(str.subSequence(start, str.length()));\n+    }\n+\n+    /**\n+     * <p>Gets a substring from the specified CharSequence avoiding exceptions.</p>\n      *\n      * <p>A negative start position can be used to start/end {@code n}\n-     * characters from the end of the String.</p>\n+     * characters from the end of the CharSequence.</p>\n      *\n      * <p>The returned substring starts with the character in the {@code start}\n      * position and ends before the {@code end} position. All position counting is\n      * zero-based -- i.e., to start at the beginning of the string use\n      * {@code start = 0}. Negative start and end positions can be used to\n-     * specify offsets relative to the end of the String.</p>\n+     * specify offsets relative to the end of the CharSequence.</p>\n      *\n      * <p>If {@code start} is not strictly to the left of {@code end}, \"\"\n      * is returned.</p>\n      * StringUtils.substring(\"abc\", -4, 2)  = \"ab\"\n      * </pre>\n      *\n-     * @param str  the String to get the substring from, may be null\n+     * @param str  the CharSequence to get the substring from, may be null\n      * @param start  the position to start from, negative means\n-     *  count back from the end of the String by this many characters\n+     *  count back from the end of the CharSequence by this many characters\n      * @param end  the position to end at (exclusive), negative means\n-     *  count back from the end of the String by this many characters\n+     *  count back from the end of the CharSequence by this many characters\n      * @return substring from start position to end positon,\n-     *  {@code null} if null String input\n-     */\n-    public static String substring(String str, int start, int end) {\n+     *  {@code null} if null CharSequence input\n+     */\n+    public static String substring(CharSequence str, int start, int end) {\n         if (str == null) {\n             return null;\n         }\n             end = 0;\n         }\n \n-        return str.substring(start, end);\n+        return sequenceToString(str.subSequence(start, end));\n     }\n \n     // Left/Right/Mid\n         return cs == null ? null : cs.subSequence(start, cs.length());\n     }\n \n+    // The following methods are used to support basic java.lang.String functionality \n+    // for CharSequences\n+\n     // Used by the indexOf(CharSequence methods) as a green implementation of indexOf\n     static int indexOfSequence(CharSequence cs, int searchChar, int start) {\n         if (cs instanceof String) {\n         }\n     }\n \n+    // Used by the lastIndexOf(CharSequence methods) as a green implementation of lastIndexOf\n+    static int lastIndexOfSequence(CharSequence cs, int searchChar, int start) {\n+        if (cs instanceof String) {\n+            return ((String) cs).lastIndexOf(searchChar, start);\n+        } else {\n+            int sz = cs.length();\n+            if ( start < 0 ) {\n+                return -1;\n+            }\n+            if ( start >= sz ) {\n+                start = sz - 1;\n+            }\n+            for ( int i=start; i >= 0; --i ) {\n+                if ( cs.charAt(i) == searchChar) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+    }\n+    // Used by the lastIndexOf(CharSequence methods) as a green implementation of lastIndexOf\n+    static int lastIndexOfSequence(CharSequence cs, CharSequence searchChar, int start) {\n+        if (cs instanceof String && searchChar instanceof String) {\n+            // TODO: Do we assume searchChar is usually relatively small; \n+            //       If so then calling toString() on it is better than reverting to \n+            //       the green implementation in the else block\n+            return ((String) cs).lastIndexOf( (String) searchChar, start);\n+        } else {\n+            // TODO: Implement rather than convert to String\n+            return cs.toString().lastIndexOf(searchChar.toString(), start);\n+        }\n+    }\n+\n+    // Green implementation of toCharArray\n+    static char[] toCharArraySequence(CharSequence cs) {\n+        if (cs instanceof String) {\n+            return ((String) cs).toCharArray();\n+        } else {\n+            // TODO: Implement rather than convert to String\n+            return cs.toString().toCharArray();\n+        }\n+    }\n+\n+    // Convert a CharSequence to a String\n+    static String sequenceToString(CharSequence cs) {\n+        if (cs instanceof String) {\n+            return ((String) cs);\n+        } else {\n+            return cs.toString();\n+        }\n+    }\n+\n }\n--- a/src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n         assertEquals(-1, StringUtils.lastIndexOf(\"\", ' '));\n         assertEquals(7, StringUtils.lastIndexOf(\"aabaabaa\", 'a'));\n         assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", 'b'));\n+\n+        assertEquals(5, StringUtils.lastIndexOf(new StringBuilder(\"aabaabaa\"), 'b'));\n     }\n \n     public void testLastIndexOf_charInt() {\n         assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", 'b', 9));\n         assertEquals(-1, StringUtils.lastIndexOf(\"aabaabaa\", 'b', -1));\n         assertEquals(0, StringUtils.lastIndexOf(\"aabaabaa\", 'a', 0));\n+\n+        assertEquals(2, StringUtils.lastIndexOf(new StringBuilder(\"aabaabaa\"), 'b', 2));\n     }\n \n     public void testLastIndexOf_String() {\n         assertEquals(7, StringUtils.lastIndexOf(\"aabaabaa\", \"a\"));\n         assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", \"b\"));\n         assertEquals(4, StringUtils.lastIndexOf(\"aabaabaa\", \"ab\"));\n+\n+        assertEquals(4, StringUtils.lastIndexOf(new StringBuilder(\"aabaabaa\"), \"ab\"));\n     }\n \n     public void testLastIndexOf_StringInt() {\n         assertEquals(-1, StringUtils.lastIndexOf(\"aabaabaa\", \"b\", -1));\n         assertEquals(-1, StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 0));\n         assertEquals(0, StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 0));\n+\n+        assertEquals(2, StringUtils.lastIndexOf(new StringBuilder(\"aabaabaa\"), \"b\", 3));\n     }\n \n     public void testLastIndexOfAny_StringStringArray() {", "timestamp": 1300344725, "metainfo": ""}