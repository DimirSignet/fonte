{"sha": "e3165ba2e0d0c47d9073dbd295d5fe3fa7f67432", "log": "[LANG-721] Complement ArrayUtils.addAll() variants with by-index and by-value removal methods  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n package org.apache.commons.lang3;\n \n import java.lang.reflect.Array;\n+import java.util.Arrays;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Map;\n \n import org.apache.commons.lang3.builder.EqualsBuilder;\n import org.apache.commons.lang3.builder.HashCodeBuilder;\n import org.apache.commons.lang3.builder.ToStringBuilder;\n import org.apache.commons.lang3.builder.ToStringStyle;\n+import org.apache.commons.lang3.mutable.MutableInt;\n \n /**\n  * <p>Operations on arrays, primitive arrays (like {@code int[]}) and\n         return result;\n     }\n \n+    /**\n+     * <p>Removes the elements at the specified positions from the specified array.\n+     * All remaining elements are shifted to the left.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except those at the specified positions. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is {@code null}, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeAll([\"a\", \"b\", \"c\"], 0, 2) = [\"b\"]\n+     * ArrayUtils.removeAll([\"a\", \"b\", \"c\"], 1, 2) = [\"a\"]\n+     * </pre>\n+     *\n+     * @param <T> the component type of the array\n+     * @param array   the array to remove the element from, may not be {@code null}\n+     * @param indices the positions of the elements to be removed\n+     * @return A new array containing the existing elements except those\n+     *         at the specified positions.\n+     * @throws IndexOutOfBoundsException if any index is out of range\n+     * (index < 0 || index >= array.length), or if the array is {@code null}.\n+     * @since 3.0.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    // removeAll() always creates an array of the same type as its input\n+    public static <T> T[] removeAll(T[] array, int... indices) {\n+        return (T[]) removeAll((Object) array, clone(indices));\n+    }\n+\n+    /**\n+     * <p>Removes occurrences of specified elements, in specified quantities,\n+     * from the specified array. All subsequent elements are shifted left.\n+     * For any element-to-be-removed specified in greater quantities than\n+     * contained in the original array, no change occurs beyond the\n+     * removal of the existing matching items.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except for the earliest-encountered occurrences of the specified\n+     * elements. The component type of the returned array is always the same\n+     * as that of the input array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElements(null, \"a\", \"b\")            = null\n+     * ArrayUtils.removeElements([], \"a\", \"b\")              = []\n+     * ArrayUtils.removeElements([\"a\"], \"b\", \"c\")           = [\"a\"]\n+     * ArrayUtils.removeElements([\"a\", \"b\"], \"a\", \"c\")      = [\"b\"]\n+     * ArrayUtils.removeElements([\"a\", \"b\", \"a\"], \"a\")      = [\"b\", \"a\"]\n+     * ArrayUtils.removeElements([\"a\", \"b\", \"a\"], \"a\", \"a\") = [\"b\"]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be {@code null}\n+     * @param elements  the elements to be removed\n+     * @return A new array containing the existing elements except the\n+     *         earliest-encountered occurrences of the specified elements.\n+     * @since 3.0.1\n+     */\n+    public static <T> T[] removeElements(T[] array, T... values) {\n+        if (isEmpty(array) || isEmpty(values)) {\n+            return clone(array);\n+        }\n+        HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n+        for (T v : values) {\n+            MutableInt count = occurrences.get(v);\n+            if (count == null) {\n+                occurrences.put(v, new MutableInt(1));\n+            } else {\n+                count.increment();\n+            }\n+        }\n+        HashSet<Integer> toRemove = new HashSet<Integer>();\n+        for (Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n+            T v = e.getKey();\n+            int found = 0;\n+            for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {\n+                found = indexOf(array, v, found);\n+                if (found < 0) {\n+                    break;\n+                }\n+                toRemove.add(found++);\n+            }\n+        }\n+        return removeAll(array, toPrimitive(toRemove.toArray(new Integer[toRemove.size()])));\n+    }\n+\n+    /**\n+     * <p>Removes the elements at the specified positions from the specified array.\n+     * All remaining elements are shifted to the left.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except those at the specified positions. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is {@code null}, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeAll([1], 0)             = []\n+     * ArrayUtils.removeAll([2, 6], 0)          = [6]\n+     * ArrayUtils.removeAll([2, 6], 0, 1)       = []\n+     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]\n+     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]\n+     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []\n+     * </pre>\n+     *\n+     * @param <T> the component type of the array\n+     * @param array   the array to remove the element from, may not be {@code null}\n+     * @param indices the positions of the elements to be removed\n+     * @return A new array containing the existing elements except those\n+     *         at the specified positions.\n+     * @throws IndexOutOfBoundsException if any index is out of range\n+     * (index < 0 || index >= array.length), or if the array is {@code null}.\n+     * @since 3.0.1\n+     */\n+    public static byte[] removeAll(byte[] array, int... indices) {\n+        return (byte[]) removeAll((Object) array, clone(indices));\n+    }\n+\n+    /**\n+     * <p>Removes occurrences of specified elements, in specified quantities,\n+     * from the specified array. All subsequent elements are shifted left.\n+     * For any element-to-be-removed specified in greater quantities than\n+     * contained in the original array, no change occurs beyond the\n+     * removal of the existing matching items.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except for the earliest-encountered occurrences of the specified\n+     * elements. The component type of the returned array is always the same\n+     * as that of the input array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElements(null, 1, 2)      = null\n+     * ArrayUtils.removeElements([], 1, 2)        = []\n+     * ArrayUtils.removeElements([1], 2, 3)       = [1]\n+     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]\n+     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]\n+     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be {@code null}\n+     * @param elements  the elements to be removed\n+     * @return A new array containing the existing elements except the\n+     *         earliest-encountered occurrences of the specified elements.\n+     * @since 3.0.1\n+     */\n+    public static byte[] removeElements(byte[] array, byte... values) {\n+        if (isEmpty(array) || isEmpty(values)) {\n+            return clone(array);\n+        }\n+        HashMap<Byte, MutableInt> occurrences = new HashMap<Byte, MutableInt>(values.length);\n+        for (byte v : values) {\n+            Byte boxed = Byte.valueOf(v);\n+            MutableInt count = occurrences.get(boxed);\n+            if (count == null) {\n+                occurrences.put(boxed, new MutableInt(1));\n+            } else {\n+                count.increment();\n+            }\n+        }\n+        HashSet<Integer> toRemove = new HashSet<Integer>();\n+        for (Map.Entry<Byte, MutableInt> e : occurrences.entrySet()) {\n+            Byte v = e.getKey();\n+            int found = 0;\n+            for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {\n+                found = indexOf(array, v.byteValue(), found);\n+                if (found < 0) {\n+                    break;\n+                }\n+                toRemove.add(found++);\n+            }\n+        }\n+        return removeAll(array, toPrimitive(toRemove.toArray(new Integer[toRemove.size()])));\n+    }\n+\n+    /**\n+     * <p>Removes the elements at the specified positions from the specified array.\n+     * All remaining elements are shifted to the left.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except those at the specified positions. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is {@code null}, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeAll([1], 0)             = []\n+     * ArrayUtils.removeAll([2, 6], 0)          = [6]\n+     * ArrayUtils.removeAll([2, 6], 0, 1)       = []\n+     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]\n+     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]\n+     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []\n+     * </pre>\n+     *\n+     * @param <T> the component type of the array\n+     * @param array   the array to remove the element from, may not be {@code null}\n+     * @param indices the positions of the elements to be removed\n+     * @return A new array containing the existing elements except those\n+     *         at the specified positions.\n+     * @throws IndexOutOfBoundsException if any index is out of range\n+     * (index < 0 || index >= array.length), or if the array is {@code null}.\n+     * @since 3.0.1\n+     */\n+    public static short[] removeAll(short[] array, int... indices) {\n+        return (short[]) removeAll((Object) array, clone(indices));\n+    }\n+\n+    /**\n+     * <p>Removes occurrences of specified elements, in specified quantities,\n+     * from the specified array. All subsequent elements are shifted left.\n+     * For any element-to-be-removed specified in greater quantities than\n+     * contained in the original array, no change occurs beyond the\n+     * removal of the existing matching items.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except for the earliest-encountered occurrences of the specified\n+     * elements. The component type of the returned array is always the same\n+     * as that of the input array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElements(null, 1, 2)      = null\n+     * ArrayUtils.removeElements([], 1, 2)        = []\n+     * ArrayUtils.removeElements([1], 2, 3)       = [1]\n+     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]\n+     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]\n+     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be {@code null}\n+     * @param elements  the elements to be removed\n+     * @return A new array containing the existing elements except the\n+     *         earliest-encountered occurrences of the specified elements.\n+     * @since 3.0.1\n+     */\n+    public static short[] removeElements(short[] array, short... values) {\n+        if (isEmpty(array) || isEmpty(values)) {\n+            return clone(array);\n+        }\n+        HashMap<Short, MutableInt> occurrences = new HashMap<Short, MutableInt>(values.length);\n+        for (short v : values) {\n+            Short boxed = Short.valueOf(v);\n+            MutableInt count = occurrences.get(boxed);\n+            if (count == null) {\n+                occurrences.put(boxed, new MutableInt(1));\n+            } else {\n+                count.increment();\n+            }\n+        }\n+        HashSet<Integer> toRemove = new HashSet<Integer>();\n+        for (Map.Entry<Short, MutableInt> e : occurrences.entrySet()) {\n+            Short v = e.getKey();\n+            int found = 0;\n+            for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {\n+                found = indexOf(array, v.shortValue(), found);\n+                if (found < 0) {\n+                    break;\n+                }\n+                toRemove.add(found++);\n+            }\n+        }\n+        return removeAll(array, toPrimitive(toRemove.toArray(new Integer[toRemove.size()])));\n+    }\n+\n+    /**\n+     * <p>Removes the elements at the specified positions from the specified array.\n+     * All remaining elements are shifted to the left.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except those at the specified positions. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is {@code null}, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeAll([1], 0)             = []\n+     * ArrayUtils.removeAll([2, 6], 0)          = [6]\n+     * ArrayUtils.removeAll([2, 6], 0, 1)       = []\n+     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]\n+     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]\n+     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []\n+     * </pre>\n+     *\n+     * @param <T> the component type of the array\n+     * @param array   the array to remove the element from, may not be {@code null}\n+     * @param indices the positions of the elements to be removed\n+     * @return A new array containing the existing elements except those\n+     *         at the specified positions.\n+     * @throws IndexOutOfBoundsException if any index is out of range\n+     * (index < 0 || index >= array.length), or if the array is {@code null}.\n+     * @since 3.0.1\n+     */\n+    public static int[] removeAll(int[] array, int... indices) {\n+        return (int[]) removeAll((Object) array, clone(indices));\n+    }\n+\n+    /**\n+     * <p>Removes occurrences of specified elements, in specified quantities,\n+     * from the specified array. All subsequent elements are shifted left.\n+     * For any element-to-be-removed specified in greater quantities than\n+     * contained in the original array, no change occurs beyond the\n+     * removal of the existing matching items.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except for the earliest-encountered occurrences of the specified\n+     * elements. The component type of the returned array is always the same\n+     * as that of the input array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElements(null, 1, 2)      = null\n+     * ArrayUtils.removeElements([], 1, 2)        = []\n+     * ArrayUtils.removeElements([1], 2, 3)       = [1]\n+     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]\n+     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]\n+     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be {@code null}\n+     * @param elements  the elements to be removed\n+     * @return A new array containing the existing elements except the\n+     *         earliest-encountered occurrences of the specified elements.\n+     * @since 3.0.1\n+     */\n+    public static int[] removeElements(int[] array, int... values) {\n+        if (isEmpty(array) || isEmpty(values)) {\n+            return clone(array);\n+        }\n+        HashMap<Integer, MutableInt> occurrences = new HashMap<Integer, MutableInt>(values.length);\n+        for (int v : values) {\n+            Integer boxed = Integer.valueOf(v);\n+            MutableInt count = occurrences.get(boxed);\n+            if (count == null) {\n+                occurrences.put(boxed, new MutableInt(1));\n+            } else {\n+                count.increment();\n+            }\n+        }\n+        HashSet<Integer> toRemove = new HashSet<Integer>();\n+        for (Map.Entry<Integer, MutableInt> e : occurrences.entrySet()) {\n+            Integer v = e.getKey();\n+            int found = 0;\n+            for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {\n+                found = indexOf(array, v.intValue(), found);\n+                if (found < 0) {\n+                    break;\n+                }\n+                toRemove.add(found++);\n+            }\n+        }\n+        return removeAll(array, toPrimitive(toRemove.toArray(new Integer[toRemove.size()])));\n+    }\n+\n+    /**\n+     * <p>Removes the elements at the specified positions from the specified array.\n+     * All remaining elements are shifted to the left.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except those at the specified positions. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is {@code null}, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeAll([1], 0)             = []\n+     * ArrayUtils.removeAll([2, 6], 0)          = [6]\n+     * ArrayUtils.removeAll([2, 6], 0, 1)       = []\n+     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]\n+     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]\n+     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []\n+     * </pre>\n+     *\n+     * @param <T> the component type of the array\n+     * @param array   the array to remove the element from, may not be {@code null}\n+     * @param indices the positions of the elements to be removed\n+     * @return A new array containing the existing elements except those\n+     *         at the specified positions.\n+     * @throws IndexOutOfBoundsException if any index is out of range\n+     * (index < 0 || index >= array.length), or if the array is {@code null}.\n+     * @since 3.0.1\n+     */\n+    public static char[] removeAll(char[] array, int... indices) {\n+        return (char[]) removeAll((Object) array, clone(indices));\n+    }\n+\n+    /**\n+     * <p>Removes occurrences of specified elements, in specified quantities,\n+     * from the specified array. All subsequent elements are shifted left.\n+     * For any element-to-be-removed specified in greater quantities than\n+     * contained in the original array, no change occurs beyond the\n+     * removal of the existing matching items.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except for the earliest-encountered occurrences of the specified\n+     * elements. The component type of the returned array is always the same\n+     * as that of the input array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElements(null, 1, 2)      = null\n+     * ArrayUtils.removeElements([], 1, 2)        = []\n+     * ArrayUtils.removeElements([1], 2, 3)       = [1]\n+     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]\n+     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]\n+     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be {@code null}\n+     * @param elements  the elements to be removed\n+     * @return A new array containing the existing elements except the\n+     *         earliest-encountered occurrences of the specified elements.\n+     * @since 3.0.1\n+     */\n+    public static char[] removeElements(char[] array, char... values) {\n+        if (isEmpty(array) || isEmpty(values)) {\n+            return clone(array);\n+        }\n+        HashMap<Character, MutableInt> occurrences = new HashMap<Character, MutableInt>(values.length);\n+        for (char v : values) {\n+            Character boxed = Character.valueOf(v);\n+            MutableInt count = occurrences.get(boxed);\n+            if (count == null) {\n+                occurrences.put(boxed, new MutableInt(1));\n+            } else {\n+                count.increment();\n+            }\n+        }\n+        HashSet<Integer> toRemove = new HashSet<Integer>();\n+        for (Map.Entry<Character, MutableInt> e : occurrences.entrySet()) {\n+            Character v = e.getKey();\n+            int found = 0;\n+            for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {\n+                found = indexOf(array, v.charValue(), found);\n+                if (found < 0) {\n+                    break;\n+                }\n+                toRemove.add(found++);\n+            }\n+        }\n+        return removeAll(array, toPrimitive(toRemove.toArray(new Integer[toRemove.size()])));\n+    }\n+\n+    /**\n+     * <p>Removes the elements at the specified positions from the specified array.\n+     * All remaining elements are shifted to the left.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except those at the specified positions. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is {@code null}, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeAll([1], 0)             = []\n+     * ArrayUtils.removeAll([2, 6], 0)          = [6]\n+     * ArrayUtils.removeAll([2, 6], 0, 1)       = []\n+     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]\n+     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]\n+     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []\n+     * </pre>\n+     *\n+     * @param <T> the component type of the array\n+     * @param array   the array to remove the element from, may not be {@code null}\n+     * @param indices the positions of the elements to be removed\n+     * @return A new array containing the existing elements except those\n+     *         at the specified positions.\n+     * @throws IndexOutOfBoundsException if any index is out of range\n+     * (index < 0 || index >= array.length), or if the array is {@code null}.\n+     * @since 3.0.1\n+     */\n+    public static long[] removeAll(long[] array, int... indices) {\n+        return (long[]) removeAll((Object) array, clone(indices));\n+    }\n+\n+    /**\n+     * <p>Removes occurrences of specified elements, in specified quantities,\n+     * from the specified array. All subsequent elements are shifted left.\n+     * For any element-to-be-removed specified in greater quantities than\n+     * contained in the original array, no change occurs beyond the\n+     * removal of the existing matching items.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except for the earliest-encountered occurrences of the specified\n+     * elements. The component type of the returned array is always the same\n+     * as that of the input array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElements(null, 1, 2)      = null\n+     * ArrayUtils.removeElements([], 1, 2)        = []\n+     * ArrayUtils.removeElements([1], 2, 3)       = [1]\n+     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]\n+     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]\n+     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be {@code null}\n+     * @param elements  the elements to be removed\n+     * @return A new array containing the existing elements except the\n+     *         earliest-encountered occurrences of the specified elements.\n+     * @since 3.0.1\n+     */\n+    public static long[] removeElements(long[] array, long... values) {\n+        if (isEmpty(array) || isEmpty(values)) {\n+            return clone(array);\n+        }\n+        HashMap<Long, MutableInt> occurrences = new HashMap<Long, MutableInt>(values.length);\n+        for (long v : values) {\n+            Long boxed = Long.valueOf(v);\n+            MutableInt count = occurrences.get(boxed);\n+            if (count == null) {\n+                occurrences.put(boxed, new MutableInt(1));\n+            } else {\n+                count.increment();\n+            }\n+        }\n+        HashSet<Integer> toRemove = new HashSet<Integer>();\n+        for (Map.Entry<Long, MutableInt> e : occurrences.entrySet()) {\n+            Long v = e.getKey();\n+            int found = 0;\n+            for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {\n+                found = indexOf(array, v.longValue(), found);\n+                if (found < 0) {\n+                    break;\n+                }\n+                toRemove.add(found++);\n+            }\n+        }\n+        return removeAll(array, toPrimitive(toRemove.toArray(new Integer[toRemove.size()])));\n+    }\n+\n+    /**\n+     * <p>Removes the elements at the specified positions from the specified array.\n+     * All remaining elements are shifted to the left.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except those at the specified positions. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is {@code null}, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeAll([1], 0)             = []\n+     * ArrayUtils.removeAll([2, 6], 0)          = [6]\n+     * ArrayUtils.removeAll([2, 6], 0, 1)       = []\n+     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]\n+     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]\n+     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []\n+     * </pre>\n+     *\n+     * @param <T> the component type of the array\n+     * @param array   the array to remove the element from, may not be {@code null}\n+     * @param indices the positions of the elements to be removed\n+     * @return A new array containing the existing elements except those\n+     *         at the specified positions.\n+     * @throws IndexOutOfBoundsException if any index is out of range\n+     * (index < 0 || index >= array.length), or if the array is {@code null}.\n+     * @since 3.0.1\n+     */\n+    public static float[] removeAll(float[] array, int... indices) {\n+        return (float[]) removeAll((Object) array, clone(indices));\n+    }\n+\n+    /**\n+     * <p>Removes occurrences of specified elements, in specified quantities,\n+     * from the specified array. All subsequent elements are shifted left.\n+     * For any element-to-be-removed specified in greater quantities than\n+     * contained in the original array, no change occurs beyond the\n+     * removal of the existing matching items.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except for the earliest-encountered occurrences of the specified\n+     * elements. The component type of the returned array is always the same\n+     * as that of the input array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElements(null, 1, 2)      = null\n+     * ArrayUtils.removeElements([], 1, 2)        = []\n+     * ArrayUtils.removeElements([1], 2, 3)       = [1]\n+     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]\n+     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]\n+     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be {@code null}\n+     * @param elements  the elements to be removed\n+     * @return A new array containing the existing elements except the\n+     *         earliest-encountered occurrences of the specified elements.\n+     * @since 3.0.1\n+     */\n+    public static float[] removeElements(float[] array, float... values) {\n+        if (isEmpty(array) || isEmpty(values)) {\n+            return clone(array);\n+        }\n+        HashMap<Float, MutableInt> occurrences = new HashMap<Float, MutableInt>(values.length);\n+        for (float v : values) {\n+            Float boxed = Float.valueOf(v);\n+            MutableInt count = occurrences.get(boxed);\n+            if (count == null) {\n+                occurrences.put(boxed, new MutableInt(1));\n+            } else {\n+                count.increment();\n+            }\n+        }\n+        HashSet<Integer> toRemove = new HashSet<Integer>();\n+        for (Map.Entry<Float, MutableInt> e : occurrences.entrySet()) {\n+            Float v = e.getKey();\n+            int found = 0;\n+            for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {\n+                found = indexOf(array, v.floatValue(), found);\n+                if (found < 0) {\n+                    break;\n+                }\n+                toRemove.add(found++);\n+            }\n+        }\n+        return removeAll(array, toPrimitive(toRemove.toArray(new Integer[toRemove.size()])));\n+    }\n+\n+    /**\n+     * <p>Removes the elements at the specified positions from the specified array.\n+     * All remaining elements are shifted to the left.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except those at the specified positions. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is {@code null}, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeAll([1], 0)             = []\n+     * ArrayUtils.removeAll([2, 6], 0)          = [6]\n+     * ArrayUtils.removeAll([2, 6], 0, 1)       = []\n+     * ArrayUtils.removeAll([2, 6, 3], 1, 2)    = [2]\n+     * ArrayUtils.removeAll([2, 6, 3], 0, 2)    = [6]\n+     * ArrayUtils.removeAll([2, 6, 3], 0, 1, 2) = []\n+     * </pre>\n+     *\n+     * @param <T> the component type of the array\n+     * @param array   the array to remove the element from, may not be {@code null}\n+     * @param indices the positions of the elements to be removed\n+     * @return A new array containing the existing elements except those\n+     *         at the specified positions.\n+     * @throws IndexOutOfBoundsException if any index is out of range\n+     * (index < 0 || index >= array.length), or if the array is {@code null}.\n+     * @since 3.0.1\n+     */\n+    public static double[] removeAll(double[] array, int... indices) {\n+        return (double[]) removeAll((Object) array, clone(indices));\n+    }\n+\n+    /**\n+     * <p>Removes occurrences of specified elements, in specified quantities,\n+     * from the specified array. All subsequent elements are shifted left.\n+     * For any element-to-be-removed specified in greater quantities than\n+     * contained in the original array, no change occurs beyond the\n+     * removal of the existing matching items.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except for the earliest-encountered occurrences of the specified\n+     * elements. The component type of the returned array is always the same\n+     * as that of the input array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElements(null, 1, 2)      = null\n+     * ArrayUtils.removeElements([], 1, 2)        = []\n+     * ArrayUtils.removeElements([1], 2, 3)       = [1]\n+     * ArrayUtils.removeElements([1, 3], 1, 2)    = [3]\n+     * ArrayUtils.removeElements([1, 3, 1], 1)    = [3, 1]\n+     * ArrayUtils.removeElements([1, 3, 1], 1, 1) = [3]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be {@code null}\n+     * @param elements  the elements to be removed\n+     * @return A new array containing the existing elements except the\n+     *         earliest-encountered occurrences of the specified elements.\n+     * @since 3.0.1\n+     */\n+    public static double[] removeElements(double[] array, double... values) {\n+        if (isEmpty(array) || isEmpty(values)) {\n+            return clone(array);\n+        }\n+        HashMap<Double, MutableInt> occurrences = new HashMap<Double, MutableInt>(values.length);\n+        for (double v : values) {\n+            Double boxed = Double.valueOf(v);\n+            MutableInt count = occurrences.get(boxed);\n+            if (count == null) {\n+                occurrences.put(boxed, new MutableInt(1));\n+            } else {\n+                count.increment();\n+            }\n+        }\n+        HashSet<Integer> toRemove = new HashSet<Integer>();\n+        for (Map.Entry<Double, MutableInt> e : occurrences.entrySet()) {\n+            Double v = e.getKey();\n+            int found = 0;\n+            for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {\n+                found = indexOf(array, v.doubleValue(), found);\n+                if (found < 0) {\n+                    break;\n+                }\n+                toRemove.add(found++);\n+            }\n+        }\n+        return removeAll(array, toPrimitive(toRemove.toArray(new Integer[toRemove.size()])));\n+    }\n+\n+    /**\n+     * <p>Removes the elements at the specified positions from the specified array.\n+     * All remaining elements are shifted to the left.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except those at the specified positions. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is {@code null}, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeAll([true, false, true], 0, 2) = [false]\n+     * ArrayUtils.removeAll([true, false, true], 1, 2) = [true]\n+     * </pre>\n+     *\n+     * @param <T> the component type of the array\n+     * @param array   the array to remove the element from, may not be {@code null}\n+     * @param indices the positions of the elements to be removed\n+     * @return A new array containing the existing elements except those\n+     *         at the specified positions.\n+     * @throws IndexOutOfBoundsException if any index is out of range\n+     * (index < 0 || index >= array.length), or if the array is {@code null}.\n+     * @since 3.0.1\n+     */\n+    public static boolean[] removeAll(boolean[] array, int... indices) {\n+        return (boolean[]) removeAll((Object) array, clone(indices));\n+    }\n+\n+    /**\n+     * <p>Removes occurrences of specified elements, in specified quantities,\n+     * from the specified array. All subsequent elements are shifted left.\n+     * For any element-to-be-removed specified in greater quantities than\n+     * contained in the original array, no change occurs beyond the\n+     * removal of the existing matching items.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except for the earliest-encountered occurrences of the specified\n+     * elements. The component type of the returned array is always the same\n+     * as that of the input array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElements(null, true, false)               = null\n+     * ArrayUtils.removeElements([], true, false)                 = []\n+     * ArrayUtils.removeElements([true], false, false)            = [true]\n+     * ArrayUtils.removeElements([true, false], true, true)       = [false]\n+     * ArrayUtils.removeElements([true, false, true], true)       = [false, true]\n+     * ArrayUtils.removeElements([true, false, true], true, true) = [false]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be {@code null}\n+     * @param elements  the elements to be removed\n+     * @return A new array containing the existing elements except the\n+     *         earliest-encountered occurrences of the specified elements.\n+     * @since 3.0.1\n+     */\n+    public static boolean[] removeElements(boolean[] array, boolean... values) {\n+        if (isEmpty(array) || isEmpty(values)) {\n+            return clone(array);\n+        }\n+        HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(values.length);\n+        for (boolean v : values) {\n+            Boolean boxed = Boolean.valueOf(v);\n+            MutableInt count = occurrences.get(boxed);\n+            if (count == null) {\n+                occurrences.put(boxed, new MutableInt(1));\n+            } else {\n+                count.increment();\n+            }\n+        }\n+        HashSet<Integer> toRemove = new HashSet<Integer>();\n+        for (Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {\n+            Boolean v = e.getKey();\n+            int found = 0;\n+            for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {\n+                found = indexOf(array, v.booleanValue(), found);\n+                if (found < 0) {\n+                    break;\n+                }\n+                toRemove.add(found++);\n+            }\n+        }\n+        return removeAll(array, toPrimitive(toRemove.toArray(new Integer[toRemove.size()])));\n+    }\n+\n+    /**\n+     * Removes multiple array elements specified by index.\n+     * @param array source\n+     * @param indices to remove, WILL BE SORTED--so only clones of user-owned arrays!\n+     * @return new array of same type minus elements specified by unique values of {@code indices}\n+     * @since 3.0.1\n+     */\n+    private static Object removeAll(Object array, int... indices) {\n+        int length = getLength(array);\n+        int diff = 0;\n+\n+        if (isNotEmpty(indices)) {\n+            Arrays.sort(indices);\n+\n+            int i = indices.length;\n+            int prevIndex = length;\n+            while (--i >= 0) {\n+                int index = indices[i];\n+                if (index < 0 || index >= length) {\n+                    throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n+                }\n+                if (index >= prevIndex) {\n+                    continue;\n+                }\n+                diff++;\n+                prevIndex = index;\n+            }\n+        }\n+        Object result = Array.newInstance(array.getClass().getComponentType(), length - diff);\n+        if (diff < length) {\n+            int end = length;\n+            int dest = length - diff;\n+            for (int i = indices.length - 1; i >= 0; i--) {\n+                int index = indices[i];\n+                if (end - index > 1) {\n+                    int cp = end - index - 1;\n+                    dest -= cp;\n+                    System.arraycopy(array, index + 1, result, dest, cp);\n+                }\n+                end = index;\n+            }\n+            if (end > 0) {\n+                System.arraycopy(array, 0, result, 0, end);\n+            }\n+        }\n+        return result;\n+    }\n+\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/ArrayUtilsRemoveMultipleTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang3;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.Arrays;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Tests ArrayUtils remove and removeElement methods.\n+ * \n+ * @version $Id$\n+ */\n+public class ArrayUtilsRemoveMultipleTest {\n+\n+    @Test\n+    public void testRemoveAllObjectArray() {\n+        Object[] array;\n+        array = ArrayUtils.removeAll(new Object[] { \"a\" }, 0);\n+        assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, array);\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new Object[] { \"a\", \"b\" }, 0, 1);\n+        assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, array);\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new Object[] { \"a\", \"b\", \"c\" }, 1, 2);\n+        assertArrayEquals(new Object[] { \"a\" }, array);\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new Object[] { \"a\", \"b\", \"c\", \"d\" }, 1, 2);\n+        assertArrayEquals(new Object[] { \"a\", \"d\" }, array);\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new Object[] { \"a\", \"b\", \"c\", \"d\" }, 0, 3);\n+        assertArrayEquals(new Object[] { \"b\", \"c\" }, array);\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new Object[] { \"a\", \"b\", \"c\", \"d\" }, 0, 1, 3);\n+        assertArrayEquals(new Object[] { \"c\" }, array);\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new Object[] { \"a\", \"b\", \"c\", \"d\", \"e\" }, 0, 1, 3);\n+        assertArrayEquals(new Object[] { \"c\", \"e\" }, array);\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new Object[] { \"a\", \"b\", \"c\", \"d\", \"e\" }, 0, 2, 4);\n+        assertArrayEquals(new Object[] { \"b\", \"d\" }, array);\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new Object[] { \"a\", \"b\", \"c\", \"d\" }, 0, 1, 3, 0, 1, 3);\n+        assertArrayEquals(new Object[] { \"c\" }, array);\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new Object[] { \"a\", \"b\", \"c\", \"d\" }, 2, 1, 0, 3);\n+        assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, array);\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new Object[] { \"a\", \"b\", \"c\", \"d\" }, 2, 0, 1, 3, 0, 2, 1, 3);\n+        assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, array);\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+    }\n+\n+    @Test\n+    public void testRemoveAllObjectArrayRemoveNone() {\n+        Object[] array1 = new Object[] { \"foo\", \"bar\", \"baz\" };\n+        Object[] array2 = ArrayUtils.removeAll(array1);\n+        assertNotSame(array1, array2);\n+        assertArrayEquals(array1, array2);\n+        assertEquals(Object.class, array2.getClass().getComponentType());\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllObjectArrayNegativeIndex() {\n+        ArrayUtils.removeAll(new Object[] { \"a\", \"b\" }, -1);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllObjectArrayOutOfBoundsIndex() {\n+        ArrayUtils.removeAll(new Object[] { \"a\", \"b\" }, 2);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllNullObjectArray() {\n+        ArrayUtils.remove((Object[]) null, 0);\n+    }\n+\n+    @Test\n+    public void testRemoveAllNumberArray() {\n+        Number[] inarray = { Integer.valueOf(1), Long.valueOf(2L), Byte.valueOf((byte) 3) };\n+        assertEquals(3, inarray.length);\n+        Number[] outarray;\n+        outarray = ArrayUtils.removeAll(inarray, 1);\n+        assertArrayEquals(new Number[] { Integer.valueOf(1), Byte.valueOf((byte) 3) }, outarray);\n+        assertEquals(Number.class, outarray.getClass().getComponentType());\n+        outarray = ArrayUtils.removeAll(outarray, 1);\n+        assertArrayEquals(new Number[] { Integer.valueOf(1) }, outarray);\n+        assertEquals(Number.class, outarray.getClass().getComponentType());\n+        outarray = ArrayUtils.removeAll(outarray, 0);\n+        assertEquals(0, outarray.length);\n+        assertEquals(Number.class, outarray.getClass().getComponentType());\n+\n+        outarray = ArrayUtils.removeAll(inarray, 0, 1);\n+        assertArrayEquals(new Number[] { Byte.valueOf((byte) 3) }, outarray);\n+        assertEquals(Number.class, outarray.getClass().getComponentType());\n+        outarray = ArrayUtils.removeAll(inarray, 0, 2);\n+        assertArrayEquals(new Number[] { Long.valueOf(2L) }, outarray);\n+        assertEquals(Number.class, outarray.getClass().getComponentType());\n+        outarray = ArrayUtils.removeAll(inarray, 1, 2);\n+        assertArrayEquals(new Number[] { Integer.valueOf(1) }, outarray);\n+        assertEquals(Number.class, outarray.getClass().getComponentType());\n+    }\n+\n+    @Test\n+    public void testRemoveAllBooleanArray() {\n+        boolean[] array;\n+        array = ArrayUtils.removeAll(new boolean[] { true }, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new boolean[] { true, false }, 0);\n+        assertTrue(Arrays.equals(new boolean[] { false }, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new boolean[] { true, false }, 1);\n+        assertTrue(Arrays.equals(new boolean[] { true }, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new boolean[] { true, false, true }, 1);\n+        assertTrue(Arrays.equals(new boolean[] { true, true }, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+\n+        array = ArrayUtils.removeAll(new boolean[] { true, false }, 0, 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new boolean[] { true, false, false }, 0, 1);\n+        assertTrue(Arrays.equals(new boolean[] { false }, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new boolean[] { true, false, false }, 0, 2);\n+        assertTrue(Arrays.equals(new boolean[] { false }, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new boolean[] { true, false, false }, 1, 2);\n+        assertTrue(Arrays.equals(new boolean[] { true }, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new boolean[] { true, false, true, false, true }, 0, 2, 4);\n+        assertTrue(Arrays.equals(new boolean[] { false, false }, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new boolean[] { true, false, true, false, true }, 1, 3);\n+        assertTrue(Arrays.equals(new boolean[] { true, true, true }, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new boolean[] { true, false, true, false, true }, 1, 3, 4);\n+        assertTrue(Arrays.equals(new boolean[] { true, true }, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new boolean[] { true, false, true, false, true, false, true }, 0, 2, 4, 6);\n+        assertTrue(Arrays.equals(new boolean[] { false, false, false }, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new boolean[] { true, false, true, false, true, false, true }, 1, 3, 5);\n+        assertTrue(Arrays.equals(new boolean[] { true, true, true, true }, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new boolean[] { true, false, true, false, true, false, true }, 0, 1, 2);\n+        assertTrue(Arrays.equals(new boolean[] { false, true, false, true }, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+    }\n+\n+    @Test\n+    public void testRemoveAllBooleanArrayRemoveNone() {\n+        boolean[] array1 = new boolean[] { true, false };\n+        boolean[] array2 = ArrayUtils.removeAll(array1);\n+        assertNotSame(array1, array2);\n+        assertTrue(Arrays.equals(array1, array2));\n+        assertEquals(boolean.class, array2.getClass().getComponentType());\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllBooleanArrayNegativeIndex() {\n+        ArrayUtils.removeAll(new boolean[] { true, false }, -1);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllBooleanArrayOutOfBoundsIndex() {\n+        ArrayUtils.removeAll(new boolean[] { true, false }, 2);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllNullBooleanArray() {\n+        ArrayUtils.removeAll((boolean[]) null, 0);\n+    }\n+\n+    @Test\n+    public void testRemoveAllByteArray() {\n+        byte[] array;\n+        array = ArrayUtils.removeAll(new byte[] { 1 }, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new byte[] { 1, 2 }, 0);\n+        assertTrue(Arrays.equals(new byte[] { 2 }, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new byte[] { 1, 2 }, 1);\n+        assertTrue(Arrays.equals(new byte[] { 1 }, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new byte[] { 1, 2, 1 }, 1);\n+        assertTrue(Arrays.equals(new byte[] { 1, 1 }, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+\n+        array = ArrayUtils.removeAll(new byte[] { 1, 2 }, 0, 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new byte[] { 1, 2, 3 }, 0, 1);\n+        assertTrue(Arrays.equals(new byte[] { 3 }, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new byte[] { 1, 2, 3 }, 1, 2);\n+        assertTrue(Arrays.equals(new byte[] { 1 }, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new byte[] { 1, 2, 3 }, 0, 2);\n+        assertTrue(Arrays.equals(new byte[] { 2 }, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new byte[] { 1, 2, 3, 4, 5 }, 1, 3);\n+        assertTrue(Arrays.equals(new byte[] { 1, 3, 5 }, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new byte[] { 1, 2, 3, 4, 5 }, 0, 2, 4);\n+        assertTrue(Arrays.equals(new byte[] { 2, 4 }, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new byte[] { 1, 2, 3, 4, 5, 6, 7 }, 1, 3, 5);\n+        assertTrue(Arrays.equals(new byte[] { 1, 3, 5, 7 }, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new byte[] { 1, 2, 3, 4, 5, 6, 7 }, 0, 2, 4, 6);\n+        assertTrue(Arrays.equals(new byte[] { 2, 4, 6 }, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+    }\n+\n+    @Test\n+    public void testRemoveAllByteArrayRemoveNone() {\n+        byte[] array1 = new byte[] { 1, 2 };\n+        byte[] array2 = ArrayUtils.removeAll(array1);\n+        assertNotSame(array1, array2);\n+        assertArrayEquals(array1, array2);\n+        assertEquals(byte.class, array2.getClass().getComponentType());\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllByteArrayNegativeIndex() {\n+        ArrayUtils.removeAll(new byte[] { 1, 2 }, -1);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllByteArrayOutOfBoundsIndex() {\n+        ArrayUtils.removeAll(new byte[] { 1, 2 }, 2);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllNullByteArray() {\n+        ArrayUtils.removeAll((byte[]) null, 0);\n+    }\n+\n+    @Test\n+    public void testRemoveAllCharArray() {\n+        char[] array;\n+        array = ArrayUtils.removeAll(new char[] { 'a' }, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new char[] { 'a', 'b' }, 0);\n+        assertTrue(Arrays.equals(new char[] { 'b' }, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new char[] { 'a', 'b' }, 1);\n+        assertTrue(Arrays.equals(new char[] { 'a' }, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c' }, 1);\n+        assertTrue(Arrays.equals(new char[] { 'a', 'c' }, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+\n+        array = ArrayUtils.removeAll(new char[] { 'a', 'b' }, 0, 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c' }, 0, 1);\n+        assertTrue(Arrays.equals(new char[] { 'c' }, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c' }, 1, 2);\n+        assertTrue(Arrays.equals(new char[] { 'a' }, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c' }, 0, 2);\n+        assertTrue(Arrays.equals(new char[] { 'b' }, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c', 'd', 'e' }, 1, 3);\n+        assertTrue(Arrays.equals(new char[] { 'a', 'c', 'e' }, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c', 'd', 'e' }, 0, 2, 4);\n+        assertTrue(Arrays.equals(new char[] { 'b', 'd' }, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g' }, 1, 3, 5);\n+        assertTrue(Arrays.equals(new char[] { 'a', 'c', 'e', 'g' }, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g' }, 0, 2, 4, 6);\n+        assertTrue(Arrays.equals(new char[] { 'b', 'd', 'f' }, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+    }\n+\n+    @Test\n+    public void testRemoveAllCharArrayRemoveNone() {\n+        char[] array1 = new char[] { 'a', 'b' };\n+        char[] array2 = ArrayUtils.removeAll(array1);\n+        assertNotSame(array1, array2);\n+        assertArrayEquals(array1, array2);\n+        assertEquals(char.class, array2.getClass().getComponentType());\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllCharArrayNegativeIndex() {\n+        ArrayUtils.removeAll(new char[] { 'a', 'b' }, -1);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllCharArrayOutOfBoundsIndex() {\n+        ArrayUtils.removeAll(new char[] { 'a', 'b' }, 2);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllNullCharArray() {\n+        ArrayUtils.removeAll((char[]) null, 0);\n+    }\n+\n+    @Test\n+    public void testRemoveAllDoubleArray() {\n+        double[] array;\n+        array = ArrayUtils.removeAll(new double[] { 1 }, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new double[] { 1, 2 }, 0);\n+        assertTrue(Arrays.equals(new double[] { 2 }, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new double[] { 1, 2 }, 1);\n+        assertTrue(Arrays.equals(new double[] { 1 }, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new double[] { 1, 2, 1 }, 1);\n+        assertTrue(Arrays.equals(new double[] { 1, 1 }, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+\n+        array = ArrayUtils.removeAll(new double[] { 1, 2 }, 0, 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new double[] { 1, 2, 3 }, 0, 1);\n+        assertTrue(Arrays.equals(new double[] { 3 }, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new double[] { 1, 2, 3 }, 1, 2);\n+        assertTrue(Arrays.equals(new double[] { 1 }, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new double[] { 1, 2, 3 }, 0, 2);\n+        assertTrue(Arrays.equals(new double[] { 2 }, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new double[] { 1, 2, 3, 4, 5 }, 1, 3);\n+        assertTrue(Arrays.equals(new double[] { 1, 3, 5 }, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new double[] { 1, 2, 3, 4, 5 }, 0, 2, 4);\n+        assertTrue(Arrays.equals(new double[] { 2, 4 }, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new double[] { 1, 2, 3, 4, 5, 6, 7 }, 1, 3, 5);\n+        assertTrue(Arrays.equals(new double[] { 1, 3, 5, 7 }, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new double[] { 1, 2, 3, 4, 5, 6, 7 }, 0, 2, 4, 6);\n+        assertTrue(Arrays.equals(new double[] { 2, 4, 6 }, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+    }\n+\n+    @Test\n+    public void testRemoveAllDoubleArrayRemoveNone() {\n+        double[] array1 = new double[] { 1, 2 };\n+        double[] array2 = ArrayUtils.removeAll(array1);\n+        assertNotSame(array1, array2);\n+        assertTrue(Arrays.equals(array1, array2));\n+        assertEquals(double.class, array2.getClass().getComponentType());\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllDoubleArrayNegativeIndex() {\n+        ArrayUtils.removeAll(new double[] { 1, 2 }, -1);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllDoubleArrayOutOfBoundsIndex() {\n+        ArrayUtils.removeAll(new double[] { 1, 2 }, 2);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllNullDoubleArray() {\n+        ArrayUtils.removeAll((double[]) null, 0);\n+    }\n+\n+    @Test\n+    public void testRemoveAllFloatArray() {\n+        float[] array;\n+        array = ArrayUtils.removeAll(new float[] { 1 }, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new float[] { 1, 2 }, 0);\n+        assertTrue(Arrays.equals(new float[] { 2 }, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new float[] { 1, 2 }, 1);\n+        assertTrue(Arrays.equals(new float[] { 1 }, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new float[] { 1, 2, 1 }, 1);\n+        assertTrue(Arrays.equals(new float[] { 1, 1 }, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+\n+        array = ArrayUtils.removeAll(new float[] { 1, 2 }, 0, 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new float[] { 1, 2, 3 }, 0, 1);\n+        assertTrue(Arrays.equals(new float[] { 3 }, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new float[] { 1, 2, 3 }, 1, 2);\n+        assertTrue(Arrays.equals(new float[] { 1 }, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new float[] { 1, 2, 3 }, 0, 2);\n+        assertTrue(Arrays.equals(new float[] { 2 }, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new float[] { 1, 2, 3, 4, 5 }, 1, 3);\n+        assertTrue(Arrays.equals(new float[] { 1, 3, 5 }, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new float[] { 1, 2, 3, 4, 5 }, 0, 2, 4);\n+        assertTrue(Arrays.equals(new float[] { 2, 4 }, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new float[] { 1, 2, 3, 4, 5, 6, 7 }, 1, 3, 5);\n+        assertTrue(Arrays.equals(new float[] { 1, 3, 5, 7 }, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new float[] { 1, 2, 3, 4, 5, 6, 7 }, 0, 2, 4, 6);\n+        assertTrue(Arrays.equals(new float[] { 2, 4, 6 }, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+    }\n+\n+    @Test\n+    public void testRemoveAllFloatArrayRemoveNone() {\n+        float[] array1 = new float[] { 1, 2 };\n+        float[] array2 = ArrayUtils.removeAll(array1);\n+        assertNotSame(array1, array2);\n+        assertTrue(Arrays.equals(array1, array2));\n+        assertEquals(float.class, array2.getClass().getComponentType());\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllFloatArrayNegativeIndex() {\n+        ArrayUtils.removeAll(new float[] { 1, 2 }, -1);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllFloatArrayOutOfBoundsIndex() {\n+        ArrayUtils.removeAll(new float[] { 1, 2 }, 2);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllNullFloatArray() {\n+        ArrayUtils.removeAll((float[]) null, 0);\n+    }\n+\n+    @Test\n+    public void testRemoveAllIntArray() {\n+        int[] array;\n+        array = ArrayUtils.removeAll(new int[] { 1 }, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new int[] { 1, 2 }, 0);\n+        assertTrue(Arrays.equals(new int[] { 2 }, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new int[] { 1, 2 }, 1);\n+        assertTrue(Arrays.equals(new int[] { 1 }, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new int[] { 1, 2, 1 }, 1);\n+        assertTrue(Arrays.equals(new int[] { 1, 1 }, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+\n+        array = ArrayUtils.removeAll(new int[] { 1, 2 }, 0, 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new int[] { 1, 2, 3 }, 0, 1);\n+        assertTrue(Arrays.equals(new int[] { 3 }, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new int[] { 1, 2, 3 }, 1, 2);\n+        assertTrue(Arrays.equals(new int[] { 1 }, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new int[] { 1, 2, 3 }, 0, 2);\n+        assertTrue(Arrays.equals(new int[] { 2 }, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new int[] { 1, 2, 3, 4, 5 }, 1, 3);\n+        assertTrue(Arrays.equals(new int[] { 1, 3, 5 }, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new int[] { 1, 2, 3, 4, 5 }, 0, 2, 4);\n+        assertTrue(Arrays.equals(new int[] { 2, 4 }, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new int[] { 1, 2, 3, 4, 5, 6, 7 }, 1, 3, 5);\n+        assertTrue(Arrays.equals(new int[] { 1, 3, 5, 7 }, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new int[] { 1, 2, 3, 4, 5, 6, 7 }, 0, 2, 4, 6);\n+        assertTrue(Arrays.equals(new int[] { 2, 4, 6 }, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+    }\n+\n+    @Test\n+    public void testRemoveAllIntArrayRemoveNone() {\n+        int[] array1 = new int[] { 1, 2 };\n+        int[] array2 = ArrayUtils.removeAll(array1);\n+        assertNotSame(array1, array2);\n+        assertArrayEquals(array1, array2);\n+        assertEquals(int.class, array2.getClass().getComponentType());\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllIntArrayNegativeIndex() {\n+        ArrayUtils.removeAll(new int[] { 1, 2 }, -1);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllIntArrayOutOfBoundsIndex() {\n+        ArrayUtils.removeAll(new int[] { 1, 2 }, 2);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllNullIntArray() {\n+        ArrayUtils.removeAll((int[]) null, 0);\n+    }\n+\n+    @Test\n+    public void testRemoveAllLongArray() {\n+        long[] array;\n+        array = ArrayUtils.removeAll(new long[] { 1 }, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new long[] { 1, 2 }, 0);\n+        assertTrue(Arrays.equals(new long[] { 2 }, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new long[] { 1, 2 }, 1);\n+        assertTrue(Arrays.equals(new long[] { 1 }, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 1);\n+        assertTrue(Arrays.equals(new long[] { 1, 1 }, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+\n+        array = ArrayUtils.removeAll(new long[] { 1, 2 }, 0, 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 0, 1);\n+        assertTrue(Arrays.equals(new long[] { 3 }, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 1, 2);\n+        assertTrue(Arrays.equals(new long[] { 1 }, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 0, 2);\n+        assertTrue(Arrays.equals(new long[] { 2 }, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4, 5 }, 1, 3);\n+        assertTrue(Arrays.equals(new long[] { 1, 3, 5 }, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4, 5 }, 0, 2, 4);\n+        assertTrue(Arrays.equals(new long[] { 2, 4 }, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4, 5, 6, 7 }, 1, 3, 5);\n+        assertTrue(Arrays.equals(new long[] { 1, 3, 5, 7 }, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4, 5, 6, 7 }, 0, 2, 4, 6);\n+        assertTrue(Arrays.equals(new long[] { 2, 4, 6 }, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+    }\n+\n+    @Test\n+    public void testRemoveAllLongArrayRemoveNone() {\n+        long[] array1 = new long[] { 1, 2 };\n+        long[] array2 = ArrayUtils.removeAll(array1);\n+        assertNotSame(array1, array2);\n+        assertArrayEquals(array1, array2);\n+        assertEquals(long.class, array2.getClass().getComponentType());\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllLongArrayNegativeIndex() {\n+        ArrayUtils.removeAll(new long[] { 1, 2 }, -1);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllLongArrayOutOfBoundsIndex() {\n+        ArrayUtils.removeAll(new long[] { 1, 2 }, 2);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllNullLongArray() {\n+        ArrayUtils.removeAll((long[]) null, 0);\n+    }\n+\n+    @Test\n+    public void testRemoveAllShortArray() {\n+        short[] array;\n+        array = ArrayUtils.removeAll(new short[] { 1 }, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new short[] { 1, 2 }, 0);\n+        assertTrue(Arrays.equals(new short[] { 2 }, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new short[] { 1, 2 }, 1);\n+        assertTrue(Arrays.equals(new short[] { 1 }, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new short[] { 1, 2, 1 }, 1);\n+        assertTrue(Arrays.equals(new short[] { 1, 1 }, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+\n+        array = ArrayUtils.removeAll(new short[] { 1, 2 }, 0, 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new short[] { 1, 2, 3 }, 0, 1);\n+        assertTrue(Arrays.equals(new short[] { 3 }, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new short[] { 1, 2, 3 }, 1, 2);\n+        assertTrue(Arrays.equals(new short[] { 1 }, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new short[] { 1, 2, 3 }, 0, 2);\n+        assertTrue(Arrays.equals(new short[] { 2 }, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new short[] { 1, 2, 3, 4, 5 }, 1, 3);\n+        assertTrue(Arrays.equals(new short[] { 1, 3, 5 }, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new short[] { 1, 2, 3, 4, 5 }, 0, 2, 4);\n+        assertTrue(Arrays.equals(new short[] { 2, 4 }, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new short[] { 1, 2, 3, 4, 5, 6, 7 }, 1, 3, 5);\n+        assertTrue(Arrays.equals(new short[] { 1, 3, 5, 7 }, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeAll(new short[] { 1, 2, 3, 4, 5, 6, 7 }, 0, 2, 4, 6);\n+        assertTrue(Arrays.equals(new short[] { 2, 4, 6 }, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+    }\n+\n+    @Test\n+    public void testRemoveAllShortArrayRemoveNone() {\n+        short[] array1 = new short[] { 1, 2 };\n+        short[] array2 = ArrayUtils.removeAll(array1);\n+        assertNotSame(array1, array2);\n+        assertArrayEquals(array1, array2);\n+        assertEquals(short.class, array2.getClass().getComponentType());\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllShortArrayNegativeIndex() {\n+        ArrayUtils.removeAll(new short[] { 1, 2 }, -1, 0);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllShortArrayOutOfBoundsIndex() {\n+        ArrayUtils.removeAll(new short[] { 1, 2 }, 2, 0);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testRemoveAllNullShortArray() {\n+        ArrayUtils.removeAll((short[]) null, 0);\n+    }\n+\n+    @Test\n+    public void testRemoveElementsObjectArray() {\n+        Object[] array;\n+        array = ArrayUtils.removeElements((Object[]) null, \"a\");\n+        assertNull(array);\n+        array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, \"a\");\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new Object[] { \"a\" }, \"a\");\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new Object[] { \"a\", \"b\" }, \"a\");\n+        assertTrue(Arrays.equals(new Object[] { \"b\" }, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new Object[] { \"a\", \"b\", \"a\" }, \"a\");\n+        assertTrue(Arrays.equals(new Object[] { \"b\", \"a\" }, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+\n+        array = ArrayUtils.removeElements((Object[]) null, \"a\", \"b\");\n+        assertNull(array);\n+        array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, \"a\", \"b\");\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new Object[] { \"a\" }, \"a\", \"b\");\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new Object[] { \"a\", \"b\" }, \"a\", \"c\");\n+        assertTrue(Arrays.equals(new Object[] { \"b\" }, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new Object[] { \"a\", \"b\", \"a\" }, \"a\");\n+        assertTrue(Arrays.equals(new Object[] { \"b\", \"a\" }, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new Object[] { \"a\", \"b\", \"a\" }, \"a\", \"b\");\n+        assertTrue(Arrays.equals(new Object[] { \"a\" }, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new Object[] { \"a\", \"b\", \"a\" }, \"a\", \"a\");\n+        assertTrue(Arrays.equals(new Object[] { \"b\" }, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new Object[] { \"a\", \"b\", \"a\" }, \"a\", \"a\", \"a\", \"a\");\n+        assertTrue(Arrays.equals(new Object[] { \"b\" }, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+    }\n+\n+    @Test\n+    public void testRemoveElementBooleanArray() {\n+        boolean[] array;\n+        array = ArrayUtils.removeElements((boolean[]) null, true);\n+        assertNull(array);\n+        array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BOOLEAN_ARRAY, true);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new boolean[] { true }, true);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new boolean[] { true, false }, true);\n+        assertTrue(Arrays.equals(new boolean[] { false }, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new boolean[] { true, false, true }, true);\n+        assertTrue(Arrays.equals(new boolean[] { false, true }, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+\n+        array = ArrayUtils.removeElements((boolean[]) null, true, false);\n+        assertNull(array);\n+        array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BOOLEAN_ARRAY, true, false);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new boolean[] { true }, true, false);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new boolean[] { true, false }, true, false);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new boolean[] { true, false }, true, true);\n+        assertTrue(Arrays.equals(new boolean[] { false }, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new boolean[] { true, false, true }, true, false);\n+        assertTrue(Arrays.equals(new boolean[] { true }, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new boolean[] { true, false, true }, true, true);\n+        assertTrue(Arrays.equals(new boolean[] { false }, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new boolean[] { true, false, true }, true, true, true, true);\n+        assertTrue(Arrays.equals(new boolean[] { false }, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+    }\n+\n+    @Test\n+    public void testRemoveElementByteArray() {\n+        byte[] array;\n+        array = ArrayUtils.removeElements((byte[]) null, (byte) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1);\n+        assertTrue(Arrays.equals(new byte[] { 2 }, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1);\n+        assertTrue(Arrays.equals(new byte[] { 2, 1 }, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+\n+        array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 2);\n+        assertNull(array);\n+        array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 2);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 2);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1, (byte) 2);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1, (byte) 1);\n+        assertTrue(Arrays.equals(new byte[] { 2 }, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 2);\n+        assertTrue(Arrays.equals(new byte[] { 1 }, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 1);\n+        assertTrue(Arrays.equals(new byte[] { 2 }, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 1, (byte) 1, (byte) 1);\n+        assertTrue(Arrays.equals(new byte[] { 2 }, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+    }\n+\n+    @Test\n+    public void testRemoveElementCharArray() {\n+        char[] array;\n+        array = ArrayUtils.removeElements((char[]) null, 'a');\n+        assertNull(array);\n+        array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a');\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new char[] { 'a' }, 'a');\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a');\n+        assertTrue(Arrays.equals(new char[] { 'b' }, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a');\n+        assertTrue(Arrays.equals(new char[] { 'b', 'a' }, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+\n+        array = ArrayUtils.removeElements((char[]) null, 'a', 'b');\n+        assertNull(array);\n+        array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b');\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new char[] { 'a' }, 'a', 'b');\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b');\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'a');\n+        assertTrue(Arrays.equals(new char[] { 'b' }, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a', 'b');\n+        assertTrue(Arrays.equals(new char[] { 'a' }, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a', 'a');\n+        assertTrue(Arrays.equals(new char[] { 'b' }, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a', 'a', 'a', 'a');\n+        assertTrue(Arrays.equals(new char[] { 'b' }, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"cast\")\n+    public void testRemoveElementDoubleArray() {\n+        double[] array;\n+        array = ArrayUtils.removeElements((double[]) null, (double) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElements(ArrayUtils.EMPTY_DOUBLE_ARRAY, (double) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new double[] { 1 }, (double) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new double[] { 1, 2 }, (double) 1);\n+        assertTrue(Arrays.equals(new double[] { 2 }, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new double[] { 1, 2, 1 }, (double) 1);\n+        assertTrue(Arrays.equals(new double[] { 2, 1 }, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+\n+        array = ArrayUtils.removeElements((double[]) null, (double) 1, (double) 2);\n+        assertNull(array);\n+        array = ArrayUtils.removeElements(ArrayUtils.EMPTY_DOUBLE_ARRAY, (double) 1, (double) 2);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new double[] { 1 }, (double) 1, (double) 2);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new double[] { 1, 2 }, (double) 1, (double) 2);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new double[] { 1, 2 }, (double) 1, (double) 1);\n+        assertTrue(Arrays.equals(new double[] { 2 }, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new double[] { 1, 2, 1 }, (double) 1, (double) 2);\n+        assertTrue(Arrays.equals(new double[] { 1 }, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new double[] { 1, 2, 1 }, (double) 1, (double) 1);\n+        assertTrue(Arrays.equals(new double[] { 2 }, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new double[] { 1, 2, 1 }, (double) 1, (double) 1, (double) 1, (double) 1);\n+        assertTrue(Arrays.equals(new double[] { 2 }, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"cast\")\n+    public void testRemoveElementFloatArray() {\n+        float[] array;\n+        array = ArrayUtils.removeElements((float[]) null, (float) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1);\n+        assertTrue(Arrays.equals(new float[] { 2 }, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1);\n+        assertTrue(Arrays.equals(new float[] { 2, 1 }, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+\n+        array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1, (float) 2);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1, (float) 1);\n+        assertTrue(Arrays.equals(new float[] { 2 }, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1, (float) 1);\n+        assertTrue(Arrays.equals(new float[] { 2 }, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1, (float) 2);\n+        assertTrue(Arrays.equals(new float[] { 1 }, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1, (float) 1, (float) 1, (float) 1);\n+        assertTrue(Arrays.equals(new float[] { 2 }, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+    }\n+\n+    @Test\n+    public void testRemoveElementIntArray() {\n+        int[] array;\n+        array = ArrayUtils.removeElements((int[]) null, 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElements(ArrayUtils.EMPTY_INT_ARRAY, 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new int[] { 1 }, 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new int[] { 1, 2 }, 1);\n+        assertTrue(Arrays.equals(new int[] { 2 }, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new int[] { 1, 2, 1 }, 1);\n+        assertTrue(Arrays.equals(new int[] { 2, 1 }, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+\n+        array = ArrayUtils.removeElements((int[]) null, 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElements(ArrayUtils.EMPTY_INT_ARRAY, 1, 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new int[] { 1 }, 1, 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new int[] { 1, 2 }, 1, 2);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new int[] { 1, 2 }, 1, 1);\n+        assertTrue(Arrays.equals(new int[] { 2 }, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new int[] { 1, 2, 1 }, 1, 2);\n+        assertTrue(Arrays.equals(new int[] { 1 }, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new int[] { 1, 2, 1 }, 1, 1);\n+        assertTrue(Arrays.equals(new int[] { 2 }, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new int[] { 1, 2, 1 }, 1, 1, 1, 1);\n+        assertTrue(Arrays.equals(new int[] { 2 }, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"cast\")\n+    public void testRemoveElementLongArray() {\n+        long[] array;\n+        array = ArrayUtils.removeElements((long[]) null, (long) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElements(ArrayUtils.EMPTY_LONG_ARRAY, (long) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new long[] { 1 }, (long) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new long[] { 1, 2 }, (long) 1);\n+        assertTrue(Arrays.equals(new long[] { 2 }, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new long[] { 1, 2, 1 }, (long) 1);\n+        assertTrue(Arrays.equals(new long[] { 2, 1 }, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+\n+        array = ArrayUtils.removeElements((long[]) null, (long) 1, (long) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElements(ArrayUtils.EMPTY_LONG_ARRAY, (long) 1, (long) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new long[] { 1 }, (long) 1, (long) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new long[] { 1, 2 }, (long) 1, (long) 2);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new long[] { 1, 2 }, (long) 1, (long) 1);\n+        assertTrue(Arrays.equals(new long[] { 2 }, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new long[] { 1, 2, 1 }, (long) 1, (long) 1);\n+        assertTrue(Arrays.equals(new long[] { 2 }, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new long[] { 1, 2, 1 }, (long) 1, (long) 2);\n+        assertTrue(Arrays.equals(new long[] { 1 }, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new long[] { 1, 2, 1 }, (long) 1, (long) 1, (long) 1, (long) 1);\n+        assertTrue(Arrays.equals(new long[] { 2 }, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+    }\n+\n+    @Test\n+    public void testRemoveElementShortArray() {\n+        short[] array;\n+        array = ArrayUtils.removeElements((short[]) null, (short) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1);\n+        assertTrue(Arrays.equals(new short[] { 2 }, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1);\n+        assertTrue(Arrays.equals(new short[] { 2, 1 }, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+\n+        array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1, (short) 2);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1, (short) 1);\n+        assertTrue(Arrays.equals(new short[] { 2 }, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1, (short) 1);\n+        assertTrue(Arrays.equals(new short[] { 2 }, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1, (short) 2);\n+        assertTrue(Arrays.equals(new short[] { 1 }, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1, (short) 1, (short) 1, (short) 1);\n+        assertTrue(Arrays.equals(new short[] { 2 }, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+    }\n+\n+}", "timestamp": 1310862604, "metainfo": ""}