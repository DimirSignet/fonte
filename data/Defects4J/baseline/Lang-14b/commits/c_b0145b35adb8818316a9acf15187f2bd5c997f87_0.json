{"sha": "b0145b35adb8818316a9acf15187f2bd5c997f87", "log": "Copying from Collections to Lang  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/compare/AbstractTestComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.collections.AbstractTestObject;\n+\n+/**\n+ * Abstract test class for testing the Comparator interface.\n+ * <p>\n+ * Concrete subclasses declare the comparator to be tested.\n+ * They also declare certain aspects of the tests.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestComparator<T> extends AbstractTestObject {\n+\n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test class name\n+     */\n+    public AbstractTestComparator(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    /**\n+     * Implement this method to return a list of sorted objects.\n+     * \n+     * @return sorted objects\n+     */\n+    public abstract List<T> getComparableObjectsOrdered();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implements the abstract superclass method to return the comparator.\n+     * \n+     * @return a full iterator\n+     */\n+    @Override\n+    public abstract Comparator<T> makeObject();\n+\n+    /**\n+     * Overrides superclass to block tests.\n+     */\n+    @Override\n+    public boolean supportsEmptyCollections() {\n+        return false;\n+    }\n+\n+    /**\n+     * Overrides superclass to block tests.\n+     */\n+    @Override\n+    public boolean supportsFullCollections() {\n+        return false;\n+    }\n+\n+    /**\n+     * Overrides superclass to set the compatability to version 2\n+     * as there were no Comparators in version 1.x.\n+     */\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"2\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Reverse the list.\n+     */\n+    protected void reverseObjects(List<?> list) {\n+        Collections.reverse(list);\n+    }\n+\n+    /**\n+     * Randomize the list.\n+     */\n+    protected void randomizeObjects(List<?> list) {\n+        Collections.shuffle(list);\n+    }\n+\n+    /**\n+     * Sort the list.\n+     */\n+    protected void sortObjects(List<T> list, Comparator<? super T> comparator) {\n+        Collections.sort(list, comparator);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test sorting an empty list\n+     */\n+    public void testEmptyListSort() {\n+        List<T> list = new LinkedList<T>();\n+        sortObjects(list, makeObject());\n+\n+        List<T> list2 = new LinkedList<T>();\n+\n+        assertTrue(\"Comparator cannot sort empty lists\", list2.equals(list));\n+    }\n+\n+    /**\n+     * Test sorting a reversed list.\n+     */\n+    public void testReverseListSort() {\n+        Comparator<T> comparator = makeObject();\n+\n+        List<T> randomList = getComparableObjectsOrdered();\n+        reverseObjects(randomList);\n+        sortObjects(randomList, comparator);\n+\n+        List<T> orderedList = getComparableObjectsOrdered();\n+\n+        assertTrue(\"Comparator did not reorder the List correctly\",\n+                   orderedList.equals(randomList));\n+    }\n+\n+    /**\n+     * Test sorting a random list.\n+     */\n+    public void testRandomListSort() {\n+        Comparator<T> comparator = makeObject();\n+\n+        List<T> randomList = getComparableObjectsOrdered();\n+        randomizeObjects(randomList);\n+        sortObjects(randomList,comparator);\n+\n+        List<T> orderedList = getComparableObjectsOrdered();\n+\n+        /* debug \n+        Iterator i = randomList.iterator();\n+        while (i.hasNext()) {\n+            System.out.println(i.next());\n+        }\n+        */\n+\n+        assertTrue(\"Comparator did not reorder the List correctly\",\n+                   orderedList.equals(randomList));\n+\n+    }\n+\n+    /**\n+     * Nearly all Comparators should be Serializable.\n+     */\n+    public void testComparatorIsSerializable() {\n+        Comparator<T> comparator = makeObject();\n+        assertTrue(\"This comparator should be Serializable.\",\n+                   comparator instanceof Serializable);\n+    }\n+\n+    public String getCanonicalComparatorName(Object object) {\n+        StringBuilder retval = new StringBuilder();\n+        retval.append(\"data/test/\");\n+        String colName = object.getClass().getName();\n+        colName = colName.substring(colName.lastIndexOf(\".\")+1,colName.length());\n+        retval.append(colName);\n+        retval.append(\".version\");\n+        retval.append(getCompatibilityVersion());\n+        retval.append(\".obj\");\n+        return retval.toString();\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the Comparator\n+     * against the canonical version in SVN.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testComparatorCompatibility() throws IOException, ClassNotFoundException {\n+        if (!skipSerializedCanonicalTests()) {\n+            Comparator<T> comparator = null;\n+    \n+            // test to make sure the canonical form has been preserved\n+            try {\n+                comparator = (Comparator<T>) readExternalFormFromDisk(getCanonicalComparatorName(makeObject()));\n+            } catch (FileNotFoundException exception) {\n+    \n+                boolean autoCreateSerialized = false;\n+    \n+                if (autoCreateSerialized) {\n+                      comparator = makeObject();\n+                    String fileName = getCanonicalComparatorName(comparator);\n+                    writeExternalFormToDisk((Serializable) comparator, fileName);\n+                    fail(\"Serialized form could not be found.  A serialized version \"\n+                            + \"has now been written (and should be added to CVS): \" + fileName);\n+                } else {\n+                    fail(\"The Serialized form could be located to test serialization \"\n+                            + \"compatibility: \" + exception.getMessage());\n+                }\n+            }\n+    \n+            \n+            // make sure the canonical form produces the ordering we currently\n+            // expect\n+            List<T> randomList = getComparableObjectsOrdered();\n+            reverseObjects(randomList);\n+            sortObjects(randomList, comparator);\n+    \n+            List<T> orderedList = getComparableObjectsOrdered();\n+    \n+            assertTrue(\"Comparator did not reorder the List correctly\",\n+                       orderedList.equals(randomList));\n+        }\n+    }\n+\n+}", "timestamp": 1312780741, "metainfo": ""}