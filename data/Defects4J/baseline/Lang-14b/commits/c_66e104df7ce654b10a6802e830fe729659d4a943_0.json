{"sha": "66e104df7ce654b10a6802e830fe729659d4a943", "log": "Copying from Collections to Lang  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/compare/TestFixedOrderComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test class for FixedOrderComparator.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author David Leppik\n+ * @author Stephen Colebourne\n+ */\n+public class TestFixedOrderComparator extends TestCase {\n+\n+    /**\n+     * Top cities of the world, by population including metro areas.\n+     */\n+    private static final String topCities[] = new String[] {\n+        \"Tokyo\",\n+        \"Mexico City\",\n+        \"Mumbai\",\n+        \"Sao Paulo\",\n+        \"New York\",\n+        \"Shanghai\",\n+        \"Lagos\",\n+        \"Los Angeles\",\n+        \"Calcutta\",\n+        \"Buenos Aires\"\n+    };\n+\n+    //\n+    // Initialization and busywork\n+    //\n+\n+    public TestFixedOrderComparator(String name) {\n+        super(name);\n+    }\n+\n+    //\n+    // Set up and tear down\n+    //\n+\n+\n+\n+    //\n+    // The tests\n+    //\n+\n+    /**\n+     * Tests that the constructor plus add method compares items properly.\n+     */\n+    public void testConstructorPlusAdd() {\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>();\n+        for (int i = 0; i < topCities.length; i++) {\n+            comparator.add(topCities[i]);\n+        }\n+        String[] keys = topCities.clone();\n+        assertComparatorYieldsOrder(keys, comparator);\n+    }\n+\n+    /**\n+     * Tests that the array constructor compares items properly.\n+     */\n+    public void testArrayConstructor() {\n+        String[] keys = topCities.clone();\n+        String[] topCitiesForTest = topCities.clone();\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCitiesForTest);\n+        assertComparatorYieldsOrder(keys, comparator);\n+        // test that changing input after constructor has no effect\n+        topCitiesForTest[0] = \"Brighton\";\n+        assertComparatorYieldsOrder(keys, comparator);\n+    }\n+\n+    /**\n+     * Tests the list constructor.\n+     */\n+    public void testListConstructor() {\n+        String[] keys = topCities.clone();\n+        List<String> topCitiesForTest = new LinkedList<String>(Arrays.asList(topCities));\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCitiesForTest);\n+        assertComparatorYieldsOrder(keys, comparator);\n+        // test that changing input after constructor has no effect\n+        topCitiesForTest.set(0, \"Brighton\");\n+        assertComparatorYieldsOrder(keys, comparator);\n+    }\n+\n+    /**\n+     * Tests addAsEqual method.\n+     */\n+    public void testAddAsEqual() {\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n+        comparator.addAsEqual(\"New York\", \"Minneapolis\");\n+        assertEquals(0, comparator.compare(\"New York\", \"Minneapolis\"));\n+        assertEquals(-1, comparator.compare(\"Tokyo\", \"Minneapolis\"));\n+        assertEquals(1, comparator.compare(\"Shanghai\", \"Minneapolis\"));\n+    }\n+\n+    /**\n+     * Tests whether or not updates are disabled after a comparison is made.\n+     */\n+    public void testLock() {\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n+        assertEquals(false, comparator.isLocked());\n+        comparator.compare(\"New York\", \"Tokyo\");\n+        assertEquals(true, comparator.isLocked());\n+        try {\n+            comparator.add(\"Minneapolis\");\n+            fail(\"Should have thrown an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // success -- ignore\n+        }\n+\n+        try {\n+            comparator.addAsEqual(\"New York\", \"Minneapolis\");\n+            fail(\"Should have thrown an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // success -- ignore\n+        }\n+    }\n+\n+    public void testUnknownObjectBehavior() {\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n+        try {\n+            comparator.compare(\"New York\", \"Minneapolis\");\n+            fail(\"Should have thrown a IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // success-- ignore\n+        }\n+        try {\n+            comparator.compare(\"Minneapolis\", \"New York\");\n+            fail(\"Should have thrown a IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // success-- ignore\n+        }\n+        assertEquals(FixedOrderComparator.UnknownObjectBehavior.EXCEPTION, comparator.getUnknownObjectBehavior());\n+\n+        comparator = new FixedOrderComparator<String>(topCities);\n+        comparator.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.BEFORE);\n+        assertEquals(FixedOrderComparator.UnknownObjectBehavior.BEFORE, comparator.getUnknownObjectBehavior());\n+        LinkedList<String> keys = new LinkedList<String>(Arrays.asList(topCities));\n+        keys.addFirst(\"Minneapolis\");\n+        assertComparatorYieldsOrder(keys.toArray(new String[0]), comparator);\n+\n+        assertEquals(-1, comparator.compare(\"Minneapolis\", \"New York\"));\n+        assertEquals( 1, comparator.compare(\"New York\", \"Minneapolis\"));\n+        assertEquals( 0, comparator.compare(\"Minneapolis\", \"St Paul\"));\n+\n+        comparator = new FixedOrderComparator<String>(topCities);\n+        comparator.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.AFTER);\n+        keys = new LinkedList<String>(Arrays.asList(topCities));\n+        keys.add(\"Minneapolis\");\n+        assertComparatorYieldsOrder(keys.toArray(new String[0]), comparator);\n+\n+        assertEquals( 1, comparator.compare(\"Minneapolis\", \"New York\"));\n+        assertEquals(-1, comparator.compare(\"New York\", \"Minneapolis\"));\n+        assertEquals( 0, comparator.compare(\"Minneapolis\", \"St Paul\"));\n+\n+    }\n+\n+    //\n+    // Helper methods\n+    //\n+\n+    /** Shuffles the keys and asserts that the comparator sorts them back to\n+     * their original order.\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private void assertComparatorYieldsOrder(String[] orderedObjects,\n+                                             Comparator<String> comparator) {\n+        String[] keys = orderedObjects.clone();\n+\n+        // shuffle until the order changes.  It's extremely rare that\n+        // this requires more than one shuffle.\n+\n+        boolean isInNewOrder = false;\n+        Random rand = new Random();\n+        while (keys.length > 1 && isInNewOrder == false) {\n+            // shuffle:\n+            for (int i = keys.length-1; i > 0; i--) {\n+                String swap = keys[i];\n+                int j = rand.nextInt(i+1);\n+                keys[i] = keys[j];\n+                keys[j] = swap;\n+            }\n+\n+            // testShuffle\n+            for (int i = 0; i < keys.length && !isInNewOrder; i++) {\n+                if( !orderedObjects[i].equals(keys[i])) {\n+                    isInNewOrder = true;\n+                }\n+            }\n+        }\n+\n+        // The real test:  sort and make sure they come out right.\n+\n+        Arrays.sort(keys, comparator);\n+\n+        for (int i = 0; i < orderedObjects.length; i++) {\n+            assertEquals(orderedObjects[i], keys[i]);\n+        }\n+    }\n+\n+}", "timestamp": 1312780799, "metainfo": ""}