{"sha": "bbf23be56fa3bacf722425e21bc1932dff36246e", "log": "Javadoc, comments, and message strings: Change \"unicode\" to \"Unicode\".  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/CharUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/CharUtils.java\n     \n     //--------------------------------------------------------------------------\n     /**\n-     * <p>Converts the string to the unicode format '\\u0020'.</p>\n+     * <p>Converts the string to the Unicode format '\\u0020'.</p>\n      * \n      * <p>This format is the Java source code format.</p>\n      *\n      * </pre>\n      * \n      * @param ch  the character to convert\n-     * @return the escaped unicode string\n+     * @return the escaped Unicode string\n      */\n     public static String unicodeEscaped(char ch) {\n         if (ch < 0x10) {\n     }\n     \n     /**\n-     * <p>Converts the string to the unicode format '\\u0020'.</p>\n+     * <p>Converts the string to the Unicode format '\\u0020'.</p>\n      * \n      * <p>This format is the Java source code format.</p>\n      * \n      * </pre>\n      * \n      * @param ch  the character to convert, may be null\n-     * @return the escaped unicode string, null if null input\n+     * @return the escaped Unicode string, null if null input\n      */\n     public static String unicodeEscaped(Character ch) {\n         if (ch == null) {\n--- a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n /**\n  * <p>Operations for random {@code String}s.</p>\n  * <p>Currently <em>private high surrogate</em> characters are ignored. \n- * These are unicode characters that fall between the values 56192 (db80)\n+ * These are Unicode characters that fall between the values 56192 (db80)\n  * and 56319 (dbff) as we don't know how to handle them. \n  * High and low surrogates are correctly dealt with - that is if a \n  * high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f) \n--- a/src/main/java/org/apache/commons/lang3/StringEscapeUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringEscapeUtils.java\n      * <p>Supports only the five basic XML entities (gt, lt, quot, amp, apos).\n      * Does not support DTDs or external entities.</p>\n      *\n-     * <p>Note that unicode characters greater than 0x7f are as of 3.0, no longer \n+     * <p>Note that Unicode characters greater than 0x7f are as of 3.0, no longer \n      *    escaped. If you still wish this functionality, you can achieve it \n      *    via the following: \n      * {@code StringEscapeUtils.ESCAPE_XML.with( NumericEntityEscaper.between(0x7f, Integer.MAX_VALUE) );}</p>\n      * <p>Supports only the five basic XML entities (gt, lt, quot, amp, apos).\n      * Does not support DTDs or external entities.</p>\n      *\n-     * <p>Note that numerical \\\\u unicode codes are unescaped to their respective \n-     *    unicode characters. This may change in future releases. </p>\n+     * <p>Note that numerical \\\\u Unicode codes are unescaped to their respective \n+     *    Unicode characters. This may change in future releases. </p>\n      *\n      * @param input  the {@code String} to unescape, may be null\n      * @return a new unescaped {@code String}, {@code null} if null string input\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n      * <code>false</code>.</p>\n      *\n      * @param str  the <code>String</code> to check\n-     * @return <code>true</code> if str contains only unicode numeric\n+     * @return <code>true</code> if str contains only Unicode numeric\n      */\n     public static boolean isDigits(String str) {\n         if (StringUtils.isEmpty(str)) {\n--- a/src/main/java/org/apache/commons/lang3/text/StrBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrBuilder.java\n \n     /**\n      * Updates the length of the builder by either dropping the last characters\n-     * or adding filler of unicode zero.\n+     * or adding filler of Unicode zero.\n      *\n      * @param length  the length to set to, must be zero or positive\n      * @return this, to enable chaining\n--- a/src/main/java/org/apache/commons/lang3/text/WordUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/text/WordUtils.java\n      *\n      * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n      * A <code>null</code> input String returns <code>null</code>.\n-     * Capitalization uses the unicode title case, normally equivalent to\n+     * Capitalization uses the Unicode title case, normally equivalent to\n      * upper case.</p>\n      *\n      * <pre>\n      * delimiter will be capitalized. </p>\n      *\n      * <p>A <code>null</code> input String returns <code>null</code>.\n-     * Capitalization uses the unicode title case, normally equivalent to\n+     * Capitalization uses the Unicode title case, normally equivalent to\n      * upper case.</p>\n      *\n      * <pre>\n      *\n      * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n      * A <code>null</code> input String returns <code>null</code>.\n-     * Capitalization uses the unicode title case, normally equivalent to\n+     * Capitalization uses the Unicode title case, normally equivalent to\n      * upper case.</p>\n      *\n      * <pre>\n      * delimiter will be capitalized. </p>\n      *\n      * <p>A <code>null</code> input String returns <code>null</code>.\n-     * Capitalization uses the unicode title case, normally equivalent to\n+     * Capitalization uses the Unicode title case, normally equivalent to\n      * upper case.</p>\n      *\n      * <pre>\n--- a/src/main/java/org/apache/commons/lang3/text/translate/UnicodeEscaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/UnicodeEscaper.java\n import java.io.Writer;\n \n /**\n- * Translates codepoints to their unicode escaped value.\n+ * Translates codepoints to their Unicode escaped value.\n  *\n  * @since 3.0\n  * @version $Id$\n             }\n         }\n \n-        // TODO: Handle potential + sign per various unicode escape implementations\n+        // TODO: Handle potential + sign per various Unicode escape implementations\n         if (codepoint > 0xffff) {\n-            // TODO: Figure out what to do. Output as two unicodes?\n+            // TODO: Figure out what to do. Output as two Unicodes?\n             //       Does this make this a Java-specific output class?\n             out.write(\"\\\\u\" + hex(codepoint));\n         } else if (codepoint > 0xfff) {\n--- a/src/main/java/org/apache/commons/lang3/text/translate/UnicodeUnescaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/UnicodeUnescaper.java\n import java.io.Writer;\n \n /**\n- * Translates escaped unicode values of the form \\\\u+\\d\\d\\d\\d back to \n- * unicode. It supports multiple 'u' characters and will work with or \n+ * Translates escaped Unicode values of the form \\\\u+\\d\\d\\d\\d back to \n+ * Unicode. It supports multiple 'u' characters and will work with or \n  * without the +.\n  * \n  * @since 3.0\n--- a/src/test/java/org/apache/commons/lang3/StringEscapeUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringEscapeUtilsTest.java\n         assertEscapeJava(\"\\\\u0234\", \"\\u0234\");\n         assertEscapeJava(\"\\\\u00EF\", \"\\u00ef\");\n         assertEscapeJava(\"\\\\u0001\", \"\\u0001\");\n-        assertEscapeJava(\"Should use capitalized unicode hex\", \"\\\\uABCD\", \"\\uabcd\");\n+        assertEscapeJava(\"Should use capitalized Unicode hex\", \"\\\\uABCD\", \"\\uabcd\");\n \n         assertEscapeJava(\"He didn't say, \\\\\\\"stop!\\\\\\\"\",\n                 \"He didn't say, \\\"stop!\\\"\");\n         assertUnescapeJava(\"'\\foo\\teste\\r\", \"\\\\'\\\\foo\\\\teste\\\\r\");\n         assertUnescapeJava(\"\", \"\\\\\");\n         //foo\n-        assertUnescapeJava(\"lowercase unicode\", \"\\uABCDx\", \"\\\\uabcdx\");\n-        assertUnescapeJava(\"uppercase unicode\", \"\\uABCDx\", \"\\\\uABCDx\");\n-        assertUnescapeJava(\"unicode as final character\", \"\\uABCD\", \"\\\\uabcd\");\n+        assertUnescapeJava(\"lowercase Unicode\", \"\\uABCDx\", \"\\\\uabcdx\");\n+        assertUnescapeJava(\"uppercase Unicode\", \"\\uABCDx\", \"\\\\uABCDx\");\n+        assertUnescapeJava(\"Unicode as final character\", \"\\uABCD\", \"\\\\uabcd\");\n     }\n \n     private void assertUnescapeJava(String unescaped, String original) throws IOException {\n             assertEquals(message, expected, actual);\n         }\n         // \\u00E7 is a cedilla (c with wiggle under)\n-        // note that the test string must be 7-bit-clean (unicode escaped) or else it will compile incorrectly\n+        // note that the test string must be 7-bit-clean (Unicode escaped) or else it will compile incorrectly\n         // on some locales        \n         assertEquals(\"funny chars pass through OK\", \"Fran\\u00E7ais\", StringEscapeUtils.unescapeHtml4(\"Fran\\u00E7ais\"));\n         \n     public void testEscapeHtmlHighUnicode() throws java.io.UnsupportedEncodingException {\n         // this is the utf8 representation of the character:\n         // COUNTING ROD UNIT DIGIT THREE\n-        // in unicode\n+        // in Unicode\n         // codepoint: U+1D362\n         byte[] data = new byte[] { (byte)0xF0, (byte)0x9D, (byte)0x8D, (byte)0xA2 };\n \n         String original = new String(data, \"UTF8\");\n \n         String escaped = StringEscapeUtils.escapeHtml4( original );\n-        assertEquals( \"High unicode should not have been escaped\", original, escaped);\n+        assertEquals( \"High Unicode should not have been escaped\", original, escaped);\n \n         String unescaped = StringEscapeUtils.unescapeHtml4( escaped );\n-        assertEquals( \"High unicode should have been unchanged\", original, unescaped);\n+        assertEquals( \"High Unicode should have been unchanged\", original, unescaped);\n \n // TODO: I think this should hold, needs further investigation\n //        String unescapedFromEntity = StringEscapeUtils.unescapeHtml4( \"&#119650;\" );\n-//        assertEquals( \"High unicode should have been unescaped\", original, unescapedFromEntity);\n+//        assertEquals( \"High Unicode should have been unescaped\", original, unescapedFromEntity);\n     }\n \n     /**\n      */\n     @Test\n     public void testEscapeHiragana() {\n-        // Some random Japanese unicode characters\n+        // Some random Japanese Unicode characters\n         String original = \"\\u304B\\u304C\\u3068\";\n         String escaped = StringEscapeUtils.escapeHtml4(original);\n-        assertEquals( \"Hiragana character unicode behaviour should not be being escaped by escapeHtml4\",\n+        assertEquals( \"Hiragana character Unicode behaviour should not be being escaped by escapeHtml4\",\n         original, escaped);\n \n         String unescaped = StringEscapeUtils.unescapeHtml4( escaped );\n \n-        assertEquals( \"Hiragana character unicode behaviour has changed - expected no unescaping\", escaped, unescaped);\n+        assertEquals( \"Hiragana character Unicode behaviour has changed - expected no unescaping\", escaped, unescaped);\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/lang3/text/translate/UnicodeEscaperTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/translate/UnicodeEscaperTest.java\n \n         String input = \"ADFGZ\";\n         String result = ue.translate(input);\n-        assertEquals(\"Failed to escape unicode characters via the below method\", \"\\\\u0041\\\\u0044FGZ\", result);\n+        assertEquals(\"Failed to escape Unicode characters via the below method\", \"\\\\u0041\\\\u0044FGZ\", result);\n     }\n \n     public void testBetween() {\n \n         String input = \"ADFGZ\";\n         String result = ue.translate(input);\n-        assertEquals(\"Failed to escape unicode characters via the between method\", \"AD\\\\u0046\\\\u0047Z\", result);\n+        assertEquals(\"Failed to escape Unicode characters via the between method\", \"AD\\\\u0046\\\\u0047Z\", result);\n     }\n \n     public void testAbove() {\n \n         String input = \"ADFGZ\";\n         String result = ue.translate(input);\n-        assertEquals(\"Failed to escape unicode characters via the above method\", \"ADF\\\\u0047\\\\u005A\", result);\n+        assertEquals(\"Failed to escape Unicode characters via the above method\", \"ADF\\\\u0047\\\\u005A\", result);\n     }\n }\n--- a/src/test/java/org/apache/commons/lang3/text/translate/UnicodeUnescaperTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/translate/UnicodeUnescaperTest.java\n         UnicodeUnescaper uu = new UnicodeUnescaper();\n \n         String input = \"\\\\u+0047\";\n-        assertEquals(\"Failed to unescape unicode characters with 'u+' notation\", \"G\", uu.translate(input));\n+        assertEquals(\"Failed to unescape Unicode characters with 'u+' notation\", \"G\", uu.translate(input));\n     }\n \n     public void testUuuuu() {\n \n         String input = \"\\\\uuuuuuuu0047\";\n         String result = uu.translate(input);\n-        assertEquals(\"Failed to unescape unicode characters with many 'u' characters\", \"G\", result);\n+        assertEquals(\"Failed to unescape Unicode characters with many 'u' characters\", \"G\", result);\n     }\n \n     public void testLessThanFour() {\n         String input = \"\\\\0047\\\\u006\";\n         try {\n             uu.translate(input);\n-            fail(\"A lack of digits in a unicode escape sequence failed to throw an exception\");\n+            fail(\"A lack of digits in a Unicode escape sequence failed to throw an exception\");\n         } catch(IllegalArgumentException iae) {\n             // expected\n         }", "timestamp": 1311108803, "metainfo": ""}