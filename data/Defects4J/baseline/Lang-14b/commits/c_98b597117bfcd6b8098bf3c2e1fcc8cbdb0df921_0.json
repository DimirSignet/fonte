{"sha": "98b597117bfcd6b8098bf3c2e1fcc8cbdb0df921", "log": "Decompose pair into an abstract class with element accessor methods + mutable/immutable concrete expression classes  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/ImmutablePair.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.util.Map;\n+\n+/**\n+ * Immutable concrete manifestation of the {@link Pair} type.\n+ * \n+ * <p>#ThreadSafe# if the objects are threadsafe</p>\n+ * @since Lang 3.0\n+ * @author Matt Benson\n+ * @version $Id$\n+ * \n+ * @param <L> left generic type\n+ * @param <R> right generic type\n+ */\n+public class ImmutablePair<L, R> extends Pair<L, R> {\n+    /** Serialization version */\n+    private static final long serialVersionUID = 4954918890077093841L;\n+\n+    /** Left object */\n+    public final L left;\n+    /** Right object */\n+    public final R right;\n+\n+    /**\n+     * Create a new ImmutablePair instance.\n+     * \n+     * @param left\n+     * @param right\n+     */\n+    public ImmutablePair(L left, R right) {\n+        super();\n+        this.left = left;\n+        this.right = right;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public L getLeftElement() {\n+        return left;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public R getRightElement() {\n+        return right;\n+    }\n+\n+    /**\n+     * {@link Map.Entry#setValue(Object)} implementation.\n+     * @throws UnsupportedOperationException\n+     */\n+    public R setValue(R arg0) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Static fluent creation method for an {@link ImmutablePair}<L, R>:\n+     * <code>ImmutablePair.of(left, right)</code>\n+     * @param <L>\n+     * @param <R>\n+     * @param left\n+     * @param right\n+     * @return ImmutablePair<L, R>(left, right)\n+     */\n+    public static <L, R> ImmutablePair<L, R> of(L left, R right) {\n+        return new ImmutablePair<L, R>(left, right);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/MutablePair.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.util.Map;\n+\n+/**\n+ * Mutable concrete manifestation of the {@link Pair} type.\n+ * \n+ * <p>#ThreadSafe# if the objects are threadsafe</p>\n+ * @since Lang 3.0\n+ * @author Matt Benson\n+ * @version $Id$\n+ * \n+ * @param <L> left generic type\n+ * @param <R> right generic type\n+ */\n+public class MutablePair<L, R> extends Pair<L, R> {\n+    /** Serialization version */\n+    private static final long serialVersionUID = 4954918890077093841L;\n+\n+    private L leftElement;\n+    private R rightElement;\n+\n+    /**\n+     * Create a new MutablePair instance.\n+     */\n+    public MutablePair() {\n+        super();\n+    }\n+\n+    /**\n+     * Create a new MutablePair instance.\n+     * \n+     * @param leftElement\n+     * @param rightElement\n+     */\n+    public MutablePair(L leftElement, R rightElement) {\n+        super();\n+        this.leftElement = leftElement;\n+        this.rightElement = rightElement;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public L getLeftElement() {\n+        return leftElement;\n+    }\n+\n+    /**\n+     * Set the left element of the pair.\n+     * @param leftElement\n+     */\n+    public void setLeftElement(L leftElement) {\n+        this.leftElement = leftElement;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public R getRightElement() {\n+        return rightElement;\n+    }\n+\n+    /**\n+     * Set the right element of the pair.\n+     * @param rightElement\n+     */\n+    public void setRightElement(R rightElement) {\n+        this.rightElement = rightElement;\n+    }\n+\n+    /**\n+     * Implement {@link Map.Entry#setValue(Object)}.\n+     * @param value value (<code>rightElement</code>) to set\n+     */\n+    public R setValue(R value) {\n+        R result = getRightElement();\n+        setRightElement(value);\n+        return result;\n+    }\n+\n+    /**\n+     * Static fluent creation method for a {@link MutablePair}<L, R>:\n+     * <code>MutablePair.of(left, right)</code>\n+     * @param <L>\n+     * @param <R>\n+     * @param left\n+     * @param right\n+     * @return MutablePair<L, R>(left, right)\n+     */\n+    public static <L, R> MutablePair<L, R> of(L left, R right) {\n+        return new MutablePair<L, R>(left, right);\n+    }\n+}\n--- a/src/main/java/org/apache/commons/lang3/Pair.java\n+++ b/src/main/java/org/apache/commons/lang3/Pair.java\n package org.apache.commons.lang3;\n \n import java.io.Serializable;\n+import java.util.Map;\n \n import org.apache.commons.lang3.builder.HashCodeBuilder;\n \n /**\n- * A basic immutable Object pair.\n- *\n- * <p>#ThreadSafe# if the objects are threadsafe</p>\n+ * Abstract Pair (or 2-element Tuple).\n+ * \n  * @since Lang 3.0\n  * @author Matt Benson\n  * @version $Id$\n  */\n-public final class Pair<L, R> implements Serializable {\n+public abstract class Pair<L, R> implements Serializable, Map.Entry<L, R> {\n     /** Serialization version */\n     private static final long serialVersionUID = 4954918890077093841L;\n \n-    /** Left object */\n-    public final L left;\n-\n-    /** Right object */\n-    public final R right;\n+    /**\n+     * Get the \"left\" element of the pair.\n+     * @return L\n+     */\n+    public abstract L getLeftElement();\n \n     /**\n-     * Create a new Pair instance.\n-     * @param left\n-     * @param right\n+     * Get the \"right\" element of the pair.\n+     * @return\n      */\n-    public Pair(L left, R right) {\n-        this.left = left;\n-        this.right = right;\n+    public abstract R getRightElement();\n+\n+    /**\n+     * Return {@link #getLeftElement()} as a {@link Map.Entry}'s key.\n+     * @return L\n+     */\n+    public final L getKey() {\n+        return getLeftElement();\n+    }\n+\n+    /**\n+     * Return {@link #getRightElement()} as a {@link Map.Entry}'s value.\n+     * @return R\n+     */\n+    public R getValue() {\n+        return getRightElement();\n     }\n \n     /**\n             return false;\n         }\n         Pair<?, ?> other = (Pair<?, ?>) obj;\n-        return ObjectUtils.equals(left, other.left) && ObjectUtils.equals(right, other.right);\n+        return ObjectUtils.equals(getLeftElement(), other.getLeftElement())\n+                && ObjectUtils.equals(getRightElement(), other.getRightElement());\n     }\n \n     /**\n      */\n     @Override\n     public int hashCode() {\n-        return new HashCodeBuilder().append(left).append(right).toHashCode();\n+        // TODO should the hashCodeBuilder be seeded per concrete type?\n+        return new HashCodeBuilder().append(getLeftElement()).append(getRightElement())\n+                .toHashCode();\n     }\n \n     /**\n      */\n     @Override\n     public String toString() {\n-        StringBuilder builder = new StringBuilder();\n+        StringBuilder builder = new StringBuilder(ClassUtils.getShortClassName(this, null));\n         builder.append(\"(\");\n-        builder.append(left);\n+        builder.append(getLeftElement());\n         builder.append(\",\");\n-        builder.append(right);\n+        builder.append(getRightElement());\n         builder.append(\")\");\n         return builder.toString();\n     }\n \n     /**\n-     * Static fluent creation method for a Pair<L, R>:  <code>Pair.of(left, right)</code>\n+     * Static fluent creation method for a {@link Pair}<L, R>:\n+     * <code>Pair.of(left, right)</code>\n      * @param <L>\n      * @param <R>\n      * @param left\n      * @param right\n-     * @return Pair<L, R>(left, right)\n+     * @return ImmutablePair<L, R>(left, right)\n      */\n     public static <L, R> Pair<L, R> of(L left, R right) {\n-        return new Pair<L, R>(left, right);\n+        return new ImmutablePair<L, R>(left, right);\n     }\n }\n--- a/src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java\n     static boolean isRegistered(Object lhs, Object rhs) {\n         Set<Pair<IDKey, IDKey>> registry = getRegistry();\n         Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n-        Pair<IDKey, IDKey> swappedPair = Pair.of(pair.right, pair.left);\n+        Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeftElement(), pair.getRightElement());\n \n         return registry != null\n                 && (registry.contains(pair) || registry.contains(swappedPair));\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/ImmutablePairTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertNull;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Test the Pair class.\n+ * @author Matt Benson\n+ * @version $Id$\n+ */\n+public class ImmutablePairTest {\n+\n+    @Test\n+    public void testBasic() throws Exception {\n+        ImmutablePair<Integer, String> pair = new ImmutablePair<Integer, String>(0, \"foo\");\n+        assertEquals(0, pair.left.intValue());\n+        assertEquals(0, pair.getLeftElement().intValue());\n+        assertEquals(\"foo\", pair.right);\n+        assertEquals(\"foo\", pair.getRightElement());\n+        ImmutablePair<Object, String> pair2 = new ImmutablePair<Object, String>(null, \"bar\");\n+        assertNull(pair2.left);\n+        assertNull(pair2.getLeftElement());\n+        assertEquals(\"bar\", pair2.right);\n+        assertEquals(\"bar\", pair2.getRightElement());\n+    }\n+\n+    @Test\n+    public void testPairOf() throws Exception {\n+        ImmutablePair<Integer, String> pair = ImmutablePair.of(0, \"foo\");\n+        assertEquals(0, pair.left.intValue());\n+        assertEquals(0, pair.getLeftElement().intValue());\n+        assertEquals(\"foo\", pair.right);\n+        assertEquals(\"foo\", pair.getRightElement());\n+        ImmutablePair<Object, String> pair2 = ImmutablePair.of(null, \"bar\");\n+        assertNull(pair2.left);\n+        assertNull(pair2.getLeftElement());\n+        assertEquals(\"bar\", pair2.right);\n+        assertEquals(\"bar\", pair2.getRightElement());\n+    }\n+\n+    @Test\n+    public void testEquals() throws Exception {\n+        assertEquals(ImmutablePair.of(null, \"foo\"), ImmutablePair.of(null, \"foo\"));\n+        assertFalse(ImmutablePair.of(\"foo\", 0).equals(ImmutablePair.of(\"foo\", null)));\n+        assertFalse(ImmutablePair.of(\"foo\", \"bar\").equals(ImmutablePair.of(\"xyz\", \"bar\")));\n+\n+        ImmutablePair<String, String> p = ImmutablePair.of(\"foo\", \"bar\");\n+        assertTrue(p.equals(p));\n+        assertFalse(p.equals(new Object()));\n+    }\n+\n+    @Test\n+    public void testHashCode() throws Exception {\n+        assertEquals(ImmutablePair.of(null, \"foo\").hashCode(), ImmutablePair.of(null, \"foo\").hashCode());\n+    }\n+\n+    @Test\n+    public void testToString() throws Exception {\n+        assertEquals(\"ImmutablePair(null,null)\", ImmutablePair.of(null, null).toString());\n+        assertEquals(\"ImmutablePair(null,two)\", ImmutablePair.of(null, \"two\").toString());\n+        assertEquals(\"ImmutablePair(one,null)\", ImmutablePair.of(\"one\", null).toString());\n+        assertEquals(\"ImmutablePair(one,two)\", ImmutablePair.of(\"one\", \"two\").toString());\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSerialization() throws Exception {\n+        ImmutablePair<Integer, String> origPair = ImmutablePair.of(0, \"foo\");\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(baos);\n+        out.writeObject(origPair);\n+        ImmutablePair<Integer, String> deserializedPair = (ImmutablePair<Integer, String>) new ObjectInputStream(\n+                new ByteArrayInputStream(baos.toByteArray())).readObject();\n+        assertEquals(origPair, deserializedPair);\n+        assertEquals(origPair.hashCode(), deserializedPair.hashCode());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/MutablePairTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertNull;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Test the MutablePair class.\n+ * @author Matt Benson\n+ * @version $Id$\n+ */\n+public class MutablePairTest {\n+\n+    @Test\n+    public void testBasic() throws Exception {\n+        MutablePair<Integer, String> pair = new MutablePair<Integer, String>(0, \"foo\");\n+        assertEquals(0, pair.getLeftElement().intValue());\n+        assertEquals(\"foo\", pair.getRightElement());\n+        MutablePair<Object, String> pair2 = new MutablePair<Object, String>(null, \"bar\");\n+        assertNull(pair2.getLeftElement());\n+        assertEquals(\"bar\", pair2.getRightElement());\n+    }\n+\n+    @Test\n+    public void testDefault() throws Exception {\n+        MutablePair<Integer, String> pair = new MutablePair<Integer, String>();\n+        assertNull(pair.getLeftElement());\n+        assertNull(pair.getRightElement());\n+    }\n+    \n+    @Test\n+    public void testMutate() throws Exception {\n+        MutablePair<Integer, String> pair = new MutablePair<Integer, String>(0, \"foo\");\n+        pair.setLeftElement(42);\n+        pair.setRightElement(\"bar\");\n+        assertEquals(42, pair.getLeftElement().intValue());\n+        assertEquals(\"bar\", pair.getRightElement());\n+    }\n+\n+    @Test\n+    public void testPairOf() throws Exception {\n+        MutablePair<Integer, String> pair = MutablePair.of(0, \"foo\");\n+        assertEquals(0, pair.getLeftElement().intValue());\n+        assertEquals(\"foo\", pair.getRightElement());\n+        MutablePair<Object, String> pair2 = MutablePair.of(null, \"bar\");\n+        assertNull(pair2.getLeftElement());\n+        assertEquals(\"bar\", pair2.getRightElement());\n+    }\n+\n+    @Test\n+    public void testEquals() throws Exception {\n+        assertEquals(MutablePair.of(null, \"foo\"), MutablePair.of(null, \"foo\"));\n+        assertFalse(MutablePair.of(\"foo\", 0).equals(MutablePair.of(\"foo\", null)));\n+        assertFalse(MutablePair.of(\"foo\", \"bar\").equals(MutablePair.of(\"xyz\", \"bar\")));\n+\n+        MutablePair<String, String> p = MutablePair.of(\"foo\", \"bar\");\n+        assertTrue(p.equals(p));\n+        assertFalse(p.equals(new Object()));\n+    }\n+\n+    @Test\n+    public void testHashCode() throws Exception {\n+        assertEquals(MutablePair.of(null, \"foo\").hashCode(), MutablePair.of(null, \"foo\").hashCode());\n+    }\n+\n+    @Test\n+    public void testToString() throws Exception {\n+        assertEquals(\"MutablePair(null,null)\", MutablePair.of(null, null).toString());\n+        assertEquals(\"MutablePair(null,two)\", MutablePair.of(null, \"two\").toString());\n+        assertEquals(\"MutablePair(one,null)\", MutablePair.of(\"one\", null).toString());\n+        assertEquals(\"MutablePair(one,two)\", MutablePair.of(\"one\", \"two\").toString());\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSerialization() throws Exception {\n+        MutablePair<Integer, String> origPair = MutablePair.of(0, \"foo\");\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(baos);\n+        out.writeObject(origPair);\n+        MutablePair<Integer, String> deserializedPair = (MutablePair<Integer, String>) new ObjectInputStream(\n+                new ByteArrayInputStream(baos.toByteArray())).readObject();\n+        assertEquals(origPair, deserializedPair);\n+        assertEquals(origPair.hashCode(), deserializedPair.hashCode());\n+    }\n+}\n--- a/src/test/java/org/apache/commons/lang3/PairTest.java\n+++ b/src/test/java/org/apache/commons/lang3/PairTest.java\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.assertNull;\n \n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n+import java.util.HashSet;\n \n import org.junit.Test;\n \n public class PairTest {\n \n     @Test\n-    public void testBasic() throws Exception {\n-        Pair<Integer, String> pair = new Pair<Integer, String>(0, \"foo\");\n-        assertEquals(0, pair.left.intValue());\n-        assertEquals(\"foo\", pair.right);\n-        Pair<Object, String> pair2 = new Pair<Object, String>(null, \"bar\");\n-        assertNull(pair2.left);\n-        assertEquals(\"bar\", pair2.right);\n+    public void testPairOf() throws Exception {\n+        Pair<Integer, String> pair = Pair.of(0, \"foo\");\n+        assertTrue(pair instanceof ImmutablePair<?, ?>);\n+        assertEquals(0, ((ImmutablePair<Integer, String>) pair).left.intValue());\n+        assertEquals(\"foo\", ((ImmutablePair<Integer, String>) pair).right);\n+        Pair<Object, String> pair2 = Pair.of(null, \"bar\");\n+        assertTrue(pair2 instanceof ImmutablePair<?, ?>);\n+        assertNull(((ImmutablePair<Object, String>) pair2).left);\n+        assertEquals(\"bar\", ((ImmutablePair<Object, String>) pair2).right);\n     }\n \n     @Test\n-    public void testPairOf() throws Exception {\n-        Pair<Integer, String> pair = Pair.of(0, \"foo\");\n-        assertEquals(0, pair.left.intValue());\n-        assertEquals(\"foo\", pair.right);\n-        Pair<Object, String> pair2 = Pair.of(null, \"bar\");\n-        assertNull(pair2.left);\n-        assertEquals(\"bar\", pair2.right);\n-    }\n+    public void testCompatibility() throws Exception {\n+        Pair<Integer, String> pair = ImmutablePair.of(0, \"foo\");\n+        Pair<Integer, String> pair2 = MutablePair.of(0, \"foo\");\n+        assertEquals(pair, pair2);\n+        assertEquals(pair.hashCode(), pair2.hashCode());\n+        HashSet<Pair<Integer, String>> set = new HashSet<Pair<Integer, String>>();\n+        set.add(pair);\n+        assertTrue(set.contains(pair2));\n \n-    @Test\n-    public void testEquals() throws Exception {\n-        assertEquals(Pair.of(null, \"foo\"), Pair.of(null, \"foo\"));\n-        assertFalse(Pair.of(\"foo\", 0).equals(Pair.of(\"foo\", null)));\n-        assertFalse(Pair.of(\"foo\", \"bar\").equals(Pair.of(\"xyz\", \"bar\")));\n-\n-        Pair p = Pair.of(\"foo\", \"bar\");\n-        assertTrue(p.equals(p));\n-        assertFalse(p.equals(new Object()));\n-    }\n-\n-    @Test\n-    public void testHashCode() throws Exception {\n-        assertEquals(Pair.of(null, \"foo\").hashCode(), Pair.of(null, \"foo\").hashCode());\n-    }\n-\n-    @Test\n-    public void testToString() throws Exception {\n-        assertEquals(\"(null,null)\", Pair.of(null, null).toString());\n-        assertEquals(\"(null,two)\", Pair.of(null, \"two\").toString());\n-        assertEquals(\"(one,null)\", Pair.of(\"one\", null).toString());\n-        assertEquals(\"(one,two)\", Pair.of(\"one\", \"two\").toString());\n-    }\n-\n-    @Test\n-    @SuppressWarnings(\"unchecked\")\n-    public void testSerialization() throws Exception {\n-        Pair<Integer, String> origPair = Pair.of(0, \"foo\");\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        ObjectOutputStream out = new ObjectOutputStream(baos);\n-        out.writeObject(origPair);\n-        Pair<Integer, String> deserializedPair = (Pair<Integer, String>) new ObjectInputStream(\n-                new ByteArrayInputStream(baos.toByteArray())).readObject();\n-        assertEquals(origPair, deserializedPair);\n-        assertEquals(origPair.hashCode(), deserializedPair.hashCode());\n+        pair2.setValue(\"bar\");\n+        assertFalse(pair.equals(pair2));\n+        assertFalse(pair.hashCode() == pair2.hashCode());\n     }\n }", "timestamp": 1299523629, "metainfo": ""}