{"sha": "87e6a42200f24347990d05eb147d599738f9ca4b", "log": "Adding Michael Wooten's event support utilities from LANG-580  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/event/AbstractEventSupport.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang3.event;\n+\n+import java.io.Serializable;\n+import java.util.EventListener;\n+import java.util.EventObject;\n+import java.util.Iterator;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.apache.commons.lang3.Validate;\n+\n+/**\n+ * <p>\n+ * The AbstractEventSupport class provides an abstract base class framework for\n+ * managing {@link EventListener} objects and for firing {@link EventObject}s to\n+ * those listeners. The class provides the ability to register a \"source\" object\n+ * that should be used as the source of the events, as well as the ability to \n+ * register and unregister listeners in a thread-safe manner. The class also \n+ * provides support for iterating over the registered listeners.\n+ * </p>\n+ * \n+ * <p>\n+ * Subclasses of the AbstractEventSupport class are designed to implement \n+ * methods for firing events. The implementations can make use of both the \n+ * iterable functionality and use the associated source object as the source \n+ * of the events.\n+ * </p>\n+ * \n+ * <p>\n+ * Example:\n+ * <code><pre>\n+ * public WindowSupport extends AbstractEventSupport<WindowListener> {\n+ *     \n+ *     public WindowSupport(Window source) {\n+ *         super(source);\n+ *     }\n+ *     \n+ *     public void fireWindowOpened(int windowId, int oldState, int newState) {\n+ *         WindowEvent windowEvent = \n+ *             new WindowEvent((Window) getSource(), windowId, oldState, newState);\n+ *         for (WindowListener listener : this) \n+ *         {\n+ *             listener.windowOpened(windowEvent);\n+ *         }\n+ *     }\n+ * }\n+ * </pre></code>\n+ * </p>\n+ * \n+ * @author <a href=\"mailto:mwooten.dev@gmail.com\">Michael Wooten</a>\n+ *\n+ * @param <L> the subclass of {@link EventListener} that this event support\n+ *        class can register.\n+ * \n+ * @since 3.0\n+ */\n+public abstract class AbstractEventSupport<L extends EventListener> \n+    implements EventSupport<L>, Iterable<L>, Serializable {\n+\n+    /**\n+     * The serialization unique version identifier.\n+     */\n+    private static final long serialVersionUID = 20100310L;\n+\n+    /**\n+     * The list used to hold the registered listeners. This list is \n+     * intentionally a thread-safe copy-on-write-array so that traversals over\n+     * the list of listeners will be atomic.\n+     */\n+    private final CopyOnWriteArrayList<L> listeners;\n+    \n+    /**\n+     * The object registered as the source of events fired to the listeners.\n+     */\n+    private final Object source;\n+    \n+    /**\n+     * Constructs a new AbstractEventSupport object and associates it with the\n+     * object that will be used as the source of all events sent to the \n+     * listeners.\n+     * \n+     * @param source the object that will be used as the source of all events\n+     *        posted to the listeners.\n+     *        \n+     * @throws NullPointerException if <code>source</code> is \n+     *         <code>null</code>.\n+     */\n+    protected AbstractEventSupport(Object source) {\n+        Validate.notNull(source, \"source cannot be null\");\n+        this.source = source;\n+        this.listeners = new CopyOnWriteArrayList<L>();\n+    }\n+    \n+    /**\n+     * Registers a listener to receive events posted the by the supported class.\n+     * \n+     * @param listener the listener to register for posted events. Values of \n+     *        <code>null</code> will be ignored.\n+     */\n+    public void addListener(L listener) {\n+        if (listener != null)\n+        {\n+            this.listeners.add(listener);\n+        }\n+    }\n+    \n+    /**\n+     * Unregisters a listener from receiving events posted by the supported \n+     * class.\n+     * \n+     * @param listener the listener to stop posting events to. Values of \n+     *        <code>null</code> will be ignored.\n+     */\n+    public void removeListener(L listener) {\n+        if (listener != null)\n+        {\n+            this.listeners.remove(listener);\n+        }\n+    }\n+    \n+    /**\n+     * Returns a reference to the object registered as the source of events \n+     * broadcast to the listeners.\n+     * \n+     * @return the object that was initially registered to be the source of all\n+     *         events sent to the listeners.\n+     */\n+    public Object getSource() {\n+        return this.source;\n+    }\n+    \n+    /**\n+     * Returns an iterator over the current list of listeners. This iterator is\n+     * immutable and does not support {@link Iterator#remove()} operations.\n+     * \n+     * @return an iterator to iterate over the currently registered listeners.\n+     */\n+    public Iterator<L> iterator() {\n+        return this.listeners.iterator();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/event/EventSupport.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang3.event;\n+\n+import java.util.EventListener;\n+\n+/**\n+ * <p>\n+ * The EventSupport interface identifies as class as being able to register\n+ * listeners for events. \n+ * </p>\n+ * \n+ * @author <a href=\"mailto:mwooten.dev@gmail.com\">Michael Wooten</a>\n+ *\n+ * @param <L> the subclass of {@link EventListener} that this event support\n+ *        class can register.\n+ *        \n+ * @since 3.0\n+ */\n+public interface EventSupport<L extends EventListener> {\n+\n+    /**\n+     * Registers a listener to receive events posted the by the supported class.\n+     * \n+     * @param listener the listener to register for posted events. Values of \n+     *        <code>null</code> will be ignored.\n+     */\n+    public void addListener(L listener);\n+    \n+    /**\n+     * Unregisters a listener from receiving events posted by the supported \n+     * class.\n+     * \n+     * @param listener the listener to stop posting events to. Values of \n+     *        <code>null</code> will be ignored.\n+     */\n+    public void removeListener(L listener);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/event/ReflectiveEventSupport.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang3.event;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.EventListener;\n+import java.util.EventObject;\n+\n+import org.apache.commons.lang3.Validate;\n+import org.apache.commons.lang3.reflect.MethodUtils;\n+\n+/**\n+ * <p>\n+ * The ReflectiveEventSupport class provides a means of posting \n+ * {@link EventObject}s to registered listeners. The class uses reflection to\n+ * call specified methods on the listeners, either by {@link Method} or method \n+ * name.\n+ * </p>\n+ * \n+ * <p>\n+ * <em>NOTE: The methods on the listeners must be accessible in order to be\n+ * called.</em>\n+ * </p>\n+ * \n+ * <p>\n+ * Example:\n+ * <code><pre>\n+ * ReflectiveEventSupport<ChangeListener> reflectiveEventSupport = \n+ *    new ReflectiveEventSupport<ChangeListener>(this);\n+ * \n+ * ...\n+ *    \n+ * reflectiveEventSupport.addListener(listener);\n+ * \n+ * ...\n+ * \n+ * reflectiveEventSupport.fireEvent(\"stateChanged\",\n+ *     new ChangeEvent(reflectiveEventSupport.getSource());\n+ * </pre></code>\n+ * </p>\n+ * \n+ * @author <a href=\"mailto:mwooten.dev@gmail.com\">Michael Wooten</a>\n+ *\n+ * @param <L> the subclass of {@link EventListener} that this event support\n+ *        class can register.\n+ * \n+ * @since 3.0\n+ */\n+public class ReflectiveEventSupport<L extends EventListener> \n+    extends AbstractEventSupport<L> {\n+\n+    /**\n+     * The serialization unique version identifier.\n+     */\n+    private static final long serialVersionUID = 20100310L;\n+    \n+    /**\n+     * Constructs a new ReflectiveEventSupport object and associates it with the\n+     * object that can be used as the source of all events sent to the \n+     * listeners.\n+     * \n+     * @param source the object that can be used as the source of all events\n+     *        posted to the listeners.\n+     *        \n+     * @throws NullPointerException if <code>source</code> is \n+     *         <code>null</code>.\n+     */\n+    public ReflectiveEventSupport(Object source) {\n+        super(source);\n+    }\n+\n+    /**\n+     * Fires the provided event object to the named method specified on each of \n+     * the listeners registered with this event support class.\n+     * \n+     * @param <E>\n+     *            the {@link EventObject} type that will be posted to the\n+     *            listeners.\n+     * \n+     * @param methodName\n+     *            the name of the method that should be called on each of the\n+     *            listeners.\n+     * @param eventObject\n+     *            the event object that will be passed to the listener's method.\n+     * \n+     * @throws NullPointerException \n+     *             if <code>methodName</code> is <code>null</code>.\n+     * @throws NoSuchMethodException\n+     *             if there is no such accessible method\n+     * @throws InvocationTargetException\n+     *             wraps an exception thrown by the method invoked\n+     * @throws IllegalAccessException\n+     *             if the requested method is not accessible via reflection\n+     */\n+    public <E extends EventObject> void fireEvent(String methodName, E eventObject) \n+        throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        Validate.notNull(methodName, \"methodName cannot be null\");\n+        for (L listener : this) {\n+            MethodUtils.invokeMethod(listener, methodName, eventObject);\n+        }\n+    }\n+    \n+    /**\n+     * Fires the provided event object to the method specified on each of the\n+     * listeners registered with this event support class.\n+     * \n+     * @param <E>\n+     *            the {@link EventObject} type that will be posted to the\n+     *            listeners.\n+     * @param method\n+     *            the method that should be called on each of the listeners.\n+     * @param eventObject\n+     *            the event object that will be passed to the listener's method.\n+     * \n+     * @throws NullPointerException \n+     *             if <code>method</code> is <code>null</code>.\n+     * @throws NoSuchMethodException \n+     *            if there is no such accessible method\n+     * @throws InvocationTargetException \n+     *            wraps an exception thrown by the method invoked\n+     * @throws IllegalAccessException \n+     *            if the requested method is not accessible via reflection\n+     */\n+    public <E extends EventObject> void fireEvent(Method method, E eventObject) \n+        throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        Validate.notNull(method, \"method cannot be null\");\n+        Method accessibleMethod = MethodUtils.getAccessibleMethod(method);\n+        for (L listener : this) {\n+            accessibleMethod.invoke(listener, eventObject);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/event/AbstractEventSupportTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang3.event;\n+\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * <p>\n+ * The {@link AbstractEventSupportTestCase} class provides test cases for \n+ * testing the {@link AbstractEventSupport} class.\n+ * </p>\n+ * \n+ * @author <a href=\"mailto:mwooten.dev@gmail.com\">Michael Wooten</a>\n+ *\n+ * @since 3.0\n+ */\n+public class AbstractEventSupportTest extends TestCase {\n+\n+    /**\n+     * The event support mock object that will be used for testing.\n+     */\n+    private AbstractEventSupport<ChangeListener> eventSupport;\n+    \n+    /**\n+     * Creates the implementation of {@link AbstractEventSupport} that will be\n+     * used for testing.\n+     */\n+    public void setUp() throws Exception {\n+        eventSupport = new AbstractEventSupportMock(this);\n+    }\n+    \n+    /**\n+     * Tests that the \n+     * {@link AbstractEventSupport#addListener(java.util.EventListener)}\n+     * properly registers a listener.\n+     */\n+    public void testAddListener() {\n+        ChangeListener changeListener = new ChangeListenerMock();\n+        eventSupport.addListener(changeListener);\n+        assertTrue(eventSupport.iterator().hasNext());\n+        assertEquals(changeListener, eventSupport.iterator().next());\n+    }\n+    \n+    /**\n+     * Tests that the \n+     * {@link AbstractEventSupport#addListener(java.util.EventListener)}\n+     * method performs no operation when provided the value of \n+     * <code>null</code>.\n+     */\n+    public void testAddNullListener() {\n+        eventSupport.addListener(null);\n+        assertFalse(eventSupport.iterator().hasNext());\n+    }\n+\n+    /**\n+     * Tests that the \n+     * {@link AbstractEventSupport#removeListener(java.util.EventListener)}\n+     * properly removes a previously registered listener.\n+     */\n+    public void testRemoveListener() {\n+        ChangeListener changeListener = new ChangeListenerMock();\n+        eventSupport.addListener(changeListener);\n+        assertTrue(eventSupport.iterator().hasNext());\n+        eventSupport.removeListener(changeListener);\n+        assertFalse(eventSupport.iterator().hasNext());\n+    }\n+    \n+    /**\n+     * Tests that the \n+     * {@link AbstractEventSupport#removeListener(java.util.EventListener)}\n+     * method performs no operation when provided the value of \n+     * <code>null</code>.\n+     */\n+    public void testRemoveNullListener() {\n+        ChangeListener changeListener = new ChangeListenerMock();\n+        eventSupport.addListener(changeListener);\n+        assertTrue(eventSupport.iterator().hasNext());\n+        eventSupport.removeListener(null);\n+        assertTrue(eventSupport.iterator().hasNext());\n+    }\n+\n+    /**\n+     * Tests that the source registered with the event support is the one \n+     * provided by {@link AbstractEventSupport#getSource()}.\n+     */\n+    public void testGetSource() {\n+        assertEquals(this, eventSupport.getSource());\n+    }\n+\n+    /**\n+     * Tests that the event support object returns an iterator of the registered\n+     * listeners.\n+     */\n+    public void testIterator() {\n+        ChangeListener changeListener = new ChangeListenerMock();\n+        eventSupport.addListener(changeListener);\n+        assertNotNull(eventSupport.iterator());\n+        assertTrue(eventSupport.iterator().hasNext());\n+    }\n+    \n+    /**\n+     * <p>\n+     * The AbstractEventSupportMock class provides a mock version of the\n+     * {@link AbstractEventSupport} class that can be used for testing since\n+     * AbstractEventSupport is an abstract class.\n+     * </p>\n+     */\n+    @SuppressWarnings(\"serial\")\n+    private class AbstractEventSupportMock extends AbstractEventSupport<ChangeListener> {\n+\n+        /**\n+         * Constructs a new AbstractEventSupportMock and associates it with the\n+         * source of the events.\n+         * \n+         * @param source the source of the events.\n+         */\n+        public AbstractEventSupportMock(Object source) {\n+            super(source);\n+        }\n+    }\n+    \n+    /**\n+     * <p>\n+     * The ChangeListenerMock class provides a mock version of the\n+     * {@link ChangeListener} interface that can be used for testing.\n+     * </p>\n+     */\n+    private class ChangeListenerMock implements ChangeListener {\n+        public void stateChanged(ChangeEvent changeEvent) {\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/event/ReflectiveEventSupportTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang3.event;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * <p>\n+ * The ReflectiveEventSupportTest class provides a set of unit tests for the \n+ * {@link ReflectiveEventSupport} class.\n+ * </p>\n+ * \n+ * @author <a href=\"mailto:mwooten.dev@gmail.com\">Michael Wooten</a>\n+ * \n+ * @since 3.0\n+ */\n+public class ReflectiveEventSupportTest extends TestCase {\n+\n+    /**\n+     * The event support mock object that will be used for testing.\n+     */\n+    private ReflectiveEventSupport<ChangeListener> eventSupport;\n+    \n+    /**\n+     * The first listener that will be registered for change events.\n+     */\n+    private ChangeDetectedChangeListener firstChangeListener;\n+    \n+    /**\n+     * The second listener that will be registered for change events.\n+     */\n+    private ChangeDetectedChangeListener secondChangeListener;\n+    \n+    /**\n+     * Creates the {@link ReflectiveEventSupport} instance under test and \n+     * registers a couple of {@link ChangeDetectedChangeListener}s with the\n+     * event support.\n+     */\n+    protected void setUp() throws Exception {\n+        eventSupport = new ReflectiveEventSupport<ChangeListener>(this);\n+        firstChangeListener = new ChangeDetectedChangeListener();\n+        secondChangeListener = new ChangeDetectedChangeListener();\n+        eventSupport.addListener(firstChangeListener);\n+        eventSupport.addListener(secondChangeListener);\n+    }\n+\n+    /**\n+     * Tests the {@link ReflectiveEventSupport#ReflectiveEventSupport(Object)}\n+     * constructor.\n+     */\n+    public void testReflectiveEventSupport() {\n+        try \n+        {\n+            new ReflectiveEventSupport<ChangeListener>(null);\n+            fail(\"ReflectiveEventSupport(null) did not throw an IllegalArgumentException\");\n+        }\n+        catch (NullPointerException iae)\n+        {\n+            // Success, the exception was properly thrown\n+        }\n+    }\n+\n+    /**\n+     * Tests the \n+     * {@link ReflectiveEventSupport#fireEvent(String, java.util.EventObject)}\n+     * method to ensure that events will be propagated to accessible methods\n+     * with the provided name.\n+     * \n+     * @throws NoSuchMethodException\n+     * @throws IllegalAccessException\n+     * @throws InvocationTargetException\n+     */\n+    public void testFireEventByMethodName() throws NoSuchMethodException, \n+        IllegalAccessException, InvocationTargetException {\n+        ChangeEvent changeEvent = new ChangeEvent(eventSupport.getSource());\n+        eventSupport.fireEvent(\"stateChanged\", changeEvent);\n+        assertTrue(\"ChangeEvent not propogated to first change lisetener\", \n+                firstChangeListener.isChanged());\n+        assertTrue(\"ChangeEvent not propogated to second change lisetener\", \n+                secondChangeListener.isChanged());\n+    }\n+    \n+    /**\n+     * Tests the \n+     * {@link ReflectiveEventSupport#fireEvent(String, java.util.EventObject)}\n+     * method to ensure that a {@link NoSuchMethodException} is thrown if the\n+     * method is not accessible.\n+     * \n+     * @throws IllegalAccessException\n+     * @throws InvocationTargetException\n+     */\n+    public void testFireEventByMethodNameToInaccessibleMethods() \n+        throws IllegalAccessException, InvocationTargetException {\n+        \n+        ChangeEvent changeEvent = new ChangeEvent(eventSupport.getSource());\n+        \n+        try\n+        {\n+            eventSupport.fireEvent(\"privateMethod\", changeEvent);\n+            fail(\"eventSupport.fireEvent() did not throw an exception \" +\n+                \"for a private method\");\n+        } \n+        catch (NoSuchMethodException nsme)\n+        {\n+            // Success\n+        }\n+        \n+        try\n+        {\n+            eventSupport.fireEvent(\"protectedMethod\", changeEvent);\n+            fail(\"eventSupport.fireEvent() did not throw an exception \" +\n+                \"for a protected method\");\n+        } \n+        catch (NoSuchMethodException nsme)\n+        {\n+            // Success\n+        }\n+        \n+        try\n+        {\n+            eventSupport.fireEvent(\"defaultMethod\", changeEvent);\n+            fail(\"eventSupport.fireEvent() did not throw an exception \" +\n+                \"for a default method\");\n+        } \n+        catch (NoSuchMethodException nsme)\n+        {\n+            // Success\n+        }\n+    }\n+    \n+    /**\n+     * Tests the \n+     * {@link ReflectiveEventSupport#fireEvent(String, java.util.EventObject)}\n+     * method to ensure that a {@link NullPointerException} is thrown if a \n+     * <code>null</code> value is provided for the method name.\n+     * \n+     * @throws NoSuchMethodException\n+     * @throws IllegalAccessException\n+     * @throws InvocationTargetException\n+     */\n+    public void testFireEventNullMethodName() throws NoSuchMethodException, \n+        IllegalAccessException, \n+        InvocationTargetException {\n+        try\n+        {\n+            ChangeEvent changeEvent = new ChangeEvent(eventSupport.getSource());\n+            eventSupport.fireEvent((String) null, changeEvent);\n+            fail(\"eventSupport.fireEvent() did not throw an exception for a \" +\n+                \"null method name.\");\n+        }\n+        catch (NullPointerException npe)\n+        {\n+            // Success\n+        }\n+    }\n+\n+    /**\n+     * Tests the \n+     * {@link ReflectiveEventSupport#fireEvent(Method, java.util.EventObject)}\n+     * method to ensure that events will be propagated to the accessible method\n+     * provided.\n+     * \n+     * @throws NoSuchMethodException\n+     * @throws IllegalAccessException\n+     * @throws InvocationTargetException\n+     */\n+    public void testFireEventByMethod() throws NoSuchMethodException, \n+        IllegalAccessException, InvocationTargetException {\n+        ChangeEvent changeEvent = new ChangeEvent(eventSupport.getSource());\n+        Method stateChangedMethod = \n+            ChangeListener.class.getMethod(\"stateChanged\", ChangeEvent.class);\n+        eventSupport.fireEvent(stateChangedMethod, changeEvent);\n+        assertTrue(\"ChangeEvent not propogated to first change lisetener\", \n+                firstChangeListener.isChanged());\n+        assertTrue(\"ChangeEvent not propogated to second change lisetener\", \n+                secondChangeListener.isChanged());\n+    }\n+    \n+    /**\n+     * Tests the \n+     * {@link ReflectiveEventSupport#fireEvent(Method, java.util.EventObject)}\n+     * method to ensure that a {@link NoSuchMethodException} is thrown if the\n+     * method is not accessible.\n+     * \n+     * @throws IllegalAccessException\n+     * @throws InvocationTargetException\n+     */\n+    public void testFireEventByMethodToInaccessibleMethods() \n+        throws IllegalAccessException, InvocationTargetException {\n+        \n+        ChangeEvent changeEvent = new ChangeEvent(eventSupport.getSource());\n+        \n+        try\n+        {\n+            Method privateMethod = \n+                ChangeListener.class.getMethod(\"privateMethod\", \n+                    ChangeEvent.class);\n+            eventSupport.fireEvent(privateMethod, changeEvent);\n+            fail(\"eventSupport.fireEvent() did not throw an exception \" +\n+                \"for a private method\");\n+        } \n+        catch (NoSuchMethodException nsme)\n+        {\n+            // Success\n+        }\n+        \n+        try\n+        {\n+            Method protectedMethod = \n+                ChangeListener.class.getMethod(\"protectedMethod\", \n+                    ChangeEvent.class);\n+            eventSupport.fireEvent(protectedMethod, changeEvent);\n+            fail(\"eventSupport.fireEvent() did not throw an exception \" +\n+                \"for a protected method\");\n+        } \n+        catch (NoSuchMethodException nsme)\n+        {\n+            // Success\n+        }\n+        \n+        try\n+        {\n+            Method defaultMethod = \n+                ChangeListener.class.getMethod(\"defaultMethod\", \n+                    ChangeEvent.class);\n+            eventSupport.fireEvent(defaultMethod, changeEvent);\n+            fail(\"eventSupport.fireEvent() did not throw an exception \" +\n+                \"for a default method\");\n+        } \n+        catch (NoSuchMethodException nsme)\n+        {\n+            // Success\n+        }\n+    }\n+\n+    /**\n+     * Tests the \n+     * {@link ReflectiveEventSupport#fireEvent(Method, java.util.EventObject)}\n+     * method to ensure that a {@link NullPointerException} is thrown if a \n+     * <code>null</code> value is provided for the method.\n+     * \n+     * @throws NoSuchMethodException\n+     * @throws IllegalAccessException\n+     * @throws InvocationTargetException\n+     */\n+    public void testFireEventNullMethod() throws NoSuchMethodException, \n+        IllegalAccessException, InvocationTargetException {\n+        try\n+        {\n+            ChangeEvent changeEvent = new ChangeEvent(eventSupport.getSource());\n+            eventSupport.fireEvent((Method) null, changeEvent);\n+            fail(\"eventSupport.fireEvent() did not throw an exception for a \" +\n+                \"null method.\");\n+        }\n+        catch (NullPointerException npe)\n+        {\n+            // Success\n+        }\n+    }\n+    \n+    /**\n+     * Tests the {@link ReflectiveEventSupport#getSource()} method to ensure it\n+     * returns the source object it was originally provided.\n+     */\n+    public void testGetSource() {\n+        assertEquals(this, eventSupport.getSource());\n+    }\n+\n+    /**\n+     * <p>\n+     * The ChangeDetectedChangeListener class provides a version of the\n+     * {@link ChangeListener} interface that detects when the listener has \n+     * been called. The class provides an {@link #isChanged()} method that\n+     * will indicate whether or not the listener has been called.\n+     * </p>\n+     */\n+    public class ChangeDetectedChangeListener implements ChangeListener {\n+        \n+        /**\n+         * Represents whether or not the listener has detected a change.\n+         */\n+        private boolean changed = false;\n+        \n+        /**\n+         * Called whenever a change is detected.\n+         * \n+         * @param changeEvent the change event indicating a state change.\n+         */\n+        public void stateChanged(ChangeEvent changeEvent) {\n+            this.changed = true;\n+        }\n+        \n+        /**\n+         * Returns whether or not the listener has detected a change event.\n+         * \n+         * @return <code>true</code> if the listener has detected a change\n+         *         event, <code>false</code> otherwise.\n+         */\n+        public boolean isChanged() {\n+            return this.changed;\n+        }\n+        \n+        /**\n+         * A default (package private) method used to test \n+         * ReflectiveEventSupport calls to inaccessible methods.\n+         * \n+         * @param changeEvent not used.\n+         */\n+        void defaultMethod(ChangeEvent changeEvent) {\n+            this.changed = true;\n+        }\n+        \n+        /**\n+         * A protected method used to test ReflectiveEventSupport calls to \n+         * inaccessible methods.\n+         * \n+         * @param changeEvent not used.\n+         */\n+        protected void protectedMethod(ChangeEvent changeEvent) {\n+            this.changed = true;\n+        }\n+        \n+        /**\n+         * A private method used to test ReflectiveEventSupport calls to \n+         * inaccessible methods.\n+         * \n+         * @param changeEvent not used.\n+         */\n+        @SuppressWarnings(\"unused\")\n+        private void privateMethod(ChangeEvent changeEvent) {\n+            this.changed = true;\n+        }\n+    }\n+}", "timestamp": 1279433151, "metainfo": ""}