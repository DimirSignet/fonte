{"sha": "8de118be851cf8d52c2928ef66badeebae3e7a65", "log": "Refactor Range with lots of new methods  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/Range.java\n+++ b/src/main/java/org/apache/commons/lang3/Range.java\n \n import java.io.Serializable;\n import java.util.Comparator;\n+import java.util.Formattable;\n \n /**\n- * <p>{@code Range} represents an immutable range of comparables of the same type.</p>\n- * <p>The objects need to either be implementations of {@code java.lang.Comparable}\n- * or you need to supply a {@code java.util.Comparator}. </p>\n+ * <p>An immutable range of objects from a minimum to maximum point inclusive.</p>\n+ * \n+ * <p>The objects need to either be implementations of {@code Comparable}\n+ * or you need to supply a {@code Comparator}. </p>\n  *\n- * <p>#ThreadSafe# if the comparables are thread-safe</p>\n+ * <p>#ThreadSafe# if the objects and comparator are thread-safe</p>\n+ * \n  * @since 3.0\n  * @version $Id$\n  */\n public final class Range<T> implements Serializable {\n \n     /**\n-     * Required for serialization support.\n-     *\n+     * Serialization version.\n      * @see java.io.Serializable\n      */\n     private static final long serialVersionUID = 1L;\n      * The ordering scheme used in this range.\n      */\n     private final Comparator<T> comparator;\n-\n     /**\n      * The minimum value in this range (inclusive).\n      */\n     private final T minimum;\n-\n     /**\n      * The maximum value in this range (inclusive).\n      */\n     private final T maximum;\n-\n     /**\n      * Cached output hashCode (class is immutable).\n      */\n-    private transient int hashCode = 0;\n-\n+    private transient int hashCode;\n     /**\n      * Cached output toString (class is immutable).\n      */\n-    private transient String toString = null;\n-\n-    /**\n-     * <p>Constructs a new {@code Range} using the specified\n-     * element as both the minimum and maximum in this range.</p>\n-     * <p>The range uses the natural ordering of the elements to\n-     * determine where values lie in the range.</p>\n-     *\n-     * @param <T> the type of this {@code Range}\n+    private transient String toString;\n+\n+    /**\n+     * <p>Obtains a range using the specified element as both the minimum\n+     * and maximum in this range.</p>\n+     * \n+     * <p>The range uses the natural ordering of the elements to determine where\n+     * values lie in the range.</p>\n+     *\n+     * @param <T> the type of the elements in this range\n+     * @param element  the value to use for this range, not null\n+     * @return the range object, not null\n+     * @throws IllegalArgumentException if the element is null\n+     * @throws ClassCastException if the element is not {@code Comparable}\n+     */\n+    public static <T extends Comparable<T>> Range<T> is(T element) {\n+        return between(element, element, null);\n+    }\n+\n+    /**\n+     * <p>Obtains a range using the specified element as both the minimum\n+     * and maximum in this range.</p>\n+     * \n+     * <p>The range uses the specified {@code Comparator} to determine where\n+     * values lie in the range.</p>\n+     *\n+     * @param <T> the type of the elements in this range\n      * @param element  the value to use for this range, must not be {@code null}\n-     * @return the new range object\n-     * @throws IllegalArgumentException if the value is {@code null}\n-     * @throws ClassCastException if the value is not Comparable\n-     */\n-    public static <T extends Comparable<T>> Range<T> is(T element) {\n-        return new Range<T>(element, element, ComparableComparator.<T>getInstance());\n-    }\n-\n-    /**\n-     * <p>Constructs a new {@code Range} with the specified\n-     * minimum and maximum values (both inclusive).</p>\n-     * <p>The range uses the natural ordering of the elements to\n-     * determine where values lie in the range.</p>\n-     *\n-     * <p>The arguments may be passed in the order (min,max) or (max,min). The\n-     * getMinimum and getMaximum methods will return the correct values.</p>\n-     *\n-     * @param <T> the type of this {@code Range}\n-     * @param element1  first value that defines the edge of the range, inclusive\n-     * @param element2  second value that defines the edge of the range, inclusive\n-     * @return the new range object\n-     * @throws IllegalArgumentException if either value is {@code null}\n-     * @throws ClassCastException if either value is not Comparable\n-     */\n-    public static <T extends Comparable<T>> Range<T> between(T element1, T element2) {\n-        return new Range<T>( element1, element2, ComparableComparator.<T>getInstance());\n-    }\n-\n-    /**\n-     * <p>Constructs a new {@code Range} using the specified\n-     * element as both the minimum and maximum in this range.</p>\n-     * <p>The range uses the passed in {@code Comparator} to\n-     * determine where values lie in the range.</p>\n-     *\n-     * @param <T> the type of this {@code Range}\n-     * @param element  the value to use for this range, must not be {@code null}\n-     * @param c comparator to be used\n-     * @return the new range object\n-     * @throws IllegalArgumentException if the value is {@code null}\n-     */\n-    public static <T> Range<T> is(T element, Comparator<T> c) {\n-        return new Range<T>(element, element, c);\n-    }\n-\n-    /**\n-     * <p>Constructs a new {@code Range} with the specified\n-     * minimum and maximum values (both inclusive).</p>\n-     * <p>The range uses the passed in {@code Comparator} to\n-     * determine where values lie in the range.</p>\n-     *\n-     * <p>The arguments may be passed in the order (min,max) or (max,min). The\n-     * getMinimum and getMaximum methods will return the correct values.</p>\n-     *\n-     * @param <T> the type of this {@code Range}\n-     * @param element1  first value that defines the edge of the range, inclusive\n-     * @param element2  second value that defines the edge of the range, inclusive\n-     * @param c comparator to be used\n-     * @return the new range object\n-     * @throws IllegalArgumentException if either value is {@code null}\n-     */\n-    public static <T> Range<T> between(T element1, T element2, Comparator<T> c) {\n-        return new Range<T>(element1, element2, c);\n-    }\n-\n-    /**\n-     * Creates a new instance of {@code Range}.\n-     *\n-     * @param element1 the first element\n-     * @param element2 the second element\n-     * @param c the comparator to be used\n-     */\n-    private Range(T element1, T element2, Comparator<T> c) {\n-        if(element1 == null || element2 == null) {\n+     * @param comparator  the comparator to be used, null for natural ordering\n+     * @return the range object, not null\n+     * @throws IllegalArgumentException if the element is null\n+     * @throws ClassCastException if using natural ordering and the elements are not {@code Comparable}\n+     */\n+    public static <T> Range<T> is(T element, Comparator<T> comparator) {\n+        return between(element, element, comparator);\n+    }\n+\n+    /**\n+     * <p>Obtains a range with the specified minimum and maximum values (both inclusive).</p>\n+     * \n+     * <p>The range uses the natural ordering of the elements to determine where\n+     * values lie in the range.</p>\n+     *\n+     * <p>The arguments may be passed in the order (min,max) or (max,min).\n+     * The getMinimum and getMaximum methods will return the correct values.</p>\n+     *\n+     * @param <T> the type of the elements in this range\n+     * @param fromInclusive  the first value that defines the edge of the range, inclusive\n+     * @param toInclusive  the second value that defines the edge of the range, inclusive\n+     * @return the range object, not null\n+     * @throws IllegalArgumentException if either element is null\n+     * @throws ClassCastException if the elements are not {@code Comparable}\n+     */\n+    public static <T extends Comparable<T>> Range<T> between(T fromInclusive, T toInclusive) {\n+        return between(fromInclusive, toInclusive, null);\n+    }\n+\n+    /**\n+     * <p>Obtains a range with the specified minimum and maximum values (both inclusive).</p>\n+     * \n+     * <p>The range uses the specified {@code Comparator} to determine where\n+     * values lie in the range.</p>\n+     *\n+     * <p>The arguments may be passed in the order (min,max) or (max,min).\n+     * The getMinimum and getMaximum methods will return the correct values.</p>\n+     *\n+     * @param <T> the type of the elements in this range\n+     * @param fromInclusive  the first value that defines the edge of the range, inclusive\n+     * @param toInclusive  the second value that defines the edge of the range, inclusive\n+     * @param comparator  the comparator to be used, null for natural ordering\n+     * @return the range object, not null\n+     * @throws IllegalArgumentException if either element is null\n+     * @throws ClassCastException if using natural ordering and the elements are not {@code Comparable}\n+     */\n+    public static <T> Range<T> between(T fromInclusive, T toInclusive, Comparator<T> comparator) {\n+        return new Range<T>(fromInclusive, toInclusive, comparator);\n+    }\n+\n+    /**\n+     * Creates an instance.\n+     *\n+     * @param element1  the first element, not null\n+     * @param element2  the second element, not null\n+     * @param comparator  the comparator to be used, null for natural ordering\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Range(T element1, T element2, Comparator<T> comparator) {\n+        if (element1 == null || element2 == null) {\n             throw new IllegalArgumentException(\"Elements in a range must not be null: element1=\" +\n                                                element1 + \", element2=\" + element2);\n         }\n-\n-        if(c == null) {\n-            throw new IllegalArgumentException(\"Comparator must not be null\");\n-        }\n-\n-        if(c.compare(element1, element2) < 1) {\n+        if (comparator == null) {\n+            comparator = ComparableComparator.INSTANCE;\n+        }\n+        if (comparator.compare(element1, element2) < 1) {\n             this.minimum = element1;\n             this.maximum = element2;\n         } else {\n             this.minimum = element2;\n             this.maximum = element1;\n         }\n-        this.comparator = c;\n+        this.comparator = comparator;\n     }\n \n     // Accessors\n     /**\n      * <p>Gets the minimum value in this range.</p>\n      *\n-     * @return the minimum value in this range\n+     * @return the minimum value in this range, not null\n      */\n     public T getMinimum() {\n-        return this.minimum;\n+        return minimum;\n     }\n \n     /**\n      * <p>Gets the maximum value in this range.</p>\n      *\n-     * @return the maximum value in this range\n+     * @return the maximum value in this range, not null\n      */\n     public T getMaximum() {\n-        return this.maximum;\n-    }\n-\n-    /**\n-     * <p>Gets the comparator being used to determine if objects are within the range. </p>\n-     *\n-     * @return the comparator being used\n+        return maximum;\n+    }\n+\n+    /**\n+     * <p>Gets the comparator being used to determine if objects are within the range.</p>\n+     * \n+     * <p>Natural ordering uses an internal comparator implementation, thus this\n+     * method never returns null. See {@link #isNaturalOrdering()}.</p>\n+     *\n+     * @return the comparator being used, not null\n      */\n     public Comparator<T> getComparator() {\n-        return this.comparator;\n-    }\n-\n-    /**\n-     * <p>Whether or not the Range is using the default natural comparison method\n-     * to compare elements. </p>\n-     *\n-     * @return whether or not the default Comparator is in use\n-     */\n-    public boolean isDefaultNaturalOrdering() {\n-        return this.comparator == ComparableComparator.INSTANCE;\n-    }\n-\n-    // Include tests\n+        return comparator;\n+    }\n+\n+    /**\n+     * <p>Whether or not the Range is using the natural ordering of the elements.</p>\n+     * \n+     * <p>Natural ordering uses an internal comparator implementation, thus this\n+     * method is the only way to check if a null comparator was specified.</p>\n+     *\n+     * @return true if using natural ordering\n+     */\n+    public boolean isNaturalOrdering() {\n+        return comparator == ComparableComparator.INSTANCE;\n+    }\n+\n+    // Element tests\n     //--------------------------------------------------------------------\n \n     /**\n-     * <p>Tests whether the specified element occurs within this range.</p>\n-     *\n-     * <p>{@code null} is handled and returns {@code false}.</p>\n-     *\n-     * @param element  the element to test, may be {@code null}\n-     * @return {@code true} if the specified element occurs within this range\n+     * <p>Checks whether the specified element occurs within this range.</p>\n+     *\n+     * @param element  the element to check for, null returns false\n+     * @return true if the specified element occurs within this range\n      */\n     public boolean contains(T element) {\n-        if(element == null) {\n-            return false;\n-        }\n-        return (comparator.compare(element, this.minimum) > -1) && (comparator.compare(element, this.maximum) < 1);\n-    }\n-\n-    /**\n-     * <p>Tests whether the specified element occurs before this range.</p>\n-     *\n-     * <p>{@code null} is handled and returns {@code false}.</p>\n-     *\n-     * @param element  the element to test, may be {@code null}\n-     * @return {@code true} if the specified element occurs before this range\n-     */\n-    public boolean elementBefore(T element) {\n-        if (element == null) {\n-            return false;\n-        }\n-\n-        return this.comparator.compare(element, this.minimum) < 0;\n-    }\n-\n-    /**\n-     * <p>Tests whether the specified element occurs after this range.</p>\n-     *\n-     * <p>{@code null} is handled and returns {@code false}.</p>\n-     *\n-     * @param element  the element to test, may be {@code null}\n-     * @return {@code true} if the specified element occurs after this range\n-     */\n-    public boolean elementAfter(T element) {\n-        if (element == null) {\n-            return false;\n-        }\n-\n-        return this.comparator.compare(element, this.maximum) > 0;\n-    }\n-\n-    /**\n-     * <p>Tests where the specified element occurs relative to this range.</p>\n+        if (element == null) {\n+            return false;\n+        }\n+        return (comparator.compare(element, minimum) > -1) && (comparator.compare(element, maximum) < 1);\n+    }\n+\n+    /**\n+     * <p>Checks whether this range is after the specified element.</p>\n+     *\n+     * @param element  the element to check for, null returns false\n+     * @return true if this range is entirely after the specified element\n+     */\n+    public boolean isAfter(T element) {\n+        if (element == null) {\n+            return false;\n+        }\n+        return comparator.compare(element, minimum) < 0;\n+    }\n+\n+    /**\n+     * <p>Checks whether this range starts with the specified element.</p>\n+     *\n+     * @param element  the element to check for, null returns false\n+     * @return true if the specified element occurs within this range\n+     */\n+    public boolean isStartedBy(T element) {\n+        if (element == null) {\n+            return false;\n+        }\n+        return comparator.compare(element, minimum) == 0;\n+    }\n+\n+    /**\n+     * <p>Checks whether this range starts with the specified element.</p>\n+     *\n+     * @param element  the element to check for, null returns false\n+     * @return true if the specified element occurs within this range\n+     */\n+    public boolean isEndedBy(T element) {\n+        if (element == null) {\n+            return false;\n+        }\n+        return comparator.compare(element, maximum) == 0;\n+    }\n+\n+    /**\n+     * <p>Checks whether this range is before the specified element.</p>\n+     *\n+     * @param element  the element to check for, null returns false\n+     * @return true if this range is entirely before the specified element\n+     */\n+    public boolean isBefore(T element) {\n+        if (element == null) {\n+            return false;\n+        }\n+        return comparator.compare(element, maximum) > 0;\n+    }\n+\n+    /**\n+     * <p>Checks where the specified element occurs relative to this range.</p>\n+     * \n      * <p>The API is reminiscent of the Comparable interface returning {@code -1} if\n      * the element is before the range, {@code 0} if contained within the range and\n      * {@code 1} if the element is after the range. </p>\n      *\n-     * @param element  the element to test\n+     * @param element  the element to check for, not null\n      * @return -1, 0 or +1 depending on the element's location relative to the range\n      */\n     public int elementCompareTo(T element) {\n-        if(element == null) {\n+        if (element == null) {\n             // Comparable API says throw NPE on null\n             throw new NullPointerException(\"Element is null\");\n         }\n-        if(elementBefore(element)) {\n+        if (isAfter(element)) {\n             return -1;\n-        } else\n-        if(elementAfter(element)) {\n+        } else if (isBefore(element)) {\n             return 1;\n         } else {\n             return 0;\n     //--------------------------------------------------------------------\n \n     /**\n-     * <p>Tests whether the specified range occurs entirely within this range.</p>\n-     *\n-     * <p>{@code null} is handled and returns {@code false}.</p>\n-     *\n-     * @param range  the range to test, may be {@code null}\n-     * @return {@code true} if the specified range occurs entirely within\n-     *  this range; otherwise, {@code false}\n-     * @throws IllegalArgumentException if the {@code Range} cannot be compared\n-     */\n-    public boolean containsAll(Range<T> range) {\n-        if (range == null) {\n-            return false;\n-        }\n-        return contains(range.getMinimum())\n-            && contains(range.getMaximum());\n-    }\n-\n-    /**\n-     * <p>Tests whether the specified range overlaps with this range.</p>\n-     *\n-     * <p>{@code null} is handled and returns {@code false}.</p>\n-     *\n-     * @param range  the range to test, may be {@code null}\n-     * @return {@code true} if the specified range overlaps with this\n+     * <p>Checks whether this range contains all the elements of the specified range.</p>\n+     *\n+     * <p>This method may fail if the ranges have two different comparators or element types.</p>\n+     *\n+     * @param otherRange  the range to check, null returns false\n+     * @return true if this range contains the specified range\n+     * @throws RuntimeException if ranges cannot be compared\n+     */\n+    public boolean containsRange(Range<T> otherRange) {\n+        if (otherRange == null) {\n+            return false;\n+        }\n+        return contains(otherRange.minimum)\n+            && contains(otherRange.maximum);\n+    }\n+\n+    /**\n+     * <p>Checks whether this range is completely after the specified range.</p>\n+     *\n+     * <p>This method may fail if the ranges have two different comparators or element types.</p>\n+     *\n+     * @param otherRange  the range to check, null returns false\n+     * @return true if this range is completely after the specified range\n+     * @throws RuntimeException if ranges cannot be compared\n+     */\n+    public boolean isAfterRange(Range<T> otherRange) {\n+        if (otherRange == null) {\n+            return false;\n+        }\n+        return isAfter(otherRange.maximum);\n+    }\n+\n+    /**\n+     * <p>Checks whether this range is overlapped by the specified range.</p>\n+     * \n+     * <p>Two ranges overlap if there is at least one element in common.</p>\n+     *\n+     * <p>This method may fail if the ranges have two different comparators or element types.</p>\n+     *\n+     * @param otherRange  the range to test, null returns false\n+     * @return true if the specified range overlaps with this\n      *  range; otherwise, {@code false}\n-     * @throws IllegalArgumentException if the {@code Range} cannot be compared\n-     */\n-    public boolean overlapsWith(Range<T> range) {\n-        if (range == null) {\n-            return false;\n-        }\n-        return range.contains(this.minimum)\n-            || range.contains(this.maximum)\n-            || contains(range.getMinimum());\n+     * @throws RuntimeException if ranges cannot be compared\n+     */\n+    public boolean isOverlappedBy(Range<T> otherRange) {\n+        if (otherRange == null) {\n+            return false;\n+        }\n+        return otherRange.contains(minimum)\n+            || otherRange.contains(maximum)\n+            || contains(otherRange.minimum);\n+    }\n+\n+    /**\n+     * <p>Checks whether this range is completely before the specified range.</p>\n+     *\n+     * <p>This method may fail if the ranges have two different comparators or element types.</p>\n+     *\n+     * @param otherRange  the range to check, null returns false\n+     * @return true if this range is completely before the specified range\n+     * @throws RuntimeException if ranges cannot be compared\n+     */\n+    public boolean isBeforeRange(Range<T> otherRange) {\n+        if (otherRange == null) {\n+            return false;\n+        }\n+        return isBefore(otherRange.minimum);\n     }\n \n     // Basics\n     /**\n      * <p>Compares this range to another object to test if they are equal.</p>.\n      *\n-     * <p>To be equal, the class, minimum and maximum must be equal.</p>\n+     * <p>To be equal, the minimum and maximum values must be equal, which\n+     * ignores any differences in the comparator.</p>\n      *\n      * @param obj the reference object with which to compare\n-     * @return {@code true} if this object is equal\n+     * @return true if this object is equal\n      */\n     @Override\n     public boolean equals(Object obj) {\n         } else {\n             @SuppressWarnings(\"unchecked\") // OK because we checked the class above\n             Range<T> range = (Range<T>) obj;\n-            return getMinimum().equals(range.getMinimum()) &&\n-                   getMaximum().equals(range.getMaximum());\n-        }\n-    }\n-\n-    /**\n-     * <p>Gets a hashCode for the range.</p>\n+            return minimum.equals(range.minimum) &&\n+                   maximum.equals(range.maximum);\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets a suitable hash code for the range.</p>\n      *\n      * @return a hash code value for this object\n      */\n         if (hashCode == 0) {\n             result = 17;\n             result = 37 * result + getClass().hashCode();\n-            result = 37 * result + this.minimum.hashCode();\n-            result = 37 * result + this.maximum.hashCode();\n+            result = 37 * result + minimum.hashCode();\n+            result = 37 * result + maximum.hashCode();\n             hashCode = result;\n         }\n         return result;\n     /**\n      * <p>Gets the range as a {@code String}.</p>\n      *\n-     * <p>The format of the String is 'Range[<i>min</i>,<i>max</i>]'.</p>\n+     * <p>The format of the String is '[<i>min</i>..<i>max</i>]'.</p>\n      *\n      * @return the {@code String} representation of this range\n      */\n         String result = toString;\n         if (result == null) {\n             StringBuilder buf = new StringBuilder(32);\n-            buf.append(\"Range[\");\n-            buf.append(this.minimum);\n-            buf.append(',');\n-            buf.append(this.maximum);\n+            buf.append('[');\n+            buf.append(minimum);\n+            buf.append(\"..\");\n+            buf.append(maximum);\n             buf.append(']');\n             result = buf.toString();\n             toString = result;\n         return result;\n     }\n \n-    // Taken from Commons Collections - documentation removed as not a public class\n-    private static class ComparableComparator<E extends Comparable<? super E>> implements Comparator<E>, Serializable {\n-\n-        private static final long serialVersionUID = 1L;\n-\n-        @SuppressWarnings(\"rawtypes\") // Comparator works for all types\n-        public static final ComparableComparator<?> INSTANCE = new ComparableComparator();\n-\n-        /**\n-         * Returns a comparator for the specified {@code Comparable} type.\n-         *\n-         * @param <E> the {@code Comparable} type\n-         * @return the comparator for this type\n-         */\n-        @SuppressWarnings(\"unchecked\") // OK to cast, because comparator works for all types\n-        public static <E extends Comparable<? super E>> ComparableComparator<E> getInstance() {\n-            return (ComparableComparator<E>) INSTANCE;\n-        }\n-\n-        /**\n-         * Creates a new instance of {@code ComparableComparator}.\n-         */\n-        public ComparableComparator() {\n-            super();\n-        }\n-\n-        /**\n-         * Compares two objects.\n-         *\n-         * @param obj1 the first object\n-         * @param obj2 the second object\n-         * @return the result of the comparison\n-         */\n-        public int compare(E obj1, E obj2) {\n-            return obj1.compareTo(obj2);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return \"ComparableComparator\".hashCode();\n-        }\n-\n-        @Override\n-        public boolean equals(Object object) {\n-            return (this == object) ||\n-                   ((null != object) && (object.getClass().equals(this.getClass())));\n-        }\n-\n+    /**\n+     * <p>Formats the receiver using the given format.</p>\n+     * \n+     * <p>This uses {@link Formattable} to perform the formatting. Three variables may\n+     * be used to embed the minimum, maximum and comparator.\n+     * Use {@code %1$s} for the minimum element, {@code %2$s} for the maximum element\n+     * and {@code %3$s} for the comparator.\n+     * The default format used by {@code toString()} is {@code [%1$s..%2$s]}.</p>\n+     * \n+     * @param format  the format string, optionally containing {@code %1$s}, {@code %2$s} and  {@code %3$s}, not null\n+     * @return the formatted string, not null\n+     */\n+    public String toString(String format) {\n+        return String.format(format, minimum, maximum, comparator);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    private enum ComparableComparator implements Comparator {\n+        INSTANCE;\n+        public int compare(Object obj1, Object obj2) {\n+            return ((Comparable) obj1).compareTo(obj2);\n+        }\n     }\n \n }\n--- a/src/test/java/org/apache/commons/lang3/RangeTest.java\n+++ b/src/test/java/org/apache/commons/lang3/RangeTest.java\n         doubleRange = Range.between((double) 10, (double) 20);\n     }\n \n-    // --------------------------------------------------------------------------\n-\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n     public void testComparableConstructors() {\n         Comparable c = \n             new Comparable() { \n                     return 1;\n                 }\n             };\n-        Range.is(c);\n-        Range.between(c, c);\n+        Range r1 = Range.is(c);\n+        Range r2 = Range.between(c, c);\n+        assertEquals(true, r1.isNaturalOrdering());\n+        assertEquals(true, r2.isNaturalOrdering());\n     }\n \n     public void testIsWithCompare(){\n         assertTrue(\"should contain -11\",rb.contains(-11));\n     }\n \n-    // --------------------------------------------------------------------------\n-\n+    //-----------------------------------------------------------------------\n     public void testRangeOfChars() {\n         Range<Character> chars = Range.between('a', 'z');\n         assertTrue(chars.contains('b'));\n         assertFalse(chars.contains('B'));\n     }\n \n-    // --------------------------------------------------------------------------\n-\n+    //-----------------------------------------------------------------------\n     public void testEqualsObject() {\n         assertEquals(byteRange, byteRange);\n         assertEquals(byteRange, byteRange2);\n     public void testHashCode() {\n         assertEquals(byteRange.hashCode(), byteRange2.hashCode());\n         assertFalse(byteRange.hashCode() == byteRange3.hashCode());\n-\n+        \n         assertEquals(intRange.hashCode(), intRange.hashCode());\n         assertTrue(intRange.hashCode() != 0);\n     }\n \n     public void testToString() {\n         assertNotNull(byteRange.toString());\n-\n+        \n         String str = intRange.toString();\n-        assertEquals(\"Range[10,20]\", str);\n-//        assertSame(str, intRange.toString());  // no longer passes - does it matter?\n-        assertEquals(\"Range[-20,-10]\", Range.between(-20, -10).toString());\n-    }\n-\n-    // --------------------------------------------------------------------------\n-\n+        assertEquals(\"[10..20]\", str);\n+        assertEquals(\"[-20..-10]\", Range.between(-20, -10).toString());\n+    }\n+\n+    public void testToStringFormat() {\n+        String str = intRange.toString(\"From %1$s to %2$s\");\n+        assertEquals(\"From 10 to 20\", str);\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testGetMinimum() {\n         assertEquals(10, (int) intRange.getMinimum());\n         assertEquals(10L, (long) longRange.getMinimum());\n         assertEquals(10f, floatRange.getMinimum(), 0.00001f);\n         assertEquals(10d, doubleRange.getMinimum(), 0.00001d);\n     }\n-    \n+\n     public void testGetMaximum() {\n         assertEquals(20, (int) intRange.getMaximum());\n         assertEquals(20L, (long) longRange.getMaximum());\n         assertFalse(intRange.contains(25));\n     }\n \n-    public void testElementBefore() {\n-        assertFalse(intRange.elementBefore(null));\n-        \n-        assertTrue(intRange.elementBefore(5));\n-        assertFalse(intRange.elementBefore(10));\n-        assertFalse(intRange.elementBefore(15));\n-        assertFalse(intRange.elementBefore(20));\n-        assertFalse(intRange.elementBefore(25));\n-    }\n-\n-    public void testElementAfter() {\n-        assertFalse(intRange.elementAfter(null));\n-        \n-        assertFalse(intRange.elementAfter(5));\n-        assertFalse(intRange.elementAfter(10));\n-        assertFalse(intRange.elementAfter(15));\n-        assertFalse(intRange.elementAfter(20));\n-        assertTrue(intRange.elementAfter(25));\n+    public void testIsAfter() {\n+        assertFalse(intRange.isAfter(null));\n+        \n+        assertTrue(intRange.isAfter(5));\n+        assertFalse(intRange.isAfter(10));\n+        assertFalse(intRange.isAfter(15));\n+        assertFalse(intRange.isAfter(20));\n+        assertFalse(intRange.isAfter(25));\n+    }\n+\n+    public void testIsStartedBy() {\n+        assertFalse(intRange.isStartedBy(null));\n+        \n+        assertFalse(intRange.isStartedBy(5));\n+        assertTrue(intRange.isStartedBy(10));\n+        assertFalse(intRange.isStartedBy(15));\n+        assertFalse(intRange.isStartedBy(20));\n+        assertFalse(intRange.isStartedBy(25));\n+    }\n+\n+    public void testIsEndedBy() {\n+        assertFalse(intRange.isEndedBy(null));\n+        \n+        assertFalse(intRange.isEndedBy(5));\n+        assertFalse(intRange.isEndedBy(10));\n+        assertFalse(intRange.isEndedBy(15));\n+        assertTrue(intRange.isEndedBy(20));\n+        assertFalse(intRange.isEndedBy(25));\n+    }\n+\n+    public void testIsBefore() {\n+        assertFalse(intRange.isBefore(null));\n+        \n+        assertFalse(intRange.isBefore(5));\n+        assertFalse(intRange.isBefore(10));\n+        assertFalse(intRange.isBefore(15));\n+        assertFalse(intRange.isBefore(20));\n+        assertTrue(intRange.isBefore(25));\n     }\n \n     public void testElementCompareTo() {\n         assertEquals(1, intRange.elementCompareTo(25));\n     }\n \n-    // --------------------------------------------------------------------------\n-\n-    public void testContainsAll() {\n+    //-----------------------------------------------------------------------\n+    public void testContainsRange() {\n \n         // null handling\n-        assertFalse(intRange.containsAll(null));\n+        assertFalse(intRange.containsRange(null));\n \n         // easy inside range\n-        assertTrue(intRange.containsAll(Range.between(12, 18)));\n+        assertTrue(intRange.containsRange(Range.between(12, 18)));\n \n         // outside range on each side\n-        assertFalse(intRange.containsAll(Range.between(32, 45)));\n-        assertFalse(intRange.containsAll(Range.between(2, 8)));\n+        assertFalse(intRange.containsRange(Range.between(32, 45)));\n+        assertFalse(intRange.containsRange(Range.between(2, 8)));\n \n         // equals range\n-        assertTrue(intRange.containsAll(Range.between(10, 20)));\n+        assertTrue(intRange.containsRange(Range.between(10, 20)));\n \n         // overlaps\n-        assertFalse(intRange.containsAll(Range.between(9, 14)));\n-        assertFalse(intRange.containsAll(Range.between(16, 21)));\n+        assertFalse(intRange.containsRange(Range.between(9, 14)));\n+        assertFalse(intRange.containsRange(Range.between(16, 21)));\n \n         // touches lower boundary\n-        assertTrue(intRange.containsAll(Range.between(10, 19)));\n-        assertFalse(intRange.containsAll(Range.between(10, 21)));\n+        assertTrue(intRange.containsRange(Range.between(10, 19)));\n+        assertFalse(intRange.containsRange(Range.between(10, 21)));\n \n         // touches upper boundary\n-        assertTrue(intRange.containsAll(Range.between(11, 20)));\n-        assertFalse(intRange.containsAll(Range.between(9, 20)));\n+        assertTrue(intRange.containsRange(Range.between(11, 20)));\n+        assertFalse(intRange.containsRange(Range.between(9, 20)));\n         \n         // negative\n-        assertFalse(intRange.containsAll(Range.between(-11, -18)));\n-\n-    }\n-\n-    public void testOverlapsWith() {\n+        assertFalse(intRange.containsRange(Range.between(-11, -18)));\n+    }\n+\n+    public void testIsAfterRange() {\n+        assertFalse(intRange.isAfterRange(null));\n+        \n+        assertTrue(intRange.isAfterRange(Range.between(5, 9)));\n+        \n+        assertFalse(intRange.isAfterRange(Range.between(5, 10)));\n+        assertFalse(intRange.isAfterRange(Range.between(5, 20)));\n+        assertFalse(intRange.isAfterRange(Range.between(5, 25)));\n+        assertFalse(intRange.isAfterRange(Range.between(15, 25)));\n+        \n+        assertFalse(intRange.isAfterRange(Range.between(21, 25)));\n+        \n+        assertFalse(intRange.isAfterRange(Range.between(10, 20)));\n+    }\n+\n+    public void testIsOverlappedBy() {\n \n         // null handling\n-        assertFalse(intRange.overlapsWith(null));\n+        assertFalse(intRange.isOverlappedBy(null));\n \n         // easy inside range\n-        assertTrue(intRange.overlapsWith(Range.between(12, 18)));\n+        assertTrue(intRange.isOverlappedBy(Range.between(12, 18)));\n \n         // outside range on each side\n-        assertFalse(intRange.overlapsWith(Range.between(32, 45)));\n-        assertFalse(intRange.overlapsWith(Range.between(2, 8)));\n+        assertFalse(intRange.isOverlappedBy(Range.between(32, 45)));\n+        assertFalse(intRange.isOverlappedBy(Range.between(2, 8)));\n \n         // equals range\n-        assertTrue(intRange.overlapsWith(Range.between(10, 20)));\n+        assertTrue(intRange.isOverlappedBy(Range.between(10, 20)));\n \n         // overlaps\n-        assertTrue(intRange.overlapsWith(Range.between(9, 14)));\n-        assertTrue(intRange.overlapsWith(Range.between(16, 21)));\n+        assertTrue(intRange.isOverlappedBy(Range.between(9, 14)));\n+        assertTrue(intRange.isOverlappedBy(Range.between(16, 21)));\n \n         // touches lower boundary\n-        assertTrue(intRange.overlapsWith(Range.between(10, 19)));\n-        assertTrue(intRange.overlapsWith(Range.between(10, 21)));\n+        assertTrue(intRange.isOverlappedBy(Range.between(10, 19)));\n+        assertTrue(intRange.isOverlappedBy(Range.between(10, 21)));\n \n         // touches upper boundary\n-        assertTrue(intRange.overlapsWith(Range.between(11, 20)));\n-        assertTrue(intRange.overlapsWith(Range.between(9, 20)));\n+        assertTrue(intRange.isOverlappedBy(Range.between(11, 20)));\n+        assertTrue(intRange.isOverlappedBy(Range.between(9, 20)));\n         \n         // negative\n-        assertFalse(intRange.overlapsWith(Range.between(-11, -18)));\n-\n-    }\n-\n+        assertFalse(intRange.isOverlappedBy(Range.between(-11, -18)));\n+    }\n+\n+    public void testIsBeforeRange() {\n+        assertFalse(intRange.isBeforeRange(null));\n+        \n+        assertFalse(intRange.isBeforeRange(Range.between(5, 9)));\n+        \n+        assertFalse(intRange.isBeforeRange(Range.between(5, 10)));\n+        assertFalse(intRange.isBeforeRange(Range.between(5, 20)));\n+        assertFalse(intRange.isBeforeRange(Range.between(5, 25)));\n+        assertFalse(intRange.isBeforeRange(Range.between(15, 25)));\n+        \n+        assertTrue(intRange.isBeforeRange(Range.between(21, 25)));\n+        \n+        assertFalse(intRange.isBeforeRange(Range.between(10, 20)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testSerializing() {\n         SerializationUtils.clone(intRange);\n     }", "timestamp": 1306338215, "metainfo": ""}