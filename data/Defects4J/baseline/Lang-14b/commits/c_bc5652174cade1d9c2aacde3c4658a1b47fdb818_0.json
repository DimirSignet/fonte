{"sha": "bc5652174cade1d9c2aacde3c4658a1b47fdb818", "log": "[LANG-102] [lang] Refactor Entities methods. http://issues.apache.org/jira/browse/LANG-102. Refactored escape and unescape methods to remove code duplication.  ", "commit": "\n--- a/src/java/org/apache/commons/lang/Entities.java\n+++ b/src/java/org/apache/commons/lang/Entities.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.commons.lang;\n \n import java.io.IOException;\n+import java.io.StringWriter;\n import java.io.Writer;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.TreeMap;\n \n /**\n- * <p>Provides HTML and XML entity utilities.</p>\n- *\n+ * <p>\n+ * Provides HTML and XML entity utilities.\n+ * </p>\n+ * \n  * @see <a href=\"http://hotwired.lycos.com/webmonkey/reference/special_characters/\">ISO Entities</a>\n  * @see <a href=\"http://www.w3.org/TR/REC-html32#latin1\">HTML 3.2 Character Entities for ISO Latin-1</a>\n  * @see <a href=\"http://www.w3.org/TR/REC-html40/sgml/entities.html\">HTML 4.0 Character entity references</a>\n  * @see <a href=\"http://www.w3.org/TR/html401/charset.html#h-5.3\">HTML 4.01 Character References</a>\n  * @see <a href=\"http://www.w3.org/TR/html401/charset.html#code-position\">HTML 4.01 Code positions</a>\n- *\n+ * \n  * @author <a href=\"mailto:alex@purpletech.com\">Alexander Day Chaffee</a>\n  * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n  * @since 2.0\n  */\n class Entities {\n \n-    private static final String[][] BASIC_ARRAY = {\n-        {\"quot\", \"34\"}, // \" - double-quote\n+    private static final String[][] BASIC_ARRAY = {{\"quot\", \"34\"}, // \" - double-quote\n         {\"amp\", \"38\"}, // & - ampersand\n         {\"lt\", \"60\"}, // < - less-than\n         {\"gt\", \"62\"}, // > - greater-than\n     };\n \n-    private static final String[][] APOS_ARRAY = {\n-        {\"apos\", \"39\"}, // XML apostrophe\n+    private static final String[][] APOS_ARRAY = {{\"apos\", \"39\"}, // XML apostrophe\n     };\n \n     // package scoped for testing\n-    static final String[][] ISO8859_1_ARRAY = {\n-        {\"nbsp\", \"160\"}, // non-breaking space\n-        {\"iexcl\", \"161\"}, //inverted exclamation mark\n-        {\"cent\", \"162\"}, //cent sign\n-        {\"pound\", \"163\"}, //pound sign\n-        {\"curren\", \"164\"}, //currency sign\n-        {\"yen\", \"165\"}, //yen sign = yuan sign\n-        {\"brvbar\", \"166\"}, //broken bar = broken vertical bar\n-        {\"sect\", \"167\"}, //section sign\n-        {\"uml\", \"168\"}, //diaeresis = spacing diaeresis\n+    static final String[][] ISO8859_1_ARRAY = {{\"nbsp\", \"160\"}, // non-breaking space\n+        {\"iexcl\", \"161\"}, // inverted exclamation mark\n+        {\"cent\", \"162\"}, // cent sign\n+        {\"pound\", \"163\"}, // pound sign\n+        {\"curren\", \"164\"}, // currency sign\n+        {\"yen\", \"165\"}, // yen sign = yuan sign\n+        {\"brvbar\", \"166\"}, // broken bar = broken vertical bar\n+        {\"sect\", \"167\"}, // section sign\n+        {\"uml\", \"168\"}, // diaeresis = spacing diaeresis\n         {\"copy\", \"169\"}, //  - copyright sign\n-        {\"ordf\", \"170\"}, //feminine ordinal indicator\n-        {\"laquo\", \"171\"}, //left-pointing double angle quotation mark = left pointing guillemet\n-        {\"not\", \"172\"}, //not sign\n-        {\"shy\", \"173\"}, //soft hyphen = discretionary hyphen\n+        {\"ordf\", \"170\"}, // feminine ordinal indicator\n+        {\"laquo\", \"171\"}, // left-pointing double angle quotation mark = left pointing guillemet\n+        {\"not\", \"172\"}, // not sign\n+        {\"shy\", \"173\"}, // soft hyphen = discretionary hyphen\n         {\"reg\", \"174\"}, //  - registered trademark sign\n-        {\"macr\", \"175\"}, //macron = spacing macron = overline = APL overbar\n-        {\"deg\", \"176\"}, //degree sign\n-        {\"plusmn\", \"177\"}, //plus-minus sign = plus-or-minus sign\n-        {\"sup2\", \"178\"}, //superscript two = superscript digit two = squared\n-        {\"sup3\", \"179\"}, //superscript three = superscript digit three = cubed\n-        {\"acute\", \"180\"}, //acute accent = spacing acute\n-        {\"micro\", \"181\"}, //micro sign\n-        {\"para\", \"182\"}, //pilcrow sign = paragraph sign\n-        {\"middot\", \"183\"}, //middle dot = Georgian comma = Greek middle dot\n-        {\"cedil\", \"184\"}, //cedilla = spacing cedilla\n-        {\"sup1\", \"185\"}, //superscript one = superscript digit one\n-        {\"ordm\", \"186\"}, //masculine ordinal indicator\n-        {\"raquo\", \"187\"}, //right-pointing double angle quotation mark = right pointing guillemet\n-        {\"frac14\", \"188\"}, //vulgar fraction one quarter = fraction one quarter\n-        {\"frac12\", \"189\"}, //vulgar fraction one half = fraction one half\n-        {\"frac34\", \"190\"}, //vulgar fraction three quarters = fraction three quarters\n-        {\"iquest\", \"191\"}, //inverted question mark = turned question mark\n+        {\"macr\", \"175\"}, // macron = spacing macron = overline = APL overbar\n+        {\"deg\", \"176\"}, // degree sign\n+        {\"plusmn\", \"177\"}, // plus-minus sign = plus-or-minus sign\n+        {\"sup2\", \"178\"}, // superscript two = superscript digit two = squared\n+        {\"sup3\", \"179\"}, // superscript three = superscript digit three = cubed\n+        {\"acute\", \"180\"}, // acute accent = spacing acute\n+        {\"micro\", \"181\"}, // micro sign\n+        {\"para\", \"182\"}, // pilcrow sign = paragraph sign\n+        {\"middot\", \"183\"}, // middle dot = Georgian comma = Greek middle dot\n+        {\"cedil\", \"184\"}, // cedilla = spacing cedilla\n+        {\"sup1\", \"185\"}, // superscript one = superscript digit one\n+        {\"ordm\", \"186\"}, // masculine ordinal indicator\n+        {\"raquo\", \"187\"}, // right-pointing double angle quotation mark = right pointing guillemet\n+        {\"frac14\", \"188\"}, // vulgar fraction one quarter = fraction one quarter\n+        {\"frac12\", \"189\"}, // vulgar fraction one half = fraction one half\n+        {\"frac34\", \"190\"}, // vulgar fraction three quarters = fraction three quarters\n+        {\"iquest\", \"191\"}, // inverted question mark = turned question mark\n         {\"Agrave\", \"192\"}, //  - uppercase A, grave accent\n         {\"Aacute\", \"193\"}, //  - uppercase A, acute accent\n         {\"Acirc\", \"194\"}, //  - uppercase A, circumflex accent\n         {\"Ocirc\", \"212\"}, //  - uppercase O, circumflex accent\n         {\"Otilde\", \"213\"}, //  - uppercase O, tilde\n         {\"Ouml\", \"214\"}, //  - uppercase O, umlaut\n-        {\"times\", \"215\"}, //multiplication sign\n+        {\"times\", \"215\"}, // multiplication sign\n         {\"Oslash\", \"216\"}, //  - uppercase O, slash\n         {\"Ugrave\", \"217\"}, //  - uppercase U, grave accent\n         {\"Uacute\", \"218\"}, //  - uppercase U, acute accent\n     // http://www.w3.org/TR/REC-html40/sgml/entities.html\n     // package scoped for testing\n     static final String[][] HTML40_ARRAY = {\n-// <!-- Latin Extended-B -->\n-        {\"fnof\", \"402\"}, //latin small f with hook = function= florin, U+0192 ISOtech -->\n-// <!-- Greek -->\n-        {\"Alpha\", \"913\"}, //greek capital letter alpha, U+0391 -->\n-        {\"Beta\", \"914\"}, //greek capital letter beta, U+0392 -->\n-        {\"Gamma\", \"915\"}, //greek capital letter gamma,U+0393 ISOgrk3 -->\n-        {\"Delta\", \"916\"}, //greek capital letter delta,U+0394 ISOgrk3 -->\n-        {\"Epsilon\", \"917\"}, //greek capital letter epsilon, U+0395 -->\n-        {\"Zeta\", \"918\"}, //greek capital letter zeta, U+0396 -->\n-        {\"Eta\", \"919\"}, //greek capital letter eta, U+0397 -->\n-        {\"Theta\", \"920\"}, //greek capital letter theta,U+0398 ISOgrk3 -->\n-        {\"Iota\", \"921\"}, //greek capital letter iota, U+0399 -->\n-        {\"Kappa\", \"922\"}, //greek capital letter kappa, U+039A -->\n-        {\"Lambda\", \"923\"}, //greek capital letter lambda,U+039B ISOgrk3 -->\n-        {\"Mu\", \"924\"}, //greek capital letter mu, U+039C -->\n-        {\"Nu\", \"925\"}, //greek capital letter nu, U+039D -->\n-        {\"Xi\", \"926\"}, //greek capital letter xi, U+039E ISOgrk3 -->\n-        {\"Omicron\", \"927\"}, //greek capital letter omicron, U+039F -->\n-        {\"Pi\", \"928\"}, //greek capital letter pi, U+03A0 ISOgrk3 -->\n-        {\"Rho\", \"929\"}, //greek capital letter rho, U+03A1 -->\n-// <!-- there is no Sigmaf, and no U+03A2 character either -->\n-        {\"Sigma\", \"931\"}, //greek capital letter sigma,U+03A3 ISOgrk3 -->\n-        {\"Tau\", \"932\"}, //greek capital letter tau, U+03A4 -->\n-        {\"Upsilon\", \"933\"}, //greek capital letter upsilon,U+03A5 ISOgrk3 -->\n-        {\"Phi\", \"934\"}, //greek capital letter phi,U+03A6 ISOgrk3 -->\n-        {\"Chi\", \"935\"}, //greek capital letter chi, U+03A7 -->\n-        {\"Psi\", \"936\"}, //greek capital letter psi,U+03A8 ISOgrk3 -->\n-        {\"Omega\", \"937\"}, //greek capital letter omega,U+03A9 ISOgrk3 -->\n-        {\"alpha\", \"945\"}, //greek small letter alpha,U+03B1 ISOgrk3 -->\n-        {\"beta\", \"946\"}, //greek small letter beta, U+03B2 ISOgrk3 -->\n-        {\"gamma\", \"947\"}, //greek small letter gamma,U+03B3 ISOgrk3 -->\n-        {\"delta\", \"948\"}, //greek small letter delta,U+03B4 ISOgrk3 -->\n-        {\"epsilon\", \"949\"}, //greek small letter epsilon,U+03B5 ISOgrk3 -->\n-        {\"zeta\", \"950\"}, //greek small letter zeta, U+03B6 ISOgrk3 -->\n-        {\"eta\", \"951\"}, //greek small letter eta, U+03B7 ISOgrk3 -->\n-        {\"theta\", \"952\"}, //greek small letter theta,U+03B8 ISOgrk3 -->\n-        {\"iota\", \"953\"}, //greek small letter iota, U+03B9 ISOgrk3 -->\n-        {\"kappa\", \"954\"}, //greek small letter kappa,U+03BA ISOgrk3 -->\n-        {\"lambda\", \"955\"}, //greek small letter lambda,U+03BB ISOgrk3 -->\n-        {\"mu\", \"956\"}, //greek small letter mu, U+03BC ISOgrk3 -->\n-        {\"nu\", \"957\"}, //greek small letter nu, U+03BD ISOgrk3 -->\n-        {\"xi\", \"958\"}, //greek small letter xi, U+03BE ISOgrk3 -->\n-        {\"omicron\", \"959\"}, //greek small letter omicron, U+03BF NEW -->\n-        {\"pi\", \"960\"}, //greek small letter pi, U+03C0 ISOgrk3 -->\n-        {\"rho\", \"961\"}, //greek small letter rho, U+03C1 ISOgrk3 -->\n-        {\"sigmaf\", \"962\"}, //greek small letter final sigma,U+03C2 ISOgrk3 -->\n-        {\"sigma\", \"963\"}, //greek small letter sigma,U+03C3 ISOgrk3 -->\n-        {\"tau\", \"964\"}, //greek small letter tau, U+03C4 ISOgrk3 -->\n-        {\"upsilon\", \"965\"}, //greek small letter upsilon,U+03C5 ISOgrk3 -->\n-        {\"phi\", \"966\"}, //greek small letter phi, U+03C6 ISOgrk3 -->\n-        {\"chi\", \"967\"}, //greek small letter chi, U+03C7 ISOgrk3 -->\n-        {\"psi\", \"968\"}, //greek small letter psi, U+03C8 ISOgrk3 -->\n-        {\"omega\", \"969\"}, //greek small letter omega,U+03C9 ISOgrk3 -->\n-        {\"thetasym\", \"977\"}, //greek small letter theta symbol,U+03D1 NEW -->\n-        {\"upsih\", \"978\"}, //greek upsilon with hook symbol,U+03D2 NEW -->\n-        {\"piv\", \"982\"}, //greek pi symbol, U+03D6 ISOgrk3 -->\n-// <!-- General Punctuation -->\n-        {\"bull\", \"8226\"}, //bullet = black small circle,U+2022 ISOpub  -->\n-// <!-- bullet is NOT the same as bullet operator, U+2219 -->\n-        {\"hellip\", \"8230\"}, //horizontal ellipsis = three dot leader,U+2026 ISOpub  -->\n-        {\"prime\", \"8242\"}, //prime = minutes = feet, U+2032 ISOtech -->\n-        {\"Prime\", \"8243\"}, //double prime = seconds = inches,U+2033 ISOtech -->\n-        {\"oline\", \"8254\"}, //overline = spacing overscore,U+203E NEW -->\n-        {\"frasl\", \"8260\"}, //fraction slash, U+2044 NEW -->\n-// <!-- Letterlike Symbols -->\n-        {\"weierp\", \"8472\"}, //script capital P = power set= Weierstrass p, U+2118 ISOamso -->\n-        {\"image\", \"8465\"}, //blackletter capital I = imaginary part,U+2111 ISOamso -->\n-        {\"real\", \"8476\"}, //blackletter capital R = real part symbol,U+211C ISOamso -->\n-        {\"trade\", \"8482\"}, //trade mark sign, U+2122 ISOnum -->\n-        {\"alefsym\", \"8501\"}, //alef symbol = first transfinite cardinal,U+2135 NEW -->\n-// <!-- alef symbol is NOT the same as hebrew letter alef,U+05D0 although the \n-//      same glyph could be used to depict both characters -->\n-// <!-- Arrows -->\n-        {\"larr\", \"8592\"}, //leftwards arrow, U+2190 ISOnum -->\n-        {\"uarr\", \"8593\"}, //upwards arrow, U+2191 ISOnum-->\n-        {\"rarr\", \"8594\"}, //rightwards arrow, U+2192 ISOnum -->\n-        {\"darr\", \"8595\"}, //downwards arrow, U+2193 ISOnum -->\n-        {\"harr\", \"8596\"}, //left right arrow, U+2194 ISOamsa -->\n-        {\"crarr\", \"8629\"}, //downwards arrow with corner leftwards= carriage return, U+21B5 NEW -->\n-        {\"lArr\", \"8656\"}, //leftwards double arrow, U+21D0 ISOtech -->\n-// <!-- ISO 10646 does not say that lArr is the same as the 'is implied by' \n-//      arrow but also does not have any other character for that function. \n-//      So ? lArr canbe used for 'is implied by' as ISOtech suggests -->\n-        {\"uArr\", \"8657\"}, //upwards double arrow, U+21D1 ISOamsa -->\n-        {\"rArr\", \"8658\"}, //rightwards double arrow,U+21D2 ISOtech -->\n-// <!-- ISO 10646 does not say this is the 'implies' character but does not\n-//      have another character with this function so ?rArr can be used for\n-//      'implies' as ISOtech suggests -->\n-        {\"dArr\", \"8659\"}, //downwards double arrow, U+21D3 ISOamsa -->\n-        {\"hArr\", \"8660\"}, //left right double arrow,U+21D4 ISOamsa -->\n-// <!-- Mathematical Operators -->\n-        {\"forall\", \"8704\"}, //for all, U+2200 ISOtech -->\n-        {\"part\", \"8706\"}, //partial differential, U+2202 ISOtech  -->\n-        {\"exist\", \"8707\"}, //there exists, U+2203 ISOtech -->\n-        {\"empty\", \"8709\"}, //empty set = null set = diameter,U+2205 ISOamso -->\n-        {\"nabla\", \"8711\"}, //nabla = backward difference,U+2207 ISOtech -->\n-        {\"isin\", \"8712\"}, //element of, U+2208 ISOtech -->\n-        {\"notin\", \"8713\"}, //not an element of, U+2209 ISOtech -->\n-        {\"ni\", \"8715\"}, //contains as member, U+220B ISOtech -->\n-// <!-- should there be a more memorable name than 'ni'? -->\n-        {\"prod\", \"8719\"}, //n-ary product = product sign,U+220F ISOamsb -->\n-// <!-- prod is NOT the same character as U+03A0 'greek capital letter pi' \n-//      though the same glyph might be used for both -->\n-        {\"sum\", \"8721\"}, //n-ary summation, U+2211 ISOamsb -->\n-// <!-- sum is NOT the same character as U+03A3 'greek capital letter sigma'\n-//      though the same glyph might be used for both -->\n-        {\"minus\", \"8722\"}, //minus sign, U+2212 ISOtech -->\n-        {\"lowast\", \"8727\"}, //asterisk operator, U+2217 ISOtech -->\n-        {\"radic\", \"8730\"}, //square root = radical sign,U+221A ISOtech -->\n-        {\"prop\", \"8733\"}, //proportional to, U+221D ISOtech -->\n-        {\"infin\", \"8734\"}, //infinity, U+221E ISOtech -->\n-        {\"ang\", \"8736\"}, //angle, U+2220 ISOamso -->\n-        {\"and\", \"8743\"}, //logical and = wedge, U+2227 ISOtech -->\n-        {\"or\", \"8744\"}, //logical or = vee, U+2228 ISOtech -->\n-        {\"cap\", \"8745\"}, //intersection = cap, U+2229 ISOtech -->\n-        {\"cup\", \"8746\"}, //union = cup, U+222A ISOtech -->\n-        {\"int\", \"8747\"}, //integral, U+222B ISOtech -->\n-        {\"there4\", \"8756\"}, //therefore, U+2234 ISOtech -->\n-        {\"sim\", \"8764\"}, //tilde operator = varies with = similar to,U+223C ISOtech -->\n-// <!-- tilde operator is NOT the same character as the tilde, U+007E,although\n-//      the same glyph might be used to represent both  -->\n-        {\"cong\", \"8773\"}, //approximately equal to, U+2245 ISOtech -->\n-        {\"asymp\", \"8776\"}, //almost equal to = asymptotic to,U+2248 ISOamsr -->\n-        {\"ne\", \"8800\"}, //not equal to, U+2260 ISOtech -->\n-        {\"equiv\", \"8801\"}, //identical to, U+2261 ISOtech -->\n-        {\"le\", \"8804\"}, //less-than or equal to, U+2264 ISOtech -->\n-        {\"ge\", \"8805\"}, //greater-than or equal to,U+2265 ISOtech -->\n-        {\"sub\", \"8834\"}, //subset of, U+2282 ISOtech -->\n-        {\"sup\", \"8835\"}, //superset of, U+2283 ISOtech -->\n-// <!-- note that nsup, 'not a superset of, U+2283' is not covered by the\n-//      Symbol font encoding and is not included. Should it be, for symmetry?\n-//      It is in ISOamsn  --> <!ENTITY nsub\", \"8836\"},  \n-//      not a subset of, U+2284 ISOamsn -->\n-        {\"sube\", \"8838\"}, //subset of or equal to, U+2286 ISOtech -->\n-        {\"supe\", \"8839\"}, //superset of or equal to,U+2287 ISOtech -->\n-        {\"oplus\", \"8853\"}, //circled plus = direct sum,U+2295 ISOamsb -->\n-        {\"otimes\", \"8855\"}, //circled times = vector product,U+2297 ISOamsb -->\n-        {\"perp\", \"8869\"}, //up tack = orthogonal to = perpendicular,U+22A5 ISOtech -->\n-        {\"sdot\", \"8901\"}, //dot operator, U+22C5 ISOamsb -->\n-// <!-- dot operator is NOT the same character as U+00B7 middle dot -->\n-// <!-- Miscellaneous Technical -->\n-        {\"lceil\", \"8968\"}, //left ceiling = apl upstile,U+2308 ISOamsc  -->\n-        {\"rceil\", \"8969\"}, //right ceiling, U+2309 ISOamsc  -->\n-        {\"lfloor\", \"8970\"}, //left floor = apl downstile,U+230A ISOamsc  -->\n-        {\"rfloor\", \"8971\"}, //right floor, U+230B ISOamsc  -->\n-        {\"lang\", \"9001\"}, //left-pointing angle bracket = bra,U+2329 ISOtech -->\n-// <!-- lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation mark' -->\n-        {\"rang\", \"9002\"}, //right-pointing angle bracket = ket,U+232A ISOtech -->\n-// <!-- rang is NOT the same character as U+003E 'greater than' or U+203A \n-//      'single right-pointing angle quotation mark' -->\n-// <!-- Geometric Shapes -->\n-        {\"loz\", \"9674\"}, //lozenge, U+25CA ISOpub -->\n-// <!-- Miscellaneous Symbols -->\n-        {\"spades\", \"9824\"}, //black spade suit, U+2660 ISOpub -->\n-// <!-- black here seems to mean filled as opposed to hollow -->\n-        {\"clubs\", \"9827\"}, //black club suit = shamrock,U+2663 ISOpub -->\n-        {\"hearts\", \"9829\"}, //black heart suit = valentine,U+2665 ISOpub -->\n-        {\"diams\", \"9830\"}, //black diamond suit, U+2666 ISOpub -->\n-\n-// <!-- Latin Extended-A -->\n-        {\"OElig\", \"338\"}, //  -- latin capital ligature OE,U+0152 ISOlat2 -->\n-        {\"oelig\", \"339\"}, //  -- latin small ligature oe, U+0153 ISOlat2 -->\n-// <!-- ligature is a misnomer, this is a separate character in some languages -->\n-        {\"Scaron\", \"352\"}, //  -- latin capital letter S with caron,U+0160 ISOlat2 -->\n-        {\"scaron\", \"353\"}, //  -- latin small letter s with caron,U+0161 ISOlat2 -->\n-        {\"Yuml\", \"376\"}, //  -- latin capital letter Y with diaeresis,U+0178 ISOlat2 -->\n-// <!-- Spacing Modifier Letters -->\n-        {\"circ\", \"710\"}, //  -- modifier letter circumflex accent,U+02C6 ISOpub -->\n-        {\"tilde\", \"732\"}, //small tilde, U+02DC ISOdia -->\n-// <!-- General Punctuation -->\n-        {\"ensp\", \"8194\"}, //en space, U+2002 ISOpub -->\n-        {\"emsp\", \"8195\"}, //em space, U+2003 ISOpub -->\n-        {\"thinsp\", \"8201\"}, //thin space, U+2009 ISOpub -->\n-        {\"zwnj\", \"8204\"}, //zero width non-joiner,U+200C NEW RFC 2070 -->\n-        {\"zwj\", \"8205\"}, //zero width joiner, U+200D NEW RFC 2070 -->\n-        {\"lrm\", \"8206\"}, //left-to-right mark, U+200E NEW RFC 2070 -->\n-        {\"rlm\", \"8207\"}, //right-to-left mark, U+200F NEW RFC 2070 -->\n-        {\"ndash\", \"8211\"}, //en dash, U+2013 ISOpub -->\n-        {\"mdash\", \"8212\"}, //em dash, U+2014 ISOpub -->\n-        {\"lsquo\", \"8216\"}, //left single quotation mark,U+2018 ISOnum -->\n-        {\"rsquo\", \"8217\"}, //right single quotation mark,U+2019 ISOnum -->\n-        {\"sbquo\", \"8218\"}, //single low-9 quotation mark, U+201A NEW -->\n-        {\"ldquo\", \"8220\"}, //left double quotation mark,U+201C ISOnum -->\n-        {\"rdquo\", \"8221\"}, //right double quotation mark,U+201D ISOnum -->\n-        {\"bdquo\", \"8222\"}, //double low-9 quotation mark, U+201E NEW -->\n-        {\"dagger\", \"8224\"}, //dagger, U+2020 ISOpub -->\n-        {\"Dagger\", \"8225\"}, //double dagger, U+2021 ISOpub -->\n-        {\"permil\", \"8240\"}, //per mille sign, U+2030 ISOtech -->\n-        {\"lsaquo\", \"8249\"}, //single left-pointing angle quotation mark,U+2039 ISO proposed -->\n-// <!-- lsaquo is proposed but not yet ISO standardized -->\n-        {\"rsaquo\", \"8250\"}, //single right-pointing angle quotation mark,U+203A ISO proposed -->\n-// <!-- rsaquo is proposed but not yet ISO standardized -->\n-        {\"euro\", \"8364\"}, //  -- euro sign, U+20AC NEW -->\n+    // <!-- Latin Extended-B -->\n+        {\"fnof\", \"402\"}, // latin small f with hook = function= florin, U+0192 ISOtech -->\n+        // <!-- Greek -->\n+        {\"Alpha\", \"913\"}, // greek capital letter alpha, U+0391 -->\n+        {\"Beta\", \"914\"}, // greek capital letter beta, U+0392 -->\n+        {\"Gamma\", \"915\"}, // greek capital letter gamma,U+0393 ISOgrk3 -->\n+        {\"Delta\", \"916\"}, // greek capital letter delta,U+0394 ISOgrk3 -->\n+        {\"Epsilon\", \"917\"}, // greek capital letter epsilon, U+0395 -->\n+        {\"Zeta\", \"918\"}, // greek capital letter zeta, U+0396 -->\n+        {\"Eta\", \"919\"}, // greek capital letter eta, U+0397 -->\n+        {\"Theta\", \"920\"}, // greek capital letter theta,U+0398 ISOgrk3 -->\n+        {\"Iota\", \"921\"}, // greek capital letter iota, U+0399 -->\n+        {\"Kappa\", \"922\"}, // greek capital letter kappa, U+039A -->\n+        {\"Lambda\", \"923\"}, // greek capital letter lambda,U+039B ISOgrk3 -->\n+        {\"Mu\", \"924\"}, // greek capital letter mu, U+039C -->\n+        {\"Nu\", \"925\"}, // greek capital letter nu, U+039D -->\n+        {\"Xi\", \"926\"}, // greek capital letter xi, U+039E ISOgrk3 -->\n+        {\"Omicron\", \"927\"}, // greek capital letter omicron, U+039F -->\n+        {\"Pi\", \"928\"}, // greek capital letter pi, U+03A0 ISOgrk3 -->\n+        {\"Rho\", \"929\"}, // greek capital letter rho, U+03A1 -->\n+        // <!-- there is no Sigmaf, and no U+03A2 character either -->\n+        {\"Sigma\", \"931\"}, // greek capital letter sigma,U+03A3 ISOgrk3 -->\n+        {\"Tau\", \"932\"}, // greek capital letter tau, U+03A4 -->\n+        {\"Upsilon\", \"933\"}, // greek capital letter upsilon,U+03A5 ISOgrk3 -->\n+        {\"Phi\", \"934\"}, // greek capital letter phi,U+03A6 ISOgrk3 -->\n+        {\"Chi\", \"935\"}, // greek capital letter chi, U+03A7 -->\n+        {\"Psi\", \"936\"}, // greek capital letter psi,U+03A8 ISOgrk3 -->\n+        {\"Omega\", \"937\"}, // greek capital letter omega,U+03A9 ISOgrk3 -->\n+        {\"alpha\", \"945\"}, // greek small letter alpha,U+03B1 ISOgrk3 -->\n+        {\"beta\", \"946\"}, // greek small letter beta, U+03B2 ISOgrk3 -->\n+        {\"gamma\", \"947\"}, // greek small letter gamma,U+03B3 ISOgrk3 -->\n+        {\"delta\", \"948\"}, // greek small letter delta,U+03B4 ISOgrk3 -->\n+        {\"epsilon\", \"949\"}, // greek small letter epsilon,U+03B5 ISOgrk3 -->\n+        {\"zeta\", \"950\"}, // greek small letter zeta, U+03B6 ISOgrk3 -->\n+        {\"eta\", \"951\"}, // greek small letter eta, U+03B7 ISOgrk3 -->\n+        {\"theta\", \"952\"}, // greek small letter theta,U+03B8 ISOgrk3 -->\n+        {\"iota\", \"953\"}, // greek small letter iota, U+03B9 ISOgrk3 -->\n+        {\"kappa\", \"954\"}, // greek small letter kappa,U+03BA ISOgrk3 -->\n+        {\"lambda\", \"955\"}, // greek small letter lambda,U+03BB ISOgrk3 -->\n+        {\"mu\", \"956\"}, // greek small letter mu, U+03BC ISOgrk3 -->\n+        {\"nu\", \"957\"}, // greek small letter nu, U+03BD ISOgrk3 -->\n+        {\"xi\", \"958\"}, // greek small letter xi, U+03BE ISOgrk3 -->\n+        {\"omicron\", \"959\"}, // greek small letter omicron, U+03BF NEW -->\n+        {\"pi\", \"960\"}, // greek small letter pi, U+03C0 ISOgrk3 -->\n+        {\"rho\", \"961\"}, // greek small letter rho, U+03C1 ISOgrk3 -->\n+        {\"sigmaf\", \"962\"}, // greek small letter final sigma,U+03C2 ISOgrk3 -->\n+        {\"sigma\", \"963\"}, // greek small letter sigma,U+03C3 ISOgrk3 -->\n+        {\"tau\", \"964\"}, // greek small letter tau, U+03C4 ISOgrk3 -->\n+        {\"upsilon\", \"965\"}, // greek small letter upsilon,U+03C5 ISOgrk3 -->\n+        {\"phi\", \"966\"}, // greek small letter phi, U+03C6 ISOgrk3 -->\n+        {\"chi\", \"967\"}, // greek small letter chi, U+03C7 ISOgrk3 -->\n+        {\"psi\", \"968\"}, // greek small letter psi, U+03C8 ISOgrk3 -->\n+        {\"omega\", \"969\"}, // greek small letter omega,U+03C9 ISOgrk3 -->\n+        {\"thetasym\", \"977\"}, // greek small letter theta symbol,U+03D1 NEW -->\n+        {\"upsih\", \"978\"}, // greek upsilon with hook symbol,U+03D2 NEW -->\n+        {\"piv\", \"982\"}, // greek pi symbol, U+03D6 ISOgrk3 -->\n+        // <!-- General Punctuation -->\n+        {\"bull\", \"8226\"}, // bullet = black small circle,U+2022 ISOpub -->\n+        // <!-- bullet is NOT the same as bullet operator, U+2219 -->\n+        {\"hellip\", \"8230\"}, // horizontal ellipsis = three dot leader,U+2026 ISOpub -->\n+        {\"prime\", \"8242\"}, // prime = minutes = feet, U+2032 ISOtech -->\n+        {\"Prime\", \"8243\"}, // double prime = seconds = inches,U+2033 ISOtech -->\n+        {\"oline\", \"8254\"}, // overline = spacing overscore,U+203E NEW -->\n+        {\"frasl\", \"8260\"}, // fraction slash, U+2044 NEW -->\n+        // <!-- Letterlike Symbols -->\n+        {\"weierp\", \"8472\"}, // script capital P = power set= Weierstrass p, U+2118 ISOamso -->\n+        {\"image\", \"8465\"}, // blackletter capital I = imaginary part,U+2111 ISOamso -->\n+        {\"real\", \"8476\"}, // blackletter capital R = real part symbol,U+211C ISOamso -->\n+        {\"trade\", \"8482\"}, // trade mark sign, U+2122 ISOnum -->\n+        {\"alefsym\", \"8501\"}, // alef symbol = first transfinite cardinal,U+2135 NEW -->\n+        // <!-- alef symbol is NOT the same as hebrew letter alef,U+05D0 although the\n+        // same glyph could be used to depict both characters -->\n+        // <!-- Arrows -->\n+        {\"larr\", \"8592\"}, // leftwards arrow, U+2190 ISOnum -->\n+        {\"uarr\", \"8593\"}, // upwards arrow, U+2191 ISOnum-->\n+        {\"rarr\", \"8594\"}, // rightwards arrow, U+2192 ISOnum -->\n+        {\"darr\", \"8595\"}, // downwards arrow, U+2193 ISOnum -->\n+        {\"harr\", \"8596\"}, // left right arrow, U+2194 ISOamsa -->\n+        {\"crarr\", \"8629\"}, // downwards arrow with corner leftwards= carriage return, U+21B5 NEW -->\n+        {\"lArr\", \"8656\"}, // leftwards double arrow, U+21D0 ISOtech -->\n+        // <!-- ISO 10646 does not say that lArr is the same as the 'is implied by'\n+        // arrow but also does not have any other character for that function.\n+        // So ? lArr canbe used for 'is implied by' as ISOtech suggests -->\n+        {\"uArr\", \"8657\"}, // upwards double arrow, U+21D1 ISOamsa -->\n+        {\"rArr\", \"8658\"}, // rightwards double arrow,U+21D2 ISOtech -->\n+        // <!-- ISO 10646 does not say this is the 'implies' character but does not\n+        // have another character with this function so ?rArr can be used for\n+        // 'implies' as ISOtech suggests -->\n+        {\"dArr\", \"8659\"}, // downwards double arrow, U+21D3 ISOamsa -->\n+        {\"hArr\", \"8660\"}, // left right double arrow,U+21D4 ISOamsa -->\n+        // <!-- Mathematical Operators -->\n+        {\"forall\", \"8704\"}, // for all, U+2200 ISOtech -->\n+        {\"part\", \"8706\"}, // partial differential, U+2202 ISOtech -->\n+        {\"exist\", \"8707\"}, // there exists, U+2203 ISOtech -->\n+        {\"empty\", \"8709\"}, // empty set = null set = diameter,U+2205 ISOamso -->\n+        {\"nabla\", \"8711\"}, // nabla = backward difference,U+2207 ISOtech -->\n+        {\"isin\", \"8712\"}, // element of, U+2208 ISOtech -->\n+        {\"notin\", \"8713\"}, // not an element of, U+2209 ISOtech -->\n+        {\"ni\", \"8715\"}, // contains as member, U+220B ISOtech -->\n+        // <!-- should there be a more memorable name than 'ni'? -->\n+        {\"prod\", \"8719\"}, // n-ary product = product sign,U+220F ISOamsb -->\n+        // <!-- prod is NOT the same character as U+03A0 'greek capital letter pi'\n+        // though the same glyph might be used for both -->\n+        {\"sum\", \"8721\"}, // n-ary summation, U+2211 ISOamsb -->\n+        // <!-- sum is NOT the same character as U+03A3 'greek capital letter sigma'\n+        // though the same glyph might be used for both -->\n+        {\"minus\", \"8722\"}, // minus sign, U+2212 ISOtech -->\n+        {\"lowast\", \"8727\"}, // asterisk operator, U+2217 ISOtech -->\n+        {\"radic\", \"8730\"}, // square root = radical sign,U+221A ISOtech -->\n+        {\"prop\", \"8733\"}, // proportional to, U+221D ISOtech -->\n+        {\"infin\", \"8734\"}, // infinity, U+221E ISOtech -->\n+        {\"ang\", \"8736\"}, // angle, U+2220 ISOamso -->\n+        {\"and\", \"8743\"}, // logical and = wedge, U+2227 ISOtech -->\n+        {\"or\", \"8744\"}, // logical or = vee, U+2228 ISOtech -->\n+        {\"cap\", \"8745\"}, // intersection = cap, U+2229 ISOtech -->\n+        {\"cup\", \"8746\"}, // union = cup, U+222A ISOtech -->\n+        {\"int\", \"8747\"}, // integral, U+222B ISOtech -->\n+        {\"there4\", \"8756\"}, // therefore, U+2234 ISOtech -->\n+        {\"sim\", \"8764\"}, // tilde operator = varies with = similar to,U+223C ISOtech -->\n+        // <!-- tilde operator is NOT the same character as the tilde, U+007E,although\n+        // the same glyph might be used to represent both -->\n+        {\"cong\", \"8773\"}, // approximately equal to, U+2245 ISOtech -->\n+        {\"asymp\", \"8776\"}, // almost equal to = asymptotic to,U+2248 ISOamsr -->\n+        {\"ne\", \"8800\"}, // not equal to, U+2260 ISOtech -->\n+        {\"equiv\", \"8801\"}, // identical to, U+2261 ISOtech -->\n+        {\"le\", \"8804\"}, // less-than or equal to, U+2264 ISOtech -->\n+        {\"ge\", \"8805\"}, // greater-than or equal to,U+2265 ISOtech -->\n+        {\"sub\", \"8834\"}, // subset of, U+2282 ISOtech -->\n+        {\"sup\", \"8835\"}, // superset of, U+2283 ISOtech -->\n+        // <!-- note that nsup, 'not a superset of, U+2283' is not covered by the\n+        // Symbol font encoding and is not included. Should it be, for symmetry?\n+        // It is in ISOamsn --> <!ENTITY nsub\", \"8836\"},\n+        // not a subset of, U+2284 ISOamsn -->\n+        {\"sube\", \"8838\"}, // subset of or equal to, U+2286 ISOtech -->\n+        {\"supe\", \"8839\"}, // superset of or equal to,U+2287 ISOtech -->\n+        {\"oplus\", \"8853\"}, // circled plus = direct sum,U+2295 ISOamsb -->\n+        {\"otimes\", \"8855\"}, // circled times = vector product,U+2297 ISOamsb -->\n+        {\"perp\", \"8869\"}, // up tack = orthogonal to = perpendicular,U+22A5 ISOtech -->\n+        {\"sdot\", \"8901\"}, // dot operator, U+22C5 ISOamsb -->\n+        // <!-- dot operator is NOT the same character as U+00B7 middle dot -->\n+        // <!-- Miscellaneous Technical -->\n+        {\"lceil\", \"8968\"}, // left ceiling = apl upstile,U+2308 ISOamsc -->\n+        {\"rceil\", \"8969\"}, // right ceiling, U+2309 ISOamsc -->\n+        {\"lfloor\", \"8970\"}, // left floor = apl downstile,U+230A ISOamsc -->\n+        {\"rfloor\", \"8971\"}, // right floor, U+230B ISOamsc -->\n+        {\"lang\", \"9001\"}, // left-pointing angle bracket = bra,U+2329 ISOtech -->\n+        // <!-- lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation\n+        // mark' -->\n+        {\"rang\", \"9002\"}, // right-pointing angle bracket = ket,U+232A ISOtech -->\n+        // <!-- rang is NOT the same character as U+003E 'greater than' or U+203A\n+        // 'single right-pointing angle quotation mark' -->\n+        // <!-- Geometric Shapes -->\n+        {\"loz\", \"9674\"}, // lozenge, U+25CA ISOpub -->\n+        // <!-- Miscellaneous Symbols -->\n+        {\"spades\", \"9824\"}, // black spade suit, U+2660 ISOpub -->\n+        // <!-- black here seems to mean filled as opposed to hollow -->\n+        {\"clubs\", \"9827\"}, // black club suit = shamrock,U+2663 ISOpub -->\n+        {\"hearts\", \"9829\"}, // black heart suit = valentine,U+2665 ISOpub -->\n+        {\"diams\", \"9830\"}, // black diamond suit, U+2666 ISOpub -->\n+\n+        // <!-- Latin Extended-A -->\n+        {\"OElig\", \"338\"}, // -- latin capital ligature OE,U+0152 ISOlat2 -->\n+        {\"oelig\", \"339\"}, // -- latin small ligature oe, U+0153 ISOlat2 -->\n+        // <!-- ligature is a misnomer, this is a separate character in some languages -->\n+        {\"Scaron\", \"352\"}, // -- latin capital letter S with caron,U+0160 ISOlat2 -->\n+        {\"scaron\", \"353\"}, // -- latin small letter s with caron,U+0161 ISOlat2 -->\n+        {\"Yuml\", \"376\"}, // -- latin capital letter Y with diaeresis,U+0178 ISOlat2 -->\n+        // <!-- Spacing Modifier Letters -->\n+        {\"circ\", \"710\"}, // -- modifier letter circumflex accent,U+02C6 ISOpub -->\n+        {\"tilde\", \"732\"}, // small tilde, U+02DC ISOdia -->\n+        // <!-- General Punctuation -->\n+        {\"ensp\", \"8194\"}, // en space, U+2002 ISOpub -->\n+        {\"emsp\", \"8195\"}, // em space, U+2003 ISOpub -->\n+        {\"thinsp\", \"8201\"}, // thin space, U+2009 ISOpub -->\n+        {\"zwnj\", \"8204\"}, // zero width non-joiner,U+200C NEW RFC 2070 -->\n+        {\"zwj\", \"8205\"}, // zero width joiner, U+200D NEW RFC 2070 -->\n+        {\"lrm\", \"8206\"}, // left-to-right mark, U+200E NEW RFC 2070 -->\n+        {\"rlm\", \"8207\"}, // right-to-left mark, U+200F NEW RFC 2070 -->\n+        {\"ndash\", \"8211\"}, // en dash, U+2013 ISOpub -->\n+        {\"mdash\", \"8212\"}, // em dash, U+2014 ISOpub -->\n+        {\"lsquo\", \"8216\"}, // left single quotation mark,U+2018 ISOnum -->\n+        {\"rsquo\", \"8217\"}, // right single quotation mark,U+2019 ISOnum -->\n+        {\"sbquo\", \"8218\"}, // single low-9 quotation mark, U+201A NEW -->\n+        {\"ldquo\", \"8220\"}, // left double quotation mark,U+201C ISOnum -->\n+        {\"rdquo\", \"8221\"}, // right double quotation mark,U+201D ISOnum -->\n+        {\"bdquo\", \"8222\"}, // double low-9 quotation mark, U+201E NEW -->\n+        {\"dagger\", \"8224\"}, // dagger, U+2020 ISOpub -->\n+        {\"Dagger\", \"8225\"}, // double dagger, U+2021 ISOpub -->\n+        {\"permil\", \"8240\"}, // per mille sign, U+2030 ISOtech -->\n+        {\"lsaquo\", \"8249\"}, // single left-pointing angle quotation mark,U+2039 ISO proposed -->\n+        // <!-- lsaquo is proposed but not yet ISO standardized -->\n+        {\"rsaquo\", \"8250\"}, // single right-pointing angle quotation mark,U+203A ISO proposed -->\n+        // <!-- rsaquo is proposed but not yet ISO standardized -->\n+        {\"euro\", \"8364\"}, // -- euro sign, U+20AC NEW -->\n     };\n \n     /**\n-     * <p>The set of entities supported by standard XML.</p>\n+     * <p>\n+     * The set of entities supported by standard XML.\n+     * </p>\n      */\n     public static final Entities XML;\n \n     /**\n-     * <p>The set of entities supported by HTML 3.2.</p>\n+     * <p>\n+     * The set of entities supported by HTML 3.2.\n+     * </p>\n      */\n     public static final Entities HTML32;\n \n     /**\n-     * <p>The set of entities supported by HTML 4.0.</p>\n+     * <p>\n+     * The set of entities supported by HTML 4.0.\n+     * </p>\n      */\n     public static final Entities HTML40;\n \n     }\n \n     /**\n-     * <p>Fills the specified entities instance with HTML 40 entities.</p>\n-     * \n-     * @param entities the instance to be filled.\n+     * <p>\n+     * Fills the specified entities instance with HTML 40 entities.\n+     * </p>\n+     * \n+     * @param entities\n+     *            the instance to be filled.\n      */\n     static void fillWithHtml40Entities(Entities entities) {\n         entities.addEntities(BASIC_ARRAY);\n \n     static interface EntityMap {\n         /**\n-         * <p>Add an entry to this entity map.</p>\n+         * <p>\n+         * Add an entry to this entity map.\n+         * </p>\n          * \n-         * @param name the entity name\n-         * @param value the entity value\n+         * @param name\n+         *            the entity name\n+         * @param value\n+         *            the entity value\n          */\n         void add(String name, int value);\n \n         /**\n-         * <p>Returns the name of the entity identified by the specified value.</p>\n+         * <p>\n+         * Returns the name of the entity identified by the specified value.\n+         * </p>\n          * \n-         * @param value the value to locate\n+         * @param value\n+         *            the value to locate\n          * @return entity name associated with the specified value\n          */\n         String name(int value);\n \n         /**\n-         * <p>Returns the value of the entity identified by the specified name.</p>\n+         * <p>\n+         * Returns the value of the entity identified by the specified name.\n+         * </p>\n          * \n-         * @param name the name to locate\n+         * @param name\n+         *            the name to locate\n          * @return entity value associated with the specified name\n          */\n         int value(String name);\n \n     static class PrimitiveEntityMap implements EntityMap {\n         private Map mapNameToValue = new HashMap();\n+\n         private IntHashMap mapValueToName = new IntHashMap();\n \n         /**\n         }\n     }\n \n-\n     static abstract class MapIntMap implements Entities.EntityMap {\n         protected Map mapNameToValue;\n+\n         protected Map mapValueToName;\n \n         /**\n     }\n \n     static class TreeEntityMap extends MapIntMap {\n-      /**\n-       * Constructs a new instance of <code>TreeEntityMap</code>.\n-       */\n+        /**\n+         * Constructs a new instance of <code>TreeEntityMap</code>.\n+         */\n         public TreeEntityMap() {\n             mapNameToValue = new TreeMap();\n             mapValueToName = new TreeMap();\n \n     static class LookupEntityMap extends PrimitiveEntityMap {\n         private String[] lookupTable;\n+\n         private int LOOKUP_TABLE_SIZE = 256;\n \n         /**\n         }\n \n         /**\n-         * <p>Returns the lookup table for this entity map. The lookup table is created if it has not been \n-         * previously.</p>\n+         * <p>\n+         * Returns the lookup table for this entity map. The lookup table is created if it has not been previously.\n+         * </p>\n          * \n          * @return the lookup table\n          */\n         }\n \n         /**\n-         * <p>Creates an entity lookup table of LOOKUP_TABLE_SIZE elements, initialized with entity names.</p>\n+         * <p>\n+         * Creates an entity lookup table of LOOKUP_TABLE_SIZE elements, initialized with entity names.\n+         * </p>\n          */\n         private void createLookupTable() {\n             lookupTable = new String[LOOKUP_TABLE_SIZE];\n \n     static class ArrayEntityMap implements EntityMap {\n         protected int growBy = 100;\n+\n         protected int size = 0;\n+\n         protected String[] names;\n+\n         protected int[] values;\n \n         /**\n         }\n \n         /**\n-         * Constructs a new instance of <code>ArrayEntityMap</code>\n-         * specifying the size by which the array should grow.\n+         * Constructs a new instance of <code>ArrayEntityMap</code> specifying the size by which the array should\n+         * grow.\n          * \n-         * @param growBy array will be initialized to and will grow by this amount\n+         * @param growBy\n+         *            array will be initialized to and will grow by this amount\n          */\n         public ArrayEntityMap(int growBy) {\n             this.growBy = growBy;\n         /**\n          * Verifies the capacity of the entity array, adjusting the size if necessary.\n          * \n-         * @param capacity size the array should be\n+         * @param capacity\n+         *            size the array should be\n          */\n         protected void ensureCapacity(int capacity) {\n             if (capacity > names.length) {\n          * Constructs a new instance of <code>BinaryEntityMap</code>.\n          */\n         public BinaryEntityMap() {\n-          super();\n-        }\n-\n-        /**\n-         * Constructs a new instance of <code>ArrayEntityMap</code>\n-         * specifying the size by which the underlying array should grow.\n+            super();\n+        }\n+\n+        /**\n+         * Constructs a new instance of <code>ArrayEntityMap</code> specifying the size by which the underlying array\n+         * should grow.\n          * \n-         * @param growBy array will be initialized to and will grow by this amount\n+         * @param growBy\n+         *            array will be initialized to and will grow by this amount\n          */\n         public BinaryEntityMap(int growBy) {\n             super(growBy);\n         }\n \n         /**\n-         * Performs a binary search of the entity array for the specified key.\n-         * This method is based on code in {@link java.util.Arrays}.\n+         * Performs a binary search of the entity array for the specified key. This method is based on code in\n+         * {@link java.util.Arrays}.\n          * \n-         * @param key the key to be found\n+         * @param key\n+         *            the key to be found\n          * @return the index of the entity array matching the specified key\n          */\n         private int binarySearch(int key) {\n                     return mid; // key found\n                 }\n             }\n-            return -(low + 1);  // key not found.\n+            return -(low + 1); // key not found.\n         }\n \n         /**\n             ensureCapacity(size + 1);\n             int insertAt = binarySearch(value);\n             if (insertAt > 0) {\n-                return;    // note: this means you can't insert the same value twice\n-            }\n-            insertAt = -(insertAt + 1);  // binarySearch returns it negative and off-by-one\n+                return; // note: this means you can't insert the same value twice\n+            }\n+            insertAt = -(insertAt + 1); // binarySearch returns it negative and off-by-one\n             System.arraycopy(values, insertAt, values, insertAt + 1, size - insertAt);\n             values[insertAt] = value;\n             System.arraycopy(names, insertAt, names, insertAt + 1, size - insertAt);\n     EntityMap map = new Entities.LookupEntityMap();\n \n     /**\n-     * <p>Adds entities to this entity.</p>\n-     * \n-     * @param entityArray array of entities to be added\n+     * <p>\n+     * Adds entities to this entity.\n+     * </p>\n+     * \n+     * @param entityArray\n+     *            array of entities to be added\n      */\n     public void addEntities(String[][] entityArray) {\n         for (int i = 0; i < entityArray.length; ++i) {\n     }\n \n     /**\n-     * <p>Add an entity to this entity.</p>\n-     * \n-     * @param name name of the entity\n-     * @param value vale of the entity\n+     * <p>\n+     * Add an entity to this entity.\n+     * </p>\n+     * \n+     * @param name\n+     *            name of the entity\n+     * @param value\n+     *            vale of the entity\n      */\n     public void addEntity(String name, int value) {\n         map.add(name, value);\n     }\n \n     /**\n-     * <p>Returns the name of the entity identified by the specified value.</p>\n-     * \n-     * @param value the value to locate\n+     * <p>\n+     * Returns the name of the entity identified by the specified value.\n+     * </p>\n+     * \n+     * @param value\n+     *            the value to locate\n      * @return entity name associated with the specified value\n      */\n     public String entityName(int value) {\n     }\n \n     /**\n-     * <p>Returns the value of the entity identified by the specified name.</p>\n-     * \n-     * @param name the name to locate\n+     * <p>\n+     * Returns the value of the entity identified by the specified name.\n+     * </p>\n+     * \n+     * @param name\n+     *            the name to locate\n      * @return entity value associated with the specified name\n      */\n     public int entityValue(String name) {\n     }\n \n     /**\n-     * <p>Escapes the characters in a <code>String</code>.</p>\n-     *\n-     * <p>For example, if you have called addEntity(&quot;foo&quot;, 0xA1),\n-     * escape(&quot;\\u00A1&quot;) will return &quot;&amp;foo;&quot;</p>\n-     *\n-     * @param str The <code>String</code> to escape.\n+     * <p>\n+     * Escapes the characters in a <code>String</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * For example, if you have called addEntity(&quot;foo&quot;, 0xA1), escape(&quot;\\u00A1&quot;) will return\n+     * &quot;&amp;foo;&quot;\n+     * </p>\n+     * \n+     * @param str\n+     *            The <code>String</code> to escape.\n      * @return A new escaped <code>String</code>.\n      */\n     public String escape(String str) {\n-        //todo: rewrite to use a Writer\n-        StringBuffer buf = new StringBuffer(str.length() * 2);\n-        int i;\n-        for (i = 0; i < str.length(); ++i) {\n-            char ch = str.charAt(i);\n-            String entityName = this.entityName(ch);\n-            if (entityName == null) {\n-                if (ch > 0x7F) {\n-                    int intValue = ch;\n-                    buf.append(\"&#\");\n-                    buf.append(intValue);\n-                    buf.append(';');\n-                } else {\n-                    buf.append(ch);\n-                }\n-            } else {\n-                buf.append('&');\n-                buf.append(entityName);\n-                buf.append(';');\n-            }\n-        }\n-        return buf.toString();\n-    }\n-\n-    /**\n-     * <p>Escapes the characters in the <code>String</code> passed and writes the result\n-     * to the <code>Writer</code> passed. </p>\n-     * \n-     * @param writer The <code>Writer</code> to write the results of the escaping to.\n-     *                            Assumed to be a non-null value.\n-     * @param str The <code>String</code> to escape. Assumed to be a non-null value.\n-     * @throws IOException when <code>Writer</code> passed throws the exception from\n-     *                                       calls to the {@link Writer#write(int)} methods.\n-     *                                       \n+        StringWriter stringWriter = newStringWriter(str);\n+        this.escape(stringWriter, str);\n+        return stringWriter.toString();\n+    }\n+\n+    /**\n+     * <p>\n+     * Escapes the characters in the <code>String</code> passed and writes the result to the <code>Writer</code>\n+     * passed.\n+     * </p>\n+     * \n+     * @param writer\n+     *            The <code>Writer</code> to write the results of the escaping to. Assumed to be a non-null value.\n+     * @param str\n+     *            The <code>String</code> to escape. Assumed to be a non-null value.\n+     * @throws IOException\n+     *             when <code>Writer</code> passed throws the exception from calls to the {@link Writer#write(int)}\n+     *             methods.\n+     * \n      * @see #escape(String)\n      * @see Writer\n      */\n             }\n         }\n     }\n-    \n-    /**\n-     * <p>Unescapes the entities in a <code>String</code>.</p>\n-     *\n-     * <p>For example, if you have called addEntity(&quot;foo&quot;, 0xA1),\n-     * unescape(&quot;&amp;foo;&quot;) will return &quot;\\u00A1&quot;</p>\n-     *\n-     * @param str The <code>String</code> to escape.\n+\n+    /**\n+     * <p>\n+     * Escapes the characters in the <code>String</code> passed and writes the result to the <code>StringWriter</code>\n+     * passed.\n+     * </p>\n+     * \n+     * @param writer\n+     *            The <code>StringWriter</code> to write the results of the escaping to. Assumed to be a non-null\n+     *            value.\n+     * @param str\n+     *            The <code>String</code> to escape. Assumed to be a non-null value.\n+     * \n+     * @see #escape(String)\n+     * @see Writer\n+     * @since 2.3\n+     */\n+    public void escape(StringWriter writer, String str) {\n+        try {\n+            this.escape((Writer) writer, str);\n+        } catch (IOException e) {\n+            // This should never happen because ALL the StringWriter methods called by #escape(Writer, String) do not\n+            // throw IOExceptions.\n+            throw new UnhandledException(e);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Unescapes the entities in a <code>String</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * For example, if you have called addEntity(&quot;foo&quot;, 0xA1), unescape(&quot;&amp;foo;&quot;) will return\n+     * &quot;\\u00A1&quot;\n+     * </p>\n+     * \n+     * @param str\n+     *            The <code>String</code> to escape.\n      * @return A new escaped <code>String</code>.\n      */\n     public String unescape(String str) {\n-        int firstAmp = str.indexOf('&');\n-        if (firstAmp < 0) {\n-            return str;\n-        }\n-\n-        StringBuffer buf = new StringBuffer(str.length());\n-        buf.append(str.substring(0, firstAmp));\n-        for (int i = firstAmp; i < str.length(); ++i) {\n-            char ch = str.charAt(i);\n-            if (ch == '&') {\n-                int semi = str.indexOf(';', i + 1);\n-                if (semi == -1) {\n-                    buf.append(ch);\n-                    continue;\n-                }\n-                int amph = str.indexOf('&', i + 1);\n-                if( amph != -1 && amph < semi ) {\n-                    // Then the text looks like &...&...;\n-                    buf.append(ch);\n-                    continue;\n-                }\n-                String entityName = str.substring(i + 1, semi);\n-                int entityValue;\n-                if (entityName.length() == 0) {\n-                    entityValue = -1;\n-                } else if (entityName.charAt(0) == '#') {\n-                    if (entityName.length() == 1) {\n-                        entityValue = -1;\n-                    } else {\n-                        char charAt1 = entityName.charAt(1);\n-                        try {\n-                            if (charAt1 == 'x' || charAt1=='X') {\n-                                entityValue = Integer.valueOf(entityName.substring(2), 16).intValue();\n-                            } else {\n-                                entityValue = Integer.parseInt(entityName.substring(1));\n-                            }\n-                            if (entityValue > 0xFFFF) {\n-                                entityValue = -1;\n-                            }\n-                        } catch (NumberFormatException ex) {\n-                            entityValue = -1;\n-                        }\n-                    }\n-                } else {\n-                    entityValue = this.entityValue(entityName);\n-                }\n-                if (entityValue == -1) {\n-                    buf.append('&');\n-                    buf.append(entityName);\n-                    buf.append(';');\n-                } else {\n-                    buf.append((char) (entityValue));\n-                }\n-                i = semi;\n-            } else {\n-                buf.append(ch);\n-            }\n-        }\n-        return buf.toString();\n-    }\n-\n-    /**\n-     * <p>Unescapes the escaped entities in the <code>String</code> passed and\n-     * writes the result to the <code>Writer</code> passed.</p>\n-     * \n-     * @param writer The <code>Writer</code> to write the results to; assumed to be non-null.\n-     * @param string The <code>String</code> to write the results to; assumed to be non-null.\n-     * @throws IOException when <code>Writer</code> passed throws the exception from\n-     *                                       calls to the {@link Writer#write(int)} methods.\n-     *                                       \n+        // Make the StringWriter larger than the source String to avoid growing the writer.\n+        StringWriter stringWriter = newStringWriter(str);\n+        this.unescape(stringWriter, str);\n+        return stringWriter.toString();\n+    }\n+\n+    private StringWriter newStringWriter(String str) {\n+        // Make the StringWriter 10% larger than the source String to avoid growing the writer\n+        return new StringWriter((int) (str.length() + (str.length() * 0.1)));\n+    }\n+\n+    /**\n+     * <p>\n+     * Unescapes the escaped entities in the <code>String</code> passed and writes the result to the\n+     * <code>StringWriter</code> passed.\n+     * </p>\n+     * \n+     * @param writer\n+     *            The <code>StringWriter</code> to write the results to; assumed to be non-null.\n+     * @param string\n+     *            The <code>String</code> to write the results to; assumed to be non-null.\n+     * \n+     * @see #escape(String)\n+     * @see Writer\n+     * @since 2.3\n+     */\n+    public void unescape(StringWriter writer, String string) {\n+        try {\n+            this.unescape((Writer) writer, string);\n+        } catch (IOException e) {\n+            // This should never happen because ALL the StringWriter methods called by #escape(Writer, String) do not\n+            // throw IOExceptions.\n+            throw new UnhandledException(e);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Unescapes the escaped entities in the <code>String</code> passed and writes the result to the\n+     * <code>Writer</code> passed.\n+     * </p>\n+     * \n+     * @param writer\n+     *            The <code>Writer</code> to write the results to; assumed to be non-null.\n+     * @param string\n+     *            The <code>String</code> to write the results to; assumed to be non-null.\n+     * @throws IOException\n+     *             when <code>Writer</code> passed throws the exception from calls to the {@link Writer#write(int)}\n+     *             methods.\n+     * \n      * @see #escape(String)\n      * @see Writer\n      */\n         for (int i = firstAmp; i < len; i++) {\n             char c = string.charAt(i);\n             if (c == '&') {\n-                int nextIdx = i+1;\n+                int nextIdx = i + 1;\n                 int semiColonIdx = string.indexOf(';', nextIdx);\n                 if (semiColonIdx == -1) {\n                     writer.write(c);\n                     continue;\n                 }\n                 int amphersandIdx = string.indexOf('&', i + 1);\n-                if( amphersandIdx != -1 && amphersandIdx < semiColonIdx ) {\n+                if (amphersandIdx != -1 && amphersandIdx < semiColonIdx) {\n                     // Then the text looks like &...&...;\n                     writer.write(c);\n                     continue;\n                 int entityValue = -1;\n                 int entityContentLen = entityContent.length();\n                 if (entityContentLen > 0) {\n-                    if (entityContent.charAt(0) == '#') { //escaped value content is an integer (decimal or hexidecimal)\n-                        if (entityContentLen > 1) {  \n+                    if (entityContent.charAt(0) == '#') { // escaped value content is an integer (decimal or\n+                        // hexidecimal)\n+                        if (entityContentLen > 1) {\n                             char isHexChar = entityContent.charAt(1);\n                             try {\n                                 switch (isHexChar) {\n                                 entityValue = -1;\n                             }\n                         }\n-                    } else { //escaped value content is an entity name\n+                    } else { // escaped value content is an entity name\n                         entityValue = this.entityValue(entityContent);\n                     }\n                 }\n-                \n+\n                 if (entityValue == -1) {\n                     writer.write('&');\n                     writer.write(entityContent);\n                 } else {\n                     writer.write(entityValue);\n                 }\n-                i = semiColonIdx; //move index up to the semi-colon                \n+                i = semiColonIdx; // move index up to the semi-colon\n             } else {\n                 writer.write(c);\n             }\n         }\n     }\n-    \n+\n }", "timestamp": 1167693867, "metainfo": ""}