{"sha": "15762e5c302d4c00917c024ba93a1ba9d0ea610e", "log": "Initial checkin of the Tokenizer class   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/Tokenizer.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Tokenizes a string based based on delimiters (separators)\n+ * and supporting quoting and ignored character concepts.\n+ * <p>\n+ * This class can split a String into many smaller strings. It aims to do a\n+ * similar job to java util StringTokenizer, however it offers much more\n+ * control and flexibility.\n+ * <p>\n+ * The input String is split into a number of <i>tokens</i>.\n+ * Each token is separated from the next String by a <i>delimiter</i>.\n+ * One or more delimiter characters must be specified.\n+ * <p>\n+ * The processing then strips all the <i>ignored</i> characters from each side of the token.\n+ * The token may also have <i>quotes</i> to mark an area not to be stripped or tokenized.\n+ * Empty tokens may be removed or returned as null.\n+ * <pre>\n+ * \"a,b,c\"       - Three tokens \"a\",\"b\",\"c\" (comma delimiter)\n+ * \"a, b , c\"    - Three tokens \"a\",\"b\",\"c\" (ignored space characters stripped)\n+ * \"a, \" b \", c\" - Three tokens \"a\",\" b \",\"c\" (quoted text untouched)\n+ * </pre>\n+ * <p>\n+ * By default, this tokenizer has the following properties:\n+ * <pre>\n+ * Property                     Default\n+ * ---------                    -------\n+ * delimiter                    ,  (comma)\n+ * quote                        \"  (double quote)\n+ * ignored                      char &lt;= 32 (as per trim)\n+ * emptyTokenAsNull             false\n+ * ignoreEmptyTokens            false\n+ * </pre>\n+ *\n+ * @author Matthew Inger\n+ * @author Stephen Colebourne\n+ */\n+public class Tokenizer implements ListIterator {\n+    // TODO: Constructors\n+    // TODO: Tests\n+    // TODO: Static factories CSV/StringTokenizer\n+    \n+    /**\n+     * A Matcher which matches the comma character.\n+     * Best used for <code>delimiter</code>.\n+     */\n+    public static final Matcher COMMA_MATCHER = new CharMatcher(',');\n+    /**\n+     * A Matcher which matches the double quote character.\n+     * Best used for <code>quote</code>.\n+     */\n+    public static final Matcher DOUBLE_QUOTE_MATCHER = new CharMatcher('\"');\n+    /**\n+     * A Matcher which matches the String trim() whitespace characters.\n+     * Best used for <code>ignored</code>.\n+     */\n+    public static final Matcher SPACES_MATCHER = new TrimMatcher();\n+    /**\n+     * A Matcher that matches no characters. Don't use this for delimiters!\n+     * Best used for <code>ignored</code>.\n+     */\n+    public static final Matcher NONE_MATCHER = new NoMatcher();\n+\n+    /** The text to work on */\n+    private char chars[];\n+    /** The parsed tokens */\n+    private String tokens[];\n+    /** The current iteration position */\n+    private int tokenPos;\n+\n+    /** The delimiter matcher */\n+    private Matcher delim = COMMA_MATCHER;\n+    /** The quote matcher */\n+    private Matcher quote = DOUBLE_QUOTE_MATCHER;\n+    /** The ignored matcher */\n+    private Matcher ignored = SPACES_MATCHER;\n+    /** Whether to return empty tokens as null */\n+    private boolean emptyAsNull = false;\n+    /** Whether to ignore empty tokens */\n+    private boolean ignoreEmptyTokens = false;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     * \n+     * @param input  the string which is to be parsed\n+     */\n+    public Tokenizer(String input) {\n+        this(input.toCharArray());\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter character\n+     */\n+    public Tokenizer(String input, char delim) {\n+        this(input.toCharArray(), delim);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter character\n+     */\n+    public Tokenizer(String input, CharSetMatcher delim) {\n+        this(input.toCharArray(), delim);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter character\n+     * @param quote  the field quoted string character\n+     */\n+    public Tokenizer(String input, char delim, char quote) {\n+        this(input.toCharArray(), delim, quote);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter character\n+     * @param quote  the field quoted string character\n+     */\n+    public Tokenizer(String input, CharSetMatcher delim, CharSetMatcher quote) {\n+        this(input.toCharArray(), delim, quote);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param input  the string which is to be parsed\n+     */\n+    public Tokenizer(char[] input) {\n+        super();\n+        this.chars = (char[]) input.clone();\n+        this.tokenPos = 0;\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param input  the string which is to be parsed\n+     * @param delim the field delimiter character\n+     */\n+    public Tokenizer(char[] input, char delim) {\n+        this(input);\n+        setDelimiterChar(delim);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter character\n+     */\n+    public Tokenizer(char[] input, CharSetMatcher delim) {\n+        this(input);\n+        setDelimiterMatcher(delim);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter character\n+     * @param quote  the field quoted string character\n+     */\n+    public Tokenizer(char[] input, char delim, char quote) {\n+        this(input, delim);\n+        setQuoteChar(quote);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter character\n+     * @param quote  the field quoted string character\n+     */\n+    public Tokenizer(char[] input, CharSetMatcher delim, CharSetMatcher quote) {\n+        this(input, delim);\n+        setQuoteMatcher(quote);\n+    }\n+\n+    // API\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of tokens found in the String.\n+     * \n+     * @return the number of matched tokens\n+     */\n+    public int size() {\n+        tokenize();\n+        return tokens.length;\n+    }\n+\n+    /**\n+     * Gets the next token from the String.\n+     * \n+     * @return the next sequential token, or null when no more tokens are found\n+     */\n+    public String nextToken() {\n+        if (hasNext()) {\n+            return tokens[tokenPos++];\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Gets the previous token from the String.\n+     * \n+     * @return the previous sequential token, or null when no more tokens are found\n+     */\n+    public String previousToken() {\n+        if (hasPrevious()) {\n+            return tokens[--tokenPos];\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Gets a copy of the full token list.\n+     * \n+     * @return the tokens as a String array\n+     */\n+    public String[] getAllTokens() {\n+        tokenize();\n+        return (String[]) tokens.clone();\n+    }\n+\n+    /**\n+     * Resets this tokenizer, forgetting all parsing and iteration already completed.\n+     * <p>\n+     * This method allows the same tokenizer to be reused for the same String.\n+     */\n+    public void reset() {\n+        tokenPos = 0;\n+        tokens = null;\n+    }\n+\n+    // ListIterator\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether there are any more tokens.\n+     * \n+     * @return true if there are more tokens\n+     */\n+    public boolean hasNext() {\n+        tokenize();\n+        return (tokenPos < tokens.length);\n+    }\n+\n+    /**\n+     * Gets the next token. This method is equivalent to {@link #nextToken()}.\n+     * \n+     * @return the next String token\n+     */\n+    public Object next() {\n+        return nextToken();\n+    }\n+\n+    /**\n+     * Gets the index of the next token to return.\n+     * \n+     * @return the next token index\n+     */\n+    public int nextIndex() {\n+        return tokenPos;\n+    }\n+\n+    /**\n+     * Checks whether there are any previous tokens that can be iterated to.\n+     * \n+     * @return true if there are previous tokens\n+     */\n+    public boolean hasPrevious() {\n+        tokenize();\n+        return (tokenPos > 0);\n+    }\n+\n+    /**\n+     * Gets the token previous to the last returned token.\n+     * \n+     * @return the previous token\n+     */\n+    public Object previous() {\n+        return previousToken();\n+    }\n+\n+    /**\n+     * Gets the index of the previous token.\n+     * \n+     * @return the previous token index\n+     */\n+    public int previousIndex() {\n+        return (tokenPos - 1);\n+    }\n+\n+    /**\n+     * Unsupported ListIterator operation.\n+     *\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() is unsupported\");\n+    }\n+\n+    /**\n+     * Unsupported ListIterator operation.\n+     *\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void set(Object obj) {\n+        throw new UnsupportedOperationException(\"set() is unsupported\");\n+    }\n+\n+    /**\n+     * Unsupported ListIterator operation.\n+     *\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void add(Object obj) {\n+        throw new UnsupportedOperationException(\"add() is unsupported\");\n+    }\n+\n+    // Implementation\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Performs the tokenization if it hasn't already been done.\n+     */\n+    private void tokenize() {\n+        if (tokens == null) {\n+            this.tokens = readTokens();\n+        }\n+    }\n+\n+    /**\n+     * Read all the tokens.\n+     */\n+    private String[] readTokens() {\n+        int len = chars.length;\n+        char cbuf[] = new char[len];\n+        StringBuffer token = new StringBuffer();\n+        int start = 0;\n+        List tokens = new ArrayList();\n+        String tok = null;\n+\n+        // Keep going until we run out of characters\n+        while (start < len) {\n+            // read the next token\n+            start = readNextToken(start, cbuf, token);\n+            tok = token.toString();\n+\n+            // Add the token, following the rules\n+            // in this object\n+            addToken(tokens, tok);\n+\n+            // Reset the string buffer to zero length\n+            token.setLength(0);\n+\n+            // Handle the special case where the very last\n+            // character is a delimiter, in which case, we\n+            // need another empty string\n+            if (start == len && delim.isMatch(chars[start - 1])) {\n+                // Add the token, following the rules\n+                // in this object\n+                addToken(tokens, new String());\n+            }\n+        }\n+\n+        return (String[]) tokens.toArray(new String[tokens.size()]);\n+    }\n+\n+    /**\n+     * Adds a token to a list, paying attention to the parameters we've set.\n+     * \n+     * @param list  the list to add to\n+     * @param tok  the token to add\n+     */\n+    private void addToken(List list, String tok) {\n+        if (tok == null || tok.length() == 0) {\n+            if (ignoreEmptyTokens) {\n+                return;\n+            }\n+            if (emptyAsNull) {\n+                tok = null;\n+            }\n+        }\n+        list.add(tok);\n+    }\n+\n+    /**\n+     * Reads character by character through the String to get the next token.\n+     * \n+     * @param start  the first character of field\n+     * @param cbuf  a character buffer for temporary computations (so we\n+     *  don't have to keep recreating one)\n+     * @param token  a StringBuffer where the output token will go\n+     * @return the starting position of the next field (the character\n+     *  immediately after the delimiter, or if end of string found,\n+     *  then the length of string\n+     */\n+    private int readNextToken(int start, char cbuf[], StringBuffer token) {\n+        token.setLength(0);\n+        int len = chars.length;\n+\n+        // skip all leading whitespace, unless it is the\n+        // field delimiter or the quote character\n+        while (start < len &&\n+                ignored.isMatch(chars[start]) &&\n+                !delim.isMatch(chars[start]) &&\n+                !quote.isMatch(chars[start])) {\n+            start++;\n+        }\n+\n+        // Read the token depending on what the first\n+        // character is like\n+        if (delim.isMatch(chars[start])) {\n+            start = readEmpty(start, token);\n+        } else if (quote.isMatch(chars[start])) {\n+            start = readQuoted(start, cbuf, token);\n+        } else {\n+            start = readUnquoted(start, token);\n+        }\n+\n+        return start;\n+    }\n+\n+    /**\n+     * Reads a quoted string token.\n+     * \n+     * @param start The first character of field (this will be the quote\n+     *              character)\n+     * @param cbuf A character buffer for temporary computations (so we\n+     *             don't have to keep recreating one)\n+     * @param token A StringBuffer where the output token will go.\n+     * @return The starting position of the next field (the character\n+     *         immediately after the delimiter, or if end of string found,\n+     *         then the length of string.\n+     */\n+    private int readQuoted(int start, char cbuf[], StringBuffer token) {\n+        // Loop until we've found the end of the quoted\n+        // string or the end of the input\n+        int cbufcnt = 0;\n+        int nd = start + 1;\n+        boolean done = false;\n+        boolean quoting = true;\n+        int len = chars.length;\n+\n+        while (nd < len && !done) {\n+            // Quoting mode can occur several times throughout\n+            // a given string, so must switch between quoting\n+            // and non-quoting until we encounter a non-quoted\n+            // delimiter, or end of string, which inidicates end\n+            // of token.\n+            if (quoting) {\n+                // If we've found a quote character, see if it's\n+                // followed by a second quote.  If so, then we need\n+                // to actually put the quote character into the token\n+                // rather than end the token.\n+                if (quote.isMatch(chars[nd]) &&\n+                        nd + 1 < len &&\n+                        chars[nd + 1] == chars[nd]) {\n+                    cbuf[cbufcnt++] = chars[nd];\n+                    nd++;\n+                }\n+                // End the quoting if we get to this condition\n+                else if (quote.isMatch(chars[nd])) {\n+                    quoting = false;\n+                }\n+                // Otherwise, just put the character into the token\n+                else {\n+                    cbuf[cbufcnt++] = chars[nd];\n+                }\n+                nd++;\n+            }\n+            // If we're not in quoting mode, if we encounter\n+            // a delimiter, the token is ended.  If we encounter\n+            // a quote, we start quoting mode, otherwise, just append\n+            // the character\n+            else {\n+                // If we're\n+                if (delim.isMatch(chars[nd])) {\n+                    done = true;\n+                } else {\n+                    if (quote.isMatch(chars[nd])) {\n+                        quoting = true;\n+                    } else {\n+                        cbuf[cbufcnt++] = chars[nd];\n+                    }\n+                    nd++;\n+                }\n+            }\n+        }\n+\n+        token.append(cbuf, 0, cbufcnt);\n+\n+        return nd + 1;\n+    }\n+\n+    /**\n+     * Read an unquoted string until a delimiter is found.\n+     * \n+     * @param start  the first character of field\n+     * @param token  a StringBuffer where the output token will go.\n+     * @return  the starting position of the next field (the character\n+     *  immediately after the delimiter, or if end of string found,\n+     *  then the length of string.\n+     */\n+    private int readUnquoted(int start, StringBuffer token) {\n+        int len = chars.length;\n+        // Skip ahead until we get to a delimiter character, or\n+        // the end of the input\n+        int nd = start + 1;\n+        while (nd < len && !delim.isMatch(chars[nd])) {\n+            nd++;\n+        }\n+\n+        token.append(chars, start, Math.min(nd, len) - start);\n+\n+        return nd + 1;\n+    }\n+\n+    /**\n+     * Read an empty string (basically, if a delimiter is found right\n+     * after another delimiter).\n+     * \n+     * @param start  the first character of field (this will be the delimiter\n+     *  character)\n+     * @param token  a StringBuffer where the output token will go.\n+     * @return The starting position of the next field (the character\n+     *  immediately after the delimiter, or if end of string found,\n+     *  then the length of string.\n+     */\n+    private int readEmpty(int start, StringBuffer token) {\n+        token.setLength(0);\n+        return start + 1;\n+    }\n+\n+    // Delimiter\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field delimiter matcher.\n+     * \n+     * @return the delimiter matcher in use\n+     */\n+    public Matcher getDelimiterMatcher() {\n+        return delim;\n+    }\n+\n+    /**\n+     * Sets the field delimiter matcher.\n+     * <p>\n+     * The delimitier is used to separate one token from another.\n+     * \n+     * @param delim  the delimiter matcher to use, null ignored\n+     */\n+    public void setDelimiterMatcher(Matcher delim) {\n+        if (delim != null) {\n+            this.delim = delim;\n+        }\n+    }\n+\n+    /**\n+     * Sets the field delimiter character\n+     * \n+     * @param delim  the delimiter character to use\n+     */\n+    public void setDelimiterChar(char delim) {\n+        setDelimiterMatcher(new CharMatcher(delim));\n+    }\n+\n+    // Quote\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the quote matcher currently in use.\n+     * <p>\n+     * The quote character is used to wrap data between the tokens.\n+     * This enables delimiters to be entered as data.\n+     * The default value is '\"' (double quote).\n+     * \n+     * @return the quote matcher in use\n+     */\n+    public Matcher getQuoteMatcher() {\n+        return quote;\n+    }\n+\n+    /**\n+     * Set the quote matcher to use.\n+     * <p>\n+     * The quote character is used to wrap data between the tokens.\n+     * This enables delimiters to be entered as data.\n+     * \n+     * @param quote  the quote matcher to use, null ignored\n+     */\n+    public void setQuoteMatcher(Matcher quote) {\n+        if (quote != null) {\n+            this.quote = quote;\n+        }\n+    }\n+\n+    /**\n+     * Sets the quote character to use.\n+     * <p>\n+     * The quote character is used to wrap data between the tokens.\n+     * This enables delimiters to be entered as data.\n+     * \n+     * @param quote  the quote character to use\n+     */\n+    public void setQuoteChar(char quote) {\n+        setQuoteMatcher(new CharMatcher(quote));\n+    }\n+\n+    // Ignored\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the ignored character matcher.\n+     * <p>\n+     * These characters are ignored when parsing the String, unless they are\n+     * within a quoted region.\n+     * The default value is space (' ') and all char control characters (32 and less).\n+     * \n+     * @return the ignored matcher in use\n+     */\n+    public Matcher getIgnoredMatcher() {\n+        return ignored;\n+    }\n+\n+    /**\n+     * Set the matcher for characters to ignore.\n+     * <p>\n+     * These characters are ignored when parsing the String, unless they are\n+     * within a quoted region.\n+     * \n+     * @param ignored  the ignored matcher to use, null ignored\n+     */\n+    public void setIgnoredMatcher(Matcher ignored) {\n+        if (ignored != null) {\n+            this.ignored = ignored;\n+        }\n+    }\n+\n+    /**\n+     * Set the character to ignore.\n+     * <p>\n+     * This character is ignored when parsing the String, unless it is\n+     * within a quoted region.\n+     * \n+     * @param quote  the ignored character to use\n+     */\n+    public void setIgnoredChar(char ignored) {\n+        setIgnoredMatcher(new CharMatcher(ignored));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets whether the tokenizer currently returns empty tokens as null.\n+     * The default for this property is false.\n+     * \n+     * @return true if empty tokens are returned as null\n+     */\n+    public boolean isEmptyTokenAsNull() {\n+        return emptyAsNull;\n+    }\n+\n+    /**\n+     * Sets whether the tokenizer should return empty tokens as null.\n+     * The default for this property is false.\n+     * \n+     * @return emptyAsNull  whether empty tokens are returned as null\n+     */\n+    public void setEmptyTokenAsNull(boolean emptyAsNull) {\n+        this.emptyAsNull = emptyAsNull;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets whether the tokenizer currently ignores empty tokens.\n+     * The default for this property is false.\n+     * \n+     * @return true if empty tokens are not returned\n+     */\n+    public boolean isIgnoreEmptyTokens() {\n+        return ignoreEmptyTokens;\n+    }\n+\n+    /**\n+     * Sets whether the tokenizer should ignore and not return empty tokens.\n+     * The default for this property is false.\n+     * \n+     * @return ignoreEmptyTokens  whether empty tokens are not returned\n+     */\n+    public void setIgnoreEmptyTokens(boolean ignoreEmptyTokens) {\n+        this.ignoreEmptyTokens = ignoreEmptyTokens;\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Class used to define a set of characters for matching purposes.\n+     */\n+    public static interface Matcher {\n+        /**\n+         * Returns true if the specified character matches.\n+         * \n+         * @param ch  the character to check for\n+         * @return true if matches\n+         */\n+        boolean isMatch(char ch);\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Class used to define a set of characters for matching purposes.\n+     */\n+    public static final class CharSetMatcher implements Matcher {\n+        private char chars[];\n+\n+        /**\n+         * Constructor that creates a matcher from a character array.\n+         * \n+         * @param chars  the characters to match, must not be null\n+         */\n+        public CharSetMatcher(char chars[]) {\n+            super();\n+            this.chars = (char[]) chars.clone();\n+            Arrays.sort(this.chars);\n+        }\n+\n+        /**\n+         * Constructor that creates a matcher from a String.\n+         * \n+         * @param chars  the characters to match, must not be null\n+         */\n+        public CharSetMatcher(String chars) {\n+            this(chars.toCharArray());\n+        }\n+\n+        /**\n+         * Gets the characters being matched.\n+         * \n+         * @return the characters being matched\n+         */\n+        public char[] getChars() {\n+            return (char[]) chars.clone();\n+        }\n+\n+        public boolean isMatch(char c) {\n+            return (Arrays.binarySearch(chars, c) >= 0);\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Class used to define a character for matching purposes.\n+     */\n+    public static final class CharMatcher implements Matcher {\n+        private char ch;\n+\n+        /**\n+         * Constructor that creates a matcher that matches a single character.\n+         * \n+         * @param chars  the character to match\n+         */\n+        public CharMatcher(char ch) {\n+            super();\n+            this.ch = ch;\n+        }\n+\n+        /**\n+         * Gets the character being matched.\n+         * \n+         * @return the character being matched\n+         */\n+        public char getChar() {\n+            return this.ch;\n+        }\n+\n+        public boolean isMatch(char ch) {\n+            return (this.ch == ch);\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Class used to match no characters.\n+     */\n+    static final class NoMatcher implements Matcher {\n+\n+        NoMatcher() {\n+            super();\n+        }\n+\n+        public boolean isMatch(char ch) {\n+            return false;\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Class used to match whitespace as per trim().\n+     */\n+    static final class TrimMatcher implements Matcher {\n+\n+        TrimMatcher() {\n+            super();\n+        }\n+\n+        public boolean isMatch(char ch) {\n+            return (ch <= 32);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/TokenizerTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit test for Tokenizer.\n+ *\n+ * @author Matthew Inger\n+ */\n+public class TokenizerTest extends TestCase {\n+    \n+    /**\n+     * JUnit constructor.\n+     * @param name\n+     */\n+    public TokenizerTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(TokenizerTest.class);\n+        suite.setName(\"TokenizerTest Tests\");\n+        return suite;\n+    }\n+\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test1() {\n+\n+        String input = \"a;b;c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        Tokenizer tok = new Tokenizer(input);\n+        tok.setDelimiterChar(';');\n+        String tokens [] = tok.getAllTokens();\n+\n+        String expected[] = new String[]\n+        {\n+            \"a\",\n+            \"b\",\n+            \"c\",\n+            \"d;\\\"e\",\n+            \"f\",\n+            \"\",\n+            \"\",\n+            \"\",\n+        };\n+\n+        assertTrue(tokens.length == expected.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i]\n+                    + \"' but was expected to be '\" + expected[i]\n+                    + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+\n+    public void test2() {\n+\n+        String input = \"a;b;c ;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        Tokenizer tok = new Tokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setIgnoredMatcher(Tokenizer.NONE_MATCHER);\n+        String tokens [] = tok.getAllTokens();\n+\n+        String expected[] = new String[]\n+        {\n+            \"a\",\n+            \"b\",\n+            \"c \",\n+            \"d;\\\"e\",\n+            \"f\",\n+            \" \",\n+            \" \",\n+            \"\",\n+        };\n+\n+        assertTrue(tokens.length == expected.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i]\n+                    + \"' but was expected to be '\" + expected[i]\n+                    + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+\n+    public void test3() {\n+\n+        String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        Tokenizer tok = new Tokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setIgnoredMatcher(Tokenizer.NONE_MATCHER);\n+        String tokens [] = tok.getAllTokens();\n+\n+        String expected[] = new String[]\n+        {\n+            \"a\",\n+            \"b\",\n+            \" c\",\n+            \"d;\\\"e\",\n+            \"f\",\n+            \" \",\n+            \" \",\n+            \"\",\n+        };\n+\n+        assertTrue(tokens.length == expected.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i]\n+                    + \"' but was expected to be '\" + expected[i]\n+                    + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+\n+    public void test4() {\n+\n+        String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        Tokenizer tok = new Tokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setIgnoreEmptyTokens(true);\n+        String tokens [] = tok.getAllTokens();\n+\n+        String expected[] = new String[]\n+        {\n+            \"a\",\n+            \"b\",\n+            \"c\",\n+            \"d;\\\"e\",\n+            \"f\",\n+        };\n+\n+        assertTrue(tokens.length == expected.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i]\n+                    + \"' but was expected to be '\" + expected[i]\n+                    + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+\n+    public void test5() {\n+\n+        String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        Tokenizer tok = new Tokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setEmptyTokenAsNull(true);\n+        String tokens [] = tok.getAllTokens();\n+\n+        String expected[] = new String[]\n+        {\n+            \"a\",\n+            \"b\",\n+            \"c\",\n+            \"d;\\\"e\",\n+            \"f\",\n+            null,\n+            null,\n+            null,\n+        };\n+\n+        assertTrue(tokens.length == expected.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i]\n+                    + \"' but was expected to be '\" + expected[i]\n+                    + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+\n+    public void test6() {\n+\n+        String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        Tokenizer tok = new Tokenizer(input);\n+        tok.setDelimiterChar(';');\n+//        tok.setTreatingEmptyAsNull(true);\n+        String tokens [] = tok.getAllTokens();\n+\n+        String expected[] = new String[]\n+        {\n+            \"a\",\n+            \"b\",\n+            \" c\",\n+            \"d;\\\"e\",\n+            \"f\",\n+            null,\n+            null,\n+            null,\n+        };\n+\n+        int nextCount = 0;\n+        while (tok.hasNext()) {\n+            tok.next();\n+            nextCount++;\n+        }\n+\n+        int prevCount = 0;\n+        while (tok.hasPrevious()) {\n+            tok.previous();\n+            prevCount++;\n+        }\n+\n+        assertTrue(tokens.length == expected.length);\n+\n+        assertTrue(\"could not cycle through entire token list\"\n+                + \" using the 'hasNext' and 'next' methods\",\n+                nextCount == expected.length);\n+\n+        assertTrue(\"could not cycle through entire token list\"\n+                + \" using the 'hasPrevious' and 'previous' methods\",\n+                prevCount == expected.length);\n+\n+    }\n+\n+\n+    public void test7() {\n+\n+        String input = \"a   b c \\\"d e\\\" f \";\n+        Tokenizer tok = new Tokenizer(input);\n+        tok.setDelimiterMatcher(Tokenizer.SPACES_MATCHER);\n+        tok.setIgnoredMatcher(Tokenizer.NONE_MATCHER);\n+        tok.setIgnoreEmptyTokens(false);\n+        String tokens [] = tok.getAllTokens();\n+\n+        String expected[] = new String[]\n+        {\n+            \"a\",\n+            \"\",\n+            \"\",\n+            \"b\",\n+            \"c\",\n+            \"d e\",\n+            \"f\",\n+            \"\",\n+        };\n+\n+        assertTrue(tokens.length == expected.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i]\n+                    + \"' but was expected to be '\" + expected[i]\n+                    + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+\n+    public void test8() {\n+\n+        String input = \"a   b c \\\"d e\\\" f \";\n+        Tokenizer tok = new Tokenizer(input);\n+        tok.setDelimiterMatcher(Tokenizer.SPACES_MATCHER);\n+        tok.setIgnoredMatcher(Tokenizer.NONE_MATCHER);\n+        tok.setIgnoreEmptyTokens(true);\n+        String tokens [] = tok.getAllTokens();\n+\n+        String expected[] = new String[]\n+        {\n+            \"a\",\n+            \"b\",\n+            \"c\",\n+            \"d e\",\n+            \"f\",\n+        };\n+\n+        assertTrue(tokens.length == expected.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i]\n+                    + \"' but was expected to be '\" + expected[i]\n+                    + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+}", "timestamp": 1069110138, "metainfo": ""}