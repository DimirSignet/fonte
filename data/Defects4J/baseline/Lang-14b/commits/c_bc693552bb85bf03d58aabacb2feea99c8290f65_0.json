{"sha": "bc693552bb85bf03d58aabacb2feea99c8290f65", "log": "Use concurrent instead of synchronization; Javadoc  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/LocaleUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/LocaleUtils.java\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Locale;\n-import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n \n /**\n  * <p>Operations to assist when working with a {@link Locale}.</p>\n  */\n public class LocaleUtils {\n \n-    /** Unmodifiable list of available locales. */\n-    //@GuardedBy(\"this\")\n-    private static List<Locale> cAvailableLocaleList; // lazily created by availableLocaleList()\n-\n-    /** Unmodifiable set of available locales. */\n-    //@GuardedBy(\"this\")\n-    private static Set<Locale> cAvailableLocaleSet;   // lazily created by availableLocaleSet()\n-\n-    /** Unmodifiable map of language locales by country. */\n-    private static final Map<String, List<Locale>> cLanguagesByCountry = \n-        Collections.synchronizedMap(new HashMap<String, List<Locale>>());\n-\n-    /** Unmodifiable map of country locales by language. */\n-    private static final Map<String, List<Locale>> cCountriesByLanguage = \n-        Collections.synchronizedMap(new HashMap<String, List<Locale>>());\n+    /** Concurrent map of language locales by country. */\n+    private static final ConcurrentMap<String, List<Locale>> cLanguagesByCountry = \n+        new ConcurrentHashMap<String, List<Locale>>();\n+\n+    /** Concurrent map of country locales by language. */\n+    private static final ConcurrentMap<String, List<Locale>> cCountriesByLanguage = \n+        new ConcurrentHashMap<String, List<Locale>>();\n \n     /**\n      * <p><code>LocaleUtils</code> instances should NOT be constructed in standard programming.\n      * </pre>\n      *\n      * @param locale  the locale to start from\n-     * @return the unmodifiable list of Locale objects, 0 being locale, never null\n+     * @return the unmodifiable list of Locale objects, 0 being locale, not null\n      */\n     public static List<Locale> localeLookupList(Locale locale) {\n         return localeLookupList(locale, locale);\n      *\n      * @param locale  the locale to start from, null returns empty list\n      * @param defaultLocale  the default locale to use if no other is found\n-     * @return the unmodifiable list of Locale objects, 0 being locale, never null\n+     * @return the unmodifiable list of Locale objects, 0 being locale, not null\n      */\n     public static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n         List<Locale> list = new ArrayList<Locale>(4);\n      * @return the unmodifiable list of available locales\n      */\n     public static List<Locale> availableLocaleList() {\n-        if(cAvailableLocaleList == null) { \n-            initAvailableLocaleList(); \n-        }\n-        return cAvailableLocaleList;\n-    }\n-\n-    /**\n-     * Initializes the availableLocaleList. It is separate from availableLocaleList() \n-     * to avoid the synchronized block affecting normal use, yet synchronized and \n-     * lazy loading to avoid a static block affecting other methods in this class. \n-     */\n-    private static synchronized void initAvailableLocaleList() {\n-        if(cAvailableLocaleList == null) {\n-            List<Locale> list = Arrays.asList(Locale.getAvailableLocales());\n-            cAvailableLocaleList = Collections.unmodifiableList(list);\n-        }\n+        return SyncAvoid.AVAILABLE_LOCALE_LIST;\n     }\n \n     //-----------------------------------------------------------------------\n      * @return the unmodifiable set of available locales\n      */\n     public static Set<Locale> availableLocaleSet() {\n-        if(cAvailableLocaleSet == null) { \n-            initAvailableLocaleSet(); \n-        }\n-        return cAvailableLocaleSet;\n-    }\n-\n-    /**\n-     * Initializes the availableLocaleSet. It is separate from availableLocaleSet() \n-     * to avoid the synchronized block affecting normal use, yet synchronized and \n-     * lazy loading to avoid a static block affecting other methods in this class. \n-     */\n-    private static synchronized void initAvailableLocaleSet() {\n-        if(cAvailableLocaleSet == null) {\n-            cAvailableLocaleSet = Collections.unmodifiableSet( new HashSet<Locale>(availableLocaleList()) );\n-        }\n+        return SyncAvoid.AVAILABLE_LOCALE_SET;\n     }\n \n     //-----------------------------------------------------------------------\n      * languages available for that country. Variant locales are removed.</p>\n      *\n      * @param countryCode  the 2 letter country code, null returns empty\n-     * @return an unmodifiable List of Locale objects, never null\n+     * @return an unmodifiable List of Locale objects, not null\n      */\n     public static List<Locale> languagesByCountry(String countryCode) {\n-        List<Locale> langs = cLanguagesByCountry.get(countryCode);  //syncd\n+        if (countryCode == null) {\n+            return Collections.emptyList();\n+        }\n+        List<Locale> langs = cLanguagesByCountry.get(countryCode);\n         if (langs == null) {\n-            if (countryCode != null) {\n-                langs = new ArrayList<Locale>();\n-                List<Locale> locales = availableLocaleList();\n-                for (int i = 0; i < locales.size(); i++) {\n-                    Locale locale = locales.get(i);\n-                    if (countryCode.equals(locale.getCountry()) &&\n-                            locale.getVariant().length() == 0) {\n-                        langs.add(locale);\n-                    }\n+            langs = new ArrayList<Locale>();\n+            List<Locale> locales = availableLocaleList();\n+            for (int i = 0; i < locales.size(); i++) {\n+                Locale locale = locales.get(i);\n+                if (countryCode.equals(locale.getCountry()) &&\n+                        locale.getVariant().length() == 0) {\n+                    langs.add(locale);\n                 }\n-                langs = Collections.unmodifiableList(langs);\n-            } else {\n-                langs = Collections.emptyList();\n-            }\n-            cLanguagesByCountry.put(countryCode, langs);  //syncd\n+            }\n+            langs = Collections.unmodifiableList(langs);\n+            cLanguagesByCountry.putIfAbsent(countryCode, langs);\n+            langs = cLanguagesByCountry.get(countryCode);\n         }\n         return langs;\n     }\n      * countries available for that language. Variant locales are removed.</p>\n      *\n      * @param languageCode  the 2 letter language code, null returns empty\n-     * @return an unmodifiable List of Locale objects, never null\n+     * @return an unmodifiable List of Locale objects, not null\n      */\n     public static List<Locale> countriesByLanguage(String languageCode) {\n-        List<Locale> countries = cCountriesByLanguage.get(languageCode);  //syncd\n+        if (languageCode == null) {\n+            return Collections.emptyList();\n+        }\n+        List<Locale> countries = cCountriesByLanguage.get(languageCode);\n         if (countries == null) {\n-            if (languageCode != null) {\n-                countries = new ArrayList<Locale>();\n-                List<Locale> locales = availableLocaleList();\n-                for (int i = 0; i < locales.size(); i++) {\n-                    Locale locale = locales.get(i);\n-                    if (languageCode.equals(locale.getLanguage()) &&\n-                            locale.getCountry().length() != 0 &&\n-                            locale.getVariant().length() == 0) {\n-                        countries.add(locale);\n-                    }\n+            countries = new ArrayList<Locale>();\n+            List<Locale> locales = availableLocaleList();\n+            for (int i = 0; i < locales.size(); i++) {\n+                Locale locale = locales.get(i);\n+                if (languageCode.equals(locale.getLanguage()) &&\n+                        locale.getCountry().length() != 0 &&\n+                        locale.getVariant().length() == 0) {\n+                    countries.add(locale);\n                 }\n-                countries = Collections.unmodifiableList(countries);\n-            } else {\n-                countries = Collections.emptyList();\n-            }\n-            cCountriesByLanguage.put(languageCode, countries);  //syncd\n+            }\n+            countries = Collections.unmodifiableList(countries);\n+            cCountriesByLanguage.putIfAbsent(languageCode, countries);\n+            countries = cCountriesByLanguage.get(languageCode);\n         }\n         return countries;\n     }\n \n+    //-----------------------------------------------------------------------\n+    // class to avoid synchronization\n+    static class SyncAvoid {\n+        /** Unmodifiable list of available locales. */\n+        private static List<Locale> AVAILABLE_LOCALE_LIST;\n+        /** Unmodifiable set of available locales. */\n+        private static Set<Locale> AVAILABLE_LOCALE_SET;\n+        \n+        static {\n+            List<Locale> list = new ArrayList<Locale>(Arrays.asList(Locale.getAvailableLocales()));  // extra safe\n+            AVAILABLE_LOCALE_LIST = Collections.unmodifiableList(list);\n+            AVAILABLE_LOCALE_SET = Collections.unmodifiableSet(new HashSet<Locale>(availableLocaleList()));\n+        }\n+    }\n+\n }", "timestamp": 1299250762, "metainfo": ""}