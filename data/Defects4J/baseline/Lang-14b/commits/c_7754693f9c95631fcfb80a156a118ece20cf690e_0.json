{"sha": "7754693f9c95631fcfb80a156a118ece20cf690e", "log": "Link builder to tokenizer properly  ", "commit": "\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n import java.io.Writer;\n import java.util.Collection;\n import java.util.Iterator;\n+import java.util.List;\n \n import org.apache.commons.lang.ArrayUtils;\n import org.apache.commons.lang.SystemUtils;\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Creates a tokenizer using the current contents of this builder.\n-     * <p>\n-     * This method allows the contents of the builder to be tokenized.\n-     * The tokenizer will be setup to tokenize on space, tab, newline\n-     * and formfeed (as per StringTokenizer). These values can be changed\n-     * on the tokenizer class, before retrieving the tokens.\n-     * <p>\n-     * Note that the internal character array is shared between the two\n-     * objects and no synchronization occurs. Once you call this method\n-     * you must complete the tokenization before altering this buffer again.\n-     *\n-     * @return a StrTokenizer instance\n+     * Creates a tokenizer that can tokenize the contents of this builder.\n+     * <p>\n+     * This method allows the contents of this builder to be tokenized.\n+     * The tokenizer will be setup by default to tokenize on space, tab,\n+     * newline and formfeed (as per StringTokenizer). These values can be\n+     * changed on the tokenizer class, before retrieving the tokens.\n+     * <p>\n+     * The returned tokenizer is linked to this builder. You may intermix\n+     * calls to the buider and tokenizer within certain limits, however\n+     * there is no synchronization. Once the tokenizer has been used once,\n+     * it must be {@link StrTokenizer#reset() reset} to pickup the latest\n+     * changes in the builder. For example:\n+     * <pre>\n+     * StrBuilder b = new StrBuilder();\n+     * b.append(\"a b \");\n+     * StrTokenizer t = b.asTokenizer();\n+     * String[] tokens1 = t.getTokenArray();  // returns a,b\n+     * b.append(\"c d \");\n+     * String[] tokens2 = t.getTokenArray();  // returns a,b (c and d ignored)\n+     * t.reset();              // reset causes builder changes to be picked up\n+     * String[] tokens3 = t.getTokenArray();  // returns a,b,c,d\n+     * </pre>\n+     * In addition to simply intermixing appends and tokenization, you can also\n+     * call the set methods on the tokenizer to alter how it tokenizes. Just\n+     * remember to call reset when you want to pickup builder changes.\n+     * <p>\n+     * Calling {@link StrTokenizer#reset(String)} or {@link StrTokenizer#reset(char[])}\n+     * with a non-null value will break the link with the builder.\n+     *\n+     * @return a tokenizer that is linked to this builder\n      */\n     public StrTokenizer asTokenizer() {\n-        return new StrTokenizer(buffer);\n+        return new StrBuilderTokenizer();\n     }\n \n     //-----------------------------------------------------------------------\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Inner class to allow StrBuilder to operate as a tokenizer.\n+     */\n+    class StrBuilderTokenizer extends StrTokenizer {\n+\n+        /** {@inheritDoc} */\n+        StrBuilderTokenizer() {\n+            super();\n+        }\n+\n+        /** {@inheritDoc} */\n+        protected List tokenize(char[] chars, int offset, int count) {\n+            if (chars == null) {\n+                return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size());\n+            } else {\n+                return super.tokenize(chars, offset, count);\n+            }\n+        }\n+\n+        /** {@inheritDoc} */\n+        public String getContent() {\n+            String str = super.getContent();\n+            if (str == null) {\n+                return StrBuilder.this.toString();\n+            } else {\n+                return str;\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Inner class to allow StrBuilder to operate as a writer.\n      */\n     class StrBuilderReader extends Reader {\n             if (ready() == false) {\n                 return -1;\n             }\n-            return charAt(pos++);\n+            return StrBuilder.this.charAt(pos++);\n         }\n \n         /** {@inheritDoc} */\n             if (len == 0) {\n                 return 0;\n             }\n-            if (pos >= size()) {\n+            if (pos >= StrBuilder.this.size()) {\n                 return -1;\n             }\n             if (pos + len > size()) {\n-                len = size() - pos;\n-            }\n-            getChars(pos, pos + len, b, off);\n+                len = StrBuilder.this.size() - pos;\n+            }\n+            StrBuilder.this.getChars(pos, pos + len, b, off);\n             pos += len;\n             return len;\n         }\n \n         /** {@inheritDoc} */\n         public long skip(long n) {\n-            if (pos + n > size()) {\n-                n = size() - pos;\n+            if (pos + n > StrBuilder.this.size()) {\n+                n = StrBuilder.this.size() - pos;\n             }\n             if (n < 0) {\n                 return 0;\n \n         /** {@inheritDoc} */\n         public boolean ready() {\n-            return pos < size();\n+            return pos < StrBuilder.this.size();\n         }\n \n         /** {@inheritDoc} */\n--- a/src/test/org/apache/commons/lang/text/StrBuilderTest.java\n+++ b/src/test/org/apache/commons/lang/text/StrBuilderTest.java\n             return 0;\n         }\n     };\n+\n+    //-----------------------------------------------------------------------\n+    public void testAsTokenizer() throws Exception {\n+        // from Javadoc\n+        StrBuilder b = new StrBuilder();\n+        b.append(\"a b \");\n+        StrTokenizer t = b.asTokenizer();\n+        \n+        String[] tokens1 = t.getTokenArray();\n+        assertEquals(2, tokens1.length);\n+        assertEquals(\"a\", tokens1[0]);\n+        assertEquals(\"b\", tokens1[1]);\n+        assertEquals(2, t.size());\n+        \n+        b.append(\"c d \");\n+        String[] tokens2 = t.getTokenArray();\n+        assertEquals(2, tokens2.length);\n+        assertEquals(\"a\", tokens2[0]);\n+        assertEquals(\"b\", tokens2[1]);\n+        assertEquals(2, t.size());\n+        assertEquals(\"a\", t.next());\n+        assertEquals(\"b\", t.next());\n+        \n+        t.reset();\n+        String[] tokens3 = t.getTokenArray();\n+        assertEquals(4, tokens3.length);\n+        assertEquals(\"a\", tokens3[0]);\n+        assertEquals(\"b\", tokens3[1]);\n+        assertEquals(\"c\", tokens3[2]);\n+        assertEquals(\"d\", tokens3[3]);\n+        assertEquals(4, t.size());\n+        assertEquals(\"a\", t.next());\n+        assertEquals(\"b\", t.next());\n+        assertEquals(\"c\", t.next());\n+        assertEquals(\"d\", t.next());\n+        \n+        assertEquals(\"a b c d \", t.getContent());\n+    }\n \n     // -----------------------------------------------------------------------\n     public void testAsReader() throws Exception {", "timestamp": 1153591816, "metainfo": ""}