{"sha": "ffe79899ff05351f5cba5156273b0d32046be5f8", "log": "Checkstyle and trailing spaces.  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n import java.io.Serializable;\n \n /**\n- * <p>Assists with the serialization process and performs additional functionality based \n+ * <p>Assists with the serialization process and performs additional functionality based\n  * on serialization.</p>\n  * <p>\n  * <ul>\n  * @version $Id$\n  */\n public class SerializationUtils {\n-    \n+\n     /**\n      * <p>SerializationUtils instances should NOT be constructed in standard programming.\n      * Instead, the class should be used as {@code SerializationUtils.clone(object)}.</p>\n      * graphs, or for those that don't support deep cloning this can\n      * be a simple alternative implementation. Of course all the objects\n      * must be {@code Serializable}.</p>\n-     * \n+     *\n+     * @param <T> the type of the object involved\n      * @param object  the {@code Serializable} object to clone\n      * @return the cloned object\n      * @throws SerializationException (runtime) if the serialization fails\n         final T result = (T) deserialize(serialize(object));\n         return result;\n     }\n-    \n+\n     // Serialize\n     //-----------------------------------------------------------------------\n     /**\n      * <p>The stream will be closed once the object is written.\n      * This avoids the need for a finally clause, and maybe also exception\n      * handling, in the application code.</p>\n-     * \n+     *\n      * <p>The stream passed in is not buffered internally within this method.\n      * This is the responsibility of your application if desired.</p>\n      *\n             // stream closed in the finally\n             out = new ObjectOutputStream(outputStream);\n             out.writeObject(obj);\n-            \n+\n         } catch (IOException ex) {\n             throw new SerializationException(ex);\n         } finally {\n      * <p>The stream will be closed once the object is written. This\n      * avoids the need for a finally clause, and maybe also exception\n      * handling, in the application code.</p>\n-     * \n+     *\n      * <p>The stream passed in is not buffered internally within this method.\n      * This is the responsibility of your application if desired.</p>\n      *\n             // stream closed in the finally\n             in = new ObjectInputStream(inputStream);\n             return in.readObject();\n-            \n+\n         } catch (ClassNotFoundException ex) {\n             throw new SerializationException(ex);\n         } catch (IOException ex) {\n         ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n         return deserialize(bais);\n     }\n-    \n+\n }", "timestamp": 1300550963, "metainfo": ""}