{"sha": "307f4c25700acee082bd5e6878bf1dc0ab05b11a", "log": "[LANG-610] Introduced ConcurrentRuntimeException and extended the exception handling methods of ConcurrentUtils to support runtime exceptions, too.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentRuntimeException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.concurrent;\n+\n+/**\n+ * <p>\n+ * An exception class used for reporting runtime error conditions related to\n+ * accessing data of background tasks.\n+ * </p>\n+ * <p>\n+ * This class is an analogon of the {@link ConcurrentException} exception class.\n+ * However, it is a runtime exception and thus does not need explicit catch\n+ * clauses. Some methods of {@link ConcurrentUtils} throw {@code\n+ * ConcurrentRuntimeException} exceptions rather than\n+ * {@link ConcurrentException} exceptions. They can be used by client code that\n+ * does not want to be bothered with checked exceptions.\n+ * </p>\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class ConcurrentRuntimeException extends RuntimeException {\n+    /**\n+     * The serial version UID.\n+     */\n+    private static final long serialVersionUID = -6582182735562919670L;\n+\n+    /**\n+     * Creates a new, uninitialized instance of {@code\n+     * ConcurrentRuntimeException}.\n+     */\n+    protected ConcurrentRuntimeException() {\n+        super();\n+    }\n+\n+    /**\n+     * Creates a new instance of {@code ConcurrentRuntimeException} and\n+     * initializes it with the given cause.\n+     *\n+     * @param cause the cause of this exception\n+     * @throws IllegalArgumentException if the cause is not a checked exception\n+     */\n+    public ConcurrentRuntimeException(Throwable cause) {\n+        super(ConcurrentUtils.checkedException(cause));\n+    }\n+\n+    /**\n+     * Creates a new instance of {@code ConcurrentRuntimeException} and\n+     * initializes it with the given message and cause.\n+     *\n+     * @param msg the error message\n+     * @param cause the cause of this exception\n+     * @throws IllegalArgumentException if the cause is not a checked exception\n+     */\n+    public ConcurrentRuntimeException(String msg, Throwable cause) {\n+        super(msg, ConcurrentUtils.checkedException(cause));\n+    }\n+}\n--- a/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentUtils.java\n     }\n \n     /**\n+     * Inspects the cause of the specified {@code ExecutionException} and\n+     * creates a {@code ConcurrentRuntimeException} with the checked cause if\n+     * necessary. This method works exactly like\n+     * {@link #extractCause(ExecutionException)}. The only difference is that\n+     * the cause of the specified {@code ExecutionException} is extracted as a\n+     * runtime exception. This is an alternative for client code that does not\n+     * want to deal with checked exceptions.\n+     *\n+     * @param ex the exception to be processed\n+     * @return a {@code ConcurrentRuntimeException} with the checked cause\n+     */\n+    public static ConcurrentRuntimeException extractCauseUnchecked(\n+            ExecutionException ex) {\n+        if (ex == null || ex.getCause() == null) {\n+            return null;\n+        }\n+\n+        throwCause(ex);\n+        return new ConcurrentRuntimeException(ex.getMessage(), ex.getCause());\n+    }\n+\n+    /**\n      * Handles the specified {@code ExecutionException}. This method calls\n      * {@link #extractCause(ExecutionException)} for obtaining the cause of the\n      * exception - which might already cause an unchecked exception or an error\n \n         if (cex != null) {\n             throw cex;\n+        }\n+    }\n+\n+    /**\n+     * Handles the specified {@code ExecutionException} and transforms it into a\n+     * runtime exception. This method works exactly like\n+     * {@link #handleCause(ExecutionException)}, but instead of a\n+     * {@link ConcurrentException} it throws a\n+     * {@link ConcurrentRuntimeException}. This is an alternative for client\n+     * code that does not want to deal with checked exceptions.\n+     *\n+     * @param ex the exception to be handled\n+     * @throws ConcurrentRuntimeException if the cause of the {@code\n+     * ExecutionException} is a checked exception; this exception is then\n+     * wrapped in the thrown runtime exception\n+     */\n+    public static void handleCauseUnchecked(ExecutionException ex) {\n+        ConcurrentRuntimeException crex = extractCauseUnchecked(ex);\n+\n+        if (crex != null) {\n+            throw crex;\n         }\n     }\n \n      * concurrent processing, perhaps as part of avoiding nulls.\n      * A constant future can also be useful in testing.\n      * </p>\n-     * \n+     *\n      * @param value  the constant value to return, may be null\n      * @return an instance of Future that will return the value, never null\n      */\n--- a/src/test/java/org/apache/commons/lang3/concurrent/ConcurrentUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/ConcurrentUtilsTest.java\n     }\n \n     /**\n+     * Tries to create a ConcurrentRuntimeException with a runtime as cause.\n+     */\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testConcurrentRuntimeExceptionCauseUnchecked() {\n+        new ConcurrentRuntimeException(new RuntimeException());\n+    }\n+\n+    /**\n+     * Tries to create a ConcurrentRuntimeException with an error as cause.\n+     */\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testConcurrentRuntimeExceptionCauseError() {\n+        new ConcurrentRuntimeException(\"An error\", new Error());\n+    }\n+\n+    /**\n+     * Tries to create a ConcurrentRuntimeException with null as cause.\n+     */\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testConcurrentRuntimeExceptionCauseNull() {\n+        new ConcurrentRuntimeException(null);\n+    }\n+\n+    /**\n      * Tests extractCause() for a null exception.\n      */\n     @Test\n      * Tests extractCause() if the cause is an unchecked exception.\n      */\n     @Test\n-    public void testExtractCauseUnchecked() {\n+    public void testExtractCauseUncheckedException() {\n         RuntimeException rex = new RuntimeException(\"Test\");\n         try {\n             ConcurrentUtils.extractCause(new ExecutionException(rex));\n     }\n \n     /**\n+     * Tests extractCauseUnchecked() for a null exception.\n+     */\n+    @Test\n+    public void testExtractCauseUncheckedNull() {\n+        assertNull(\"Non null result\", ConcurrentUtils.extractCauseUnchecked(null));\n+    }\n+\n+    /**\n+     * Tests extractCauseUnchecked() if the cause of the passed in exception is null.\n+     */\n+    @Test\n+    public void testExtractCauseUncheckedNullCause() {\n+        assertNull(\"Non null result\", ConcurrentUtils\n+                .extractCauseUnchecked(new ExecutionException(\"Test\", null)));\n+    }\n+\n+    /**\n+     * Tests extractCauseUnchecked() if the cause is an error.\n+     */\n+    @Test\n+    public void testExtractCauseUncheckedError() {\n+        Error err = new AssertionError(\"Test\");\n+        try {\n+            ConcurrentUtils.extractCauseUnchecked(new ExecutionException(err));\n+            fail(\"Error not thrown!\");\n+        } catch (Error e) {\n+            assertEquals(\"Wrong error\", err, e);\n+        }\n+    }\n+\n+    /**\n+     * Tests extractCauseUnchecked() if the cause is an unchecked exception.\n+     */\n+    @Test\n+    public void testExtractCauseUncheckedUncheckedException() {\n+        RuntimeException rex = new RuntimeException(\"Test\");\n+        try {\n+            ConcurrentUtils.extractCauseUnchecked(new ExecutionException(rex));\n+            fail(\"Runtime exception not thrown!\");\n+        } catch (RuntimeException r) {\n+            assertEquals(\"Wrong exception\", rex, r);\n+        }\n+    }\n+\n+    /**\n+     * Tests extractCauseUnchecked() if the cause is a checked exception.\n+     */\n+    @Test\n+    public void testExtractCauseUncheckedChecked() {\n+        Exception ex = new Exception(\"Test\");\n+        ConcurrentRuntimeException cex = ConcurrentUtils\n+                .extractCauseUnchecked(new ExecutionException(ex));\n+        assertSame(\"Wrong cause\", ex, cex.getCause());\n+    }\n+\n+    /**\n      * Tests handleCause() if the cause is an error.\n      */\n     @Test\n      * Tests handleCause() if the cause is an unchecked exception.\n      */\n     @Test\n-    public void testHandleCauseUnchecked() throws ConcurrentException {\n+    public void testHandleCauseUncheckedException() throws ConcurrentException {\n         RuntimeException rex = new RuntimeException(\"Test\");\n         try {\n             ConcurrentUtils.handleCause(new ExecutionException(rex));\n     public void testHandleCauseNull() throws ConcurrentException {\n         ConcurrentUtils.handleCause(null);\n         ConcurrentUtils.handleCause(new ExecutionException(\"Test\", null));\n+    }\n+\n+    /**\n+     * Tests handleCauseUnchecked() if the cause is an error.\n+     */\n+    @Test\n+    public void testHandleCauseUncheckedError() throws ConcurrentException {\n+        Error err = new AssertionError(\"Test\");\n+        try {\n+            ConcurrentUtils.handleCauseUnchecked(new ExecutionException(err));\n+            fail(\"Error not thrown!\");\n+        } catch (Error e) {\n+            assertEquals(\"Wrong error\", err, e);\n+        }\n+    }\n+\n+    /**\n+     * Tests handleCauseUnchecked() if the cause is an unchecked exception.\n+     */\n+    @Test\n+    public void testHandleCauseUncheckedUncheckedException()\n+            throws ConcurrentException {\n+        RuntimeException rex = new RuntimeException(\"Test\");\n+        try {\n+            ConcurrentUtils.handleCauseUnchecked(new ExecutionException(rex));\n+            fail(\"Runtime exception not thrown!\");\n+        } catch (RuntimeException r) {\n+            assertEquals(\"Wrong exception\", rex, r);\n+        }\n+    }\n+\n+    /**\n+     * Tests handleCauseUnchecked() if the cause is a checked exception.\n+     */\n+    @Test\n+    public void testHandleCauseUncheckedChecked() {\n+        Exception ex = new Exception(\"Test\");\n+        try {\n+            ConcurrentUtils.handleCauseUnchecked(new ExecutionException(ex));\n+            fail(\"ConcurrentRuntimeException not thrown!\");\n+        } catch (ConcurrentRuntimeException crex) {\n+            assertEquals(\"Wrong cause\", ex, crex.getCause());\n+        }\n+    }\n+\n+    /**\n+     * Tests handleCauseUnchecked() for a null parameter or a null cause. In\n+     * this case the method should do nothing. We can only test that no\n+     * exception is thrown.\n+     */\n+    @Test\n+    public void testHandleCauseUncheckedNull() throws ConcurrentException {\n+        ConcurrentUtils.handleCauseUnchecked(null);\n+        ConcurrentUtils.handleCauseUnchecked(new ExecutionException(\"Test\",\n+                null));\n     }\n \n     //-----------------------------------------------------------------------", "timestamp": 1269189322, "metainfo": ""}