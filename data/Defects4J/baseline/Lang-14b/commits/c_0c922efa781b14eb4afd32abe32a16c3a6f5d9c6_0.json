{"sha": "0c922efa781b14eb4afd32abe32a16c3a6f5d9c6", "log": "Moving the CharSequence specific methods out of StringUtils and reintroducing the CharSequenceUtils class  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/CharSequenceUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+/**\n+ * <p>Operations on {@link java.lang.CharSequence} that are\n+ * {@code null} safe.</p>\n+ *\n+ * @see java.lang.CharSequence\n+ * @since 3.0\n+ * @version $Id: StringUtils.java 1089734 2011-04-07 04:37:52Z bayard $\n+ */\n+public class CharSequenceUtils {\n+\n+    /**\n+     * <p>{@code CharSequenceUtils} instances should NOT be constructed in\n+     * standard programming. </p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public CharSequenceUtils() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns a new {@code CharSequence} that is a subsequence of this\n+     * sequence starting with the {@code char} value at the specified index.</p>\n+     *\n+     * <p>This provides the {@code CharSequence} equivalent to {@link String#substring(int)}.\n+     * The length (in {@code char}) of the returned sequence is {@code length() - start},\n+     * so if {@code start == end} then an empty sequence is returned.</p>\n+     *\n+     * @param cs  the specified subsequence, null returns null\n+     * @param start  the start index, inclusive, valid\n+     * @return a new subsequence, may be null\n+     * @throws IndexOutOfBoundsException if {@code start} is negative or if \n+     *  {@code start} is greater than {@code length()}\n+     */\n+    public static CharSequence subSequence(CharSequence cs, int start) {\n+        return cs == null ? null : cs.subSequence(start, cs.length());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Used by the indexOf(CharSequence methods) as a green implementation of\n+     * indexOf.\n+     *\n+     * @param cs the {@code CharSequence} to be processed\n+     * @param searchChar the char to be searched for\n+     * @param start the start index\n+     * @return the index where the search char was found\n+     */\n+    static int indexOf(CharSequence cs, int searchChar, int start) {\n+        if (cs instanceof String) {\n+            return ((String) cs).indexOf(searchChar, start);\n+        } else {\n+            int sz = cs.length();\n+            if ( start < 0 ) {\n+                start = 0;\n+            }\n+            for ( int i=start; i < sz; i++ ) {\n+                if ( cs.charAt(i) == searchChar) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Used by the indexOf(CharSequence methods) as a green implementation of indexOf.\n+     *\n+     * @param cs the {@code CharSequence} to be processed\n+     * @param searchChar the {@code CharSequence} to be searched for\n+     * @param start the start index\n+     * @return the index where the search sequence was found\n+     */\n+    static int indexOf(CharSequence cs, CharSequence searchChar, int start) {\n+        if (cs instanceof String && searchChar instanceof String) {\n+            // TODO: Do we assume searchChar is usually relatively small;\n+            //       If so then calling toString() on it is better than reverting to\n+            //       the green implementation in the else block\n+            return ((String) cs).indexOf( (String) searchChar, start);\n+        } else {\n+            // TODO: Implement rather than convert to String\n+            return cs.toString().indexOf(searchChar.toString(), start);\n+        }\n+    }\n+\n+    /**\n+     * Used by the lastIndexOf(CharSequence methods) as a green implementation of lastIndexOf\n+     *\n+     * @param cs the {@code CharSequence} to be processed\n+     * @param searchChar the char to be searched for\n+     * @param start the start index\n+     * @return the index where the search char was found\n+     */\n+    static int lastIndexOf(CharSequence cs, int searchChar, int start) {\n+        if (cs instanceof String) {\n+            return ((String) cs).lastIndexOf(searchChar, start);\n+        } else {\n+            int sz = cs.length();\n+            if ( start < 0 ) {\n+                return -1;\n+            }\n+            if ( start >= sz ) {\n+                start = sz - 1;\n+            }\n+            for ( int i=start; i >= 0; --i ) {\n+                if ( cs.charAt(i) == searchChar) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Used by the lastIndexOf(CharSequence methods) as a green implementation of lastIndexOf\n+     *\n+     * @param cs the {@code CharSequence} to be processed\n+     * @param searchChar the {@code CharSequence} to be searched for\n+     * @param start the start index\n+     * @return the index where the search sequence was found\n+     */\n+    static int lastIndexOf(CharSequence cs, CharSequence searchChar, int start) {\n+        if (cs instanceof String && searchChar instanceof String) {\n+            // TODO: Do we assume searchChar is usually relatively small;\n+            //       If so then calling toString() on it is better than reverting to\n+            //       the green implementation in the else block\n+            return ((String) cs).lastIndexOf( (String) searchChar, start);\n+        } else {\n+            // TODO: Implement rather than convert to String\n+            return cs.toString().lastIndexOf(searchChar.toString(), start);\n+        }\n+    }\n+\n+    /**\n+     * Green implementation of toCharArray.\n+     *\n+     * @param cs the {@code CharSequence} to be processed\n+     * @return the resulting char array\n+     */\n+    static char[] toCharArray(CharSequence cs) {\n+        if (cs instanceof String) {\n+            return ((String) cs).toCharArray();\n+        } else {\n+            int sz = cs.length();\n+            char[] array = new char[cs.length()];\n+            for (int i=0; i < sz; i++) {\n+                array[i] = cs.charAt(i);\n+            }\n+            return array;\n+        }\n+    }\n+\n+    /**\n+     * Green implementation of regionMatches.\n+     *\n+     * @param cs the {@code CharSequence} to be processed\n+     * @param ignoreCase whether or not to be case insensitive\n+     * @param thisStart the index to start on the {@code cs} CharSequence\n+     * @param substring the {@code CharSequence} to be looked for\n+     * @param start the index to start on the {@code substring} CharSequence\n+     * @param length character length of the region\n+     * @return whether the region matched\n+     */\n+    static boolean regionMatches(CharSequence cs, boolean ignoreCase, int thisStart, \n+                                         CharSequence substring, int start, int length)\n+    {\n+        if (cs instanceof String && substring instanceof String) {\n+            return ((String) cs).regionMatches(ignoreCase, thisStart, ((String)substring), start, length);\n+        } else {\n+            // TODO: Implement rather than convert to String\n+            return cs.toString().regionMatches(ignoreCase, thisStart, substring.toString(), start, length);\n+        }\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n         if (str1 == null || str2 == null) {\n             return str1 == str2;\n         } else {\n-            return regionMatchesSequence(str1, true, 0, str2, 0, Math.max(str1.length(), str2.length()));\n+            return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, Math.max(str1.length(), str2.length()));\n         }\n     }\n \n         if (isEmpty(seq)) {\n             return INDEX_NOT_FOUND;\n         }\n-        return StringUtils.indexOfSequence(seq, searchChar, 0);\n+        return CharSequenceUtils.indexOf(seq, searchChar, 0);\n     }\n \n     /**\n         if (isEmpty(seq)) {\n             return INDEX_NOT_FOUND;\n         }\n-        return StringUtils.indexOfSequence(seq, searchChar, startPos);\n+        return CharSequenceUtils.indexOf(seq, searchChar, startPos);\n     }\n \n     /**\n         if (seq == null || searchSeq == null) {\n             return INDEX_NOT_FOUND;\n         }\n-        return StringUtils.indexOfSequence(seq, searchSeq, 0);\n+        return CharSequenceUtils.indexOf(seq, searchSeq, 0);\n     }\n \n     /**\n         if (seq == null || searchSeq == null) {\n             return INDEX_NOT_FOUND;\n         }\n-        return StringUtils.indexOfSequence(seq, searchSeq, startPos);\n+        return CharSequenceUtils.indexOf(seq, searchSeq, startPos);\n     }\n \n     /**\n         int index = lastIndex ? str.length() : INDEX_NOT_FOUND;\n         do {\n             if (lastIndex) {\n-                index = lastIndexOfSequence(str, searchStr, index - 1);\n+                index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1);\n             } else {\n-                index = indexOfSequence(str, searchStr, index + 1);\n+                index = CharSequenceUtils.indexOf(str, searchStr, index + 1);\n             }\n             if (index < 0) {\n                 return index;\n             return startPos;\n         }\n         for (int i = startPos; i < endLimit; i++) {\n-            if (regionMatchesSequence(str, true, i, searchStr, 0, searchStr.length())) {\n+            if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {\n                 return i;\n             }\n         }\n         if (isEmpty(seq)) {\n             return INDEX_NOT_FOUND;\n         }\n-        return StringUtils.lastIndexOfSequence(seq, searchChar, seq.length());\n+        return CharSequenceUtils.lastIndexOf(seq, searchChar, seq.length());\n     }\n \n     /**\n         if (isEmpty(seq)) {\n             return INDEX_NOT_FOUND;\n         }\n-        return StringUtils.lastIndexOfSequence(seq, searchChar, startPos);\n+        return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos);\n     }\n \n     /**\n         if (seq == null || searchSeq == null) {\n             return INDEX_NOT_FOUND;\n         }\n-        return StringUtils.lastIndexOfSequence(seq, searchSeq, seq.length());\n+        return CharSequenceUtils.lastIndexOf(seq, searchSeq, seq.length());\n     }\n \n     /**\n         if (seq == null || searchSeq == null) {\n             return INDEX_NOT_FOUND;\n         }\n-        return StringUtils.lastIndexOfSequence(seq, searchSeq, startPos);\n+        return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);\n     }\n \n     /**\n         }\n \n         for (int i = startPos; i >= 0; i--) {\n-            if (regionMatchesSequence(str, true, i, searchStr, 0, searchStr.length())) {\n+            if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {\n                 return i;\n             }\n         }\n         if (isEmpty(seq)) {\n             return false;\n         }\n-        return indexOfSequence(seq, searchChar, 0) >= 0;\n+        return CharSequenceUtils.indexOf(seq, searchChar, 0) >= 0;\n     }\n \n     /**\n         if (seq == null || searchSeq == null) {\n             return false;\n         }\n-        return indexOfSequence(seq, searchSeq, 0) >= 0;\n+        return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;\n     }\n \n     /**\n         int len = searchStr.length();\n         int max = str.length() - len;\n         for (int i = 0; i <= max; i++) {\n-            if (regionMatchesSequence(str, true, i, searchStr, 0, len)) {\n+            if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) {\n                 return true;\n             }\n         }\n         if (searchChars == null) {\n             return false;\n         }\n-        return containsAny(cs, toCharArraySequence(searchChars));\n+        return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));\n     }\n \n     // IndexOfAnyBut chars\n         int strLen = seq.length();\n         for (int i = 0; i < strLen; i++) {\n             char ch = seq.charAt(i);\n-            boolean chFound = indexOfSequence(searchChars, ch, 0) >= 0;\n+            boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;\n             if (i + 1 < strLen && Character.isHighSurrogate(ch)) {\n                 char ch2 = seq.charAt(i + 1);\n-                if (chFound && indexOfSequence(searchChars, ch2, 0) < 0) {\n+                if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {\n                     return i;\n                 }\n             } else {\n             if (search == null) {\n                 continue;\n             }\n-            tmp = indexOfSequence(str, search, 0);\n+            tmp = CharSequenceUtils.indexOf(str, search, 0);\n             if (tmp == INDEX_NOT_FOUND) {\n                 continue;\n             }\n             if (search == null) {\n                 continue;\n             }\n-            tmp = lastIndexOfSequence(str, search, str.length());\n+            tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());\n             if (tmp > ret) {\n                 ret = tmp;\n             }\n         }\n         int count = 0;\n         int idx = 0;\n-        while ((idx = indexOfSequence(str, sub, idx)) != INDEX_NOT_FOUND) {\n+        while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) {\n             count++;\n             idx += sub.length();\n         }\n         if (prefix.length() > str.length()) {\n             return false;\n         }\n-        return regionMatchesSequence(str, ignoreCase, 0, prefix, 0, prefix.length());\n+        return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n     }\n \n     /**\n             return false;\n         }\n         int strOffset = str.length() - suffix.length();\n-        return regionMatchesSequence(str, ignoreCase, strOffset, suffix, 0, suffix.length());\n+        return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());\n     }\n \n     /**\n         return false;\n     }\n \n-    //-----------------------------------------------------------------------\n-    /**\n-     * <p>Returns a new {@code CharSequence} that is a subsequence of this\n-     * sequence starting with the {@code char} value at the specified index.</p>\n-     *\n-     * <p>This provides the {@code CharSequence} equivalent to {@link String#substring(int)}.\n-     * The length (in {@code char}) of the returned sequence is {@code length() - start},\n-     * so if {@code start == end} then an empty sequence is returned.</p>\n-     *\n-     * @param cs  the specified subsequence, null returns null\n-     * @param start  the start index, inclusive, valid\n-     * @return a new subsequence, may be null\n-     * @throws IndexOutOfBoundsException if {@code start} is negative or if \n-     *  {@code start} is greater than {@code length()}\n-     */\n-    public static CharSequence subSequence(CharSequence cs, int start) {\n-        return cs == null ? null : cs.subSequence(start, cs.length());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-\n-    /**\n-     * Used by the indexOf(CharSequence methods) as a green implementation of\n-     * indexOf.\n-     *\n-     * @param cs the {@code CharSequence} to be processed\n-     * @param searchChar the char to be searched for\n-     * @param start the start index\n-     * @return the index where the search char was found\n-     */\n-    static int indexOfSequence(CharSequence cs, int searchChar, int start) {\n-        if (cs instanceof String) {\n-            return ((String) cs).indexOf(searchChar, start);\n-        } else {\n-            int sz = cs.length();\n-            if ( start < 0 ) {\n-                start = 0;\n-            }\n-            for ( int i=start; i < sz; i++ ) {\n-                if ( cs.charAt(i) == searchChar) {\n-                    return i;\n-                }\n-            }\n-            return -1;\n-        }\n-    }\n-\n-    /**\n-     * Used by the indexOf(CharSequence methods) as a green implementation of indexOf.\n-     *\n-     * @param cs the {@code CharSequence} to be processed\n-     * @param searchChar the {@code CharSequence} to be searched for\n-     * @param start the start index\n-     * @return the index where the search sequence was found\n-     */\n-    static int indexOfSequence(CharSequence cs, CharSequence searchChar, int start) {\n-        if (cs instanceof String && searchChar instanceof String) {\n-            // TODO: Do we assume searchChar is usually relatively small;\n-            //       If so then calling toString() on it is better than reverting to\n-            //       the green implementation in the else block\n-            return ((String) cs).indexOf( (String) searchChar, start);\n-        } else {\n-            // TODO: Implement rather than convert to String\n-            return cs.toString().indexOf(searchChar.toString(), start);\n-        }\n-    }\n-\n-    /**\n-     * Used by the lastIndexOf(CharSequence methods) as a green implementation of lastIndexOf\n-     *\n-     * @param cs the {@code CharSequence} to be processed\n-     * @param searchChar the char to be searched for\n-     * @param start the start index\n-     * @return the index where the search char was found\n-     */\n-    static int lastIndexOfSequence(CharSequence cs, int searchChar, int start) {\n-        if (cs instanceof String) {\n-            return ((String) cs).lastIndexOf(searchChar, start);\n-        } else {\n-            int sz = cs.length();\n-            if ( start < 0 ) {\n-                return -1;\n-            }\n-            if ( start >= sz ) {\n-                start = sz - 1;\n-            }\n-            for ( int i=start; i >= 0; --i ) {\n-                if ( cs.charAt(i) == searchChar) {\n-                    return i;\n-                }\n-            }\n-            return -1;\n-        }\n-    }\n-\n-    /**\n-     * Used by the lastIndexOf(CharSequence methods) as a green implementation of lastIndexOf\n-     *\n-     * @param cs the {@code CharSequence} to be processed\n-     * @param searchChar the {@code CharSequence} to be searched for\n-     * @param start the start index\n-     * @return the index where the search sequence was found\n-     */\n-    static int lastIndexOfSequence(CharSequence cs, CharSequence searchChar, int start) {\n-        if (cs instanceof String && searchChar instanceof String) {\n-            // TODO: Do we assume searchChar is usually relatively small;\n-            //       If so then calling toString() on it is better than reverting to\n-            //       the green implementation in the else block\n-            return ((String) cs).lastIndexOf( (String) searchChar, start);\n-        } else {\n-            // TODO: Implement rather than convert to String\n-            return cs.toString().lastIndexOf(searchChar.toString(), start);\n-        }\n-    }\n-\n-    /**\n-     * Green implementation of toCharArray.\n-     *\n-     * @param cs the {@code CharSequence} to be processed\n-     * @return the resulting char array\n-     */\n-    static char[] toCharArraySequence(CharSequence cs) {\n-        if (cs instanceof String) {\n-            return ((String) cs).toCharArray();\n-        } else {\n-            int sz = cs.length();\n-            char[] array = new char[cs.length()];\n-            for (int i=0; i < sz; i++) {\n-                array[i] = cs.charAt(i);\n-            }\n-            return array;\n-        }\n-    }\n-\n-    /**\n-     * Green implementation of regionMatches.\n-     *\n-     * @param cs the {@code CharSequence} to be processed\n-     * @param ignoreCase whether or not to be case insensitive\n-     * @param thisStart the index to start on the {@code cs} CharSequence\n-     * @param substring the {@code CharSequence} to be looked for\n-     * @param start the index to start on the {@code substring} CharSequence\n-     * @param length character length of the region\n-     * @return whether the region matched\n-     */\n-    static boolean regionMatchesSequence(CharSequence cs, boolean ignoreCase, int thisStart, \n-                                         CharSequence substring, int start, int length)\n-    {\n-        if (cs instanceof String && substring instanceof String) {\n-            return ((String) cs).regionMatches(ignoreCase, thisStart, ((String)substring), start, length);\n-        } else {\n-            // TODO: Implement rather than convert to String\n-            return cs.toString().regionMatches(ignoreCase, thisStart, substring.toString(), start, length);\n-        }\n-    }\n-\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/CharSequenceUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+\n+import junit.framework.Assert;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests CharSequenceUtils\n+ *\n+ * @author Gary Gregory\n+ * @version $Id: CharSequenceUtilsTest.java 1066341 2011-02-02 06:21:53Z bayard $\n+ */\n+public class CharSequenceUtilsTest extends TestCase {\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new CharSequenceUtils());\n+        Constructor<?>[] cons = CharSequenceUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(CharSequenceUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(CharSequenceUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testSubSequence() {\n+        //\n+        // null input\n+        //\n+        Assert.assertEquals(null, CharSequenceUtils.subSequence(null, -1));\n+        Assert.assertEquals(null, CharSequenceUtils.subSequence(null, 0));\n+        Assert.assertEquals(null, CharSequenceUtils.subSequence(null, 1));\n+        //\n+        // non-null input\n+        //\n+        Assert.assertEquals(StringUtils.EMPTY, CharSequenceUtils.subSequence(StringUtils.EMPTY, 0));\n+        Assert.assertEquals(\"012\", CharSequenceUtils.subSequence(\"012\", 0));\n+        Assert.assertEquals(\"12\", CharSequenceUtils.subSequence(\"012\", 1));\n+        Assert.assertEquals(\"2\", CharSequenceUtils.subSequence(\"012\", 2));\n+        Assert.assertEquals(StringUtils.EMPTY, CharSequenceUtils.subSequence(\"012\", 3));\n+        //\n+        // Exception expected\n+        //\n+        try {\n+            Assert.assertEquals(null, CharSequenceUtils.subSequence(StringUtils.EMPTY, -1));\n+            Assert.fail(\"Expected \" + IndexOutOfBoundsException.class.getName());\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+        try {\n+            Assert.assertEquals(null, CharSequenceUtils.subSequence(StringUtils.EMPTY, 1));\n+            Assert.fail(\"Expected \" + IndexOutOfBoundsException.class.getName());\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/lang3/StringUtilsSubstringTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsSubstringTest.java\n              StringUtils.countMatches(\"oooooooooooo\", \"ooo\"));\n     }\n \n-    //-----------------------------------------------------------------------\n-    public void testSubSequence() {\n-        //\n-        // null input\n-        //\n-        Assert.assertEquals(null, StringUtils.subSequence(null, -1));\n-        Assert.assertEquals(null, StringUtils.subSequence(null, 0));\n-        Assert.assertEquals(null, StringUtils.subSequence(null, 1));\n-        //\n-        // non-null input\n-        //\n-        Assert.assertEquals(StringUtils.EMPTY, StringUtils.subSequence(StringUtils.EMPTY, 0));\n-        Assert.assertEquals(\"012\", StringUtils.subSequence(\"012\", 0));\n-        Assert.assertEquals(\"12\", StringUtils.subSequence(\"012\", 1));\n-        Assert.assertEquals(\"2\", StringUtils.subSequence(\"012\", 2));\n-        Assert.assertEquals(StringUtils.EMPTY, StringUtils.subSequence(\"012\", 3));\n-        //\n-        // Exception expected\n-        //\n-        try {\n-            Assert.assertEquals(null, StringUtils.subSequence(StringUtils.EMPTY, -1));\n-            Assert.fail(\"Expected \" + IndexOutOfBoundsException.class.getName());\n-        } catch (IndexOutOfBoundsException e) {\n-            // Expected\n-        }\n-        try {\n-            Assert.assertEquals(null, StringUtils.subSequence(StringUtils.EMPTY, 1));\n-            Assert.fail(\"Expected \" + IndexOutOfBoundsException.class.getName());\n-        } catch (IndexOutOfBoundsException e) {\n-            // Expected\n-        }\n-    }\n-\n }", "timestamp": 1302157701, "metainfo": ""}