{"sha": "1bf3be90035217848a60da0bc00fb7612146f502", "log": "[LANG-678] Added support for ConcurrentMap.putIfAbsent() to ConcurrentUtils.  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentUtils.java\n  */\n package org.apache.commons.lang3.concurrent;\n \n+import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n     //-----------------------------------------------------------------------\n     /**\n      * <p>\n+     * Puts a value in the specified {@code ConcurrentMap} if the key is not yet\n+     * present. This method works similar to the {@code putIfAbsent()} method of\n+     * the {@code ConcurrentMap} interface, but the value returned is different.\n+     * Basically, this method is equivalent to the following code fragment:\n+     *\n+     * <pre>\n+     * if (!map.containsKey(key)) {\n+     *     map.put(key, value);\n+     *     return value;\n+     * } else {\n+     *     return map.get(key);\n+     * }\n+     * </pre>\n+     *\n+     * except that the action is performed atomically. So this method always\n+     * returns the value which is stored in the map.\n+     * </p>\n+     * <p>\n+     * This method is <b>null</b>-safe: It accepts a <b>null</b> map as input\n+     * without throwing an exception. In this case the return value is\n+     * <b>null</b>, too.\n+     * </p>\n+     *\n+     * @param <K> the type of the keys of the map\n+     * @param <V> the type of the values of the map\n+     * @param map the map to be modified\n+     * @param key the key of the value to be added\n+     * @param value the value to be added\n+     * @return the value stored in the map after this operation\n+     */\n+    public static <K, V> V putIfAbsent(ConcurrentMap<K, V> map, K key, V value) {\n+        if (map == null) {\n+            return null;\n+        }\n+\n+        V result = map.putIfAbsent(key, value);\n+        return (result != null) ? result : value;\n+    }\n+\n+    /**\n+     * Checks if a concurrent map contains a key and creates a corresponding\n+     * value if not. This method first checks the presence of the key in the\n+     * given map. If it is already contained, its value is returned. Otherwise\n+     * the {@code get()} method of the passed in {@link ConcurrentInitializer}\n+     * is called. With the resulting object\n+     * {@link #putIfAbsent(ConcurrentMap, Object, Object)} is called. This\n+     * handles the case that in the meantime another thread has added the key to\n+     * the map. Both the map and the initializer can be <b>null</b>; in this\n+     * case this method simply returns <b>null</b>.\n+     *\n+     * @param <K> the type of the keys of the map\n+     * @param <V> the type of the values of the map\n+     * @param map the map to be modified\n+     * @param key the key of the value to be added\n+     * @param init the {@link ConcurrentInitializer} for creating the value\n+     * @return the value stored in the map after this operation; this may or may\n+     * not be the object created by the {@link ConcurrentInitializer}\n+     * @throws ConcurrentException if the initializer throws an exception\n+     */\n+    public static <K, V> V createIfAbsent(ConcurrentMap<K, V> map, K key,\n+            ConcurrentInitializer<V> init) throws ConcurrentException {\n+        if (map == null || init == null) {\n+            return null;\n+        }\n+\n+        V value = map.get(key);\n+        if (value == null) {\n+            return putIfAbsent(map, key, init.get());\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * Checks if a concurrent map contains a key and creates a corresponding\n+     * value if not, suppressing checked exceptions. This method calls\n+     * {@code createIfAbsent()}. If a {@link ConcurrentException} is thrown, it\n+     * is caught and re-thrown as a {@link ConcurrentRuntimeException}.\n+     *\n+     * @param <K> the type of the keys of the map\n+     * @param <V> the type of the values of the map\n+     * @param map the map to be modified\n+     * @param key the key of the value to be added\n+     * @param init the {@link ConcurrentInitializer} for creating the value\n+     * @return the value stored in the map after this operation; this may or may\n+     * not be the object created by the {@link ConcurrentInitializer}\n+     * @throws ConcurrentRuntimeException if the initializer throws an exception\n+     */\n+    public static <K, V> V createIfAbsentUnchecked(ConcurrentMap<K, V> map,\n+            K key, ConcurrentInitializer<V> init) {\n+        try {\n+            return createIfAbsent(map, key, init);\n+        } catch (ConcurrentException cex) {\n+            throw new ConcurrentRuntimeException(cex.getCause());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>\n      * Gets an implementation of <code>Future</code> that is immediately done\n      * and returns the specified constant value.\n      * </p>\n--- a/src/test/java/org/apache/commons/lang3/concurrent/ConcurrentUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/ConcurrentUtilsTest.java\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n \n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n         assertFalse(test.cancel(false));\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests putIfAbsent() if the map contains the key in question.\n+     */\n+    @Test\n+    public void testPutIfAbsentKeyPresent() {\n+        final String key = \"testKey\";\n+        final Integer value = 42;\n+        ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>();\n+        map.put(key, value);\n+        assertEquals(\"Wrong result\", value,\n+                ConcurrentUtils.putIfAbsent(map, key, 0));\n+        assertEquals(\"Wrong value in map\", value, map.get(key));\n+    }\n+\n+    /**\n+     * Tests putIfAbsent() if the map does not contain the key in question.\n+     */\n+    @Test\n+    public void testPutIfAbsentKeyNotPresent() {\n+        final String key = \"testKey\";\n+        final Integer value = 42;\n+        ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>();\n+        assertEquals(\"Wrong result\", value,\n+                ConcurrentUtils.putIfAbsent(map, key, value));\n+        assertEquals(\"Wrong value in map\", value, map.get(key));\n+    }\n+\n+    /**\n+     * Tests putIfAbsent() if a null map is passed in.\n+     */\n+    @Test\n+    public void testPutIfAbsentNullMap() {\n+        assertNull(\"Wrong result\",\n+                ConcurrentUtils.putIfAbsent(null, \"test\", 100));\n+    }\n+\n+    /**\n+     * Tests createIfAbsent() if the key is found in the map.\n+     */\n+    @Test\n+    public void testCreateIfAbsentKeyPresent() throws ConcurrentException {\n+        @SuppressWarnings(\"unchecked\")\n+        ConcurrentInitializer<Integer> init = EasyMock\n+                .createMock(ConcurrentInitializer.class);\n+        EasyMock.replay(init);\n+        final String key = \"testKey\";\n+        final Integer value = 42;\n+        ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>();\n+        map.put(key, value);\n+        assertEquals(\"Wrong result\", value,\n+                ConcurrentUtils.createIfAbsent(map, key, init));\n+        assertEquals(\"Wrong value in map\", value, map.get(key));\n+        EasyMock.verify(init);\n+    }\n+\n+    /**\n+     * Tests createIfAbsent() if the map does not contain the key in question.\n+     */\n+    @Test\n+    public void testCreateIfAbsentKeyNotPresent() throws ConcurrentException {\n+        @SuppressWarnings(\"unchecked\")\n+        ConcurrentInitializer<Integer> init = EasyMock\n+                .createMock(ConcurrentInitializer.class);\n+        final String key = \"testKey\";\n+        final Integer value = 42;\n+        EasyMock.expect(init.get()).andReturn(value);\n+        EasyMock.replay(init);\n+        ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>();\n+        assertEquals(\"Wrong result\", value,\n+                ConcurrentUtils.createIfAbsent(map, key, init));\n+        assertEquals(\"Wrong value in map\", value, map.get(key));\n+        EasyMock.verify(init);\n+    }\n+\n+    /**\n+     * Tests createIfAbsent() if a null map is passed in.\n+     */\n+    @Test\n+    public void testCreateIfAbsentNullMap() throws ConcurrentException {\n+        @SuppressWarnings(\"unchecked\")\n+        ConcurrentInitializer<Integer> init = EasyMock\n+                .createMock(ConcurrentInitializer.class);\n+        EasyMock.replay(init);\n+        assertNull(\"Wrong result\",\n+                ConcurrentUtils.createIfAbsent(null, \"test\", init));\n+        EasyMock.verify(init);\n+    }\n+\n+    /**\n+     * Tests createIfAbsent() if a null initializer is passed in.\n+     */\n+    @Test\n+    public void testCreateIfAbsentNullInit() throws ConcurrentException {\n+        ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>();\n+        final String key = \"testKey\";\n+        final Integer value = 42;\n+        map.put(key, value);\n+        assertNull(\"Wrong result\",\n+                ConcurrentUtils.createIfAbsent(map, key, null));\n+        assertEquals(\"Map was changed\", value, map.get(key));\n+    }\n+\n+    /**\n+     * Tests createIfAbsentUnchecked() if no exception is thrown.\n+     */\n+    @Test\n+    public void testCreateIfAbsentUncheckedSuccess() {\n+        final String key = \"testKey\";\n+        final Integer value = 42;\n+        ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>();\n+        assertEquals(\"Wrong result\", value,\n+                ConcurrentUtils.createIfAbsentUnchecked(map, key,\n+                        new ConstantInitializer<Integer>(value)));\n+        assertEquals(\"Wrong value in map\", value, map.get(key));\n+    }\n+\n+    /**\n+     * Tests createIfAbsentUnchecked() if an exception is thrown.\n+     */\n+    @Test\n+    public void testCreateIfAbsentUncheckedException()\n+            throws ConcurrentException {\n+        @SuppressWarnings(\"unchecked\")\n+        ConcurrentInitializer<Integer> init = EasyMock\n+                .createMock(ConcurrentInitializer.class);\n+        Exception ex = new Exception();\n+        EasyMock.expect(init.get()).andThrow(new ConcurrentException(ex));\n+        EasyMock.replay(init);\n+        try {\n+            ConcurrentUtils.createIfAbsentUnchecked(\n+                    new ConcurrentHashMap<String, Integer>(), \"test\", init);\n+            fail(\"Exception not thrown!\");\n+        } catch (ConcurrentRuntimeException crex) {\n+            assertEquals(\"Wrong cause\", ex, crex.getCause());\n+        }\n+        EasyMock.verify(init);\n+    }\n }", "timestamp": 1297891227, "metainfo": ""}