{"sha": "514f9665295ca33bf2207d67143ec0a125a63a71", "log": "require values parameter when generating bit vectors from enums, throwing NullPointerException if omitted; merge check for type eligibility; add E... generateBitVector() variant; alter generateBitVector(Class<E>, EnumSet<E>) to (Class<E>, Iterable<E>) by using |= << instead of + to accumulate values; process only specified values  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/EnumUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/EnumUtils.java\n      * <p>Do not use this method if you have more than 64 values in your Enum, as this\n      * would create a value greater than a long can hold.</p>\n      *\n-     * @param enumClass the class of the enum we are working with, not null\n-     * @param set       the set of enum values we want to convert\n+     * @param enumClass the class of the enum we are working with, not {@code null}\n+     * @param values    the values we want to convert, not {@code null}\n      * @param <E>       the type of the enumeration\n      * @return a long whose binary value represents the given set of enum values.\n-     */\n-    public static <E extends Enum<E>> long generateBitVector(Class<E> enumClass, EnumSet<E> set) {\n-        if (enumClass == null) {\n-            throw new IllegalArgumentException(\"EnumClass must be defined.\");\n-        }\n-        final E[] constants = enumClass.getEnumConstants();\n-        if (constants != null && constants.length > 64) {\n-            throw new IllegalArgumentException(\"EnumClass is too big to be stored in a 64-bit value.\");\n-        }\n+     * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}\n+     * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values\n+     * @since 3.0.1\n+     */\n+    public static <E extends Enum<E>> long generateBitVector(Class<E> enumClass, Iterable<E> values) {\n+        checkBitVectorable(enumClass);\n+        Validate.notNull(values);\n         long total = 0;\n-        if (set != null) {\n-            if (constants != null && constants.length > 0) {\n-                for (E constant : constants) {\n-                    if (set.contains(constant)) {\n-                        total += Math.pow(2, constant.ordinal());\n-                    }\n-                }\n-            }\n+        for (E constant : values) {\n+            total |= (1 << constant.ordinal());\n         }\n         return total;\n+    }\n+\n+    /**\n+     * <p>Creates a long bit vector representation of the given array of Enum values.</p>\n+     *\n+     * <p>This generates a value that is usable by {@link EnumUtils#processBitVector}.</p>\n+     *\n+     * <p>Do not use this method if you have more than 64 values in your Enum, as this\n+     * would create a value greater than a long can hold.</p>\n+     *\n+     * @param enumClass the class of the enum we are working with, not {@code null}\n+     * @param values    the values we want to convert, not {@code null}\n+     * @param <E>       the type of the enumeration\n+     * @return a long whose binary value represents the given set of enum values.\n+     * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}\n+     * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values\n+     * @since 3.0.1\n+     */\n+    public static <E extends Enum<E>> long generateBitVector(Class<E> enumClass, E... values) {\n+        Validate.noNullElements(values);\n+        return generateBitVector(enumClass, Arrays.<E> asList(values));\n     }\n \n     /**\n      * enum values that it represents.</p>\n      *\n      * <p>If you store this value, beware any changes to the enum that would affect ordinal values.</p>\n-     * @param enumClass the class of the enum we are working with, not null\n+     * @param enumClass the class of the enum we are working with, not {@code null}\n      * @param value     the long value representation of a set of enum values\n      * @param <E>       the type of the enumeration\n      * @return a set of enum values\n+     * @throws NullPointerException if {@code enumClass} is {@code null}\n+     * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values\n+     * @since 3.0.1\n      */\n     public static <E extends Enum<E>> EnumSet<E> processBitVector(Class<E> enumClass, long value) {\n-        if (enumClass == null) {\n-            throw new IllegalArgumentException(\"EnumClass must be defined.\");\n-        }\n+        final E[] constants = checkBitVectorable(enumClass).getEnumConstants();\n+        final EnumSet<E> results = EnumSet.noneOf(enumClass);\n+        for (E constant : constants) {\n+            if ((value & (1 << constant.ordinal())) != 0) {\n+                results.add(constant);\n+            }\n+        }\n+        return results;\n+    }\n+\n+    /**\n+     * Validate that {@code enumClass} is compatible with representation in a {@code long}.\n+     * @param <E> the type of the enumeration\n+     * @param enumClass to check\n+     * @return {@code enumClass}\n+     * @throws NullPointerException if {@code enumClass} is {@code null}\n+     * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values\n+     * @since 3.0.1\n+     */\n+    private static <E extends Enum<E>> Class<E> checkBitVectorable(Class<E> enumClass) {\n+        Validate.notNull(enumClass, \"EnumClass must be defined.\");\n+\n         final E[] constants = enumClass.getEnumConstants();\n-        if (constants != null && constants.length > 64) {\n-            throw new IllegalArgumentException(\"EnumClass is too big to be stored in a 64-bit value.\");\n-        }\n-        final EnumSet results = EnumSet.noneOf(enumClass);\n-        if (constants != null && constants.length > 0) {\n-            for (E constant : constants) {\n-                if ((value & (1 << constant.ordinal())) != 0) {\n-                    results.add(constant);\n-                }\n-            }\n-        }\n-        return results;\n+        Validate.isTrue(constants != null, \"%s does not seem to be an Enum type\", enumClass);\n+        Validate.isTrue(constants.length <= Long.SIZE, \"Cannot store %s %s values in %s bits\", constants.length,\n+            enumClass.getSimpleName(), Long.SIZE);\n+\n+        return enumClass;\n     }\n }\n--- a/src/test/java/org/apache/commons/lang3/EnumUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/EnumUtilsTest.java\n \n import static org.junit.Assert.*;\n \n+import java.util.ArrayList;\n import java.util.EnumSet;\n import java.util.List;\n import java.util.Map;\n         EnumUtils.getEnum((Class<Traffic>) null, \"PURPLE\");\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void test_generateBitVector_nullClass() {\n         EnumUtils.generateBitVector(null, EnumSet.of(Traffic.RED));\n+    }\n+\n+    @Test(expected=NullPointerException.class)\n+    public void test_generateBitVector_nullIterable() {\n+        EnumUtils.generateBitVector(null, (Iterable<Traffic>) null);\n+    }\n+\n+    @Test(expected=NullPointerException.class)\n+    public void test_generateBitVector_nullClassWithArray() {\n+        EnumUtils.generateBitVector(null, Traffic.RED);\n+    }\n+    \n+    @Test(expected=NullPointerException.class)\n+    public void test_generateBitVector_nullArray() {\n+        EnumUtils.generateBitVector(null, (Traffic[]) null);\n     }\n \n     @Test(expected=IllegalArgumentException.class)\n         EnumUtils.generateBitVector(TooMany.class, EnumSet.of(TooMany.A1));\n     }\n \n+    @Test(expected=IllegalArgumentException.class)\n+    public void test_generateBitVector_longClassWithArray() {\n+        EnumUtils.generateBitVector(TooMany.class, TooMany.A1);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class)\n+    public void test_generateBitVector_nonEnumClass() {\n+        @SuppressWarnings(\"rawtypes\")\n+        Class rawType = Object.class;\n+        @SuppressWarnings(\"rawtypes\")\n+        List rawList = new ArrayList();\n+        EnumUtils.generateBitVector(rawType, rawList);\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class)\n+    public void test_generateBitVector_nonEnumClassWithArray() {\n+        @SuppressWarnings(\"rawtypes\")\n+        Class rawType = Object.class;\n+        EnumUtils.generateBitVector(rawType);\n+    }\n+    \n     @Test\n     public void test_generateBitVector() {\n-        assertEquals(0L, EnumUtils.generateBitVector(Traffic.class, null));\n         assertEquals(0L, EnumUtils.generateBitVector(Traffic.class, EnumSet.noneOf(Traffic.class)));\n         assertEquals(1L, EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED)));\n         assertEquals(2L, EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.AMBER)));\n         assertEquals(7L, EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN)));\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n+    public void test_generateBitVectorFromArray() {\n+        assertEquals(0L, EnumUtils.generateBitVector(Traffic.class));\n+        assertEquals(1L, EnumUtils.generateBitVector(Traffic.class, Traffic.RED));\n+        assertEquals(2L, EnumUtils.generateBitVector(Traffic.class, Traffic.AMBER));\n+        assertEquals(4L, EnumUtils.generateBitVector(Traffic.class, Traffic.GREEN));\n+        assertEquals(3L, EnumUtils.generateBitVector(Traffic.class, Traffic.RED, Traffic.AMBER));\n+        assertEquals(5L, EnumUtils.generateBitVector(Traffic.class, Traffic.RED, Traffic.GREEN));\n+        assertEquals(6L, EnumUtils.generateBitVector(Traffic.class, Traffic.AMBER, Traffic.GREEN));\n+        assertEquals(7L, EnumUtils.generateBitVector(Traffic.class, Traffic.RED, Traffic.AMBER, Traffic.GREEN));\n+        //gracefully handles duplicates:\n+        assertEquals(7L, EnumUtils.generateBitVector(Traffic.class, Traffic.RED, Traffic.AMBER, Traffic.GREEN, Traffic.GREEN));\n+    }\n+    \n+    @Test(expected=NullPointerException.class)\n     public void test_processBitVector_nullClass() {\n         final Class<Traffic> empty = null;\n         EnumUtils.processBitVector(empty, 0L);", "timestamp": 1311275507, "metainfo": ""}