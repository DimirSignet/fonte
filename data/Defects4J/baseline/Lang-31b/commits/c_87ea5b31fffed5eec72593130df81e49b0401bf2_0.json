{"sha": "87ea5b31fffed5eec72593130df81e49b0401bf2", "log": "Update class and add javadoc ready for release   ", "commit": "\n--- a/src/java/org/apache/commons/lang/time/FastDateFormat.java\n+++ b/src/java/org/apache/commons/lang/time/FastDateFormat.java\n  */\n package org.apache.commons.lang.time;\n \n+import java.io.Serializable;\n+import java.text.DateFormat;\n+import java.text.DateFormatSymbols;\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.ParsePosition;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n import java.util.Date;\n-import java.util.Calendar;\n import java.util.GregorianCalendar;\n+import java.util.HashMap;\n+import java.util.List;\n import java.util.Locale;\n+import java.util.Map;\n import java.util.TimeZone;\n-import java.util.List;\n-import java.util.ArrayList;\n-import java.util.Map;\n-import java.util.HashMap;\n-import java.text.DateFormatSymbols;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n \n /**\n- * Similar to {@link java.text.SimpleDateFormat}, but faster and thread-safe.\n+ * FastDateFormat is similar to {@link java.text.SimpleDateFormat}, but \n+ * faster and thread-safe.\n+ * <p>\n  * Only formatting is supported, but all patterns are compatible with\n- * SimpleDateFormat. [Code originally taken from the open source TreeTrove\n- * project.]\n+ * SimpleDateFormat.\n+ * <p>\n+ * NOTE: Code originally taken from the open source TreeTrove project.\n  *\n  * @author Brian S O'Neill\n  * @author Sean Schofield\n  * @author Gary Gregory\n- * @since 2.1\n- * @version $Id: FastDateFormat.java,v 1.4 2003/02/04 22:19:33 scolebourne Exp $\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ * @version $Id: FastDateFormat.java,v 1.5 2003/05/21 23:39:53 scolebourne Exp $\n  */\n-public class FastDateFormat {\n-    /** Style pattern */\n-    public static final Object\n-        FULL = new Integer(SimpleDateFormat.FULL),\n-        LONG = new Integer(SimpleDateFormat.LONG),\n-        MEDIUM = new Integer(SimpleDateFormat.MEDIUM),\n-        SHORT = new Integer(SimpleDateFormat.SHORT);\n-\n+public class FastDateFormat extends Format {\n+    \n+    /** FULL date or time style */\n+    public static final int FULL = SimpleDateFormat.FULL;\n+    /** LONG date or time style */\n+    public static final int LONG = SimpleDateFormat.LONG;\n+    /** MEDIUM date or time style */\n+    public static final int MEDIUM = SimpleDateFormat.MEDIUM;\n+    /** SHORT date or time style */\n+    public static final int SHORT = SimpleDateFormat.SHORT;\n+    \n     // package scoped as used by inner class\n     static final double LOG_10 = Math.log(10);\n \n     private static String cDefaultPattern;\n     private static TimeZone cDefaultTimeZone = TimeZone.getDefault();\n-\n-    private static Map cTimeZoneDisplayCache = new HashMap();\n \n     private static Map cInstanceCache = new HashMap(7);\n     private static Map cDateInstanceCache = new HashMap(7);\n     private static Map cTimeInstanceCache = new HashMap(7);\n     private static Map cDateTimeInstanceCache = new HashMap(7);\n-\n+    private static Map cTimeZoneDisplayCache = new HashMap(7);\n+\n+    /** The pattern */\n+    private final String mPattern;\n+    /** The time zone */\n+    private final TimeZone mTimeZone;\n+    /** The locale */\n+    private final Locale mLocale;\n+    /** The parsed rules */\n+    private final Rule[] mRules;\n+    /** The estimated maximum length */\n+    private final int mMaxLengthEstimate;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a formatter instance using the default pattern in the default locale.\n+     * \n+     * @return a date/time formatter\n+     */\n     public static FastDateFormat getInstance() {\n-        //return getInstance(getDefaultPattern(), null, null, null);\n         return getInstance(getDefaultPattern(), null, null);\n     }\n \n     /**\n-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n+     * Gets a formatter instance using the specified pattern in the default locale.\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern\n+     * @return a pattern based date/time formatter\n+     * @throws IllegalArgumentException if pattern is invalid\n      */\n     public static FastDateFormat getInstance(String pattern) {\n-        //return getInstance(pattern, null, null, null);\n         return getInstance(pattern, null, null);\n     }\n \n     /**\n-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n-     * @param timeZone optional time zone, overrides time zone of formatted\n-     * date\n+     * Gets a formatter instance using the specified pattern and time zone.\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern\n+     * @param timeZone  optional time zone, overrides time zone of formatted date\n+     * @return a pattern based date/time formatter\n+     * @throws IllegalArgumentException if pattern is invalid\n      */\n     public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {\n-        //return getInstance(pattern, timeZone, null, null);\n         return getInstance(pattern, timeZone, null);\n     }\n \n     /**\n-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n-     * @param locale optional locale, overrides system locale\n+     * Gets a formatter instance using the specified pattern and locale.\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern\n+     * @param locale  optional locale, overrides system locale\n+     * @return a pattern based date/time formatter\n+     * @throws IllegalArgumentException if pattern is invalid\n      */\n     public static FastDateFormat getInstance(String pattern, Locale locale) {\n-        //return getInstance(pattern, null, locale, null);\n         return getInstance(pattern, null, locale);\n     }\n \n     /**\n-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n-     * @param symbols optional date format symbols, overrides symbols for\n-     * system locale\n-     */\n-    /*\n-    public static FastDateFormat getInstance\n-        (String pattern, DateFormatSymbols symbols)\n-        throws IllegalArgumentException\n-    {\n-        return getInstance(pattern, null, null, symbols);\n-    }\n-    */\n-\n-    /**\n-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n-     * @param timeZone optional time zone, overrides time zone of formatted\n-     * date\n-     * @param locale optional locale, overrides system locale\n-     */\n-    public static FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\n-        //return getInstance(pattern, timeZone, locale, null);\n+     * Gets a formatter instance using the specified pattern, time zone and locale.\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern\n+     * @param timeZone  optional time zone, overrides time zone of formatted date\n+     * @param locale  optional locale, overrides system locale\n+     * @return a pattern based date/time formatter\n+     * @throws IllegalArgumentException if pattern is invalid\n+     */\n+    public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\n         Object key = pattern;\n-\n         if (timeZone != null) {\n             key = new Pair(key, timeZone);\n         }\n             key = new Pair(key, locale);\n         }\n \n-        FastDateFormat format = (FastDateFormat)cInstanceCache.get(key);\n+        FastDateFormat format = (FastDateFormat) cInstanceCache.get(key);\n         if (format == null) {\n             if (locale == null) {\n                 locale = Locale.getDefault();\n     }\n \n     /**\n-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n-     * @param timeZone optional time zone, overrides time zone of formatted\n-     * date\n-     * @param locale optional locale, overrides system locale\n-     * @param symbols optional date format symbols, overrides symbols for\n-     * provided locale\n-     */\n-    /*\n-    public static synchronized FastDateFormat getInstance\n-        (String pattern, TimeZone timeZone, Locale locale,\n-         DateFormatSymbols symbols)\n-        throws IllegalArgumentException\n-    {\n-        Object key = pattern;\n-\n+     * Gets a date formatter instance using the specified style, time zone and locale.\n+     * \n+     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of formatted date\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard date formatter\n+     * @throws IllegalArgumentException if the Locale has no date pattern defined\n+     */\n+    public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {\n+        Object key = new Integer(style);\n         if (timeZone != null) {\n             key = new Pair(key, timeZone);\n         }\n-        if (locale != null) {\n+        if (locale == null) {\n             key = new Pair(key, locale);\n         }\n-        if (symbols != null) {\n-            key = new Pair(key, symbols);\n-        }\n-\n-        FastDateFormat format = (FastDateFormat)cInstanceCache.get(key);\n+\n+        FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\n         if (format == null) {\n             if (locale == null) {\n                 locale = Locale.getDefault();\n             }\n-            if (symbols == null) {\n-                symbols = new DateFormatSymbols(locale);\n-            }\n-            format = new FastDateFormat(pattern, timeZone, locale, symbols);\n-            cInstanceCache.put(key, format);\n+\n+            try {\n+                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n+                String pattern = formatter.toPattern();\n+                format = getInstance(pattern, timeZone, locale);\n+                cDateInstanceCache.put(key, format);\n+                \n+            } catch (ClassCastException ex) {\n+                throw new IllegalArgumentException(\"No date pattern for locale: \" + locale);\n+            }\n         }\n         return format;\n     }\n-    */\n-\n-    /**\n-     * @param style date style: FULL, LONG, MEDIUM, or SHORT (corresponds to those in java.text.DateFormat)\n-     * @param timeZone optional time zone, overrides time zone of formatted\n-     * date\n-     * @param locale optional locale, overrides system locale\n-     */\n-    public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {\n+\n+    /**\n+     * Gets a time formatter instance using the specified style, time zone and locale.\n+     * \n+     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of formatted time\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard time formatter\n+     * @throws IllegalArgumentException if the Locale has no time pattern defined\n+     */\n+    public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {\n         Object key = new Integer(style);\n-\n         if (timeZone != null) {\n             key = new Pair(key, timeZone);\n         }\n-        if (locale == null) {\n+        if (locale != null) {\n             key = new Pair(key, locale);\n         }\n \n-        FastDateFormat format = (FastDateFormat)cDateInstanceCache.get(key);\n-\n+        FastDateFormat format = (FastDateFormat) cTimeInstanceCache.get(key);\n         if (format == null) {\n             if (locale == null) {\n                 locale = Locale.getDefault();\n             }\n \n             try {\n-                String pattern = ((SimpleDateFormat)DateFormat.getDateInstance(style, locale)).toPattern();\n+                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);\n+                String pattern = formatter.toPattern();\n                 format = getInstance(pattern, timeZone, locale);\n-                cDateInstanceCache.put(key, format);\n-            }\n-            catch (ClassCastException e) {\n-                throw new IllegalArgumentException\n-                    (\"No date pattern for locale: \" + locale);\n-            }\n-        }\n-\n+                cTimeInstanceCache.put(key, format);\n+            \n+            } catch (ClassCastException ex) {\n+                throw new IllegalArgumentException(\"No date pattern for locale: \" + locale);\n+            }\n+        }\n         return format;\n     }\n \n     /**\n-     * @param style time style: FULL, LONG, MEDIUM, or SHORT\n-     * @param timeZone optional time zone, overrides time zone of formatted\n-     * date\n-     * @param locale optional locale, overrides system locale\n-     */\n-    public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {\n-        Object key = new Integer(style);\n-\n+     * Gets a date/time formatter instance using the specified style, time zone and locale.\n+     * \n+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of formatted date\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard date/time formatter\n+     * @throws IllegalArgumentException if the Locale has no date/time pattern defined\n+     */\n+    public static synchronized FastDateFormat getDateTimeInstance(\n+            int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {\n+\n+        Object key = new Pair(new Integer(dateStyle), new Integer(timeStyle));\n         if (timeZone != null) {\n             key = new Pair(key, timeZone);\n         }\n             key = new Pair(key, locale);\n         }\n \n-        FastDateFormat format = (FastDateFormat)cTimeInstanceCache.get(key);\n-\n+        FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);\n         if (format == null) {\n-\n             if (locale == null) {\n                 locale = Locale.getDefault();\n             }\n \n             try {\n-                String pattern = ((SimpleDateFormat)DateFormat.getTimeInstance(style, locale)).toPattern();\n-                format = getInstance(pattern, timeZone, locale);\n-                cTimeInstanceCache.put(key, format);\n-            }\n-            catch (ClassCastException e) {\n-                throw new IllegalArgumentException\n-                    (\"No date pattern for locale: \" + locale);\n-            }\n-        }\n-\n-        return format;\n-    }\n-\n-    /**\n-     * @param dateStyle date style: FULL, LONG, MEDIUM, or SHORT\n-     * @param timeStyle time style: FULL, LONG, MEDIUM, or SHORT\n-     * @param timeZone optional time zone, overrides time zone of formatted\n-     * date\n-     * @param locale optional locale, overrides system locale\n-     */\n-    public static synchronized FastDateFormat getDateTimeInstance(Object dateStyle, Object timeStyle,\n-            TimeZone timeZone, Locale locale) {\n-\n-        Object key = new Pair(dateStyle, timeStyle);\n-\n-        if (timeZone != null) {\n-            key = new Pair(key, timeZone);\n-        }\n-        if (locale != null) {\n-            key = new Pair(key, locale);\n-        }\n-\n-        FastDateFormat format =\n-            (FastDateFormat)cDateTimeInstanceCache.get(key);\n-\n-        if (format == null) {\n-            int ds;\n-            try {\n-                ds = ((Integer)dateStyle).intValue();\n-            }\n-            catch (ClassCastException e) {\n-                throw new IllegalArgumentException\n-                    (\"Illegal date style: \" + dateStyle);\n-            }\n-\n-            int ts;\n-            try {\n-                ts = ((Integer)timeStyle).intValue();\n-            }\n-            catch (ClassCastException e) {\n-                throw new IllegalArgumentException\n-                    (\"Illegal time style: \" + timeStyle);\n-            }\n-\n-            if (locale == null) {\n-                locale = Locale.getDefault();\n-            }\n-\n-            try {\n-                String pattern = ((SimpleDateFormat)DateFormat.getDateTimeInstance(ds, ts, locale)).toPattern();\n+                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);\n+                String pattern = formatter.toPattern();\n                 format = getInstance(pattern, timeZone, locale);\n                 cDateTimeInstanceCache.put(key, format);\n-            }\n-            catch (ClassCastException e) {\n-                throw new IllegalArgumentException\n-                    (\"No date time pattern for locale: \" + locale);\n-            }\n-        }\n-\n+                \n+            } catch (ClassCastException ex) {\n+                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n+            }\n+        }\n         return format;\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the time zone display name, using a cache for performance.\n+     * \n+     * @param tz  the zone to query\n+     * @param daylight  true if daylight savings\n+     * @param style  the style to use TimeZone.LONG or TimeZone.SHORT\n+     * @param locale  the locale to use\n+     * @return the textual name of the time zone\n+     */\n     static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\n         Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n-        String value = (String)cTimeZoneDisplayCache.get(key);\n+        String value = (String) cTimeZoneDisplayCache.get(key);\n         if (value == null) {\n             // This is a very slow call, so cache the results.\n             value = tz.getDisplayName(daylight, style, locale);\n         return value;\n     }\n \n+    /**\n+     * Gets the default pattern.\n+     * \n+     * @return the default pattern\n+     */\n     private static synchronized String getDefaultPattern() {\n         if (cDefaultPattern == null) {\n             cDefaultPattern = new SimpleDateFormat().toPattern();\n     }\n \n     /**\n-     * Returns a list of Rules.\n+     * Returns a list of Rules given a pattern.\n+     * \n+     * @param pattern  the pattern to parse\n+     * @param timeZone  the time zone to use\n+     * @param locale  the locale to use\n+     * @param symbols  the symbols to use\n+     * @return a List of Rule objects\n+     * @throws IllegalArgumentException if pattern is invalid\n      */\n     private static List parse(String pattern, TimeZone timeZone, Locale locale, DateFormatSymbols symbols) {\n         List rules = new ArrayList();\n         int length = pattern.length();\n         int[] indexRef = new int[1];\n \n-        for (int i=0; i<length; i++) {\n+        for (int i = 0; i < length; i++) {\n             indexRef[0] = i;\n             String token = parseToken(pattern, indexRef);\n             i = indexRef[0];\n             case 'y': // year (number)\n                 if (tokenLen >= 4) {\n                     rule = new UnpaddedNumberField(Calendar.YEAR);\n-                }\n-                else {\n+                } else {\n                     rule = new TwoDigitYearField();\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n-                }\n-                else if (tokenLen == 3) {\n+                } else if (tokenLen == 3) {\n                     rule = new TextField(Calendar.MONTH, shortMonths);\n-                }\n-                else if (tokenLen == 2) {\n+                } else if (tokenLen == 2) {\n                     rule = new TwoDigitMonthField();\n-                }\n-                else {\n+                } else {\n                     rule = new UnpaddedMonthField();\n                 }\n                 break;\n                 rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n                 break;\n             case 'h': // hour in am/pm (number, 1..12)\n-                rule = new TwelveHourField\n-                    (selectNumberRule(Calendar.HOUR, tokenLen));\n+                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n                 break;\n             case 'H': // hour in day (number, 0..23)\n                 rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n                 rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n                 break;\n             case 'E': // day in week (text)\n-                rule = new TextField\n-                    (Calendar.DAY_OF_WEEK,\n-                     tokenLen < 4 ? shortWeekdays : weekdays);\n+                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n                 break;\n             case 'D': // day in year (number)\n                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n                 break;\n             case 'F': // day of week in month (number)\n-                rule = selectNumberRule\n-                    (Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n+                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n                 break;\n             case 'w': // week in year (number)\n                 rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n                 rule = new TextField(Calendar.AM_PM, AmPmStrings);\n                 break;\n             case 'k': // hour in day (1..24)\n-                rule = new TwentyFourHourField\n-                    (selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n+                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n                 break;\n             case 'K': // hour in am/pm (0..11)\n                 rule = selectNumberRule(Calendar.HOUR, tokenLen);\n             case 'z': // time zone (text)\n                 if (tokenLen >= 4) {\n                     rule = new TimeZoneRule(timeZone, locale, TimeZone.LONG);\n-                }\n-                else {\n+                } else {\n                     rule = new TimeZoneRule(timeZone, locale, TimeZone.SHORT);\n                 }\n                 break;\n                 String sub = token.substring(1);\n                 if (sub.length() == 1) {\n                     rule = new CharacterLiteral(sub.charAt(0));\n-                }\n-                else {\n+                } else {\n                     rule = new StringLiteral(new String(sub));\n                 }\n                 break;\n             default:\n-                throw new IllegalArgumentException\n-                    (\"Illegal pattern component: \" + token);\n+                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n             }\n \n             rules.add(rule);\n         return rules;\n     }\n \n+    /**\n+     * Performs the parsing of tokens.\n+     * \n+     * @param pattern  the pattern\n+     * @param indexRef  index references\n+     * @return parsed token\n+     */\n     private static String parseToken(String pattern, int[] indexRef) {\n         StringBuffer buf = new StringBuffer();\n \n                 if (peek == c) {\n                     buf.append(c);\n                     i++;\n-                }\n-                else {\n+                } else {\n                     break;\n                 }\n             }\n-        }\n-        else {\n+        } else {\n             // This will identify token as text.\n             buf.append('\\'');\n \n                         // '' is treated as escaped '\n                         i++;\n                         buf.append(c);\n-                    }\n-                    else {\n+                    } else {\n                         inLiteral = !inLiteral;\n                     }\n-                }\n-                else if (!inLiteral &&\n+                } else if (!inLiteral &&\n                          (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n                     i--;\n                     break;\n-                }\n-                else {\n+                } else {\n                     buf.append(c);\n                 }\n             }\n         return buf.toString();\n     }\n \n+    /**\n+     * Gets an appropriate rule for the padding required.\n+     * \n+     * @param field  the field to get a rule for\n+     * @param padding  the padding required\n+     * @return a new rule with the correct padding\n+     */\n     private static NumberRule selectNumberRule(int field, int padding) {\n         switch (padding) {\n         case 1:\n         }\n     }\n \n-    private final String mPattern;\n-    private final TimeZone mTimeZone;\n-    private final Locale mLocale;\n-    private final Rule[] mRules;\n-    private final int mMaxLengthEstimate;\n-\n-    private FastDateFormat() {\n-        this(getDefaultPattern(), null, null, null);\n-    }\n-\n-    /**\n-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n-     */\n-    private FastDateFormat(String pattern) throws IllegalArgumentException {\n-        this(pattern, null, null, null);\n-    }\n-\n-    /**\n-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n-     * @param timeZone optional time zone, overrides time zone of formatted\n-     * date\n-     */\n-    private FastDateFormat(String pattern, TimeZone timeZone) {\n-        this(pattern, timeZone, null, null);\n-    }\n-\n-    /**\n-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n-     * @param locale optional locale, overrides system locale\n-     */\n-    private FastDateFormat(String pattern, Locale locale) {\n-        this(pattern, null, locale, null);\n-    }\n-\n-    /**\n-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n-     * @param symbols optional date format symbols, overrides symbols for\n-     * system locale\n-     */\n-    private FastDateFormat(String pattern, DateFormatSymbols symbols) {\n-        this(pattern, null, null, symbols);\n-    }\n-\n-    /**\n-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n-     * @param timeZone optional time zone, overrides time zone of formatted\n-     * date\n-     * @param locale optional locale, overrides system locale\n-     */\n-    private FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\n-        this(pattern, timeZone, locale, null);\n-    }\n-\n-    /**\n-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n-     * @param timeZone optional time zone, overrides time zone of formatted\n-     * date\n-     * @param locale optional locale, overrides system locale\n-     * @param symbols optional date format symbols, overrides symbols for\n-     * provided locale\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new FastDateFormat.\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern\n+     * @param timeZone  optional time zone, overrides time zone of formatted date\n+     * @param locale  optional locale, overrides system locale\n+     * @param symbols  optional date format symbols, overrides symbols for provided locale\n+     * @throws IllegalArgumentException if pattern is invalid\n      */\n     private FastDateFormat(String pattern, TimeZone timeZone, Locale locale, DateFormatSymbols symbols) {\n         if (locale == null) {\n         }\n \n         List rulesList = parse(pattern, timeZone, locale, symbols);\n-        mRules = (Rule[])rulesList.toArray(new Rule[rulesList.size()]);\n+        mRules = (Rule[]) rulesList.toArray(new Rule[rulesList.size()]);\n \n         int len = 0;\n         for (int i=mRules.length; --i >= 0; ) {\n         mMaxLengthEstimate = len;\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Format either a Date or a Calendar object.\n+     * \n+     * @param obj  the object to format\n+     * @param toAppendTo  the buffer to append to\n+     * @param pos  the position - ignored\n+     * @return the buffer passed in\n+     */\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+        if (obj instanceof Date) {\n+            return format((Date) obj, toAppendTo);\n+        } else if (obj instanceof Calendar) {\n+            return format((Calendar) obj, toAppendTo);\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown class: \" +\n+                (obj == null ? \"<null>\" : obj.getClass().getName()));\n+        }\n+    }\n+\n+    /**\n+     * Formats a Date object.\n+     * \n+     * @param date  the date to format\n+     * @return the formatted string\n+     */\n     public String format(Date date) {\n         Calendar c = new GregorianCalendar(cDefaultTimeZone);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n+    /**\n+     * Formats a Calendar object.\n+     * \n+     * @param calendar  the calendar to format\n+     * @return the formatted string\n+     */\n     public String format(Calendar calendar) {\n-        return format(calendar, new StringBuffer(mMaxLengthEstimate))\n-            .toString();\n-    }\n-\n+        return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n+    }\n+\n+    /**\n+     * Formats a Date object into the supplied StringBuffer.\n+     * \n+     * @param date  the date to format\n+     * @param buf  the buffer to format into\n+     * @return the specified string buffer\n+     */\n     public StringBuffer format(Date date, StringBuffer buf) {\n         Calendar c = new GregorianCalendar(cDefaultTimeZone);\n         c.setTime(date);\n         return applyRules(c, buf);\n     }\n \n+    /**\n+     * Formats a Calendar object into the supplied StringBuffer.\n+     * \n+     * @param calendar  the calendar to format\n+     * @param buf  the buffer to format into\n+     * @return the specified string buffer\n+     */\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n         if (mTimeZone != null) {\n             calendar = (Calendar)calendar.clone();\n         return applyRules(calendar, buf);\n     }\n \n+    /**\n+     * Performs the formatting by applying the rules to the specified calendar.\n+     * \n+     * @param calendar  the calendar to format\n+     * @param buf  the buffer to format into\n+     * @return the specified string buffer\n+     */\n     private StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n         Rule[] rules = mRules;\n         int len = mRules.length;\n-        for (int i=0; i<len; i++) {\n+        for (int i = 0; i < len; i++) {\n             rules[i].appendTo(buf, calendar);\n         }\n         return buf;\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Parsing not supported.\n+     * \n+     * @param source  the string to parse\n+     * @param pos  the parsing position\n+     * @return null as not supported\n+     */\n+    public Object parseObject(String source, ParsePosition pos) {\n+        pos.setIndex(0);\n+        pos.setErrorIndex(0);\n+        return null;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the pattern used by this formatter.\n+     * \n+     * @return the pattern, {@link java.text.SimpleDateFormat} compatible\n+     */\n     public String getPattern() {\n         return mPattern;\n     }\n \n     /**\n-     * Returns the time zone used by this formatter, or null if time zone of\n+     * Gets the time zone used by this formatter, or null if time zone of\n      * formatted dates is used instead.\n+     * \n+     * @return the time zone\n      */\n     public TimeZone getTimeZone() {\n         return mTimeZone;\n     }\n \n+    /**\n+     * Gets the locale used by this formatter.\n+     * \n+     * @return the locale\n+     */\n     public Locale getLocale() {\n         return mLocale;\n     }\n \n     /**\n-     * Returns an estimate for the maximum length date that this date\n-     * formatter will produce. The actual formatted length will almost always\n-     * be less than or equal to this amount.\n+     * Gets  an estimate for the maximum string length that the formatter will produce.\n+     * The actual formatted length will almost always be less than or equal to this amount.\n+     * \n+     * @return the maximum formatted length\n      */\n     public int getMaxLengthEstimate() {\n         return mMaxLengthEstimate;\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class defining a rule.\n+     */\n     private interface Rule {\n         int estimateLength();\n-\n         void appendTo(StringBuffer buffer, Calendar calendar);\n     }\n \n+    /**\n+     * Inner class defining a numeric rule.\n+     */\n     private interface NumberRule extends Rule {\n         void appendTo(StringBuffer buffer, int value);\n     }\n \n+    /**\n+     * Inner class to output a constant single character.\n+     */\n     private static class CharacterLiteral implements Rule {\n         private final char mValue;\n \n         }\n     }\n \n+    /**\n+     * Inner class to output a constant string.\n+     */\n     private static class StringLiteral implements Rule {\n         private final String mValue;\n \n         }\n     }\n \n+    /**\n+     * Inner class to output one of a set of values.\n+     */\n     private static class TextField implements Rule {\n         private final int mField;\n         private final String[] mValues;\n         }\n     }\n \n+    /**\n+     * Inner class to output an unpadded number.\n+     */\n     private static class UnpaddedNumberField implements NumberRule {\n         private final int mField;\n \n         }\n     }\n \n+    /**\n+     * Inner class to output an unpadded month.\n+     */\n     private static class UnpaddedMonthField implements NumberRule {\n         UnpaddedMonthField() {\n         }\n         }\n     }\n \n+    /**\n+     * Inner class to output a padded number.\n+     */\n     private static class PaddedNumberField implements NumberRule {\n         private final int mField;\n         private final int mSize;\n         }\n     }\n \n+    /**\n+     * Inner class to output a two digit number.\n+     */\n     private static class TwoDigitNumberField implements NumberRule {\n         private final int mField;\n \n         }\n     }\n \n+    /**\n+     * Inner class to output a two digit year.\n+     */\n     private static class TwoDigitYearField implements NumberRule {\n         TwoDigitYearField() {\n         }\n         }\n     }\n \n+    /**\n+     * Inner class to output a two digit month.\n+     */\n     private static class TwoDigitMonthField implements NumberRule {\n         TwoDigitMonthField() {\n         }\n         }\n     }\n \n+    /**\n+     * Inner class to output the twelve hour field.\n+     */\n     private static class TwelveHourField implements NumberRule {\n         private final NumberRule mRule;\n \n         }\n     }\n \n+    /**\n+     * Inner class to output the twenty four hour field.\n+     */\n     private static class TwentyFourHourField implements NumberRule {\n         private final NumberRule mRule;\n \n         }\n     }\n \n+    /**\n+     * Inner class to output a time zone.\n+     */\n     private static class TimeZoneRule implements Rule {\n         private final TimeZone mTimeZone;\n         private final Locale mLocale;\n         }\n     }\n \n+    // ----------------------------------------------------------------------------------\n+    /**\n+     * Inner class that acts as a compound key for time zone names.\n+     */\n     private static class TimeZoneDisplayKey {\n         private final TimeZone mTimeZone;\n         private final int mStyle;\n         }\n     }\n \n-    // Pair\n     // ----------------------------------------------------------------------------------\n     /**\n      * Helper class for creating compound objects.  One use for this class is to create a\n      * hashtable key out of multiple objects.\n      */\n-    private static class Pair implements Comparable, java.io.Serializable {\n+    private static class Pair implements Comparable, Serializable {\n         private final Object mObj1;\n         private final Object mObj2;\n \n             return \"[\" + mObj1 + ':' + mObj2 + ']';\n         }\n     }\n+\n }", "timestamp": 1053560393, "metainfo": ""}