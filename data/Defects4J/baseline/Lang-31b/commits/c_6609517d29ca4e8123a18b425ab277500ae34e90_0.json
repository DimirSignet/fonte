{"sha": "6609517d29ca4e8123a18b425ab277500ae34e90", "log": "(35366) Implementation of escape/unescapeHtml methods with Writer (http://issues.apache.org/bugzilla/show_bug.cgi?id=35366)  ", "commit": "\n--- a/src/java/org/apache/commons/lang/Entities.java\n+++ b/src/java/org/apache/commons/lang/Entities.java\n  */\n package org.apache.commons.lang;\n \n+import java.io.IOException;\n+import java.io.Writer;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.TreeMap;\n         {\"real\", \"8476\"}, //blackletter capital R = real part symbol,U+211C ISOamso -->\n         {\"trade\", \"8482\"}, //trade mark sign, U+2122 ISOnum -->\n         {\"alefsym\", \"8501\"}, //alef symbol = first transfinite cardinal,U+2135 NEW -->\n-// <!-- alef symbol is NOT the same as hebrew letter alef,U+05D0 although the same glyph could be used to depict both characters -->\n+// <!-- alef symbol is NOT the same as hebrew letter alef,U+05D0 although the \n+//      same glyph could be used to depict both characters -->\n // <!-- Arrows -->\n         {\"larr\", \"8592\"}, //leftwards arrow, U+2190 ISOnum -->\n         {\"uarr\", \"8593\"}, //upwards arrow, U+2191 ISOnum-->\n         {\"harr\", \"8596\"}, //left right arrow, U+2194 ISOamsa -->\n         {\"crarr\", \"8629\"}, //downwards arrow with corner leftwards= carriage return, U+21B5 NEW -->\n         {\"lArr\", \"8656\"}, //leftwards double arrow, U+21D0 ISOtech -->\n-// <!-- ISO 10646 does not say that lArr is the same as the 'is implied by' arrowbut also does not have any other character for that function. So ? lArr canbe used for 'is implied by' as ISOtech suggests -->\n+// <!-- ISO 10646 does not say that lArr is the same as the 'is implied by' \n+//      arrow but also does not have any other character for that function. \n+//      So ? lArr canbe used for 'is implied by' as ISOtech suggests -->\n         {\"uArr\", \"8657\"}, //upwards double arrow, U+21D1 ISOamsa -->\n         {\"rArr\", \"8658\"}, //rightwards double arrow,U+21D2 ISOtech -->\n-// <!-- ISO 10646 does not say this is the 'implies' character but does not have another character with this function so ?rArr can be used for 'implies' as ISOtech suggests -->\n+// <!-- ISO 10646 does not say this is the 'implies' character but does not\n+//      have another character with this function so ?rArr can be used for\n+//      'implies' as ISOtech suggests -->\n         {\"dArr\", \"8659\"}, //downwards double arrow, U+21D3 ISOamsa -->\n         {\"hArr\", \"8660\"}, //left right double arrow,U+21D4 ISOamsa -->\n // <!-- Mathematical Operators -->\n         {\"ni\", \"8715\"}, //contains as member, U+220B ISOtech -->\n // <!-- should there be a more memorable name than 'ni'? -->\n         {\"prod\", \"8719\"}, //n-ary product = product sign,U+220F ISOamsb -->\n-// <!-- prod is NOT the same character as U+03A0 'greek capital letter pi' though the same glyph might be used for both -->\n+// <!-- prod is NOT the same character as U+03A0 'greek capital letter pi' \n+//      though the same glyph might be used for both -->\n         {\"sum\", \"8721\"}, //n-ary summation, U+2211 ISOamsb -->\n-// <!-- sum is NOT the same character as U+03A3 'greek capital letter sigma' though the same glyph might be used for both -->\n+// <!-- sum is NOT the same character as U+03A3 'greek capital letter sigma'\n+//      though the same glyph might be used for both -->\n         {\"minus\", \"8722\"}, //minus sign, U+2212 ISOtech -->\n         {\"lowast\", \"8727\"}, //asterisk operator, U+2217 ISOtech -->\n         {\"radic\", \"8730\"}, //square root = radical sign,U+221A ISOtech -->\n         {\"int\", \"8747\"}, //integral, U+222B ISOtech -->\n         {\"there4\", \"8756\"}, //therefore, U+2234 ISOtech -->\n         {\"sim\", \"8764\"}, //tilde operator = varies with = similar to,U+223C ISOtech -->\n-// <!-- tilde operator is NOT the same character as the tilde, U+007E,although the same glyph might be used to represent both  -->\n+// <!-- tilde operator is NOT the same character as the tilde, U+007E,although\n+//      the same glyph might be used to represent both  -->\n         {\"cong\", \"8773\"}, //approximately equal to, U+2245 ISOtech -->\n         {\"asymp\", \"8776\"}, //almost equal to = asymptotic to,U+2248 ISOamsr -->\n         {\"ne\", \"8800\"}, //not equal to, U+2260 ISOtech -->\n         {\"ge\", \"8805\"}, //greater-than or equal to,U+2265 ISOtech -->\n         {\"sub\", \"8834\"}, //subset of, U+2282 ISOtech -->\n         {\"sup\", \"8835\"}, //superset of, U+2283 ISOtech -->\n-// <!-- note that nsup, 'not a superset of, U+2283' is not covered by the Symbol font encoding and is not included. Should it be, for symmetry?It is in ISOamsn  --> <!ENTITY nsub\", \"8836\"},  //not a subset of, U+2284 ISOamsn -->\n+// <!-- note that nsup, 'not a superset of, U+2283' is not covered by the\n+//      Symbol font encoding and is not included. Should it be, for symmetry?\n+//      It is in ISOamsn  --> <!ENTITY nsub\", \"8836\"},  \n+//      not a subset of, U+2284 ISOamsn -->\n         {\"sube\", \"8838\"}, //subset of or equal to, U+2286 ISOtech -->\n         {\"supe\", \"8839\"}, //superset of or equal to,U+2287 ISOtech -->\n         {\"oplus\", \"8853\"}, //circled plus = direct sum,U+2295 ISOamsb -->\n         {\"lang\", \"9001\"}, //left-pointing angle bracket = bra,U+2329 ISOtech -->\n // <!-- lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation mark' -->\n         {\"rang\", \"9002\"}, //right-pointing angle bracket = ket,U+232A ISOtech -->\n-// <!-- rang is NOT the same character as U+003E 'greater than' or U+203A 'single right-pointing angle quotation mark' -->\n+// <!-- rang is NOT the same character as U+003E 'greater than' or U+203A \n+//      'single right-pointing angle quotation mark' -->\n // <!-- Geometric Shapes -->\n         {\"loz\", \"9674\"}, //lozenge, U+25CA ISOpub -->\n // <!-- Miscellaneous Symbols -->\n         fillWithHtml40Entities(HTML40);\n     }\n \n+    /**\n+     * <p>Fills the specified entities instance with HTML 40 entities.</p>\n+     * \n+     * @param entities the instance to be filled.\n+     */\n     static void fillWithHtml40Entities(Entities entities) {\n         entities.addEntities(BASIC_ARRAY);\n         entities.addEntities(ISO8859_1_ARRAY);\n     }\n \n     static interface EntityMap {\n+        /**\n+         * <p>Add an entry to this entity map.</p>\n+         * \n+         * @param name the entity name\n+         * @param value the entity value\n+         */\n         void add(String name, int value);\n \n+        /**\n+         * <p>Returns the name of the entity identified by the specified value.</p>\n+         * \n+         * @param value the value to locate\n+         * @return entity name associated with the specified value\n+         */\n         String name(int value);\n \n+        /**\n+         * <p>Returns the value of the entity identified by the specified name.</p>\n+         * \n+         * @param name the name to locate\n+         * @return entity value associated with the specified name\n+         */\n         int value(String name);\n     }\n \n         private Map mapNameToValue = new HashMap();\n         private IntHashMap mapValueToName = new IntHashMap();\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public void add(String name, int value) {\n             mapNameToValue.put(name, new Integer(value));\n             mapValueToName.put(value, name);\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public String name(int value) {\n             return (String) mapValueToName.get(value);\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public int value(String name) {\n             Object value = mapNameToValue.get(name);\n             if (value == null) {\n         protected Map mapNameToValue;\n         protected Map mapValueToName;\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public void add(String name, int value) {\n             mapNameToValue.put(name, new Integer(value));\n             mapValueToName.put(new Integer(value), name);\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public String name(int value) {\n             return (String) mapValueToName.get(new Integer(value));\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public int value(String name) {\n             Object value = mapNameToValue.get(name);\n             if (value == null) {\n     }\n \n     static class HashEntityMap extends MapIntMap {\n+        /**\n+         * Constructs a new instance of <code>HashEntityMap</code>.\n+         */\n         public HashEntityMap() {\n             mapNameToValue = new HashMap();\n             mapValueToName = new HashMap();\n     }\n \n     static class TreeEntityMap extends MapIntMap {\n+      /**\n+       * Constructs a new instance of <code>TreeEntityMap</code>.\n+       */\n         public TreeEntityMap() {\n             mapNameToValue = new TreeMap();\n             mapValueToName = new TreeMap();\n         private String[] lookupTable;\n         private int LOOKUP_TABLE_SIZE = 256;\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public String name(int value) {\n             if (value < LOOKUP_TABLE_SIZE) {\n                 return lookupTable()[value];\n             return super.name(value);\n         }\n \n+        /**\n+         * <p>Returns the lookup table for this entity map. The lookup table is created if it has not been \n+         * previously.</p>\n+         * \n+         * @return the lookup table\n+         */\n         private String[] lookupTable() {\n             if (lookupTable == null) {\n                 createLookupTable();\n             return lookupTable;\n         }\n \n+        /**\n+         * <p>Creates an entity lookup table of LOOKUP_TABLE_SIZE elements, initialized with entity names.</p>\n+         */\n         private void createLookupTable() {\n             lookupTable = new String[LOOKUP_TABLE_SIZE];\n             for (int i = 0; i < LOOKUP_TABLE_SIZE; ++i) {\n         protected String[] names;\n         protected int[] values;\n \n+        /**\n+         * Constructs a new instance of <code>ArrayEntityMap</code>.\n+         */\n         public ArrayEntityMap() {\n             names = new String[growBy];\n             values = new int[growBy];\n         }\n \n+        /**\n+         * Constructs a new instance of <code>ArrayEntityMap</code>\n+         * specifying the size by which the array should grow.\n+         * \n+         * @param growBy array will be initialized to and will grow by this amount\n+         */\n         public ArrayEntityMap(int growBy) {\n             this.growBy = growBy;\n             names = new String[growBy];\n             values = new int[growBy];\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public void add(String name, int value) {\n             ensureCapacity(size + 1);\n             names[size] = name;\n             size++;\n         }\n \n+        /**\n+         * Verifies the capacity of the entity array, adjusting the size if necessary.\n+         * \n+         * @param capacity size the array should be\n+         */\n         protected void ensureCapacity(int capacity) {\n             if (capacity > names.length) {\n                 int newSize = Math.max(capacity, size + growBy);\n             }\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public String name(int value) {\n             for (int i = 0; i < size; ++i) {\n                 if (values[i] == value) {\n             return null;\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public int value(String name) {\n             for (int i = 0; i < size; ++i) {\n                 if (names[i].equals(name)) {\n \n     static class BinaryEntityMap extends ArrayEntityMap {\n \n+        /**\n+         * Constructs a new instance of <code>BinaryEntityMap</code>.\n+         */\n         public BinaryEntityMap() {\n-        }\n-\n+          ; // empty constructor\n+        }\n+\n+        /**\n+         * Constructs a new instance of <code>ArrayEntityMap</code>\n+         * specifying the size by which the underlying array should grow.\n+         * \n+         * @param growBy array will be initialized to and will grow by this amount\n+         */\n         public BinaryEntityMap(int growBy) {\n             super(growBy);\n         }\n \n-        // based on code in java.util.Arrays\n+        /**\n+         * Performs a binary search of the entity array for the specified key.\n+         * This method is based on code in {@link java.util.Arrays}.\n+         * \n+         * @param key the key to be found\n+         * @return the index of the entity array matching the specified key\n+         */\n         private int binarySearch(int key) {\n             int low = 0;\n             int high = size - 1;\n             return -(low + 1);  // key not found.\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public void add(String name, int value) {\n             ensureCapacity(size + 1);\n             int insertAt = binarySearch(value);\n             size++;\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public String name(int value) {\n             int index = binarySearch(value);\n             if (index < 0) {\n     // package scoped for testing\n     EntityMap map = new Entities.LookupEntityMap();\n \n+    /**\n+     * <p>Adds entities to this entity.</p>\n+     * \n+     * @param entityArray array of entities to be added\n+     */\n     public void addEntities(String[][] entityArray) {\n         for (int i = 0; i < entityArray.length; ++i) {\n             addEntity(entityArray[i][0], Integer.parseInt(entityArray[i][1]));\n         }\n     }\n \n+    /**\n+     * <p>Add an entity to this entity.</p>\n+     * \n+     * @param name name of the entity\n+     * @param value vale of the entity\n+     */\n     public void addEntity(String name, int value) {\n         map.add(name, value);\n     }\n \n+    /**\n+     * <p>Returns the name of the entity identified by the specified value.</p>\n+     * \n+     * @param value the value to locate\n+     * @return entity name associated with the specified value\n+     */\n     public String entityName(int value) {\n         return map.name(value);\n     }\n \n-\n+    /**\n+     * <p>Returns the value of the entity identified by the specified name.</p>\n+     * \n+     * @param name the name to locate\n+     * @return entity value associated with the specified name\n+     */\n     public int entityValue(String name) {\n         return map.value(name);\n     }\n         return buf.toString();\n     }\n \n+    /**\n+     * <p>Escapes the characters in the <code>String</code> passed and writes the result\n+     * to the <code>Writer</code> passed. </p>\n+     * \n+     * @param writer The <code>Writer</code> to write the results of the escaping to.\n+     *                            Assumed to be a non-null value.\n+     * @param str The <code>String</code> to escape. Assumed to be a non-null value.\n+     * @throws IOException when <code>Writer</code> passed throws the exception from\n+     *                                       calls to the {@link Writer#write(int)} methods.\n+     *                                       \n+     * @see #escape(String)\n+     * @see Writer\n+     */\n+    public void escape(Writer writer, String str) throws IOException {\n+        int len = str.length();\n+        for (int i = 0; i < len; i++) {\n+            char c = str.charAt(i);\n+            String entityName = this.entityName(c);\n+            if (entityName == null) {\n+                if (c > 0x7F) {\n+                    writer.write(\"&#\");\n+                    writer.write(Integer.toString(c, 10));\n+                    writer.write(';');\n+                } else {\n+                    writer.write(c);\n+                }\n+            } else {\n+                writer.write('&');\n+                writer.write(entityName);\n+                writer.write(';');\n+            }\n+        }\n+    }\n+    \n     /**\n      * <p>Unescapes the entities in a <code>String</code>.</p>\n      *\n         return buf.toString();\n     }\n \n+    /**\n+     * <p>Unescapes the escaped entities in the <code>String</code> passed and\n+     * writes the result to the <code>Writer</code> passed.</p>\n+     * \n+     * @param writer The <code>Writer</code> to write the results to; assumed to be non-null.\n+     * @param string The <code>String</code> to write the results to; assumed to be non-null.\n+     * @throws IOException when <code>Writer</code> passed throws the exception from\n+     *                                       calls to the {@link Writer#write(int)} methods.\n+     *                                       \n+     * @see #escape(String)\n+     * @see Writer\n+     */\n+    public void unescape(Writer writer, String string) throws IOException {\n+        int len = string.length();\n+        if (len == 0) {\n+            return;\n+        }\n+        for (int i = 0; i < len; i++) {\n+            char c = string.charAt(i);\n+            if (c == '&') {\n+                int nextIdx = i+1;\n+                int semiColonIdx = string.indexOf(';', nextIdx);\n+                if (semiColonIdx == -1) {\n+                    writer.write(c);\n+                    continue;\n+                }\n+                String entityContent = string.substring(nextIdx, semiColonIdx);\n+                int entityValue = -1;\n+                int entityContentLen = entityContent.length();\n+                if (entityContentLen > 0) {\n+                    if (entityContent.charAt(0) == '#') { //escaped value content is an integer (decimal or hexidecimal)\n+                        if (entityContentLen > 1) {  \n+                            char isHexChar = entityContent.charAt(1);\n+                            try {\n+                                switch (isHexChar) {\n+                                    case 'X' :\n+                                    case 'x' : {\n+                                        entityValue = Integer.parseInt(entityContent.substring(2), 16);\n+                                    }\n+                                    default : {\n+                                        entityValue = Integer.parseInt(entityContent.substring(1), 10);\n+                                    }\n+                                }\n+                            } catch (NumberFormatException e) {\n+                            }\n+                        }\n+                    } else { //escaped value content is an entity name\n+                        entityValue = this.entityValue(entityContent);\n+                    }\n+                }\n+                \n+                if (entityValue == -1) {\n+                    writer.write('&');\n+                    writer.write(entityContent);\n+                    writer.write(';');\n+                } else {\n+                    writer.write(entityValue);\n+                }\n+                i = semiColonIdx; //move index up to the semi-colon                \n+            } else {\n+                writer.write(c);\n+            }\n+        }\n+    }\n+    \n }\n--- a/src/java/org/apache/commons/lang/StringEscapeUtils.java\n+++ b/src/java/org/apache/commons/lang/StringEscapeUtils.java\n      * @return a new escaped <code>String</code>, <code>null</code> if null string input\n      * \n      * @see #unescapeHtml(String)\n-     * @see </br><a href=\"http://hotwired.lycos.com/webmonkey/reference/special_characters/\">ISO Entities</a>\n-     * @see </br><a href=\"http://www.w3.org/TR/REC-html32#latin1\">HTML 3.2 Character Entities for ISO Latin-1</a>\n-     * @see </br><a href=\"http://www.w3.org/TR/REC-html40/sgml/entities.html\">HTML 4.0 Character entity references</a>\n-     * @see </br><a href=\"http://www.w3.org/TR/html401/charset.html#h-5.3\">HTML 4.01 Character References</a>\n-     * @see </br><a href=\"http://www.w3.org/TR/html401/charset.html#code-position\">HTML 4.01 Code positions</a>\n+     * @see <a href=\"http://hotwired.lycos.com/webmonkey/reference/special_characters/\">ISO Entities</a>\n+     * @see <a href=\"http://www.w3.org/TR/REC-html32#latin1\">HTML 3.2 Character Entities for ISO Latin-1</a>\n+     * @see <a href=\"http://www.w3.org/TR/REC-html40/sgml/entities.html\">HTML 4.0 Character entity references</a>\n+     * @see <a href=\"http://www.w3.org/TR/html401/charset.html#h-5.3\">HTML 4.01 Character References</a>\n+     * @see <a href=\"http://www.w3.org/TR/html401/charset.html#code-position\">HTML 4.01 Code positions</a>\n      **/\n     public static String escapeHtml(String str) {\n         if (str == null) {\n             return null;\n         }\n-        //todo: add a version that takes a Writer\n-        //todo: rewrite underlying method to use a Writer instead of a StringBuffer\n-        return Entities.HTML40.escape(str);\n+        \n+        try {\n+            StringPrintWriter writer = new StringPrintWriter ((int)(str.length() * 1.5));\n+            escapeHtml(writer, str);\n+            return writer.getString();\n+        } catch (IOException e) {\n+            //assert false;\n+            //should be impossible\n+            e.printStackTrace();\n+            return null;\n+        }\n+    }\n+    \n+    /**\n+     * <p>Escapes the characters in a <code>String</code> using HTML entities and writes\n+     * them to a <code>Writer</code>.</p>\n+     *\n+     * <p>\n+     * For example:\n+     * </p> \n+     * <code>\"bread\" & \"butter\"</code>\n+     * <p>becomes:</p>\n+     * <code>&amp;quot;bread&amp;quot; &amp;amp; &amp;quot;butter&amp;quot;</code>.\n+     * \n+     * <p>Supports all known HTML 4.0 entities, including funky accents.</p>\n+     * \n+     * @param writer The <code>Writer</code> to write the result to. This must not be <code>null</code>.\n+     * @param string  The <code>String</code> to escape. This may be <code>null</code>.\n+     * \n+     * @throws IOException when <code>Writer</code> passed throws the exception from\n+     *                                       calls to the {@link Writer#write(int)} methods.\n+     * \n+     * @see #escapeHtml(String)\n+     * @see #unescapeHtml(String)\n+     * @see <a href=\"http://hotwired.lycos.com/webmonkey/reference/special_characters/\">ISO Entities</a>\n+     * @see <a href=\"http://www.w3.org/TR/REC-html32#latin1\">HTML 3.2 Character Entities for ISO Latin-1</a>\n+     * @see <a href=\"http://www.w3.org/TR/REC-html40/sgml/entities.html\">HTML 4.0 Character entity references</a>\n+     * @see <a href=\"http://www.w3.org/TR/html401/charset.html#h-5.3\">HTML 4.01 Character References</a>\n+     * @see <a href=\"http://www.w3.org/TR/html401/charset.html#code-position\">HTML 4.01 Code positions</a>\n+     */\n+    public static void escapeHtml(Writer writer, String string) throws IOException {\n+        if (writer == null ) {\n+            throw new IllegalArgumentException (\"The Writer must not be null.\");\n+        }\n+        \n+        if (string == null) {\n+            return;\n+        }\n+        \n+        Entities.HTML40.escape(writer, string);\n     }\n \n     /**\n         if (str == null) {\n             return null;\n         }\n-        return Entities.HTML40.unescape(str);\n+        \n+        try {\n+            StringPrintWriter writer = new StringPrintWriter ((int)(str.length() * 1.5));\n+            unescapeHtml(writer, str);\n+            return writer.getString();\n+        } catch (IOException e) {\n+            //assert false;\n+            //should be impossible\n+            e.printStackTrace();\n+            return null;\n+        }\n+    }\n+    \n+    public static void unescapeHtml(Writer writer, String string) throws IOException {\n+        if (writer == null ) {\n+            throw new IllegalArgumentException (\"The Writer must not be null.\");\n+        }\n+        \n+        if (string == null) {\n+            return;\n+        }\n+        \n+        Entities.HTML40.unescape(writer, string);\n     }\n \n     /**\n--- a/src/test/org/apache/commons/lang/StringEscapeUtilsTest.java\n+++ b/src/test/org/apache/commons/lang/StringEscapeUtilsTest.java\n             String expected = htmlEscapes[i][1];\n             String original = htmlEscapes[i][2];\n             assertEquals(message, expected, StringEscapeUtils.escapeHtml(original));\n-            // todo: add test for (and implement) Writer-based version, something like this:\n-//            StringPrintWriter sw = new StringPrintWriter();\n-//            StringEscapeUtils.escapeHtml(sw, original);\n-//            assertEquals(expected, sw.getString());\n+            StringPrintWriter sw = new StringPrintWriter();\n+            try {\n+            StringEscapeUtils.escapeHtml(sw, original);\n+            } catch (IOException e) {\n+            }\n+            String actual = original == null ? null : sw.getString();\n+            assertEquals(message, expected, actual);\n         }\n     }\n \n     public void testUnescapeHtml() {\n         for (int i = 0; i < htmlEscapes.length; ++i) {\n-            assertEquals(htmlEscapes[i][0], htmlEscapes[i][2], StringEscapeUtils.unescapeHtml(htmlEscapes[i][1]));\n-            // todo: add test for (and implement) Writer-based version\n+            String message = htmlEscapes[i][0];\n+            String expected = htmlEscapes[i][2];\n+            String original = htmlEscapes[i][1];\n+            assertEquals(message, expected, StringEscapeUtils.unescapeHtml(original));\n+            \n+            StringPrintWriter sw = new StringPrintWriter();\n+            try {\n+            StringEscapeUtils.unescapeHtml(sw, original);\n+            } catch (IOException e) {\n+            }\n+            String actual = original == null ? null : sw.getString();\n+            assertEquals(message, expected, actual);\n         }\n         // \\u00E7 is a cedilla (c with wiggle under)\n         // note that the test string must be 7-bit-clean (unicode escaped) or else it will compile incorrectly", "timestamp": 1119804996, "metainfo": ""}