{"sha": "aeb61edce7e99f7997b6a928d1d879585426b883", "log": "Fix raw Class types  ", "commit": "\n--- a/src/java/org/apache/commons/lang/reflect/MethodUtils.java\n+++ b/src/java/org/apache/commons/lang/reflect/MethodUtils.java\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n         }\n         int arguments = args.length;\n-        Class[] parameterTypes = new Class[arguments];\n+        Class<?>[] parameterTypes = new Class[arguments];\n         for (int i = 0; i < arguments; i++) {\n             parameterTypes[i] = args[i].getClass();\n         }\n      * @throws IllegalAccessException if the requested method is not accessible via reflection\n      */\n     public static Object invokeMethod(Object object, String methodName,\n-            Object[] args, Class[] parameterTypes)\n+            Object[] args, Class<?>[] parameterTypes)\n             throws NoSuchMethodException, IllegalAccessException,\n             InvocationTargetException {\n         if (parameterTypes == null) {\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n         }\n         int arguments = args.length;\n-        Class[] parameterTypes = new Class[arguments];\n+        Class<?>[] parameterTypes = new Class[arguments];\n         for (int i = 0; i < arguments; i++) {\n             parameterTypes[i] = args[i].getClass();\n         }\n      *  via reflection\n      */\n     public static Object invokeExactMethod(Object object, String methodName,\n-            Object[] args, Class[] parameterTypes)\n+            Object[] args, Class<?>[] parameterTypes)\n             throws NoSuchMethodException, IllegalAccessException,\n             InvocationTargetException {\n         if (args == null) {\n      * @throws IllegalAccessException if the requested method is not accessible\n      *  via reflection\n      */\n-    public static Object invokeExactStaticMethod(Class cls, String methodName,\n-            Object[] args, Class[] parameterTypes)\n+    public static Object invokeExactStaticMethod(Class<?> cls, String methodName,\n+            Object[] args, Class<?>[] parameterTypes)\n             throws NoSuchMethodException, IllegalAccessException,\n             InvocationTargetException {\n         if (args == null) {\n      * @throws IllegalAccessException if the requested method is not accessible\n      *  via reflection\n      */\n-    public static Object invokeStaticMethod(Class cls, String methodName,\n+    public static Object invokeStaticMethod(Class<?> cls, String methodName,\n             Object arg) throws NoSuchMethodException, IllegalAccessException,\n             InvocationTargetException {\n         return invokeStaticMethod(cls, methodName, new Object[] { arg });\n      * @throws IllegalAccessException if the requested method is not accessible\n      *  via reflection\n      */\n-    public static Object invokeStaticMethod(Class cls, String methodName,\n+    public static Object invokeStaticMethod(Class<?> cls, String methodName,\n             Object[] args) throws NoSuchMethodException,\n             IllegalAccessException, InvocationTargetException {\n         if (args == null) {\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n         }\n         int arguments = args.length;\n-        Class[] parameterTypes = new Class[arguments];\n+        Class<?>[] parameterTypes = new Class[arguments];\n         for (int i = 0; i < arguments; i++) {\n             parameterTypes[i] = args[i].getClass();\n         }\n      * @throws IllegalAccessException if the requested method is not accessible\n      *  via reflection\n      */\n-    public static Object invokeStaticMethod(Class cls, String methodName,\n-            Object[] args, Class[] parameterTypes)\n+    public static Object invokeStaticMethod(Class<?> cls, String methodName,\n+            Object[] args, Class<?>[] parameterTypes)\n             throws NoSuchMethodException, IllegalAccessException,\n             InvocationTargetException {\n         if (parameterTypes == null) {\n      * @throws IllegalAccessException if the requested method is not accessible\n      *  via reflection\n      */\n-    public static Object invokeExactStaticMethod(Class cls, String methodName,\n+    public static Object invokeExactStaticMethod(Class<?> cls, String methodName,\n             Object arg) throws NoSuchMethodException, IllegalAccessException,\n             InvocationTargetException {\n         return invokeExactStaticMethod(cls, methodName, new Object[] { arg });\n      * @throws IllegalAccessException if the requested method is not accessible\n      *  via reflection\n      */\n-    public static Object invokeExactStaticMethod(Class cls, String methodName,\n+    public static Object invokeExactStaticMethod(Class<?> cls, String methodName,\n             Object[] args) throws NoSuchMethodException,\n             IllegalAccessException, InvocationTargetException {\n         if (args == null) {\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n         }\n         int arguments = args.length;\n-        Class[] parameterTypes = new Class[arguments];\n+        Class<?>[] parameterTypes = new Class[arguments];\n         for (int i = 0; i < arguments; i++) {\n             parameterTypes[i] = args[i].getClass();\n         }\n      * @param parameterType taking this type of parameter\n      * @return The accessible method\n      */\n-    public static Method getAccessibleMethod(Class cls, String methodName,\n-            Class parameterType) {\n+    public static Method getAccessibleMethod(Class<?> cls, String methodName,\n+            Class<?> parameterType) {\n         return getAccessibleMethod(cls, methodName,\n-                new Class[] { parameterType });\n+                new Class<?>[] { parameterType });\n     }\n \n     /**\n      * @param parameterTypes with these parameters types\n      * @return The accessible method\n      */\n-    public static Method getAccessibleMethod(Class cls, String methodName,\n-            Class[] parameterTypes) {\n+    public static Method getAccessibleMethod(Class<?> cls, String methodName,\n+            Class<?>[] parameterTypes) {\n         try {\n             return getAccessibleMethod(cls.getMethod(methodName,\n                     parameterTypes));\n             return null;\n         }\n         // If the declaring class is public, we are done\n-        Class cls = method.getDeclaringClass();\n+        Class<?> cls = method.getDeclaringClass();\n         if (Modifier.isPublic(cls.getModifiers())) {\n             return method;\n         }\n         String methodName = method.getName();\n-        Class[] parameterTypes = method.getParameterTypes();\n+        Class<?>[] parameterTypes = method.getParameterTypes();\n \n         // Check the implemented interfaces and subinterfaces\n         method = getAccessibleMethodFromInterfaceNest(cls, methodName,\n      * @param methodName Method name of the method we wish to call\n      * @param parameterTypes The parameter type signatures\n      */\n-    private static Method getAccessibleMethodFromSuperclass(Class cls,\n-            String methodName, Class[] parameterTypes) {\n-        Class parentClass = cls.getSuperclass();\n+    private static Method getAccessibleMethodFromSuperclass(Class<?> cls,\n+            String methodName, Class<?>[] parameterTypes) {\n+        Class<?> parentClass = cls.getSuperclass();\n         while (parentClass != null) {\n             if (Modifier.isPublic(parentClass.getModifiers())) {\n                 try {\n      * @param methodName Method name of the method we wish to call\n      * @param parameterTypes The parameter type signatures\n      */\n-    private static Method getAccessibleMethodFromInterfaceNest(Class cls,\n-            String methodName, Class[] parameterTypes) {\n+    private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls,\n+            String methodName, Class<?>[] parameterTypes) {\n         Method method = null;\n \n         // Search up the superclass chain\n         for (; cls != null; cls = cls.getSuperclass()) {\n \n             // Check the implemented interfaces of the parent class\n-            Class[] interfaces = cls.getInterfaces();\n+            Class<?>[] interfaces = cls.getInterfaces();\n             for (int i = 0; i < interfaces.length; i++) {\n                 // Is this interface public?\n                 if (!Modifier.isPublic(interfaces[i].getModifiers())) {\n      * @param parameterTypes find method with most compatible parameters \n      * @return The accessible method\n      */\n-    public static Method getMatchingAccessibleMethod(Class cls,\n-            String methodName, Class[] parameterTypes) {\n+    public static Method getMatchingAccessibleMethod(Class<?> cls,\n+            String methodName, Class<?>[] parameterTypes) {\n         try {\n             Method method = cls.getMethod(methodName, parameterTypes);\n             MemberUtils.setAccessibleWorkaround(method);", "timestamp": 1256391466, "metainfo": ""}