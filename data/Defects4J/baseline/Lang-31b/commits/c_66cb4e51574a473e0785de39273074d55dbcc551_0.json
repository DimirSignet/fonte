{"sha": "66cb4e51574a473e0785de39273074d55dbcc551", "log": "[LANG-366] Add MultiFormat  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/MultiFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.ParsePosition;\n+import java.util.ArrayList;\n+\n+import org.apache.commons.lang.Validate;\n+\n+/**\n+ * Format that tries a number of delegates in turn until one is successful.\n+ * Contrast to {@link CompositeFormat}.\n+ * \n+ * @author Matt Benson\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+public class MultiFormat extends Format {\n+    private static final long serialVersionUID = -6128683973856547540L;\n+\n+    /**\n+     * Provides a builder with a fluent interface. Example:\n+     * <p>\n+     * <code>\n+     * <pre>\n+     * MultiFormat mf = new MultiFormat.Builder().add(new FooFormat()).add(\n+     *         new BarFormat()).add(new BazFormat()).toMultiFormat();\n+     * </pre></code>\n+     * </p>\n+     */\n+    public static class Builder {\n+        private ArrayList delegates = new ArrayList();\n+\n+        /**\n+         * Add a delegate format.\n+         * \n+         * @param delegate\n+         * @return the builder\n+         */\n+        public Builder add(Format delegate) {\n+            Validate.notNull(delegate, \"delegate format is null\");\n+            delegates.add(delegate);\n+            return this;\n+        }\n+\n+        /**\n+         * Render the {@link MultiFormat} instance from this Builder.\n+         * \n+         * @return MultiFormat\n+         */\n+        public MultiFormat toMultiFormat() {\n+            return new MultiFormat((Format[]) delegates\n+                    .toArray(new Format[delegates.size()]));\n+        }\n+\n+    }\n+\n+    private Format[] delegates;\n+\n+    /**\n+     * Create a new MultiFormat.\n+     */\n+    public MultiFormat() {\n+    }\n+\n+    /**\n+     * Create a new MultiFormat.\n+     * \n+     * @param delegates\n+     */\n+    public MultiFormat(Format[] delegates) {\n+        setDelegates(delegates);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer,\n+     *      java.text.FieldPosition)\n+     */\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+            FieldPosition pos) {\n+        Format[] d = getValidDelegates();\n+        for (int i = 0; i < d.length; i++) {\n+            try {\n+                return d[i].format(obj, toAppendTo, pos);\n+            } catch (IllegalArgumentException e) {\n+                continue;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"No delegate Format can parse \"\n+                + obj);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see java.text.Format#parseObject(java.lang.String,\n+     *      java.text.ParsePosition)\n+     */\n+    public Object parseObject(String source, ParsePosition pos) {\n+        int start = pos.getIndex();\n+        Format[] d = getDelegates();\n+        for (int i = 0; i < d.length; i++) {\n+            Object o = d[i].parseObject(source, pos);\n+            if (pos.getErrorIndex() < 0) {\n+                return o;\n+            }\n+            // set up for next attempt:\n+            pos.setIndex(start);\n+            pos.setErrorIndex(-1);\n+        }\n+        pos.setErrorIndex(start);\n+        return null;\n+    }\n+\n+    /**\n+     * Set the delegates.\n+     * \n+     * @param delegates\n+     *            the Format[] delegates to set.\n+     */\n+    public void setDelegates(Format[] delegates) {\n+        Validate.noNullElements(delegates,\n+                \"Null elements present in delegates Format[]\");\n+        this.delegates = delegates;\n+    }\n+\n+    /**\n+     * Get the delegates.\n+     * \n+     * @return Format[].\n+     */\n+    public Format[] getDelegates() {\n+        return delegates;\n+    }\n+\n+    private Format[] getValidDelegates() {\n+        Format[] result = getDelegates();\n+        Validate.notEmpty(result, \"No delegate Formats configured\");\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/text/MultiFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.text.DateFormat;\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.Locale;\n+\n+import org.apache.commons.lang.ClassUtils;\n+import org.apache.commons.lang.Validate;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test MultiFormat\n+ * \n+ * @author Matt Benson\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+public class MultiFormatTest extends TestCase {\n+    private class GuardedFormat extends Format {\n+        private static final long serialVersionUID = 1L;\n+\n+        Format delegate;\n+        Class[] allowableTypes;\n+\n+        /**\n+         * Create a new MultiFormatTest.GuardedFormat.\n+         */\n+        public GuardedFormat(Format delegate, Class[] allowableTypes) {\n+            Validate.notNull(delegate);\n+            this.delegate = delegate;\n+            Validate.notNull(allowableTypes);\n+            this.allowableTypes = allowableTypes;\n+        }\n+\n+        public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+                FieldPosition pos) {\n+            Class c = obj == null ? null : obj.getClass();\n+            for (int i = 0; i < allowableTypes.length; i++) {\n+                if (ClassUtils.isAssignable(c, allowableTypes[i])) {\n+                    return delegate.format(obj, toAppendTo, pos);\n+                }\n+            }\n+            throw new IllegalArgumentException();\n+        }\n+\n+        public Object parseObject(String source, ParsePosition pos) {\n+            return delegate.parseObject(source, pos);\n+        }\n+    }\n+\n+    private Format format;\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see junit.framework.TestCase#setUp()\n+     */\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        // silliness to avoid the DateFormat grabbing the Integer, or the\n+        // integer parsing the first (month) date component:\n+        format = new MultiFormat.Builder().add(\n+                new GuardedFormat(DateFormat.getDateInstance(DateFormat.SHORT,\n+                        Locale.US), new Class[] { Date.class })).add(\n+                NumberFormat.getIntegerInstance(Locale.US)).toMultiFormat();\n+    }\n+\n+    public void testWTF() {\n+        System.out.println(DateFormat.getDateInstance(DateFormat.SHORT,\n+                Locale.US).format(new Integer(1000)));\n+    }\n+\n+    public void testFormatNumber() {\n+        assertEquals(\"1,000\", format.format(new Integer(1000)));\n+    }\n+\n+    public void testParseNumber() throws ParseException {\n+        assertEquals(new Integer(-1000).intValue(), ((Number) format\n+                .parseObject(\"-1,000\")).intValue());\n+    }\n+\n+    public void testFormatDate() {\n+        assertEquals(\"1/1/70\", format.format(new GregorianCalendar(1970,\n+                Calendar.JANUARY, 01).getTime()));\n+    }\n+\n+    public void testParseDate() throws ParseException {\n+        assertEquals(new GregorianCalendar(1970, Calendar.JANUARY, 01)\n+                .getTime(), format.parseObject(\"1/1/70\"));\n+    }\n+\n+    public void testFormatObject() {\n+        try {\n+            format.format(new Object());\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // okay\n+        }\n+    }\n+\n+    public void testParseGarbage() {\n+        try {\n+            format.parseObject(\"garbage\");\n+            fail(\"expected ParseException\");\n+        } catch (ParseException e) {\n+            //okay\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/lang/text/TextTestSuite.java\n+++ b/src/test/org/apache/commons/lang/text/TextTestSuite.java\n         suite.addTest(StrMatcherTest.suite());\n         suite.addTest(StrSubstitutorTest.suite());\n         suite.addTest(StrTokenizerTest.suite());\n+        suite.addTestSuite(MultiFormatTest.class);\n         return suite;\n     }\n ", "timestamp": 1193669423, "metainfo": ""}