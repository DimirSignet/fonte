{"sha": "586080851f6bca4d7aa84a7d307203ad8222407e", "log": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/ArrayUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Array;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.builder.EqualsBuilder;\n+import org.apache.commons.lang.builder.ToStringBuilder;\n+import org.apache.commons.lang.builder.ToStringStyle;\n+\n+/**\n+ * <p>Operations on arrays, primitive arrays (like <code>int[]</code>) and\n+ * primitive wrapper arrays (like <code>Integer[]</code>).</p>\n+ *\n+ * <p>This class tries to handle <code>null</code> input gracefully.\n+ * An exception will not be thrown for a <code>null</code>\n+ * array input. However, an Object array that contains a <code>null</code>\n+ * element may throw an exception. Each method documents its behaviour.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Moritz Petersen\n+ * @author <a href=\"mailto:fredrik@westermarck.com\">Fredrik Westermarck</a>\n+ * @author Nikolay Metchev\n+ * @author Matthew Hawthorne\n+ * @author Tim O'Brien\n+ * @author Pete Gieser\n+ * @author Gary Gregory\n+ * @author <a href=\"mailto:equinus100@hotmail.com\">Ashwin S</a>\n+ * @author Maarten Coene\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class ArrayUtils {\n+\n+    /**\n+     * An empty immutable <code>Object</code> array.\n+     */\n+    public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n+    /**\n+     * An empty immutable <code>Class</code> array.\n+     */\n+    public static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n+    /**\n+     * An empty immutable <code>String</code> array.\n+     */\n+    public static final String[] EMPTY_STRING_ARRAY = new String[0];\n+    /**\n+     * An empty immutable <code>long</code> array.\n+     */\n+    public static final long[] EMPTY_LONG_ARRAY = new long[0];\n+    /**\n+     * An empty immutable <code>Long</code> array.\n+     */\n+    public static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n+    /**\n+     * An empty immutable <code>int</code> array.\n+     */\n+    public static final int[] EMPTY_INT_ARRAY = new int[0];\n+    /**\n+     * An empty immutable <code>Integer</code> array.\n+     */\n+    public static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n+    /**\n+     * An empty immutable <code>short</code> array.\n+     */\n+    public static final short[] EMPTY_SHORT_ARRAY = new short[0];\n+    /**\n+     * An empty immutable <code>Short</code> array.\n+     */\n+    public static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n+    /**\n+     * An empty immutable <code>byte</code> array.\n+     */\n+    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n+    /**\n+     * An empty immutable <code>Byte</code> array.\n+     */\n+    public static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n+    /**\n+     * An empty immutable <code>double</code> array.\n+     */\n+    public static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n+    /**\n+     * An empty immutable <code>Double</code> array.\n+     */\n+    public static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n+    /**\n+     * An empty immutable <code>float</code> array.\n+     */\n+    public static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n+    /**\n+     * An empty immutable <code>Float</code> array.\n+     */\n+    public static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n+    /**\n+     * An empty immutable <code>boolean</code> array.\n+     */\n+    public static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n+    /**\n+     * An empty immutable <code>Boolean</code> array.\n+     */\n+    public static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n+    /**\n+     * An empty immutable <code>char</code> array.\n+     */\n+    public static final char[] EMPTY_CHAR_ARRAY = new char[0];\n+    /**\n+     * An empty immutable <code>Character</code> array.\n+     */\n+    public static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n+\n+    /**\n+     * The index value when an element is not found in a list or array: <code>-1</code>.\n+     * This value is returned by methods in this class and can also be used in comparisons with values returned by\n+     * various method from {@link java.util.List}.\n+     */\n+    public static final int INDEX_NOT_FOUND = -1;\n+\n+    /**\n+     * <p>ArrayUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>ArrayUtils.clone(new int[] {2})</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public ArrayUtils() {\n+      super();\n+    }\n+\n+    // Basic methods handling multi-dimensional arrays\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Outputs an array as a String, treating <code>null</code> as an empty array.</p>\n+     *\n+     * <p>Multi-dimensional arrays are handled correctly, including\n+     * multi-dimensional primitive arrays.</p>\n+     *\n+     * <p>The format is that of Java source code, for example <code>{a,b}</code>.</p>\n+     *\n+     * @param array  the array to get a toString for, may be <code>null</code>\n+     * @return a String representation of the array, '{}' if null array input\n+     */\n+    public static String toString(Object array) {\n+        return toString(array, \"{}\");\n+    }\n+\n+    /**\n+     * <p>Outputs an array as a String handling <code>null</code>s.</p>\n+     *\n+     * <p>Multi-dimensional arrays are handled correctly, including\n+     * multi-dimensional primitive arrays.</p>\n+     *\n+     * <p>The format is that of Java source code, for example <code>{a,b}</code>.</p>\n+     *\n+     * @param array  the array to get a toString for, may be <code>null</code>\n+     * @param stringIfNull  the String to return if the array is <code>null</code>\n+     * @return a String representation of the array\n+     */\n+    public static String toString(Object array, String stringIfNull) {\n+        if (array == null) {\n+            return stringIfNull;\n+        }\n+        return new ToStringBuilder(array, ToStringStyle.SIMPLE_STYLE).append(array).toString();\n+    }\n+\n+    /**\n+     * <p>Compares two arrays, using equals(), handling multi-dimensional arrays\n+     * correctly.</p>\n+     *\n+     * <p>Multi-dimensional primitive arrays are also handled correctly by this method.</p>\n+     *\n+     * @param array1  the left hand array to compare, may be <code>null</code>\n+     * @param array2  the right hand array to compare, may be <code>null</code>\n+     * @return <code>true</code> if the arrays are equal\n+     */\n+    public static boolean isEquals(Object array1, Object array2) {\n+        return new EqualsBuilder().append(array1, array2).isEquals();\n+    }\n+\n+    // To map\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts the given array into a {@link java.util.Map}. Each element of the array\n+     * must be either a {@link java.util.Map.Entry} or an Array, containing at least two\n+     * elements, where the first element is used as key and the second as\n+     * value.</p>\n+     *\n+     * <p>This method can be used to initialize:</p>\n+     * <pre>\n+     * // Create a Map mapping colors.\n+     * Map colorMap = MapUtils.toMap(new String[][] {{\n+     *     {\"RED\", \"#FF0000\"},\n+     *     {\"GREEN\", \"#00FF00\"},\n+     *     {\"BLUE\", \"#0000FF\"}});\n+     * </pre>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  an array whose elements are either a {@link java.util.Map.Entry} or\n+     *  an Array containing at least two elements, may be <code>null</code>\n+     * @return a <code>Map</code> that was created from the array\n+     * @throws IllegalArgumentException  if one element of this Array is\n+     *  itself an Array containing less then two elements\n+     * @throws IllegalArgumentException  if the array contains elements other\n+     *  than {@link java.util.Map.Entry} and an Array\n+     */\n+    public static Map<Object, Object> toMap(Object[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5));\n+        for (int i = 0; i < array.length; i++) {\n+            Object object = array[i];\n+            if (object instanceof Map.Entry<?, ?>) {\n+                Map.Entry<?,?> entry = (Map.Entry<?,?>) object;\n+                map.put(entry.getKey(), entry.getValue());\n+            } else if (object instanceof Object[]) {\n+                Object[] entry = (Object[]) object;\n+                if (entry.length < 2) {\n+                    throw new IllegalArgumentException(\"Array element \" + i + \", '\"\n+                        + object\n+                        + \"', has a length less than 2\");\n+                }\n+                map.put(entry[0], entry[1]);\n+            } else {\n+                throw new IllegalArgumentException(\"Array element \" + i + \", '\"\n+                        + object\n+                        + \"', is neither of type Map.Entry nor an Array\");\n+            }\n+        }\n+        return map;\n+    }\n+\n+    // Clone\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Shallow clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>The objects in the array are not cloned, thus there is no special\n+     * handling for multi-dimensional arrays.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to shallow clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static <T> T[] clone(T[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static long[] clone(long[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static int[] clone(int[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static short[] clone(short[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static char[] clone(char[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static byte[] clone(byte[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static double[] clone(double[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static float[] clone(float[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static boolean[] clone(boolean[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return array.clone();\n+    }\n+\n+    // Subarrays\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Produces a new array containing the elements between\n+     * the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * <p>The component type of the subarray is always the same as\n+     * that of the input array. Thus, if the input is an array of type\n+     * <code>Date</code>, the following usage is envisaged:</p>\n+     *\n+     * <pre>\n+     * Date[] someDates = (Date[])ArrayUtils.subarray(allDates, 2, 5);\n+     * </pre>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T[] subarray(T[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        Class<?> type = array.getClass().getComponentType();\n+        if (newSize <= 0) {\n+            return (T[]) Array.newInstance(type, 0);\n+        }\n+        T[] subarray = (T[]) Array.newInstance(type, newSize);\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>long</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_LONG_ARRAY;\n+        }\n+\n+        long[] subarray = new long[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>int</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_INT_ARRAY;\n+        }\n+\n+        int[] subarray = new int[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>short</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_SHORT_ARRAY;\n+        }\n+\n+        short[] subarray = new short[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>char</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_CHAR_ARRAY;\n+        }\n+\n+        char[] subarray = new char[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>byte</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_BYTE_ARRAY;\n+        }\n+\n+        byte[] subarray = new byte[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>double</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_DOUBLE_ARRAY;\n+        }\n+\n+        double[] subarray = new double[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>float</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_FLOAT_ARRAY;\n+        }\n+\n+        float[] subarray = new float[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>boolean</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_BOOLEAN_ARRAY;\n+        }\n+\n+        boolean[] subarray = new boolean[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    // Is same length\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.\n+     *\n+     * <p>Any multi-dimensional aspects of the arrays are ignored.</p>\n+     *\n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(Object[] array1, Object[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     *\n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(long[] array1, long[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     *\n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(int[] array1, int[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     *\n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(short[] array1, short[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     *\n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(char[] array1, char[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     *\n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(byte[] array1, byte[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     *\n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(double[] array1, double[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     *\n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(float[] array1, float[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     *\n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(boolean[] array1, boolean[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns the length of the specified array.\n+     * This method can deal with <code>Object</code> arrays and with primitive arrays.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, <code>0</code> is returned.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.getLength(null)            = 0\n+     * ArrayUtils.getLength([])              = 0\n+     * ArrayUtils.getLength([null])          = 1\n+     * ArrayUtils.getLength([true, false])   = 2\n+     * ArrayUtils.getLength([1, 2, 3])       = 3\n+     * ArrayUtils.getLength([\"a\", \"b\", \"c\"]) = 3\n+     * </pre>\n+     *\n+     * @param array  the array to retrieve the length from, may be null\n+     * @return The length of the array, or <code>0</code> if the array is <code>null</code>\n+     * @throws IllegalArgumentException if the object arguement is not an array.\n+     * @since 2.1\n+     */\n+    public static int getLength(Object array) {\n+        if (array == null) {\n+            return 0;\n+        }\n+        return Array.getLength(array);\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same type taking into account\n+     * multi-dimensional arrays.</p>\n+     *\n+     * @param array1 the first array, must not be <code>null</code>\n+     * @param array2 the second array, must not be <code>null</code>\n+     * @return <code>true</code> if type of arrays matches\n+     * @throws IllegalArgumentException if either array is <code>null</code>\n+     */\n+    public static boolean isSameType(Object array1, Object array2) {\n+        if (array1 == null || array2 == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        }\n+        return array1.getClass().getName().equals(array2.getClass().getName());\n+    }\n+\n+    // Reverse\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     *\n+     * <p>There is no special handling for multi-dimensional arrays.</p>\n+     *\n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(Object[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        Object tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     *\n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(long[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        long tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     *\n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(int[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        int tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     *\n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(short[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        short tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     *\n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(char[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        char tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     *\n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(byte[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        byte tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     *\n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(double[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        double tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     *\n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(float[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        float tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     *\n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(boolean[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        boolean tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    // IndexOf search\n+    // ----------------------------------------------------------------------\n+\n+    // Object IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given object in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param objectToFind  the object to find, may be <code>null</code>\n+     * @return the index of the object within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(Object[] array, Object objectToFind) {\n+        return indexOf(array, objectToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given object in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param objectToFind  the object to find, may be <code>null</code>\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the object within the array starting at the index,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(Object[] array, Object objectToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        if (objectToFind == null) {\n+            for (int i = startIndex; i < array.length; i++) {\n+                if (array[i] == null) {\n+                    return i;\n+                }\n+            }\n+        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n+            for (int i = startIndex; i < array.length; i++) {\n+                if (objectToFind.equals(array[i])) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given object within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param objectToFind  the object to find, may be <code>null</code>\n+     * @return the last index of the object within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(Object[] array, Object objectToFind) {\n+        return lastIndexOf(array, objectToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given object in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than\n+     * the array length will search from the end of the array.</p>\n+     *\n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param objectToFind  the object to find, may be <code>null</code>\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the object within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        if (objectToFind == null) {\n+            for (int i = startIndex; i >= 0; i--) {\n+                if (array[i] == null) {\n+                    return i;\n+                }\n+            }\n+        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n+            for (int i = startIndex; i >= 0; i--) {\n+                if (objectToFind.equals(array[i])) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the object is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     *\n+     * @param array  the array to search through\n+     * @param objectToFind  the object to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(Object[] array, Object objectToFind) {\n+        return indexOf(array, objectToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // long IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(long[] array, long valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(long[] array, long valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(long[] array, long valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n+     * array length will search from the end of the array.</p>\n+     *\n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     *\n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(long[] array, long valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // int IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(int[] array, int valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(int[] array, int valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(int[] array, int valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n+     * array length will search from the end of the array.</p>\n+     *\n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     *\n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(int[] array, int valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // short IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(short[] array, short valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(short[] array, short valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(short[] array, short valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n+     * array length will search from the end of the array.</p>\n+     *\n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     *\n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(short[] array, short valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // char IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     * @since 2.1\n+     */\n+    public static int indexOf(char[] array, char valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     * @since 2.1\n+     */\n+    public static int indexOf(char[] array, char valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     * @since 2.1\n+     */\n+    public static int lastIndexOf(char[] array, char valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n+     * array length will search from the end of the array.</p>\n+     *\n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     * @since 2.1\n+     */\n+    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     *\n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     * @since 2.1\n+     */\n+    public static boolean contains(char[] array, char valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // byte IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(byte[] array, byte valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(byte[] array, byte valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(byte[] array, byte valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n+     * array length will search from the end of the array.</p>\n+     *\n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     *\n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(byte[] array, byte valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // double IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(double[] array, double valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value within a given tolerance in the array.\n+     * This method will return the index of the first value which falls between the region\n+     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param tolerance tolerance of the search\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(double[] array, double valueToFind, double tolerance) {\n+        return indexOf(array, valueToFind, 0, tolerance);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(double[] array, double valueToFind, int startIndex) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.\n+     * This method will return the index of the first value which falls between the region\n+     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @param tolerance tolerance of the search\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(double[] array, double valueToFind, int startIndex, double tolerance) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        double min = valueToFind - tolerance;\n+        double max = valueToFind + tolerance;\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (array[i] >= min && array[i] <= max) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(double[] array, double valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within a given tolerance in the array.\n+     * This method will return the index of the last value which falls between the region\n+     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param tolerance tolerance of the search\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(double[] array, double valueToFind, double tolerance) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n+     * array length will search from the end of the array.</p>\n+     *\n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.\n+     * This method will return the index of the last value which falls between the region\n+     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n+     * array length will search from the end of the array.</p>\n+     *\n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @param tolerance  search for value within plus/minus this amount\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        double min = valueToFind - tolerance;\n+        double max = valueToFind + tolerance;\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (array[i] >= min && array[i] <= max) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     *\n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(double[] array, double valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if a value falling within the given tolerance is in the\n+     * given array.  If the array contains a value within the inclusive range\n+     * defined by (value - tolerance) to (value + tolerance).</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array\n+     * is passed in.</p>\n+     *\n+     * @param array  the array to search\n+     * @param valueToFind  the value to find\n+     * @param tolerance  the array contains the tolerance of the search\n+     * @return true if value falling within tolerance is in array\n+     */\n+    public static boolean contains(double[] array, double valueToFind, double tolerance) {\n+        return indexOf(array, valueToFind, 0, tolerance) != INDEX_NOT_FOUND;\n+    }\n+\n+    // float IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(float[] array, float valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(float[] array, float valueToFind, int startIndex) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(float[] array, float valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n+     * array length will search from the end of the array.</p>\n+     *\n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     *\n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(float[] array, float valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // boolean IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(boolean[] array, boolean valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code>\n+     *  array input\n+     */\n+    public static int indexOf(boolean[] array, boolean valueToFind, int startIndex) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) if\n+     * <code>null</code> array input.</p>\n+     *\n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(boolean[] array, boolean valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than\n+     * the array length will search from the end of the array.</p>\n+     *\n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     *\n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(boolean[] array, boolean valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // Primitive/Object array converters\n+    // ----------------------------------------------------------------------\n+\n+    // Character array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Characters to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Character</code> array, may be <code>null</code>\n+     * @return a <code>char</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static char[] toPrimitive(Character[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_CHAR_ARRAY;\n+        }\n+        final char[] result = new char[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].charValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Character to primitives handling <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Character</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>char</code> array, <code>null</code> if null array input\n+     */\n+    public static char[] toPrimitive(Character[] array, char valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_CHAR_ARRAY;\n+        }\n+        final char[] result = new char[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Character b = array[i];\n+            result[i] = (b == null ? valueForNull : b.charValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive chars to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array a <code>char</code> array\n+     * @return a <code>Character</code> array, <code>null</code> if null array input\n+     */\n+    public static Character[] toObject(char[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_CHARACTER_OBJECT_ARRAY;\n+        }\n+        final Character[] result = new Character[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = Character.valueOf(array[i]);\n+        }\n+        return result;\n+     }\n+\n+    // Long array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Longs to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Long</code> array, may be <code>null</code>\n+     * @return a <code>long</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static long[] toPrimitive(Long[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_LONG_ARRAY;\n+        }\n+        final long[] result = new long[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].longValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Long to primitives handling <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Long</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>long</code> array, <code>null</code> if null array input\n+     */\n+    public static long[] toPrimitive(Long[] array, long valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_LONG_ARRAY;\n+        }\n+        final long[] result = new long[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Long b = array[i];\n+            result[i] = (b == null ? valueForNull : b.longValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive longs to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>long</code> array\n+     * @return a <code>Long</code> array, <code>null</code> if null array input\n+     */\n+    public static Long[] toObject(long[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_LONG_OBJECT_ARRAY;\n+        }\n+        final Long[] result = new Long[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = Long.valueOf(array[i]);\n+        }\n+        return result;\n+    }\n+\n+    // Int array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Integers to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Integer</code> array, may be <code>null</code>\n+     * @return an <code>int</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static int[] toPrimitive(Integer[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_INT_ARRAY;\n+        }\n+        final int[] result = new int[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].intValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Integer to primitives handling <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Integer</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return an <code>int</code> array, <code>null</code> if null array input\n+     */\n+    public static int[] toPrimitive(Integer[] array, int valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_INT_ARRAY;\n+        }\n+        final int[] result = new int[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Integer b = array[i];\n+            result[i] = (b == null ? valueForNull : b.intValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive ints to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  an <code>int</code> array\n+     * @return an <code>Integer</code> array, <code>null</code> if null array input\n+     */\n+    public static Integer[] toObject(int[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_INTEGER_OBJECT_ARRAY;\n+        }\n+        final Integer[] result = new Integer[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = Integer.valueOf(array[i]);\n+        }\n+        return result;\n+    }\n+\n+    // Short array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Shorts to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Short</code> array, may be <code>null</code>\n+     * @return a <code>byte</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static short[] toPrimitive(Short[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_SHORT_ARRAY;\n+        }\n+        final short[] result = new short[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].shortValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Short to primitives handling <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Short</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>byte</code> array, <code>null</code> if null array input\n+     */\n+    public static short[] toPrimitive(Short[] array, short valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_SHORT_ARRAY;\n+        }\n+        final short[] result = new short[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Short b = array[i];\n+            result[i] = (b == null ? valueForNull : b.shortValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive shorts to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>short</code> array\n+     * @return a <code>Short</code> array, <code>null</code> if null array input\n+     */\n+    public static Short[] toObject(short[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_SHORT_OBJECT_ARRAY;\n+        }\n+        final Short[] result = new Short[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = Short.valueOf(array[i]);\n+        }\n+        return result;\n+    }\n+\n+    // Byte array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Bytes to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Byte</code> array, may be <code>null</code>\n+     * @return a <code>byte</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static byte[] toPrimitive(Byte[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_BYTE_ARRAY;\n+        }\n+        final byte[] result = new byte[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].byteValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Bytes to primitives handling <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Byte</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>byte</code> array, <code>null</code> if null array input\n+     */\n+    public static byte[] toPrimitive(Byte[] array, byte valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_BYTE_ARRAY;\n+        }\n+        final byte[] result = new byte[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Byte b = array[i];\n+            result[i] = (b == null ? valueForNull : b.byteValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive bytes to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>byte</code> array\n+     * @return a <code>Byte</code> array, <code>null</code> if null array input\n+     */\n+    public static Byte[] toObject(byte[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_BYTE_OBJECT_ARRAY;\n+        }\n+        final Byte[] result = new Byte[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = Byte.valueOf(array[i]);\n+        }\n+        return result;\n+    }\n+\n+    // Double array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Doubles to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Double</code> array, may be <code>null</code>\n+     * @return a <code>double</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static double[] toPrimitive(Double[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_DOUBLE_ARRAY;\n+        }\n+        final double[] result = new double[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].doubleValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Doubles to primitives handling <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Double</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>double</code> array, <code>null</code> if null array input\n+     */\n+    public static double[] toPrimitive(Double[] array, double valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_DOUBLE_ARRAY;\n+        }\n+        final double[] result = new double[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Double b = array[i];\n+            result[i] = (b == null ? valueForNull : b.doubleValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive doubles to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>double</code> array\n+     * @return a <code>Double</code> array, <code>null</code> if null array input\n+     */\n+    public static Double[] toObject(double[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_DOUBLE_OBJECT_ARRAY;\n+        }\n+        final Double[] result = new Double[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = Double.valueOf(array[i]);\n+        }\n+        return result;\n+    }\n+\n+    //   Float array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Floats to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Float</code> array, may be <code>null</code>\n+     * @return a <code>float</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static float[] toPrimitive(Float[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_FLOAT_ARRAY;\n+        }\n+        final float[] result = new float[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].floatValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Floats to primitives handling <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Float</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>float</code> array, <code>null</code> if null array input\n+     */\n+    public static float[] toPrimitive(Float[] array, float valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_FLOAT_ARRAY;\n+        }\n+        final float[] result = new float[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Float b = array[i];\n+            result[i] = (b == null ? valueForNull : b.floatValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive floats to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>float</code> array\n+     * @return a <code>Float</code> array, <code>null</code> if null array input\n+     */\n+    public static Float[] toObject(float[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_FLOAT_OBJECT_ARRAY;\n+        }\n+        final Float[] result = new Float[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = Float.valueOf(array[i]);\n+        }\n+        return result;\n+    }\n+\n+    // Boolean array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Booleans to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Boolean</code> array, may be <code>null</code>\n+     * @return a <code>boolean</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static boolean[] toPrimitive(Boolean[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_BOOLEAN_ARRAY;\n+        }\n+        final boolean[] result = new boolean[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].booleanValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Booleans to primitives handling <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Boolean</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>boolean</code> array, <code>null</code> if null array input\n+     */\n+    public static boolean[] toPrimitive(Boolean[] array, boolean valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_BOOLEAN_ARRAY;\n+        }\n+        final boolean[] result = new boolean[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Boolean b = array[i];\n+            result[i] = (b == null ? valueForNull : b.booleanValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive booleans to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>boolean</code> array\n+     * @return a <code>Boolean</code> array, <code>null</code> if null array input\n+     */\n+    public static Boolean[] toObject(boolean[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_BOOLEAN_OBJECT_ARRAY;\n+        }\n+        final Boolean[] result = new Boolean[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);\n+        }\n+        return result;\n+    }\n+\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if an array of Objects is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static <T> boolean isEmpty(T[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive longs is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(long[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive ints is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(int[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive shorts is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(short[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive chars is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(char[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive bytes is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(byte[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(double[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive floats is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(float[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive booleans is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(boolean[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(null, null)     = null\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * ArrayUtils.addAll([null], [null]) = [null, null]\n+     * ArrayUtils.addAll([\"a\", \"b\", \"c\"], [\"1\", \"2\", \"3\"]) = [\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"]\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array, may be <code>null</code>\n+     * @param array2  the second array whose elements are added to the new array, may be <code>null</code>\n+     * @return The new array, <code>null</code> if <code>null</code> array inputs.\n+     *      The type of the new array is the type of the first array.\n+     * @since 2.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T[] addAll(T[] array1, T... array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        T[] joinedArray = (T[]) Array.newInstance(array1.getClass().getComponentType(),\n+                                                            array1.length + array2.length);\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new boolean[] array.\n+     * @since 2.1\n+     */\n+    public static boolean[] addAll(boolean[] array1, boolean... array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        boolean[] joinedArray = new boolean[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new char[] array.\n+     * @since 2.1\n+     */\n+    public static char[] addAll(char[] array1, char... array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        char[] joinedArray = new char[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new byte[] array.\n+     * @since 2.1\n+     */\n+    public static byte[] addAll(byte[] array1, byte... array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        byte[] joinedArray = new byte[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new short[] array.\n+     * @since 2.1\n+     */\n+    public static short[] addAll(short[] array1, short... array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        short[] joinedArray = new short[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new int[] array.\n+     * @since 2.1\n+     */\n+    public static int[] addAll(int[] array1, int... array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        int[] joinedArray = new int[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new long[] array.\n+     * @since 2.1\n+     */\n+    public static long[] addAll(long[] array1, long... array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        long[] joinedArray = new long[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new float[] array.\n+     * @since 2.1\n+     */\n+    public static float[] addAll(float[] array1, float... array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        float[] joinedArray = new float[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new double[] array.\n+     * @since 2.1\n+     */\n+    public static double[] addAll(double[] array1, double... array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        double[] joinedArray = new double[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of\n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, null)      = [null]\n+     * ArrayUtils.add(null, \"a\")       = [\"a\"]\n+     * ArrayUtils.add([\"a\"], null)     = [\"a\", null]\n+     * ArrayUtils.add([\"a\"], \"b\")      = [\"a\", \"b\"]\n+     * ArrayUtils.add([\"a\", \"b\"], \"c\") = [\"a\", \"b\", \"c\"]\n+     * </pre>\n+     *\n+     * @param array  the array to \"add\" the element to, may be <code>null</code>\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T[] add(T[] array, T element) {\n+        Class<?> type = array != null ? array.getClass() : (element != null ? element.getClass() : Object.class);\n+        T[] newArray = (T[]) copyArrayGrow1(array, type);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+\n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of\n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, true)          = [true]\n+     * ArrayUtils.add([true], false)       = [true, false]\n+     * ArrayUtils.add([true, false], true) = [true, false, true]\n+     * </pre>\n+     *\n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static boolean[] add(boolean[] array, boolean element) {\n+        boolean[] newArray = (boolean[])copyArrayGrow1(array, Boolean.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+\n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of\n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, 0)   = [0]\n+     * ArrayUtils.add([1], 0)    = [1, 0]\n+     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static byte[] add(byte[] array, byte element) {\n+        byte[] newArray = (byte[])copyArrayGrow1(array, Byte.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+\n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of\n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, '0')       = ['0']\n+     * ArrayUtils.add(['1'], '0')      = ['1', '0']\n+     * ArrayUtils.add(['1', '0'], '1') = ['1', '0', '1']\n+     * </pre>\n+     *\n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static char[] add(char[] array, char element) {\n+        char[] newArray = (char[])copyArrayGrow1(array, Character.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+\n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of\n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, 0)   = [0]\n+     * ArrayUtils.add([1], 0)    = [1, 0]\n+     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static double[] add(double[] array, double element) {\n+        double[] newArray = (double[])copyArrayGrow1(array, Double.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+\n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of\n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, 0)   = [0]\n+     * ArrayUtils.add([1], 0)    = [1, 0]\n+     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static float[] add(float[] array, float element) {\n+        float[] newArray = (float[])copyArrayGrow1(array, Float.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+\n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of\n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, 0)   = [0]\n+     * ArrayUtils.add([1], 0)    = [1, 0]\n+     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static int[] add(int[] array, int element) {\n+        int[] newArray = (int[])copyArrayGrow1(array, Integer.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+\n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of\n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, 0)   = [0]\n+     * ArrayUtils.add([1], 0)    = [1, 0]\n+     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static long[] add(long[] array, long element) {\n+        long[] newArray = (long[])copyArrayGrow1(array, Long.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+\n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of\n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, 0)   = [0]\n+     * ArrayUtils.add([1], 0)    = [1, 0]\n+     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static short[] add(short[] array, short element) {\n+        short[] newArray = (short[])copyArrayGrow1(array, Short.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+\n+    /**\n+     * Returns a copy of the given array of size 1 greater than the argument.\n+     * The last value of the array is left to the default value.\n+     *\n+     * @param array The array to copy, must not be <code>null</code>.\n+     * @param newArrayComponentType If <code>array</code> is <code>null</code>, create a\n+     * size 1 array of this type.\n+     * @return A new copy of the array of size 1 greater than the input.\n+     */\n+    private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentType) {\n+        if (array != null) {\n+            int arrayLength = Array.getLength(array);\n+            Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\n+            System.arraycopy(array, 0, newArray, 0, arrayLength);\n+            return newArray;\n+        }\n+        return Array.newInstance(newArrayComponentType, 1);\n+    }\n+\n+    /**\n+     * <p>Inserts the specified element at the specified position in the array.\n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, 0, null)      = [null]\n+     * ArrayUtils.add(null, 0, \"a\")       = [\"a\"]\n+     * ArrayUtils.add([\"a\"], 1, null)     = [\"a\", null]\n+     * ArrayUtils.add([\"a\"], 1, \"b\")      = [\"a\", \"b\"]\n+     * ArrayUtils.add([\"a\", \"b\"], 3, \"c\") = [\"a\", \"b\", \"c\"]\n+     * </pre>\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index > array.length).\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T[] add(T[] array, int index, T element) {\n+        Class<?> clss = null;\n+        if (array != null) {\n+            clss = array.getClass().getComponentType();\n+        } else if (element != null) {\n+            clss = element.getClass();\n+        } else {\n+            return (T[]) new Object[] { null };\n+        }\n+        return (T[]) add(array, index, element, clss);\n+    }\n+\n+    /**\n+     * <p>Inserts the specified element at the specified position in the array.\n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, 0, true)          = [true]\n+     * ArrayUtils.add([true], 0, false)       = [false, true]\n+     * ArrayUtils.add([false], 1, true)       = [false, true]\n+     * ArrayUtils.add([true, false], 1, true) = [true, true, false]\n+     * </pre>\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index > array.length).\n+     */\n+    public static boolean[] add(boolean[] array, int index, boolean element) {\n+        return (boolean[]) add(array, index, Boolean.valueOf(element), Boolean.TYPE);\n+    }\n+\n+    /**\n+     * <p>Inserts the specified element at the specified position in the array.\n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, 0, 'a')            = ['a']\n+     * ArrayUtils.add(['a'], 0, 'b')           = ['b', 'a']\n+     * ArrayUtils.add(['a', 'b'], 0, 'c')      = ['c', 'a', 'b']\n+     * ArrayUtils.add(['a', 'b'], 1, 'k')      = ['a', 'k', 'b']\n+     * ArrayUtils.add(['a', 'b', 'c'], 1, 't') = ['a', 't', 'b', 'c']\n+     * </pre>\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index > array.length).\n+     */\n+    public static char[] add(char[] array, int index, char element) {\n+        return (char[]) add(array, index, Character.valueOf(element), Character.TYPE);\n+    }\n+\n+    /**\n+     * <p>Inserts the specified element at the specified position in the array.\n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n+     * ArrayUtils.add([2, 6], 2, 3)      = [2, 6, 3]\n+     * ArrayUtils.add([2, 6], 0, 1)      = [1, 2, 6]\n+     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n+     * </pre>\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index > array.length).\n+     */\n+    public static byte[] add(byte[] array, int index, byte element) {\n+        return (byte[]) add(array, index, Byte.valueOf(element), Byte.TYPE);\n+    }\n+\n+    /**\n+     * <p>Inserts the specified element at the specified position in the array.\n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n+     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]\n+     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]\n+     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n+     * </pre>\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index > array.length).\n+     */\n+    public static short[] add(short[] array, int index, short element) {\n+        return (short[]) add(array, index, Short.valueOf(element), Short.TYPE);\n+    }\n+\n+    /**\n+     * <p>Inserts the specified element at the specified position in the array.\n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n+     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]\n+     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]\n+     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n+     * </pre>\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index > array.length).\n+     */\n+    public static int[] add(int[] array, int index, int element) {\n+        return (int[]) add(array, index, Integer.valueOf(element), Integer.TYPE);\n+    }\n+\n+    /**\n+     * <p>Inserts the specified element at the specified position in the array.\n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add([1L], 0, 2L)           = [2L, 1L]\n+     * ArrayUtils.add([2L, 6L], 2, 10L)      = [2L, 6L, 10L]\n+     * ArrayUtils.add([2L, 6L], 0, -4L)      = [-4L, 2L, 6L]\n+     * ArrayUtils.add([2L, 6L, 3L], 2, 1L)   = [2L, 6L, 1L, 3L]\n+     * </pre>\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index > array.length).\n+     */\n+    public static long[] add(long[] array, int index, long element) {\n+        return (long[]) add(array, index, Long.valueOf(element), Long.TYPE);\n+    }\n+\n+    /**\n+     * <p>Inserts the specified element at the specified position in the array.\n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add([1.1f], 0, 2.2f)               = [2.2f, 1.1f]\n+     * ArrayUtils.add([2.3f, 6.4f], 2, 10.5f)        = [2.3f, 6.4f, 10.5f]\n+     * ArrayUtils.add([2.6f, 6.7f], 0, -4.8f)        = [-4.8f, 2.6f, 6.7f]\n+     * ArrayUtils.add([2.9f, 6.0f, 0.3f], 2, 1.0f)   = [2.9f, 6.0f, 1.0f, 0.3f]\n+     * </pre>\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index > array.length).\n+     */\n+    public static float[] add(float[] array, int index, float element) {\n+        return (float[]) add(array, index, Float.valueOf(element), Float.TYPE);\n+    }\n+\n+    /**\n+     * <p>Inserts the specified element at the specified position in the array.\n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add([1.1], 0, 2.2)              = [2.2, 1.1]\n+     * ArrayUtils.add([2.3, 6.4], 2, 10.5)        = [2.3, 6.4, 10.5]\n+     * ArrayUtils.add([2.6, 6.7], 0, -4.8)        = [-4.8, 2.6, 6.7]\n+     * ArrayUtils.add([2.9, 6.0, 0.3], 2, 1.0)    = [2.9, 6.0, 1.0, 0.3]\n+     * </pre>\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index > array.length).\n+     */\n+    public static double[] add(double[] array, int index, double element) {\n+        return (double[]) add(array, index, Double.valueOf(element), Double.TYPE);\n+    }\n+\n+    /**\n+     * Underlying implementation of add(array, index, element) methods.\n+     * The last parameter is the class, which may not equal element.getClass\n+     * for primitives.\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @param clss the type of the element being added\n+     * @return A new array containing the existing elements and the new element\n+     */\n+    private static Object add(Object array, int index, Object element, Class<?> clss) {\n+        if (array == null) {\n+            if (index != 0) {\n+                throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: 0\");\n+            }\n+            Object joinedArray = Array.newInstance(clss, 1);\n+            Array.set(joinedArray, 0, element);\n+            return joinedArray;\n+        }\n+        int length = Array.getLength(array);\n+        if (index > length || index < 0) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n+        }\n+        Object result = Array.newInstance(clss, length + 1);\n+        System.arraycopy(array, 0, result, 0, index);\n+        Array.set(result, index, element);\n+        if (index < length) {\n+            System.arraycopy(array, index, result, index + 1, length - index);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([\"a\"], 0)           = []\n+     * ArrayUtils.remove([\"a\", \"b\"], 0)      = [\"b\"]\n+     * ArrayUtils.remove([\"a\", \"b\"], 1)      = [\"a\"]\n+     * ArrayUtils.remove([\"a\", \"b\", \"c\"], 1) = [\"a\", \"c\"]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T[] remove(T[] array, int index) {\n+        return (T[]) remove((Object) array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left\n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, \"a\")            = null\n+     * ArrayUtils.removeElement([], \"a\")              = []\n+     * ArrayUtils.removeElement([\"a\"], \"b\")           = [\"a\"]\n+     * ArrayUtils.removeElement([\"a\", \"b\"], \"a\")      = [\"b\"]\n+     * ArrayUtils.removeElement([\"a\", \"b\", \"a\"], \"a\") = [\"b\", \"a\"]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static <T> T[] removeElement(T[] array, Object element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        }\n+        return remove(array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([true], 0)              = []\n+     * ArrayUtils.remove([true, false], 0)       = [false]\n+     * ArrayUtils.remove([true, false], 1)       = [true]\n+     * ArrayUtils.remove([true, true, false], 1) = [true, false]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static boolean[] remove(boolean[] array, int index) {\n+        return (boolean[]) remove((Object) array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left\n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, true)                = null\n+     * ArrayUtils.removeElement([], true)                  = []\n+     * ArrayUtils.removeElement([true], false)             = [true]\n+     * ArrayUtils.removeElement([true, false], false)      = [true]\n+     * ArrayUtils.removeElement([true, false, true], true) = [false, true]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static boolean[] removeElement(boolean[] array, boolean element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        }\n+        return remove(array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1], 0)          = []\n+     * ArrayUtils.remove([1, 0], 0)       = [0]\n+     * ArrayUtils.remove([1, 0], 1)       = [1]\n+     * ArrayUtils.remove([1, 0, 1], 1)    = [1, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static byte[] remove(byte[] array, int index) {\n+        return (byte[]) remove((Object) array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left\n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1)        = null\n+     * ArrayUtils.removeElement([], 1)          = []\n+     * ArrayUtils.removeElement([1], 0)         = [1]\n+     * ArrayUtils.removeElement([1, 0], 0)      = [1]\n+     * ArrayUtils.removeElement([1, 0, 1], 1)   = [0, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static byte[] removeElement(byte[] array, byte element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        }\n+        return remove(array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove(['a'], 0)           = []\n+     * ArrayUtils.remove(['a', 'b'], 0)      = ['b']\n+     * ArrayUtils.remove(['a', 'b'], 1)      = ['a']\n+     * ArrayUtils.remove(['a', 'b', 'c'], 1) = ['a', 'c']\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static char[] remove(char[] array, int index) {\n+        return (char[]) remove((Object) array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left\n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 'a')            = null\n+     * ArrayUtils.removeElement([], 'a')              = []\n+     * ArrayUtils.removeElement(['a'], 'b')           = ['a']\n+     * ArrayUtils.removeElement(['a', 'b'], 'a')      = ['b']\n+     * ArrayUtils.removeElement(['a', 'b', 'a'], 'a') = ['b', 'a']\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static char[] removeElement(char[] array, char element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        }\n+        return remove(array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1.1], 0)           = []\n+     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]\n+     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]\n+     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static double[] remove(double[] array, int index) {\n+        return (double[]) remove((Object) array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left\n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1.1)            = null\n+     * ArrayUtils.removeElement([], 1.1)              = []\n+     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]\n+     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]\n+     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static double[] removeElement(double[] array, double element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        }\n+        return remove(array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1.1], 0)           = []\n+     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]\n+     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]\n+     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static float[] remove(float[] array, int index) {\n+        return (float[]) remove((Object) array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left\n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1.1)            = null\n+     * ArrayUtils.removeElement([], 1.1)              = []\n+     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]\n+     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]\n+     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static float[] removeElement(float[] array, float element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        }\n+        return remove(array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1], 0)         = []\n+     * ArrayUtils.remove([2, 6], 0)      = [6]\n+     * ArrayUtils.remove([2, 6], 1)      = [2]\n+     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static int[] remove(int[] array, int index) {\n+        return (int[]) remove((Object) array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left\n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1)      = null\n+     * ArrayUtils.removeElement([], 1)        = []\n+     * ArrayUtils.removeElement([1], 2)       = [1]\n+     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n+     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static int[] removeElement(int[] array, int element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        }\n+        return remove(array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1], 0)         = []\n+     * ArrayUtils.remove([2, 6], 0)      = [6]\n+     * ArrayUtils.remove([2, 6], 1)      = [2]\n+     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static long[] remove(long[] array, int index) {\n+        return (long[]) remove((Object) array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left\n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1)      = null\n+     * ArrayUtils.removeElement([], 1)        = []\n+     * ArrayUtils.removeElement([1], 2)       = [1]\n+     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n+     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static long[] removeElement(long[] array, long element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        }\n+        return remove(array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1], 0)         = []\n+     * ArrayUtils.remove([2, 6], 0)      = [6]\n+     * ArrayUtils.remove([2, 6], 1)      = [2]\n+     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static short[] remove(short[] array, int index) {\n+        return (short[]) remove((Object) array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left\n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1)      = null\n+     * ArrayUtils.removeElement([], 1)        = []\n+     * ArrayUtils.removeElement([1], 2)       = [1]\n+     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n+     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static short[] removeElement(short[] array, short element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        }\n+        return remove(array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    private static Object remove(Object array, int index) {\n+        int length = getLength(array);\n+        if (index < 0 || index >= length) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n+        }\n+\n+        Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);\n+        System.arraycopy(array, 0, result, 0, index);\n+        if (index < length - 1) {\n+            System.arraycopy(array, index + 1, result, index, length - index - 1);\n+        }\n+\n+        return result;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/BitField.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+/**\n+ * <p>Operations on bit-mapped fields.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Apache Jakarta POI\n+ * @author Scott Sanders (sanders at apache dot org)\n+ * @author Marc Johnson (mjohnson at apache dot org)\n+ * @author Andrew C. Oliver (acoliver at apache dot org)\n+ * @author Pete Gieser\n+ * @author Gary Gregory\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class BitField {\n+    \n+    private final int _mask;\n+    private final int _shift_count;\n+\n+    /**\n+     * <p>Creates a BitField instance.</p>\n+     *\n+     * @param mask the mask specifying which bits apply to this\n+     *  BitField. Bits that are set in this mask are the bits\n+     *  that this BitField operates on\n+     */\n+    public BitField(int mask) {\n+        _mask = mask;\n+        int count = 0;\n+        int bit_pattern = mask;\n+\n+        if (bit_pattern != 0) {\n+            while ((bit_pattern & 1) == 0) {\n+                count++;\n+                bit_pattern >>= 1;\n+            }\n+        }\n+        _shift_count = count;\n+    }\n+\n+    /**\n+     * <p>Obtains the value for the specified BitField, appropriately\n+     * shifted right.</p>\n+     *\n+     * <p>Many users of a BitField will want to treat the specified\n+     * bits as an int value, and will not want to be aware that the\n+     * value is stored as a BitField (and so shifted left so many\n+     * bits).</p>\n+     *\n+     * @see #setValue(int,int)\n+     * @param holder the int data containing the bits we're interested\n+     *  in\n+     * @return the selected bits, shifted right appropriately\n+     */\n+    public int getValue(int holder) {\n+        return getRawValue(holder) >> _shift_count;\n+    }\n+\n+    /**\n+     * <p>Obtains the value for the specified BitField, appropriately\n+     * shifted right, as a short.</p>\n+     *\n+     * <p>Many users of a BitField will want to treat the specified\n+     * bits as an int value, and will not want to be aware that the\n+     * value is stored as a BitField (and so shifted left so many\n+     * bits).</p>\n+     *\n+     * @see #setShortValue(short,short)\n+     * @param holder the short data containing the bits we're\n+     *  interested in\n+     * @return the selected bits, shifted right appropriately\n+     */\n+    public short getShortValue(short holder) {\n+        return (short) getValue(holder);\n+    }\n+\n+    /**\n+     * <p>Obtains the value for the specified BitField, unshifted.</p>\n+     *\n+     * @param holder the int data containing the bits we're\n+     *  interested in\n+     * @return the selected bits\n+     */\n+    public int getRawValue(int holder) {\n+        return holder & _mask;\n+    }\n+\n+    /**\n+     * <p>Obtains the value for the specified BitField, unshifted.</p>\n+     *\n+     * @param holder the short data containing the bits we're\n+     *  interested in\n+     * @return the selected bits\n+     */\n+    public short getShortRawValue(short holder) {\n+        return (short) getRawValue(holder);\n+    }\n+\n+    /**\n+     * <p>Returns whether the field is set or not.</p>\n+     *\n+     * <p>This is most commonly used for a single-bit field, which is\n+     * often used to represent a boolean value; the results of using\n+     * it for a multi-bit field is to determine whether *any* of its\n+     * bits are set.</p>\n+     *\n+     * @param holder the int data containing the bits we're interested\n+     *  in\n+     * @return <code>true</code> if any of the bits are set,\n+     *  else <code>false</code>\n+     */\n+    public boolean isSet(int holder) {\n+        return (holder & _mask) != 0;\n+    }\n+\n+    /**\n+     * <p>Returns whether all of the bits are set or not.</p>\n+     *\n+     * <p>This is a stricter test than {@link #isSet(int)},\n+     * in that all of the bits in a multi-bit set must be set\n+     * for this method to return <code>true</code>.</p>\n+     *\n+     * @param holder the int data containing the bits we're\n+     *  interested in\n+     * @return <code>true</code> if all of the bits are set,\n+     *  else <code>false</code>\n+     */\n+    public boolean isAllSet(int holder) {\n+        return (holder & _mask) == _mask;\n+    }\n+\n+    /**\n+     * <p>Replaces the bits with new values.</p>\n+     *\n+     * @see #getValue(int)\n+     * @param holder the int data containing the bits we're\n+     *  interested in\n+     * @param value the new value for the specified bits\n+     * @return the value of holder with the bits from the value\n+     *  parameter replacing the old bits\n+     */\n+    public int setValue(int holder, int value) {\n+        return (holder & ~_mask) | ((value << _shift_count) & _mask);\n+    }\n+\n+    /**\n+     * <p>Replaces the bits with new values.</p>\n+     *\n+     * @see #getShortValue(short)\n+     * @param holder the short data containing the bits we're\n+     *  interested in\n+     * @param value the new value for the specified bits\n+     * @return the value of holder with the bits from the value\n+     *  parameter replacing the old bits\n+     */\n+    public short setShortValue(short holder, short value) {\n+        return (short) setValue(holder, value);\n+    }\n+\n+    /**\n+     * <p>Clears the bits.</p>\n+     *\n+     * @param holder the int data containing the bits we're\n+     *  interested in\n+     * @return the value of holder with the specified bits cleared\n+     *  (set to <code>0</code>)\n+     */\n+    public int clear(int holder) {\n+        return holder & ~_mask;\n+    }\n+\n+    /**\n+     * <p>Clears the bits.</p>\n+     *\n+     * @param holder the short data containing the bits we're\n+     *  interested in\n+     * @return the value of holder with the specified bits cleared\n+     *  (set to <code>0</code>)\n+     */\n+    public short clearShort(short holder) {\n+        return (short) clear(holder);\n+    }\n+\n+    /**\n+     * <p>Clears the bits.</p>\n+     *\n+     * @param holder the byte data containing the bits we're\n+     *  interested in\n+     *\n+     * @return the value of holder with the specified bits cleared\n+     *  (set to <code>0</code>)\n+     */\n+    public byte clearByte(byte holder) {\n+        return (byte) clear(holder);\n+    }\n+\n+    /**\n+     * <p>Sets the bits.</p>\n+     *\n+     * @param holder the int data containing the bits we're\n+     *  interested in\n+     * @return the value of holder with the specified bits set\n+     *  to <code>1</code>\n+     */\n+    public int set(int holder) {\n+        return holder | _mask;\n+    }\n+\n+    /**\n+     * <p>Sets the bits.</p>\n+     *\n+     * @param holder the short data containing the bits we're\n+     *  interested in\n+     * @return the value of holder with the specified bits set\n+     *  to <code>1</code>\n+     */\n+    public short setShort(short holder) {\n+        return (short) set(holder);\n+    }\n+\n+    /**\n+     * <p>Sets the bits.</p>\n+     *\n+     * @param holder the byte data containing the bits we're\n+     *  interested in\n+     *\n+     * @return the value of holder with the specified bits set\n+     *  to <code>1</code>\n+     */\n+    public byte setByte(byte holder) {\n+        return (byte) set(holder);\n+    }\n+\n+    /**\n+     * <p>Sets a boolean BitField.</p>\n+     *\n+     * @param holder the int data containing the bits we're\n+     *  interested in\n+     * @param flag indicating whether to set or clear the bits\n+     * @return the value of holder with the specified bits set or\n+     *         cleared\n+     */\n+    public int setBoolean(int holder, boolean flag) {\n+        return flag ? set(holder) : clear(holder);\n+    }\n+\n+    /**\n+     * <p>Sets a boolean BitField.</p>\n+     *\n+     * @param holder the short data containing the bits we're\n+     *  interested in\n+     * @param flag indicating whether to set or clear the bits\n+     * @return the value of holder with the specified bits set or\n+     *  cleared\n+     */\n+    public short setShortBoolean(short holder, boolean flag) {\n+        return flag ? setShort(holder) : clearShort(holder);\n+    }\n+\n+    /**\n+     * <p>Sets a boolean BitField.</p>\n+     *\n+     * @param holder the byte data containing the bits we're\n+     *  interested in\n+     * @param flag indicating whether to set or clear the bits\n+     * @return the value of holder with the specified bits set or\n+     *  cleared\n+     */\n+    public byte setByteBoolean(byte holder, boolean flag) {\n+        return flag ? setByte(holder) : clearByte(holder);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/BooleanUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import org.apache.commons.lang.math.NumberUtils;\n+\n+/**\n+ * <p>Operations on boolean primitives and Boolean objects.</p>\n+ *\n+ * <p>This class tries to handle <code>null</code> input gracefully.\n+ * An exception will not be thrown for a <code>null</code> input.\n+ * Each method documents its behaviour in more detail.</p>\n+ * \n+ * @author Apache Software Foundation\n+ * @author Matthew Hawthorne\n+ * @author Gary Gregory\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class BooleanUtils {\n+\n+    /**\n+     * <p><code>BooleanUtils</code> instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>BooleanUtils.negate(true);</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public BooleanUtils() {\n+      super();\n+    }\n+\n+    // Boolean utilities\n+    //--------------------------------------------------------------------------\n+    /**\n+     * <p>Negates the specified boolean.</p>\n+     * \n+     * <p>If <code>null</code> is passed in, <code>null</code> will be returned.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.negate(Boolean.TRUE)  = Boolean.FALSE;\n+     *   BooleanUtils.negate(Boolean.FALSE) = Boolean.TRUE;\n+     *   BooleanUtils.negate(null)          = null;\n+     * </pre>\n+     * \n+     * @param bool  the Boolean to negate, may be null\n+     * @return the negated Boolean, or <code>null</code> if <code>null</code> input\n+     */\n+    public static Boolean negate(Boolean bool) {\n+        if (bool == null) {\n+            return null;\n+        }\n+        return (bool.booleanValue() ? Boolean.FALSE : Boolean.TRUE);\n+    }\n+    \n+    // boolean Boolean methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if a <code>Boolean</code> value is <code>true</code>,\n+     * handling <code>null</code> by returning <code>false</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.isTrue(Boolean.TRUE)  = true\n+     *   BooleanUtils.isTrue(Boolean.FALSE) = false\n+     *   BooleanUtils.isTrue(null)          = false\n+     * </pre>\n+     *\n+     * @param bool  the boolean to check, null returns <code>false</code>\n+     * @return <code>true</code> only if the input is non-null and true\n+     * @since 2.1\n+     */\n+    public static boolean isTrue(Boolean bool) {\n+        if (bool == null) {\n+            return false;\n+        }\n+        return bool.booleanValue() ? true : false;\n+    }\n+\n+    /**\n+     * <p>Checks if a <code>Boolean</code> value is <i>not</i> <code>true</code>,\n+     * handling <code>null</code> by returning <code>true</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.isNotTrue(Boolean.TRUE)  = false\n+     *   BooleanUtils.isNotTrue(Boolean.FALSE) = true\n+     *   BooleanUtils.isNotTrue(null)          = true\n+     * </pre>\n+     *\n+     * @param bool  the boolean to check, null returns <code>true</code>\n+     * @return <code>true</code> if the input is null or false\n+     * @since 2.3\n+     */\n+    public static boolean isNotTrue(Boolean bool) {\n+        return !isTrue(bool);\n+    }\n+\n+    /**\n+     * <p>Checks if a <code>Boolean</code> value is <code>false</code>,\n+     * handling <code>null</code> by returning <code>false</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.isFalse(Boolean.TRUE)  = false\n+     *   BooleanUtils.isFalse(Boolean.FALSE) = true\n+     *   BooleanUtils.isFalse(null)          = false\n+     * </pre>\n+     *\n+     * @param bool  the boolean to check, null returns <code>false</code>\n+     * @return <code>true</code> only if the input is non-null and false\n+     * @since 2.1\n+     */\n+    public static boolean isFalse(Boolean bool) {\n+        if (bool == null) {\n+            return false;\n+        }\n+        return bool.booleanValue() ? false : true;\n+    }\n+\n+    /**\n+     * <p>Checks if a <code>Boolean</code> value is <i>not</i> <code>false</code>,\n+     * handling <code>null</code> by returning <code>true</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.isNotFalse(Boolean.TRUE)  = true\n+     *   BooleanUtils.isNotFalse(Boolean.FALSE) = false\n+     *   BooleanUtils.isNotFalse(null)          = true\n+     * </pre>\n+     *\n+     * @param bool  the boolean to check, null returns <code>true</code>\n+     * @return <code>true</code> if the input is null or true\n+     * @since 2.3\n+     */\n+    public static boolean isNotFalse(Boolean bool) {\n+        return !isFalse(bool);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a Boolean to a boolean handling <code>null</code>\n+     * by returning <code>false</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBoolean(Boolean.TRUE)  = true\n+     *   BooleanUtils.toBoolean(Boolean.FALSE) = false\n+     *   BooleanUtils.toBoolean(null)          = false\n+     * </pre>\n+     *\n+     * @param bool  the boolean to convert\n+     * @return <code>true</code> or <code>false</code>, \n+     *  <code>null</code> returns <code>false</code>\n+     */\n+    public static boolean toBoolean(Boolean bool) {\n+        if (bool == null) {\n+            return false;\n+        }\n+        return bool.booleanValue() ? true : false;\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to a boolean handling <code>null</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, false) = true\n+     *   BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, true) = false\n+     *   BooleanUtils.toBooleanDefaultIfNull(null, true)          = true\n+     * </pre>\n+     *\n+     * @param bool  the boolean to convert\n+     * @param valueIfNull  the boolean value to return if <code>null</code>\n+     * @return <code>true</code> or <code>false</code>\n+     */\n+    public static boolean toBooleanDefaultIfNull(Boolean bool, boolean valueIfNull) {\n+        if (bool == null) {\n+            return valueIfNull;\n+        }\n+        return bool.booleanValue() ? true : false;\n+    }\n+    \n+    // Integer to Boolean methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an int to a boolean using the convention that <code>zero</code>\n+     * is <code>false</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBoolean(0) = false\n+     *   BooleanUtils.toBoolean(1) = true\n+     *   BooleanUtils.toBoolean(2) = true\n+     * </pre>\n+     *\n+     * @param value  the int to convert\n+     * @return <code>true</code> if non-zero, <code>false</code>\n+     *  if zero\n+     */\n+    public static boolean toBoolean(int value) {\n+        return value == 0 ? false : true;\n+    }\n+    \n+    /**\n+     * <p>Converts an int to a Boolean using the convention that <code>zero</code>\n+     * is <code>false</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBoolean(0) = Boolean.FALSE\n+     *   BooleanUtils.toBoolean(1) = Boolean.TRUE\n+     *   BooleanUtils.toBoolean(2) = Boolean.TRUE\n+     * </pre>\n+     *\n+     * @param value  the int to convert\n+     * @return Boolean.TRUE if non-zero, Boolean.FALSE if zero,\n+     *  <code>null</code> if <code>null</code>\n+     */\n+    public static Boolean toBooleanObject(int value) {\n+        return value == 0 ? Boolean.FALSE : Boolean.TRUE;\n+    }\n+    \n+    /**\n+     * <p>Converts an Integer to a Boolean using the convention that <code>zero</code>\n+     * is <code>false</code>.</p>\n+     * \n+     * <p><code>null</code> will be converted to <code>null</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBoolean(new Integer(0))    = Boolean.FALSE\n+     *   BooleanUtils.toBoolean(new Integer(1))    = Boolean.TRUE\n+     *   BooleanUtils.toBoolean(new Integer(null)) = null\n+     * </pre>\n+     *\n+     * @param value  the Integer to convert\n+     * @return Boolean.TRUE if non-zero, Boolean.FALSE if zero,\n+     *  <code>null</code> if <code>null</code> input\n+     */\n+    public static Boolean toBooleanObject(Integer value) {\n+        if (value == null) {\n+            return null;\n+        }\n+        return value.intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n+    }\n+    \n+    /**\n+     * <p>Converts an int to a boolean specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBoolean(0, 1, 0) = false\n+     *   BooleanUtils.toBoolean(1, 1, 0) = true\n+     *   BooleanUtils.toBoolean(2, 1, 2) = false\n+     *   BooleanUtils.toBoolean(2, 2, 0) = true\n+     * </pre>\n+     *\n+     * @param value  the Integer to convert\n+     * @param trueValue  the value to match for <code>true</code>\n+     * @param falseValue  the value to match for <code>false</code>\n+     * @return <code>true</code> or <code>false</code>\n+     * @throws IllegalArgumentException if no match\n+     */\n+    public static boolean toBoolean(int value, int trueValue, int falseValue) {\n+        if (value == trueValue) {\n+            return true;\n+        } else if (value == falseValue) {\n+            return false;\n+        }\n+        // no match\n+        throw new IllegalArgumentException(\"The Integer did not match either specified value\");\n+    }\n+    \n+    /**\n+     * <p>Converts an Integer to a boolean specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBoolean(new Integer(0), new Integer(1), new Integer(0)) = false\n+     *   BooleanUtils.toBoolean(new Integer(1), new Integer(1), new Integer(0)) = true\n+     *   BooleanUtils.toBoolean(new Integer(2), new Integer(1), new Integer(2)) = false\n+     *   BooleanUtils.toBoolean(new Integer(2), new Integer(2), new Integer(0)) = true\n+     *   BooleanUtils.toBoolean(null, null, new Integer(0))                     = true\n+     * </pre>\n+     *\n+     * @param value  the Integer to convert\n+     * @param trueValue  the value to match for <code>true</code>,\n+     *  may be <code>null</code>\n+     * @param falseValue  the value to match for <code>false</code>,\n+     *  may be <code>null</code>\n+     * @return <code>true</code> or <code>false</code>\n+     * @throws IllegalArgumentException if no match\n+     */\n+    public static boolean toBoolean(Integer value, Integer trueValue, Integer falseValue) {\n+        if (value == null) {\n+            if (trueValue == null) {\n+                return true;\n+            } else if (falseValue == null) {\n+                return false;\n+            }\n+        } else if (value.equals(trueValue)) {\n+            return true;\n+        } else if (value.equals(falseValue)) {\n+            return false;\n+        }\n+        // no match\n+        throw new IllegalArgumentException(\"The Integer did not match either specified value\");\n+    }\n+    \n+    /**\n+     * <p>Converts an int to a Boolean specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBooleanObject(0, 0, 2, 3) = Boolean.TRUE\n+     *   BooleanUtils.toBooleanObject(2, 1, 2, 3) = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(3, 1, 2, 3) = null\n+     * </pre>\n+     *\n+     * @param value  the Integer to convert\n+     * @param trueValue  the value to match for <code>true</code>\n+     * @param falseValue  the value to match for <code>false</code>\n+     * @param nullValue  the value to to match for <code>null</code>\n+     * @return Boolean.TRUE, Boolean.FALSE, or <code>null</code>\n+     * @throws IllegalArgumentException if no match\n+     */\n+    public static Boolean toBooleanObject(int value, int trueValue, int falseValue, int nullValue) {\n+        if (value == trueValue) {\n+            return Boolean.TRUE;\n+        } else if (value == falseValue) {\n+            return Boolean.FALSE;\n+        } else if (value == nullValue) {\n+            return null;\n+        }\n+        // no match\n+        throw new IllegalArgumentException(\"The Integer did not match any specified value\");\n+    }\n+    \n+    /**\n+     * <p>Converts an Integer to a Boolean specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBooleanObject(new Integer(0), new Integer(0), new Integer(2), new Integer(3)) = Boolean.TRUE\n+     *   BooleanUtils.toBooleanObject(new Integer(2), new Integer(1), new Integer(2), new Integer(3)) = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(new Integer(3), new Integer(1), new Integer(2), new Integer(3)) = null\n+     * </pre>\n+     *\n+     * @param value  the Integer to convert\n+     * @param trueValue  the value to match for <code>true</code>,\n+     *  may be <code>null</code>\n+     * @param falseValue  the value to match for <code>false</code>,\n+     *  may be <code>null</code>\n+     * @param nullValue  the value to to match for <code>null</code>,\n+     *  may be <code>null</code>\n+     * @return Boolean.TRUE, Boolean.FALSE, or <code>null</code>\n+     * @throws IllegalArgumentException if no match\n+     */\n+    public static Boolean toBooleanObject(Integer value, Integer trueValue, Integer falseValue, Integer nullValue) {\n+        if (value == null) {\n+            if (trueValue == null) {\n+                return Boolean.TRUE;\n+            } else if (falseValue == null) {\n+                return Boolean.FALSE;\n+            } else if (nullValue == null) {\n+                return null;\n+            }\n+        } else if (value.equals(trueValue)) {\n+            return Boolean.TRUE;\n+        } else if (value.equals(falseValue)) {\n+            return Boolean.FALSE;\n+        } else if (value.equals(nullValue)) {\n+            return null;\n+        }\n+        // no match\n+        throw new IllegalArgumentException(\"The Integer did not match any specified value\");\n+    }\n+    \n+    // Boolean to Integer methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a boolean to an int using the convention that\n+     * <code>zero</code> is <code>false</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toInteger(true)  = 1\n+     *   BooleanUtils.toInteger(false) = 0\n+     * </pre>\n+     *\n+     * @param bool  the boolean to convert\n+     * @return one if <code>true</code>, zero if <code>false</code>\n+     */\n+    public static int toInteger(boolean bool) {\n+        return bool ? 1 : 0;\n+    }\n+    \n+    /**\n+     * <p>Converts a boolean to an Integer using the convention that\n+     * <code>zero</code> is <code>false</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toIntegerObject(true)  = new Integer(1)\n+     *   BooleanUtils.toIntegerObject(false) = new Integer(0)\n+     * </pre>\n+     *\n+     * @param bool  the boolean to convert\n+     * @return one if <code>true</code>, zero if <code>false</code>\n+     */\n+    public static Integer toIntegerObject(boolean bool) {\n+        return bool ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO;\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to a Integer using the convention that\n+     * <code>zero</code> is <code>false</code>.</p>\n+     *\n+     * <p><code>null</code> will be converted to <code>null</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toIntegerObject(Boolean.TRUE)  = new Integer(1)\n+     *   BooleanUtils.toIntegerObject(Boolean.FALSE) = new Integer(0)\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to convert\n+     * @return one if Boolean.TRUE, zero if Boolean.FALSE, <code>null</code> if <code>null</code>\n+     */\n+    public static Integer toIntegerObject(Boolean bool) {\n+        if (bool == null) {\n+            return null;\n+        }\n+        return bool.booleanValue() ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO;\n+    }\n+    \n+    /**\n+     * <p>Converts a boolean to an int specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toInteger(true, 1, 0)  = 1\n+     *   BooleanUtils.toInteger(false, 1, 0) = 0\n+     * </pre>\n+     *\n+     * @param bool  the to convert\n+     * @param trueValue  the value to return if <code>true</code>\n+     * @param falseValue  the value to return if <code>false</code>\n+     * @return the appropriate value\n+     */\n+    public static int toInteger(boolean bool, int trueValue, int falseValue) {\n+        return bool ? trueValue : falseValue;\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to an int specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toInteger(Boolean.TRUE, 1, 0, 2)  = 1\n+     *   BooleanUtils.toInteger(Boolean.FALSE, 1, 0, 2) = 0\n+     *   BooleanUtils.toInteger(null, 1, 0, 2)          = 2\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to convert\n+     * @param trueValue  the value to return if <code>true</code>\n+     * @param falseValue  the value to return if <code>false</code>\n+     * @param nullValue  the value to return if <code>null</code>\n+     * @return the appropriate value\n+     */\n+    public static int toInteger(Boolean bool, int trueValue, int falseValue, int nullValue) {\n+        if (bool == null) {\n+            return nullValue;\n+        }\n+        return bool.booleanValue() ? trueValue : falseValue;\n+    }\n+    \n+    /**\n+     * <p>Converts a boolean to an Integer specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toIntegerObject(true, new Integer(1), new Integer(0))  = new Integer(1)\n+     *   BooleanUtils.toIntegerObject(false, new Integer(1), new Integer(0)) = new Integer(0)\n+     * </pre>\n+     *\n+     * @param bool  the to convert\n+     * @param trueValue  the value to return if <code>true</code>,\n+     *  may be <code>null</code>\n+     * @param falseValue  the value to return if <code>false</code>,\n+     *  may be <code>null</code>\n+     * @return the appropriate value\n+     */\n+    public static Integer toIntegerObject(boolean bool, Integer trueValue, Integer falseValue) {\n+        return bool ? trueValue : falseValue;\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to an Integer specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toIntegerObject(Boolean.TRUE, new Integer(1), new Integer(0), new Integer(2))  = new Integer(1)\n+     *   BooleanUtils.toIntegerObject(Boolean.FALSE, new Integer(1), new Integer(0), new Integer(2)) = new Integer(0)\n+     *   BooleanUtils.toIntegerObject(null, new Integer(1), new Integer(0), new Integer(2))          = new Integer(2)\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to convert\n+     * @param trueValue  the value to return if <code>true</code>,\n+     *  may be <code>null</code>\n+     * @param falseValue  the value to return if <code>false</code>,\n+     *  may be <code>null</code>\n+     * @param nullValue  the value to return if <code>null</code>,\n+     *  may be <code>null</code>\n+     * @return the appropriate value\n+     */\n+    public static Integer toIntegerObject(Boolean bool, Integer trueValue, Integer falseValue, Integer nullValue) {\n+        if (bool == null) {\n+            return nullValue;\n+        }\n+        return bool.booleanValue() ? trueValue : falseValue;\n+    }\n+    \n+    // String to Boolean methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a String to a Boolean.</p>\n+     * \n+     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n+     * (case insensitive) will return <code>true</code>.\n+     * <code>'false'</code>, <code>'off'</code> or <code>'no'</code>\n+     * (case insensitive) will return <code>false</code>.\n+     * Otherwise, <code>null</code> is returned.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBooleanObject(null)    = null\n+     *   BooleanUtils.toBooleanObject(\"true\")  = Boolean.TRUE\n+     *   BooleanUtils.toBooleanObject(\"false\") = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(\"on\")    = Boolean.TRUE\n+     *   BooleanUtils.toBooleanObject(\"ON\")    = Boolean.TRUE\n+     *   BooleanUtils.toBooleanObject(\"off\")   = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(\"oFf\")   = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(\"blue\")  = null\n+     * </pre>\n+     *\n+     * @param str  the String to check\n+     * @return the Boolean value of the string,\n+     *  <code>null</code> if no match or <code>null</code> input\n+     */\n+    public static Boolean toBooleanObject(String str) {\n+        if (\"true\".equalsIgnoreCase(str)) {\n+            return Boolean.TRUE;\n+        } else if (\"false\".equalsIgnoreCase(str)) {\n+            return Boolean.FALSE;\n+        } else if (\"on\".equalsIgnoreCase(str)) {\n+            return Boolean.TRUE;\n+        } else if (\"off\".equalsIgnoreCase(str)) {\n+            return Boolean.FALSE;\n+        } else if (\"yes\".equalsIgnoreCase(str)) {\n+            return Boolean.TRUE;\n+        } else if (\"no\".equalsIgnoreCase(str)) {\n+            return Boolean.FALSE;\n+        }\n+        // no match\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Converts a String to a Boolean throwing an exception if no match.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBooleanObject(\"true\", \"true\", \"false\", \"null\")  = Boolean.TRUE\n+     *   BooleanUtils.toBooleanObject(\"false\", \"true\", \"false\", \"null\") = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(\"null\", \"true\", \"false\", \"null\")  = null\n+     * </pre>\n+     *\n+     * @param str  the String to check\n+     * @param trueString  the String to match for <code>true</code>\n+     *  (case sensitive), may be <code>null</code>\n+     * @param falseString  the String to match for <code>false</code>\n+     *  (case sensitive), may be <code>null</code>\n+     * @param nullString  the String to match for <code>null</code>\n+     *  (case sensitive), may be <code>null</code>\n+     * @return the Boolean value of the string,\n+     *  <code>null</code> if either the String matches <code>nullString</code>\n+     *  or if <code>null</code> input and <code>nullString</code> is\n+     *  <code>null</code>\n+     * @throws IllegalArgumentException if the String doesn't match\n+     */\n+    public static Boolean toBooleanObject(String str, String trueString, String falseString, String nullString) {\n+        if (str == null) {\n+            if (trueString == null) {\n+                return Boolean.TRUE;\n+            } else if (falseString == null) {\n+                return Boolean.FALSE;\n+            } else if (nullString == null) {\n+                return null;\n+            }\n+        } else if (str.equals(trueString)) {\n+            return Boolean.TRUE;\n+        } else if (str.equals(falseString)) {\n+            return Boolean.FALSE;\n+        } else if (str.equals(nullString)) {\n+            return null;\n+        }\n+        // no match\n+        throw new IllegalArgumentException(\"The String did not match any specified value\");\n+    }\n+\n+    // String to boolean methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a String to a boolean (optimised for performance).</p>\n+     * \n+     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n+     * (case insensitive) will return <code>true</code>. Otherwise,\n+     * <code>false</code> is returned.</p>\n+     * \n+     * <p>This method performs 4 times faster (JDK1.4) than\n+     * <code>Boolean.valueOf(String)</code>. However, this method accepts\n+     * 'on' and 'yes' as true values.\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBoolean(null)    = false\n+     *   BooleanUtils.toBoolean(\"true\")  = true\n+     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n+     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n+     *   BooleanUtils.toBoolean(\"on\")    = true\n+     *   BooleanUtils.toBoolean(\"yes\")   = true\n+     *   BooleanUtils.toBoolean(\"false\") = false\n+     *   BooleanUtils.toBoolean(\"x gti\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check\n+     * @return the boolean value of the string, <code>false</code> if no match\n+     */\n+    public static boolean toBoolean(String str) {\n+        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n+        // Non interned 'true' matched 15 times slower.\n+        // \n+        // Optimisation provides same performance as before for interned 'true'.\n+        // Similar performance for null, 'false', and other strings not length 2/3/4.\n+        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n+        if (str == \"true\") {\n+            return true;\n+        }\n+        if (str == null) {\n+            return false;\n+        }\n+        switch (str.length()) {\n+            case 2: {\n+                char ch0 = str.charAt(0);\n+                char ch1 = str.charAt(1);\n+                return \n+                    (ch0 == 'o' || ch0 == 'O') &&\n+                    (ch1 == 'n' || ch1 == 'N');\n+            }\n+            case 3: {\n+                char ch = str.charAt(0);\n+                if (ch == 'y') {\n+                    return \n+                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n+                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n+                }\n+                if (ch == 'Y') {\n+                    return \n+                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n+                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n+                }\n+                return false;\n+            }\n+            case 4: {\n+                char ch = str.charAt(0);\n+                if (ch == 't') {\n+                    return \n+                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n+                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n+                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n+                }\n+                if (ch == 'T') {\n+                    return \n+                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n+                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n+                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * <p>Converts a String to a Boolean throwing an exception if no match found.</p>\n+     * \n+     * <p>null is returned if there is no match.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBoolean(\"true\", \"true\", \"false\")  = true\n+     *   BooleanUtils.toBoolean(\"false\", \"true\", \"false\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check\n+     * @param trueString  the String to match for <code>true</code>\n+     *  (case sensitive), may be <code>null</code>\n+     * @param falseString  the String to match for <code>false</code>\n+     *  (case sensitive), may be <code>null</code>\n+     * @return the boolean value of the string\n+     * @throws IllegalArgumentException if the String doesn't match\n+     */\n+    public static boolean toBoolean(String str, String trueString, String falseString) {\n+        if (str == null) {\n+            if (trueString == null) {\n+                return true;\n+            } else if (falseString == null) {\n+                return false;\n+            }\n+        } else if (str.equals(trueString)) {\n+            return true;\n+        } else if (str.equals(falseString)) {\n+            return false;\n+        }\n+        // no match\n+        throw new IllegalArgumentException(\"The String did not match either specified value\");\n+    }\n+\n+    // Boolean to String methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a Boolean to a String returning <code>'true'</code>,\n+     * <code>'false'</code>, or <code>null</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toStringTrueFalse(Boolean.TRUE)  = \"true\"\n+     *   BooleanUtils.toStringTrueFalse(Boolean.FALSE) = \"false\"\n+     *   BooleanUtils.toStringTrueFalse(null)          = null;\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @return <code>'true'</code>, <code>'false'</code>,\n+     *  or <code>null</code>\n+     */\n+    public static String toStringTrueFalse(Boolean bool) {\n+        return toString(bool, \"true\", \"false\", null);\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to a String returning <code>'on'</code>,\n+     * <code>'off'</code>, or <code>null</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toStringOnOff(Boolean.TRUE)  = \"on\"\n+     *   BooleanUtils.toStringOnOff(Boolean.FALSE) = \"off\"\n+     *   BooleanUtils.toStringOnOff(null)          = null;\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @return <code>'on'</code>, <code>'off'</code>,\n+     *  or <code>null</code>\n+     */\n+    public static String toStringOnOff(Boolean bool) {\n+        return toString(bool, \"on\", \"off\", null);\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to a String returning <code>'yes'</code>,\n+     * <code>'no'</code>, or <code>null</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toStringYesNo(Boolean.TRUE)  = \"yes\"\n+     *   BooleanUtils.toStringYesNo(Boolean.FALSE) = \"no\"\n+     *   BooleanUtils.toStringYesNo(null)          = null;\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @return <code>'yes'</code>, <code>'no'</code>,\n+     *  or <code>null</code>\n+     */\n+    public static String toStringYesNo(Boolean bool) {\n+        return toString(bool, \"yes\", \"no\", null);\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to a String returning one of the input Strings.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toString(Boolean.TRUE, \"true\", \"false\", null)   = \"true\"\n+     *   BooleanUtils.toString(Boolean.FALSE, \"true\", \"false\", null)  = \"false\"\n+     *   BooleanUtils.toString(null, \"true\", \"false\", null)           = null;\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @param trueString  the String to return if <code>true</code>,\n+     *  may be <code>null</code>\n+     * @param falseString  the String to return if <code>false</code>,\n+     *  may be <code>null</code>\n+     * @param nullString  the String to return if <code>null</code>,\n+     *  may be <code>null</code>\n+     * @return one of the three input Strings\n+     */\n+    public static String toString(Boolean bool, String trueString, String falseString, String nullString) {\n+        if (bool == null) {\n+            return nullString;\n+        }\n+        return bool.booleanValue() ? trueString : falseString;\n+    }\n+    \n+    // boolean to String methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a boolean to a String returning <code>'true'</code>\n+     * or <code>'false'</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toStringTrueFalse(true)   = \"true\"\n+     *   BooleanUtils.toStringTrueFalse(false)  = \"false\"\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @return <code>'true'</code>, <code>'false'</code>,\n+     *  or <code>null</code>\n+     */\n+    public static String toStringTrueFalse(boolean bool) {\n+        return toString(bool, \"true\", \"false\");\n+    }\n+    \n+    /**\n+     * <p>Converts a boolean to a String returning <code>'on'</code>\n+     * or <code>'off'</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toStringOnOff(true)   = \"on\"\n+     *   BooleanUtils.toStringOnOff(false)  = \"off\"\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @return <code>'on'</code>, <code>'off'</code>,\n+     *  or <code>null</code>\n+     */\n+    public static String toStringOnOff(boolean bool) {\n+        return toString(bool, \"on\", \"off\");\n+    }\n+    \n+    /**\n+     * <p>Converts a boolean to a String returning <code>'yes'</code>\n+     * or <code>'no'</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toStringYesNo(true)   = \"yes\"\n+     *   BooleanUtils.toStringYesNo(false)  = \"no\"\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @return <code>'yes'</code>, <code>'no'</code>,\n+     *  or <code>null</code>\n+     */\n+    public static String toStringYesNo(boolean bool) {\n+        return toString(bool, \"yes\", \"no\");\n+    }\n+    \n+    /**\n+     * <p>Converts a boolean to a String returning one of the input Strings.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toString(true, \"true\", \"false\")   = \"true\"\n+     *   BooleanUtils.toString(false, \"true\", \"false\")  = \"false\"\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @param trueString  the String to return if <code>true</code>,\n+     *  may be <code>null</code>\n+     * @param falseString  the String to return if <code>false</code>,\n+     *  may be <code>null</code>\n+     * @return one of the two input Strings\n+     */\n+    public static String toString(boolean bool, String trueString, String falseString) {\n+        return bool ? trueString : falseString;\n+    }\n+    \n+    // xor methods\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Performs an xor on a set of booleans.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.xor(new boolean[] { true, true })   = false\n+     *   BooleanUtils.xor(new boolean[] { false, false }) = false\n+     *   BooleanUtils.xor(new boolean[] { true, false })  = true\n+     * </pre>\n+     *\n+     * @param array  an array of <code>boolean<code>s\n+     * @return <code>true</code> if the xor is successful.\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty.\n+     */\n+    public static boolean xor(boolean[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array is empty\");\n+        }\n+\n+        // Loops through array, comparing each item\n+        int trueCount = 0;\n+        for (boolean element : array) {\n+            // If item is true, and trueCount is < 1, increments count\n+            // Else, xor fails\n+            if (element) {\n+                if (trueCount < 1) {\n+                    trueCount++;\n+                } else {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        // Returns true if there was exactly 1 true item\n+        return trueCount == 1;\n+    }\n+\n+    /**\n+     * <p>Performs an xor on an array of Booleans.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.xor(new Boolean[] { Boolean.TRUE, Boolean.TRUE })   = Boolean.FALSE\n+     *   BooleanUtils.xor(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) = Boolean.FALSE\n+     *   BooleanUtils.xor(new Boolean[] { Boolean.TRUE, Boolean.FALSE })  = Boolean.TRUE\n+     * </pre>\n+     *\n+     * @param array  an array of <code>Boolean<code>s\n+     * @return <code>true</code> if the xor is successful.\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty.\n+     * @throws IllegalArgumentException if <code>array</code> contains a <code>null</code>\n+     */\n+    public static Boolean xor(Boolean[] array) {\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array is empty\");\n+        }\n+        boolean[] primitive = null;\n+        try {\n+            primitive = ArrayUtils.toPrimitive(array);\n+        } catch (NullPointerException ex) {\n+            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n+        }\n+        return xor(primitive) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/CharEncoding.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang;\n+\n+import java.io.UnsupportedEncodingException;\n+\n+/**\n+ * <p>\n+ * Character encoding names required of every implementation of the Java platform.\n+ * </p>\n+ * \n+ * <p>\n+ * According to <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+ * encoding names</a>:\n+ * <p>\n+ * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult the\n+ * release documentation for your implementation to see if any other encodings are supported.</cite>\n+ * </p>\n+ * </p>\n+ * \n+ * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character encoding\n+ *      names</a>\n+ * @author Apache Software Foundation\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class CharEncoding {\n+\n+    /**\n+     * <p>\n+     * ISO Latin Alphabet #1, also known as ISO-LATIN-1.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static final String ISO_8859_1 = \"ISO-8859-1\";\n+\n+    /**\n+     * <p>\n+     * Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static final String US_ASCII = \"US-ASCII\";\n+\n+    /**\n+     * <p>\n+     * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either\n+     * order accepted on input, big-endian used on output).\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static final String UTF_16 = \"UTF-16\";\n+\n+    /**\n+     * <p>\n+     * Sixteen-bit Unicode Transformation Format, big-endian byte order.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static final String UTF_16BE = \"UTF-16BE\";\n+\n+    /**\n+     * <p>\n+     * Sixteen-bit Unicode Transformation Format, little-endian byte order.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static final String UTF_16LE = \"UTF-16LE\";\n+\n+    /**\n+     * <p>\n+     * Eight-bit Unicode Transformation Format.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static final String UTF_8 = \"UTF-8\";\n+\n+    /**\n+     * <p>\n+     * Returns whether the named charset is supported.\n+     * </p>\n+     * <p>\n+     * This is similar to <a\n+     * href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html#isSupported(java.lang.String)\">\n+     * java.nio.charset.Charset.isSupported(String)</a>\n+     * </p>\n+     * \n+     * @param name\n+     *            the name of the requested charset; may be either a canonical name or an alias\n+     * @return <code>true</code> if, and only if, support for the named charset is available in the current Java\n+     *         virtual machine\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static boolean isSupported(String name) {\n+        if (name == null) {\n+            return false;\n+        }\n+        try {\n+            new String(ArrayUtils.EMPTY_BYTE_ARRAY, name);\n+        } catch (UnsupportedEncodingException e) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/CharRange.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * <p>A contiguous range of characters, optionally negated.</p>\n+ * \n+ * <p>Instances are immutable.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Chris Feldhacker\n+ * @author Gary Gregory\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public final class CharRange implements Serializable {\n+\n+    /**\n+     * Required for serialization support. Lang version 2.0. \n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 8270183163158333422L;\n+    \n+    /** The first character, inclusive, in the range. */\n+    private final char start;\n+    /** The last character, inclusive, in the range. */\n+    private final char end;\n+    /** True if the range is everything except the characters specified. */\n+    private final boolean negated;\n+    \n+    /** Cached toString. */\n+    private transient String iToString;\n+\n+    /**\n+     * <p>Constructs a <code>CharRange</code> over a set of characters,\n+     * optionally negating the range.</p>\n+     *\n+     * <p>A negated range includes everything except that defined by the\n+     * start and end characters.</p>\n+     * \n+     * <p>If start and end are in the wrong order, they are reversed.\n+     * Thus <code>a-e</code> is the same as <code>e-a</code>.</p>\n+     *\n+     * @param start  first character, inclusive, in this range\n+     * @param end  last character, inclusive, in this range\n+     * @param negated  true to express everything except the range\n+     */\n+    private CharRange(char start, char end, boolean negated) {\n+        super();\n+        if (start > end) {\n+            char temp = start;\n+            start = end;\n+            end = temp;\n+        }\n+        \n+        this.start = start;\n+        this.end = end;\n+        this.negated = negated;\n+    }\n+\n+    /**\n+     * <p>Constructs a <code>CharRange</code> over a single character.</p>\n+     *\n+     * @param ch  only character in this range\n+     * @see CharRange#CharRange(char, char, boolean)\n+     */\n+    public static CharRange is(char ch) {\n+        return new CharRange(ch, ch, false);\n+    }\n+\n+    /**\n+     * <p>Constructs a negated <code>CharRange</code> over a single character.</p>\n+     *\n+     * @param ch  only character in this range\n+     * @see CharRange#CharRange(char, char, boolean)\n+     */\n+    public static CharRange isNot(char ch) {\n+        return new CharRange(ch, ch, true);\n+    }\n+\n+    /**\n+     * <p>Constructs a <code>CharRange</code> over a set of characters.</p>\n+     *\n+     * @param start  first character, inclusive, in this range\n+     * @param end  last character, inclusive, in this range\n+     * @see CharRange#CharRange(char, char, boolean)\n+     */\n+    public static CharRange isIn(char start, char end) {\n+        return new CharRange(start, end, false);\n+    }\n+\n+    /**\n+     * <p>Constructs a negated <code>CharRange</code> over a set of characters.</p>\n+     *\n+     * @param start  first character, inclusive, in this range\n+     * @param end  last character, inclusive, in this range\n+     * @see CharRange#CharRange(char, char, boolean)\n+     */\n+    public static CharRange isNotIn(char start, char end) {\n+        return new CharRange(start, end, true);\n+    }\n+\n+    // Accessors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the start character for this character range.</p>\n+     * \n+     * @return the start char (inclusive)\n+     */\n+    public char getStart() {\n+        return this.start;\n+    }\n+\n+    /**\n+     * <p>Gets the end character for this character range.</p>\n+     * \n+     * @return the end char (inclusive)\n+     */\n+    public char getEnd() {\n+        return this.end;\n+    }\n+\n+    /**\n+     * <p>Is this <code>CharRange</code> negated.</p>\n+     * \n+     * <p>A negated range includes everything except that defined by the\n+     * start and end characters.</p>\n+     *\n+     * @return <code>true</code> is negated\n+     */\n+    public boolean isNegated() {\n+        return negated;\n+    }\n+\n+    // Contains\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Is the character specified contained in this range.</p>\n+     *\n+     * @param ch  the character to check\n+     * @return <code>true</code> if this range contains the input character\n+     */\n+    public boolean contains(char ch) {\n+        return (ch >= start && ch <= end) != negated;\n+    }\n+\n+    /**\n+     * <p>Are all the characters of the passed in range contained in\n+     * this range.</p>\n+     *\n+     * @param range  the range to check against\n+     * @return <code>true</code> if this range entirely contains the input range\n+     * @throws IllegalArgumentException if <code>null</code> input\n+     */\n+    public boolean contains(CharRange range) {\n+        if (range == null) {\n+            throw new IllegalArgumentException(\"The Range must not be null\");\n+        }\n+        if (negated) {\n+            if (range.negated) {\n+                return start >= range.start && end <= range.end;\n+            }\n+            return range.end < start || range.start > end;\n+        }\n+        if (range.negated) {\n+            return start == 0 && end == Character.MAX_VALUE;\n+        }\n+        return start <= range.start && end >= range.end;\n+    }\n+\n+    // Basics\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compares two CharRange objects, returning true if they represent\n+     * exactly the same range of characters defined in the same way.</p>\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof CharRange == false) {\n+            return false;\n+        }\n+        CharRange other = (CharRange) obj;\n+        return start == other.start && end == other.end && negated == other.negated;\n+    }\n+\n+    /**\n+     * <p>Gets a hashCode compatible with the equals method.</p>\n+     * \n+     * @return a suitable hashCode\n+     */\n+    @Override\n+    public int hashCode() {\n+        return 83 + start + 7 * end + (negated ? 1 : 0);\n+    }\n+    \n+    /**\n+     * <p>Gets a string representation of the character range.</p>\n+     * \n+     * @return string representation of this range\n+     */\n+    @Override\n+    public String toString() {\n+        if (iToString == null) {\n+            StringBuilder buf = new StringBuilder(4);\n+            if (isNegated()) {\n+                buf.append('^');\n+            }\n+            buf.append(start);\n+            if (start != end) {\n+                buf.append('-');\n+                buf.append(end);\n+            }\n+            iToString = buf.toString();\n+        }\n+        return iToString;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/CharSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * <p>A set of characters.</p>\n+ *\n+ * <p>Instances are immutable, but instances of subclasses may not be.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Phil Steitz\n+ * @author Pete Gieser\n+ * @author Gary Gregory\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class CharSet implements Serializable {\n+\n+    /**\n+     * Required for serialization support. Lang version 2.0. \n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 5947847346149275958L;\n+\n+    /** \n+     * A CharSet defining no characters. \n+     * @since 2.0\n+     */\n+    public static final CharSet EMPTY = new CharSet((String) null);\n+\n+    /** \n+     * A CharSet defining ASCII alphabetic characters \"a-zA-Z\".\n+     * @since 2.0\n+     */\n+    public static final CharSet ASCII_ALPHA = new CharSet(\"a-zA-Z\");\n+\n+    /** \n+     * A CharSet defining ASCII alphabetic characters \"a-z\".\n+     * @since 2.0\n+     */\n+    public static final CharSet ASCII_ALPHA_LOWER = new CharSet(\"a-z\");\n+\n+    /** \n+     * A CharSet defining ASCII alphabetic characters \"A-Z\".\n+     * @since 2.0\n+     */\n+    public static final CharSet ASCII_ALPHA_UPPER = new CharSet(\"A-Z\");\n+\n+    /** \n+     * A CharSet defining ASCII alphabetic characters \"0-9\".\n+     * @since 2.0\n+     */\n+    public static final CharSet ASCII_NUMERIC = new CharSet(\"0-9\");\n+\n+    /**\n+     * A Map of the common cases used in the factory.\n+     * Subclasses can add more common patterns if desired.\n+     * @since 2.0\n+     */\n+    protected static final Map<String, CharSet> COMMON = new HashMap<String, CharSet>();\n+    \n+    static {\n+        COMMON.put(null, EMPTY);\n+        COMMON.put(\"\", EMPTY);\n+        COMMON.put(\"a-zA-Z\", ASCII_ALPHA);\n+        COMMON.put(\"A-Za-z\", ASCII_ALPHA);\n+        COMMON.put(\"a-z\", ASCII_ALPHA_LOWER);\n+        COMMON.put(\"A-Z\", ASCII_ALPHA_UPPER);\n+        COMMON.put(\"0-9\", ASCII_NUMERIC);\n+    }\n+\n+    /** The set of CharRange objects. */\n+    private final Set<CharRange> set = new HashSet<CharRange>();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Factory method to create a new CharSet using a special syntax.</p>\n+     *\n+     * <ul>\n+     *  <li><code>null</code> or empty string (\"\")\n+     * - set containing no characters</li>\n+     *  <li>Single character, such as \"a\"\n+     *  - set containing just that character</li>\n+     *  <li>Multi character, such as \"a-e\"\n+     *  - set containing characters from one character to the other</li>\n+     *  <li>Negated, such as \"^a\" or \"^a-e\"\n+     *  - set containing all characters except those defined</li>\n+     *  <li>Combinations, such as \"abe-g\"\n+     *  - set containing all the characters from the individual sets</li>\n+     * </ul>\n+     *\n+     * <p>The matching order is:</p>\n+     * <ol>\n+     *  <li>Negated multi character range, such as \"^a-e\"\n+     *  <li>Ordinary multi character range, such as \"a-e\"\n+     *  <li>Negated single character, such as \"^a\"\n+     *  <li>Ordinary single character, such as \"a\"\n+     * </ol>\n+     * <p>Matching works left to right. Once a match is found the\n+     * search starts again from the next character.</p>\n+     *\n+     * <p>If the same range is defined twice using the same syntax, only\n+     * one range will be kept.\n+     * Thus, \"a-ca-c\" creates only one range of \"a-c\".</p>\n+     *\n+     * <p>If the start and end of a range are in the wrong order,\n+     * they are reversed. Thus \"a-e\" is the same as \"e-a\".\n+     * As a result, \"a-ee-a\" would create only one range,\n+     * as the \"a-e\" and \"e-a\" are the same.</p>\n+     *\n+     * <p>The set of characters represented is the union of the specified ranges.</p>\n+     *\n+     * <p>All CharSet objects returned by this method will be immutable.</p>\n+     *\n+     * @param setStr  the String describing the set, may be null\n+     * @return a CharSet instance\n+     * @since 2.0\n+     */\n+    public static CharSet getInstance(String setStr) {\n+        Object set = COMMON.get(setStr);\n+        if (set != null) {\n+            return (CharSet) set;\n+        }\n+        return new CharSet(setStr);\n+    }\n+\n+    /**\n+     * <p>Constructs a new CharSet using the set syntax.\n+     * Each string is merged in with the set.</p>\n+     *\n+     * @param setStrs  Strings to merge into the initial set, may be null\n+     * @return a CharSet instance\n+     * @since 2.4\n+     */\n+    public static CharSet getInstance(String[] setStrs) {\n+        if (setStrs == null) {\n+            return null;\n+        }\n+        return new CharSet(setStrs); \n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Constructs a new CharSet using the set syntax.</p>\n+     *\n+     * @param setStr  the String describing the set, may be null\n+     * @since 2.0\n+     */\n+    protected CharSet(String setStr) {\n+        super();\n+        add(setStr);\n+    }\n+\n+    /**\n+     * <p>Constructs a new CharSet using the set syntax.\n+     * Each string is merged in with the set.</p>\n+     *\n+     * @param set  Strings to merge into the initial set\n+     * @throws NullPointerException if set is <code>null</code>\n+     */\n+    protected CharSet(String[] set) {\n+        super();\n+        int sz = set.length;\n+        for (int i = 0; i < sz; i++) {\n+            add(set[i]);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Add a set definition string to the <code>CharSet</code>.</p>\n+     *\n+     * @param str  set definition string\n+     */\n+    protected void add(String str) {\n+        if (str == null) {\n+            return;\n+        }\n+\n+        int len = str.length();\n+        int pos = 0;\n+        while (pos < len) {\n+            int remainder = (len - pos);\n+            if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') {\n+                // negated range\n+                set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3)));\n+                pos += 4;\n+            } else if (remainder >= 3 && str.charAt(pos + 1) == '-') {\n+                // range\n+                set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2)));\n+                pos += 3;\n+            } else if (remainder >= 2 && str.charAt(pos) == '^') {\n+                // negated char\n+                set.add(CharRange.isNot(str.charAt(pos + 1)));\n+                pos += 2;\n+            } else {\n+                // char\n+                set.add(CharRange.is(str.charAt(pos)));\n+                pos += 1;\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the internal set as an array of CharRange objects.</p>\n+     *\n+     * @return an array of immutable CharRange objects\n+     * @since 2.0\n+     */\n+    public CharRange[] getCharRanges() {\n+        return set.toArray(new CharRange[set.size()]);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Does the <code>CharSet</code> contain the specified\n+     * character <code>ch</code>.</p>\n+     *\n+     * @param ch  the character to check for\n+     * @return <code>true</code> if the set contains the characters\n+     */\n+    public boolean contains(char ch) {\n+        for (CharRange range : set) {\n+            if (range.contains(ch)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    // Basics\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compares two CharSet objects, returning true if they represent\n+     * exactly the same set of characters defined in the same way.</p>\n+     *\n+     * <p>The two sets <code>abc</code> and <code>a-c</code> are <i>not</i>\n+     * equal according to this method.</p>\n+     *\n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     * @since 2.0\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof CharSet == false) {\n+            return false;\n+        }\n+        CharSet other = (CharSet) obj;\n+        return set.equals(other.set);\n+    }\n+\n+    /**\n+     * <p>Gets a hashCode compatible with the equals method.</p>\n+     *\n+     * @return a suitable hashCode\n+     * @since 2.0\n+     */\n+    @Override\n+    public int hashCode() {\n+        return 89 + set.hashCode();\n+    }\n+\n+    /**\n+     * <p>Gets a string representation of the set.</p>\n+     *\n+     * @return string representation of the set\n+     */\n+    @Override\n+    public String toString() {\n+        return set.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/CharSetUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+/**\n+ * <p>Operations on <code>CharSet</code>s.</p>\n+ *\n+ * <p>This class handles <code>null</code> input gracefully.\n+ * An exception will not be thrown for a <code>null</code> input.\n+ * Each method documents its behaviour in more detail.</p>\n+ * \n+ * @see CharSet\n+ * @author Apache Software Foundation\n+ * @author Phil Steitz\n+ * @author Gary Gregory\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class CharSetUtils {\n+\n+    /**\n+     * <p>CharSetUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>CharSetUtils.evaluateSet(null);</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public CharSetUtils() {\n+      super();\n+    }\n+\n+    // Squeeze\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Squeezes any repetitions of a character that is mentioned in the\n+     * supplied set.</p>\n+     *\n+     * <pre>\n+     * CharSetUtils.squeeze(null, *)        = null\n+     * CharSetUtils.squeeze(\"\", *)          = \"\"\n+     * CharSetUtils.squeeze(*, null)        = *\n+     * CharSetUtils.squeeze(*, \"\")          = *\n+     * CharSetUtils.squeeze(\"hello\", \"k-p\") = \"helo\"\n+     * CharSetUtils.squeeze(\"hello\", \"a-e\") = \"hello\"\n+     * </pre>\n+     *\n+     * @see CharSet#getInstance(java.lang.String) for set-syntax.\n+     * @param str  the string to squeeze, may be null\n+     * @param set  the character set to use for manipulation, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     */\n+    public static String squeeze(String str, String set) {\n+        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(set)) {\n+            return str;\n+        }\n+        String[] strs = new String[1];\n+        strs[0] = set;\n+        return squeeze(str, strs);\n+    }\n+\n+    /**\n+     * <p>Squeezes any repetitions of a character that is mentioned in the\n+     * supplied set.</p>\n+     *\n+     * <p>An example is:</p>\n+     * <ul>\n+     *   <li>squeeze(&quot;hello&quot;, {&quot;el&quot;}) => &quot;helo&quot;</li>\n+     * </ul>\n+     * \n+     * @see CharSet#getInstance(java.lang.String) for set-syntax.\n+     * @param str  the string to squeeze, may be null\n+     * @param set  the character set to use for manipulation, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     */\n+    public static String squeeze(String str, String[] set) {\n+        if (StringUtils.isEmpty(str) || ArrayUtils.isEmpty(set)) {\n+            return str;\n+        }\n+        CharSet chars = CharSet.getInstance(set);\n+        StringBuilder buffer = new StringBuilder(str.length());\n+        char[] chrs = str.toCharArray();\n+        int sz = chrs.length;\n+        char lastChar = ' ';\n+        char ch = ' ';\n+        for (int i = 0; i < sz; i++) {\n+            ch = chrs[i];\n+            if (chars.contains(ch)) {\n+                if ((ch == lastChar) && (i != 0)) {\n+                    continue;\n+                }\n+            }\n+            buffer.append(ch);\n+            lastChar = ch;\n+        }\n+        return buffer.toString();\n+    }\n+\n+    // Count\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Takes an argument in set-syntax, see evaluateSet,\n+     * and returns the number of characters present in the specified string.</p>\n+     *\n+     * <pre>\n+     * CharSetUtils.count(null, *)        = 0\n+     * CharSetUtils.count(\"\", *)          = 0\n+     * CharSetUtils.count(*, null)        = 0\n+     * CharSetUtils.count(*, \"\")          = 0\n+     * CharSetUtils.count(\"hello\", \"k-p\") = 3\n+     * CharSetUtils.count(\"hello\", \"a-e\") = 1\n+     * </pre>\n+     *\n+     * @see CharSet#getInstance(java.lang.String) for set-syntax.\n+     * @param str  String to count characters in, may be null\n+     * @param set  String set of characters to count, may be null\n+     * @return character count, zero if null string input\n+     */\n+    public static int count(String str, String set) {\n+        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(set)) {\n+            return 0;\n+        }\n+        String[] strs = new String[1];\n+        strs[0] = set;\n+        return count(str, strs);\n+    }\n+    \n+    /**\n+     * <p>Takes an argument in set-syntax, see evaluateSet,\n+     * and returns the number of characters present in the specified string.</p>\n+     *\n+     * <p>An example would be:</p>\n+     * <ul>\n+     *  <li>count(&quot;hello&quot;, {&quot;c-f&quot;, &quot;o&quot;}) returns 2.</li>\n+     * </ul>\n+     *\n+     * @see CharSet#getInstance(java.lang.String) for set-syntax.\n+     * @param str  String to count characters in, may be null\n+     * @param set  String[] set of characters to count, may be null\n+     * @return character count, zero if null string input\n+     */\n+    public static int count(String str, String[] set) {\n+        if (StringUtils.isEmpty(str) || ArrayUtils.isEmpty(set)) {\n+            return 0;\n+        }\n+        CharSet chars = CharSet.getInstance(set);\n+        int count = 0;\n+        char[] chrs = str.toCharArray();\n+        int sz = chrs.length;\n+        for(int i=0; i<sz; i++) {\n+            if(chars.contains(chrs[i])) {\n+                count++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    // Keep\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Takes an argument in set-syntax, see evaluateSet,\n+     * and keeps any of characters present in the specified string.</p>\n+     *\n+     * <pre>\n+     * CharSetUtils.keep(null, *)        = null\n+     * CharSetUtils.keep(\"\", *)          = \"\"\n+     * CharSetUtils.keep(*, null)        = \"\"\n+     * CharSetUtils.keep(*, \"\")          = \"\"\n+     * CharSetUtils.keep(\"hello\", \"hl\")  = \"hll\"\n+     * CharSetUtils.keep(\"hello\", \"le\")  = \"ell\"\n+     * </pre>\n+     *\n+     * @see CharSet#getInstance(java.lang.String) for set-syntax.\n+     * @param str  String to keep characters from, may be null\n+     * @param set  String set of characters to keep, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     * @since 2.0\n+     */\n+    public static String keep(String str, String set) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (str.length() == 0 || StringUtils.isEmpty(set)) {\n+            return \"\";\n+        }\n+        String[] strs = new String[1];\n+        strs[0] = set;\n+        return keep(str, strs);\n+    }\n+    \n+    /**\n+     * <p>Takes an argument in set-syntax, see evaluateSet,\n+     * and keeps any of characters present in the specified string.</p>\n+     *\n+     * <p>An example would be:</p>\n+     * <ul>\n+     *  <li>keep(&quot;hello&quot;, {&quot;c-f&quot;, &quot;o&quot;})\n+     *   returns &quot;eo&quot;</li>\n+     * </ul>\n+     *\n+     * @see CharSet#getInstance(java.lang.String) for set-syntax.\n+     * @param str  String to keep characters from, may be null\n+     * @param set  String[] set of characters to keep, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     * @since 2.0\n+     */\n+    public static String keep(String str, String[] set) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (str.length() == 0 || ArrayUtils.isEmpty(set)) {\n+            return \"\";\n+        }\n+        return modify(str, set, true);\n+    }\n+\n+    // Delete\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Takes an argument in set-syntax, see evaluateSet,\n+     * and deletes any of characters present in the specified string.</p>\n+     *\n+     * <pre>\n+     * CharSetUtils.delete(null, *)        = null\n+     * CharSetUtils.delete(\"\", *)          = \"\"\n+     * CharSetUtils.delete(*, null)        = *\n+     * CharSetUtils.delete(*, \"\")          = *\n+     * CharSetUtils.delete(\"hello\", \"hl\")  = \"eo\"\n+     * CharSetUtils.delete(\"hello\", \"le\")  = \"ho\"\n+     * </pre>\n+     *\n+     * @see CharSet#getInstance(java.lang.String) for set-syntax.\n+     * @param str  String to delete characters from, may be null\n+     * @param set  String set of characters to delete, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     */\n+    public static String delete(String str, String set) {\n+        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(set)) {\n+            return str;\n+        }\n+        String[] strs = new String[1];\n+        strs[0] = set;\n+        return delete(str, strs);\n+    }\n+    \n+    /**\n+     * <p>Takes an argument in set-syntax, see evaluateSet,\n+     * and deletes any of characters present in the specified string.</p>\n+     *\n+     * <p>An example would be:</p>\n+     * <ul>\n+     *  <li>delete(&quot;hello&quot;, {&quot;c-f&quot;, &quot;o&quot;}) returns\n+     *   &quot;hll&quot;</li>\n+     * </ul>\n+     *\n+     * @see CharSet#getInstance(java.lang.String) for set-syntax.\n+     * @param str  String to delete characters from, may be null\n+     * @param set  String[] set of characters to delete, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     */\n+    public static String delete(String str, String[] set) {\n+        if (StringUtils.isEmpty(str) || ArrayUtils.isEmpty(set)) {\n+            return str;\n+        }\n+        return modify(str, set, false);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implementation of delete and keep\n+     *\n+     * @param str String to modify characters within\n+     * @param set String[] set of characters to modify\n+     * @param expect whether to evaluate on match, or non-match\n+     * @return modified String\n+     */\n+    private static String modify(String str, String[] set, boolean expect) {\n+        CharSet chars = CharSet.getInstance(set);\n+        StringBuilder buffer = new StringBuilder(str.length());\n+        char[] chrs = str.toCharArray();\n+        int sz = chrs.length;\n+        for(int i=0; i<sz; i++) {\n+            if(chars.contains(chrs[i]) == expect) {\n+                buffer.append(chrs[i]);\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/CharUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+/**\n+ * <p>Operations on char primitives and Character objects.</p>\n+ *\n+ * <p>This class tries to handle <code>null</code> input gracefully.\n+ * An exception will not be thrown for a <code>null</code> input.\n+ * Each method documents its behaviour in more detail.</p>\n+ * \n+ * @author Apache Software Foundation\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class CharUtils {\n+    \n+    private static final String CHAR_STRING = \n+        \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\" +\n+        \"\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\" +\n+        \"\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\" +\n+        \"\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\" +\n+        \"\\u0020\\u0021\\\"\\u0023\\u0024\\u0025\\u0026\\u0027\" +\n+        \"\\u0028\\u0029\\u002a\\u002b\\u002c\\u002d\\u002e\\u002f\" +\n+        \"\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\" +\n+        \"\\u0038\\u0039\\u003a\\u003b\\u003c\\u003d\\u003e\\u003f\" +\n+        \"\\u0040\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\" +\n+        \"\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\" +\n+        \"\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\" +\n+        \"\\u0058\\u0059\\u005a\\u005b\\\\\\u005d\\u005e\\u005f\" +\n+        \"\\u0060\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\" +\n+        \"\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\" +\n+        \"\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\" +\n+        \"\\u0078\\u0079\\u007a\\u007b\\u007c\\u007d\\u007e\\u007f\";\n+    \n+    private static final String[] CHAR_STRING_ARRAY = new String[128];\n+    private static final Character[] CHAR_ARRAY = new Character[128];\n+    \n+    /**\n+     * <code>\\u000a</code> linefeed LF ('\\n').\n+     * \n+     * @see <a href=\"http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#101089\">JLF: Escape Sequences\n+     *      for Character and String Literals</a>\n+     * @since 2.2\n+     */\n+    public static final char LF = '\\n';\n+\n+    /**\n+     * <code>\\u000d</code> carriage return CR ('\\r').\n+     * \n+     * @see <a href=\"http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#101089\">JLF: Escape Sequences\n+     *      for Character and String Literals</a>\n+     * @since 2.2\n+     */\n+    public static final char CR = '\\r';\n+    \n+\n+    static {\n+        for (int i = 127; i >= 0; i--) {\n+            CHAR_STRING_ARRAY[i] = CHAR_STRING.substring(i, i + 1);\n+            CHAR_ARRAY[i] = new Character((char) i);\n+        }\n+    }\n+\n+    /**\n+     * <p><code>CharUtils</code> instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>CharUtils.toString('c');</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public CharUtils() {\n+      super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts the character to a Character.</p>\n+     * \n+     * <p>For ASCII 7 bit characters, this uses a cache that will return the\n+     * same Character object each time.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toCharacterObject(' ')  = ' '\n+     *   CharUtils.toCharacterObject('A')  = 'A'\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @return a Character of the specified character\n+     */\n+    public static Character toCharacterObject(char ch) {\n+        if (ch < CHAR_ARRAY.length) {\n+            return CHAR_ARRAY[ch];\n+        }\n+        return new Character(ch);\n+    }\n+    \n+    /**\n+     * <p>Converts the String to a Character using the first character, returning\n+     * null for empty Strings.</p>\n+     * \n+     * <p>For ASCII 7 bit characters, this uses a cache that will return the\n+     * same Character object each time.</p>\n+     * \n+     * <pre>\n+     *   CharUtils.toCharacterObject(null) = null\n+     *   CharUtils.toCharacterObject(\"\")   = null\n+     *   CharUtils.toCharacterObject(\"A\")  = 'A'\n+     *   CharUtils.toCharacterObject(\"BA\") = 'B'\n+     * </pre>\n+     *\n+     * @param str  the character to convert\n+     * @return the Character value of the first letter of the String\n+     */\n+    public static Character toCharacterObject(String str) {\n+        if (StringUtils.isEmpty(str)) {\n+            return null;\n+        }\n+        return toCharacterObject(str.charAt(0));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts the Character to a char throwing an exception for <code>null</code>.</p>\n+     * \n+     * <pre>\n+     *   CharUtils.toChar(null) = IllegalArgumentException\n+     *   CharUtils.toChar(' ')  = ' '\n+     *   CharUtils.toChar('A')  = 'A'\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @return the char value of the Character\n+     * @throws IllegalArgumentException if the Character is null\n+     */\n+    public static char toChar(Character ch) {\n+        if (ch == null) {\n+            throw new IllegalArgumentException(\"The Character must not be null\");\n+        }\n+        return ch.charValue();\n+    }\n+    \n+    /**\n+     * <p>Converts the Character to a char handling <code>null</code>.</p>\n+     * \n+     * <pre>\n+     *   CharUtils.toChar(null, 'X') = 'X'\n+     *   CharUtils.toChar(' ', 'X')  = ' '\n+     *   CharUtils.toChar('A', 'X')  = 'A'\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @param defaultValue  the value to use if the  Character is null\n+     * @return the char value of the Character or the default if null\n+     */\n+    public static char toChar(Character ch, char defaultValue) {\n+        if (ch == null) {\n+            return defaultValue;\n+        }\n+        return ch.charValue();\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts the String to a char using the first character, throwing\n+     * an exception on empty Strings.</p>\n+     * \n+     * <pre>\n+     *   CharUtils.toChar(null) = IllegalArgumentException\n+     *   CharUtils.toChar(\"\")   = IllegalArgumentException\n+     *   CharUtils.toChar(\"A\")  = 'A'\n+     *   CharUtils.toChar(\"BA\") = 'B'\n+     * </pre>\n+     *\n+     * @param str  the character to convert\n+     * @return the char value of the first letter of the String\n+     * @throws IllegalArgumentException if the String is empty\n+     */\n+    public static char toChar(String str) {\n+        if (StringUtils.isEmpty(str)) {\n+            throw new IllegalArgumentException(\"The String must not be empty\");\n+        }\n+        return str.charAt(0);\n+    }\n+    \n+    /**\n+     * <p>Converts the String to a char using the first character, defaulting\n+     * the value on empty Strings.</p>\n+     * \n+     * <pre>\n+     *   CharUtils.toChar(null, 'X') = 'X'\n+     *   CharUtils.toChar(\"\", 'X')   = 'X'\n+     *   CharUtils.toChar(\"A\", 'X')  = 'A'\n+     *   CharUtils.toChar(\"BA\", 'X') = 'B'\n+     * </pre>\n+     *\n+     * @param str  the character to convert\n+     * @param defaultValue  the value to use if the  Character is null\n+     * @return the char value of the first letter of the String or the default if null\n+     */\n+    public static char toChar(String str, char defaultValue) {\n+        if (StringUtils.isEmpty(str)) {\n+            return defaultValue;\n+        }\n+        return str.charAt(0);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts the character to the Integer it represents, throwing an\n+     * exception if the character is not numeric.</p>\n+     * \n+     * <p>This method coverts the char '1' to the int 1 and so on.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toIntValue('3')  = 3\n+     *   CharUtils.toIntValue('A')  = IllegalArgumentException\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @return the int value of the character\n+     * @throws IllegalArgumentException if the character is not ASCII numeric\n+     */\n+    public static int toIntValue(char ch) {\n+        if (isAsciiNumeric(ch) == false) {\n+            throw new IllegalArgumentException(\"The character \" + ch + \" is not in the range '0' - '9'\");\n+        }\n+        return ch - 48;\n+    }\n+    \n+    /**\n+     * <p>Converts the character to the Integer it represents, throwing an\n+     * exception if the character is not numeric.</p>\n+     * \n+     * <p>This method coverts the char '1' to the int 1 and so on.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toIntValue('3', -1)  = 3\n+     *   CharUtils.toIntValue('A', -1)  = -1\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @param defaultValue  the default value to use if the character is not numeric\n+     * @return the int value of the character\n+     */\n+    public static int toIntValue(char ch, int defaultValue) {\n+        if (isAsciiNumeric(ch) == false) {\n+            return defaultValue;\n+        }\n+        return ch - 48;\n+    }\n+    \n+    /**\n+     * <p>Converts the character to the Integer it represents, throwing an\n+     * exception if the character is not numeric.</p>\n+     * \n+     * <p>This method coverts the char '1' to the int 1 and so on.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toIntValue(null) = IllegalArgumentException\n+     *   CharUtils.toIntValue('3')  = 3\n+     *   CharUtils.toIntValue('A')  = IllegalArgumentException\n+     * </pre>\n+     *\n+     * @param ch  the character to convert, not null\n+     * @return the int value of the character\n+     * @throws IllegalArgumentException if the Character is not ASCII numeric or is null\n+     */\n+    public static int toIntValue(Character ch) {\n+        if (ch == null) {\n+            throw new IllegalArgumentException(\"The character must not be null\");\n+        }\n+        return toIntValue(ch.charValue());\n+    }\n+    \n+    /**\n+     * <p>Converts the character to the Integer it represents, throwing an\n+     * exception if the character is not numeric.</p>\n+     * \n+     * <p>This method coverts the char '1' to the int 1 and so on.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toIntValue(null, -1) = -1\n+     *   CharUtils.toIntValue('3', -1)  = 3\n+     *   CharUtils.toIntValue('A', -1)  = -1\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @param defaultValue  the default value to use if the character is not numeric\n+     * @return the int value of the character\n+     */\n+    public static int toIntValue(Character ch, int defaultValue) {\n+        if (ch == null) {\n+            return defaultValue;\n+        }\n+        return toIntValue(ch.charValue(), defaultValue);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts the character to a String that contains the one character.</p>\n+     * \n+     * <p>For ASCII 7 bit characters, this uses a cache that will return the\n+     * same String object each time.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toString(' ')  = \" \"\n+     *   CharUtils.toString('A')  = \"A\"\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @return a String containing the one specified character\n+     */\n+    public static String toString(char ch) {\n+        if (ch < 128) {\n+            return CHAR_STRING_ARRAY[ch];\n+        }\n+        return new String(new char[] {ch});\n+    }\n+    \n+    /**\n+     * <p>Converts the character to a String that contains the one character.</p>\n+     * \n+     * <p>For ASCII 7 bit characters, this uses a cache that will return the\n+     * same String object each time.</p>\n+     * \n+     * <p>If <code>null</code> is passed in, <code>null</code> will be returned.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toString(null) = null\n+     *   CharUtils.toString(' ')  = \" \"\n+     *   CharUtils.toString('A')  = \"A\"\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @return a String containing the one specified character\n+     */\n+    public static String toString(Character ch) {\n+        if (ch == null) {\n+            return null;\n+        }\n+        return toString(ch.charValue());\n+    }\n+    \n+    //--------------------------------------------------------------------------\n+    /**\n+     * <p>Converts the string to the unicode format '\\u0020'.</p>\n+     * \n+     * <p>This format is the Java source code format.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.unicodeEscaped(' ') = \"\\u0020\"\n+     *   CharUtils.unicodeEscaped('A') = \"\\u0041\"\n+     * </pre>\n+     * \n+     * @param ch  the character to convert\n+     * @return the escaped unicode string\n+     */\n+    public static String unicodeEscaped(char ch) {\n+        if (ch < 0x10) {\n+            return \"\\\\u000\" + Integer.toHexString(ch);\n+        } else if (ch < 0x100) {\n+            return \"\\\\u00\" + Integer.toHexString(ch);\n+        } else if (ch < 0x1000) {\n+            return \"\\\\u0\" + Integer.toHexString(ch);\n+        }\n+        return \"\\\\u\" + Integer.toHexString(ch);\n+    }\n+    \n+    /**\n+     * <p>Converts the string to the unicode format '\\u0020'.</p>\n+     * \n+     * <p>This format is the Java source code format.</p>\n+     * \n+     * <p>If <code>null</code> is passed in, <code>null</code> will be returned.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.unicodeEscaped(null) = null\n+     *   CharUtils.unicodeEscaped(' ')  = \"\\u0020\"\n+     *   CharUtils.unicodeEscaped('A')  = \"\\u0041\"\n+     * </pre>\n+     * \n+     * @param ch  the character to convert, may be null\n+     * @return the escaped unicode string, null if null input\n+     */\n+    public static String unicodeEscaped(Character ch) {\n+        if (ch == null) {\n+            return null;\n+        }\n+        return unicodeEscaped(ch.charValue());\n+    }\n+    \n+    //--------------------------------------------------------------------------\n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAscii('a')  = true\n+     *   CharUtils.isAscii('A')  = true\n+     *   CharUtils.isAscii('3')  = true\n+     *   CharUtils.isAscii('-')  = true\n+     *   CharUtils.isAscii('\\n') = true\n+     *   CharUtils.isAscii('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if less than 128\n+     */\n+    public static boolean isAscii(char ch) {\n+        return ch < 128;\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit printable.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiPrintable('a')  = true\n+     *   CharUtils.isAsciiPrintable('A')  = true\n+     *   CharUtils.isAsciiPrintable('3')  = true\n+     *   CharUtils.isAsciiPrintable('-')  = true\n+     *   CharUtils.isAsciiPrintable('\\n') = false\n+     *   CharUtils.isAsciiPrintable('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if between 32 and 126 inclusive\n+     */\n+    public static boolean isAsciiPrintable(char ch) {\n+        return ch >= 32 && ch < 127;\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit control.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiControl('a')  = false\n+     *   CharUtils.isAsciiControl('A')  = false\n+     *   CharUtils.isAsciiControl('3')  = false\n+     *   CharUtils.isAsciiControl('-')  = false\n+     *   CharUtils.isAsciiControl('\\n') = true\n+     *   CharUtils.isAsciiControl('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if less than 32 or equals 127\n+     */\n+    public static boolean isAsciiControl(char ch) {\n+        return ch < 32 || ch == 127;\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit alphabetic.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiAlpha('a')  = true\n+     *   CharUtils.isAsciiAlpha('A')  = true\n+     *   CharUtils.isAsciiAlpha('3')  = false\n+     *   CharUtils.isAsciiAlpha('-')  = false\n+     *   CharUtils.isAsciiAlpha('\\n') = false\n+     *   CharUtils.isAsciiAlpha('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if between 65 and 90 or 97 and 122 inclusive\n+     */\n+    public static boolean isAsciiAlpha(char ch) {\n+        return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit alphabetic upper case.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiAlphaUpper('a')  = false\n+     *   CharUtils.isAsciiAlphaUpper('A')  = true\n+     *   CharUtils.isAsciiAlphaUpper('3')  = false\n+     *   CharUtils.isAsciiAlphaUpper('-')  = false\n+     *   CharUtils.isAsciiAlphaUpper('\\n') = false\n+     *   CharUtils.isAsciiAlphaUpper('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if between 65 and 90 inclusive\n+     */\n+    public static boolean isAsciiAlphaUpper(char ch) {\n+        return ch >= 'A' && ch <= 'Z';\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit alphabetic lower case.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiAlphaLower('a')  = true\n+     *   CharUtils.isAsciiAlphaLower('A')  = false\n+     *   CharUtils.isAsciiAlphaLower('3')  = false\n+     *   CharUtils.isAsciiAlphaLower('-')  = false\n+     *   CharUtils.isAsciiAlphaLower('\\n') = false\n+     *   CharUtils.isAsciiAlphaLower('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if between 97 and 122 inclusive\n+     */\n+    public static boolean isAsciiAlphaLower(char ch) {\n+        return ch >= 'a' && ch <= 'z';\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit numeric.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiNumeric('a')  = false\n+     *   CharUtils.isAsciiNumeric('A')  = false\n+     *   CharUtils.isAsciiNumeric('3')  = true\n+     *   CharUtils.isAsciiNumeric('-')  = false\n+     *   CharUtils.isAsciiNumeric('\\n') = false\n+     *   CharUtils.isAsciiNumeric('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if between 48 and 57 inclusive\n+     */\n+    public static boolean isAsciiNumeric(char ch) {\n+        return ch >= '0' && ch <= '9';\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit numeric.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiAlphanumeric('a')  = true\n+     *   CharUtils.isAsciiAlphanumeric('A')  = true\n+     *   CharUtils.isAsciiAlphanumeric('3')  = true\n+     *   CharUtils.isAsciiAlphanumeric('-')  = false\n+     *   CharUtils.isAsciiAlphanumeric('\\n') = false\n+     *   CharUtils.isAsciiAlphanumeric('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if between 48 and 57 or 65 and 90 or 97 and 122 inclusive\n+     */\n+    public static boolean isAsciiAlphanumeric(char ch) {\n+        return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9');\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/ClassUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * <p>Operates on classes without using reflection.</p>\n+ *\n+ * <p>This class handles invalid <code>null</code> inputs as best it can.\n+ * Each method documents its behaviour in more detail.</p>\n+ *\n+ * <p>The notion of a <code>canonical name</code> includes the human\n+ * readable name for the type, for example <code>int[]</code>. The\n+ * non-canonical method variants work with the JVM names, such as\n+ * <code>[I</code>. </p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Gary Gregory\n+ * @author Norm Deane\n+ * @author Alban Peignier\n+ * @author Tomasz Blachowicz\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class ClassUtils {\n+\n+    /**\n+     * <p>The package separator character: <code>'&#x2e;' == {@value}</code>.</p>\n+     */\n+    public static final char PACKAGE_SEPARATOR_CHAR = '.';\n+\n+    /**\n+     * <p>The package separator String: <code>\"&#x2e;\"</code>.</p>\n+     */\n+    public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR);\n+\n+    /**\n+     * <p>The inner class separator character: <code>'$' == {@value}</code>.</p>\n+     */\n+    public static final char INNER_CLASS_SEPARATOR_CHAR = '$';\n+\n+    /**\n+     * <p>The inner class separator String: <code>\"$\"</code>.</p>\n+     */\n+    public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR);\n+\n+    /**\n+     * Maps primitive <code>Class</code>es to their corresponding wrapper <code>Class</code>.\n+     */\n+    private static final Map<Class<?>, Class<?>> primitiveWrapperMap = new HashMap<Class<?>, Class<?>>();\n+    static {\n+         primitiveWrapperMap.put(Boolean.TYPE, Boolean.class);\n+         primitiveWrapperMap.put(Byte.TYPE, Byte.class);\n+         primitiveWrapperMap.put(Character.TYPE, Character.class);\n+         primitiveWrapperMap.put(Short.TYPE, Short.class);\n+         primitiveWrapperMap.put(Integer.TYPE, Integer.class);\n+         primitiveWrapperMap.put(Long.TYPE, Long.class);\n+         primitiveWrapperMap.put(Double.TYPE, Double.class);\n+         primitiveWrapperMap.put(Float.TYPE, Float.class);\n+         primitiveWrapperMap.put(Void.TYPE, Void.TYPE);\n+    }\n+\n+    /**\n+     * Maps wrapper <code>Class</code>es to their corresponding primitive types.\n+     */\n+    private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>();\n+    static {\n+        for (Class<?> primitiveClass : primitiveWrapperMap.keySet()) {\n+            Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass);\n+            if (!primitiveClass.equals(wrapperClass)) {\n+                wrapperPrimitiveMap.put(wrapperClass, primitiveClass);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Maps a primitive class name to its corresponding abbreviation used in array class names.\n+     */\n+    private static final Map<String, String> abbreviationMap = new HashMap<String, String>();\n+\n+    /**\n+     * Maps an abbreviation used in array class names to corresponding primitive class name.\n+     */\n+    private static final Map<String, String> reverseAbbreviationMap = new HashMap<String, String>();\n+\n+    /**\n+     * Add primitive type abbreviation to maps of abbreviations.\n+     *\n+     * @param primitive Canonical name of primitive type\n+     * @param abbreviation Corresponding abbreviation of primitive type\n+     */\n+    private static void addAbbreviation(String primitive, String abbreviation) {\n+        abbreviationMap.put(primitive, abbreviation);\n+        reverseAbbreviationMap.put(abbreviation, primitive);\n+    }\n+\n+    /**\n+     * Feed abbreviation maps\n+     */\n+    static {\n+        addAbbreviation(\"int\", \"I\");\n+        addAbbreviation(\"boolean\", \"Z\");\n+        addAbbreviation(\"float\", \"F\");\n+        addAbbreviation(\"long\", \"J\");\n+        addAbbreviation(\"short\", \"S\");\n+        addAbbreviation(\"byte\", \"B\");\n+        addAbbreviation(\"double\", \"D\");\n+        addAbbreviation(\"char\", \"C\");\n+    }\n+\n+    /**\n+     * <p>ClassUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as\n+     * <code>ClassUtils.getShortClassName(cls)</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public ClassUtils() {\n+      super();\n+    }\n+\n+    // Short class name\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the class name minus the package name for an <code>Object</code>.</p>\n+     *\n+     * @param object  the class to get the short name for, may be null\n+     * @param valueIfNull  the value to return if null\n+     * @return the class name of the object without the package name, or the null value\n+     */\n+    public static String getShortClassName(Object object, String valueIfNull) {\n+        if (object == null) {\n+            return valueIfNull;\n+        }\n+        return getShortClassName(object.getClass());\n+    }\n+\n+    /**\n+     * <p>Gets the class name minus the package name from a <code>Class</code>.</p>\n+     *\n+     * @param cls  the class to get the short name for.\n+     * @return the class name without the package name or an empty string\n+     */\n+    public static String getShortClassName(Class<?> cls) {\n+        if (cls == null) {\n+            return StringUtils.EMPTY;\n+        }\n+        return getShortClassName(cls.getName());\n+    }\n+\n+    /**\n+     * <p>Gets the class name minus the package name from a String.</p>\n+     *\n+     * <p>The string passed in is assumed to be a class name - it is not checked.</p>\n+     *\n+     * @param className  the className to get the short name for\n+     * @return the class name of the class without the package name or an empty string\n+     */\n+    public static String getShortClassName(String className) {\n+        if (className == null) {\n+            return StringUtils.EMPTY;\n+        }\n+        if (className.length() == 0) {\n+            return StringUtils.EMPTY;\n+        }\n+\n+        StringBuilder arrayPrefix = new StringBuilder();\n+\n+        // Handle array encoding\n+        if (className.startsWith(\"[\")) {\n+            while (className.charAt(0) == '[') {\n+                className = className.substring(1);\n+                arrayPrefix.append(\"[]\");\n+            }\n+            // Strip Object type encoding\n+            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n+                className = className.substring(1, className.length() - 1);\n+            }\n+        }\n+\n+        if (reverseAbbreviationMap.containsKey(className)) {\n+            className = reverseAbbreviationMap.get(className);\n+        }\n+\n+        int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n+        int innerIdx = className.indexOf(\n+                INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n+        String out = className.substring(lastDotIdx + 1);\n+        if (innerIdx != -1) {\n+            out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n+        }\n+        return out + arrayPrefix;\n+    }\n+\n+    // Package name\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the package name of an <code>Object</code>.</p>\n+     *\n+     * @param object  the class to get the package name for, may be null\n+     * @param valueIfNull  the value to return if null\n+     * @return the package name of the object, or the null value\n+     */\n+    public static String getPackageName(Object object, String valueIfNull) {\n+        if (object == null) {\n+            return valueIfNull;\n+        }\n+        return getPackageName(object.getClass());\n+    }\n+\n+    /**\n+     * <p>Gets the package name of a <code>Class</code>.</p>\n+     *\n+     * @param cls  the class to get the package name for, may be <code>null</code>.\n+     * @return the package name or an empty string\n+     */\n+    public static String getPackageName(Class<?> cls) {\n+        if (cls == null) {\n+            return StringUtils.EMPTY;\n+        }\n+        return getPackageName(cls.getName());\n+    }\n+\n+    /**\n+     * <p>Gets the package name from a <code>String</code>.</p>\n+     *\n+     * <p>The string passed in is assumed to be a class name - it is not checked.</p>\n+     * <p>If the class is unpackaged, return an empty string.</p>\n+     *\n+     * @param className  the className to get the package name for, may be <code>null</code>\n+     * @return the package name or an empty string\n+     */\n+    public static String getPackageName(String className) {\n+        if (className == null || className.length() == 0) {\n+            return StringUtils.EMPTY;\n+        }\n+\n+        // Strip array encoding\n+        while (className.charAt(0) == '[') {\n+            className = className.substring(1);\n+        }\n+        // Strip Object type encoding\n+        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n+            className = className.substring(1);\n+        }\n+\n+        int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n+        if (i == -1) {\n+            return StringUtils.EMPTY;\n+        }\n+        return className.substring(0, i);\n+    }\n+\n+    // Superclasses/Superinterfaces\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a <code>List</code> of superclasses for the given class.</p>\n+     *\n+     * @param cls  the class to look up, may be <code>null</code>\n+     * @return the <code>List</code> of superclasses in order going up from this one\n+     *  <code>null</code> if null input\n+     */\n+    public static List<Class<?>> getAllSuperclasses(Class<?> cls) {\n+        if (cls == null) {\n+            return null;\n+        }\n+        List<Class<?>> classes = new ArrayList<Class<?>>();\n+        Class<?> superclass = cls.getSuperclass();\n+        while (superclass != null) {\n+            classes.add(superclass);\n+            superclass = superclass.getSuperclass();\n+        }\n+        return classes;\n+    }\n+\n+    /**\n+     * <p>Gets a <code>List</code> of all interfaces implemented by the given\n+     * class and its superclasses.</p>\n+     *\n+     * <p>The order is determined by looking through each interface in turn as\n+     * declared in the source file and following its hierarchy up. Then each\n+     * superclass is considered in the same way. Later duplicates are ignored,\n+     * so the order is maintained.</p>\n+     *\n+     * @param cls  the class to look up, may be <code>null</code>\n+     * @return the <code>List</code> of interfaces in order,\n+     *  <code>null</code> if null input\n+     */\n+    public static List<Class<?>> getAllInterfaces(Class<?> cls) {\n+        if (cls == null) {\n+            return null;\n+        }\n+\n+        LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>();\n+        getAllInterfaces(cls, interfacesFound);\n+\n+        return new ArrayList<Class<?>>(interfacesFound);\n+    }\n+\n+    private static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound) {\n+        while (cls != null) {\n+            Class<?>[] interfaces = cls.getInterfaces();\n+\n+            for (Class<?> i : interfaces) {\n+                if (interfacesFound.add(i)) {\n+                    getAllInterfaces(i, interfacesFound);\n+                }\n+            }\n+\n+            cls = cls.getSuperclass();\n+         }\n+     }\n+\n+    // Convert list\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Given a <code>List</code> of class names, this method converts them into classes.</p>\n+     *\n+     * <p>A new <code>List</code> is returned. If the class name cannot be found, <code>null</code>\n+     * is stored in the <code>List</code>. If the class name in the <code>List</code> is\n+     * <code>null</code>, <code>null</code> is stored in the output <code>List</code>.</p>\n+     *\n+     * @param classNames  the classNames to change\n+     * @return a <code>List</code> of Class objects corresponding to the class names,\n+     *  <code>null</code> if null input\n+     * @throws ClassCastException if classNames contains a non String entry\n+     */\n+    public static List<Class<?>> convertClassNamesToClasses(List<String> classNames) {\n+        if (classNames == null) {\n+            return null;\n+        }\n+        List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size());\n+        for (String className : classNames) {\n+            try {\n+                classes.add(Class.forName(className));\n+            } catch (Exception ex) {\n+                classes.add(null);\n+            }\n+        }\n+        return classes;\n+    }\n+\n+    /**\n+     * <p>Given a <code>List</code> of <code>Class</code> objects, this method converts\n+     * them into class names.</p>\n+     *\n+     * <p>A new <code>List</code> is returned. <code>null</code> objects will be copied into\n+     * the returned list as <code>null</code>.</p>\n+     *\n+     * @param classes  the classes to change\n+     * @return a <code>List</code> of class names corresponding to the Class objects,\n+     *  <code>null</code> if null input\n+     * @throws ClassCastException if <code>classes</code> contains a non-<code>Class</code> entry\n+     */\n+    public static List<String> convertClassesToClassNames(List<Class<?>> classes) {\n+        if (classes == null) {\n+            return null;\n+        }\n+        List<String> classNames = new ArrayList<String>(classes.size());\n+        for (Class<?> cls : classes) {\n+            if (cls == null) {\n+                classNames.add(null);\n+            } else {\n+                classNames.add(cls.getName());\n+            }\n+        }\n+        return classNames;\n+    }\n+\n+    // Is assignable\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>\n+     *\n+     * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each\n+     * Class pair in the input arrays. It can be used to check if a set of arguments\n+     * (the first parameter) are suitably compatible with a set of method parameter types\n+     * (the second parameter).</p>\n+     *\n+     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this\n+     * method takes into account widenings of primitive classes and\n+     * <code>null</code>s.</p>\n+     *\n+     * <p>Primitive widenings allow an int to be assigned to a <code>long</code>,\n+     * <code>float</code> or <code>double</code>. This method returns the correct\n+     * result for these cases.</p>\n+     *\n+     * <p><code>Null</code> may be assigned to any reference type. This method will\n+     * return <code>true</code> if <code>null</code> is passed in and the toClass is\n+     * non-primitive.</p>\n+     *\n+     * <p>Specifically, this method tests whether the type represented by the\n+     * specified <code>Class</code> parameter can be converted to the type\n+     * represented by this <code>Class</code> object via an identity conversion\n+     * widening primitive or widening reference conversion. See\n+     * <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java Language Specification</a></em>,\n+     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>\n+     *\n+     * @param classArray  the array of Classes to check, may be <code>null</code>\n+     * @param toClassArray  the array of Classes to try to assign into, may be <code>null</code>\n+     * @return <code>true</code> if assignment possible\n+     */\n+    //TODO when we bump the major version we should default autoboxing to true on platforms >= 1.5\n+    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray) {\n+        return isAssignable(classArray, toClassArray, false);\n+    }\n+\n+    /**\n+     * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>\n+     *\n+     * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each\n+     * Class pair in the input arrays. It can be used to check if a set of arguments\n+     * (the first parameter) are suitably compatible with a set of method parameter types\n+     * (the second parameter).</p>\n+     *\n+     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this\n+     * method takes into account widenings of primitive classes and\n+     * <code>null</code>s.</p>\n+     *\n+     * <p>Primitive widenings allow an int to be assigned to a <code>long</code>,\n+     * <code>float</code> or <code>double</code>. This method returns the correct\n+     * result for these cases.</p>\n+     *\n+     * <p><code>Null</code> may be assigned to any reference type. This method will\n+     * return <code>true</code> if <code>null</code> is passed in and the toClass is\n+     * non-primitive.</p>\n+     *\n+     * <p>Specifically, this method tests whether the type represented by the\n+     * specified <code>Class</code> parameter can be converted to the type\n+     * represented by this <code>Class</code> object via an identity conversion\n+     * widening primitive or widening reference conversion. See\n+     * <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java Language Specification</a></em>,\n+     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>\n+     *\n+     * @param classArray  the array of Classes to check, may be <code>null</code>\n+     * @param toClassArray  the array of Classes to try to assign into, may be <code>null</code>\n+     * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers\n+     * @return <code>true</code> if assignment possible\n+     */\n+    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {\n+        if (ArrayUtils.isSameLength(classArray, toClassArray) == false) {\n+            return false;\n+        }\n+        if (classArray == null) {\n+            classArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        if (toClassArray == null) {\n+            toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        for (int i = 0; i < classArray.length; i++) {\n+            if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if one <code>Class</code> can be assigned to a variable of\n+     * another <code>Class</code>.</p>\n+     *\n+     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,\n+     * this method takes into account widenings of primitive classes and\n+     * <code>null</code>s.</p>\n+     *\n+     * <p>Primitive widenings allow an int to be assigned to a long, float or\n+     * double. This method returns the correct result for these cases.</p>\n+     *\n+     * <p><code>Null</code> may be assigned to any reference type. This method\n+     * will return <code>true</code> if <code>null</code> is passed in and the\n+     * toClass is non-primitive.</p>\n+     *\n+     * <p>Specifically, this method tests whether the type represented by the\n+     * specified <code>Class</code> parameter can be converted to the type\n+     * represented by this <code>Class</code> object via an identity conversion\n+     * widening primitive or widening reference conversion. See\n+     * <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java Language Specification</a></em>,\n+     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>\n+     *\n+     * @param cls  the Class to check, may be null\n+     * @param toClass  the Class to try to assign into, returns false if null\n+     * @return <code>true</code> if assignment possible\n+     */\n+    //TODO when we bump the major version we should default autoboxing to true on platforms >= 1.5\n+    public static boolean isAssignable(Class<?> cls, Class<?> toClass) {\n+        return isAssignable(cls, toClass, false);\n+    }\n+\n+    /**\n+     * <p>Checks if one <code>Class</code> can be assigned to a variable of\n+     * another <code>Class</code>.</p>\n+     *\n+     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,\n+     * this method takes into account widenings of primitive classes and\n+     * <code>null</code>s.</p>\n+     *\n+     * <p>Primitive widenings allow an int to be assigned to a long, float or\n+     * double. This method returns the correct result for these cases.</p>\n+     *\n+     * <p><code>Null</code> may be assigned to any reference type. This method\n+     * will return <code>true</code> if <code>null</code> is passed in and the\n+     * toClass is non-primitive.</p>\n+     *\n+     * <p>Specifically, this method tests whether the type represented by the\n+     * specified <code>Class</code> parameter can be converted to the type\n+     * represented by this <code>Class</code> object via an identity conversion\n+     * widening primitive or widening reference conversion. See\n+     * <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java Language Specification</a></em>,\n+     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>\n+     *\n+     * @param cls  the Class to check, may be null\n+     * @param toClass  the Class to try to assign into, returns false if null\n+     * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers\n+     * @return <code>true</code> if assignment possible\n+     */\n+    public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {\n+        if (toClass == null) {\n+            return false;\n+        }\n+        // have to check for null, as isAssignableFrom doesn't\n+        if (cls == null) {\n+            return !(toClass.isPrimitive());\n+        }\n+        //autoboxing:\n+        if (autoboxing) {\n+            if (cls.isPrimitive() && !toClass.isPrimitive()) {\n+                cls = primitiveToWrapper(cls);\n+                if (cls == null) {\n+                    return false;\n+                }\n+            }\n+            if (toClass.isPrimitive() && !cls.isPrimitive()) {\n+                cls = wrapperToPrimitive(cls);\n+                if (cls == null) {\n+                    return false;\n+                }\n+            }\n+        }\n+        if (cls.equals(toClass)) {\n+            return true;\n+        }\n+        if (cls.isPrimitive()) {\n+            if (toClass.isPrimitive() == false) {\n+                return false;\n+            }\n+            if (Integer.TYPE.equals(cls)) {\n+                return Long.TYPE.equals(toClass)\n+                    || Float.TYPE.equals(toClass)\n+                    || Double.TYPE.equals(toClass);\n+            }\n+            if (Long.TYPE.equals(cls)) {\n+                return Float.TYPE.equals(toClass)\n+                    || Double.TYPE.equals(toClass);\n+            }\n+            if (Boolean.TYPE.equals(cls)) {\n+                return false;\n+            }\n+            if (Double.TYPE.equals(cls)) {\n+                return false;\n+            }\n+            if (Float.TYPE.equals(cls)) {\n+                return Double.TYPE.equals(toClass);\n+            }\n+            if (Character.TYPE.equals(cls)) {\n+                return Integer.TYPE.equals(toClass)\n+                    || Long.TYPE.equals(toClass)\n+                    || Float.TYPE.equals(toClass)\n+                    || Double.TYPE.equals(toClass);\n+            }\n+            if (Short.TYPE.equals(cls)) {\n+                return Integer.TYPE.equals(toClass)\n+                    || Long.TYPE.equals(toClass)\n+                    || Float.TYPE.equals(toClass)\n+                    || Double.TYPE.equals(toClass);\n+            }\n+            if (Byte.TYPE.equals(cls)) {\n+                return Short.TYPE.equals(toClass)\n+                    || Integer.TYPE.equals(toClass)\n+                    || Long.TYPE.equals(toClass)\n+                    || Float.TYPE.equals(toClass)\n+                    || Double.TYPE.equals(toClass);\n+            }\n+            // should never get here\n+            return false;\n+        }\n+        return toClass.isAssignableFrom(cls);\n+    }\n+\n+    /**\n+     * <p>Converts the specified primitive Class object to its corresponding\n+     * wrapper Class object.</p>\n+     *\n+     * <p>NOTE: From v2.2, this method handles <code>Void.TYPE</code>,\n+     * returning <code>Void.TYPE</code>.</p>\n+     *\n+     * @param cls  the class to convert, may be null\n+     * @return the wrapper class for <code>cls</code> or <code>cls</code> if\n+     * <code>cls</code> is not a primitive. <code>null</code> if null input.\n+     * @since 2.1\n+     */\n+    public static Class<?> primitiveToWrapper(Class<?> cls) {\n+        Class<?> convertedClass = cls;\n+        if (cls != null && cls.isPrimitive()) {\n+            convertedClass = primitiveWrapperMap.get(cls);\n+        }\n+        return convertedClass;\n+    }\n+\n+    /**\n+     * <p>Converts the specified array of primitive Class objects to an array of\n+     * its corresponding wrapper Class objects.</p>\n+     *\n+     * @param classes  the class array to convert, may be null or empty\n+     * @return an array which contains for each given class, the wrapper class or\n+     * the original class if class is not a primitive. <code>null</code> if null input.\n+     * Empty array if an empty array passed in.\n+     * @since 2.1\n+     */\n+    public static Class<?>[] primitivesToWrappers(Class<?>[] classes) {\n+        if (classes == null) {\n+            return null;\n+        }\n+\n+        if (classes.length == 0) {\n+            return classes;\n+        }\n+\n+        Class<?>[] convertedClasses = new Class[classes.length];\n+        for (int i = 0; i < classes.length; i++) {\n+            convertedClasses[i] = primitiveToWrapper(classes[i]);\n+        }\n+        return convertedClasses;\n+    }\n+\n+    /**\n+     * <p>Converts the specified wrapper class to its corresponding primitive\n+     * class.</p>\n+     *\n+     * <p>This method is the counter part of <code>primitiveToWrapper()</code>.\n+     * If the passed in class is a wrapper class for a primitive type, this\n+     * primitive type will be returned (e.g. <code>Integer.TYPE</code> for\n+     * <code>Integer.class</code>). For other classes, or if the parameter is\n+     * <b>null</b>, the return value is <b>null</b>.</p>\n+     *\n+     * @param cls the class to convert, may be <b>null</b>\n+     * @return the corresponding primitive type if <code>cls</code> is a\n+     * wrapper class, <b>null</b> otherwise\n+     * @see #primitiveToWrapper(Class)\n+     * @since 2.4\n+     */\n+    public static Class<?> wrapperToPrimitive(Class<?> cls) {\n+        return wrapperPrimitiveMap.get(cls);\n+    }\n+\n+    /**\n+     * <p>Converts the specified array of wrapper Class objects to an array of\n+     * its corresponding primitive Class objects.</p>\n+     *\n+     * <p>This method invokes <code>wrapperToPrimitive()</code> for each element\n+     * of the passed in array.</p>\n+     *\n+     * @param classes  the class array to convert, may be null or empty\n+     * @return an array which contains for each given class, the primitive class or\n+     * <b>null</b> if the original class is not a wrapper class. <code>null</code> if null input.\n+     * Empty array if an empty array passed in.\n+     * @see #wrapperToPrimitive(Class)\n+     * @since 2.4\n+     */\n+    public static Class<?>[] wrappersToPrimitives(Class<?>[] classes) {\n+        if (classes == null) {\n+            return null;\n+        }\n+\n+        if (classes.length == 0) {\n+            return classes;\n+        }\n+\n+        Class<?>[] convertedClasses = new Class[classes.length];\n+        for (int i = 0; i < classes.length; i++) {\n+            convertedClasses[i] = wrapperToPrimitive(classes[i]);\n+        }\n+        return convertedClasses;\n+    }\n+\n+    // Inner class\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Is the specified class an inner class or static nested class.</p>\n+     *\n+     * @param cls  the class to check, may be null\n+     * @return <code>true</code> if the class is an inner or static nested class,\n+     *  false if not or <code>null</code>\n+     */\n+    public static boolean isInnerClass(Class<?> cls) {\n+        if (cls == null) {\n+            return false;\n+        }\n+        return cls.getName().indexOf(INNER_CLASS_SEPARATOR_CHAR) >= 0;\n+    }\n+\n+    // Class loading\n+    // ----------------------------------------------------------------------\n+    /**\n+     * Returns the class represented by <code>className</code> using the\n+     * <code>classLoader</code>.  This implementation supports names like\n+     * \"<code>java.lang.String[]</code>\" as well as \"<code>[Ljava.lang.String;</code>\".\n+     *\n+     * @param classLoader  the class loader to use to load the class\n+     * @param className  the class name\n+     * @param initialize  whether the class must be initialized\n+     * @return the class represented by <code>className</code> using the <code>classLoader</code>\n+     * @throws ClassNotFoundException if the class is not found\n+     */\n+    public static Class<?> getClass(\n+            ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException {\n+        Class<?> clazz;\n+        if (abbreviationMap.containsKey(className)) {\n+            String clsName = \"[\" + abbreviationMap.get(className);\n+            clazz = Class.forName(clsName, initialize, classLoader).getComponentType();\n+        } else {\n+            clazz = Class.forName(toCanonicalName(className), initialize, classLoader);\n+        }\n+        return clazz;\n+    }\n+\n+    /**\n+     * Returns the (initialized) class represented by <code>className</code>\n+     * using the <code>classLoader</code>.  This implementation supports names\n+     * like \"<code>java.lang.String[]</code>\" as well as\n+     * \"<code>[Ljava.lang.String;</code>\".\n+     *\n+     * @param classLoader  the class loader to use to load the class\n+     * @param className  the class name\n+     * @return the class represented by <code>className</code> using the <code>classLoader</code>\n+     * @throws ClassNotFoundException if the class is not found\n+     */\n+    public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException {\n+        return getClass(classLoader, className, true);\n+    }\n+\n+    /**\n+     * Returns the (initialized) class represented by <code>className</code>\n+     * using the current thread's context class loader. This implementation\n+     * supports names like \"<code>java.lang.String[]</code>\" as well as\n+     * \"<code>[Ljava.lang.String;</code>\".\n+     *\n+     * @param className  the class name\n+     * @return the class represented by <code>className</code> using the current thread's context class loader\n+     * @throws ClassNotFoundException if the class is not found\n+     */\n+    public static Class<?> getClass(String className) throws ClassNotFoundException {\n+        return getClass(className, true);\n+    }\n+\n+    /**\n+     * Returns the class represented by <code>className</code> using the\n+     * current thread's context class loader. This implementation supports\n+     * names like \"<code>java.lang.String[]</code>\" as well as\n+     * \"<code>[Ljava.lang.String;</code>\".\n+     *\n+     * @param className  the class name\n+     * @param initialize  whether the class must be initialized\n+     * @return the class represented by <code>className</code> using the current thread's context class loader\n+     * @throws ClassNotFoundException if the class is not found\n+     */\n+    public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException {\n+        ClassLoader contextCL = Thread.currentThread().getContextClassLoader();\n+        ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;\n+        return getClass(loader, className, initialize );\n+    }\n+\n+    // Public method\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Returns the desired Method much like <code>Class.getMethod</code>, however\n+     * it ensures that the returned Method is from a public class or interface and not\n+     * from an anonymous inner class. This means that the Method is invokable and\n+     * doesn't fall foul of Java bug\n+     * <a href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4071957\">4071957</a>).\n+     *\n+     *  <code><pre>Set set = Collections.unmodifiableSet(...);\n+     *  Method method = ClassUtils.getPublicMethod(set.getClass(), \"isEmpty\",  new Class[0]);\n+     *  Object result = method.invoke(set, new Object[]);</pre></code>\n+     * </p>\n+     *\n+     * @param cls  the class to check, not null\n+     * @param methodName  the name of the method\n+     * @param parameterTypes  the list of parameters\n+     * @return the method\n+     * @throws NullPointerException if the class is null\n+     * @throws SecurityException if a a security violation occured\n+     * @throws NoSuchMethodException if the method is not found in the given class\n+     *  or if the metothod doen't conform with the requirements\n+     */\n+    public static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[])\n+            throws SecurityException, NoSuchMethodException {\n+\n+        Method declaredMethod = cls.getMethod(methodName, parameterTypes);\n+        if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) {\n+            return declaredMethod;\n+        }\n+\n+        List<Class<?>> candidateClasses = new ArrayList<Class<?>>();\n+        candidateClasses.addAll(getAllInterfaces(cls));\n+        candidateClasses.addAll(getAllSuperclasses(cls));\n+\n+        for (Class<?> candidateClass : candidateClasses) {\n+            if (!Modifier.isPublic(candidateClass.getModifiers())) {\n+                continue;\n+            }\n+            Method candidateMethod;\n+            try {\n+                candidateMethod = candidateClass.getMethod(methodName, parameterTypes);\n+            } catch (NoSuchMethodException ex) {\n+                continue;\n+            }\n+            if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {\n+                return candidateMethod;\n+            }\n+        }\n+\n+        throw new NoSuchMethodException(\"Can't find a public method for \" +\n+                methodName + \" \" + ArrayUtils.toString(parameterTypes));\n+    }\n+\n+    // ----------------------------------------------------------------------\n+    /**\n+     * Converts a class name to a JLS style class name.\n+     *\n+     * @param className  the class name\n+     * @return the converted name\n+     */\n+    private static String toCanonicalName(String className) {\n+        className = StringUtils.deleteWhitespace(className);\n+        if (className == null) {\n+            throw new NullPointerException(\"className must not be null.\");\n+        } else if (className.endsWith(\"[]\")) {\n+            StringBuilder classNameBuffer = new StringBuilder();\n+            while (className.endsWith(\"[]\")) {\n+                className = className.substring(0, className.length() - 2);\n+                classNameBuffer.append(\"[\");\n+            }\n+            String abbreviation = abbreviationMap.get(className);\n+            if (abbreviation != null) {\n+                classNameBuffer.append(abbreviation);\n+            } else {\n+                classNameBuffer.append(\"L\").append(className).append(\";\");\n+            }\n+            className = classNameBuffer.toString();\n+        }\n+        return className;\n+    }\n+\n+    /**\n+     * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array an <code>Object</code> array\n+     * @return a <code>Class</code> array, <code>null</code> if null array input\n+     * @since 2.4\n+     */\n+    public static Class<?>[] toClass(Object[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        Class<?>[] classes = new Class[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            classes[i] = array[i].getClass();\n+        }\n+        return classes;\n+    }\n+\n+    // Short canonical name\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the canonical name minus the package name for an <code>Object</code>.</p>\n+     *\n+     * @param object  the class to get the short name for, may be null\n+     * @param valueIfNull  the value to return if null\n+     * @return the canonical name of the object without the package name, or the null value\n+     * @since 2.4\n+     */\n+    public static String getShortCanonicalName(Object object, String valueIfNull) {\n+        if (object == null) {\n+            return valueIfNull;\n+        }\n+        return getShortCanonicalName(object.getClass().getName());\n+    }\n+\n+    /**\n+     * <p>Gets the canonical name minus the package name from a <code>Class</code>.</p>\n+     *\n+     * @param cls  the class to get the short name for.\n+     * @return the canonical name without the package name or an empty string\n+     * @since 2.4\n+     */\n+    public static String getShortCanonicalName(Class<?> cls) {\n+        if (cls == null) {\n+            return StringUtils.EMPTY;\n+        }\n+        return getShortCanonicalName(cls.getName());\n+    }\n+\n+    /**\n+     * <p>Gets the canonical name minus the package name from a String.</p>\n+     *\n+     * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>\n+     *\n+     * @param canonicalName  the class name to get the short name for\n+     * @return the canonical name of the class without the package name or an empty string\n+     * @since 2.4\n+     */\n+    public static String getShortCanonicalName(String canonicalName) {\n+        return ClassUtils.getShortClassName(getCanonicalName(canonicalName));\n+    }\n+\n+    // Package name\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the package name from the canonical name of an <code>Object</code>.</p>\n+     *\n+     * @param object  the class to get the package name for, may be null\n+     * @param valueIfNull  the value to return if null\n+     * @return the package name of the object, or the null value\n+     * @since 2.4\n+     */\n+    public static String getPackageCanonicalName(Object object, String valueIfNull) {\n+        if (object == null) {\n+            return valueIfNull;\n+        }\n+        return getPackageCanonicalName(object.getClass().getName());\n+    }\n+\n+    /**\n+     * <p>Gets the package name from the canonical name of a <code>Class</code>.</p>\n+     *\n+     * @param cls  the class to get the package name for, may be <code>null</code>.\n+     * @return the package name or an empty string\n+     * @since 2.4\n+     */\n+    public static String getPackageCanonicalName(Class<?> cls) {\n+        if (cls == null) {\n+            return StringUtils.EMPTY;\n+        }\n+        return getPackageCanonicalName(cls.getName());\n+    }\n+\n+    /**\n+     * <p>Gets the package name from the canonical name. </p>\n+     *\n+     * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>\n+     * <p>If the class is unpackaged, return an empty string.</p>\n+     *\n+     * @param canonicalName  the canonical name to get the package name for, may be <code>null</code>\n+     * @return the package name or an empty string\n+     * @since 2.4\n+     */\n+    public static String getPackageCanonicalName(String canonicalName) {\n+        return ClassUtils.getPackageName(getCanonicalName(canonicalName));\n+    }\n+\n+    /**\n+     * <p>Converts a given name of class into canonical format.\n+     * If name of class is not a name of array class it returns\n+     * unchanged name.</p>\n+     * <p>Example:\n+     * <ul>\n+     * <li><code>getCanonicalName(\"[I\") = \"int[]\"</code></li>\n+     * <li><code>getCanonicalName(\"[Ljava.lang.String;\") = \"java.lang.String[]\"</code></li>\n+     * <li><code>getCanonicalName(\"java.lang.String\") = \"java.lang.String\"</code></li>\n+     * </ul>\n+     * </p>\n+     *\n+     * @param className the name of class\n+     * @return canonical form of class name\n+     * @since 2.4\n+     */\n+    private static String getCanonicalName(String className) {\n+        className = StringUtils.deleteWhitespace(className);\n+        if (className == null) {\n+            return null;\n+        } else {\n+            int dim = 0;\n+            while (className.startsWith(\"[\")) {\n+                dim++;\n+                className = className.substring(1);\n+            }\n+            if (dim < 1) {\n+                return className;\n+            } else {\n+                if (className.startsWith(\"L\")) {\n+                    className = className.substring(\n+                        1,\n+                        className.endsWith(\";\")\n+                            ? className.length() - 1\n+                            : className.length());\n+                } else {\n+                    if (className.length() > 0) {\n+                        className = reverseAbbreviationMap.get(className.substring(0, 1));\n+                    }\n+                }\n+                StringBuilder canonicalClassNameBuffer = new StringBuilder(className);\n+                for (int i = 0; i < dim; i++) {\n+                    canonicalClassNameBuffer.append(\"[]\");\n+                }\n+                return canonicalClassNameBuffer.toString();\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/EnumUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Utility library to provide helper methods for Java enums.\n+ * \n+ * @author Apache Software Foundation\n+ */\n+public class EnumUtils {\n+\n+    /**\n+     * This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.\n+     */\n+    public EnumUtils() {\n+    }\n+\n+    /**\n+     * Gets the <code>Map</code> of <code>enums</code> by name.\n+     * <p>\n+     * This method is useful when you need a map of enums by name.\n+     *\n+     * @param enumClass  the class of the <code>enum</code> to get, not null\n+     * @return the modifiable map of enum names to enums, never null\n+     */\n+    public static <E extends Enum<E>> Map<String, E> getEnumMap(Class<E> enumClass) {\n+        Map<String, E> map = new LinkedHashMap<String, E>();\n+        for (E e: enumClass.getEnumConstants()) {\n+            map.put(e.name(), e);\n+        }\n+        return map;\n+    }\n+\n+    /**\n+     * Gets the <code>List</code> of <code>enums</code>.\n+     * <p>\n+     * This method is useful when you need a list of enums rather than an array.\n+     *\n+     * @param enumClass  the class of the <code>enum</code> to get, not null\n+     * @return the modifiable list of enums, never null\n+     */\n+    public static <E extends Enum<E>> List<E> getEnumList(Class<E> enumClass) {\n+        return new ArrayList<E>(Arrays.asList(enumClass.getEnumConstants()));\n+    }\n+\n+    /**\n+     * Checks if the specified name is a valid <code>enum</code> for the class.\n+     * <p>\n+     * This method differs from {@link Enum#valueOf} in that checks if the name is\n+     * a valid enum without needing to catch the exception.\n+     *\n+     * @param enumClass  the class of the <code>enum</code> to get, not null\n+     * @return the map of enum names to enums, never null\n+     */\n+    public static <E extends Enum<E>> boolean isValidEnum(Class<E> enumClass, String enumName) {\n+        try {\n+            Enum.valueOf(enumClass, enumName);\n+            return true;\n+        } catch (IllegalArgumentException ex) {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Gets the <code>enum</code> for the class, returning <code>null</code> if not found.\n+     * <p>\n+     * This method differs from {@link Enum#valueOf} in that it does not throw an exception\n+     * for an invalid enum name.\n+     *\n+     * @param enumClass  the class of the <code>enum</code> to get, not null\n+     * @return the map of enum names to enums, never null\n+     */\n+    public static <E extends Enum<E>> E getEnum(Class<E> enumClass, String enumName) {\n+        try {\n+            return Enum.valueOf(enumClass, enumName);\n+        } catch (IllegalArgumentException ex) {\n+            return null;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/LocaleUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * <p>Operations to assist when working with a {@link Locale}.</p>\n+ *\n+ * <p>This class tries to handle <code>null</code> input gracefully.\n+ * An exception will not be thrown for a <code>null</code> input.\n+ * Each method documents its behaviour in more detail.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @since 2.2\n+ * @version $Id$\n+ */\n+public class LocaleUtils {\n+\n+    /** Unmodifiable list of available locales. */\n+    //@GuardedBy(\"this\")\n+    private static List<Locale> cAvailableLocaleList; // lazily created by availableLocaleList()\n+\n+    /** Unmodifiable set of available locales. */\n+    //@GuardedBy(\"this\")\n+    private static Set<Locale> cAvailableLocaleSet;   // lazily created by availableLocaleSet()\n+\n+    /** Unmodifiable map of language locales by country. */\n+    private static final Map<String, List<Locale>> cLanguagesByCountry = Collections.synchronizedMap(new HashMap<String, List<Locale>>());\n+\n+    /** Unmodifiable map of country locales by language. */\n+    private static final Map<String, List<Locale>> cCountriesByLanguage = Collections.synchronizedMap(new HashMap<String, List<Locale>>());\n+\n+    /**\n+     * <p><code>LocaleUtils</code> instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>LocaleUtils.toLocale(\"en_GB\");</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public LocaleUtils() {\n+      super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a String to a Locale.</p>\n+     *\n+     * <p>This method takes the string format of a locale and creates the\n+     * locale object from it.</p>\n+     *\n+     * <pre>\n+     *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n+     *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n+     *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n+     * </pre>\n+     *\n+     * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n+     * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n+     * Thus, the result from getVariant() may vary depending on your JDK.</p>\n+     *\n+     * <p>This method validates the input strictly.\n+     * The language code must be lowercase.\n+     * The country code must be uppercase.\n+     * The separator must be an underscore.\n+     * The length must be correct.\n+     * </p>\n+     *\n+     * @param str  the locale String to convert, null returns null\n+     * @return a Locale, null if null input\n+     * @throws IllegalArgumentException if the string is an invalid format\n+     */\n+    public static Locale toLocale(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        int len = str.length();\n+        if (len != 2 && len != 5 && len < 7) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        char ch0 = str.charAt(0);\n+        char ch1 = str.charAt(1);\n+        if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        if (len == 2) {\n+            return new Locale(str, \"\");\n+        } else {\n+            if (str.charAt(2) != '_') {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+            }\n+            char ch3 = str.charAt(3);\n+            if (ch3 == '_') {\n+                return new Locale(str.substring(0, 2), \"\", str.substring(4));\n+            }\n+            char ch4 = str.charAt(4);\n+            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+            }\n+            if (len == 5) {\n+                return new Locale(str.substring(0, 2), str.substring(3, 5));\n+            } else {\n+                if (str.charAt(5) != '_') {\n+                    throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+                }\n+                return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains the list of locales to search through when performing\n+     * a locale search.</p>\n+     *\n+     * <pre>\n+     * localeLookupList(Locale(\"fr\",\"CA\",\"xxx\"))\n+     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\")]\n+     * </pre>\n+     *\n+     * @param locale  the locale to start from\n+     * @return the unmodifiable list of Locale objects, 0 being locale, never null\n+     */\n+    public static List<Locale> localeLookupList(Locale locale) {\n+        return localeLookupList(locale, locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains the list of locales to search through when performing\n+     * a locale search.</p>\n+     *\n+     * <pre>\n+     * localeLookupList(Locale(\"fr\", \"CA\", \"xxx\"), Locale(\"en\"))\n+     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\"]\n+     * </pre>\n+     *\n+     * <p>The result list begins with the most specific locale, then the\n+     * next more general and so on, finishing with the default locale.\n+     * The list will never contain the same locale twice.</p>\n+     *\n+     * @param locale  the locale to start from, null returns empty list\n+     * @param defaultLocale  the default locale to use if no other is found\n+     * @return the unmodifiable list of Locale objects, 0 being locale, never null\n+     */\n+    public static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n+        List<Locale> list = new ArrayList<Locale>(4);\n+        if (locale != null) {\n+            list.add(locale);\n+            if (locale.getVariant().length() > 0) {\n+                list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n+            }\n+            if (locale.getCountry().length() > 0) {\n+                list.add(new Locale(locale.getLanguage(), \"\"));\n+            }\n+            if (list.contains(defaultLocale) == false) {\n+                list.add(defaultLocale);\n+            }\n+        }\n+        return Collections.unmodifiableList(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains an unmodifiable list of installed locales.</p>\n+     * \n+     * <p>This method is a wrapper around {@link Locale#getAvailableLocales()}.\n+     * It is more efficient, as the JDK method must create a new array each\n+     * time it is called.</p>\n+     *\n+     * @return the unmodifiable list of available locales\n+     */\n+    public static List<Locale> availableLocaleList() {\n+        if(cAvailableLocaleList == null) { \n+            initAvailableLocaleList(); \n+        }\n+        return cAvailableLocaleList;\n+    }\n+\n+    /**\n+     * Initializes the availableLocaleList. It is separate from availableLocaleList() \n+     * to avoid the synchronized block affecting normal use, yet synchronized and \n+     * lazy loading to avoid a static block affecting other methods in this class. \n+     */\n+    private static synchronized void initAvailableLocaleList() {\n+        if(cAvailableLocaleList == null) {\n+            List<Locale> list = Arrays.asList(Locale.getAvailableLocales());\n+            cAvailableLocaleList = Collections.unmodifiableList(list);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains an unmodifiable set of installed locales.</p>\n+     * \n+     * <p>This method is a wrapper around {@link Locale#getAvailableLocales()}.\n+     * It is more efficient, as the JDK method must create a new array each\n+     * time it is called.</p>\n+     *\n+     * @return the unmodifiable set of available locales\n+     */\n+    public static Set<Locale> availableLocaleSet() {\n+        if(cAvailableLocaleSet == null) { \n+            initAvailableLocaleSet(); \n+        }\n+        return cAvailableLocaleSet;\n+    }\n+\n+    /**\n+     * Initializes the availableLocaleSet. It is separate from availableLocaleSet() \n+     * to avoid the synchronized block affecting normal use, yet synchronized and \n+     * lazy loading to avoid a static block affecting other methods in this class. \n+     */\n+    private static synchronized void initAvailableLocaleSet() {\n+        if(cAvailableLocaleSet == null) {\n+            cAvailableLocaleSet = Collections.unmodifiableSet( new HashSet<Locale>(availableLocaleList()) );\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if the locale specified is in the list of available locales.</p>\n+     *\n+     * @param locale the Locale object to check if it is available\n+     * @return true if the locale is a known locale\n+     */\n+    public static boolean isAvailableLocale(Locale locale) {\n+        return availableLocaleList().contains(locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains the list of languages supported for a given country.</p>\n+     *\n+     * <p>This method takes a country code and searches to find the\n+     * languages available for that country. Variant locales are removed.</p>\n+     *\n+     * @param countryCode  the 2 letter country code, null returns empty\n+     * @return an unmodifiable List of Locale objects, never null\n+     */\n+    public static List<Locale> languagesByCountry(String countryCode) {\n+        List<Locale> langs = cLanguagesByCountry.get(countryCode);  //syncd\n+        if (langs == null) {\n+            if (countryCode != null) {\n+                langs = new ArrayList<Locale>();\n+                List<Locale> locales = availableLocaleList();\n+                for (int i = 0; i < locales.size(); i++) {\n+                    Locale locale = locales.get(i);\n+                    if (countryCode.equals(locale.getCountry()) &&\n+                            locale.getVariant().length() == 0) {\n+                        langs.add(locale);\n+                    }\n+                }\n+                langs = Collections.unmodifiableList(langs);\n+            } else {\n+                langs = Collections.emptyList();\n+            }\n+            cLanguagesByCountry.put(countryCode, langs);  //syncd\n+        }\n+        return langs;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains the list of countries supported for a given language.</p>\n+     * \n+     * <p>This method takes a language code and searches to find the\n+     * countries available for that language. Variant locales are removed.</p>\n+     *\n+     * @param languageCode  the 2 letter language code, null returns empty\n+     * @return an unmodifiable List of Locale objects, never null\n+     */\n+    public static List<Locale> countriesByLanguage(String languageCode) {\n+        List<Locale> countries = cCountriesByLanguage.get(languageCode);  //syncd\n+        if (countries == null) {\n+            if (languageCode != null) {\n+                countries = new ArrayList<Locale>();\n+                List<Locale> locales = availableLocaleList();\n+                for (int i = 0; i < locales.size(); i++) {\n+                    Locale locale = locales.get(i);\n+                    if (languageCode.equals(locale.getLanguage()) &&\n+                            locale.getCountry().length() != 0 &&\n+                            locale.getVariant().length() == 0) {\n+                        countries.add(locale);\n+                    }\n+                }\n+                countries = Collections.unmodifiableList(countries);\n+            } else {\n+                countries = Collections.emptyList();\n+            }\n+            cCountriesByLanguage.put(languageCode, countries);  //syncd\n+        }\n+        return countries;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/ObjectUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * <p>Operations on <code>Object</code>.</p>\n+ * \n+ * <p>This class tries to handle <code>null</code> input gracefully.\n+ * An exception will generally not be thrown for a <code>null</code> input.\n+ * Each method documents its behaviour in more detail.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:nissim@nksystems.com\">Nissim Karpenstein</a>\n+ * @author <a href=\"mailto:janekdb@yahoo.co.uk\">Janek Bogucki</a>\n+ * @author Daniel L. Rall\n+ * @author Gary Gregory\n+ * @author Mario Winterer\n+ * @author <a href=\"mailto:david@davidkarlsen.com\">David J. M. Karlsen</a>\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+//@Immutable\n+public class ObjectUtils {\n+\n+    /**\n+     * <p>Singleton used as a <code>null</code> placeholder where\n+     * <code>null</code> has another meaning.</p>\n+     *\n+     * <p>For example, in a <code>HashMap</code> the\n+     * {@link java.util.HashMap#get(java.lang.Object)} method returns\n+     * <code>null</code> if the <code>Map</code> contains\n+     * <code>null</code> or if there is no matching key. The\n+     * <code>Null</code> placeholder can be used to distinguish between\n+     * these two cases.</p>\n+     *\n+     * <p>Another example is <code>Hashtable</code>, where <code>null</code>\n+     * cannot be stored.</p>\n+     *\n+     * <p>This instance is Serializable.</p>\n+     */\n+    public static final Null NULL = new Null();\n+    \n+    /**\n+     * <p><code>ObjectUtils</code> instances should NOT be constructed in\n+     * standard programming. Instead, the class should be used as\n+     * <code>ObjectUtils.defaultIfNull(\"a\",\"b\");</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public ObjectUtils() {\n+        super();\n+    }\n+\n+    // Defaulting\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns a default value if the object passed is\n+     * <code>null</code>.</p>\n+     * \n+     * <pre>\n+     * ObjectUtils.defaultIfNull(null, null)      = null\n+     * ObjectUtils.defaultIfNull(null, \"\")        = \"\"\n+     * ObjectUtils.defaultIfNull(null, \"zz\")      = \"zz\"\n+     * ObjectUtils.defaultIfNull(\"abc\", *)        = \"abc\"\n+     * ObjectUtils.defaultIfNull(Boolean.TRUE, *) = Boolean.TRUE\n+     * </pre>\n+     *\n+     * @param object  the <code>Object</code> to test, may be <code>null</code>\n+     * @param defaultValue  the default value to return, may be <code>null</code>\n+     * @return <code>object</code> if it is not <code>null</code>, defaultValue otherwise\n+     */\n+    public static Object defaultIfNull(Object object, Object defaultValue) {\n+        return object != null ? object : defaultValue;\n+    }\n+\n+    /**\n+     * <p>Returns the first value in the array which is not <code>null</code>.\n+     * If all the values are <code>null</code> or the array is <code>null</code>\n+     * or empty then <code>null</code> is returned.</p>\n+     * \n+     * <pre>\n+     * ObjectUtils.firstNonNull(null, null)      = null\n+     * ObjectUtils.firstNonNull(null, \"\")        = \"\"\n+     * ObjectUtils.firstNonNull(null, null, \"\")  = \"\"\n+     * ObjectUtils.firstNonNull(null, \"zz\")      = \"zz\"\n+     * ObjectUtils.firstNonNull(\"abc\", *)        = \"abc\"\n+     * ObjectUtils.firstNonNull(null, \"xyz\", *)  = \"xyz\"\n+     * ObjectUtils.firstNonNull(Boolean.TRUE, *) = Boolean.TRUE\n+     * ObjectUtils.firstNonNull()                = null\n+     * </pre>\n+     *\n+     * @param values  the values to test, may be <code>null</code> or empty\n+     * @return the first value from <code>values</code> which is not <code>null</code>,\n+     *  or <code>null</code> if there are no non-null values\n+     */\n+    public static <T> T firstNonNull(T... values) {\n+        if (values != null) {\n+            for (T val : values) {\n+                if (val != null) {\n+                    return val;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    // Null-safe equals/hashCode\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compares two objects for equality, where either one or both\n+     * objects may be <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * ObjectUtils.equals(null, null)                  = true\n+     * ObjectUtils.equals(null, \"\")                    = false\n+     * ObjectUtils.equals(\"\", null)                    = false\n+     * ObjectUtils.equals(\"\", \"\")                      = true\n+     * ObjectUtils.equals(Boolean.TRUE, null)          = false\n+     * ObjectUtils.equals(Boolean.TRUE, \"true\")        = false\n+     * ObjectUtils.equals(Boolean.TRUE, Boolean.TRUE)  = true\n+     * ObjectUtils.equals(Boolean.TRUE, Boolean.FALSE) = false\n+     * </pre>\n+     *\n+     * @param object1  the first object, may be <code>null</code>\n+     * @param object2  the second object, may be <code>null</code>\n+     * @return <code>true</code> if the values of both objects are the same\n+     */\n+    public static boolean equals(Object object1, Object object2) {\n+        if (object1 == object2) {\n+            return true;\n+        }\n+        if ((object1 == null) || (object2 == null)) {\n+            return false;\n+        }\n+        return object1.equals(object2);\n+    }\n+\n+    /**\n+     * <p>Gets the hash code of an object returning zero when the\n+     * object is <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * ObjectUtils.hashCode(null)   = 0\n+     * ObjectUtils.hashCode(obj)    = obj.hashCode()\n+     * </pre>\n+     *\n+     * @param obj  the object to obtain the hash code of, may be <code>null</code>\n+     * @return the hash code of the object, or zero if null\n+     * @since 2.1\n+     */\n+    public static int hashCode(Object obj) {\n+        return (obj == null) ? 0 : obj.hashCode();\n+    }\n+\n+    // Identity ToString\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the toString that would be produced by <code>Object</code>\n+     * if a class did not override toString itself. <code>null</code>\n+     * will return <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * ObjectUtils.identityToString(null)         = null\n+     * ObjectUtils.identityToString(\"\")           = \"java.lang.String@1e23\"\n+     * ObjectUtils.identityToString(Boolean.TRUE) = \"java.lang.Boolean@7fa\"\n+     * </pre>\n+     *\n+     * @param object  the object to create a toString for, may be\n+     *  <code>null</code>\n+     * @return the default toString text, or <code>null</code> if\n+     *  <code>null</code> passed in\n+     */\n+    public static String identityToString(Object object) {\n+        if (object == null) {\n+            return null;\n+        }\n+        StringBuffer buffer = new StringBuffer();\n+        identityToString(buffer, object);\n+        return buffer.toString();\n+    }\n+\n+    /**\n+     * <p>Appends the toString that would be produced by <code>Object</code>\n+     * if a class did not override toString itself. <code>null</code>\n+     * will throw a NullPointerException for either of the two parameters. </p>\n+     *\n+     * <pre>\n+     * ObjectUtils.identityToString(buf, \"\")            = buf.append(\"java.lang.String@1e23\"\n+     * ObjectUtils.identityToString(buf, Boolean.TRUE)  = buf.append(\"java.lang.Boolean@7fa\"\n+     * ObjectUtils.identityToString(buf, Boolean.TRUE)  = buf.append(\"java.lang.Boolean@7fa\")\n+     * </pre>\n+     *\n+     * @param buffer  the buffer to append to\n+     * @param object  the object to create a toString for\n+     * @since 2.4\n+     */\n+    public static void identityToString(StringBuffer buffer, Object object) {\n+        if (object == null) {\n+            throw new NullPointerException(\"Cannot get the toString of a null identity\");\n+        }\n+        buffer.append(object.getClass().getName())\n+              .append('@')\n+              .append(Integer.toHexString(System.identityHashCode(object)));\n+    }\n+\n+    // ToString\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the <code>toString</code> of an <code>Object</code> returning\n+     * an empty string (\"\") if <code>null</code> input.</p>\n+     * \n+     * <pre>\n+     * ObjectUtils.toString(null)         = \"\"\n+     * ObjectUtils.toString(\"\")           = \"\"\n+     * ObjectUtils.toString(\"bat\")        = \"bat\"\n+     * ObjectUtils.toString(Boolean.TRUE) = \"true\"\n+     * </pre>\n+     * \n+     * @see StringUtils#defaultString(String)\n+     * @see String#valueOf(Object)\n+     * @param obj  the Object to <code>toString</code>, may be null\n+     * @return the passed in Object's toString, or nullStr if <code>null</code> input\n+     * @since 2.0\n+     */\n+    public static String toString(Object obj) {\n+        return obj == null ? \"\" : obj.toString();\n+    }\n+\n+    /**\n+     * <p>Gets the <code>toString</code> of an <code>Object</code> returning\n+     * a specified text if <code>null</code> input.</p>\n+     * \n+     * <pre>\n+     * ObjectUtils.toString(null, null)           = null\n+     * ObjectUtils.toString(null, \"null\")         = \"null\"\n+     * ObjectUtils.toString(\"\", \"null\")           = \"\"\n+     * ObjectUtils.toString(\"bat\", \"null\")        = \"bat\"\n+     * ObjectUtils.toString(Boolean.TRUE, \"null\") = \"true\"\n+     * </pre>\n+     * \n+     * @see StringUtils#defaultString(String,String)\n+     * @see String#valueOf(Object)\n+     * @param obj  the Object to <code>toString</code>, may be null\n+     * @param nullStr  the String to return if <code>null</code> input, may be null\n+     * @return the passed in Object's toString, or nullStr if <code>null</code> input\n+     * @since 2.0\n+     */\n+    public static String toString(Object obj, String nullStr) {\n+        return obj == null ? nullStr : obj.toString();\n+    }\n+\n+    // Min/Max\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Null safe comparison of Comparables.\n+     * \n+     * @param c1  the first comparable, may be null\n+     * @param c2  the second comparable, may be null\n+     * @return\n+     *  <ul>\n+     *   <li>If both objects are non-null and unequal, the lesser object.\n+     *   <li>If both objects are non-null and equal, c1.\n+     *   <li>If one of the comparables is null, the non-null object.\n+     *   <li>If both the comparables are null, null is returned.\n+     *  </ul>\n+     */\n+    public static <T extends Comparable<? super T>> T min(T c1, T c2) {\n+        if (c1 != null && c2 != null) {\n+            return c1.compareTo(c2) < 1 ? c1 : c2;\n+        } else {\n+            return c1 != null ? c1 : c2;\n+        }                              \n+    }\n+\n+    /**\n+     * Null safe comparison of Comparables.\n+     * \n+     * @param c1  the first comparable, may be null\n+     * @param c2  the second comparable, may be null\n+     * @return\n+     *  <ul>\n+     *   <li>If both objects are non-null and unequal, the greater object.\n+     *   <li>If both objects are non-null and equal, c1.\n+     *   <li>If one of the comparables is null, the non-null object.\n+     *   <li>If both the comparables are null, null is returned.\n+     *  </ul>\n+     */\n+    public static <T extends Comparable<? super T>> T max(T c1, T c2) {\n+        if (c1 != null && c2 != null) {\n+            return c1.compareTo(c2) >= 0 ? c1 : c2;\n+        } else {\n+            return c1 != null ? c1 : c2;\n+        }\n+    }\n+\n+    // Null\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Class used as a null placeholder where <code>null</code>\n+     * has another meaning.</p>\n+     *\n+     * <p>For example, in a <code>HashMap</code> the\n+     * {@link java.util.HashMap#get(java.lang.Object)} method returns\n+     * <code>null</code> if the <code>Map</code> contains\n+     * <code>null</code> or if there is no matching key. The\n+     * <code>Null</code> placeholder can be used to distinguish between\n+     * these two cases.</p>\n+     *\n+     * <p>Another example is <code>Hashtable</code>, where <code>null</code>\n+     * cannot be stored.</p>\n+     */\n+    public static class Null implements Serializable {\n+        /**\n+         * Required for serialization support. Declare serialization compatibility with Commons Lang 1.0\n+         * \n+         * @see java.io.Serializable\n+         */\n+        private static final long serialVersionUID = 7092611880189329093L;\n+        \n+        /**\n+         * Restricted constructor - singleton.\n+         */\n+        Null() {\n+            super();\n+        }\n+        \n+        /**\n+         * <p>Ensure singleton.</p>\n+         * \n+         * @return the singleton value\n+         */\n+        private Object readResolve() {\n+            return ObjectUtils.NULL;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/RandomStringUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.util.Random;\n+/**\n+ * <p>Operations for random <code>String</code>s.</p>\n+ * <p>Currently <em>private high surrogate</em> characters are ignored. \n+ * These are unicode characters that fall between the values 56192 (db80)\n+ * and 56319 (dbff) as we don't know how to handle them. \n+ * High and low surrogates are correctly dealt with - that is if a \n+ * high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f) \n+ * then it is followed by a low surrogate. If a low surrogate is chosen, \n+ * 56320 (dc00) to 57343 (dfff) then it is placed after a randomly \n+ * chosen high surrogate. </p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @author Gary Gregory\n+ * @author Phil Steitz\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class RandomStringUtils {\n+\n+    /**\n+     * <p>Random object used by random method. This has to be not local\n+     * to the random method so as to not return the same value in the \n+     * same millisecond.</p>\n+     */\n+    private static final Random RANDOM = new Random();\n+\n+    /**\n+     * <p><code>RandomStringUtils</code> instances should NOT be constructed in\n+     * standard programming. Instead, the class should be used as\n+     * <code>RandomStringUtils.random(5);</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public RandomStringUtils() {\n+      super();\n+    }\n+\n+    // Random\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of all characters.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @return the random string\n+     */\n+    public static String random(int count) {\n+        return random(count, false, false);\n+    }\n+\n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of characters whose\n+     * ASCII value is between <code>32</code> and <code>126</code> (inclusive).</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @return the random string\n+     */\n+    public static String randomAscii(int count) {\n+        return random(count, 32, 127, false, false);\n+    }\n+    \n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of alphabetic\n+     * characters.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @return the random string\n+     */\n+    public static String randomAlphabetic(int count) {\n+        return random(count, true, false);\n+    }\n+    \n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of alpha-numeric\n+     * characters.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @return the random string\n+     */\n+    public static String randomAlphanumeric(int count) {\n+        return random(count, true, true);\n+    }\n+    \n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of numeric\n+     * characters.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @return the random string\n+     */\n+    public static String randomNumeric(int count) {\n+        return random(count, false, true);\n+    }\n+\n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of alpha-numeric\n+     * characters as indicated by the arguments.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @param letters  if <code>true</code>, generated string will include\n+     *  alphabetic characters\n+     * @param numbers  if <code>true</code>, generated string will include\n+     *  numeric characters\n+     * @return the random string\n+     */\n+    public static String random(int count, boolean letters, boolean numbers) {\n+        return random(count, 0, 0, letters, numbers);\n+    }\n+    \n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of alpha-numeric\n+     * characters as indicated by the arguments.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @param start  the position in set of chars to start at\n+     * @param end  the position in set of chars to end before\n+     * @param letters  if <code>true</code>, generated string will include\n+     *  alphabetic characters\n+     * @param numbers  if <code>true</code>, generated string will include\n+     *  numeric characters\n+     * @return the random string\n+     */\n+    public static String random(int count, int start, int end, boolean letters, boolean numbers) {\n+        return random(count, start, end, letters, numbers, null, RANDOM);\n+    }\n+\n+    /**\n+     * <p>Creates a random string based on a variety of options, using\n+     * default source of randomness.</p>\n+     *\n+     * <p>This method has exactly the same semantics as\n+     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n+     * instead of using an externally supplied source of randomness, it uses\n+     * the internal static {@link Random} instance.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @param start  the position in set of chars to start at\n+     * @param end  the position in set of chars to end before\n+     * @param letters  only allow letters?\n+     * @param numbers  only allow numbers?\n+     * @param chars  the set of chars to choose randoms from.\n+     *  If <code>null</code>, then it will use the set of all chars.\n+     * @return the random string\n+     * @throws ArrayIndexOutOfBoundsException if there are not\n+     *  <code>(end - start) + 1</code> characters in the set array.\n+     */\n+    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n+        return random(count, start, end, letters, numbers, chars, RANDOM);\n+    }\n+\n+    /**\n+     * <p>Creates a random string based on a variety of options, using\n+     * supplied source of randomness.</p>\n+     *\n+     * <p>If start and end are both <code>0</code>, start and end are set\n+     * to <code>' '</code> and <code>'z'</code>, the ASCII printable\n+     * characters, will be used, unless letters and numbers are both\n+     * <code>false</code>, in which case, start and end are set to\n+     * <code>0</code> and <code>Integer.MAX_VALUE</code>.\n+     *\n+     * <p>If set is not <code>null</code>, characters between start and\n+     * end are chosen.</p>\n+     *\n+     * <p>This method accepts a user-supplied {@link Random}\n+     * instance to use as a source of randomness. By seeding a single \n+     * {@link Random} instance with a fixed seed and using it for each call,\n+     * the same random sequence of strings can be generated repeatedly\n+     * and predictably.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @param start  the position in set of chars to start at\n+     * @param end  the position in set of chars to end before\n+     * @param letters  only allow letters?\n+     * @param numbers  only allow numbers?\n+     * @param chars  the set of chars to choose randoms from.\n+     *  If <code>null</code>, then it will use the set of all chars.\n+     * @param random  a source of randomness.\n+     * @return the random string\n+     * @throws ArrayIndexOutOfBoundsException if there are not\n+     *  <code>(end - start) + 1</code> characters in the set array.\n+     * @throws IllegalArgumentException if <code>count</code> &lt; 0.\n+     * @since 2.0\n+     */\n+    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n+                                char[] chars, Random random) {\n+        if (count == 0) {\n+            return \"\";\n+        } else if (count < 0) {\n+            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n+        }\n+        if ((start == 0) && (end == 0)) {\n+            end = 'z' + 1;\n+            start = ' ';\n+            if (!letters && !numbers) {\n+                start = 0;\n+                end = Integer.MAX_VALUE;\n+            }\n+        }\n+\n+        char[] buffer = new char[count];\n+        int gap = end - start;\n+\n+        while (count-- != 0) {\n+            char ch;\n+            if (chars == null) {\n+                ch = (char) (random.nextInt(gap) + start);\n+            } else {\n+                ch = chars[random.nextInt(gap) + start];\n+            }\n+            if ((letters && Character.isLetter(ch))\n+                || (numbers && Character.isDigit(ch))\n+                || (!letters && !numbers)) \n+            {\n+                if(ch >= 56320 && ch <= 57343) {\n+                    if(count == 0) {\n+                        count++;\n+                    } else {\n+                        // low surrogate, insert high surrogate after putting it in\n+                        buffer[count] = ch;\n+                        count--;\n+                        buffer[count] = (char) (55296 + random.nextInt(128));\n+                    }\n+                } else if(ch >= 55296 && ch <= 56191) {\n+                    if(count == 0) {\n+                        count++;\n+                    } else {\n+                        // high surrogate, insert low surrogate before putting it in\n+                        buffer[count] = (char) (56320 + random.nextInt(128));\n+                        count--;\n+                        buffer[count] = ch;\n+                    }\n+                } else if(ch >= 56192 && ch <= 56319) {\n+                    // private high surrogate, no effing clue, so skip it\n+                    count++;\n+                } else {\n+                    buffer[count] = ch;\n+                }\n+            } else {\n+                count++;\n+            }\n+        }\n+        return new String(buffer);\n+    }\n+\n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of characters\n+     * specified.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @param chars  the String containing the set of characters to use,\n+     *  may be null\n+     * @return the random string\n+     * @throws IllegalArgumentException if <code>count</code> &lt; 0.\n+     */\n+    public static String random(int count, String chars) {\n+        if (chars == null) {\n+            return random(count, 0, 0, false, false, null, RANDOM);\n+        }\n+        return random(count, chars.toCharArray());\n+    }\n+\n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of characters specified.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @param chars  the character array containing the set of characters to use,\n+     *  may be null\n+     * @return the random string\n+     * @throws IllegalArgumentException if <code>count</code> &lt; 0.\n+     */\n+    public static String random(int count, char[] chars) {\n+        if (chars == null) {\n+            return random(count, 0, 0, false, false, null, RANDOM);\n+        }\n+        return random(count, 0, chars.length, false, false, chars, RANDOM);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/Range.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+\n+/**\n+ * <p><code>Range</code> represents a range of numbers of the same type.</p>\n+ * \n+ * @author Apache Software Foundation\n+ * @since 3.0\n+ * @version $Id: Range.java 830032 2009-10-27 00:15:00Z scolebourne $\n+ */\n+// TODO: Make class final and use fields instead of getters?\n+public class Range<T> implements Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private final Comparator<T> comparator;\n+    private final T minimum;\n+    private final T maximum;\n+\n+    /**\n+     * <p>Constructs a new <code>Range</code> using the specified\n+     * element as both the minimum and maximum in this range.</p>\n+     * <p>The range uses the natural ordering of the elements to \n+     * determine where values lie in the range.</p>\n+     *\n+     * @param element  the value to use for this range, must not be <code>null</code>\n+     * @throws IllegalArgumentException if the value is <code>null</code>\n+     * @throws ClassCastException if the value is not Comparable\n+     */\n+    public static <T extends Comparable<T>> Range<T> is(T element) {\n+        return new Range<T>(element, element, ComparableComparator.<T>getInstance());\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>Range</code> with the specified\n+     * minimum and maximum values (both inclusive).</p>\n+     * <p>The range uses the natural ordering of the elements to \n+     * determine where values lie in the range.</p>\n+     *\n+     * <p>The arguments may be passed in the order (min,max) or (max,min). The\n+     * getMinimum and getMaximum methods will return the correct values.</p>\n+     *\n+     * @param element1  first value that defines the edge of the range, inclusive\n+     * @param element2  second value that defines the edge of the range, inclusive\n+     * @throws IllegalArgumentException if either value is <code>null</code>\n+     * @throws ClassCastException if either value is not Comparable\n+     */\n+    public static <T extends Comparable<T>> Range<T> between(T element1, T element2) {\n+        return new Range<T>( element1, element2, ComparableComparator.<T>getInstance());\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>Range</code> using the specified\n+     * element as both the minimum and maximum in this range.</p>\n+     * <p>The range uses the passed in <code>Comparator</code> to \n+     * determine where values lie in the range.</p>\n+     *\n+     * @param element  the value to use for this range, must not be <code>null</code>\n+     * @param c comparator to be used\n+     * @throws IllegalArgumentException if the value is <code>null</code>\n+     */\n+    public static <T> Range<T> is(T element, Comparator<T> c) {\n+        return new Range<T>(element, element, c);\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>Range</code> with the specified\n+     * minimum and maximum values (both inclusive).</p>\n+     * <p>The range uses the passed in <code>Comparator</code> to \n+     * determine where values lie in the range.</p>\n+     *\n+     * <p>The arguments may be passed in the order (min,max) or (max,min). The\n+     * getMinimum and getMaximum methods will return the correct values.</p>\n+     *\n+     * @param element1  first value that defines the edge of the range, inclusive\n+     * @param element2  second value that defines the edge of the range, inclusive\n+     * @param c comparator to be used\n+     * @throws IllegalArgumentException if either value is <code>null</code>\n+     */\n+    public static <T> Range<T> between(T element1, T element2, Comparator<T> c) {\n+        return new Range<T>(element1, element2, c);\n+    }\n+\n+    private Range(T element1, T element2, Comparator<T> c) {\n+        if(element1 == null || element2 == null) {\n+            throw new IllegalArgumentException(\"Elements in a range must not be null: element1=\" + \n+                                               element1 + \", element2=\" + element2);\n+        }\n+\n+        if(c == null) {\n+            throw new IllegalArgumentException(\"Comparator must not be null\");\n+        }\n+\n+        if(c.compare(element1, element2) < 1) {\n+            this.minimum = element1;\n+            this.maximum = element2;\n+        } else {\n+            this.minimum = element2;\n+            this.maximum = element1;\n+        }\n+        this.comparator = c;\n+    }\n+\n+    // Accessors\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the minimum value in this range.</p>\n+     *\n+     * @return the minimum value in this range\n+     */\n+    public T getMinimum() {\n+        return this.minimum;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum value in this range.</p>\n+     *\n+     * @return the maximum value in this range\n+     */\n+    public T getMaximum() {\n+        return this.maximum;\n+    }\n+\n+    /**\n+     * <p>Gets the comparator being used to determine if objects are within the range. </p>\n+     *\n+     * @return the comparator being used\n+     */\n+    public Comparator<T> getComparator() {\n+        return this.comparator;\n+    }\n+\n+    /**\n+     * <p>Whether or not the Range is using the default natural comparison method \n+     * to compare elements. </p>\n+     *\n+     * @return whether or not the default Comparator is in use\n+     */\n+    public boolean isDefaultNaturalOrdering() {\n+        return this.comparator == ComparableComparator.INSTANCE;\n+    }\n+\n+    // Include tests\n+    //--------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Tests whether the specified element occurs within this range.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     *\n+     * @param element  the element to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified element occurs within this range\n+     */\n+    public boolean contains(T element) {\n+        if(element == null) {\n+            return false;\n+        }\n+        return (comparator.compare(element, getMinimum()) > -1) && (comparator.compare(element, getMaximum()) < 1);\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified element occurs before this range.</p>\n+     *\n+     * @param element  the element to test\n+     * @return <code>true</code> if the specified element occurs before this range\n+     */\n+    public boolean elementBefore(T element) {\n+        if (element == null) {\n+            return false; // ??\n+        }\n+        \n+        return this.comparator.compare(element, getMinimum()) < 0;\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified element occurs after this range.</p>\n+     *\n+     * @param element  the element to test\n+     * @return <code>true</code> if the specified element occurs after this range\n+     */\n+    public boolean elementAfter(T element) {\n+        if (element == null) {\n+            return false; // ??\n+        }\n+        \n+        return this.comparator.compare(element, getMaximum()) > 0;\n+    }\n+\n+    /**\n+     * <p>Tests where the specified element occurs relative to this range.</p>\n+     * <p>The API is reminiscent of the Comparable interface returning <code>-1</code> if \n+     * the element is before the range, <code>0</code> if contained within the range and \n+     * <code>1</code> if the element is after the range. </p>\n+     *\n+     * @param element  the element to test\n+     * @return -1, 0 or +1 depending on the element's location relative to the range\n+     */\n+    public int elementCompareTo(T element) {\n+        if(element == null) {\n+            // Comparable API says throw NPE on null\n+            throw new NullPointerException(\"Element is null\");\n+        }\n+        if(elementBefore(element)) {\n+            return -1;\n+        } else\n+        if(elementAfter(element)) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    // Range tests\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Tests whether the specified range occurs entirely within this range.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     * \n+     * @param range  the range to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified range occurs entirely within\n+     *  this range; otherwise, <code>false</code>\n+     * @throws IllegalArgumentException if the <code>Range</code> cannot be compared\n+     */\n+    public boolean containsRange(Range<T> range) {\n+        if (range == null) {\n+            return false;\n+        }\n+        return contains(range.getMinimum()) \n+            && contains(range.getMaximum());\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified range overlaps with this range.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     * \n+     * @param range  the range to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified range overlaps with this\n+     *  range; otherwise, <code>false</code>\n+     * @throws IllegalArgumentException if the <code>Range</code> cannot be compared\n+     */\n+    public boolean overlapsRange(Range<T> range) {\n+        if (range == null) {\n+            return false;\n+        }\n+        return range.contains(getMinimum())\n+            || range.contains(getMaximum())\n+            || contains(range.getMinimum());\n+    }\n+\n+    // Basics\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Compares this range to another object to test if they are equal.</p>.\n+     * \n+     * <p>To be equal, the class, minimum and maximum must be equal.</p>\n+     * \n+     * @param obj the reference object with which to compare\n+     * @return <code>true</code> if this object is equal\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        } else if (obj == null || obj.getClass() != getClass()) {\n+            return false;\n+        } else {\n+            @SuppressWarnings(\"unchecked\") // OK because we checked the class above\n+            Range<T> range = (Range<T>) obj;\n+            return getMinimum().equals(range.getMinimum()) &&\n+                   getMaximum().equals(range.getMaximum());\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets a hashCode for the range.</p>\n+     * \n+     * @return a hash code value for this object\n+     */\n+    @Override\n+    public int hashCode() {\n+        int result = 17;\n+        result = 37 * result + getClass().hashCode();\n+        result = 37 * result + getMinimum().hashCode();\n+        result = 37 * result + getMaximum().hashCode();\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Gets the range as a <code>String</code>.</p>\n+     *\n+     * <p>The format of the String is 'Range[<i>min</i>,<i>max</i>]'.</p>\n+     * \n+     * @return the <code>String</code> representation of this range\n+     */\n+    @Override\n+    public String toString() {\n+        StringBuilder buf = new StringBuilder(32);\n+        buf.append(\"Range[\");\n+        buf.append(getMinimum());\n+        buf.append(',');\n+        buf.append(getMaximum());\n+        buf.append(']');\n+        return buf.toString();\n+    }\n+\n+\n+    // Taken from Commons Collections - documentation removed as not a public class\n+    private static class ComparableComparator<E extends Comparable<? super E>> implements Comparator<E> {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public static final ComparableComparator<?> INSTANCE = new ComparableComparator();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public static <E extends Comparable<? super E>> ComparableComparator<E> getInstance() {\n+            return (ComparableComparator<E>) INSTANCE;\n+        }\n+\n+        public ComparableComparator() {\n+            super();\n+        }\n+\n+        public int compare(E obj1, E obj2) {\n+            return obj1.compareTo(obj2);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return \"ComparableComparator\".hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(Object object) {\n+            return (this == object) || \n+                   ((null != object) && (object.getClass().equals(this.getClass())));\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/SerializationException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+/**\n+ * <p>Exception thrown when the Serialization process fails.</p>\n+ *\n+ * <p>The original error is wrapped within this one.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class SerializationException extends RuntimeException {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 4029025366392702726L;\n+\n+    /**\n+     * <p>Constructs a new <code>SerializationException</code> without specified\n+     * detail message.</p>\n+     */\n+    public SerializationException() {\n+        super();\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>SerializationException</code> with specified\n+     * detail message.</p>\n+     *\n+     * @param msg  The error message.\n+     */\n+    public SerializationException(String msg) {\n+        super(msg);\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>SerializationException</code> with specified\n+     * nested <code>Throwable</code>.</p>\n+     *\n+     * @param cause  The <code>Exception</code> or <code>Error</code>\n+     *  that caused this exception to be thrown.\n+     */\n+    public SerializationException(Throwable cause) {\n+        super(cause);\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>SerializationException</code> with specified\n+     * detail message and nested <code>Throwable</code>.</p>\n+     *\n+     * @param msg    The error message.\n+     * @param cause  The <code>Exception</code> or <code>Error</code>\n+     *  that caused this exception to be thrown.\n+     */\n+    public SerializationException(String msg, Throwable cause) {\n+        super(msg, cause);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/SerializationUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+\n+/**\n+ * <p>Assists with the serialization process and performs additional functionality based \n+ * on serialization.</p>\n+ * <p>\n+ * <ul>\n+ * <li>Deep clone using serialization\n+ * <li>Serialize managing finally and IOException\n+ * <li>Deserialize managing finally and IOException\n+ * </ul>\n+ *\n+ * <p>This class throws exceptions for invalid <code>null</code> inputs.\n+ * Each method documents its behaviour in more detail.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:nissim@nksystems.com\">Nissim Karpenstein</a>\n+ * @author <a href=\"mailto:janekdb@yahoo.co.uk\">Janek Bogucki</a>\n+ * @author Daniel L. Rall\n+ * @author Jeff Varszegi\n+ * @author Gary Gregory\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class SerializationUtils {\n+    \n+    /**\n+     * <p>SerializationUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>SerializationUtils.clone(object)</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     * @since 2.0\n+     */\n+    public SerializationUtils() {\n+        super();\n+    }\n+\n+    // Clone\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Deep clone an <code>Object</code> using serialization.</p>\n+     *\n+     * <p>This is many times slower than writing clone methods by hand\n+     * on all objects in your object graph. However, for complex object\n+     * graphs, or for those that don't support deep cloning this can\n+     * be a simple alternative implementation. Of course all the objects\n+     * must be <code>Serializable</code>.</p>\n+     * \n+     * @param object  the <code>Serializable</code> object to clone\n+     * @return the cloned object\n+     * @throws SerializationException (runtime) if the serialization fails\n+     */\n+    public static Object clone(Serializable object) {\n+        return deserialize(serialize(object));\n+    }\n+    \n+    // Serialize\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Serializes an <code>Object</code> to the specified stream.</p>\n+     *\n+     * <p>The stream will be closed once the object is written.\n+     * This avoids the need for a finally clause, and maybe also exception\n+     * handling, in the application code.</p>\n+     * \n+     * <p>The stream passed in is not buffered internally within this method.\n+     * This is the responsibility of your application if desired.</p>\n+     *\n+     * @param obj  the object to serialize to bytes, may be null\n+     * @param outputStream  the stream to write to, must not be null\n+     * @throws IllegalArgumentException if <code>outputStream</code> is <code>null</code>\n+     * @throws SerializationException (runtime) if the serialization fails\n+     */\n+    public static void serialize(Serializable obj, OutputStream outputStream) {\n+        if (outputStream == null) {\n+            throw new IllegalArgumentException(\"The OutputStream must not be null\");\n+        }\n+        ObjectOutputStream out = null;\n+        try {\n+            // stream closed in the finally\n+            out = new ObjectOutputStream(outputStream);\n+            out.writeObject(obj);\n+            \n+        } catch (IOException ex) {\n+            throw new SerializationException(ex);\n+        } finally {\n+            try {\n+                if (out != null) {\n+                    out.close();\n+                }\n+            } catch (IOException ex) {\n+                // ignore close exception\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Serializes an <code>Object</code> to a byte array for\n+     * storage/serialization.</p>\n+     *\n+     * @param obj  the object to serialize to bytes\n+     * @return a byte[] with the converted Serializable\n+     * @throws SerializationException (runtime) if the serialization fails\n+     */\n+    public static byte[] serialize(Serializable obj) {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream(512);\n+        serialize(obj, baos);\n+        return baos.toByteArray();\n+    }\n+\n+    // Deserialize\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Deserializes an <code>Object</code> from the specified stream.</p>\n+     *\n+     * <p>The stream will be closed once the object is written. This\n+     * avoids the need for a finally clause, and maybe also exception\n+     * handling, in the application code.</p>\n+     * \n+     * <p>The stream passed in is not buffered internally within this method.\n+     * This is the responsibility of your application if desired.</p>\n+     *\n+     * @param inputStream  the serialized object input stream, must not be null\n+     * @return the deserialized object\n+     * @throws IllegalArgumentException if <code>inputStream</code> is <code>null</code>\n+     * @throws SerializationException (runtime) if the serialization fails\n+     */\n+    public static Object deserialize(InputStream inputStream) {\n+        if (inputStream == null) {\n+            throw new IllegalArgumentException(\"The InputStream must not be null\");\n+        }\n+        ObjectInputStream in = null;\n+        try {\n+            // stream closed in the finally\n+            in = new ObjectInputStream(inputStream);\n+            return in.readObject();\n+            \n+        } catch (ClassNotFoundException ex) {\n+            throw new SerializationException(ex);\n+        } catch (IOException ex) {\n+            throw new SerializationException(ex);\n+        } finally {\n+            try {\n+                if (in != null) {\n+                    in.close();\n+                }\n+            } catch (IOException ex) {\n+                // ignore close exception\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Deserializes a single <code>Object</code> from an array of bytes.</p>\n+     *\n+     * @param objectData  the serialized object, must not be null\n+     * @return the deserialized object\n+     * @throws IllegalArgumentException if <code>objectData</code> is <code>null</code>\n+     * @throws SerializationException (runtime) if the serialization fails\n+     */\n+    public static Object deserialize(byte[] objectData) {\n+        if (objectData == null) {\n+            throw new IllegalArgumentException(\"The byte[] must not be null\");\n+        }\n+        ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n+        return deserialize(bais);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/StringEscapeUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import org.apache.commons.lang.text.translate.*;\n+\n+/**\n+ * <p>Escapes and unescapes <code>String</code>s for\n+ * Java, Java Script, HTML and XML.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Apache Jakarta Turbine\n+ * @author Purple Technology\n+ * @author <a href=\"mailto:alex@purpletech.com\">Alexander Day Chaffee</a>\n+ * @author Antony Riley\n+ * @author Helge Tesgaard\n+ * @author <a href=\"sean@boohai.com\">Sean Brown</a>\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author Phil Steitz\n+ * @author Pete Gieser\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class StringEscapeUtils {\n+\n+    /* ESCAPE TRANSLATORS */\n+\n+    public static final CharSequenceTranslator ESCAPE_JAVA = \n+          new LookupTranslator(\n+            new String[][] { \n+              {\"\\\"\", \"\\\\\\\"\"},\n+              {\"\\\\\", \"\\\\\\\\\"},\n+          }).with(\n+            new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())\n+          ).with(\n+            UnicodeEscaper.outsideOf(32, 0x7f) \n+        );\n+\n+    public static final CharSequenceTranslator ESCAPE_ECMASCRIPT = \n+        new AggregateTranslator(\n+            new LookupTranslator(\n+                      new String[][] { \n+                            {\"'\", \"\\\\'\"},\n+                            {\"\\\"\", \"\\\\\\\"\"},\n+                            {\"\\\\\", \"\\\\\\\\\"},\n+                            {\"/\", \"\\\\/\"}\n+                      }),\n+            new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()),\n+            UnicodeEscaper.outsideOf(32, 0x7f) \n+        );\n+            \n+    public static final CharSequenceTranslator ESCAPE_XML = \n+        new AggregateTranslator(\n+            new LookupTranslator(EntityArrays.BASIC_ESCAPE()),\n+            new LookupTranslator(EntityArrays.APOS_ESCAPE())\n+        );\n+\n+    public static final CharSequenceTranslator ESCAPE_HTML3 = \n+        new AggregateTranslator(\n+            new LookupTranslator(EntityArrays.BASIC_ESCAPE()),\n+            new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE())\n+        );\n+\n+    public static final CharSequenceTranslator ESCAPE_HTML4 = \n+        new AggregateTranslator(\n+            new LookupTranslator(EntityArrays.BASIC_ESCAPE()),\n+            new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()),\n+            new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE())\n+        );\n+\n+    public static final CharSequenceTranslator ESCAPE_CSV = new CsvEscaper();\n+\n+    // TODO: Create a parent class - 'SinglePassTranslator' ?\n+    // TODO: It would handle the index checking, and length returning, and \n+    // TODO: could also have an optimization check method.\n+    static class CsvEscaper extends CharSequenceTranslator {\n+\n+        private static final char CSV_DELIMITER = ',';\n+        private static final char CSV_QUOTE = '\"';\n+        private static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\n+        private static final char[] CSV_SEARCH_CHARS = new char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n+\n+        // TODO: Replace with a RegexTranslator. That should consume the number of characters the regex uses up?\n+        @Override\n+        public int translate(CharSequence input, int index, Writer out) throws IOException {\n+\n+            if(index != 0) {\n+                throw new IllegalStateException(\"CsvEscaper should never reach the [1] index\");\n+            }\n+\n+            if (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\n+                out.write(input.toString());\n+            } else {\n+                out.write(CSV_QUOTE);\n+                out.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\n+                out.write(CSV_QUOTE);\n+            }\n+            return input.length();\n+        }\n+    }\n+\n+    /* UNESCAPE TRANSLATORS */\n+\n+    // TODO: throw \"illegal character: \\92\" as an Exception if a \\ on the end of the Java (as per the compiler)?\n+    public static final CharSequenceTranslator UNESCAPE_JAVA = \n+        new AggregateTranslator(\n+            new UnicodeUnescaper(),\n+            new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()),\n+            new LookupTranslator(\n+                      new String[][] { \n+                            {\"\\\\\\\\\", \"\\\\\"},\n+                            {\"\\\\\\\"\", \"\\\"\"},\n+                            {\"\\\\'\", \"'\"},\n+                            {\"\\\\\", \"\"}\n+                      })\n+        );\n+\n+    public static final CharSequenceTranslator UNESCAPE_ECMASCRIPT = UNESCAPE_JAVA;\n+\n+    public static final CharSequenceTranslator UNESCAPE_HTML3 = \n+        new AggregateTranslator(\n+            new LookupTranslator(EntityArrays.BASIC_UNESCAPE()),\n+            new LookupTranslator(EntityArrays.ISO8859_1_UNESCAPE()),\n+            new NumericEntityUnescaper()\n+        );\n+\n+    public static final CharSequenceTranslator UNESCAPE_HTML4 = \n+        new AggregateTranslator(\n+            new LookupTranslator(EntityArrays.BASIC_UNESCAPE()),\n+            new LookupTranslator(EntityArrays.ISO8859_1_UNESCAPE()),\n+            new LookupTranslator(EntityArrays.HTML40_EXTENDED_UNESCAPE()),\n+            new NumericEntityUnescaper()\n+        );\n+\n+    public static final CharSequenceTranslator UNESCAPE_XML = \n+        new AggregateTranslator(\n+            new LookupTranslator(EntityArrays.BASIC_UNESCAPE()),\n+            new LookupTranslator(EntityArrays.APOS_UNESCAPE()),\n+            new NumericEntityUnescaper()\n+        );\n+\n+    public static final CharSequenceTranslator UNESCAPE_CSV = new CsvUnescaper();\n+\n+    static class CsvUnescaper extends CharSequenceTranslator {\n+\n+        private static final char CSV_DELIMITER = ',';\n+        private static final char CSV_QUOTE = '\"';\n+        private static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\n+        private static final char[] CSV_SEARCH_CHARS = new char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n+\n+        // TODO: Replace with a RegexTranslator. That should consume the number of characters the regex uses up?\n+        @Override\n+        public int translate(CharSequence input, int index, Writer out) throws IOException {\n+\n+            if(index != 0) {\n+                throw new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n+            }\n+\n+            if ( input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE ) {\n+                out.write(input.toString());\n+                return input.length();\n+            }\n+\n+            // strip quotes\n+            String quoteless = input.subSequence(1, input.length() - 1).toString();\n+\n+            if ( StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS) ) {\n+                // deal with escaped quotes; ie) \"\"\n+                out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n+            } else {\n+                out.write(input.toString());\n+            }\n+            return input.length();\n+        }\n+    }\n+\n+    /* Helper functions */\n+\n+    /**\n+     * <p><code>StringEscapeUtils</code> instances should NOT be constructed in\n+     * standard programming.</p>\n+     *\n+     * <p>Instead, the class should be used as:\n+     * <pre>StringEscapeUtils.escapeJava(\"foo\");</pre></p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public StringEscapeUtils() {\n+      super();\n+    }\n+\n+    // Java and JavaScript\n+    //--------------------------------------------------------------------------\n+    /**\n+     * <p>Escapes the characters in a <code>String</code> using Java String rules.</p>\n+     *\n+     * <p>Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n+     *\n+     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n+     * <code>'t'</code>.</p>\n+     *\n+     * <p>The only difference between Java strings and JavaScript strings\n+     * is that in JavaScript, a single quote and forward-slash (/) are escaped.</p>\n+     *\n+     * <p>Example:\n+     * <pre>\n+     * input string: He didn't say, \"Stop!\"\n+     * output string: He didn't say, \\\"Stop!\\\"\n+     * </pre>\n+     * </p>\n+     *\n+     * @param input  String to escape values in, may be null\n+     * @return String with escaped values, <code>null</code> if null string input\n+     */\n+    public static final String escapeJava(String input) {\n+        return ESCAPE_JAVA.translate(input);\n+    }\n+\n+    /**\n+     * <p>Escapes the characters in a <code>String</code> using EcmaScript String rules.</p>\n+     * <p>Escapes any values it finds into their EcmaScript String form.\n+     * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n+     *\n+     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n+     * <code>'t'</code>.</p>\n+     *\n+     * <p>The only difference between Java strings and EcmaScript strings\n+     * is that in EcmaScript, a single quote and forward-slash (/) are escaped.</p>\n+     *\n+     * <p>Note that EcmaScript is best known by the JavaScript and ActionScript dialects. </p>\n+     *\n+     * <p>Example:\n+     * <pre>\n+     * input string: He didn't say, \"Stop!\"\n+     * output string: He didn\\'t say, \\\"Stop!\\\"\n+     * </pre>\n+     * </p>\n+     *\n+     * @param input  String to escape values in, may be null\n+     * @return String with escaped values, <code>null</code> if null string input\n+     */\n+    public static final String escapeEcmaScript(String input) {\n+        return ESCAPE_ECMASCRIPT.translate(input);\n+    }\n+\n+    /**\n+     * <p>Unescapes any Java literals found in the <code>String</code>.\n+     * For example, it will turn a sequence of <code>'\\'</code> and\n+     * <code>'n'</code> into a newline character, unless the <code>'\\'</code>\n+     * is preceded by another <code>'\\'</code>.</p>\n+     * \n+     * @param input  the <code>String</code> to unescape, may be null\n+     * @return a new unescaped <code>String</code>, <code>null</code> if null string input\n+     */\n+    public static final String unescapeJava(String input) {\n+        return UNESCAPE_JAVA.translate(input);\n+    }\n+\n+    /**\n+     * <p>Unescapes any EcmaScript literals found in the <code>String</code>.</p>\n+     *\n+     * <p>For example, it will turn a sequence of <code>'\\'</code> and <code>'n'</code>\n+     * into a newline character, unless the <code>'\\'</code> is preceded by another\n+     * <code>'\\'</code>.</p>\n+     *\n+     * @see #unescapeJava(String)\n+     * @param input  the <code>String</code> to unescape, may be null\n+     * @return A new unescaped <code>String</code>, <code>null</code> if null string input\n+     */\n+    public static final String unescapeEcmaScript(String input) {\n+        return UNESCAPE_ECMASCRIPT.translate(input);\n+    }\n+\n+    // HTML and XML\n+    //--------------------------------------------------------------------------\n+    /**\n+     * <p>Escapes the characters in a <code>String</code> using HTML entities.</p>\n+     *\n+     * <p>\n+     * For example:\n+     * </p> \n+     * <p><code>\"bread\" & \"butter\"</code></p>\n+     * becomes:\n+     * <p>\n+     * <code>&amp;quot;bread&amp;quot; &amp;amp; &amp;quot;butter&amp;quot;</code>.\n+     * </p>\n+     *\n+     * <p>Supports all known HTML 4.0 entities, including funky accents.\n+     * Note that the commonly used apostrophe escape character (&amp;apos;)\n+     * is not a legal entity and so is not supported). </p>\n+     *\n+     * @param input  the <code>String</code> to escape, may be null\n+     * @return a new escaped <code>String</code>, <code>null</code> if null string input\n+     * \n+     * @see <a href=\"http://hotwired.lycos.com/webmonkey/reference/special_characters/\">ISO Entities</a>\n+     * @see <a href=\"http://www.w3.org/TR/REC-html32#latin1\">HTML 3.2 Character Entities for ISO Latin-1</a>\n+     * @see <a href=\"http://www.w3.org/TR/REC-html40/sgml/entities.html\">HTML 4.0 Character entity references</a>\n+     * @see <a href=\"http://www.w3.org/TR/html401/charset.html#h-5.3\">HTML 4.01 Character References</a>\n+     * @see <a href=\"http://www.w3.org/TR/html401/charset.html#code-position\">HTML 4.01 Code positions</a>\n+     */\n+    public static final String escapeHtml4(String input) {\n+        return ESCAPE_HTML4.translate(input);\n+    }\n+\n+    public static final String escapeHtml3(String input) {\n+        return ESCAPE_HTML3.translate(input);\n+    }\n+                \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Unescapes a string containing entity escapes to a string\n+     * containing the actual Unicode characters corresponding to the\n+     * escapes. Supports HTML 4.0 entities.</p>\n+     *\n+     * <p>For example, the string \"&amp;lt;Fran&amp;ccedil;ais&amp;gt;\"\n+     * will become \"&lt;Fran&ccedil;ais&gt;\"</p>\n+     *\n+     * <p>If an entity is unrecognized, it is left alone, and inserted\n+     * verbatim into the result string. e.g. \"&amp;gt;&amp;zzzz;x\" will\n+     * become \"&gt;&amp;zzzz;x\".</p>\n+     *\n+     * @param input  the <code>String</code> to unescape, may be null\n+     * @return a new unescaped <code>String</code>, <code>null</code> if null string input\n+     */\n+    public static final String unescapeHtml4(String input) {\n+        return UNESCAPE_HTML4.translate(input);\n+    }\n+\n+    public static final String unescapeHtml3(String input) {\n+        return UNESCAPE_HTML3.translate(input);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Escapes the characters in a <code>String</code> using XML entities.</p>\n+     *\n+     * <p>For example: <tt>\"bread\" & \"butter\"</tt> =>\n+     * <tt>&amp;quot;bread&amp;quot; &amp;amp; &amp;quot;butter&amp;quot;</tt>.\n+     * </p>\n+     *\n+     * <p>Supports only the five basic XML entities (gt, lt, quot, amp, apos).\n+     * Does not support DTDs or external entities.</p>\n+     *\n+     * <p>Note that unicode characters greater than 0x7f are as of 3.0, no longer \n+     *    escaped. </p>\n+     *\n+     * @param input  the <code>String</code> to escape, may be null\n+     * @return a new escaped <code>String</code>, <code>null</code> if null string input\n+     * @see #unescapeXml(java.lang.String)\n+     */\n+    public static final String escapeXml(String input) {\n+        return ESCAPE_XML.translate(input);\n+    }\n+                \n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Unescapes a string containing XML entity escapes to a string\n+     * containing the actual Unicode characters corresponding to the\n+     * escapes.</p>\n+     *\n+     * <p>Supports only the five basic XML entities (gt, lt, quot, amp, apos).\n+     * Does not support DTDs or external entities.</p>\n+     *\n+     * <p>Note that numerical \\\\u unicode codes are unescaped to their respective \n+     *    unicode characters. This may change in future releases. </p>\n+     *\n+     * @param input  the <code>String</code> to unescape, may be null\n+     * @return a new unescaped <code>String</code>, <code>null</code> if null string input\n+     * @see #escapeXml(String)\n+     */\n+    public static final String unescapeXml(String input) {\n+        return UNESCAPE_XML.translate(input);\n+    }\n+                \n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * <p>Returns a <code>String</code> value for a CSV column enclosed in double quotes,\n+     * if required.</p>\n+     *\n+     * <p>If the value contains a comma, newline or double quote, then the\n+     *    String value is returned enclosed in double quotes.</p>\n+     * </p>\n+     *\n+     * <p>Any double quote characters in the value are escaped with another double quote.</p>\n+     *\n+     * <p>If the value does not contain a comma, newline or double quote, then the\n+     *    String value is returned unchanged.</p>\n+     * </p>\n+     *\n+     * see <a href=\"http://en.wikipedia.org/wiki/Comma-separated_values\">Wikipedia</a> and\n+     * <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n+     *\n+     * @param input the input CSV column String, may be null\n+     * @return the input String, enclosed in double quotes if the value contains a comma,\n+     * newline or double quote, <code>null</code> if null string input\n+     * @since 2.4\n+     */\n+    public static final String escapeCsv(String input) {\n+        return ESCAPE_CSV.translate(input);\n+    }\n+\n+    /**\n+     * <p>Returns a <code>String</code> value for an unescaped CSV column. </p>\n+     *\n+     * <p>If the value is enclosed in double quotes, and contains a comma, newline \n+     *    or double quote, then quotes are removed. \n+     * </p>\n+     *\n+     * <p>Any double quote escaped characters (a pair of double quotes) are unescaped \n+     *    to just one double quote. </p>\n+     *\n+     * <p>If the value is not enclosed in double quotes, or is and does not contain a \n+     *    comma, newline or double quote, then the String value is returned unchanged.</p>\n+     * </p>\n+     *\n+     * see <a href=\"http://en.wikipedia.org/wiki/Comma-separated_values\">Wikipedia</a> and\n+     * <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n+     *\n+     * @param input the input CSV column String, may be null\n+     * @return the input String, with enclosing double quotes removed and embedded double \n+     * quotes unescaped, <code>null</code> if null string input\n+     * @since 2.4\n+     */\n+    public static final String unescapeCsv(String input) {\n+        return UNESCAPE_CSV.translate(input);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/StringUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+\n+/**\n+ * <p>Operations on {@link java.lang.String} that are\n+ * <code>null</code> safe.</p>\n+ *\n+ * <ul>\n+ *  <li><b>IsEmpty/IsBlank</b>\n+ *      - checks if a String contains text</li>\n+ *  <li><b>Trim/Strip</b>\n+ *      - removes leading and trailing whitespace</li>\n+ *  <li><b>Equals</b>\n+ *      - compares two strings null-safe</li>\n+ *  <li><b>startsWith</b>\n+ *      - check if a String starts with a prefix null-safe</li>\n+ *  <li><b>endsWith</b>\n+ *      - check if a String ends with a suffix null-safe</li>\n+ *  <li><b>IndexOf/LastIndexOf/Contains</b>\n+ *      - null-safe index-of checks\n+ *  <li><b>IndexOfAny/LastIndexOfAny/IndexOfAnyBut/LastIndexOfAnyBut</b>\n+ *      - index-of any of a set of Strings</li>\n+ *  <li><b>ContainsOnly/ContainsNone/ContainsAny</b>\n+ *      - does String contains only/none/any of these characters</li>\n+ *  <li><b>Substring/Left/Right/Mid</b>\n+ *      - null-safe substring extractions</li>\n+ *  <li><b>SubstringBefore/SubstringAfter/SubstringBetween</b>\n+ *      - substring extraction relative to other strings</li>\n+ *  <li><b>Split/Join</b>\n+ *      - splits a String into an array of substrings and vice versa</li>\n+ *  <li><b>Remove/Delete</b>\n+ *      - removes part of a String</li>\n+ *  <li><b>Replace/Overlay</b>\n+ *      - Searches a String and replaces one String with another</li>\n+ *  <li><b>Chomp/Chop</b>\n+ *      - removes the last part of a String</li>\n+ *  <li><b>LeftPad/RightPad/Center/Repeat</b>\n+ *      - pads a String</li>\n+ *  <li><b>UpperCase/LowerCase/SwapCase/Capitalize/Uncapitalize</b>\n+ *      - changes the case of a String</li>\n+ *  <li><b>CountMatches</b>\n+ *      - counts the number of occurrences of one String in another</li>\n+ *  <li><b>IsAlpha/IsNumeric/IsWhitespace/IsAsciiPrintable</b>\n+ *      - checks the characters in a String</li>\n+ *  <li><b>DefaultString</b>\n+ *      - protects against a null input String</li>\n+ *  <li><b>Reverse/ReverseDelimited</b>\n+ *      - reverses a String</li>\n+ *  <li><b>Abbreviate</b>\n+ *      - abbreviates a string using ellipsis</li>\n+ *  <li><b>Difference</b>\n+ *      - compares Strings and reports on their differences</li>\n+ *  <li><b>LevensteinDistance</b>\n+ *      - the number of changes needed to change one String into another</li>\n+ * </ul>\n+ *\n+ * <p>The <code>StringUtils</code> class defines certain words related to\n+ * String handling.</p>\n+ *\n+ * <ul>\n+ *  <li>null - <code>null</code></li>\n+ *  <li>empty - a zero-length string (<code>\"\"</code>)</li>\n+ *  <li>space - the space character (<code>' '</code>, char 32)</li>\n+ *  <li>whitespace - the characters defined by {@link Character#isWhitespace(char)}</li>\n+ *  <li>trim - the characters &lt;= 32 as in {@link String#trim()}</li>\n+ * </ul>\n+ *\n+ * <p><code>StringUtils</code> handles <code>null</code> input Strings quietly.\n+ * That is to say that a <code>null</code> input will return <code>null</code>.\n+ * Where a <code>boolean</code> or <code>int</code> is being returned\n+ * details vary by method.</p>\n+ *\n+ * <p>A side effect of the <code>null</code> handling is that a\n+ * <code>NullPointerException</code> should be considered a bug in\n+ * <code>StringUtils</code>.</p>\n+ *\n+ * <p>Methods in this class give sample code to explain their operation.\n+ * The symbol <code>*</code> is used to indicate any input including <code>null</code>.</p>\n+ *\n+ * @see java.lang.String\n+ * @author Apache Software Foundation\n+ * @author <a href=\"http://jakarta.apache.org/turbine/\">Apache Jakarta Turbine</a>\n+ * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n+ * @author Daniel L. Rall\n+ * @author <a href=\"mailto:gcoladonato@yahoo.com\">Greg Coladonato</a>\n+ * @author <a href=\"mailto:ed@apache.org\">Ed Korthof</a>\n+ * @author <a href=\"mailto:rand_mcneely@yahoo.com\">Rand McNeely</a>\n+ * @author <a href=\"mailto:fredrik@westermarck.com\">Fredrik Westermarck</a>\n+ * @author Holger Krauth\n+ * @author <a href=\"mailto:alex@purpletech.com\">Alexander Day Chaffee</a>\n+ * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n+ * @author Arun Mammen Thomas\n+ * @author Gary Gregory\n+ * @author Phil Steitz\n+ * @author Al Chou\n+ * @author Michael Davey\n+ * @author Reuben Sivan\n+ * @author Chris Hyzer\n+ * @author Scott Johnson\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+//@Immutable\n+public class StringUtils {\n+    // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n+    // Whitespace:\n+    // Character.isWhitespace() is faster than WHITESPACE.indexOf()\n+    // where WHITESPACE is a string of all whitespace characters\n+    //\n+    // Character access:\n+    // String.charAt(n) versus toCharArray(), then array[n]\n+    // String.charAt(n) is about 15% worse for a 10K string\n+    // They are about equal for a length 50 string\n+    // String.charAt(n) is about 4 times better for a length 3 string\n+    // String.charAt(n) is best bet overall\n+    //\n+    // Append:\n+    // String.concat about twice as fast as StringBuffer.append\n+    // (not sure who tested this)\n+\n+    /**\n+     * The empty String <code>\"\"</code>.\n+     * @since 2.0\n+     */\n+    public static final String EMPTY = \"\";\n+\n+    /**\n+     * Represents a failed index search.\n+     * @since 2.1\n+     */\n+    public static final int INDEX_NOT_FOUND = -1;\n+\n+    /**\n+     * <p>The maximum size to which the padding constant(s) can expand.</p>\n+     */\n+    private static final int PAD_LIMIT = 8192;\n+\n+    /**\n+     * <p><code>StringUtils</code> instances should NOT be constructed in\n+     * standard programming. Instead, the class should be used as\n+     * <code>StringUtils.trim(\" foo \");</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public StringUtils() {\n+        super();\n+    }\n+\n+    // Empty checks\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if a String is empty (\"\") or null.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isEmpty(null)      = true\n+     * StringUtils.isEmpty(\"\")        = true\n+     * StringUtils.isEmpty(\" \")       = false\n+     * StringUtils.isEmpty(\"bob\")     = false\n+     * StringUtils.isEmpty(\"  bob  \") = false\n+     * </pre>\n+     *\n+     * <p>NOTE: This method changed in Lang version 2.0.\n+     * It no longer trims the String.\n+     * That functionality is available in isBlank().</p>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if the String is empty or null\n+     */\n+    public static boolean isEmpty(CharSequence str) {\n+        return str == null || str.length() == 0;\n+    }\n+\n+    /**\n+     * <p>Checks if a String is not empty (\"\") and not null.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isNotEmpty(null)      = false\n+     * StringUtils.isNotEmpty(\"\")        = false\n+     * StringUtils.isNotEmpty(\" \")       = true\n+     * StringUtils.isNotEmpty(\"bob\")     = true\n+     * StringUtils.isNotEmpty(\"  bob  \") = true\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if the String is not empty and not null\n+     */\n+    public static boolean isNotEmpty(CharSequence str) {\n+        return !StringUtils.isEmpty(str);\n+    }\n+\n+    /**\n+     * <p>Checks if a String is whitespace, empty (\"\") or null.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isBlank(null)      = true\n+     * StringUtils.isBlank(\"\")        = true\n+     * StringUtils.isBlank(\" \")       = true\n+     * StringUtils.isBlank(\"bob\")     = false\n+     * StringUtils.isBlank(\"  bob  \") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if the String is null, empty or whitespace\n+     * @since 2.0\n+     */\n+    public static boolean isBlank(CharSequence str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return true;\n+        }\n+        for (int i = 0; i < strLen; i++) {\n+            if ((Character.isWhitespace(str.charAt(i)) == false)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if a String is not empty (\"\"), not null and not whitespace only.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isNotBlank(null)      = false\n+     * StringUtils.isNotBlank(\"\")        = false\n+     * StringUtils.isNotBlank(\" \")       = false\n+     * StringUtils.isNotBlank(\"bob\")     = true\n+     * StringUtils.isNotBlank(\"  bob  \") = true\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if the String is\n+     *  not empty and not null and not whitespace\n+     * @since 2.0\n+     */\n+    public static boolean isNotBlank(CharSequence str) {\n+        return !StringUtils.isBlank(str);\n+    }\n+\n+    // Trim\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Removes control characters (char &lt;= 32) from both\n+     * ends of this String, handling <code>null</code> by returning\n+     * <code>null</code>.</p>\n+     *\n+     * <p>The String is trimmed using {@link String#trim()}.\n+     * Trim removes start and end characters &lt;= 32.\n+     * To strip whitespace use {@link #strip(String)}.</p>\n+     *\n+     * <p>To trim your choice of characters, use the\n+     * {@link #strip(String, String)} methods.</p>\n+     *\n+     * <pre>\n+     * StringUtils.trim(null)          = null\n+     * StringUtils.trim(\"\")            = \"\"\n+     * StringUtils.trim(\"     \")       = \"\"\n+     * StringUtils.trim(\"abc\")         = \"abc\"\n+     * StringUtils.trim(\"    abc    \") = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to be trimmed, may be null\n+     * @return the trimmed string, <code>null</code> if null String input\n+     */\n+    public static String trim(String str) {\n+        return str == null ? null : str.trim();\n+    }\n+\n+    /**\n+     * <p>Removes control characters (char &lt;= 32) from both\n+     * ends of this String returning <code>null</code> if the String is\n+     * empty (\"\") after the trim or if it is <code>null</code>.\n+     *\n+     * <p>The String is trimmed using {@link String#trim()}.\n+     * Trim removes start and end characters &lt;= 32.\n+     * To strip whitespace use {@link #stripToNull(String)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.trimToNull(null)          = null\n+     * StringUtils.trimToNull(\"\")            = null\n+     * StringUtils.trimToNull(\"     \")       = null\n+     * StringUtils.trimToNull(\"abc\")         = \"abc\"\n+     * StringUtils.trimToNull(\"    abc    \") = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to be trimmed, may be null\n+     * @return the trimmed String,\n+     *  <code>null</code> if only chars &lt;= 32, empty or null String input\n+     * @since 2.0\n+     */\n+    public static String trimToNull(String str) {\n+        String ts = trim(str);\n+        return isEmpty(ts) ? null : ts;\n+    }\n+\n+    /**\n+     * <p>Removes control characters (char &lt;= 32) from both\n+     * ends of this String returning an empty String (\"\") if the String\n+     * is empty (\"\") after the trim or if it is <code>null</code>.\n+     *\n+     * <p>The String is trimmed using {@link String#trim()}.\n+     * Trim removes start and end characters &lt;= 32.\n+     * To strip whitespace use {@link #stripToEmpty(String)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.trimToEmpty(null)          = \"\"\n+     * StringUtils.trimToEmpty(\"\")            = \"\"\n+     * StringUtils.trimToEmpty(\"     \")       = \"\"\n+     * StringUtils.trimToEmpty(\"abc\")         = \"abc\"\n+     * StringUtils.trimToEmpty(\"    abc    \") = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to be trimmed, may be null\n+     * @return the trimmed String, or an empty String if <code>null</code> input\n+     * @since 2.0\n+     */\n+    public static String trimToEmpty(String str) {\n+        return str == null ? EMPTY : str.trim();\n+    }\n+\n+    // Stripping\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Strips whitespace from the start and end of a String.</p>\n+     *\n+     * <p>This is similar to {@link #trim(String)} but removes whitespace.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.strip(null)     = null\n+     * StringUtils.strip(\"\")       = \"\"\n+     * StringUtils.strip(\"   \")    = \"\"\n+     * StringUtils.strip(\"abc\")    = \"abc\"\n+     * StringUtils.strip(\"  abc\")  = \"abc\"\n+     * StringUtils.strip(\"abc  \")  = \"abc\"\n+     * StringUtils.strip(\" abc \")  = \"abc\"\n+     * StringUtils.strip(\" ab c \") = \"ab c\"\n+     * </pre>\n+     *\n+     * @param str  the String to remove whitespace from, may be null\n+     * @return the stripped String, <code>null</code> if null String input\n+     */\n+    public static String strip(String str) {\n+        return strip(str, null);\n+    }\n+\n+    /**\n+     * <p>Strips whitespace from the start and end of a String  returning\n+     * <code>null</code> if the String is empty (\"\") after the strip.</p>\n+     *\n+     * <p>This is similar to {@link #trimToNull(String)} but removes whitespace.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.stripToNull(null)     = null\n+     * StringUtils.stripToNull(\"\")       = null\n+     * StringUtils.stripToNull(\"   \")    = null\n+     * StringUtils.stripToNull(\"abc\")    = \"abc\"\n+     * StringUtils.stripToNull(\"  abc\")  = \"abc\"\n+     * StringUtils.stripToNull(\"abc  \")  = \"abc\"\n+     * StringUtils.stripToNull(\" abc \")  = \"abc\"\n+     * StringUtils.stripToNull(\" ab c \") = \"ab c\"\n+     * </pre>\n+     *\n+     * @param str  the String to be stripped, may be null\n+     * @return the stripped String,\n+     *  <code>null</code> if whitespace, empty or null String input\n+     * @since 2.0\n+     */\n+    public static String stripToNull(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        str = strip(str, null);\n+        return str.length() == 0 ? null : str;\n+    }\n+\n+    /**\n+     * <p>Strips whitespace from the start and end of a String  returning\n+     * an empty String if <code>null</code> input.</p>\n+     *\n+     * <p>This is similar to {@link #trimToEmpty(String)} but removes whitespace.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.stripToEmpty(null)     = \"\"\n+     * StringUtils.stripToEmpty(\"\")       = \"\"\n+     * StringUtils.stripToEmpty(\"   \")    = \"\"\n+     * StringUtils.stripToEmpty(\"abc\")    = \"abc\"\n+     * StringUtils.stripToEmpty(\"  abc\")  = \"abc\"\n+     * StringUtils.stripToEmpty(\"abc  \")  = \"abc\"\n+     * StringUtils.stripToEmpty(\" abc \")  = \"abc\"\n+     * StringUtils.stripToEmpty(\" ab c \") = \"ab c\"\n+     * </pre>\n+     *\n+     * @param str  the String to be stripped, may be null\n+     * @return the trimmed String, or an empty String if <code>null</code> input\n+     * @since 2.0\n+     */\n+    public static String stripToEmpty(String str) {\n+        return str == null ? EMPTY : strip(str, null);\n+    }\n+\n+    /**\n+     * <p>Strips any of a set of characters from the start and end of a String.\n+     * This is similar to {@link String#trim()} but allows the characters\n+     * to be stripped to be controlled.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * An empty string (\"\") input returns the empty string.</p>\n+     *\n+     * <p>If the stripChars String is <code>null</code>, whitespace is\n+     * stripped as defined by {@link Character#isWhitespace(char)}.\n+     * Alternatively use {@link #strip(String)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.strip(null, *)          = null\n+     * StringUtils.strip(\"\", *)            = \"\"\n+     * StringUtils.strip(\"abc\", null)      = \"abc\"\n+     * StringUtils.strip(\"  abc\", null)    = \"abc\"\n+     * StringUtils.strip(\"abc  \", null)    = \"abc\"\n+     * StringUtils.strip(\" abc \", null)    = \"abc\"\n+     * StringUtils.strip(\"  abcyx\", \"xyz\") = \"  abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to remove characters from, may be null\n+     * @param stripChars  the characters to remove, null treated as whitespace\n+     * @return the stripped String, <code>null</code> if null String input\n+     */\n+    public static String strip(String str, String stripChars) {\n+        if (isEmpty(str)) {\n+            return str;\n+        }\n+        str = stripStart(str, stripChars);\n+        return stripEnd(str, stripChars);\n+    }\n+\n+    /**\n+     * <p>Strips any of a set of characters from the start of a String.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * An empty string (\"\") input returns the empty string.</p>\n+     *\n+     * <p>If the stripChars String is <code>null</code>, whitespace is\n+     * stripped as defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.stripStart(null, *)          = null\n+     * StringUtils.stripStart(\"\", *)            = \"\"\n+     * StringUtils.stripStart(\"abc\", \"\")        = \"abc\"\n+     * StringUtils.stripStart(\"abc\", null)      = \"abc\"\n+     * StringUtils.stripStart(\"  abc\", null)    = \"abc\"\n+     * StringUtils.stripStart(\"abc  \", null)    = \"abc  \"\n+     * StringUtils.stripStart(\" abc \", null)    = \"abc \"\n+     * StringUtils.stripStart(\"yxabc  \", \"xyz\") = \"abc  \"\n+     * </pre>\n+     *\n+     * @param str  the String to remove characters from, may be null\n+     * @param stripChars  the characters to remove, null treated as whitespace\n+     * @return the stripped String, <code>null</code> if null String input\n+     */\n+    public static String stripStart(String str, String stripChars) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return str;\n+        }\n+        int start = 0;\n+        if (stripChars == null) {\n+            while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {\n+                start++;\n+            }\n+        } else if (stripChars.length() == 0) {\n+            return str;\n+        } else {\n+            while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != -1)) {\n+                start++;\n+            }\n+        }\n+        return str.substring(start);\n+    }\n+\n+    /**\n+     * <p>Strips any of a set of characters from the end of a String.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * An empty string (\"\") input returns the empty string.</p>\n+     *\n+     * <p>If the stripChars String is <code>null</code>, whitespace is\n+     * stripped as defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.stripEnd(null, *)          = null\n+     * StringUtils.stripEnd(\"\", *)            = \"\"\n+     * StringUtils.stripEnd(\"abc\", \"\")        = \"abc\"\n+     * StringUtils.stripEnd(\"abc\", null)      = \"abc\"\n+     * StringUtils.stripEnd(\"  abc\", null)    = \"  abc\"\n+     * StringUtils.stripEnd(\"abc  \", null)    = \"abc\"\n+     * StringUtils.stripEnd(\" abc \", null)    = \" abc\"\n+     * StringUtils.stripEnd(\"  abcyx\", \"xyz\") = \"  abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to remove characters from, may be null\n+     * @param stripChars  the characters to remove, null treated as whitespace\n+     * @return the stripped String, <code>null</code> if null String input\n+     */\n+    public static String stripEnd(String str, String stripChars) {\n+        int end;\n+        if (str == null || (end = str.length()) == 0) {\n+            return str;\n+        }\n+\n+        if (stripChars == null) {\n+            while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {\n+                end--;\n+            }\n+        } else if (stripChars.length() == 0) {\n+            return str;\n+        } else {\n+            while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != -1)) {\n+                end--;\n+            }\n+        }\n+        return str.substring(0, end);\n+    }\n+\n+    // StripAll\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Strips whitespace from the start and end of every String in an array.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <p>A new array is returned each time, except for length zero.\n+     * A <code>null</code> array will return <code>null</code>.\n+     * An empty array will return itself.\n+     * A <code>null</code> array entry will be ignored.</p>\n+     *\n+     * <pre>\n+     * StringUtils.stripAll(null)             = null\n+     * StringUtils.stripAll([])               = []\n+     * StringUtils.stripAll([\"abc\", \"  abc\"]) = [\"abc\", \"abc\"]\n+     * StringUtils.stripAll([\"abc  \", null])  = [\"abc\", null]\n+     * </pre>\n+     *\n+     * @param strs  the array to remove whitespace from, may be null\n+     * @return the stripped Strings, <code>null</code> if null array input\n+     */\n+    public static String[] stripAll(String[] strs) {\n+        return stripAll(strs, null);\n+    }\n+\n+    /**\n+     * <p>Strips any of a set of characters from the start and end of every\n+     * String in an array.</p>\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <p>A new array is returned each time, except for length zero.\n+     * A <code>null</code> array will return <code>null</code>.\n+     * An empty array will return itself.\n+     * A <code>null</code> array entry will be ignored.\n+     * A <code>null</code> stripChars will strip whitespace as defined by\n+     * {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.stripAll(null, *)                = null\n+     * StringUtils.stripAll([], *)                  = []\n+     * StringUtils.stripAll([\"abc\", \"  abc\"], null) = [\"abc\", \"abc\"]\n+     * StringUtils.stripAll([\"abc  \", null], null)  = [\"abc\", null]\n+     * StringUtils.stripAll([\"abc  \", null], \"yz\")  = [\"abc  \", null]\n+     * StringUtils.stripAll([\"yabcz\", null], \"yz\")  = [\"abc\", null]\n+     * </pre>\n+     *\n+     * @param strs  the array to remove characters from, may be null\n+     * @param stripChars  the characters to remove, null treated as whitespace\n+     * @return the stripped Strings, <code>null</code> if null array input\n+     */\n+    public static String[] stripAll(String[] strs, String stripChars) {\n+        int strsLen;\n+        if (strs == null || (strsLen = strs.length) == 0) {\n+            return strs;\n+        }\n+        String[] newArr = new String[strsLen];\n+        for (int i = 0; i < strsLen; i++) {\n+            newArr[i] = strip(strs[i], stripChars);\n+        }\n+        return newArr;\n+    }\n+\n+    // Equals\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compares two Strings, returning <code>true</code> if they are equal.</p>\n+     *\n+     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n+     * references are considered to be equal. The comparison is case sensitive.</p>\n+     *\n+     * <pre>\n+     * StringUtils.equals(null, null)   = true\n+     * StringUtils.equals(null, \"abc\")  = false\n+     * StringUtils.equals(\"abc\", null)  = false\n+     * StringUtils.equals(\"abc\", \"abc\") = true\n+     * StringUtils.equals(\"abc\", \"ABC\") = false\n+     * </pre>\n+     *\n+     * @see java.lang.String#equals(Object)\n+     * @param str1  the first String, may be null\n+     * @param str2  the second String, may be null\n+     * @return <code>true</code> if the Strings are equal, case sensitive, or\n+     *  both <code>null</code>\n+     */\n+    public static boolean equals(String str1, String str2) {\n+        return str1 == null ? str2 == null : str1.equals(str2);\n+    }\n+\n+    /**\n+     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n+     * the case.</p>\n+     *\n+     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n+     * references are considered equal. Comparison is case insensitive.</p>\n+     *\n+     * <pre>\n+     * StringUtils.equalsIgnoreCase(null, null)   = true\n+     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n+     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n+     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n+     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n+     * </pre>\n+     *\n+     * @see java.lang.String#equalsIgnoreCase(String)\n+     * @param str1  the first String, may be null\n+     * @param str2  the second String, may be null\n+     * @return <code>true</code> if the Strings are equal, case insensitive, or\n+     *  both <code>null</code>\n+     */\n+    public static boolean equalsIgnoreCase(String str1, String str2) {\n+        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n+    }\n+\n+    // IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the first index within a String, handling <code>null</code>.\n+     * This method uses {@link String#indexOf(int)}.</p>\n+     *\n+     * <p>A <code>null</code> or empty (\"\") String will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOf(null, *)         = -1\n+     * StringUtils.indexOf(\"\", *)           = -1\n+     * StringUtils.indexOf(\"aabaabaa\", 'a') = 0\n+     * StringUtils.indexOf(\"aabaabaa\", 'b') = 2\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChar  the character to find\n+     * @return the first index of the search character,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int indexOf(String str, char searchChar) {\n+        if (isEmpty(str)) {\n+            return -1;\n+        }\n+        return str.indexOf(searchChar);\n+    }\n+\n+    /**\n+     * <p>Finds the first index within a String from a start position,\n+     * handling <code>null</code>.\n+     * This method uses {@link String#indexOf(int, int)}.</p>\n+     *\n+     * <p>A <code>null</code> or empty (\"\") String will return <code>-1</code>.\n+     * A negative start position is treated as zero.\n+     * A start position greater than the string length returns <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOf(null, *, *)          = -1\n+     * StringUtils.indexOf(\"\", *, *)            = -1\n+     * StringUtils.indexOf(\"aabaabaa\", 'b', 0)  = 2\n+     * StringUtils.indexOf(\"aabaabaa\", 'b', 3)  = 5\n+     * StringUtils.indexOf(\"aabaabaa\", 'b', 9)  = -1\n+     * StringUtils.indexOf(\"aabaabaa\", 'b', -1) = 2\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChar  the character to find\n+     * @param startPos  the start position, negative treated as zero\n+     * @return the first index of the search character,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int indexOf(String str, char searchChar, int startPos) {\n+        if (isEmpty(str)) {\n+            return -1;\n+        }\n+        return str.indexOf(searchChar, startPos);\n+    }\n+\n+    /**\n+     * <p>Finds the first index within a String, handling <code>null</code>.\n+     * This method uses {@link String#indexOf(String)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOf(null, *)          = -1\n+     * StringUtils.indexOf(*, null)          = -1\n+     * StringUtils.indexOf(\"\", \"\")           = 0\n+     * StringUtils.indexOf(\"aabaabaa\", \"a\")  = 0\n+     * StringUtils.indexOf(\"aabaabaa\", \"b\")  = 2\n+     * StringUtils.indexOf(\"aabaabaa\", \"ab\") = 1\n+     * StringUtils.indexOf(\"aabaabaa\", \"\")   = 0\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @return the first index of the search String,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int indexOf(String str, String searchStr) {\n+        if (str == null || searchStr == null) {\n+            return -1;\n+        }\n+        return str.indexOf(searchStr);\n+    }\n+\n+    /**\n+     * <p>Finds the n-th index within a String, handling <code>null</code>.\n+     * This method uses {@link String#indexOf(String)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.ordinalIndexOf(null, *, *)          = -1\n+     * StringUtils.ordinalIndexOf(*, null, *)          = -1\n+     * StringUtils.ordinalIndexOf(\"\", \"\", *)           = 0\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 1)  = 0\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 2)  = 1\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 1)  = 2\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 2)  = 5\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 1) = 1\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 2) = 4\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 1)   = 0\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 2)   = 0\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @param ordinal  the n-th <code>searchStr</code> to find\n+     * @return the n-th index of the search String,\n+     *  <code>-1</code> (<code>INDEX_NOT_FOUND</code>) if no match or <code>null</code> string input\n+     * @since 2.1\n+     */\n+    public static int ordinalIndexOf(String str, String searchStr, int ordinal) {\n+        if (str == null || searchStr == null || ordinal <= 0) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (searchStr.length() == 0) {\n+            return 0;\n+        }\n+        int found = 0;\n+        int index = INDEX_NOT_FOUND;\n+        do {\n+            index = str.indexOf(searchStr, index + 1);\n+            if (index < 0) {\n+                return index;\n+            }\n+            found++;\n+        } while (found < ordinal);\n+        return index;\n+    }\n+\n+    /**\n+     * <p>Finds the first index within a String, handling <code>null</code>.\n+     * This method uses {@link String#indexOf(String, int)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A negative start position is treated as zero.\n+     * An empty (\"\") search String always matches.\n+     * A start position greater than the string length only matches\n+     * an empty search String.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOf(null, *, *)          = -1\n+     * StringUtils.indexOf(*, null, *)          = -1\n+     * StringUtils.indexOf(\"\", \"\", 0)           = 0\n+     * StringUtils.indexOf(\"aabaabaa\", \"a\", 0)  = 0\n+     * StringUtils.indexOf(\"aabaabaa\", \"b\", 0)  = 2\n+     * StringUtils.indexOf(\"aabaabaa\", \"ab\", 0) = 1\n+     * StringUtils.indexOf(\"aabaabaa\", \"b\", 3)  = 5\n+     * StringUtils.indexOf(\"aabaabaa\", \"b\", 9)  = -1\n+     * StringUtils.indexOf(\"aabaabaa\", \"b\", -1) = 2\n+     * StringUtils.indexOf(\"aabaabaa\", \"\", 2)   = 2\n+     * StringUtils.indexOf(\"abc\", \"\", 9)        = 3\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @param startPos  the start position, negative treated as zero\n+     * @return the first index of the search String,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int indexOf(String str, String searchStr, int startPos) {\n+        if (str == null || searchStr == null) {\n+            return -1;\n+        }\n+        // JDK1.2/JDK1.3 have a bug, when startPos > str.length for \"\", hence\n+        if (searchStr.length() == 0 && startPos >= str.length()) {\n+            return str.length();\n+        }\n+        return str.indexOf(searchStr, startPos);\n+    }\n+\n+    // LastIndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the last index within a String, handling <code>null</code>.\n+     * This method uses {@link String#lastIndexOf(int)}.</p>\n+     *\n+     * <p>A <code>null</code> or empty (\"\") String will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.lastIndexOf(null, *)         = -1\n+     * StringUtils.lastIndexOf(\"\", *)           = -1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'a') = 7\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'b') = 5\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChar  the character to find\n+     * @return the last index of the search character,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int lastIndexOf(String str, char searchChar) {\n+        if (isEmpty(str)) {\n+            return -1;\n+        }\n+        return str.lastIndexOf(searchChar);\n+    }\n+\n+    /**\n+     * <p>Finds the last index within a String from a start position,\n+     * handling <code>null</code>.\n+     * This method uses {@link String#lastIndexOf(int, int)}.</p>\n+     *\n+     * <p>A <code>null</code> or empty (\"\") String will return <code>-1</code>.\n+     * A negative start position returns <code>-1</code>.\n+     * A start position greater than the string length searches the whole string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.lastIndexOf(null, *, *)          = -1\n+     * StringUtils.lastIndexOf(\"\", *,  *)           = -1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 8)  = 5\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 4)  = 2\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 0)  = -1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 9)  = 5\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', -1) = -1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'a', 0)  = 0\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChar  the character to find\n+     * @param startPos  the start position\n+     * @return the last index of the search character,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int lastIndexOf(String str, char searchChar, int startPos) {\n+        if (isEmpty(str)) {\n+            return -1;\n+        }\n+        return str.lastIndexOf(searchChar, startPos);\n+    }\n+\n+    /**\n+     * <p>Finds the last index within a String, handling <code>null</code>.\n+     * This method uses {@link String#lastIndexOf(String)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.lastIndexOf(null, *)          = -1\n+     * StringUtils.lastIndexOf(*, null)          = -1\n+     * StringUtils.lastIndexOf(\"\", \"\")           = 0\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"a\")  = 0\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\")  = 2\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"ab\") = 1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"\")   = 8\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @return the last index of the search String,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int lastIndexOf(String str, String searchStr) {\n+        if (str == null || searchStr == null) {\n+            return -1;\n+        }\n+        return str.lastIndexOf(searchStr);\n+    }\n+\n+    /**\n+     * <p>Finds the first index within a String, handling <code>null</code>.\n+     * This method uses {@link String#lastIndexOf(String, int)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A negative start position returns <code>-1</code>.\n+     * An empty (\"\") search String always matches unless the start position is negative.\n+     * A start position greater than the string length searches the whole string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.lastIndexOf(null, *, *)          = -1\n+     * StringUtils.lastIndexOf(*, null, *)          = -1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 8)  = 7\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 8)  = 5\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"ab\", 8) = 4\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 9)  = 5\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", -1) = -1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 0)  = 0\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 0)  = -1\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @param startPos  the start position, negative treated as zero\n+     * @return the first index of the search String,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int lastIndexOf(String str, String searchStr, int startPos) {\n+        if (str == null || searchStr == null) {\n+            return -1;\n+        }\n+        return str.lastIndexOf(searchStr, startPos);\n+    }\n+\n+    // Contains\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if String contains a search character, handling <code>null</code>.\n+     * This method uses {@link String#indexOf(int)}.</p>\n+     *\n+     * <p>A <code>null</code> or empty (\"\") String will return <code>false</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.contains(null, *)    = false\n+     * StringUtils.contains(\"\", *)      = false\n+     * StringUtils.contains(\"abc\", 'a') = true\n+     * StringUtils.contains(\"abc\", 'z') = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChar  the character to find\n+     * @return true if the String contains the search character,\n+     *  false if not or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static boolean contains(String str, char searchChar) {\n+        if (isEmpty(str)) {\n+            return false;\n+        }\n+        return str.indexOf(searchChar) >= 0;\n+    }\n+\n+    /**\n+     * <p>Checks if String contains a search String, handling <code>null</code>.\n+     * This method uses {@link String#indexOf(String)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>false</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.contains(null, *)     = false\n+     * StringUtils.contains(*, null)     = false\n+     * StringUtils.contains(\"\", \"\")      = true\n+     * StringUtils.contains(\"abc\", \"\")   = true\n+     * StringUtils.contains(\"abc\", \"a\")  = true\n+     * StringUtils.contains(\"abc\", \"z\")  = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @return true if the String contains the search String,\n+     *  false if not or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static boolean contains(String str, String searchStr) {\n+        if (str == null || searchStr == null) {\n+            return false;\n+        }\n+        return str.indexOf(searchStr) >= 0;\n+    }\n+\n+    /**\n+     * <p>Checks if String contains a search String irrespective of case,\n+     * handling <code>null</code>. Case-insensitivity is defined as by\n+     * {@link String#equalsIgnoreCase(String)}.\n+     *\n+     * <p>A <code>null</code> String will return <code>false</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.contains(null, *) = false\n+     * StringUtils.contains(*, null) = false\n+     * StringUtils.contains(\"\", \"\") = true\n+     * StringUtils.contains(\"abc\", \"\") = true\n+     * StringUtils.contains(\"abc\", \"a\") = true\n+     * StringUtils.contains(\"abc\", \"z\") = false\n+     * StringUtils.contains(\"abc\", \"A\") = true\n+     * StringUtils.contains(\"abc\", \"Z\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @return true if the String contains the search String irrespective of\n+     * case or false if not or <code>null</code> string input\n+     */\n+    public static boolean containsIgnoreCase(String str, String searchStr) {\n+        if (str == null || searchStr == null) {\n+            return false;\n+        }\n+        int len = searchStr.length();\n+        int max = str.length() - len;\n+        for (int i = 0; i <= max; i++) {\n+            if (str.regionMatches(true, i, searchStr, 0, len)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    // IndexOfAny chars\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Search a String to find the first index of any\n+     * character in the given set of characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A <code>null</code> or zero length search array will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfAny(null, *)                = -1\n+     * StringUtils.indexOfAny(\"\", *)                  = -1\n+     * StringUtils.indexOfAny(*, null)                = -1\n+     * StringUtils.indexOfAny(*, [])                  = -1\n+     * StringUtils.indexOfAny(\"zzabyycdxx\",['z','a']) = 0\n+     * StringUtils.indexOfAny(\"zzabyycdxx\",['b','y']) = 3\n+     * StringUtils.indexOfAny(\"aba\", ['z'])           = -1\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChars  the chars to search for, may be null\n+     * @return the index of any of the chars, -1 if no match or null input\n+     * @since 2.0\n+     */\n+    public static int indexOfAny(String str, char[] searchChars) {\n+        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n+            return -1;\n+        }\n+        for (int i = 0; i < str.length(); i++) {\n+            char ch = str.charAt(i);\n+            for (int j = 0; j < searchChars.length; j++) {\n+                if (searchChars[j] == ch) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * <p>Search a String to find the first index of any\n+     * character in the given set of characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A <code>null</code> search string will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfAny(null, *)            = -1\n+     * StringUtils.indexOfAny(\"\", *)              = -1\n+     * StringUtils.indexOfAny(*, null)            = -1\n+     * StringUtils.indexOfAny(*, \"\")              = -1\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", \"za\") = 0\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", \"by\") = 3\n+     * StringUtils.indexOfAny(\"aba\",\"z\")          = -1\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChars  the chars to search for, may be null\n+     * @return the index of any of the chars, -1 if no match or null input\n+     * @since 2.0\n+     */\n+    public static int indexOfAny(String str, String searchChars) {\n+        if (isEmpty(str) || isEmpty(searchChars)) {\n+            return -1;\n+        }\n+        return indexOfAny(str, searchChars.toCharArray());\n+    }\n+\n+    // ContainsAny\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if the String contains any character in the given\n+     * set of characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>false</code>.\n+     * A <code>null</code> or zero length search array will return <code>false</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.containsAny(null, *)                = false\n+     * StringUtils.containsAny(\"\", *)                  = false\n+     * StringUtils.containsAny(*, null)                = false\n+     * StringUtils.containsAny(*, [])                  = false\n+     * StringUtils.containsAny(\"zzabyycdxx\",['z','a']) = true\n+     * StringUtils.containsAny(\"zzabyycdxx\",['b','y']) = true\n+     * StringUtils.containsAny(\"aba\", ['z'])           = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChars  the chars to search for, may be null\n+     * @return the <code>true</code> if any of the chars are found,\n+     * <code>false</code> if no match or null input\n+     * @since 2.4\n+     */\n+    public static boolean containsAny(String str, char[] searchChars) {\n+        if (str == null || str.length() == 0 || searchChars == null || searchChars.length == 0) {\n+            return false;\n+        }\n+        for (int i = 0; i < str.length(); i++) {\n+            char ch = str.charAt(i);\n+            for (int j = 0; j < searchChars.length; j++) {\n+                if (searchChars[j] == ch) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>\n+     * Checks if the String contains any character in the given set of characters.\n+     * </p>\n+     * \n+     * <p>\n+     * A <code>null</code> String will return <code>false</code>. A <code>null</code> search string will return\n+     * <code>false</code>.\n+     * </p>\n+     * \n+     * <pre>\n+     * StringUtils.containsAny(null, *)            = false\n+     * StringUtils.containsAny(\"\", *)              = false\n+     * StringUtils.containsAny(*, null)            = false\n+     * StringUtils.containsAny(*, \"\")              = false\n+     * StringUtils.containsAny(\"zzabyycdxx\", \"za\") = true\n+     * StringUtils.containsAny(\"zzabyycdxx\", \"by\") = true\n+     * StringUtils.containsAny(\"aba\",\"z\")          = false\n+     * </pre>\n+     * \n+     * @param str\n+     *            the String to check, may be null\n+     * @param searchChars\n+     *            the chars to search for, may be null\n+     * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input\n+     * @since 2.4\n+     */\n+    public static boolean containsAny(String str, String searchChars) {\n+        if (searchChars == null) {\n+            return false;\n+        }\n+        return containsAny(str, searchChars.toCharArray());\n+    }\n+\n+    // IndexOfAnyBut chars\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Search a String to find the first index of any\n+     * character not in the given set of characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A <code>null</code> or zero length search array will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfAnyBut(null, *)           = -1\n+     * StringUtils.indexOfAnyBut(\"\", *)             = -1\n+     * StringUtils.indexOfAnyBut(*, null)           = -1\n+     * StringUtils.indexOfAnyBut(*, [])             = -1\n+     * StringUtils.indexOfAnyBut(\"zzabyycdxx\",'za') = 3\n+     * StringUtils.indexOfAnyBut(\"zzabyycdxx\", '')  = 0\n+     * StringUtils.indexOfAnyBut(\"aba\", 'ab')       = -1\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChars  the chars to search for, may be null\n+     * @return the index of any of the chars, -1 if no match or null input\n+     * @since 2.0\n+     */\n+    public static int indexOfAnyBut(String str, char[] searchChars) {\n+        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n+            return -1;\n+        }\n+        outer : for (int i = 0; i < str.length(); i++) {\n+            char ch = str.charAt(i);\n+            for (int j = 0; j < searchChars.length; j++) {\n+                if (searchChars[j] == ch) {\n+                    continue outer;\n+                }\n+            }\n+            return i;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * <p>Search a String to find the first index of any\n+     * character not in the given set of characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A <code>null</code> search string will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfAnyBut(null, *)            = -1\n+     * StringUtils.indexOfAnyBut(\"\", *)              = -1\n+     * StringUtils.indexOfAnyBut(*, null)            = -1\n+     * StringUtils.indexOfAnyBut(*, \"\")              = -1\n+     * StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"za\") = 3\n+     * StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"\")   = 0\n+     * StringUtils.indexOfAnyBut(\"aba\",\"ab\")         = -1\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChars  the chars to search for, may be null\n+     * @return the index of any of the chars, -1 if no match or null input\n+     * @since 2.0\n+     */\n+    public static int indexOfAnyBut(String str, String searchChars) {\n+        if (isEmpty(str) || isEmpty(searchChars)) {\n+            return -1;\n+        }\n+        for (int i = 0; i < str.length(); i++) {\n+            if (searchChars.indexOf(str.charAt(i)) < 0) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    // ContainsOnly\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if the String contains only certain characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>false</code>.\n+     * A <code>null</code> valid character array will return <code>false</code>.\n+     * An empty String (\"\") always returns <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.containsOnly(null, *)       = false\n+     * StringUtils.containsOnly(*, null)       = false\n+     * StringUtils.containsOnly(\"\", *)         = true\n+     * StringUtils.containsOnly(\"ab\", '')      = false\n+     * StringUtils.containsOnly(\"abab\", 'abc') = true\n+     * StringUtils.containsOnly(\"ab1\", 'abc')  = false\n+     * StringUtils.containsOnly(\"abz\", 'abc')  = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param valid  an array of valid chars, may be null\n+     * @return true if it only contains valid chars and is non-null\n+     */\n+    public static boolean containsOnly(String str, char[] valid) {\n+        // All these pre-checks are to maintain API with an older version\n+        if ((valid == null) || (str == null)) {\n+            return false;\n+        }\n+        if (str.length() == 0) {\n+            return true;\n+        }\n+        if (valid.length == 0) {\n+            return false;\n+        }\n+        return indexOfAnyBut(str, valid) == -1;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only certain characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>false</code>.\n+     * A <code>null</code> valid character String will return <code>false</code>.\n+     * An empty String (\"\") always returns <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.containsOnly(null, *)       = false\n+     * StringUtils.containsOnly(*, null)       = false\n+     * StringUtils.containsOnly(\"\", *)         = true\n+     * StringUtils.containsOnly(\"ab\", \"\")      = false\n+     * StringUtils.containsOnly(\"abab\", \"abc\") = true\n+     * StringUtils.containsOnly(\"ab1\", \"abc\")  = false\n+     * StringUtils.containsOnly(\"abz\", \"abc\")  = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param validChars  a String of valid chars, may be null\n+     * @return true if it only contains valid chars and is non-null\n+     * @since 2.0\n+     */\n+    public static boolean containsOnly(String str, String validChars) {\n+        if (str == null || validChars == null) {\n+            return false;\n+        }\n+        return containsOnly(str, validChars.toCharArray());\n+    }\n+\n+    // ContainsNone\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks that the String does not contain certain characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>true</code>.\n+     * A <code>null</code> invalid character array will return <code>true</code>.\n+     * An empty String (\"\") always returns true.</p>\n+     *\n+     * <pre>\n+     * StringUtils.containsNone(null, *)       = true\n+     * StringUtils.containsNone(*, null)       = true\n+     * StringUtils.containsNone(\"\", *)         = true\n+     * StringUtils.containsNone(\"ab\", '')      = true\n+     * StringUtils.containsNone(\"abab\", 'xyz') = true\n+     * StringUtils.containsNone(\"ab1\", 'xyz')  = true\n+     * StringUtils.containsNone(\"abz\", 'xyz')  = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param invalidChars  an array of invalid chars, may be null\n+     * @return true if it contains none of the invalid chars, or is null\n+     * @since 2.0\n+     */\n+    public static boolean containsNone(String str, char[] invalidChars) {\n+        if (str == null || invalidChars == null) {\n+            return true;\n+        }\n+        int strSize = str.length();\n+        int validSize = invalidChars.length;\n+        for (int i = 0; i < strSize; i++) {\n+            char ch = str.charAt(i);\n+            for (int j = 0; j < validSize; j++) {\n+                if (invalidChars[j] == ch) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks that the String does not contain certain characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>true</code>.\n+     * A <code>null</code> invalid character array will return <code>true</code>.\n+     * An empty String (\"\") always returns true.</p>\n+     *\n+     * <pre>\n+     * StringUtils.containsNone(null, *)       = true\n+     * StringUtils.containsNone(*, null)       = true\n+     * StringUtils.containsNone(\"\", *)         = true\n+     * StringUtils.containsNone(\"ab\", \"\")      = true\n+     * StringUtils.containsNone(\"abab\", \"xyz\") = true\n+     * StringUtils.containsNone(\"ab1\", \"xyz\")  = true\n+     * StringUtils.containsNone(\"abz\", \"xyz\")  = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param invalidChars  a String of invalid chars, may be null\n+     * @return true if it contains none of the invalid chars, or is null\n+     * @since 2.0\n+     */\n+    public static boolean containsNone(String str, String invalidChars) {\n+        if (str == null || invalidChars == null) {\n+            return true;\n+        }\n+        return containsNone(str, invalidChars.toCharArray());\n+    }\n+\n+    // IndexOfAny strings\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Find the first index of any of a set of potential substrings.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A <code>null</code> or zero length search array will return <code>-1</code>.\n+     * A <code>null</code> search array entry will be ignored, but a search\n+     * array containing \"\" will return <code>0</code> if <code>str</code> is not\n+     * null. This method uses {@link String#indexOf(String)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfAny(null, *)                     = -1\n+     * StringUtils.indexOfAny(*, null)                     = -1\n+     * StringUtils.indexOfAny(*, [])                       = -1\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"ab\",\"cd\"])   = 2\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"cd\",\"ab\"])   = 2\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"])   = -1\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"zab\",\"aby\"]) = 1\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"\"])          = 0\n+     * StringUtils.indexOfAny(\"\", [\"\"])                    = 0\n+     * StringUtils.indexOfAny(\"\", [\"a\"])                   = -1\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStrs  the Strings to search for, may be null\n+     * @return the first index of any of the searchStrs in str, -1 if no match\n+     */\n+    public static int indexOfAny(String str, String[] searchStrs) {\n+        if ((str == null) || (searchStrs == null)) {\n+            return -1;\n+        }\n+        int sz = searchStrs.length;\n+\n+        // String's can't have a MAX_VALUEth index.\n+        int ret = Integer.MAX_VALUE;\n+\n+        int tmp = 0;\n+        for (int i = 0; i < sz; i++) {\n+            String search = searchStrs[i];\n+            if (search == null) {\n+                continue;\n+            }\n+            tmp = str.indexOf(search);\n+            if (tmp == -1) {\n+                continue;\n+            }\n+\n+            if (tmp < ret) {\n+                ret = tmp;\n+            }\n+        }\n+\n+        return (ret == Integer.MAX_VALUE) ? -1 : ret;\n+    }\n+\n+    /**\n+     * <p>Find the latest index of any of a set of potential substrings.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A <code>null</code> search array will return <code>-1</code>.\n+     * A <code>null</code> or zero length search array entry will be ignored,\n+     * but a search array containing \"\" will return the length of <code>str</code>\n+     * if <code>str</code> is not null. This method uses {@link String#indexOf(String)}</p>\n+     *\n+     * <pre>\n+     * StringUtils.lastIndexOfAny(null, *)                   = -1\n+     * StringUtils.lastIndexOfAny(*, null)                   = -1\n+     * StringUtils.lastIndexOfAny(*, [])                     = -1\n+     * StringUtils.lastIndexOfAny(*, [null])                 = -1\n+     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"ab\",\"cd\"]) = 6\n+     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"cd\",\"ab\"]) = 6\n+     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"]) = -1\n+     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"]) = -1\n+     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"\"])   = 10\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStrs  the Strings to search for, may be null\n+     * @return the last index of any of the Strings, -1 if no match\n+     */\n+    public static int lastIndexOfAny(String str, String[] searchStrs) {\n+        if ((str == null) || (searchStrs == null)) {\n+            return -1;\n+        }\n+        int sz = searchStrs.length;\n+        int ret = -1;\n+        int tmp = 0;\n+        for (int i = 0; i < sz; i++) {\n+            String search = searchStrs[i];\n+            if (search == null) {\n+                continue;\n+            }\n+            tmp = str.lastIndexOf(search);\n+            if (tmp > ret) {\n+                ret = tmp;\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    // Substring\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a substring from the specified String avoiding exceptions.</p>\n+     *\n+     * <p>A negative start position can be used to start <code>n</code>\n+     * characters from the end of the String.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>null</code>.\n+     * An empty (\"\") String will return \"\".</p>\n+     *\n+     * <pre>\n+     * StringUtils.substring(null, *)   = null\n+     * StringUtils.substring(\"\", *)     = \"\"\n+     * StringUtils.substring(\"abc\", 0)  = \"abc\"\n+     * StringUtils.substring(\"abc\", 2)  = \"c\"\n+     * StringUtils.substring(\"abc\", 4)  = \"\"\n+     * StringUtils.substring(\"abc\", -2) = \"bc\"\n+     * StringUtils.substring(\"abc\", -4) = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to get the substring from, may be null\n+     * @param start  the position to start from, negative means\n+     *  count back from the end of the String by this many characters\n+     * @return substring from start position, <code>null</code> if null String input\n+     */\n+    public static String substring(String str, int start) {\n+        if (str == null) {\n+            return null;\n+        }\n+\n+        // handle negatives, which means last n characters\n+        if (start < 0) {\n+            start = str.length() + start; // remember start is negative\n+        }\n+\n+        if (start < 0) {\n+            start = 0;\n+        }\n+        if (start > str.length()) {\n+            return EMPTY;\n+        }\n+\n+        return str.substring(start);\n+    }\n+\n+    /**\n+     * <p>Gets a substring from the specified String avoiding exceptions.</p>\n+     *\n+     * <p>A negative start position can be used to start/end <code>n</code>\n+     * characters from the end of the String.</p>\n+     *\n+     * <p>The returned substring starts with the character in the <code>start</code>\n+     * position and ends before the <code>end</code> position. All position counting is\n+     * zero-based -- i.e., to start at the beginning of the string use\n+     * <code>start = 0</code>. Negative start and end positions can be used to\n+     * specify offsets relative to the end of the String.</p>\n+     *\n+     * <p>If <code>start</code> is not strictly to the left of <code>end</code>, \"\"\n+     * is returned.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substring(null, *, *)    = null\n+     * StringUtils.substring(\"\", * ,  *)    = \"\";\n+     * StringUtils.substring(\"abc\", 0, 2)   = \"ab\"\n+     * StringUtils.substring(\"abc\", 2, 0)   = \"\"\n+     * StringUtils.substring(\"abc\", 2, 4)   = \"c\"\n+     * StringUtils.substring(\"abc\", 4, 6)   = \"\"\n+     * StringUtils.substring(\"abc\", 2, 2)   = \"\"\n+     * StringUtils.substring(\"abc\", -2, -1) = \"b\"\n+     * StringUtils.substring(\"abc\", -4, 2)  = \"ab\"\n+     * </pre>\n+     *\n+     * @param str  the String to get the substring from, may be null\n+     * @param start  the position to start from, negative means\n+     *  count back from the end of the String by this many characters\n+     * @param end  the position to end at (exclusive), negative means\n+     *  count back from the end of the String by this many characters\n+     * @return substring from start position to end positon,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String substring(String str, int start, int end) {\n+        if (str == null) {\n+            return null;\n+        }\n+\n+        // handle negatives\n+        if (end < 0) {\n+            end = str.length() + end; // remember end is negative\n+        }\n+        if (start < 0) {\n+            start = str.length() + start; // remember start is negative\n+        }\n+\n+        // check length next\n+        if (end > str.length()) {\n+            end = str.length();\n+        }\n+\n+        // if start is greater than end, return \"\"\n+        if (start > end) {\n+            return EMPTY;\n+        }\n+\n+        if (start < 0) {\n+            start = 0;\n+        }\n+        if (end < 0) {\n+            end = 0;\n+        }\n+\n+        return str.substring(start, end);\n+    }\n+\n+    // Left/Right/Mid\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the leftmost <code>len</code> characters of a String.</p>\n+     *\n+     * <p>If <code>len</code> characters are not available, or the\n+     * String is <code>null</code>, the String will be returned without\n+     * an exception. An exception is thrown if len is negative.</p>\n+     *\n+     * <pre>\n+     * StringUtils.left(null, *)    = null\n+     * StringUtils.left(*, -ve)     = \"\"\n+     * StringUtils.left(\"\", *)      = \"\"\n+     * StringUtils.left(\"abc\", 0)   = \"\"\n+     * StringUtils.left(\"abc\", 2)   = \"ab\"\n+     * StringUtils.left(\"abc\", 4)   = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to get the leftmost characters from, may be null\n+     * @param len  the length of the required String, must be zero or positive\n+     * @return the leftmost characters, <code>null</code> if null String input\n+     */\n+    public static String left(String str, int len) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (len < 0) {\n+            return EMPTY;\n+        }\n+        if (str.length() <= len) {\n+            return str;\n+        }\n+        return str.substring(0, len);\n+    }\n+\n+    /**\n+     * <p>Gets the rightmost <code>len</code> characters of a String.</p>\n+     *\n+     * <p>If <code>len</code> characters are not available, or the String\n+     * is <code>null</code>, the String will be returned without an\n+     * an exception. An exception is thrown if len is negative.</p>\n+     *\n+     * <pre>\n+     * StringUtils.right(null, *)    = null\n+     * StringUtils.right(*, -ve)     = \"\"\n+     * StringUtils.right(\"\", *)      = \"\"\n+     * StringUtils.right(\"abc\", 0)   = \"\"\n+     * StringUtils.right(\"abc\", 2)   = \"bc\"\n+     * StringUtils.right(\"abc\", 4)   = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to get the rightmost characters from, may be null\n+     * @param len  the length of the required String, must be zero or positive\n+     * @return the rightmost characters, <code>null</code> if null String input\n+     */\n+    public static String right(String str, int len) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (len < 0) {\n+            return EMPTY;\n+        }\n+        if (str.length() <= len) {\n+            return str;\n+        }\n+        return str.substring(str.length() - len);\n+    }\n+\n+    /**\n+     * <p>Gets <code>len</code> characters from the middle of a String.</p>\n+     *\n+     * <p>If <code>len</code> characters are not available, the remainder\n+     * of the String will be returned without an exception. If the\n+     * String is <code>null</code>, <code>null</code> will be returned.\n+     * An exception is thrown if len is negative.</p>\n+     *\n+     * <pre>\n+     * StringUtils.mid(null, *, *)    = null\n+     * StringUtils.mid(*, *, -ve)     = \"\"\n+     * StringUtils.mid(\"\", 0, *)      = \"\"\n+     * StringUtils.mid(\"abc\", 0, 2)   = \"ab\"\n+     * StringUtils.mid(\"abc\", 0, 4)   = \"abc\"\n+     * StringUtils.mid(\"abc\", 2, 4)   = \"c\"\n+     * StringUtils.mid(\"abc\", 4, 2)   = \"\"\n+     * StringUtils.mid(\"abc\", -2, 2)  = \"ab\"\n+     * </pre>\n+     *\n+     * @param str  the String to get the characters from, may be null\n+     * @param pos  the position to start from, negative treated as zero\n+     * @param len  the length of the required String, must be zero or positive\n+     * @return the middle characters, <code>null</code> if null String input\n+     */\n+    public static String mid(String str, int pos, int len) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (len < 0 || pos > str.length()) {\n+            return EMPTY;\n+        }\n+        if (pos < 0) {\n+            pos = 0;\n+        }\n+        if (str.length() <= (pos + len)) {\n+            return str.substring(pos);\n+        }\n+        return str.substring(pos, pos + len);\n+    }\n+\n+    // SubStringAfter/SubStringBefore\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the substring before the first occurrence of a separator.\n+     * The separator is not returned.</p>\n+     *\n+     * <p>A <code>null</code> string input will return <code>null</code>.\n+     * An empty (\"\") string input will return the empty string.\n+     * A <code>null</code> separator will return the input string.</p>\n+     *\n+     * <p>If nothing is found, the string input is returned.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substringBefore(null, *)      = null\n+     * StringUtils.substringBefore(\"\", *)        = \"\"\n+     * StringUtils.substringBefore(\"abc\", \"a\")   = \"\"\n+     * StringUtils.substringBefore(\"abcba\", \"b\") = \"a\"\n+     * StringUtils.substringBefore(\"abc\", \"c\")   = \"ab\"\n+     * StringUtils.substringBefore(\"abc\", \"d\")   = \"abc\"\n+     * StringUtils.substringBefore(\"abc\", \"\")    = \"\"\n+     * StringUtils.substringBefore(\"abc\", null)  = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to get a substring from, may be null\n+     * @param separator  the String to search for, may be null\n+     * @return the substring before the first occurrence of the separator,\n+     *  <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String substringBefore(String str, String separator) {\n+        if (isEmpty(str) || separator == null) {\n+            return str;\n+        }\n+        if (separator.length() == 0) {\n+            return EMPTY;\n+        }\n+        int pos = str.indexOf(separator);\n+        if (pos == -1) {\n+            return str;\n+        }\n+        return str.substring(0, pos);\n+    }\n+\n+    /**\n+     * <p>Gets the substring after the first occurrence of a separator.\n+     * The separator is not returned.</p>\n+     *\n+     * <p>A <code>null</code> string input will return <code>null</code>.\n+     * An empty (\"\") string input will return the empty string.\n+     * A <code>null</code> separator will return the empty string if the\n+     * input string is not <code>null</code>.</p>\n+     *\n+     * <p>If nothing is found, the empty string is returned.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substringAfter(null, *)      = null\n+     * StringUtils.substringAfter(\"\", *)        = \"\"\n+     * StringUtils.substringAfter(*, null)      = \"\"\n+     * StringUtils.substringAfter(\"abc\", \"a\")   = \"bc\"\n+     * StringUtils.substringAfter(\"abcba\", \"b\") = \"cba\"\n+     * StringUtils.substringAfter(\"abc\", \"c\")   = \"\"\n+     * StringUtils.substringAfter(\"abc\", \"d\")   = \"\"\n+     * StringUtils.substringAfter(\"abc\", \"\")    = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to get a substring from, may be null\n+     * @param separator  the String to search for, may be null\n+     * @return the substring after the first occurrence of the separator,\n+     *  <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String substringAfter(String str, String separator) {\n+        if (isEmpty(str)) {\n+            return str;\n+        }\n+        if (separator == null) {\n+            return EMPTY;\n+        }\n+        int pos = str.indexOf(separator);\n+        if (pos == -1) {\n+            return EMPTY;\n+        }\n+        return str.substring(pos + separator.length());\n+    }\n+\n+    /**\n+     * <p>Gets the substring before the last occurrence of a separator.\n+     * The separator is not returned.</p>\n+     *\n+     * <p>A <code>null</code> string input will return <code>null</code>.\n+     * An empty (\"\") string input will return the empty string.\n+     * An empty or <code>null</code> separator will return the input string.</p>\n+     *\n+     * <p>If nothing is found, the string input is returned.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substringBeforeLast(null, *)      = null\n+     * StringUtils.substringBeforeLast(\"\", *)        = \"\"\n+     * StringUtils.substringBeforeLast(\"abcba\", \"b\") = \"abc\"\n+     * StringUtils.substringBeforeLast(\"abc\", \"c\")   = \"ab\"\n+     * StringUtils.substringBeforeLast(\"a\", \"a\")     = \"\"\n+     * StringUtils.substringBeforeLast(\"a\", \"z\")     = \"a\"\n+     * StringUtils.substringBeforeLast(\"a\", null)    = \"a\"\n+     * StringUtils.substringBeforeLast(\"a\", \"\")      = \"a\"\n+     * </pre>\n+     *\n+     * @param str  the String to get a substring from, may be null\n+     * @param separator  the String to search for, may be null\n+     * @return the substring before the last occurrence of the separator,\n+     *  <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String substringBeforeLast(String str, String separator) {\n+        if (isEmpty(str) || isEmpty(separator)) {\n+            return str;\n+        }\n+        int pos = str.lastIndexOf(separator);\n+        if (pos == -1) {\n+            return str;\n+        }\n+        return str.substring(0, pos);\n+    }\n+\n+    /**\n+     * <p>Gets the substring after the last occurrence of a separator.\n+     * The separator is not returned.</p>\n+     *\n+     * <p>A <code>null</code> string input will return <code>null</code>.\n+     * An empty (\"\") string input will return the empty string.\n+     * An empty or <code>null</code> separator will return the empty string if\n+     * the input string is not <code>null</code>.</p>\n+     *\n+     * <p>If nothing is found, the empty string is returned.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substringAfterLast(null, *)      = null\n+     * StringUtils.substringAfterLast(\"\", *)        = \"\"\n+     * StringUtils.substringAfterLast(*, \"\")        = \"\"\n+     * StringUtils.substringAfterLast(*, null)      = \"\"\n+     * StringUtils.substringAfterLast(\"abc\", \"a\")   = \"bc\"\n+     * StringUtils.substringAfterLast(\"abcba\", \"b\") = \"a\"\n+     * StringUtils.substringAfterLast(\"abc\", \"c\")   = \"\"\n+     * StringUtils.substringAfterLast(\"a\", \"a\")     = \"\"\n+     * StringUtils.substringAfterLast(\"a\", \"z\")     = \"\"\n+     * </pre>\n+     *\n+     * @param str  the String to get a substring from, may be null\n+     * @param separator  the String to search for, may be null\n+     * @return the substring after the last occurrence of the separator,\n+     *  <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String substringAfterLast(String str, String separator) {\n+        if (isEmpty(str)) {\n+            return str;\n+        }\n+        if (isEmpty(separator)) {\n+            return EMPTY;\n+        }\n+        int pos = str.lastIndexOf(separator);\n+        if (pos == -1 || pos == (str.length() - separator.length())) {\n+            return EMPTY;\n+        }\n+        return str.substring(pos + separator.length());\n+    }\n+\n+    // Substring between\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the String that is nested in between two instances of the\n+     * same String.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> tag returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substringBetween(null, *)            = null\n+     * StringUtils.substringBetween(\"\", \"\")             = \"\"\n+     * StringUtils.substringBetween(\"\", \"tag\")          = null\n+     * StringUtils.substringBetween(\"tagabctag\", null)  = null\n+     * StringUtils.substringBetween(\"tagabctag\", \"\")    = \"\"\n+     * StringUtils.substringBetween(\"tagabctag\", \"tag\") = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String containing the substring, may be null\n+     * @param tag  the String before and after the substring, may be null\n+     * @return the substring, <code>null</code> if no match\n+     * @since 2.0\n+     */\n+    public static String substringBetween(String str, String tag) {\n+        return substringBetween(str, tag, tag);\n+    }\n+\n+    /**\n+     * <p>Gets the String that is nested in between two Strings.\n+     * Only the first match is returned.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> open/close returns <code>null</code> (no match).\n+     * An empty (\"\") open and close returns an empty string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substringBetween(\"wx[b]yz\", \"[\", \"]\") = \"b\"\n+     * StringUtils.substringBetween(null, *, *)          = null\n+     * StringUtils.substringBetween(*, null, *)          = null\n+     * StringUtils.substringBetween(*, *, null)          = null\n+     * StringUtils.substringBetween(\"\", \"\", \"\")          = \"\"\n+     * StringUtils.substringBetween(\"\", \"\", \"]\")         = null\n+     * StringUtils.substringBetween(\"\", \"[\", \"]\")        = null\n+     * StringUtils.substringBetween(\"yabcz\", \"\", \"\")     = \"\"\n+     * StringUtils.substringBetween(\"yabcz\", \"y\", \"z\")   = \"abc\"\n+     * StringUtils.substringBetween(\"yabczyabcz\", \"y\", \"z\")   = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String containing the substring, may be null\n+     * @param open  the String before the substring, may be null\n+     * @param close  the String after the substring, may be null\n+     * @return the substring, <code>null</code> if no match\n+     * @since 2.0\n+     */\n+    public static String substringBetween(String str, String open, String close) {\n+        if (str == null || open == null || close == null) {\n+            return null;\n+        }\n+        int start = str.indexOf(open);\n+        if (start != -1) {\n+            int end = str.indexOf(close, start + open.length());\n+            if (end != -1) {\n+                return str.substring(start + open.length(), end);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Searches a String for substrings delimited by a start and end tag,\n+     * returning all matching substrings in an array.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> open/close returns <code>null</code> (no match).\n+     * An empty (\"\") open/close returns <code>null</code> (no match).</p>\n+     *\n+     * <pre>\n+     * StringUtils.substringsBetween(\"[a][b][c]\", \"[\", \"]\") = [\"a\",\"b\",\"c\"]\n+     * StringUtils.substringsBetween(null, *, *)            = null\n+     * StringUtils.substringsBetween(*, null, *)            = null\n+     * StringUtils.substringsBetween(*, *, null)            = null\n+     * StringUtils.substringsBetween(\"\", \"[\", \"]\")          = []\n+     * </pre>\n+     *\n+     * @param str  the String containing the substrings, null returns null, empty returns empty\n+     * @param open  the String identifying the start of the substring, empty returns null\n+     * @param close  the String identifying the end of the substring, empty returns null\n+     * @return a String Array of substrings, or <code>null</code> if no match\n+     * @since 2.3\n+     */\n+    public static String[] substringsBetween(String str, String open, String close) {\n+        if (str == null || isEmpty(open) || isEmpty(close)) {\n+            return null;\n+        }\n+        int strLen = str.length();\n+        if (strLen == 0) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        int closeLen = close.length();\n+        int openLen = open.length();\n+        List<String> list = new ArrayList<String>();\n+        int pos = 0;\n+        while (pos < (strLen - closeLen)) {\n+            int start = str.indexOf(open, pos);\n+            if (start < 0) {\n+                break;\n+            }\n+            start += openLen;\n+            int end = str.indexOf(close, start);\n+            if (end < 0) {\n+                break;\n+            }\n+            list.add(str.substring(start, end));\n+            pos = end + closeLen;\n+        }\n+        if (list.isEmpty()) {\n+            return null;\n+        } \n+        return list.toArray(new String [list.size()]);\n+    }\n+\n+    // Nested extraction\n+    //-----------------------------------------------------------------------\n+\n+    // Splitting\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Splits the provided text into an array, using whitespace as the\n+     * separator.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as one separator.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.split(null)       = null\n+     * StringUtils.split(\"\")         = []\n+     * StringUtils.split(\"abc def\")  = [\"abc\", \"def\"]\n+     * StringUtils.split(\"abc  def\") = [\"abc\", \"def\"]\n+     * StringUtils.split(\" abc \")    = [\"abc\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    public static String[] split(String str) {\n+        return split(str, null, -1);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separator specified.\n+     * This is an alternative to using StringTokenizer.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as one separator.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.split(null, *)         = null\n+     * StringUtils.split(\"\", *)           = []\n+     * StringUtils.split(\"a.b.c\", '.')    = [\"a\", \"b\", \"c\"]\n+     * StringUtils.split(\"a..b.c\", '.')   = [\"a\", \"b\", \"c\"]\n+     * StringUtils.split(\"a:b:c\", '.')    = [\"a:b:c\"]\n+     * StringUtils.split(\"a b c\", ' ')    = [\"a\", \"b\", \"c\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separatorChar  the character used as the delimiter\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String[] split(String str, char separatorChar) {\n+        return splitWorker(str, separatorChar, false);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separators specified.\n+     * This is an alternative to using StringTokenizer.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as one separator.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separatorChars splits on whitespace.</p>\n+     *\n+     * <pre>\n+     * StringUtils.split(null, *)         = null\n+     * StringUtils.split(\"\", *)           = []\n+     * StringUtils.split(\"abc def\", null) = [\"abc\", \"def\"]\n+     * StringUtils.split(\"abc def\", \" \")  = [\"abc\", \"def\"]\n+     * StringUtils.split(\"abc  def\", \" \") = [\"abc\", \"def\"]\n+     * StringUtils.split(\"ab:cd:ef\", \":\") = [\"ab\", \"cd\", \"ef\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separatorChars  the characters used as the delimiters,\n+     *  <code>null</code> splits on whitespace\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    public static String[] split(String str, String separatorChars) {\n+        return splitWorker(str, separatorChars, -1, false);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array with a maximum length,\n+     * separators specified.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as one separator.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separatorChars splits on whitespace.</p>\n+     *\n+     * <p>If more than <code>max</code> delimited substrings are found, the last\n+     * returned string includes all characters after the first <code>max - 1</code>\n+     * returned strings (including separator characters).</p>\n+     *\n+     * <pre>\n+     * StringUtils.split(null, *, *)            = null\n+     * StringUtils.split(\"\", *, *)              = []\n+     * StringUtils.split(\"ab de fg\", null, 0)   = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.split(\"ab   de fg\", null, 0) = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.split(\"ab:cd:ef\", \":\", 0)    = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.split(\"ab:cd:ef\", \":\", 2)    = [\"ab\", \"cd:ef\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separatorChars  the characters used as the delimiters,\n+     *  <code>null</code> splits on whitespace\n+     * @param max  the maximum number of elements to include in the\n+     *  array. A zero or negative value implies no limit\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    public static String[] split(String str, String separatorChars, int max) {\n+        return splitWorker(str, separatorChars, max, false);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separator string specified.</p>\n+     *\n+     * <p>The separator(s) will not be included in the returned String array.\n+     * Adjacent separators are treated as one separator.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separator splits on whitespace.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitByWholeSeparator(null, *)               = null\n+     * StringUtils.splitByWholeSeparator(\"\", *)                 = []\n+     * StringUtils.splitByWholeSeparator(\"ab de fg\", null)      = [\"ab\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparator(\"ab   de fg\", null)    = [\"ab\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparator(\"ab:cd:ef\", \":\")       = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\") = [\"ab\", \"cd\", \"ef\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separator  String containing the String to be used as a delimiter,\n+     *  <code>null</code> splits on whitespace\n+     * @return an array of parsed Strings, <code>null</code> if null String was input\n+     */\n+    public static String[] splitByWholeSeparator(String str, String separator) {\n+        return splitByWholeSeparatorWorker( str, separator, -1, false ) ;\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separator string specified.\n+     * Returns a maximum of <code>max</code> substrings.</p>\n+     *\n+     * <p>The separator(s) will not be included in the returned String array.\n+     * Adjacent separators are treated as one separator.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separator splits on whitespace.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitByWholeSeparator(null, *, *)               = null\n+     * StringUtils.splitByWholeSeparator(\"\", *, *)                 = []\n+     * StringUtils.splitByWholeSeparator(\"ab de fg\", null, 0)      = [\"ab\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparator(\"ab   de fg\", null, 0)    = [\"ab\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparator(\"ab:cd:ef\", \":\", 2)       = [\"ab\", \"cd:ef\"]\n+     * StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\", 5) = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\", 2) = [\"ab\", \"cd-!-ef\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separator  String containing the String to be used as a delimiter,\n+     *  <code>null</code> splits on whitespace\n+     * @param max  the maximum number of elements to include in the returned\n+     *  array. A zero or negative value implies no limit.\n+     * @return an array of parsed Strings, <code>null</code> if null String was input\n+     */\n+    public static String[] splitByWholeSeparator( String str, String separator, int max ) {\n+        return splitByWholeSeparatorWorker(str, separator, max, false);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separator string specified. </p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separator splits on whitespace.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *)               = null\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"\", *)                 = []\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab de fg\", null)      = [\"ab\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab   de fg\", null)    = [\"ab\", \"\", \"\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab:cd:ef\", \":\")       = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\") = [\"ab\", \"cd\", \"ef\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separator  String containing the String to be used as a delimiter,\n+     *  <code>null</code> splits on whitespace\n+     * @return an array of parsed Strings, <code>null</code> if null String was input\n+     * @since 2.4\n+     */\n+    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {\n+        return splitByWholeSeparatorWorker(str, separator, -1, true);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separator string specified.\n+     * Returns a maximum of <code>max</code> substrings.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separator splits on whitespace.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *, *)               = null\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"\", *, *)                 = []\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab de fg\", null, 0)      = [\"ab\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab   de fg\", null, 0)    = [\"ab\", \"\", \"\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab:cd:ef\", \":\", 2)       = [\"ab\", \"cd:ef\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\", 5) = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\", 2) = [\"ab\", \"cd-!-ef\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separator  String containing the String to be used as a delimiter,\n+     *  <code>null</code> splits on whitespace\n+     * @param max  the maximum number of elements to include in the returned\n+     *  array. A zero or negative value implies no limit.\n+     * @return an array of parsed Strings, <code>null</code> if null String was input\n+     * @since 2.4\n+     */\n+    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) {\n+        return splitByWholeSeparatorWorker(str, separator, max, true);\n+    }\n+\n+    /**\n+     * Performs the logic for the <code>splitByWholeSeparatorPreserveAllTokens</code> methods.\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separator  String containing the String to be used as a delimiter,\n+     *  <code>null</code> splits on whitespace\n+     * @param max  the maximum number of elements to include in the returned\n+     *  array. A zero or negative value implies no limit.\n+     * @param preserveAllTokens if <code>true</code>, adjacent separators are\n+     * treated as empty token separators; if <code>false</code>, adjacent\n+     * separators are treated as one separator.\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.4\n+     */\n+    private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, \n+                                                        boolean preserveAllTokens) \n+    {\n+        if (str == null) {\n+            return null;\n+        }\n+\n+        int len = str.length();\n+\n+        if (len == 0) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+\n+        if ((separator == null) || (EMPTY.equals(separator))) {\n+            // Split on whitespace.\n+            return splitWorker(str, null, max, preserveAllTokens);\n+        }\n+\n+        int separatorLength = separator.length();\n+\n+        ArrayList<String> substrings = new ArrayList<String>();\n+        int numberOfSubstrings = 0;\n+        int beg = 0;\n+        int end = 0;\n+        while (end < len) {\n+            end = str.indexOf(separator, beg);\n+\n+            if (end > -1) {\n+                if (end > beg) {\n+                    numberOfSubstrings += 1;\n+\n+                    if (numberOfSubstrings == max) {\n+                        end = len;\n+                        substrings.add(str.substring(beg));\n+                    } else {\n+                        // The following is OK, because String.substring( beg, end ) excludes\n+                        // the character at the position 'end'.\n+                        substrings.add(str.substring(beg, end));\n+\n+                        // Set the starting point for the next search.\n+                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n+                        // which is the right calculation:\n+                        beg = end + separatorLength;\n+                    }\n+                } else {\n+                    // We found a consecutive occurrence of the separator, so skip it.\n+                    if (preserveAllTokens) {\n+                        numberOfSubstrings += 1;\n+                        if (numberOfSubstrings == max) {\n+                            end = len;\n+                            substrings.add(str.substring(beg));\n+                        } else {\n+                            substrings.add(EMPTY);\n+                        }\n+                    }\n+                    beg = end + separatorLength;\n+                }\n+            } else {\n+                // String.substring( beg ) goes from 'beg' to the end of the String.\n+                substrings.add(str.substring(beg));\n+                end = len;\n+            }\n+        }\n+\n+        return substrings.toArray(new String[substrings.size()]);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * <p>Splits the provided text into an array, using whitespace as the\n+     * separator, preserving all tokens, including empty tokens created by \n+     * adjacent separators. This is an alternative to using StringTokenizer.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitPreserveAllTokens(null)       = null\n+     * StringUtils.splitPreserveAllTokens(\"\")         = []\n+     * StringUtils.splitPreserveAllTokens(\"abc def\")  = [\"abc\", \"def\"]\n+     * StringUtils.splitPreserveAllTokens(\"abc  def\") = [\"abc\", \"\", \"def\"]\n+     * StringUtils.splitPreserveAllTokens(\" abc \")    = [\"\", \"abc\", \"\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String[] splitPreserveAllTokens(String str) {\n+        return splitWorker(str, null, -1, true);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separator specified,\n+     * preserving all tokens, including empty tokens created by adjacent\n+     * separators. This is an alternative to using StringTokenizer.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitPreserveAllTokens(null, *)         = null\n+     * StringUtils.splitPreserveAllTokens(\"\", *)           = []\n+     * StringUtils.splitPreserveAllTokens(\"a.b.c\", '.')    = [\"a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\"a..b.c\", '.')   = [\"a\", \"\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\"a:b:c\", '.')    = [\"a:b:c\"]\n+     * StringUtils.splitPreserveAllTokens(\"a\\tb\\nc\", null) = [\"a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\"a b c\", ' ')    = [\"a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\"a b c \", ' ')   = [\"a\", \"b\", \"c\", \"\"]\n+     * StringUtils.splitPreserveAllTokens(\"a b c  \", ' ')   = [\"a\", \"b\", \"c\", \"\", \"\"]\n+     * StringUtils.splitPreserveAllTokens(\" a b c\", ' ')   = [\"\", a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\"  a b c\", ' ')  = [\"\", \"\", a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\" a b c \", ' ')  = [\"\", a\", \"b\", \"c\", \"\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separatorChar  the character used as the delimiter,\n+     *  <code>null</code> splits on whitespace\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String[] splitPreserveAllTokens(String str, char separatorChar) {\n+        return splitWorker(str, separatorChar, true);\n+    }\n+\n+    /**\n+     * Performs the logic for the <code>split</code> and \n+     * <code>splitPreserveAllTokens</code> methods that do not return a\n+     * maximum array length.\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separatorChar the separate character\n+     * @param preserveAllTokens if <code>true</code>, adjacent separators are\n+     * treated as empty token separators; if <code>false</code>, adjacent\n+     * separators are treated as one separator.\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) {\n+        // Performance tuned for 2.0 (JDK1.4)\n+\n+        if (str == null) {\n+            return null;\n+        }\n+        int len = str.length();\n+        if (len == 0) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        List<String> list = new ArrayList<String>();\n+        int i = 0, start = 0;\n+        boolean match = false;\n+        boolean lastMatch = false;\n+        while (i < len) {\n+            if (str.charAt(i) == separatorChar) {\n+                if (match || preserveAllTokens) {\n+                    list.add(str.substring(start, i));\n+                    match = false;\n+                    lastMatch = true;\n+                }\n+                start = ++i;\n+                continue;\n+            }\n+            lastMatch = false;\n+            match = true;\n+            i++;\n+        }\n+        if (match || (preserveAllTokens && lastMatch)) {\n+            list.add(str.substring(start, i));\n+        }\n+        return list.toArray(new String[list.size()]);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separators specified, \n+     * preserving all tokens, including empty tokens created by adjacent\n+     * separators. This is an alternative to using StringTokenizer.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separatorChars splits on whitespace.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitPreserveAllTokens(null, *)           = null\n+     * StringUtils.splitPreserveAllTokens(\"\", *)             = []\n+     * StringUtils.splitPreserveAllTokens(\"abc def\", null)   = [\"abc\", \"def\"]\n+     * StringUtils.splitPreserveAllTokens(\"abc def\", \" \")    = [\"abc\", \"def\"]\n+     * StringUtils.splitPreserveAllTokens(\"abc  def\", \" \")   = [\"abc\", \"\", def\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\")   = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef:\", \":\")  = [\"ab\", \"cd\", \"ef\", \"\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef::\", \":\") = [\"ab\", \"cd\", \"ef\", \"\", \"\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab::cd:ef\", \":\")  = [\"ab\", \"\", cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\":cd:ef\", \":\")     = [\"\", cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"::cd:ef\", \":\")    = [\"\", \"\", cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\":cd:ef:\", \":\")    = [\"\", cd\", \"ef\", \"\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separatorChars  the characters used as the delimiters,\n+     *  <code>null</code> splits on whitespace\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String[] splitPreserveAllTokens(String str, String separatorChars) {\n+        return splitWorker(str, separatorChars, -1, true);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array with a maximum length,\n+     * separators specified, preserving all tokens, including empty tokens \n+     * created by adjacent separators.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * Adjacent separators are treated as one separator.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separatorChars splits on whitespace.</p>\n+     *\n+     * <p>If more than <code>max</code> delimited substrings are found, the last\n+     * returned string includes all characters after the first <code>max - 1</code>\n+     * returned strings (including separator characters).</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitPreserveAllTokens(null, *, *)            = null\n+     * StringUtils.splitPreserveAllTokens(\"\", *, *)              = []\n+     * StringUtils.splitPreserveAllTokens(\"ab de fg\", null, 0)   = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 0) = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\", 0)    = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\", 2)    = [\"ab\", \"cd:ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 2) = [\"ab\", \"  de fg\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 3) = [\"ab\", \"\", \" de fg\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 4) = [\"ab\", \"\", \"\", \"de fg\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separatorChars  the characters used as the delimiters,\n+     *  <code>null</code> splits on whitespace\n+     * @param max  the maximum number of elements to include in the\n+     *  array. A zero or negative value implies no limit\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {\n+        return splitWorker(str, separatorChars, max, true);\n+    }\n+\n+    /**\n+     * Performs the logic for the <code>split</code> and \n+     * <code>splitPreserveAllTokens</code> methods that return a maximum array \n+     * length.\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separatorChars the separate character\n+     * @param max  the maximum number of elements to include in the\n+     *  array. A zero or negative value implies no limit.\n+     * @param preserveAllTokens if <code>true</code>, adjacent separators are\n+     * treated as empty token separators; if <code>false</code>, adjacent\n+     * separators are treated as one separator.\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n+        // Performance tuned for 2.0 (JDK1.4)\n+        // Direct code is quicker than StringTokenizer.\n+        // Also, StringTokenizer uses isSpace() not isWhitespace()\n+\n+        if (str == null) {\n+            return null;\n+        }\n+        int len = str.length();\n+        if (len == 0) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        List<String> list = new ArrayList<String>();\n+        int sizePlus1 = 1;\n+        int i = 0, start = 0;\n+        boolean match = false;\n+        boolean lastMatch = false;\n+        if (separatorChars == null) {\n+            // Null separator means use whitespace\n+            while (i < len) {\n+                if (Character.isWhitespace(str.charAt(i))) {\n+                    if (match || preserveAllTokens) {\n+                        lastMatch = true;\n+                        if (sizePlus1++ == max) {\n+                            i = len;\n+                            lastMatch = false;\n+                        }\n+                        list.add(str.substring(start, i));\n+                        match = false;\n+                    }\n+                    start = ++i;\n+                    continue;\n+                }\n+                lastMatch = false;\n+                match = true;\n+                i++;\n+            }\n+        } else if (separatorChars.length() == 1) {\n+            // Optimise 1 character case\n+            char sep = separatorChars.charAt(0);\n+            while (i < len) {\n+                if (str.charAt(i) == sep) {\n+                    if (match || preserveAllTokens) {\n+                        lastMatch = true;\n+                        if (sizePlus1++ == max) {\n+                            i = len;\n+                            lastMatch = false;\n+                        }\n+                        list.add(str.substring(start, i));\n+                        match = false;\n+                    }\n+                    start = ++i;\n+                    continue;\n+                }\n+                lastMatch = false;\n+                match = true;\n+                i++;\n+            }\n+        } else {\n+            // standard case\n+            while (i < len) {\n+                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n+                    if (match || preserveAllTokens) {\n+                        lastMatch = true;\n+                        if (sizePlus1++ == max) {\n+                            i = len;\n+                            lastMatch = false;\n+                        }\n+                        list.add(str.substring(start, i));\n+                        match = false;\n+                    }\n+                    start = ++i;\n+                    continue;\n+                }\n+                lastMatch = false;\n+                match = true;\n+                i++;\n+            }\n+        }\n+        if (match || (preserveAllTokens && lastMatch)) {\n+            list.add(str.substring(start, i));\n+        }\n+        return list.toArray(new String[list.size()]);\n+    }\n+\n+    /**\n+     * <p>Splits a String by Character type as returned by\n+     * <code>java.lang.Character.getType(char)</code>. Groups of contiguous\n+     * characters of the same type are returned as complete tokens. \n+     * <pre>\n+     * StringUtils.splitByCharacterType(null)         = null\n+     * StringUtils.splitByCharacterType(\"\")           = []\n+     * StringUtils.splitByCharacterType(\"ab de fg\")   = [\"ab\", \" \", \"de\", \" \", \"fg\"]\n+     * StringUtils.splitByCharacterType(\"ab   de fg\") = [\"ab\", \"   \", \"de\", \" \", \"fg\"]\n+     * StringUtils.splitByCharacterType(\"ab:cd:ef\")   = [\"ab\", \":\", \"cd\", \":\", \"ef\"]\n+     * StringUtils.splitByCharacterType(\"number5\")    = [\"number\", \"5\"]\n+     * StringUtils.splitByCharacterType(\"fooBar\")     = [\"foo\", \"B\", \"ar\"]\n+     * StringUtils.splitByCharacterType(\"foo200Bar\")  = [\"foo\", \"200\", \"B\", \"ar\"]\n+     * StringUtils.splitByCharacterType(\"ASFRules\")   = [\"ASFR\", \"ules\"]\n+     * </pre>\n+     * @param str the String to split, may be <code>null</code>\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.4\n+     */\n+    public static String[] splitByCharacterType(String str) {\n+        return splitByCharacterType(str, false);\n+    }\n+\n+    /**\n+     * <p>Splits a String by Character type as returned by\n+     * <code>java.lang.Character.getType(char)</code>. Groups of contiguous\n+     * characters of the same type are returned as complete tokens, with the\n+     * following exception: the character of type\n+     * <code>Character.UPPERCASE_LETTER</code>, if any, immediately\n+     * preceding a token of type <code>Character.LOWERCASE_LETTER</code>\n+     * will belong to the following token rather than to the preceding, if any,\n+     * <code>Character.UPPERCASE_LETTER</code> token. \n+     * <pre>\n+     * StringUtils.splitByCharacterTypeCamelCase(null)         = null\n+     * StringUtils.splitByCharacterTypeCamelCase(\"\")           = []\n+     * StringUtils.splitByCharacterTypeCamelCase(\"ab de fg\")   = [\"ab\", \" \", \"de\", \" \", \"fg\"]\n+     * StringUtils.splitByCharacterTypeCamelCase(\"ab   de fg\") = [\"ab\", \"   \", \"de\", \" \", \"fg\"]\n+     * StringUtils.splitByCharacterTypeCamelCase(\"ab:cd:ef\")   = [\"ab\", \":\", \"cd\", \":\", \"ef\"]\n+     * StringUtils.splitByCharacterTypeCamelCase(\"number5\")    = [\"number\", \"5\"]\n+     * StringUtils.splitByCharacterTypeCamelCase(\"fooBar\")     = [\"foo\", \"Bar\"]\n+     * StringUtils.splitByCharacterTypeCamelCase(\"foo200Bar\")  = [\"foo\", \"200\", \"Bar\"]\n+     * StringUtils.splitByCharacterTypeCamelCase(\"ASFRules\")   = [\"ASF\", \"Rules\"]\n+     * </pre>\n+     * @param str the String to split, may be <code>null</code>\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.4\n+     */\n+    public static String[] splitByCharacterTypeCamelCase(String str) {\n+        return splitByCharacterType(str, true);\n+    }\n+\n+    /**\n+     * <p>Splits a String by Character type as returned by\n+     * <code>java.lang.Character.getType(char)</code>. Groups of contiguous\n+     * characters of the same type are returned as complete tokens, with the\n+     * following exception: if <code>camelCase</code> is <code>true</code>,\n+     * the character of type <code>Character.UPPERCASE_LETTER</code>, if any,\n+     * immediately preceding a token of type <code>Character.LOWERCASE_LETTER</code>\n+     * will belong to the following token rather than to the preceding, if any,\n+     * <code>Character.UPPERCASE_LETTER</code> token. \n+     * @param str the String to split, may be <code>null</code>\n+     * @param camelCase whether to use so-called \"camel-case\" for letter types\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.4\n+     */\n+    private static String[] splitByCharacterType(String str, boolean camelCase) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (str.length() == 0) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        char[] c = str.toCharArray();\n+        List<String> list = new ArrayList<String>();\n+        int tokenStart = 0;\n+        int currentType = Character.getType(c[tokenStart]);\n+        for (int pos = tokenStart + 1; pos < c.length; pos++) {\n+            int type = Character.getType(c[pos]);\n+            if (type == currentType) {\n+                continue;\n+            }\n+            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n+                int newTokenStart = pos - 1;\n+                if (newTokenStart != tokenStart) {\n+                    list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n+                    tokenStart = newTokenStart;\n+                }\n+            } else {\n+                list.add(new String(c, tokenStart, pos - tokenStart));\n+                tokenStart = pos;\n+            }\n+            currentType = type;\n+        }\n+        list.add(new String(c, tokenStart, c.length - tokenStart));\n+        return list.toArray(new String[list.size()]);\n+    }\n+\n+    // Joining\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Joins the elements of the provided array into a single String\n+     * containing the provided list of elements.</p>\n+     *\n+     * <p>No separator is added to the joined String.\n+     * Null objects or empty strings within the array are represented by\n+     * empty strings.</p>\n+     *\n+     * <pre>\n+     * StringUtils.join(null)            = null\n+     * StringUtils.join([])              = \"\"\n+     * StringUtils.join([null])          = \"\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"]) = \"abc\"\n+     * StringUtils.join([null, \"\", \"a\"]) = \"a\"\n+     * </pre>\n+     *\n+     * @param array  the array of values to join together, may be null\n+     * @return the joined String, <code>null</code> if null array input\n+     * @since 2.0\n+     */\n+    public static String join(Object[] array) {\n+        return join(array, null);\n+    }\n+\n+    /**\n+     * <p>Joins the elements of the provided array into a single String\n+     * containing the provided list of elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list.\n+     * Null objects or empty strings within the array are represented by\n+     * empty strings.</p>\n+     *\n+     * <pre>\n+     * StringUtils.join(null, *)               = null\n+     * StringUtils.join([], *)                 = \"\"\n+     * StringUtils.join([null], *)             = \"\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], ';')  = \"a;b;c\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], null) = \"abc\"\n+     * StringUtils.join([null, \"\", \"a\"], ';')  = \";;a\"\n+     * </pre>\n+     *\n+     * @param array  the array of values to join together, may be null\n+     * @param separator  the separator character to use\n+     * @return the joined String, <code>null</code> if null array input\n+     * @since 2.0\n+     */\n+    public static String join(Object[] array, char separator) {\n+        if (array == null) {\n+            return null;\n+        }\n+\n+        return join(array, separator, 0, array.length);\n+    }\n+\n+    /**\n+     * <p>Joins the elements of the provided array into a single String\n+     * containing the provided list of elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list.\n+     * Null objects or empty strings within the array are represented by\n+     * empty strings.</p>\n+     *\n+     * <pre>\n+     * StringUtils.join(null, *)               = null\n+     * StringUtils.join([], *)                 = \"\"\n+     * StringUtils.join([null], *)             = \"\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], ';')  = \"a;b;c\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], null) = \"abc\"\n+     * StringUtils.join([null, \"\", \"a\"], ';')  = \";;a\"\n+     * </pre>\n+     *\n+     * @param array  the array of values to join together, may be null\n+     * @param separator  the separator character to use\n+     * @param startIndex the first index to start joining from.  It is\n+     * an error to pass in an end index past the end of the array\n+     * @param endIndex the index to stop joining from (exclusive). It is\n+     * an error to pass in an end index past the end of the array\n+     * @return the joined String, <code>null</code> if null array input\n+     * @since 2.0\n+     */\n+    public static String join(Object[] array, char separator, int startIndex, int endIndex) {\n+        if (array == null) {\n+            return null;\n+        }\n+        int bufSize = (endIndex - startIndex);\n+        if (bufSize <= 0) {\n+            return EMPTY;\n+        }\n+\n+        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n+        StringBuilder buf = new StringBuilder(bufSize);\n+\n+        for (int i = startIndex; i < endIndex; i++) {\n+            if (i > startIndex) {\n+                buf.append(separator);\n+            }\n+            if (array[i] != null) {\n+                buf.append(array[i]);\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+\n+    /**\n+     * <p>Joins the elements of the provided array into a single String\n+     * containing the provided list of elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list.\n+     * A <code>null</code> separator is the same as an empty String (\"\").\n+     * Null objects or empty strings within the array are represented by\n+     * empty strings.</p>\n+     *\n+     * <pre>\n+     * StringUtils.join(null, *)                = null\n+     * StringUtils.join([], *)                  = \"\"\n+     * StringUtils.join([null], *)              = \"\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], \"--\")  = \"a--b--c\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], null)  = \"abc\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], \"\")    = \"abc\"\n+     * StringUtils.join([null, \"\", \"a\"], ',')   = \",,a\"\n+     * </pre>\n+     *\n+     * @param array  the array of values to join together, may be null\n+     * @param separator  the separator character to use, null treated as \"\"\n+     * @return the joined String, <code>null</code> if null array input\n+     */\n+    public static String join(Object[] array, String separator) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return join(array, separator, 0, array.length);\n+    }\n+\n+    /**\n+     * <p>Joins the elements of the provided array into a single String\n+     * containing the provided list of elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list.\n+     * A <code>null</code> separator is the same as an empty String (\"\").\n+     * Null objects or empty strings within the array are represented by\n+     * empty strings.</p>\n+     *\n+     * <pre>\n+     * StringUtils.join(null, *)                = null\n+     * StringUtils.join([], *)                  = \"\"\n+     * StringUtils.join([null], *)              = \"\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], \"--\")  = \"a--b--c\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], null)  = \"abc\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], \"\")    = \"abc\"\n+     * StringUtils.join([null, \"\", \"a\"], ',')   = \",,a\"\n+     * </pre>\n+     *\n+     * @param array  the array of values to join together, may be null\n+     * @param separator  the separator character to use, null treated as \"\"\n+     * @param startIndex the first index to start joining from.  It is\n+     * an error to pass in an end index past the end of the array\n+     * @param endIndex the index to stop joining from (exclusive). It is\n+     * an error to pass in an end index past the end of the array\n+     * @return the joined String, <code>null</code> if null array input\n+     */\n+    public static String join(Object[] array, String separator, int startIndex, int endIndex) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (separator == null) {\n+            separator = EMPTY;\n+        }\n+\n+        // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))\n+        //           (Assuming that all Strings are roughly equally long)\n+        int bufSize = (endIndex - startIndex);\n+        if (bufSize <= 0) {\n+            return EMPTY;\n+        }\n+\n+        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length())\n+                        + separator.length());\n+\n+        StringBuilder buf = new StringBuilder(bufSize);\n+\n+        for (int i = startIndex; i < endIndex; i++) {\n+            if (i > startIndex) {\n+                buf.append(separator);\n+            }\n+            if (array[i] != null) {\n+                buf.append(array[i]);\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * <p>Joins the elements of the provided <code>Iterator</code> into\n+     * a single String containing the provided elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list. Null objects or empty\n+     * strings within the iteration are represented by empty strings.</p>\n+     *\n+     * <p>See the examples here: {@link #join(Object[],char)}. </p>\n+     *\n+     * @param iterator  the <code>Iterator</code> of values to join together, may be null\n+     * @param separator  the separator character to use\n+     * @return the joined String, <code>null</code> if null iterator input\n+     * @since 2.0\n+     */\n+    public static String join(Iterator<?> iterator, char separator) {\n+\n+        // handle null, zero and one elements before building a buffer\n+        if (iterator == null) {\n+            return null;\n+        }\n+        if (!iterator.hasNext()) {\n+            return EMPTY;\n+        }\n+        Object first = iterator.next();\n+        if (!iterator.hasNext()) {\n+            return ObjectUtils.toString(first);\n+        }\n+\n+        // two or more elements\n+        StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small\n+        if (first != null) {\n+            buf.append(first);\n+        }\n+\n+        while (iterator.hasNext()) {\n+            buf.append(separator);\n+            Object obj = iterator.next();\n+            if (obj != null) {\n+                buf.append(obj);\n+            }\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * <p>Joins the elements of the provided <code>Iterator</code> into\n+     * a single String containing the provided elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list.\n+     * A <code>null</code> separator is the same as an empty String (\"\").</p>\n+     *\n+     * <p>See the examples here: {@link #join(Object[],String)}. </p>\n+     *\n+     * @param iterator  the <code>Iterator</code> of values to join together, may be null\n+     * @param separator  the separator character to use, null treated as \"\"\n+     * @return the joined String, <code>null</code> if null iterator input\n+     */\n+    public static String join(Iterator<?> iterator, String separator) {\n+\n+        // handle null, zero and one elements before building a buffer\n+        if (iterator == null) {\n+            return null;\n+        }\n+        if (!iterator.hasNext()) {\n+            return EMPTY;\n+        }\n+        Object first = iterator.next();\n+        if (!iterator.hasNext()) {\n+            return ObjectUtils.toString(first);\n+        }\n+\n+        // two or more elements\n+        StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small\n+        if (first != null) {\n+            buf.append(first);\n+        }\n+\n+        while (iterator.hasNext()) {\n+            if (separator != null) {\n+                buf.append(separator);\n+            }\n+            Object obj = iterator.next();\n+            if (obj != null) {\n+                buf.append(obj);\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * <p>Joins the elements of the provided <code>Iterable</code> into\n+     * a single String containing the provided elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list. Null objects or empty\n+     * strings within the iteration are represented by empty strings.</p>\n+     *\n+     * <p>See the examples here: {@link #join(Object[],char)}. </p>\n+     *\n+     * @param iterable  the <code>Iterable</code> providing the values to join together, may be null\n+     * @param separator  the separator character to use\n+     * @return the joined String, <code>null</code> if null iterator input\n+     * @since 2.3\n+     */\n+    public static String join(Iterable<?> iterable, char separator) {\n+        if (iterable == null) {\n+            return null;\n+        }\n+        return join(iterable.iterator(), separator);\n+    }\n+\n+    /**\n+     * <p>Joins the elements of the provided <code>Iterable</code> into\n+     * a single String containing the provided elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list.\n+     * A <code>null</code> separator is the same as an empty String (\"\").</p>\n+     *\n+     * <p>See the examples here: {@link #join(Object[],String)}. </p>\n+     *\n+     * @param iterable  the <code>Iterable</code> providing the values to join together, may be null\n+     * @param separator  the separator character to use, null treated as \"\"\n+     * @return the joined String, <code>null</code> if null iterator input\n+     * @since 2.3\n+     */\n+    public static String join(Iterable<?> iterable, String separator) {\n+        if (iterable == null) {\n+            return null;\n+        }\n+        return join(iterable.iterator(), separator);\n+    }\n+\n+    // Delete\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Deletes all whitespaces from a String as defined by\n+     * {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.deleteWhitespace(null)         = null\n+     * StringUtils.deleteWhitespace(\"\")           = \"\"\n+     * StringUtils.deleteWhitespace(\"abc\")        = \"abc\"\n+     * StringUtils.deleteWhitespace(\"   ab  c  \") = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to delete whitespace from, may be null\n+     * @return the String without whitespaces, <code>null</code> if null String input\n+     */\n+    public static String deleteWhitespace(String str) {\n+        if (isEmpty(str)) {\n+            return str;\n+        }\n+        int sz = str.length();\n+        char[] chs = new char[sz];\n+        int count = 0;\n+        for (int i = 0; i < sz; i++) {\n+            if (!Character.isWhitespace(str.charAt(i))) {\n+                chs[count++] = str.charAt(i);\n+            }\n+        }\n+        if (count == sz) {\n+            return str;\n+        }\n+        return new String(chs, 0, count);\n+    }\n+\n+    // Remove\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Removes a substring only if it is at the begining of a source string,\n+     * otherwise returns the source string.</p>\n+     *\n+     * <p>A <code>null</code> source string will return <code>null</code>.\n+     * An empty (\"\") source string will return the empty string.\n+     * A <code>null</code> search string will return the source string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.removeStart(null, *)      = null\n+     * StringUtils.removeStart(\"\", *)        = \"\"\n+     * StringUtils.removeStart(*, null)      = *\n+     * StringUtils.removeStart(\"www.domain.com\", \"www.\")   = \"domain.com\"\n+     * StringUtils.removeStart(\"domain.com\", \"www.\")       = \"domain.com\"\n+     * StringUtils.removeStart(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n+     * StringUtils.removeStart(\"abc\", \"\")    = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the source String to search, may be null\n+     * @param remove  the String to search for and remove, may be null\n+     * @return the substring with the string removed if found,\n+     *  <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String removeStart(String str, String remove) {\n+        if (isEmpty(str) || isEmpty(remove)) {\n+            return str;\n+        }\n+        if (str.startsWith(remove)){\n+            return str.substring(remove.length());\n+        }\n+        return str;\n+    }\n+\n+    /**\n+     * <p>Case insensitive removal of a substring if it is at the begining of a source string,\n+     * otherwise returns the source string.</p>\n+     *\n+     * <p>A <code>null</code> source string will return <code>null</code>.\n+     * An empty (\"\") source string will return the empty string.\n+     * A <code>null</code> search string will return the source string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.removeStartIgnoreCase(null, *)      = null\n+     * StringUtils.removeStartIgnoreCase(\"\", *)        = \"\"\n+     * StringUtils.removeStartIgnoreCase(*, null)      = *\n+     * StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"www.\")   = \"domain.com\"\n+     * StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"WWW.\")   = \"domain.com\"\n+     * StringUtils.removeStartIgnoreCase(\"domain.com\", \"www.\")       = \"domain.com\"\n+     * StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n+     * StringUtils.removeStartIgnoreCase(\"abc\", \"\")    = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the source String to search, may be null\n+     * @param remove  the String to search for (case insensitive) and remove, may be null\n+     * @return the substring with the string removed if found,\n+     *  <code>null</code> if null String input\n+     * @since 2.4\n+     */\n+    public static String removeStartIgnoreCase(String str, String remove) {\n+        if (isEmpty(str) || isEmpty(remove)) {\n+            return str;\n+        }\n+        if (startsWithIgnoreCase(str, remove)) {\n+            return str.substring(remove.length());\n+        }\n+        return str;\n+    }\n+\n+    /**\n+     * <p>Removes a substring only if it is at the end of a source string,\n+     * otherwise returns the source string.</p>\n+     *\n+     * <p>A <code>null</code> source string will return <code>null</code>.\n+     * An empty (\"\") source string will return the empty string.\n+     * A <code>null</code> search string will return the source string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.removeEnd(null, *)      = null\n+     * StringUtils.removeEnd(\"\", *)        = \"\"\n+     * StringUtils.removeEnd(*, null)      = *\n+     * StringUtils.removeEnd(\"www.domain.com\", \".com.\")  = \"www.domain.com\"\n+     * StringUtils.removeEnd(\"www.domain.com\", \".com\")   = \"www.domain\"\n+     * StringUtils.removeEnd(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n+     * StringUtils.removeEnd(\"abc\", \"\")    = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the source String to search, may be null\n+     * @param remove  the String to search for and remove, may be null\n+     * @return the substring with the string removed if found,\n+     *  <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String removeEnd(String str, String remove) {\n+        if (isEmpty(str) || isEmpty(remove)) {\n+            return str;\n+        }\n+        if (str.endsWith(remove)) {\n+            return str.substring(0, str.length() - remove.length());\n+        }\n+        return str;\n+    }\n+\n+    /**\n+     * <p>Case insensitive removal of a substring if it is at the end of a source string,\n+     * otherwise returns the source string.</p>\n+     *\n+     * <p>A <code>null</code> source string will return <code>null</code>.\n+     * An empty (\"\") source string will return the empty string.\n+     * A <code>null</code> search string will return the source string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.removeEnd(null, *)      = null\n+     * StringUtils.removeEnd(\"\", *)        = \"\"\n+     * StringUtils.removeEnd(*, null)      = *\n+     * StringUtils.removeEnd(\"www.domain.com\", \".com.\")  = \"www.domain.com.\"\n+     * StringUtils.removeEnd(\"www.domain.com\", \".com\")   = \"www.domain\"\n+     * StringUtils.removeEnd(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n+     * StringUtils.removeEnd(\"abc\", \"\")    = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the source String to search, may be null\n+     * @param remove  the String to search for (case insensitive) and remove, may be null\n+     * @return the substring with the string removed if found,\n+     *  <code>null</code> if null String input\n+     * @since 2.4\n+     */\n+    public static String removeEndIgnoreCase(String str, String remove) {\n+        if (isEmpty(str) || isEmpty(remove)) {\n+            return str;\n+        }\n+        if (endsWithIgnoreCase(str, remove)) {\n+            return str.substring(0, str.length() - remove.length());\n+        }\n+        return str;\n+    }\n+\n+    /**\n+     * <p>Removes all occurrences of a substring from within the source string.</p>\n+     *\n+     * <p>A <code>null</code> source string will return <code>null</code>.\n+     * An empty (\"\") source string will return the empty string.\n+     * A <code>null</code> remove string will return the source string.\n+     * An empty (\"\") remove string will return the source string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.remove(null, *)        = null\n+     * StringUtils.remove(\"\", *)          = \"\"\n+     * StringUtils.remove(*, null)        = *\n+     * StringUtils.remove(*, \"\")          = *\n+     * StringUtils.remove(\"queued\", \"ue\") = \"qd\"\n+     * StringUtils.remove(\"queued\", \"zz\") = \"queued\"\n+     * </pre>\n+     *\n+     * @param str  the source String to search, may be null\n+     * @param remove  the String to search for and remove, may be null\n+     * @return the substring with the string removed if found,\n+     *  <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String remove(String str, String remove) {\n+        if (isEmpty(str) || isEmpty(remove)) {\n+            return str;\n+        }\n+        return replace(str, remove, EMPTY, -1);\n+    }\n+\n+    /**\n+     * <p>Removes all occurrences of a character from within the source string.</p>\n+     *\n+     * <p>A <code>null</code> source string will return <code>null</code>.\n+     * An empty (\"\") source string will return the empty string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.remove(null, *)       = null\n+     * StringUtils.remove(\"\", *)         = \"\"\n+     * StringUtils.remove(\"queued\", 'u') = \"qeed\"\n+     * StringUtils.remove(\"queued\", 'z') = \"queued\"\n+     * </pre>\n+     *\n+     * @param str  the source String to search, may be null\n+     * @param remove  the char to search for and remove, may be null\n+     * @return the substring with the char removed if found,\n+     *  <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String remove(String str, char remove) {\n+        if (isEmpty(str) || str.indexOf(remove) == -1) {\n+            return str;\n+        }\n+        char[] chars = str.toCharArray();\n+        int pos = 0;\n+        for (int i = 0; i < chars.length; i++) {\n+            if (chars[i] != remove) {\n+                chars[pos++] = chars[i];\n+            }\n+        }\n+        return new String(chars, 0, pos);\n+    }\n+\n+    // Replacing\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Replaces a String with another String inside a larger String, once.</p>\n+     *\n+     * <p>A <code>null</code> reference passed to this method is a no-op.</p>\n+     *\n+     * <pre>\n+     * StringUtils.replaceOnce(null, *, *)        = null\n+     * StringUtils.replaceOnce(\"\", *, *)          = \"\"\n+     * StringUtils.replaceOnce(\"any\", null, *)    = \"any\"\n+     * StringUtils.replaceOnce(\"any\", *, null)    = \"any\"\n+     * StringUtils.replaceOnce(\"any\", \"\", *)      = \"any\"\n+     * StringUtils.replaceOnce(\"aba\", \"a\", null)  = \"aba\"\n+     * StringUtils.replaceOnce(\"aba\", \"a\", \"\")    = \"ba\"\n+     * StringUtils.replaceOnce(\"aba\", \"a\", \"z\")   = \"zba\"\n+     * </pre>\n+     *\n+     * @see #replace(String text, String searchString, String replacement, int max)\n+     * @param text  text to search and replace in, may be null\n+     * @param searchString  the String to search for, may be null\n+     * @param replacement  the String to replace with, may be null\n+     * @return the text with any replacements processed,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String replaceOnce(String text, String searchString, String replacement) {\n+        return replace(text, searchString, replacement, 1);\n+    }\n+\n+    /**\n+     * <p>Replaces all occurrences of a String within another String.</p>\n+     *\n+     * <p>A <code>null</code> reference passed to this method is a no-op.</p>\n+     *\n+     * <pre>\n+     * StringUtils.replace(null, *, *)        = null\n+     * StringUtils.replace(\"\", *, *)          = \"\"\n+     * StringUtils.replace(\"any\", null, *)    = \"any\"\n+     * StringUtils.replace(\"any\", *, null)    = \"any\"\n+     * StringUtils.replace(\"any\", \"\", *)      = \"any\"\n+     * StringUtils.replace(\"aba\", \"a\", null)  = \"aba\"\n+     * StringUtils.replace(\"aba\", \"a\", \"\")    = \"b\"\n+     * StringUtils.replace(\"aba\", \"a\", \"z\")   = \"zbz\"\n+     * </pre>\n+     *\n+     * @see #replace(String text, String searchString, String replacement, int max)\n+     * @param text  text to search and replace in, may be null\n+     * @param searchString  the String to search for, may be null\n+     * @param replacement  the String to replace it with, may be null\n+     * @return the text with any replacements processed,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String replace(String text, String searchString, String replacement) {\n+        return replace(text, searchString, replacement, -1);\n+    }\n+\n+    /**\n+     * <p>Replaces a String with another String inside a larger String,\n+     * for the first <code>max</code> values of the search String.</p>\n+     *\n+     * <p>A <code>null</code> reference passed to this method is a no-op.</p>\n+     *\n+     * <pre>\n+     * StringUtils.replace(null, *, *, *)         = null\n+     * StringUtils.replace(\"\", *, *, *)           = \"\"\n+     * StringUtils.replace(\"any\", null, *, *)     = \"any\"\n+     * StringUtils.replace(\"any\", *, null, *)     = \"any\"\n+     * StringUtils.replace(\"any\", \"\", *, *)       = \"any\"\n+     * StringUtils.replace(\"any\", *, *, 0)        = \"any\"\n+     * StringUtils.replace(\"abaa\", \"a\", null, -1) = \"abaa\"\n+     * StringUtils.replace(\"abaa\", \"a\", \"\", -1)   = \"b\"\n+     * StringUtils.replace(\"abaa\", \"a\", \"z\", 0)   = \"abaa\"\n+     * StringUtils.replace(\"abaa\", \"a\", \"z\", 1)   = \"zbaa\"\n+     * StringUtils.replace(\"abaa\", \"a\", \"z\", 2)   = \"zbza\"\n+     * StringUtils.replace(\"abaa\", \"a\", \"z\", -1)  = \"zbzz\"\n+     * </pre>\n+     *\n+     * @param text  text to search and replace in, may be null\n+     * @param searchString  the String to search for, may be null\n+     * @param replacement  the String to replace it with, may be null\n+     * @param max  maximum number of values to replace, or <code>-1</code> if no maximum\n+     * @return the text with any replacements processed,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String replace(String text, String searchString, String replacement, int max) {\n+        if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {\n+            return text;\n+        }\n+        int start = 0;\n+        int end = text.indexOf(searchString, start);\n+        if (end == -1) {\n+            return text;\n+        }\n+        int replLength = searchString.length();\n+        int increase = replacement.length() - replLength;\n+        increase = (increase < 0 ? 0 : increase);\n+        increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));\n+        StringBuilder buf = new StringBuilder(text.length() + increase);\n+        while (end != -1) {\n+            buf.append(text.substring(start, end)).append(replacement);\n+            start = end + replLength;\n+            if (--max == 0) {\n+                break;\n+            }\n+            end = text.indexOf(searchString, start);\n+        }\n+        buf.append(text.substring(start));\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * <p>\n+     * Replaces all occurrences of Strings within another String.\n+     * </p>\n+     * \n+     * <p>\n+     * A <code>null</code> reference passed to this method is a no-op, or if\n+     * any \"search string\" or \"string to replace\" is null, that replace will be\n+     * ignored. This will not repeat. For repeating replaces, call the\n+     * overloaded method.\n+     * </p>\n+     * \n+     * <pre>\n+     *  StringUtils.replaceEach(null, *, *)        = null\n+     *  StringUtils.replaceEach(\"\", *, *)          = \"\"\n+     *  StringUtils.replaceEach(\"aba\", null, null) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[0], null) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", null, new String[0]) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null)  = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"})  = \"b\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"})  = \"aba\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"})  = \"wcte\"\n+     *  (example of how it does not repeat)\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"})  = \"dcte\"\n+     * </pre>\n+     * \n+     * @param text\n+     *            text to search and replace in, no-op if null\n+     * @param searchList\n+     *            the Strings to search for, no-op if null\n+     * @param replacementList\n+     *            the Strings to replace them with, no-op if null\n+     * @return the text with any replacements processed, <code>null</code> if\n+     *         null String input\n+     * @throws IndexOutOfBoundsException\n+     *             if the lengths of the arrays are not the same (null is ok,\n+     *             and/or size 0)\n+     * @since 2.4\n+     */\n+    public static String replaceEach(String text, String[] searchList, String[] replacementList) {\n+        return replaceEach(text, searchList, replacementList, false, 0);\n+    }\n+\n+    /**\n+     * <p>\n+     * Replaces all occurrences of Strings within another String.\n+     * </p>\n+     * \n+     * <p>\n+     * A <code>null</code> reference passed to this method is a no-op, or if\n+     * any \"search string\" or \"string to replace\" is null, that replace will be\n+     * ignored. This will not repeat. For repeating replaces, call the\n+     * overloaded method.\n+     * </p>\n+     * \n+     * <pre>\n+     *  StringUtils.replaceEach(null, *, *, *) = null\n+     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n+     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n+     *  (example of how it repeats)\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, true) = IllegalArgumentException\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, false) = \"dcabe\"\n+     * </pre>\n+     * \n+     * @param text\n+     *            text to search and replace in, no-op if null\n+     * @param searchList\n+     *            the Strings to search for, no-op if null\n+     * @param replacementList\n+     *            the Strings to replace them with, no-op if null\n+     * @return the text with any replacements processed, <code>null</code> if\n+     *         null String input\n+     * @throws IllegalArgumentException\n+     *             if the search is repeating and there is an endless loop due\n+     *             to outputs of one being inputs to another\n+     * @throws IndexOutOfBoundsException\n+     *             if the lengths of the arrays are not the same (null is ok,\n+     *             and/or size 0)\n+     * @since 2.4\n+     */\n+    public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {\n+        // timeToLive should be 0 if not used or nothing to replace, else it's\n+        // the length of the replace array\n+        int timeToLive = searchList == null ? 0 : searchList.length;\n+        return replaceEach(text, searchList, replacementList, true, timeToLive);\n+    }\n+\n+    /**\n+     * <p>\n+     * Replaces all occurrences of Strings within another String.\n+     * </p>\n+     * \n+     * <p>\n+     * A <code>null</code> reference passed to this method is a no-op, or if\n+     * any \"search string\" or \"string to replace\" is null, that replace will be\n+     * ignored. \n+     * </p>\n+     * \n+     * <pre>\n+     *  StringUtils.replaceEach(null, *, *, *) = null\n+     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n+     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n+     *  (example of how it repeats)\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n+     * </pre>\n+     * \n+     * @param text\n+     *            text to search and replace in, no-op if null\n+     * @param searchList\n+     *            the Strings to search for, no-op if null\n+     * @param replacementList\n+     *            the Strings to replace them with, no-op if null\n+     * @param repeat if true, then replace repeatedly \n+     *       until there are no more possible replacements or timeToLive < 0\n+     * @param timeToLive\n+     *            if less than 0 then there is a circular reference and endless\n+     *            loop\n+     * @return the text with any replacements processed, <code>null</code> if\n+     *         null String input\n+     * @throws IllegalArgumentException\n+     *             if the search is repeating and there is an endless loop due\n+     *             to outputs of one being inputs to another\n+     * @throws IndexOutOfBoundsException\n+     *             if the lengths of the arrays are not the same (null is ok,\n+     *             and/or size 0)\n+     * @since 2.4\n+     */\n+    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n+                                      boolean repeat, int timeToLive) \n+    {\n+\n+        // mchyzer Performance note: This creates very few new objects (one major goal)\n+        // let me know if there are performance requests, we can create a harness to measure\n+\n+        if (text == null || text.length() == 0 || searchList == null || \n+            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n+        {\n+            return text;\n+        }\n+\n+        // if recursing, this shouldnt be less than 0\n+        if (timeToLive < 0) {\n+            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n+        }\n+\n+        int searchLength = searchList.length;\n+        int replacementLength = replacementList.length;\n+\n+        // make sure lengths are ok, these need to be equal\n+        if (searchLength != replacementLength) {\n+            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n+                + searchLength\n+                + \" vs \"\n+                + replacementLength);\n+        }\n+\n+        // keep track of which still have matches\n+        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n+\n+        // index on index that the match was found\n+        int textIndex = -1;\n+        int replaceIndex = -1;\n+        int tempIndex = -1;\n+\n+        // index of replace array that will replace the search string found\n+        // NOTE: logic duplicated below START\n+        for (int i = 0; i < searchLength; i++) {\n+            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n+                searchList[i].length() == 0 || replacementList[i] == null) \n+            {\n+                continue;\n+            }\n+            tempIndex = text.indexOf(searchList[i]);\n+\n+            // see if we need to keep searching for this\n+            if (tempIndex == -1) {\n+                noMoreMatchesForReplIndex[i] = true;\n+            } else {\n+                if (textIndex == -1 || tempIndex < textIndex) {\n+                    textIndex = tempIndex;\n+                    replaceIndex = i;\n+                }\n+            }\n+        }\n+        // NOTE: logic mostly below END\n+\n+        // no search strings found, we are done\n+        if (textIndex == -1) {\n+            return text;\n+        }\n+\n+        int start = 0;\n+\n+        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n+        int increase = 0;\n+\n+        // count the replacement text elements that are larger than their corresponding text being replaced\n+        for (int i = 0; i < searchList.length; i++) {\n+            int greater = replacementList[i].length() - searchList[i].length();\n+            if (greater > 0) {\n+                increase += 3 * greater; // assume 3 matches\n+            }\n+        }\n+        // have upper-bound at 20% increase, then let Java take over\n+        increase = Math.min(increase, text.length() / 5);\n+\n+        StringBuilder buf = new StringBuilder(text.length() + increase);\n+\n+        while (textIndex != -1) {\n+\n+            for (int i = start; i < textIndex; i++) {\n+                buf.append(text.charAt(i));\n+            }\n+            buf.append(replacementList[replaceIndex]);\n+\n+            start = textIndex + searchList[replaceIndex].length();\n+\n+            textIndex = -1;\n+            replaceIndex = -1;\n+            tempIndex = -1;\n+            // find the next earliest match\n+            // NOTE: logic mostly duplicated above START\n+            for (int i = 0; i < searchLength; i++) {\n+                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n+                    searchList[i].length() == 0 || replacementList[i] == null) \n+                {\n+                    continue;\n+                }\n+                tempIndex = text.indexOf(searchList[i], start);\n+\n+                // see if we need to keep searching for this\n+                if (tempIndex == -1) {\n+                    noMoreMatchesForReplIndex[i] = true;\n+                } else {\n+                    if (textIndex == -1 || tempIndex < textIndex) {\n+                        textIndex = tempIndex;\n+                        replaceIndex = i;\n+                    }\n+                }\n+            }\n+            // NOTE: logic duplicated above END\n+\n+        }\n+        int textLength = text.length();\n+        for (int i = start; i < textLength; i++) {\n+            buf.append(text.charAt(i));\n+        }\n+        String result = buf.toString();\n+        if (!repeat) {\n+            return result;\n+        }\n+\n+        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n+    }\n+\n+    // Replace, character based\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Replaces all occurrences of a character in a String with another.\n+     * This is a null-safe version of {@link String#replace(char, char)}.</p>\n+     *\n+     * <p>A <code>null</code> string input returns <code>null</code>.\n+     * An empty (\"\") string input returns an empty string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.replaceChars(null, *, *)        = null\n+     * StringUtils.replaceChars(\"\", *, *)          = \"\"\n+     * StringUtils.replaceChars(\"abcba\", 'b', 'y') = \"aycya\"\n+     * StringUtils.replaceChars(\"abcba\", 'z', 'y') = \"abcba\"\n+     * </pre>\n+     *\n+     * @param str  String to replace characters in, may be null\n+     * @param searchChar  the character to search for, may be null\n+     * @param replaceChar  the character to replace, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     * @since 2.0\n+     */\n+    public static String replaceChars(String str, char searchChar, char replaceChar) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return str.replace(searchChar, replaceChar);\n+    }\n+\n+    /**\n+     * <p>Replaces multiple characters in a String in one go.\n+     * This method can also be used to delete characters.</p>\n+     *\n+     * <p>For example:<br />\n+     * <code>replaceChars(&quot;hello&quot;, &quot;ho&quot;, &quot;jy&quot;) = jelly</code>.</p>\n+     *\n+     * <p>A <code>null</code> string input returns <code>null</code>.\n+     * An empty (\"\") string input returns an empty string.\n+     * A null or empty set of search characters returns the input string.</p>\n+     *\n+     * <p>The length of the search characters should normally equal the length\n+     * of the replace characters.\n+     * If the search characters is longer, then the extra search characters\n+     * are deleted.\n+     * If the search characters is shorter, then the extra replace characters\n+     * are ignored.</p>\n+     *\n+     * <pre>\n+     * StringUtils.replaceChars(null, *, *)           = null\n+     * StringUtils.replaceChars(\"\", *, *)             = \"\"\n+     * StringUtils.replaceChars(\"abc\", null, *)       = \"abc\"\n+     * StringUtils.replaceChars(\"abc\", \"\", *)         = \"abc\"\n+     * StringUtils.replaceChars(\"abc\", \"b\", null)     = \"ac\"\n+     * StringUtils.replaceChars(\"abc\", \"b\", \"\")       = \"ac\"\n+     * StringUtils.replaceChars(\"abcba\", \"bc\", \"yz\")  = \"ayzya\"\n+     * StringUtils.replaceChars(\"abcba\", \"bc\", \"y\")   = \"ayya\"\n+     * StringUtils.replaceChars(\"abcba\", \"bc\", \"yzx\") = \"ayzya\"\n+     * </pre>\n+     *\n+     * @param str  String to replace characters in, may be null\n+     * @param searchChars  a set of characters to search for, may be null\n+     * @param replaceChars  a set of characters to replace, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     * @since 2.0\n+     */\n+    public static String replaceChars(String str, String searchChars, String replaceChars) {\n+        if (isEmpty(str) || isEmpty(searchChars)) {\n+            return str;\n+        }\n+        if (replaceChars == null) {\n+            replaceChars = EMPTY;\n+        }\n+        boolean modified = false;\n+        int replaceCharsLength = replaceChars.length();\n+        int strLength = str.length();\n+        StringBuilder buf = new StringBuilder(strLength);\n+        for (int i = 0; i < strLength; i++) {\n+            char ch = str.charAt(i);\n+            int index = searchChars.indexOf(ch);\n+            if (index >= 0) {\n+                modified = true;\n+                if (index < replaceCharsLength) {\n+                    buf.append(replaceChars.charAt(index));\n+                }\n+            } else {\n+                buf.append(ch);\n+            }\n+        }\n+        if (modified) {\n+            return buf.toString();\n+        }\n+        return str;\n+    }\n+\n+    // Overlay\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Overlays part of a String with another String.</p>\n+     *\n+     * <p>A <code>null</code> string input returns <code>null</code>.\n+     * A negative index is treated as zero.\n+     * An index greater than the string length is treated as the string length.\n+     * The start index is always the smaller of the two indices.</p>\n+     *\n+     * <pre>\n+     * StringUtils.overlay(null, *, *, *)            = null\n+     * StringUtils.overlay(\"\", \"abc\", 0, 0)          = \"abc\"\n+     * StringUtils.overlay(\"abcdef\", null, 2, 4)     = \"abef\"\n+     * StringUtils.overlay(\"abcdef\", \"\", 2, 4)       = \"abef\"\n+     * StringUtils.overlay(\"abcdef\", \"\", 4, 2)       = \"abef\"\n+     * StringUtils.overlay(\"abcdef\", \"zzzz\", 2, 4)   = \"abzzzzef\"\n+     * StringUtils.overlay(\"abcdef\", \"zzzz\", 4, 2)   = \"abzzzzef\"\n+     * StringUtils.overlay(\"abcdef\", \"zzzz\", -1, 4)  = \"zzzzef\"\n+     * StringUtils.overlay(\"abcdef\", \"zzzz\", 2, 8)   = \"abzzzz\"\n+     * StringUtils.overlay(\"abcdef\", \"zzzz\", -2, -3) = \"zzzzabcdef\"\n+     * StringUtils.overlay(\"abcdef\", \"zzzz\", 8, 10)  = \"abcdefzzzz\"\n+     * </pre>\n+     *\n+     * @param str  the String to do overlaying in, may be null\n+     * @param overlay  the String to overlay, may be null\n+     * @param start  the position to start overlaying at\n+     * @param end  the position to stop overlaying before\n+     * @return overlayed String, <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String overlay(String str, String overlay, int start, int end) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (overlay == null) {\n+            overlay = EMPTY;\n+        }\n+        int len = str.length();\n+        if (start < 0) {\n+            start = 0;\n+        }\n+        if (start > len) {\n+            start = len;\n+        }\n+        if (end < 0) {\n+            end = 0;\n+        }\n+        if (end > len) {\n+            end = len;\n+        }\n+        if (start > end) {\n+            int temp = start;\n+            start = end;\n+            end = temp;\n+        }\n+        return new StringBuilder(len + start - end + overlay.length() + 1)\n+            .append(str.substring(0, start))\n+            .append(overlay)\n+            .append(str.substring(end))\n+            .toString();\n+    }\n+\n+    // Chomping\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Removes one newline from end of a String if it's there,\n+     * otherwise leave it alone.  A newline is &quot;<code>\\n</code>&quot;,\n+     * &quot;<code>\\r</code>&quot;, or &quot;<code>\\r\\n</code>&quot;.</p>\n+     *\n+     * <p>NOTE: This method changed in 2.0.\n+     * It now more closely matches Perl chomp.</p>\n+     *\n+     * <pre>\n+     * StringUtils.chomp(null)          = null\n+     * StringUtils.chomp(\"\")            = \"\"\n+     * StringUtils.chomp(\"abc \\r\")      = \"abc \"\n+     * StringUtils.chomp(\"abc\\n\")       = \"abc\"\n+     * StringUtils.chomp(\"abc\\r\\n\")     = \"abc\"\n+     * StringUtils.chomp(\"abc\\r\\n\\r\\n\") = \"abc\\r\\n\"\n+     * StringUtils.chomp(\"abc\\n\\r\")     = \"abc\\n\"\n+     * StringUtils.chomp(\"abc\\n\\rabc\")  = \"abc\\n\\rabc\"\n+     * StringUtils.chomp(\"\\r\")          = \"\"\n+     * StringUtils.chomp(\"\\n\")          = \"\"\n+     * StringUtils.chomp(\"\\r\\n\")        = \"\"\n+     * </pre>\n+     *\n+     * @param str  the String to chomp a newline from, may be null\n+     * @return String without newline, <code>null</code> if null String input\n+     */\n+    public static String chomp(String str) {\n+        if (isEmpty(str)) {\n+            return str;\n+        }\n+\n+        if (str.length() == 1) {\n+            char ch = str.charAt(0);\n+            if (ch == CharUtils.CR || ch == CharUtils.LF) {\n+                return EMPTY;\n+            }\n+            return str;\n+        }\n+\n+        int lastIdx = str.length() - 1;\n+        char last = str.charAt(lastIdx);\n+\n+        if (last == CharUtils.LF) {\n+            if (str.charAt(lastIdx - 1) == CharUtils.CR) {\n+                lastIdx--;\n+            }\n+        } else if (last != CharUtils.CR) {\n+            lastIdx++;\n+        }\n+        return str.substring(0, lastIdx);\n+    }\n+\n+    /**\n+     * <p>Removes <code>separator</code> from the end of\n+     * <code>str</code> if it's there, otherwise leave it alone.</p>\n+     *\n+     * <p>NOTE: This method changed in version 2.0.\n+     * It now more closely matches Perl chomp.\n+     * For the previous behavior, use {@link #substringBeforeLast(String, String)}.\n+     * This method uses {@link String#endsWith(String)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.chomp(null, *)         = null\n+     * StringUtils.chomp(\"\", *)           = \"\"\n+     * StringUtils.chomp(\"foobar\", \"bar\") = \"foo\"\n+     * StringUtils.chomp(\"foobar\", \"baz\") = \"foobar\"\n+     * StringUtils.chomp(\"foo\", \"foo\")    = \"\"\n+     * StringUtils.chomp(\"foo \", \"foo\")   = \"foo \"\n+     * StringUtils.chomp(\" foo\", \"foo\")   = \" \"\n+     * StringUtils.chomp(\"foo\", \"foooo\")  = \"foo\"\n+     * StringUtils.chomp(\"foo\", \"\")       = \"foo\"\n+     * StringUtils.chomp(\"foo\", null)     = \"foo\"\n+     * </pre>\n+     *\n+     * @param str  the String to chomp from, may be null\n+     * @param separator  separator String, may be null\n+     * @return String without trailing separator, <code>null</code> if null String input\n+     */\n+    public static String chomp(String str, String separator) {\n+        if (isEmpty(str) || separator == null) {\n+            return str;\n+        }\n+        if (str.endsWith(separator)) {\n+            return str.substring(0, str.length() - separator.length());\n+        }\n+        return str;\n+    }\n+\n+    // Chopping\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Remove the last character from a String.</p>\n+     *\n+     * <p>If the String ends in <code>\\r\\n</code>, then remove both\n+     * of them.</p>\n+     *\n+     * <pre>\n+     * StringUtils.chop(null)          = null\n+     * StringUtils.chop(\"\")            = \"\"\n+     * StringUtils.chop(\"abc \\r\")      = \"abc \"\n+     * StringUtils.chop(\"abc\\n\")       = \"abc\"\n+     * StringUtils.chop(\"abc\\r\\n\")     = \"abc\"\n+     * StringUtils.chop(\"abc\")         = \"ab\"\n+     * StringUtils.chop(\"abc\\nabc\")    = \"abc\\nab\"\n+     * StringUtils.chop(\"a\")           = \"\"\n+     * StringUtils.chop(\"\\r\")          = \"\"\n+     * StringUtils.chop(\"\\n\")          = \"\"\n+     * StringUtils.chop(\"\\r\\n\")        = \"\"\n+     * </pre>\n+     *\n+     * @param str  the String to chop last character from, may be null\n+     * @return String without last character, <code>null</code> if null String input\n+     */\n+    public static String chop(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        int strLen = str.length();\n+        if (strLen < 2) {\n+            return EMPTY;\n+        }\n+        int lastIdx = strLen - 1;\n+        String ret = str.substring(0, lastIdx);\n+        char last = str.charAt(lastIdx);\n+        if (last == CharUtils.LF) {\n+            if (ret.charAt(lastIdx - 1) == CharUtils.CR) {\n+                return ret.substring(0, lastIdx - 1);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+\n+    // Padding\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Repeat a String <code>repeat</code> times to form a\n+     * new String.</p>\n+     *\n+     * <pre>\n+     * StringUtils.repeat(null, 2) = null\n+     * StringUtils.repeat(\"\", 0)   = \"\"\n+     * StringUtils.repeat(\"\", 2)   = \"\"\n+     * StringUtils.repeat(\"a\", 3)  = \"aaa\"\n+     * StringUtils.repeat(\"ab\", 2) = \"abab\"\n+     * StringUtils.repeat(\"a\", -2) = \"\"\n+     * </pre>\n+     *\n+     * @param str  the String to repeat, may be null\n+     * @param repeat  number of times to repeat str, negative treated as zero\n+     * @return a new String consisting of the original String repeated,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String repeat(String str, int repeat) {\n+        // Performance tuned for 2.0 (JDK1.4)\n+\n+        if (str == null) {\n+            return null;\n+        }\n+        if (repeat <= 0) {\n+            return EMPTY;\n+        }\n+        int inputLength = str.length();\n+        if (repeat == 1 || inputLength == 0) {\n+            return str;\n+        }\n+        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n+            return padding(repeat, str.charAt(0));\n+        }\n+\n+        int outputLength = inputLength * repeat;\n+        switch (inputLength) {\n+            case 1 :\n+                char ch = str.charAt(0);\n+                char[] output1 = new char[outputLength];\n+                for (int i = repeat - 1; i >= 0; i--) {\n+                    output1[i] = ch;\n+                }\n+                return new String(output1);\n+            case 2 :\n+                char ch0 = str.charAt(0);\n+                char ch1 = str.charAt(1);\n+                char[] output2 = new char[outputLength];\n+                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n+                    output2[i] = ch0;\n+                    output2[i + 1] = ch1;\n+                }\n+                return new String(output2);\n+            default :\n+                StringBuilder buf = new StringBuilder(outputLength);\n+                for (int i = 0; i < repeat; i++) {\n+                    buf.append(str);\n+                }\n+                return buf.toString();\n+        }\n+    }\n+\n+    /**\n+     * <p>Repeat a String <code>repeat</code> times to form a\n+     * new String, with a String separator injected each time. </p>\n+     *\n+     * <pre>\n+     * StringUtils.repeat(null, null, 2) = null\n+     * StringUtils.repeat(null, \"x\", 2)  = null\n+     * StringUtils.repeat(\"\", null, 0)   = \"\"\n+     * StringUtils.repeat(\"\", \"\", 2)     = \"\"\n+     * StringUtils.repeat(\"\", \"x\", 3)    = \"xxx\"\n+     * StringUtils.repeat(\"?\", \", \", 3)  = \"?, ?, ?\"\n+     * </pre>\n+     *\n+     * @param str        the String to repeat, may be null\n+     * @param separator  the String to inject, may be null\n+     * @param repeat     number of times to repeat str, negative treated as zero\n+     * @return a new String consisting of the original String repeated,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String repeat(String str, String separator, int repeat) {\n+        if(str == null || separator == null) {\n+            return repeat(str, repeat);\n+        } else {\n+            // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it\n+            String result = repeat(str + separator, repeat);\n+            return removeEnd(result, separator);\n+        }\n+    }\n+\n+    /**\n+     * <p>Returns padding using the specified delimiter repeated\n+     * to a given length.</p>\n+     *\n+     * <pre>\n+     * StringUtils.padding(0, 'e')  = \"\"\n+     * StringUtils.padding(3, 'e')  = \"eee\"\n+     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n+     * </pre>\n+     *\n+     * <p>Note: this method doesn't not support padding with\n+     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n+     * as they require a pair of <code>char</code>s to be represented.\n+     * If you are needing to support full I18N of your applications\n+     * consider using {@link #repeat(String, int)} instead. \n+     * </p>\n+     *\n+     * @param repeat  number of times to repeat delim\n+     * @param padChar  character to repeat\n+     * @return String with repeated character\n+     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n+     * @see #repeat(String, int)\n+     */\n+    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n+        if (repeat < 0) {\n+            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n+        }\n+        final char[] buf = new char[repeat];\n+        for (int i = 0; i < buf.length; i++) {\n+            buf[i] = padChar;\n+        }\n+        return new String(buf);\n+    }\n+\n+    /**\n+     * <p>Right pad a String with spaces (' ').</p>\n+     *\n+     * <p>The String is padded to the size of <code>size</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.rightPad(null, *)   = null\n+     * StringUtils.rightPad(\"\", 3)     = \"   \"\n+     * StringUtils.rightPad(\"bat\", 3)  = \"bat\"\n+     * StringUtils.rightPad(\"bat\", 5)  = \"bat  \"\n+     * StringUtils.rightPad(\"bat\", 1)  = \"bat\"\n+     * StringUtils.rightPad(\"bat\", -1) = \"bat\"\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n+     * @param size  the size to pad to\n+     * @return right padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String rightPad(String str, int size) {\n+        return rightPad(str, size, ' ');\n+    }\n+\n+    /**\n+     * <p>Right pad a String with a specified character.</p>\n+     *\n+     * <p>The String is padded to the size of <code>size</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.rightPad(null, *, *)     = null\n+     * StringUtils.rightPad(\"\", 3, 'z')     = \"zzz\"\n+     * StringUtils.rightPad(\"bat\", 3, 'z')  = \"bat\"\n+     * StringUtils.rightPad(\"bat\", 5, 'z')  = \"batzz\"\n+     * StringUtils.rightPad(\"bat\", 1, 'z')  = \"bat\"\n+     * StringUtils.rightPad(\"bat\", -1, 'z') = \"bat\"\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n+     * @param size  the size to pad to\n+     * @param padChar  the character to pad with\n+     * @return right padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String rightPad(String str, int size, char padChar) {\n+        if (str == null) {\n+            return null;\n+        }\n+        int pads = size - str.length();\n+        if (pads <= 0) {\n+            return str; // returns original String when possible\n+        }\n+        if (pads > PAD_LIMIT) {\n+            return rightPad(str, size, String.valueOf(padChar));\n+        }\n+        return str.concat(padding(pads, padChar));\n+    }\n+\n+    /**\n+     * <p>Right pad a String with a specified String.</p>\n+     *\n+     * <p>The String is padded to the size of <code>size</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.rightPad(null, *, *)      = null\n+     * StringUtils.rightPad(\"\", 3, \"z\")      = \"zzz\"\n+     * StringUtils.rightPad(\"bat\", 3, \"yz\")  = \"bat\"\n+     * StringUtils.rightPad(\"bat\", 5, \"yz\")  = \"batyz\"\n+     * StringUtils.rightPad(\"bat\", 8, \"yz\")  = \"batyzyzy\"\n+     * StringUtils.rightPad(\"bat\", 1, \"yz\")  = \"bat\"\n+     * StringUtils.rightPad(\"bat\", -1, \"yz\") = \"bat\"\n+     * StringUtils.rightPad(\"bat\", 5, null)  = \"bat  \"\n+     * StringUtils.rightPad(\"bat\", 5, \"\")    = \"bat  \"\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n+     * @param size  the size to pad to\n+     * @param padStr  the String to pad with, null or empty treated as single space\n+     * @return right padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String rightPad(String str, int size, String padStr) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (isEmpty(padStr)) {\n+            padStr = \" \";\n+        }\n+        int padLen = padStr.length();\n+        int strLen = str.length();\n+        int pads = size - strLen;\n+        if (pads <= 0) {\n+            return str; // returns original String when possible\n+        }\n+        if (padLen == 1 && pads <= PAD_LIMIT) {\n+            return rightPad(str, size, padStr.charAt(0));\n+        }\n+\n+        if (pads == padLen) {\n+            return str.concat(padStr);\n+        } else if (pads < padLen) {\n+            return str.concat(padStr.substring(0, pads));\n+        } else {\n+            char[] padding = new char[pads];\n+            char[] padChars = padStr.toCharArray();\n+            for (int i = 0; i < pads; i++) {\n+                padding[i] = padChars[i % padLen];\n+            }\n+            return str.concat(new String(padding));\n+        }\n+    }\n+\n+    /**\n+     * <p>Left pad a String with spaces (' ').</p>\n+     *\n+     * <p>The String is padded to the size of <code>size</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.leftPad(null, *)   = null\n+     * StringUtils.leftPad(\"\", 3)     = \"   \"\n+     * StringUtils.leftPad(\"bat\", 3)  = \"bat\"\n+     * StringUtils.leftPad(\"bat\", 5)  = \"  bat\"\n+     * StringUtils.leftPad(\"bat\", 1)  = \"bat\"\n+     * StringUtils.leftPad(\"bat\", -1) = \"bat\"\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n+     * @param size  the size to pad to\n+     * @return left padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String leftPad(String str, int size) {\n+        return leftPad(str, size, ' ');\n+    }\n+\n+    /**\n+     * <p>Left pad a String with a specified character.</p>\n+     *\n+     * <p>Pad to a size of <code>size</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.leftPad(null, *, *)     = null\n+     * StringUtils.leftPad(\"\", 3, 'z')     = \"zzz\"\n+     * StringUtils.leftPad(\"bat\", 3, 'z')  = \"bat\"\n+     * StringUtils.leftPad(\"bat\", 5, 'z')  = \"zzbat\"\n+     * StringUtils.leftPad(\"bat\", 1, 'z')  = \"bat\"\n+     * StringUtils.leftPad(\"bat\", -1, 'z') = \"bat\"\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n+     * @param size  the size to pad to\n+     * @param padChar  the character to pad with\n+     * @return left padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String leftPad(String str, int size, char padChar) {\n+        if (str == null) {\n+            return null;\n+        }\n+        int pads = size - str.length();\n+        if (pads <= 0) {\n+            return str; // returns original String when possible\n+        }\n+        if (pads > PAD_LIMIT) {\n+            return leftPad(str, size, String.valueOf(padChar));\n+        }\n+        return padding(pads, padChar).concat(str);\n+    }\n+\n+    /**\n+     * <p>Left pad a String with a specified String.</p>\n+     *\n+     * <p>Pad to a size of <code>size</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.leftPad(null, *, *)      = null\n+     * StringUtils.leftPad(\"\", 3, \"z\")      = \"zzz\"\n+     * StringUtils.leftPad(\"bat\", 3, \"yz\")  = \"bat\"\n+     * StringUtils.leftPad(\"bat\", 5, \"yz\")  = \"yzbat\"\n+     * StringUtils.leftPad(\"bat\", 8, \"yz\")  = \"yzyzybat\"\n+     * StringUtils.leftPad(\"bat\", 1, \"yz\")  = \"bat\"\n+     * StringUtils.leftPad(\"bat\", -1, \"yz\") = \"bat\"\n+     * StringUtils.leftPad(\"bat\", 5, null)  = \"  bat\"\n+     * StringUtils.leftPad(\"bat\", 5, \"\")    = \"  bat\"\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n+     * @param size  the size to pad to\n+     * @param padStr  the String to pad with, null or empty treated as single space\n+     * @return left padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String leftPad(String str, int size, String padStr) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (isEmpty(padStr)) {\n+            padStr = \" \";\n+        }\n+        int padLen = padStr.length();\n+        int strLen = str.length();\n+        int pads = size - strLen;\n+        if (pads <= 0) {\n+            return str; // returns original String when possible\n+        }\n+        if (padLen == 1 && pads <= PAD_LIMIT) {\n+            return leftPad(str, size, padStr.charAt(0));\n+        }\n+\n+        if (pads == padLen) {\n+            return padStr.concat(str);\n+        } else if (pads < padLen) {\n+            return padStr.substring(0, pads).concat(str);\n+        } else {\n+            char[] padding = new char[pads];\n+            char[] padChars = padStr.toCharArray();\n+            for (int i = 0; i < pads; i++) {\n+                padding[i] = padChars[i % padLen];\n+            }\n+            return new String(padding).concat(str);\n+        }\n+    }\n+\n+    /**\n+     * Gets a String's length or <code>0</code> if the String is <code>null</code>.\n+     * \n+     * @param str\n+     *            a String or <code>null</code>\n+     * @return String length or <code>0</code> if the String is <code>null</code>.\n+     * @since 2.4\n+     */\n+    public static int length(String str) {\n+        return str == null ? 0 : str.length();\n+    }\n+    \n+    // Centering\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Centers a String in a larger String of size <code>size</code>\n+     * using the space character (' ').<p>\n+     *\n+     * <p>If the size is less than the String length, the String is returned.\n+     * A <code>null</code> String returns <code>null</code>.\n+     * A negative size is treated as zero.</p>\n+     *\n+     * <p>Equivalent to <code>center(str, size, \" \")</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.center(null, *)   = null\n+     * StringUtils.center(\"\", 4)     = \"    \"\n+     * StringUtils.center(\"ab\", -1)  = \"ab\"\n+     * StringUtils.center(\"ab\", 4)   = \" ab \"\n+     * StringUtils.center(\"abcd\", 2) = \"abcd\"\n+     * StringUtils.center(\"a\", 4)    = \" a  \"\n+     * </pre>\n+     *\n+     * @param str  the String to center, may be null\n+     * @param size  the int size of new String, negative treated as zero\n+     * @return centered String, <code>null</code> if null String input\n+     */\n+    public static String center(String str, int size) {\n+        return center(str, size, ' ');\n+    }\n+\n+    /**\n+     * <p>Centers a String in a larger String of size <code>size</code>.\n+     * Uses a supplied character as the value to pad the String with.</p>\n+     *\n+     * <p>If the size is less than the String length, the String is returned.\n+     * A <code>null</code> String returns <code>null</code>.\n+     * A negative size is treated as zero.</p>\n+     *\n+     * <pre>\n+     * StringUtils.center(null, *, *)     = null\n+     * StringUtils.center(\"\", 4, ' ')     = \"    \"\n+     * StringUtils.center(\"ab\", -1, ' ')  = \"ab\"\n+     * StringUtils.center(\"ab\", 4, ' ')   = \" ab\"\n+     * StringUtils.center(\"abcd\", 2, ' ') = \"abcd\"\n+     * StringUtils.center(\"a\", 4, ' ')    = \" a  \"\n+     * StringUtils.center(\"a\", 4, 'y')    = \"yayy\"\n+     * </pre>\n+     *\n+     * @param str  the String to center, may be null\n+     * @param size  the int size of new String, negative treated as zero\n+     * @param padChar  the character to pad the new String with\n+     * @return centered String, <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String center(String str, int size, char padChar) {\n+        if (str == null || size <= 0) {\n+            return str;\n+        }\n+        int strLen = str.length();\n+        int pads = size - strLen;\n+        if (pads <= 0) {\n+            return str;\n+        }\n+        str = leftPad(str, strLen + pads / 2, padChar);\n+        str = rightPad(str, size, padChar);\n+        return str;\n+    }\n+\n+    /**\n+     * <p>Centers a String in a larger String of size <code>size</code>.\n+     * Uses a supplied String as the value to pad the String with.</p>\n+     *\n+     * <p>If the size is less than the String length, the String is returned.\n+     * A <code>null</code> String returns <code>null</code>.\n+     * A negative size is treated as zero.</p>\n+     *\n+     * <pre>\n+     * StringUtils.center(null, *, *)     = null\n+     * StringUtils.center(\"\", 4, \" \")     = \"    \"\n+     * StringUtils.center(\"ab\", -1, \" \")  = \"ab\"\n+     * StringUtils.center(\"ab\", 4, \" \")   = \" ab\"\n+     * StringUtils.center(\"abcd\", 2, \" \") = \"abcd\"\n+     * StringUtils.center(\"a\", 4, \" \")    = \" a  \"\n+     * StringUtils.center(\"a\", 4, \"yz\")   = \"yayz\"\n+     * StringUtils.center(\"abc\", 7, null) = \"  abc  \"\n+     * StringUtils.center(\"abc\", 7, \"\")   = \"  abc  \"\n+     * </pre>\n+     *\n+     * @param str  the String to center, may be null\n+     * @param size  the int size of new String, negative treated as zero\n+     * @param padStr  the String to pad the new String with, must not be null or empty\n+     * @return centered String, <code>null</code> if null String input\n+     * @throws IllegalArgumentException if padStr is <code>null</code> or empty\n+     */\n+    public static String center(String str, int size, String padStr) {\n+        if (str == null || size <= 0) {\n+            return str;\n+        }\n+        if (isEmpty(padStr)) {\n+            padStr = \" \";\n+        }\n+        int strLen = str.length();\n+        int pads = size - strLen;\n+        if (pads <= 0) {\n+            return str;\n+        }\n+        str = leftPad(str, strLen + pads / 2, padStr);\n+        str = rightPad(str, size, padStr);\n+        return str;\n+    }\n+\n+    // Case conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a String to upper case as per {@link String#toUpperCase()}.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.upperCase(null)  = null\n+     * StringUtils.upperCase(\"\")    = \"\"\n+     * StringUtils.upperCase(\"aBc\") = \"ABC\"\n+     * </pre>\n+     *\n+     * <p><strong>Note:</strong> As described in the documentation for {@link String#toUpperCase()},\n+     * the result of this method is affected by the current locale.\n+     * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}\n+     * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).</p>\n+     *\n+     * @param str  the String to upper case, may be null\n+     * @return the upper cased String, <code>null</code> if null String input\n+     */\n+    public static String upperCase(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return str.toUpperCase();\n+    }\n+\n+    /**\n+     * <p>Converts a String to upper case as per {@link String#toUpperCase(Locale)}.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.upperCase(null, Locale.ENGLISH)  = null\n+     * StringUtils.upperCase(\"\", Locale.ENGLISH)    = \"\"\n+     * StringUtils.upperCase(\"aBc\", Locale.ENGLISH) = \"ABC\"\n+     * </pre>\n+     *\n+     * @param str  the String to upper case, may be null\n+     * @param locale  the locale that defines the case transformation rules, must not be null\n+     * @return the upper cased String, <code>null</code> if null String input\n+     * @since 3.0\n+     */\n+    public static String upperCase(String str, Locale locale) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return str.toUpperCase(locale);\n+    }\n+\n+    /**\n+     * <p>Converts a String to lower case as per {@link String#toLowerCase()}.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.lowerCase(null)  = null\n+     * StringUtils.lowerCase(\"\")    = \"\"\n+     * StringUtils.lowerCase(\"aBc\") = \"abc\"\n+     * </pre>\n+     *\n+     * <p><strong>Note:</strong> As described in the documentation for {@link String#toLowerCase()},\n+     * the result of this method is affected by the current locale.\n+     * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}\n+     * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).</p>\n+     *\n+     * @param str  the String to lower case, may be null\n+     * @return the lower cased String, <code>null</code> if null String input\n+     */\n+    public static String lowerCase(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return str.toLowerCase();\n+    }\n+\n+    /**\n+     * <p>Converts a String to lower case as per {@link String#toLowerCase(Locale)}.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.lowerCase(null, Locale.ENGLISH)  = null\n+     * StringUtils.lowerCase(\"\", Locale.ENGLISH)    = \"\"\n+     * StringUtils.lowerCase(\"aBc\", Locale.ENGLISH) = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to lower case, may be null\n+     * @param locale  the locale that defines the case transformation rules, must not be null\n+     * @return the lower cased String, <code>null</code> if null String input\n+     * @since 3.0\n+     */\n+    public static String lowerCase(String str, Locale locale) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return str.toLowerCase(locale);\n+    }\n+\n+    /**\n+     * <p>Capitalizes a String changing the first letter to title case as\n+     * per {@link Character#toTitleCase(char)}. No other letters are changed.</p>\n+     *\n+     * <p>For a word based algorithm, see {@link WordUtils#capitalize(String)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.capitalize(null)  = null\n+     * StringUtils.capitalize(\"\")    = \"\"\n+     * StringUtils.capitalize(\"cat\") = \"Cat\"\n+     * StringUtils.capitalize(\"cAt\") = \"CAt\"\n+     * </pre>\n+     *\n+     * @param str  the String to capitalize, may be null\n+     * @return the capitalized String, <code>null</code> if null String input\n+     * @see WordUtils#capitalize(String)\n+     * @see #uncapitalize(String)\n+     * @since 2.0\n+     */\n+    public static String capitalize(String str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return str;\n+        }\n+        return new StringBuilder(strLen)\n+            .append(Character.toTitleCase(str.charAt(0)))\n+            .append(str.substring(1))\n+            .toString();\n+    }\n+\n+    /**\n+     * <p>Uncapitalizes a String changing the first letter to title case as\n+     * per {@link Character#toLowerCase(char)}. No other letters are changed.</p>\n+     *\n+     * <p>For a word based algorithm, see {@link WordUtils#uncapitalize(String)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.uncapitalize(null)  = null\n+     * StringUtils.uncapitalize(\"\")    = \"\"\n+     * StringUtils.uncapitalize(\"Cat\") = \"cat\"\n+     * StringUtils.uncapitalize(\"CAT\") = \"cAT\"\n+     * </pre>\n+     *\n+     * @param str  the String to uncapitalize, may be null\n+     * @return the uncapitalized String, <code>null</code> if null String input\n+     * @see WordUtils#uncapitalize(String)\n+     * @see #capitalize(String)\n+     * @since 2.0\n+     */\n+    public static String uncapitalize(String str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return str;\n+        }\n+        return new StringBuilder(strLen)\n+            .append(Character.toLowerCase(str.charAt(0)))\n+            .append(str.substring(1))\n+            .toString();\n+    }\n+\n+    /**\n+     * <p>Swaps the case of a String changing upper and title case to\n+     * lower case, and lower case to upper case.</p>\n+     *\n+     * <ul>\n+     *  <li>Upper case character converts to Lower case</li>\n+     *  <li>Title case character converts to Lower case</li>\n+     *  <li>Lower case character converts to Upper case</li>\n+     * </ul>\n+     *\n+     * <p>For a word based algorithm, see {@link WordUtils#swapCase(String)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.swapCase(null)                 = null\n+     * StringUtils.swapCase(\"\")                   = \"\"\n+     * StringUtils.swapCase(\"The dog has a BONE\") = \"tHE DOG HAS A bone\"\n+     * </pre>\n+     *\n+     * <p>NOTE: This method changed in Lang version 2.0.\n+     * It no longer performs a word based algorithm.\n+     * If you only use ASCII, you will notice no change.\n+     * That functionality is available in WordUtils.</p>\n+     *\n+     * @param str  the String to swap case, may be null\n+     * @return the changed String, <code>null</code> if null String input\n+     */\n+    public static String swapCase(String str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return str;\n+        }\n+        StringBuilder buffer = new StringBuilder(strLen);\n+\n+        char ch = 0;\n+        for (int i = 0; i < strLen; i++) {\n+            ch = str.charAt(i);\n+            if (Character.isUpperCase(ch)) {\n+                ch = Character.toLowerCase(ch);\n+            } else if (Character.isTitleCase(ch)) {\n+                ch = Character.toLowerCase(ch);\n+            } else if (Character.isLowerCase(ch)) {\n+                ch = Character.toUpperCase(ch);\n+            }\n+            buffer.append(ch);\n+        }\n+        return buffer.toString();\n+    }\n+\n+    // Count matches\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Counts how many times the substring appears in the larger String.</p>\n+     *\n+     * <p>A <code>null</code> or empty (\"\") String input returns <code>0</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.countMatches(null, *)       = 0\n+     * StringUtils.countMatches(\"\", *)         = 0\n+     * StringUtils.countMatches(\"abba\", null)  = 0\n+     * StringUtils.countMatches(\"abba\", \"\")    = 0\n+     * StringUtils.countMatches(\"abba\", \"a\")   = 2\n+     * StringUtils.countMatches(\"abba\", \"ab\")  = 1\n+     * StringUtils.countMatches(\"abba\", \"xxx\") = 0\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param sub  the substring to count, may be null\n+     * @return the number of occurrences, 0 if either String is <code>null</code>\n+     */\n+    public static int countMatches(String str, String sub) {\n+        if (isEmpty(str) || isEmpty(sub)) {\n+            return 0;\n+        }\n+        int count = 0;\n+        int idx = 0;\n+        while ((idx = str.indexOf(sub, idx)) != -1) {\n+            count++;\n+            idx += sub.length();\n+        }\n+        return count;\n+    }\n+\n+    // Character Tests\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if the String contains only unicode letters.</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isAlpha(null)   = false\n+     * StringUtils.isAlpha(\"\")     = true\n+     * StringUtils.isAlpha(\"  \")   = false\n+     * StringUtils.isAlpha(\"abc\")  = true\n+     * StringUtils.isAlpha(\"ab2c\") = false\n+     * StringUtils.isAlpha(\"ab-c\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains letters, and is non-null\n+     */\n+    public static boolean isAlpha(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if (Character.isLetter(str.charAt(i)) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only unicode letters and\n+     * space (' ').</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isAlphaSpace(null)   = false\n+     * StringUtils.isAlphaSpace(\"\")     = true\n+     * StringUtils.isAlphaSpace(\"  \")   = true\n+     * StringUtils.isAlphaSpace(\"abc\")  = true\n+     * StringUtils.isAlphaSpace(\"ab c\") = true\n+     * StringUtils.isAlphaSpace(\"ab2c\") = false\n+     * StringUtils.isAlphaSpace(\"ab-c\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains letters and space,\n+     *  and is non-null\n+     */\n+    public static boolean isAlphaSpace(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if ((Character.isLetter(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only unicode letters or digits.</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isAlphanumeric(null)   = false\n+     * StringUtils.isAlphanumeric(\"\")     = true\n+     * StringUtils.isAlphanumeric(\"  \")   = false\n+     * StringUtils.isAlphanumeric(\"abc\")  = true\n+     * StringUtils.isAlphanumeric(\"ab c\") = false\n+     * StringUtils.isAlphanumeric(\"ab2c\") = true\n+     * StringUtils.isAlphanumeric(\"ab-c\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains letters or digits,\n+     *  and is non-null\n+     */\n+    public static boolean isAlphanumeric(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if (Character.isLetterOrDigit(str.charAt(i)) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only unicode letters, digits\n+     * or space (<code>' '</code>).</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isAlphanumeric(null)   = false\n+     * StringUtils.isAlphanumeric(\"\")     = true\n+     * StringUtils.isAlphanumeric(\"  \")   = true\n+     * StringUtils.isAlphanumeric(\"abc\")  = true\n+     * StringUtils.isAlphanumeric(\"ab c\") = true\n+     * StringUtils.isAlphanumeric(\"ab2c\") = true\n+     * StringUtils.isAlphanumeric(\"ab-c\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains letters, digits or space,\n+     *  and is non-null\n+     */\n+    public static boolean isAlphanumericSpace(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if ((Character.isLetterOrDigit(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the string contains only ASCII printable characters.</p>\n+     * \n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     * \n+     * <pre>\n+     * StringUtils.isAsciiPrintable(null)     = false\n+     * StringUtils.isAsciiPrintable(\"\")       = true\n+     * StringUtils.isAsciiPrintable(\" \")      = true\n+     * StringUtils.isAsciiPrintable(\"Ceki\")   = true\n+     * StringUtils.isAsciiPrintable(\"ab2c\")   = true\n+     * StringUtils.isAsciiPrintable(\"!ab-c~\") = true\n+     * StringUtils.isAsciiPrintable(\"\\u0020\") = true\n+     * StringUtils.isAsciiPrintable(\"\\u0021\") = true\n+     * StringUtils.isAsciiPrintable(\"\\u007e\") = true\n+     * StringUtils.isAsciiPrintable(\"\\u007f\") = false\n+     * StringUtils.isAsciiPrintable(\"Ceki G\\u00fclc\\u00fc\") = false\n+     * </pre>\n+     *\n+     * @param str the string to check, may be null\n+     * @return <code>true</code> if every character is in the range\n+     *  32 thru 126\n+     * @since 2.1\n+     */\n+    public static boolean isAsciiPrintable(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if (CharUtils.isAsciiPrintable(str.charAt(i)) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only unicode digits.\n+     * A decimal point is not a unicode digit and returns false.</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isNumeric(null)   = false\n+     * StringUtils.isNumeric(\"\")     = true\n+     * StringUtils.isNumeric(\"  \")   = false\n+     * StringUtils.isNumeric(\"123\")  = true\n+     * StringUtils.isNumeric(\"12 3\") = false\n+     * StringUtils.isNumeric(\"ab2c\") = false\n+     * StringUtils.isNumeric(\"12-3\") = false\n+     * StringUtils.isNumeric(\"12.3\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains digits, and is non-null\n+     */\n+    public static boolean isNumeric(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if (Character.isDigit(str.charAt(i)) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only unicode digits or space\n+     * (<code>' '</code>).\n+     * A decimal point is not a unicode digit and returns false.</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isNumeric(null)   = false\n+     * StringUtils.isNumeric(\"\")     = true\n+     * StringUtils.isNumeric(\"  \")   = true\n+     * StringUtils.isNumeric(\"123\")  = true\n+     * StringUtils.isNumeric(\"12 3\") = true\n+     * StringUtils.isNumeric(\"ab2c\") = false\n+     * StringUtils.isNumeric(\"12-3\") = false\n+     * StringUtils.isNumeric(\"12.3\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains digits or space,\n+     *  and is non-null\n+     */\n+    public static boolean isNumericSpace(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if ((Character.isDigit(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only whitespace.</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isWhitespace(null)   = false\n+     * StringUtils.isWhitespace(\"\")     = true\n+     * StringUtils.isWhitespace(\"  \")   = true\n+     * StringUtils.isWhitespace(\"abc\")  = false\n+     * StringUtils.isWhitespace(\"ab2c\") = false\n+     * StringUtils.isWhitespace(\"ab-c\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains whitespace, and is non-null\n+     * @since 2.0\n+     */\n+    public static boolean isWhitespace(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if ((Character.isWhitespace(str.charAt(i)) == false)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only lowercase characters.</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>false</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isAllLowerCase(null)   = false\n+     * StringUtils.isAllLowerCase(\"\")     = false\n+     * StringUtils.isAllLowerCase(\"  \")   = false\n+     * StringUtils.isAllLowerCase(\"abc\")  = true\n+     * StringUtils.isAllLowerCase(\"abC\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains lowercase characters, and is non-null\n+     */\n+    public static boolean isAllLowerCase(String str) {\n+        if (str == null || isEmpty(str)) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if (Character.isLowerCase(str.charAt(i)) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only uppercase characters.</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>false</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isAllUpperCase(null)   = false\n+     * StringUtils.isAllUpperCase(\"\")     = false\n+     * StringUtils.isAllUpperCase(\"  \")   = false\n+     * StringUtils.isAllUpperCase(\"ABC\")  = true\n+     * StringUtils.isAllUpperCase(\"aBC\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains uppercase characters, and is non-null\n+     */\n+    public static boolean isAllUpperCase(String str) {\n+        if (str == null || isEmpty(str)) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if (Character.isUpperCase(str.charAt(i)) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    // Defaults\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns either the passed in String,\n+     * or if the String is <code>null</code>, an empty String (\"\").</p>\n+     *\n+     * <pre>\n+     * StringUtils.defaultString(null)  = \"\"\n+     * StringUtils.defaultString(\"\")    = \"\"\n+     * StringUtils.defaultString(\"bat\") = \"bat\"\n+     * </pre>\n+     *\n+     * @see ObjectUtils#toString(Object)\n+     * @see String#valueOf(Object)\n+     * @param str  the String to check, may be null\n+     * @return the passed in String, or the empty String if it\n+     *  was <code>null</code>\n+     */\n+    public static String defaultString(String str) {\n+        return str == null ? EMPTY : str;\n+    }\n+\n+    /**\n+     * <p>Returns either the passed in String, or if the String is\n+     * <code>null</code>, the value of <code>defaultStr</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.defaultString(null, \"NULL\")  = \"NULL\"\n+     * StringUtils.defaultString(\"\", \"NULL\")    = \"\"\n+     * StringUtils.defaultString(\"bat\", \"NULL\") = \"bat\"\n+     * </pre>\n+     *\n+     * @see ObjectUtils#toString(Object,String)\n+     * @see String#valueOf(Object)\n+     * @param str  the String to check, may be null\n+     * @param defaultStr  the default String to return\n+     *  if the input is <code>null</code>, may be null\n+     * @return the passed in String, or the default if it was <code>null</code>\n+     */\n+    public static String defaultString(String str, String defaultStr) {\n+        return str == null ? defaultStr : str;\n+    }\n+\n+    /**\n+     * <p>Returns either the passed in String, or if the String is\n+     * empty or <code>null</code>, the value of <code>defaultStr</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.defaultIfEmpty(null, \"NULL\")  = \"NULL\"\n+     * StringUtils.defaultIfEmpty(\"\", \"NULL\")    = \"NULL\"\n+     * StringUtils.defaultIfEmpty(\"bat\", \"NULL\") = \"bat\"\n+     * StringUtils.defaultIfEmpty(\"\", null)      = null\n+     * </pre>\n+     *\n+     * @see StringUtils#defaultString(String, String)\n+     * @param str  the String to check, may be null\n+     * @param defaultStr  the default String to return\n+     *  if the input is empty (\"\") or <code>null</code>, may be null\n+     * @return the passed in String, or the default\n+     */\n+    public static String defaultIfEmpty(String str, String defaultStr) {\n+        return StringUtils.isEmpty(str) ? defaultStr : str;\n+    }\n+\n+    // Reversing\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Reverses a String as per {@link StringBuilder#reverse()}.</p>\n+     *\n+     * <p>A <code>null</code> String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.reverse(null)  = null\n+     * StringUtils.reverse(\"\")    = \"\"\n+     * StringUtils.reverse(\"bat\") = \"tab\"\n+     * </pre>\n+     *\n+     * @param str  the String to reverse, may be null\n+     * @return the reversed String, <code>null</code> if null String input\n+     */\n+    public static String reverse(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return new StringBuilder(str).reverse().toString();\n+    }\n+\n+    /**\n+     * <p>Reverses a String that is delimited by a specific character.</p>\n+     *\n+     * <p>The Strings between the delimiters are not reversed.\n+     * Thus java.lang.String becomes String.lang.java (if the delimiter\n+     * is <code>'.'</code>).</p>\n+     *\n+     * <pre>\n+     * StringUtils.reverseDelimited(null, *)      = null\n+     * StringUtils.reverseDelimited(\"\", *)        = \"\"\n+     * StringUtils.reverseDelimited(\"a.b.c\", 'x') = \"a.b.c\"\n+     * StringUtils.reverseDelimited(\"a.b.c\", \".\") = \"c.b.a\"\n+     * </pre>\n+     *\n+     * @param str  the String to reverse, may be null\n+     * @param separatorChar  the separator character to use\n+     * @return the reversed String, <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String reverseDelimited(String str, char separatorChar) {\n+        if (str == null) {\n+            return null;\n+        }\n+        // could implement manually, but simple way is to reuse other,\n+        // probably slower, methods.\n+        String[] strs = split(str, separatorChar);\n+        ArrayUtils.reverse(strs);\n+        return join(strs, separatorChar);\n+    }\n+\n+    // Abbreviating\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Abbreviates a String using ellipses. This will turn\n+     * \"Now is the time for all good men\" into \"Now is the time for...\"</p>\n+     *\n+     * <p>Specifically:\n+     * <ul>\n+     *   <li>If <code>str</code> is less than <code>maxWidth</code> characters\n+     *       long, return it.</li>\n+     *   <li>Else abbreviate it to <code>(substring(str, 0, max-3) + \"...\")</code>.</li>\n+     *   <li>If <code>maxWidth</code> is less than <code>4</code>, throw an\n+     *       <code>IllegalArgumentException</code>.</li>\n+     *   <li>In no case will it return a String of length greater than\n+     *       <code>maxWidth</code>.</li>\n+     * </ul>\n+     * </p>\n+     *\n+     * <pre>\n+     * StringUtils.abbreviate(null, *)      = null\n+     * StringUtils.abbreviate(\"\", 4)        = \"\"\n+     * StringUtils.abbreviate(\"abcdefg\", 6) = \"abc...\"\n+     * StringUtils.abbreviate(\"abcdefg\", 7) = \"abcdefg\"\n+     * StringUtils.abbreviate(\"abcdefg\", 8) = \"abcdefg\"\n+     * StringUtils.abbreviate(\"abcdefg\", 4) = \"a...\"\n+     * StringUtils.abbreviate(\"abcdefg\", 3) = IllegalArgumentException\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param maxWidth  maximum length of result String, must be at least 4\n+     * @return abbreviated String, <code>null</code> if null String input\n+     * @throws IllegalArgumentException if the width is too small\n+     * @since 2.0\n+     */\n+    public static String abbreviate(String str, int maxWidth) {\n+        return abbreviate(str, 0, maxWidth);\n+    }\n+\n+    /**\n+     * <p>Abbreviates a String using ellipses. This will turn\n+     * \"Now is the time for all good men\" into \"...is the time for...\"</p>\n+     *\n+     * <p>Works like <code>abbreviate(String, int)</code>, but allows you to specify\n+     * a \"left edge\" offset.  Note that this left edge is not necessarily going to\n+     * be the leftmost character in the result, or the first character following the\n+     * ellipses, but it will appear somewhere in the result.\n+     *\n+     * <p>In no case will it return a String of length greater than\n+     * <code>maxWidth</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.abbreviate(null, *, *)                = null\n+     * StringUtils.abbreviate(\"\", 0, 4)                  = \"\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", -1, 10) = \"abcdefg...\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 0, 10)  = \"abcdefg...\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 1, 10)  = \"abcdefg...\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 4, 10)  = \"abcdefg...\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 5, 10)  = \"...fghi...\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 6, 10)  = \"...ghij...\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 8, 10)  = \"...ijklmno\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 10, 10) = \"...ijklmno\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 12, 10) = \"...ijklmno\"\n+     * StringUtils.abbreviate(\"abcdefghij\", 0, 3)        = IllegalArgumentException\n+     * StringUtils.abbreviate(\"abcdefghij\", 5, 6)        = IllegalArgumentException\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param offset  left edge of source String\n+     * @param maxWidth  maximum length of result String, must be at least 4\n+     * @return abbreviated String, <code>null</code> if null String input\n+     * @throws IllegalArgumentException if the width is too small\n+     * @since 2.0\n+     */\n+    public static String abbreviate(String str, int offset, int maxWidth) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (maxWidth < 4) {\n+            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n+        }\n+        if (str.length() <= maxWidth) {\n+            return str;\n+        }\n+        if (offset > str.length()) {\n+            offset = str.length();\n+        }\n+        if ((str.length() - offset) < (maxWidth - 3)) {\n+            offset = str.length() - (maxWidth - 3);\n+        }\n+        if (offset <= 4) {\n+            return str.substring(0, maxWidth - 3) + \"...\";\n+        }\n+        if (maxWidth < 7) {\n+            throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n+        }\n+        if ((offset + (maxWidth - 3)) < str.length()) {\n+            return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n+        }\n+        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n+    }\n+\n+    // Difference\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compares two Strings, and returns the portion where they differ.\n+     * (More precisely, return the remainder of the second String,\n+     * starting from where it's different from the first.)</p>\n+     *\n+     * <p>For example,\n+     * <code>difference(\"i am a machine\", \"i am a robot\") -> \"robot\"</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.difference(null, null) = null\n+     * StringUtils.difference(\"\", \"\") = \"\"\n+     * StringUtils.difference(\"\", \"abc\") = \"abc\"\n+     * StringUtils.difference(\"abc\", \"\") = \"\"\n+     * StringUtils.difference(\"abc\", \"abc\") = \"\"\n+     * StringUtils.difference(\"ab\", \"abxyz\") = \"xyz\"\n+     * StringUtils.difference(\"abcde\", \"abxyz\") = \"xyz\"\n+     * StringUtils.difference(\"abcde\", \"xyz\") = \"xyz\"\n+     * </pre>\n+     *\n+     * @param str1  the first String, may be null\n+     * @param str2  the second String, may be null\n+     * @return the portion of str2 where it differs from str1; returns the\n+     * empty String if they are equal\n+     * @since 2.0\n+     */\n+    public static String difference(String str1, String str2) {\n+        if (str1 == null) {\n+            return str2;\n+        }\n+        if (str2 == null) {\n+            return str1;\n+        }\n+        int at = indexOfDifference(str1, str2);\n+        if (at == -1) {\n+            return EMPTY;\n+        }\n+        return str2.substring(at);\n+    }\n+\n+    /**\n+     * <p>Compares two Strings, and returns the index at which the\n+     * Strings begin to differ.</p>\n+     *\n+     * <p>For example,\n+     * <code>indexOfDifference(\"i am a machine\", \"i am a robot\") -> 7</code></p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfDifference(null, null) = -1\n+     * StringUtils.indexOfDifference(\"\", \"\") = -1\n+     * StringUtils.indexOfDifference(\"\", \"abc\") = 0\n+     * StringUtils.indexOfDifference(\"abc\", \"\") = 0\n+     * StringUtils.indexOfDifference(\"abc\", \"abc\") = -1\n+     * StringUtils.indexOfDifference(\"ab\", \"abxyz\") = 2\n+     * StringUtils.indexOfDifference(\"abcde\", \"abxyz\") = 2\n+     * StringUtils.indexOfDifference(\"abcde\", \"xyz\") = 0\n+     * </pre>\n+     *\n+     * @param str1  the first String, may be null\n+     * @param str2  the second String, may be null\n+     * @return the index where str2 and str1 begin to differ; -1 if they are equal\n+     * @since 2.0\n+     */\n+    public static int indexOfDifference(String str1, String str2) {\n+        if (str1 == str2) {\n+            return -1;\n+        }\n+        if (str1 == null || str2 == null) {\n+            return 0;\n+        }\n+        int i;\n+        for (i = 0; i < str1.length() && i < str2.length(); ++i) {\n+            if (str1.charAt(i) != str2.charAt(i)) {\n+                break;\n+            }\n+        }\n+        if (i < str2.length() || i < str1.length()) {\n+            return i;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * <p>Compares all Strings in an array and returns the index at which the\n+     * Strings begin to differ.</p>\n+     *\n+     * <p>For example,\n+     * <code>indexOfDifference(new String[] {\"i am a machine\", \"i am a robot\"}) -> 7</code></p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfDifference(null) = -1\n+     * StringUtils.indexOfDifference(new String[] {}) = -1\n+     * StringUtils.indexOfDifference(new String[] {\"abc\"}) = -1\n+     * StringUtils.indexOfDifference(new String[] {null, null}) = -1\n+     * StringUtils.indexOfDifference(new String[] {\"\", \"\"}) = -1\n+     * StringUtils.indexOfDifference(new String[] {\"\", null}) = 0\n+     * StringUtils.indexOfDifference(new String[] {\"abc\", null, null}) = 0\n+     * StringUtils.indexOfDifference(new String[] {null, null, \"abc\"}) = 0\n+     * StringUtils.indexOfDifference(new String[] {\"\", \"abc\"}) = 0\n+     * StringUtils.indexOfDifference(new String[] {\"abc\", \"\"}) = 0\n+     * StringUtils.indexOfDifference(new String[] {\"abc\", \"abc\"}) = -1\n+     * StringUtils.indexOfDifference(new String[] {\"abc\", \"a\"}) = 1\n+     * StringUtils.indexOfDifference(new String[] {\"ab\", \"abxyz\"}) = 2\n+     * StringUtils.indexOfDifference(new String[] {\"abcde\", \"abxyz\"}) = 2\n+     * StringUtils.indexOfDifference(new String[] {\"abcde\", \"xyz\"}) = 0\n+     * StringUtils.indexOfDifference(new String[] {\"xyz\", \"abcde\"}) = 0\n+     * StringUtils.indexOfDifference(new String[] {\"i am a machine\", \"i am a robot\"}) = 7\n+     * </pre>\n+     *\n+     * @param strs  array of strings, entries may be null\n+     * @return the index where the strings begin to differ; -1 if they are all equal\n+     * @since 2.4\n+     */\n+    public static int indexOfDifference(String[] strs) {\n+        if (strs == null || strs.length <= 1) {\n+            return -1;\n+        }\n+        boolean anyStringNull = false;\n+        boolean allStringsNull = true;\n+        int arrayLen = strs.length;\n+        int shortestStrLen = Integer.MAX_VALUE;\n+        int longestStrLen = 0;\n+\n+        // find the min and max string lengths; this avoids checking to make\n+        // sure we are not exceeding the length of the string each time through\n+        // the bottom loop.\n+        for (int i = 0; i < arrayLen; i++) {\n+            if (strs[i] == null) {\n+                anyStringNull = true;\n+                shortestStrLen = 0;\n+            } else {\n+                allStringsNull = false;\n+                shortestStrLen = Math.min(strs[i].length(), shortestStrLen);\n+                longestStrLen = Math.max(strs[i].length(), longestStrLen);\n+            }\n+        }\n+\n+        // handle lists containing all nulls or all empty strings\n+        if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) {\n+            return -1;\n+        }\n+\n+        // handle lists containing some nulls or some empty strings\n+        if (shortestStrLen == 0) {\n+            return 0;\n+        }\n+\n+        // find the position with the first difference across all strings\n+        int firstDiff = -1;\n+        for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {\n+            char comparisonChar = strs[0].charAt(stringPos);\n+            for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {\n+                if (strs[arrayPos].charAt(stringPos) != comparisonChar) {\n+                    firstDiff = stringPos;\n+                    break;\n+                }\n+            }\n+            if (firstDiff != -1) {\n+                break;\n+            }\n+        }\n+\n+        if (firstDiff == -1 && shortestStrLen != longestStrLen) {\n+            // we compared all of the characters up to the length of the\n+            // shortest string and didn't find a match, but the string lengths\n+            // vary, so return the length of the shortest string.\n+            return shortestStrLen;\n+        }\n+        return firstDiff;\n+    }\n+    \n+    /**\n+     * <p>Compares all Strings in an array and returns the initial sequence of \n+     * characters that is common to all of them.</p>\n+     *\n+     * <p>For example,\n+     * <code>getCommonPrefix(new String[] {\"i am a machine\", \"i am a robot\"}) -> \"i am a \"</code></p>\n+     *\n+     * <pre>\n+     * StringUtils.getCommonPrefix(null) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {}) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {\"abc\"}) = \"abc\"\n+     * StringUtils.getCommonPrefix(new String[] {null, null}) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {\"\", \"\"}) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {\"\", null}) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {\"abc\", null, null}) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {null, null, \"abc\"}) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {\"\", \"abc\"}) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {\"abc\", \"\"}) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {\"abc\", \"abc\"}) = \"abc\"\n+     * StringUtils.getCommonPrefix(new String[] {\"abc\", \"a\"}) = \"a\"\n+     * StringUtils.getCommonPrefix(new String[] {\"ab\", \"abxyz\"}) = \"ab\"\n+     * StringUtils.getCommonPrefix(new String[] {\"abcde\", \"abxyz\"}) = \"ab\"\n+     * StringUtils.getCommonPrefix(new String[] {\"abcde\", \"xyz\"}) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {\"xyz\", \"abcde\"}) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {\"i am a machine\", \"i am a robot\"}) = \"i am a \"\n+     * </pre>\n+     *\n+     * @param strs  array of String objects, entries may be null\n+     * @return the initial sequence of characters that are common to all Strings\n+     * in the array; empty String if the array is null, the elements are all null \n+     * or if there is no common prefix. \n+     * @since 2.4\n+     */\n+    public static String getCommonPrefix(String[] strs) {\n+        if (strs == null || strs.length == 0) {\n+            return EMPTY;\n+        }\n+        int smallestIndexOfDiff = indexOfDifference(strs);\n+        if (smallestIndexOfDiff == -1) {\n+            // all strings were identical\n+            if (strs[0] == null) {\n+                return EMPTY;\n+            }\n+            return strs[0];\n+        } else if (smallestIndexOfDiff == 0) {\n+            // there were no common initial characters\n+            return EMPTY;\n+        } else {\n+            // we found a common initial character sequence\n+            return strs[0].substring(0, smallestIndexOfDiff);\n+        }\n+    }  \n+    \n+    // Misc\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Find the Levenshtein distance between two Strings.</p>\n+     *\n+     * <p>This is the number of changes needed to change one String into\n+     * another, where each change is a single character modification (deletion,\n+     * insertion or substitution).</p>\n+     *\n+     * <p>The previous implementation of the Levenshtein distance algorithm\n+     * was from <a href=\"http://www.merriampark.com/ld.htm\">http://www.merriampark.com/ld.htm</a></p>\n+     *\n+     * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError\n+     * which can occur when my Java implementation is used with very large strings.<br>\n+     * This implementation of the Levenshtein distance algorithm\n+     * is from <a href=\"http://www.merriampark.com/ldjava.htm\">http://www.merriampark.com/ldjava.htm</a></p>\n+     *\n+     * <pre>\n+     * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException\n+     * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException\n+     * StringUtils.getLevenshteinDistance(\"\",\"\")               = 0\n+     * StringUtils.getLevenshteinDistance(\"\",\"a\")              = 1\n+     * StringUtils.getLevenshteinDistance(\"aaapppp\", \"\")       = 7\n+     * StringUtils.getLevenshteinDistance(\"frog\", \"fog\")       = 1\n+     * StringUtils.getLevenshteinDistance(\"fly\", \"ant\")        = 3\n+     * StringUtils.getLevenshteinDistance(\"elephant\", \"hippo\") = 7\n+     * StringUtils.getLevenshteinDistance(\"hippo\", \"elephant\") = 7\n+     * StringUtils.getLevenshteinDistance(\"hippo\", \"zzzzzzzz\") = 8\n+     * StringUtils.getLevenshteinDistance(\"hello\", \"hallo\")    = 1\n+     * </pre>\n+     *\n+     * @param s  the first String, must not be null\n+     * @param t  the second String, must not be null\n+     * @return result distance\n+     * @throws IllegalArgumentException if either String input <code>null</code>\n+     */\n+    public static int getLevenshteinDistance(String s, String t) {\n+        if (s == null || t == null) {\n+            throw new IllegalArgumentException(\"Strings must not be null\");\n+        }\n+\n+        /*\n+           The difference between this impl. and the previous is that, rather \n+           than creating and retaining a matrix of size s.length()+1 by t.length()+1, \n+           we maintain two single-dimensional arrays of length s.length()+1.  The first, d,\n+           is the 'current working' distance array that maintains the newest distance cost\n+           counts as we iterate through the characters of String s.  Each time we increment\n+           the index of String t we are comparing, d is copied to p, the second int[].  Doing so\n+           allows us to retain the previous cost counts as required by the algorithm (taking \n+           the minimum of the cost count to the left, up one, and diagonally up and to the left\n+           of the current cost count being calculated).  (Note that the arrays aren't really \n+           copied anymore, just switched...this is clearly much better than cloning an array \n+           or doing a System.arraycopy() each time  through the outer loop.)\n+\n+           Effectively, the difference between the two implementations is this one does not \n+           cause an out of memory condition when calculating the LD over two very large strings.\n+         */\n+\n+        int n = s.length(); // length of s\n+        int m = t.length(); // length of t\n+\n+        if (n == 0) {\n+            return m;\n+        } else if (m == 0) {\n+            return n;\n+        }\n+\n+        if (n > m) {\n+            // swap the input strings to consume less memory\n+            String tmp = s;\n+            s = t;\n+            t = tmp;\n+            n = m;\n+            m = t.length();\n+        }\n+\n+        int p[] = new int[n+1]; //'previous' cost array, horizontally\n+        int d[] = new int[n+1]; // cost array, horizontally\n+        int _d[]; //placeholder to assist in swapping p and d\n+\n+        // indexes into strings s and t\n+        int i; // iterates through s\n+        int j; // iterates through t\n+\n+        char t_j; // jth character of t\n+\n+        int cost; // cost\n+\n+        for (i = 0; i<=n; i++) {\n+            p[i] = i;\n+        }\n+\n+        for (j = 1; j<=m; j++) {\n+            t_j = t.charAt(j-1);\n+            d[0] = j;\n+\n+            for (i=1; i<=n; i++) {\n+                cost = s.charAt(i-1)==t_j ? 0 : 1;\n+                // minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n+                d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+cost);\n+            }\n+\n+            // copy current distance counts to 'previous row' distance counts\n+            _d = p;\n+            p = d;\n+            d = _d;\n+        }\n+\n+        // our last action in the above loop was to switch d and p, so p now \n+        // actually has the most recent cost counts\n+        return p[n];\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>int</code> values.</p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+/*\n+    private static int min(int a, int b, int c) {\n+        // Method copied from NumberUtils to avoid dependency on subpackage\n+        if (b < a) {\n+            a = b;\n+        }\n+        if (c < a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+*/\n+\n+    // startsWith\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * <p>Check if a String starts with a specified prefix.</p>\n+     *\n+     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n+     * references are considered to be equal. The comparison is case sensitive.</p>\n+     *\n+     * <pre>\n+     * StringUtils.startsWith(null, null)      = true\n+     * StringUtils.startsWith(null, \"abc\")     = false\n+     * StringUtils.startsWith(\"abcdef\", null)  = false\n+     * StringUtils.startsWith(\"abcdef\", \"abc\") = true\n+     * StringUtils.startsWith(\"ABCDEF\", \"abc\") = false\n+     * </pre>\n+     *\n+     * @see java.lang.String#startsWith(String)\n+     * @param str  the String to check, may be null\n+     * @param prefix the prefix to find, may be null\n+     * @return <code>true</code> if the String starts with the prefix, case sensitive, or\n+     *  both <code>null</code>\n+     * @since 2.4\n+     */\n+    public static boolean startsWith(String str, String prefix) {\n+        return startsWith(str, prefix, false);\n+    }\n+\n+    /**\n+     * <p>Case insensitive check if a String starts with a specified prefix.</p>\n+     *\n+     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n+     * references are considered to be equal. The comparison is case insensitive.</p>\n+     *\n+     * <pre>\n+     * StringUtils.startsWithIgnoreCase(null, null)      = true\n+     * StringUtils.startsWithIgnoreCase(null, \"abc\")     = false\n+     * StringUtils.startsWithIgnoreCase(\"abcdef\", null)  = false\n+     * StringUtils.startsWithIgnoreCase(\"abcdef\", \"abc\") = true\n+     * StringUtils.startsWithIgnoreCase(\"ABCDEF\", \"abc\") = true\n+     * </pre>\n+     *\n+     * @see java.lang.String#startsWith(String)\n+     * @param str  the String to check, may be null\n+     * @param prefix the prefix to find, may be null\n+     * @return <code>true</code> if the String starts with the prefix, case insensitive, or\n+     *  both <code>null</code>\n+     * @since 2.4\n+     */\n+    public static boolean startsWithIgnoreCase(String str, String prefix) {\n+        return startsWith(str, prefix, true);\n+    }\n+\n+    /**\n+     * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>\n+     *\n+     * @see java.lang.String#startsWith(String)\n+     * @param str  the String to check, may be null\n+     * @param prefix the prefix to find, may be null\n+     * @param ignoreCase inidicates whether the compare should ignore case\n+     *  (case insensitive) or not.\n+     * @return <code>true</code> if the String starts with the prefix or\n+     *  both <code>null</code>\n+     */\n+    private static boolean startsWith(String str, String prefix, boolean ignoreCase) {\n+        if (str == null || prefix == null) {\n+            return (str == null && prefix == null);\n+        }\n+        if (prefix.length() > str.length()) {\n+            return false;\n+        }\n+        return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n+    }\n+    \n+    /**\n+     * <p>Check if a String starts with any of an array of specified strings.</p>\n+     * \n+     * <pre>\n+     * StringUtils.startsWithAny(null, null)      = false\n+     * StringUtils.startsWithAny(null, new String[] {\"abc\"})  = false\n+     * StringUtils.startsWithAny(\"abcxyz\", null)     = false\n+     * StringUtils.startsWithAny(\"abcxyz\", new String[] {\"\"}) = false\n+     * StringUtils.startsWithAny(\"abcxyz\", new String[] {\"abc\"}) = true\n+     * StringUtils.startsWithAny(\"abcxyz\", new String[] {null, \"xyz\", \"abc\"}) = true\n+     * </pre>\n+     *\n+     * @param string  the String to check, may be null\n+     * @param searchStrings the Strings to find, may be null or empty\n+     * @return <code>true</code> if the String starts with any of the the prefixes, case insensitive, or\n+     *  both <code>null</code>\n+     * @since 3.0\n+     */\n+    public static boolean startsWithAny(String string, String[] searchStrings) {\n+        if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n+            return false;\n+        }\n+        for (int i = 0; i < searchStrings.length; i++) {\n+            String searchString = searchStrings[i];\n+            if (StringUtils.startsWith(string, searchString)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    // endsWith\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * <p>Check if a String ends with a specified suffix.</p>\n+     *\n+     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n+     * references are considered to be equal. The comparison is case sensitive.</p>\n+     *\n+     * <pre>\n+     * StringUtils.endsWith(null, null)      = true\n+     * StringUtils.endsWith(null, \"def\")     = false\n+     * StringUtils.endsWith(\"abcdef\", null)  = false\n+     * StringUtils.endsWith(\"abcdef\", \"def\") = true\n+     * StringUtils.endsWith(\"ABCDEF\", \"def\") = false\n+     * StringUtils.endsWith(\"ABCDEF\", \"cde\") = false\n+     * </pre>\n+     *\n+     * @see java.lang.String#endsWith(String)\n+     * @param str  the String to check, may be null\n+     * @param suffix the suffix to find, may be null\n+     * @return <code>true</code> if the String ends with the suffix, case sensitive, or\n+     *  both <code>null</code>\n+     * @since 2.4\n+     */\n+    public static boolean endsWith(String str, String suffix) {\n+        return endsWith(str, suffix, false);\n+    }\n+\n+    /**\n+     * <p>Case insensitive check if a String ends with a specified suffix.</p>\n+     *\n+     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n+     * references are considered to be equal. The comparison is case insensitive.</p>\n+     *\n+     * <pre>\n+     * StringUtils.endsWithIgnoreCase(null, null)      = true\n+     * StringUtils.endsWithIgnoreCase(null, \"def\")     = false\n+     * StringUtils.endsWithIgnoreCase(\"abcdef\", null)  = false\n+     * StringUtils.endsWithIgnoreCase(\"abcdef\", \"def\") = true\n+     * StringUtils.endsWithIgnoreCase(\"ABCDEF\", \"def\") = true\n+     * StringUtils.endsWithIgnoreCase(\"ABCDEF\", \"cde\") = false\n+     * </pre>\n+     *\n+     * @see java.lang.String#endsWith(String)\n+     * @param str  the String to check, may be null\n+     * @param suffix the suffix to find, may be null\n+     * @return <code>true</code> if the String ends with the suffix, case insensitive, or\n+     *  both <code>null</code>\n+     * @since 2.4\n+     */\n+    public static boolean endsWithIgnoreCase(String str, String suffix) {\n+        return endsWith(str, suffix, true);\n+    }\n+\n+    /**\n+     * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>\n+     *\n+     * @see java.lang.String#endsWith(String)\n+     * @param str  the String to check, may be null\n+     * @param suffix the suffix to find, may be null\n+     * @param ignoreCase inidicates whether the compare should ignore case\n+     *  (case insensitive) or not.\n+     * @return <code>true</code> if the String starts with the prefix or\n+     *  both <code>null</code>\n+     */\n+    private static boolean endsWith(String str, String suffix, boolean ignoreCase) {\n+        if (str == null || suffix == null) {\n+            return (str == null && suffix == null);\n+        }\n+        if (suffix.length() > str.length()) {\n+            return false;\n+        }\n+        int strOffset = str.length() - suffix.length();\n+        return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/SystemUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.File;\n+\n+/**\n+ * <p>Helpers for <code>java.lang.System</code>.</p>\n+ * \n+ * <p>If a system property cannot be read due to security restrictions, \n+ * the corresponding field in this class will be set to <code>null</code>\n+ * and a message will be written to <code>System.err</code>.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Based on code from Avalon Excalibur\n+ * @author Based on code from Lucene\n+ * @author <a href=\"mailto:sdowney@panix.com\">Steve Downey</a>\n+ * @author Gary Gregory\n+ * @author Michael Becke\n+ * @author Tetsuya Kaneuchi\n+ * @author Rafal Krupinski\n+ * @author Jason Gritman\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class SystemUtils {\n+\n+    /**\n+     * The prefix String for all Windows OS.\n+     */\n+    private static final String OS_NAME_WINDOWS_PREFIX = \"Windows\";\n+    \n+    // System property constants\n+    //-----------------------------------------------------------------------\n+    // These MUST be declared first. Other constants depend on this.\n+    \n+    /**\n+     * The System property key for the user home directory.\n+     */\n+    private static final String USER_HOME_KEY = \"user.home\";\n+\n+    /**\n+     * The System property key for the user directory.\n+     */\n+    private static final String USER_DIR_KEY = \"user.dir\";\n+    \n+    /**\n+     * The System property key for the Java IO temporary directory.\n+     */\n+    private static final String JAVA_IO_TMPDIR_KEY = \"java.io.tmpdir\";\n+    \n+    /**\n+     * The System property key for the Java home directory.\n+     */\n+    private static final String JAVA_HOME_KEY = \"java.home\";\n+    \n+    /**\n+     * <p>The <code>awt.toolkit</code> System Property.</p>\n+     * <p>Holds a class name, on Windows XP this is <code>sun.awt.windows.WToolkit</code>.</p>\n+     * <p><b>On platforms without a GUI, this value is <code>null</code>.</b></p>\n+     * \n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n+\n+    /**\n+     * <p>The <code>file.encoding</code> System Property.</p>\n+     * <p>File encoding, such as <code>Cp1252</code>.</p>\n+     * \n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.0\n+     * @since Java 1.2\n+     */\n+    public static final String FILE_ENCODING = getSystemProperty(\"file.encoding\");\n+\n+    /**\n+     * <p>The <code>file.separator</code> System Property.\n+     * File separator (<code>&quot;/&quot;</code> on UNIX).</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String FILE_SEPARATOR = getSystemProperty(\"file.separator\");\n+\n+    /**\n+     * <p>The <code>java.awt.fonts</code> System Property.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final String JAVA_AWT_FONTS = getSystemProperty(\"java.awt.fonts\");\n+\n+    /**\n+     * <p>The <code>java.awt.graphicsenv</code> System Property.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final String JAVA_AWT_GRAPHICSENV = getSystemProperty(\"java.awt.graphicsenv\");\n+\n+    /**\n+     * <p>\n+     * The <code>java.awt.headless</code> System Property.\n+     * The value of this property is the String <code>\"true\"</code> or <code>\"false\"</code>. \n+     * </p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @see #isJavaAwtHeadless()\n+     * @since 2.1\n+     * @since Java 1.4\n+     */\n+    public static final String JAVA_AWT_HEADLESS = getSystemProperty(\"java.awt.headless\");\n+\n+    /**\n+     * <p>The <code>java.awt.printerjob</code> System Property.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final String JAVA_AWT_PRINTERJOB = getSystemProperty(\"java.awt.printerjob\");\n+\n+    /**\n+     * <p>The <code>java.class.path</code> System Property. Java class path.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String JAVA_CLASS_PATH = getSystemProperty(\"java.class.path\");\n+\n+    /**\n+     * <p>The <code>java.class.version</code> System Property.\n+     * Java class format version number.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String JAVA_CLASS_VERSION = getSystemProperty(\"java.class.version\");\n+\n+    /**\n+     * <p>The <code>java.compiler</code> System Property. Name of JIT compiler to use.\n+     * First in JDK version 1.2. Not used in Sun JDKs after 1.2.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2. Not used in Sun versions after 1.2.\n+     */\n+    public static final String JAVA_COMPILER = getSystemProperty(\"java.compiler\");\n+\n+    /**\n+     * <p>The <code>java.endorsed.dirs</code> System Property. Path of endorsed directory\n+     * or directories.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.4\n+     */\n+    public static final String JAVA_ENDORSED_DIRS = getSystemProperty(\"java.endorsed.dirs\");\n+\n+    /**\n+     * <p>The <code>java.ext.dirs</code> System Property. Path of extension directory\n+     * or directories.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.3\n+     */\n+    public static final String JAVA_EXT_DIRS = getSystemProperty(\"java.ext.dirs\");\n+\n+    /**\n+     * <p>The <code>java.home</code> System Property. Java installation directory.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String JAVA_HOME = getSystemProperty(JAVA_HOME_KEY);\n+\n+    /**\n+     * <p>The <code>java.io.tmpdir</code> System Property. Default temp file path.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_IO_TMPDIR = getSystemProperty(JAVA_IO_TMPDIR_KEY);\n+\n+    /**\n+     * <p>The <code>java.library.path</code> System Property. List of paths to search\n+     * when loading libraries.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_LIBRARY_PATH = getSystemProperty(\"java.library.path\");\n+\n+    /**\n+     * <p>The <code>java.runtime.name</code> System Property. Java Runtime Environment\n+     * name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.0\n+     * @since Java 1.3\n+     */\n+    public static final String JAVA_RUNTIME_NAME = getSystemProperty(\"java.runtime.name\");\n+\n+    /**\n+     * <p>The <code>java.runtime.version</code> System Property. Java Runtime Environment\n+     * version.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.0\n+     * @since Java 1.3\n+     */\n+    public static final String JAVA_RUNTIME_VERSION = getSystemProperty(\"java.runtime.version\");\n+\n+    /**\n+     * <p>The <code>java.specification.name</code> System Property. Java Runtime Environment\n+     * specification name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_SPECIFICATION_NAME = getSystemProperty(\"java.specification.name\");\n+\n+    /**\n+     * <p>The <code>java.specification.vendor</code> System Property. Java Runtime Environment\n+     * specification vendor.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_SPECIFICATION_VENDOR = getSystemProperty(\"java.specification.vendor\");\n+\n+    /**\n+     * <p>The <code>java.specification.version</code> System Property. Java Runtime Environment\n+     * specification version.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.3\n+     */\n+    public static final String JAVA_SPECIFICATION_VERSION = getSystemProperty(\"java.specification.version\");\n+\n+    /**\n+     * <p>The <code>java.util.prefs.PreferencesFactory</code> System Property. A class name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.1\n+     * @since Java 1.4\n+     */\n+    public static final String JAVA_UTIL_PREFS_PREFERENCES_FACTORY = \n+        getSystemProperty(\"java.util.prefs.PreferencesFactory\");\n+\n+    /**\n+     * <p>The <code>java.vendor</code> System Property. Java vendor-specific string.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String JAVA_VENDOR = getSystemProperty(\"java.vendor\");\n+\n+    /**\n+     * <p>The <code>java.vendor.url</code> System Property. Java vendor URL.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+    */\n+    public static final String JAVA_VENDOR_URL = getSystemProperty(\"java.vendor.url\");\n+\n+    /**\n+     * <p>The <code>java.version</code> System Property. Java version number.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String JAVA_VERSION = getSystemProperty(\"java.version\");\n+\n+    /**\n+     * <p>The <code>java.vm.info</code> System Property. Java Virtual Machine implementation\n+     * info.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.0\n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_INFO = getSystemProperty(\"java.vm.info\");\n+\n+    /**\n+     * <p>The <code>java.vm.name</code> System Property. Java Virtual Machine implementation\n+     * name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_NAME = getSystemProperty(\"java.vm.name\");\n+\n+    /**\n+     * <p>The <code>java.vm.specification.name</code> System Property. Java Virtual Machine\n+     * specification name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_SPECIFICATION_NAME = getSystemProperty(\"java.vm.specification.name\");\n+\n+    /**\n+     * <p>The <code>java.vm.specification.vendor</code> System Property. Java Virtual\n+     * Machine specification vendor.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_SPECIFICATION_VENDOR = getSystemProperty(\"java.vm.specification.vendor\");\n+\n+    /**\n+     * <p>The <code>java.vm.specification.version</code> System Property. Java Virtual Machine\n+     * specification version.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_SPECIFICATION_VERSION = getSystemProperty(\"java.vm.specification.version\");\n+\n+    /**\n+     * <p>The <code>java.vm.vendor</code> System Property. Java Virtual Machine implementation\n+     * vendor.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_VENDOR = getSystemProperty(\"java.vm.vendor\");\n+\n+    /**\n+     * <p>The <code>java.vm.version</code> System Property. Java Virtual Machine\n+     * implementation version.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_VERSION = getSystemProperty(\"java.vm.version\");\n+\n+    /**\n+     * <p>The <code>line.separator</code> System Property. Line separator\n+     * (<code>&quot;\\n&quot;</code> on UNIX).</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String LINE_SEPARATOR = getSystemProperty(\"line.separator\");\n+\n+    /**\n+     * <p>The <code>os.arch</code> System Property. Operating system architecture.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String OS_ARCH = getSystemProperty(\"os.arch\");\n+\n+    /**\n+     * <p>The <code>os.name</code> System Property. Operating system name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String OS_NAME = getSystemProperty(\"os.name\");\n+\n+    /**\n+     * <p>The <code>os.version</code> System Property. Operating system version.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String OS_VERSION = getSystemProperty(\"os.version\");\n+\n+    /**\n+     * <p>The <code>path.separator</code> System Property. Path separator\n+     * (<code>&quot;:&quot;</code> on UNIX).</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String PATH_SEPARATOR = getSystemProperty(\"path.separator\");\n+\n+    /**\n+     * <p>The <code>user.country</code> or <code>user.region</code> System Property.\n+     * User's country code, such as <code>GB</code>. First in JDK version 1.2 as\n+     * <code>user.region</code>. Renamed to <code>user.country</code> in 1.4</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.0\n+     * @since Java 1.2\n+     */\n+    public static final String USER_COUNTRY = \n+        getSystemProperty(\"user.country\") == null ?\n+            getSystemProperty(\"user.region\") : getSystemProperty(\"user.country\");\n+\n+    /**\n+     * <p>The <code>user.dir</code> System Property. User's current working\n+     * directory.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String USER_DIR = getSystemProperty(USER_DIR_KEY);\n+\n+    /**\n+     * <p>The <code>user.home</code> System Property. User's home directory.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String USER_HOME = getSystemProperty(USER_HOME_KEY);\n+\n+    /**\n+     * <p>The <code>user.language</code> System Property. User's language code,\n+     * such as <code>\"en\"</code>.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.0\n+     * @since Java 1.2\n+     */\n+    public static final String USER_LANGUAGE = getSystemProperty(\"user.language\");\n+\n+    /**\n+     * <p>The <code>user.name</code> System Property. User's account name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String USER_NAME = getSystemProperty(\"user.name\");\n+\n+    /**\n+     * <p>The <code>user.timezone</code> System Property. \n+     * For example: <code>\"America/Los_Angeles\"</code>.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final String USER_TIMEZONE = getSystemProperty(\"user.timezone\");\n+\n+    // Java version\n+    //-----------------------------------------------------------------------\n+    // This MUST be declared after those above as it depends on the\n+    // values being set up\n+\n+    /**\n+     * <p>Gets the Java version as a <code>String</code> trimming leading letters.</p>\n+     *\n+     * <p>The field will return <code>null</code> if {@link #JAVA_VERSION} is <code>null</code>.</p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final String JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+\n+    // Java version values\n+    //-----------------------------------------------------------------------\n+    // These MUST be declared after the trim above as they depend on the\n+    // value being set up\n+\n+    /**\n+     * <p>Gets the Java version as a <code>float</code>.</p>\n+     *\n+     * <p>Example return values:</p>\n+     * <ul>\n+     *  <li><code>1.2f</code> for JDK 1.2\n+     *  <li><code>1.31f</code> for JDK 1.3.1\n+     * </ul>\n+     *\n+     * <p>The field will return zero if {@link #JAVA_VERSION} is <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final float JAVA_VERSION_FLOAT = getJavaVersionAsFloat();\n+\n+    /**\n+     * <p>Gets the Java version as an <code>int</code>.</p>\n+     *\n+     * <p>Example return values:</p>\n+     * <ul>\n+     *  <li><code>120</code> for JDK 1.2\n+     *  <li><code>131</code> for JDK 1.3.1\n+     * </ul>\n+     *\n+     * <p>The field will return zero if {@link #JAVA_VERSION} is <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final int JAVA_VERSION_INT = getJavaVersionAsInt();\n+\n+    // Java version checks\n+    //-----------------------------------------------------------------------\n+    // These MUST be declared after those above as they depend on the\n+    // values being set up\n+    \n+    /**\n+     * <p>Is <code>true</code> if this is Java version 1.1 (also 1.1.x versions).</p>\n+     *\n+     * <p>The field will return <code>false</code> if {@link #JAVA_VERSION} is\n+     * <code>null</code>.</p>\n+     */\n+    public static final boolean IS_JAVA_1_1 = getJavaVersionMatches(\"1.1\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Java version 1.2 (also 1.2.x versions).</p>\n+     *\n+     * <p>The field will return <code>false</code> if {@link #JAVA_VERSION} is\n+     * <code>null</code>.</p>\n+     */\n+    public static final boolean IS_JAVA_1_2 = getJavaVersionMatches(\"1.2\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Java version 1.3 (also 1.3.x versions).</p>\n+     *\n+     * <p>The field will return <code>false</code> if {@link #JAVA_VERSION} is\n+     * <code>null</code>.</p>\n+     */\n+    public static final boolean IS_JAVA_1_3 = getJavaVersionMatches(\"1.3\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Java version 1.4 (also 1.4.x versions).</p>\n+     *\n+     * <p>The field will return <code>false</code> if {@link #JAVA_VERSION} is\n+     * <code>null</code>.</p>\n+     */\n+    public static final boolean IS_JAVA_1_4 = getJavaVersionMatches(\"1.4\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Java version 1.5 (also 1.5.x versions).</p>\n+     *\n+     * <p>The field will return <code>false</code> if {@link #JAVA_VERSION} is\n+     * <code>null</code>.</p>\n+     */\n+    public static final boolean IS_JAVA_1_5 = getJavaVersionMatches(\"1.5\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Java version 1.6 (also 1.6.x versions).</p>\n+     *\n+     * <p>The field will return <code>false</code> if {@link #JAVA_VERSION} is\n+     * <code>null</code>.</p>\n+     */\n+    public static final boolean IS_JAVA_1_6 = getJavaVersionMatches(\"1.6\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Java version 1.7 (also 1.7.x versions).</p>\n+     *\n+     * <p>The field will return <code>false</code> if {@link #JAVA_VERSION} is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 3.0\n+     */\n+    public static final boolean IS_JAVA_1_7 = getJavaVersionMatches(\"1.7\");\n+\n+    // Operating system checks\n+    //-----------------------------------------------------------------------\n+    // These MUST be declared after those above as they depend on the\n+    // values being set up\n+    // OS names from http://www.vamphq.com/os.html\n+    // Selected ones included - please advise dev@commons.apache.org\n+    // if you want another added or a mistake corrected\n+\n+    /**\n+     * <p>Is <code>true</code> if this is AIX.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_AIX = getOSMatches(\"AIX\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is HP-UX.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_HP_UX = getOSMatches(\"HP-UX\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Irix.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_IRIX = getOSMatches(\"Irix\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Linux.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_LINUX = getOSMatches(\"Linux\") || getOSMatches(\"LINUX\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Mac.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_MAC = getOSMatches(\"Mac\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Mac.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_MAC_OSX = getOSMatches(\"Mac OS X\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is OS/2.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_OS2 = getOSMatches(\"OS/2\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Solaris.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_SOLARIS = getOSMatches(\"Solaris\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is SunOS.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_SUN_OS = getOSMatches(\"SunOS\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is a POSIX compilant system,\n+     * as in any of AIX, HP-UX, Irix, Linux, MacOSX, Solaris or SUN OS.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final boolean IS_OS_UNIX =\n+        IS_OS_AIX || IS_OS_HP_UX || IS_OS_IRIX || IS_OS_LINUX ||\n+        IS_OS_MAC_OSX || IS_OS_SOLARIS || IS_OS_SUN_OS;\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS = getOSMatches(OS_NAME_WINDOWS_PREFIX);\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows 2000.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS_2000 = getOSMatches(OS_NAME_WINDOWS_PREFIX, \"5.0\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows 95.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS_95 = getOSMatches(OS_NAME_WINDOWS_PREFIX + \" 9\", \"4.0\");\n+    // JDK 1.2 running on Windows98 returns 'Windows 95', hence the above\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows 98.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS_98 = getOSMatches(OS_NAME_WINDOWS_PREFIX + \" 9\", \"4.1\");\n+    // JDK 1.2 running on Windows98 returns 'Windows 95', hence the above\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows ME.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS_ME = getOSMatches(OS_NAME_WINDOWS_PREFIX, \"4.9\");\n+    // JDK 1.2 running on WindowsME may return 'Windows 95', hence the above\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows NT.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS_NT = getOSMatches(OS_NAME_WINDOWS_PREFIX + \" NT\");\n+    // Windows 2000 returns 'Windows 2000' but may suffer from same JDK1.2 problem\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows XP.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS_XP = getOSMatches(OS_NAME_WINDOWS_PREFIX, \"5.1\");\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * <p>Is <code>true</code> if this is Windows Vista.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     *\n+     * @since 2.4\n+     */\n+    public static final boolean IS_OS_WINDOWS_VISTA = getOSMatches(OS_NAME_WINDOWS_PREFIX, \"6.0\"); \n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows 7.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     *\n+     * @since 3.0\n+     */\n+    public static final boolean IS_OS_WINDOWS_7 = getOSMatches(OS_NAME_WINDOWS_PREFIX, \"6.1\"); \n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * <p>SystemUtils instances should NOT be constructed in standard\n+     * programming. Instead, the class should be used as\n+     * <code>SystemUtils.FILE_SEPARATOR</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public SystemUtils() {\n+        super();\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    /**\n+     * <p>Gets the Java version number as a <code>float</code>.</p>\n+     *\n+     * <p>Example return values:</p>\n+     * <ul>\n+     *  <li><code>1.2f</code> for JDK 1.2\n+     *  <li><code>1.31f</code> for JDK 1.3.1\n+     * </ul>\n+     * \n+     * <p>Patch releases are not reported.\n+     * Zero is returned if {@link #JAVA_VERSION_TRIMMED} is <code>null</code>.</p>\n+     * \n+     * @return the version, for example 1.31f for JDK 1.3.1\n+     */\n+    private static float getJavaVersionAsFloat() {\n+        if (JAVA_VERSION_TRIMMED == null) {\n+            return 0f;\n+        }\n+        String str = JAVA_VERSION_TRIMMED.substring(0, 3);\n+        if (JAVA_VERSION_TRIMMED.length() >= 5) {\n+            str = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n+        }\n+        try {\n+            return Float.parseFloat(str);\n+        } catch (Exception ex) {\n+            return 0;\n+        }\n+    }\n+    \n+    /**\n+     * <p>Gets the Java version number as an <code>int</code>.</p>\n+     *\n+     * <p>Example return values:</p>\n+     * <ul>\n+     *  <li><code>120</code> for JDK 1.2\n+     *  <li><code>131</code> for JDK 1.3.1\n+     * </ul>\n+     * \n+     * <p>Patch releases are not reported.\n+     * Zero is returned if {@link #JAVA_VERSION_TRIMMED} is <code>null</code>.</p>\n+     * \n+     * @return the version, for example 131 for JDK 1.3.1\n+     */\n+    private static int getJavaVersionAsInt() {\n+        if (JAVA_VERSION_TRIMMED == null) {\n+            return 0;\n+        }\n+        String str = JAVA_VERSION_TRIMMED.substring(0, 1);\n+        str = str + JAVA_VERSION_TRIMMED.substring(2, 3);\n+        if (JAVA_VERSION_TRIMMED.length() >= 5) {\n+            str = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n+        } else {\n+            str = str + \"0\";\n+        }\n+        try {\n+            return Integer.parseInt(str);\n+        } catch (Exception ex) {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Trims the text of the java version to start with numbers.\n+     * \n+     * @return the trimmed java version\n+     */\n+    private static String getJavaVersionTrimmed() {\n+        if (JAVA_VERSION != null) {\n+            for (int i = 0; i < JAVA_VERSION.length(); i++) {\n+                char ch = JAVA_VERSION.charAt(i);\n+                if (ch >= '0' && ch <= '9') {\n+                    return JAVA_VERSION.substring(i);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Decides if the java version matches.</p>\n+     * \n+     * @param versionPrefix  the prefix for the java version\n+     * @return true if matches, or false if not or can't determine\n+     */\n+    private static boolean getJavaVersionMatches(String versionPrefix) {\n+        if (JAVA_VERSION_TRIMMED == null) {\n+            return false;\n+        }\n+        return JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n+    }    \n+    \n+    /**\n+     * <p>Decides if the operating system matches.</p>\n+     * \n+     * @param osNamePrefix  the prefix for the os name\n+     * @return true if matches, or false if not or can't determine\n+     */\n+    private static boolean getOSMatches(String osNamePrefix) {\n+        if (OS_NAME == null) {\n+            return false;\n+        }\n+        return OS_NAME.startsWith(osNamePrefix);\n+    }    \n+\n+    /**\n+     * <p>Decides if the operating system matches.</p>\n+     * \n+     * @param osNamePrefix  the prefix for the os name\n+     * @param osVersionPrefix  the prefix for the version\n+     * @return true if matches, or false if not or can't determine\n+     */\n+    private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\n+        if (OS_NAME == null || OS_VERSION == null) {\n+            return false;\n+        }\n+        return OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n+    }    \n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a System property, defaulting to <code>null</code> if the property\n+     * cannot be read.</p>\n+     *\n+     * <p>If a <code>SecurityException</code> is caught, the return\n+     * value is <code>null</code> and a message is written to <code>System.err</code>.</p>\n+     * \n+     * @param property the system property name\n+     * @return the system property value or <code>null</code> if a security problem occurs\n+     */\n+    private static String getSystemProperty(String property) {\n+        try {\n+            return System.getProperty(property);\n+        } catch (SecurityException ex) {\n+            // we are not allowed to look at this property\n+            System.err.println(\n+                \"Caught a SecurityException reading the system property '\" + property \n+                + \"'; the SystemUtils property value will default to null.\"\n+            );\n+            return null;\n+        }\n+    }\n+    \n+    /**\n+     * <p>Is the Java version at least the requested version.</p>\n+     *\n+     * <p>Example input:</p>\n+     * <ul>\n+     *  <li><code>1.2f</code> to test for JDK 1.2</li>\n+     *  <li><code>1.31f</code> to test for JDK 1.3.1</li>\n+     * </ul>\n+     * \n+     * @param requiredVersion  the required version, for example 1.31f\n+     * @return <code>true</code> if the actual version is equal or greater\n+     *  than the required version\n+     */\n+    public static boolean isJavaVersionAtLeast(float requiredVersion) {\n+        return JAVA_VERSION_FLOAT >= requiredVersion;\n+    }\n+    \n+    /**\n+     * <p>Is the Java version at least the requested version.</p>\n+     *\n+     * <p>Example input:</p>\n+     * <ul>\n+     *  <li><code>120</code> to test for JDK 1.2 or greater</li>\n+     *  <li><code>131</code> to test for JDK 1.3.1 or greater</li>\n+     * </ul>\n+     * \n+     * @param requiredVersion  the required version, for example 131\n+     * @return <code>true</code> if the actual version is equal or greater\n+     *  than the required version\n+     * @since 2.0\n+     */\n+    public static boolean isJavaVersionAtLeast(int requiredVersion) {\n+        return JAVA_VERSION_INT >= requiredVersion;\n+    }\n+\n+    /**\n+     * Returns whether the {@link #JAVA_AWT_HEADLESS} value is <code>true</code>.\n+     *  \n+     * @return <code>true</code> if <code>JAVA_AWT_HEADLESS</code> is <code>\"true\"</code>,\n+     * <code>false</code> otherwise.\n+     * \n+     * @see #JAVA_AWT_HEADLESS\n+     * @since 2.1\n+     * @since Java 1.4\n+     */\n+    public static boolean isJavaAwtHeadless() {\n+        return JAVA_AWT_HEADLESS != null ? JAVA_AWT_HEADLESS.equals(Boolean.TRUE.toString()) : false;\n+    }\n+    /**\n+     * <p>Gets the Java home directory as a <code>File</code>.</p>\n+     * \n+     * @return a directory\n+     * @throws  SecurityException  if a security manager exists and its  \n+     *             <code>checkPropertyAccess</code> method doesn't allow\n+     *              access to the specified system property.\n+     * @see System#getProperty(String)\n+     * @since 2.1\n+     */\n+    public static File getJavaHome() {\n+        return new File(System.getProperty(JAVA_HOME_KEY));\n+    }\n+\n+    /**\n+     * <p>Gets the Java IO temporary directory as a <code>File</code>.</p>\n+     * \n+     * @return a directory\n+     * @throws  SecurityException  if a security manager exists and its  \n+     *             <code>checkPropertyAccess</code> method doesn't allow\n+     *              access to the specified system property.\n+     * @see System#getProperty(String)\n+     * @since 2.1\n+     */\n+    public static File getJavaIoTmpDir() {\n+        return new File(System.getProperty(JAVA_IO_TMPDIR_KEY));\n+    }\n+\n+    /**\n+     * <p>Gets the user directory as a <code>File</code>.</p>\n+     * \n+     * @return a directory\n+     * @throws  SecurityException  if a security manager exists and its  \n+     *             <code>checkPropertyAccess</code> method doesn't allow\n+     *              access to the specified system property.\n+     * @see System#getProperty(String)\n+     * @since 2.1\n+     */\n+    public static File getUserDir() {\n+        return new File(System.getProperty(USER_DIR_KEY));\n+    }\n+\n+    /**\n+     * <p>Gets the user home directory as a <code>File</code>.</p>\n+     * \n+     * @return a directory\n+     * @throws  SecurityException  if a security manager exists and its  \n+     *             <code>checkPropertyAccess</code> method doesn't allow\n+     *              access to the specified system property.\n+     * @see System#getProperty(String)\n+     * @since 2.1\n+     */\n+    public static File getUserHome() {\n+        return new File(System.getProperty(USER_HOME_KEY));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/Validate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+/**\n+ * <p>This class assists in validating arguments. The validation methods are \n+ * based along the following principles: \n+ * <ul>\n+ *   <li>An invalid <code>null</code> argument causes a {@link NullPointerException}.</li>\n+ *   <li>A non-<code>null</code> argument causes an {@link IllegalArgumentException}.</li>\n+ *   <li>An invalid index into an array/collection/map/string causes an {@link IndexOutOfBoundsException}.</li> \n+ * </ul>\n+ *  \n+ * <p>All exceptions messages are <a href=\"http://java.sun.com/j2se/1.5.0/docs/api/java/util/Formatter.html#syntax\">format strings</a>\n+ * as defined by the Java platform. For example:</p>\n+ * \n+ * <pre>\n+ * Validate.isTrue(i > 0, \"The value must be greater than zero: %d\", i);\n+ * Validate.notNull(surname, \"The surname must not be %s\", null);\n+ * </pre>\n+ * \n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:ola.berg@arkitema.se\">Ola Berg</a>\n+ * @author Gary Gregory\n+ * @author Norm Deane\n+ * @author Paul Benedict\n+ * @version $Id$\n+ * @see java.lang.String#format(String, Object...)\n+ * @since 2.0\n+ */\n+public class Validate {\n+\n+    private static final String DEFAULT_IS_NULL_EXCEPTION_MESSAGE = \"The validated object is null\";\n+    private static final String DEFAULT_IS_TRUE_EXCEPTION_MESSAGE = \"The validated expression is false\";\n+    private static final String DEFAULT_NO_NULL_ELEMENTS_ARRAY_EXCEPTION_MESSAGE = \"The validated array contains null element at index: %d\";\n+    private static final String DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EXCEPTION_MESSAGE = \"The validated collection contains null element at index: %d\";\n+    private static final String DEFAULT_NOT_BLANK_EXCEPTION_MESSAGE = \"The validated character sequence is blank\";\n+    private static final String DEFAULT_NOT_EMPTY_ARRAY_EXCEPTION_MESSAGE = \"The validated array is empty\";\n+    private static final String DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EXCEPTION_MESSAGE = \"The validated character sequence is empty\";\n+    private static final String DEFAULT_NOT_EMPTY_COLLECTION_EXCEPTION_MESSAGE = \"The validated collection is empty\";\n+    private static final String DEFAULT_NOT_EMPTY_MAP_EXCEPTION_MESSAGE = \"The validated map is empty\";\n+    private static final String DEFAULT_VALID_INDEX_ARRAY_EXCEPTION_MESSAGE = \"The validated array index is invalid: %d\";\n+    private static final String DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EXCEPTION_MESSAGE = \"The validated character sequence index is invalid: %d\";\n+    private static final String DEFAULT_VALID_INDEX_COLLECTION_EXCEPTION_MESSAGE = \"The validated collection index is invalid: %d\";\n+\n+    /**\n+     * Constructor. This class should not normally be instantiated.\n+     */\n+    public Validate() {\n+      super();\n+    }\n+\n+    // isTrue\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate that the argument condition is <code>true</code>; otherwise \n+     * throwing an exception with the specified message. This method is useful when\n+     * validating according to an arbitrary boolean expression, such as validating a \n+     * primitive number or using your own custom validation expression.</p>\n+     *\n+     * <pre>Validate.isTrue(myObject.isOk(), \"The object is not OK: %s\", myObject);</pre>\n+     *\n+     * <p>For performance reasons, the object is passed as a separate parameter and\n+     * appended to the exception message only in the case of an error.</p>\n+     * \n+     * @param expression the boolean expression to check \n+     * @param message the exception message if invalid\n+     * @param value the value to append to the message when invalid\n+     * @throws IllegalArgumentException if expression is <code>false</code>\n+     * @see #isTrue(boolean)\n+     * @see #isTrue(boolean, String, long)\n+     * @see #isTrue(boolean, String, double)\n+     * @see #isTrue(boolean, String, Object...)\n+     */\n+    public static void isTrue(boolean expression, String message, Object value) {\n+        if (expression == false) {\n+            throw new IllegalArgumentException(String.format(message, value));\n+        }\n+    }\n+\n+    /**\n+     * <p>Validate that the argument condition is <code>true</code>; otherwise \n+     * throwing an exception with the specified message. This method is useful when\n+     * validating according to an arbitrary boolean expression, such as validating a \n+     * primitive number or using your own custom validation expression.</p>\n+     *\n+     * <pre>Validate.isTrue(i > 0.0, \"The value must be greater than zero: %d\", i);</pre>\n+     *\n+     * <p>For performance reasons, the long value is passed as a separate parameter and\n+     * appended to the exception message only in the case of an error.</p>\n+     * \n+     * @param expression the boolean expression to check \n+     * @param message the exception message if invalid\n+     * @param value the value to append to the message when invalid\n+     * @throws IllegalArgumentException if expression is <code>false</code>\n+     * @see #isTrue(boolean)\n+     * @see #isTrue(boolean, String, double)\n+     * @see #isTrue(boolean, String, Object)\n+     * @see #isTrue(boolean, String, Object...)\n+     */\n+    public static void isTrue(boolean expression, String message, long value) {\n+        if (expression == false) {\n+            throw new IllegalArgumentException(String.format(message, value));\n+        }\n+    }\n+\n+    /**\n+     * <p>Validate that the argument condition is <code>true</code>; otherwise \n+     * throwing an exception with the specified message. This method is useful when\n+     * validating according to an arbitrary boolean expression, such as validating a \n+     * primitive number or using your own custom validation expression.</p>\n+     *\n+     * <pre>Validate.isTrue(d > 0.0, \"The value must be greater than zero: %s\", d);</pre>\n+     *\n+     * <p>For performance reasons, the double value is passed as a separate parameter and\n+     * appended to the exception message only in the case of an error.</p>\n+     * \n+     * @param expression the boolean expression to check \n+     * @param message the exception message if invalid\n+     * @param value the value to append to the message when invalid\n+     * @throws IllegalArgumentException if expression is <code>false</code>\n+     * @see #isTrue(boolean)\n+     * @see #isTrue(boolean, String, long)\n+     * @see #isTrue(boolean, String, Object)\n+     * @see #isTrue(boolean, String, Object...)\n+     */\n+    public static void isTrue(boolean expression, String message, double value) {\n+        if (expression == false) {\n+            throw new IllegalArgumentException(String.format(message, value));\n+        }\n+    }\n+\n+    /**\n+     * <p>Validate that the argument condition is <code>true</code>; otherwise \n+     * throwing an exception with the specified message. This method is useful when\n+     * validating according to an arbitrary boolean expression, such as validating a \n+     * primitive number or using your own custom validation expression.</p>\n+     *\n+     * <pre>\n+     * Validate.isTrue(i >= min && i <= max, \"The value must be between %d and %d\", min, max);\n+     * Validate.isTrue(myObject.isOk(), \"The object is not okay\");</pre>\n+     *\n+     * <p>For performance reasons, the message string should not involve a string append,\n+     * instead use the {@link #isTrue(boolean, String, Object)} method.</p>\n+     * \n+     * @param expression the boolean expression to check \n+     * @param message the exception message if invalid\n+     * @param values the optional values for the formatted exception message\n+     * @throws IllegalArgumentException if expression is <code>false</code>\n+     * @see #isTrue(boolean)\n+     * @see #isTrue(boolean, String, long)\n+     * @see #isTrue(boolean, String, double)\n+     * @see #isTrue(boolean, String, Object)\n+     */\n+    public static void isTrue(boolean expression, String message, Object... values) {\n+        if (expression == false) {\n+            throw new IllegalArgumentException(String.format(message, values));\n+        }\n+    }\n+\n+    /**\n+     * <p>Validate that the argument condition is <code>true</code>; otherwise \n+     * throwing an exception. This method is useful when validating according \n+     * to an arbitrary boolean expression, such as validating a \n+     * primitive number or using your own custom validation expression.</p>\n+     *\n+     * <pre>\n+     * Validate.isTrue(i > 0);\n+     * Validate.isTrue(myObject.isOk());</pre>\n+     *\n+     * <p>The message of the exception is &quot;The validated expression is \n+     * false&quot;.</p>\n+     * \n+     * @param expression the boolean expression to check \n+     * @throws IllegalArgumentException if expression is <code>false</code>\n+     * @see #isTrue(boolean, String, long)\n+     * @see #isTrue(boolean, String, double)\n+     * @see #isTrue(boolean, String, Object)\n+     * @see #isTrue(boolean, String, Object...)\n+     */\n+    public static void isTrue(boolean expression) {\n+        if (expression == false) {\n+            throw new IllegalArgumentException(DEFAULT_IS_TRUE_EXCEPTION_MESSAGE);\n+        }\n+    }\n+\n+    // notNull\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate that the specified argument is not <code>null</code>; \n+     * otherwise throwing an exception.\n+     *\n+     * <pre>Validate.notNull(myObject, \"The object must not be null\");</pre>\n+     *\n+     * <p>The message of the exception is &quot;The validated object is \n+     * null&quot;.</p>\n+     * \n+     * @param <T> the object type\n+     * @param object the object to check\n+     * @return the validated object (never <code>null</code> for method chaining)\n+     * @throws NullPointerException if the object is <code>null</code>\n+     * @see #notNull(Object, String, Object...)\n+     */\n+    public static <T> T notNull(T object) {\n+        return notNull(object, DEFAULT_IS_NULL_EXCEPTION_MESSAGE);\n+    }\n+\n+    /**\n+     * <p>Validate that the specified argument is not <code>null</code>; \n+     * otherwise throwing an exception with the specified message.\n+     *\n+     * <pre>Validate.notNull(myObject, \"The object must not be null\");</pre>\n+     * \n+     * @param <T> the object type\n+     * @param object the object to check\n+     * @param message the exception message if invalid\n+     * @param values the optional values for the formatted exception message\n+     * @return the validated object (never <code>null</code> for method chaining)\n+     * @throws NullPointerException if the object is <code>null</code>\n+     * @see #notNull(Object)\n+     */\n+    public static <T> T notNull(T object, String message, Object... values) {\n+        if (object == null) {\n+            throw new NullPointerException(String.format(message, values));\n+        }\n+        return object;\n+    }\n+\n+    // notEmpty array\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate that the specified argument array is neither <code>null</code> \n+     * nor a length of zero (no elements); otherwise throwing an exception \n+     * with the specified message.\n+     *\n+     * <pre>Validate.notEmpty(myArray, \"The array must not be empty\");</pre>\n+     * \n+     * @param <T> the array type\n+     * @param array the array to check\n+     * @param message the exception message if invalid\n+     * @return the validated array (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the array is <code>null</code>\n+     * @throws IllegalArgumentException if the array is empty\n+     * @see #notEmpty(Object[])\n+     */\n+    public static <T> T[] notEmpty(T[] array, String message, Object... values) {\n+        if (array == null) {\n+            throw new NullPointerException(String.format(message, values));\n+        }\n+        if (array.length == 0) {\n+            throw new IllegalArgumentException(String.format(message, values));\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * <p>Validate that the specified argument array is neither <code>null</code> \n+     * nor a length of zero (no elements); otherwise throwing an exception. \n+     *\n+     * <pre>Validate.notEmpty(myArray);</pre>\n+     * \n+     * <p>The message in the exception is &quot;The validated array is \n+     * empty&quot;.\n+     * \n+     * @param <T> the array type\n+     * @param array the array to check\n+     * @return the validated array (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the array is <code>null</code>\n+     * @throws IllegalArgumentException if the array is empty\n+     * @see #notEmpty(Object[], String, Object...)\n+     */\n+    public static <T> T[] notEmpty(T[] array) {\n+        return notEmpty(array, DEFAULT_NOT_EMPTY_ARRAY_EXCEPTION_MESSAGE);\n+    }\n+\n+    // notEmpty collection\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate that the specified argument collection is neither <code>null</code> \n+     * nor a size of zero (no elements); otherwise throwing an exception \n+     * with the specified message.\n+     *\n+     * <pre>Validate.notEmpty(myCollection, \"The collection must not be empty\");</pre>\n+     * \n+     * @param <T> the collection type\n+     * @param collection the collection to check\n+     * @param message the exception message if invalid\n+     * @return the validated collection (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the collection is <code>null</code>\n+     * @throws IllegalArgumentException if the collection is empty\n+     * @see #notEmpty(Object[])\n+     */\n+    public static <T extends Collection<?>> T notEmpty(T collection, String message, Object... values) {\n+        if (collection == null) {\n+            throw new NullPointerException(String.format(message, values));\n+        }\n+        if (collection.size() == 0) {\n+            throw new IllegalArgumentException(String.format(message, values));\n+        }\n+        return collection;\n+    }\n+\n+    /**\n+     * <p>Validate that the specified argument collection is neither <code>null</code> \n+     * nor a size of zero (no elements); otherwise throwing an exception. \n+     *\n+     * <pre>Validate.notEmpty(myCollection);</pre>\n+     * \n+     * <p>The message in the exception is &quot;The validated collection is \n+     * empty&quot;.</p>\n+     * \n+     * @param <T> the collection type\n+     * @param collection the collection to check\n+     * @return the validated collection (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the collection is <code>null</code>\n+     * @throws IllegalArgumentException if the collection is empty\n+     * @see #notEmpty(Collection, String, Object...)\n+     */\n+    public static <T extends Collection<?>> T notEmpty(T collection) {\n+        return notEmpty(collection, DEFAULT_NOT_EMPTY_COLLECTION_EXCEPTION_MESSAGE);\n+    }\n+\n+    // notEmpty map\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate that the specified argument map is neither <code>null</code> \n+     * nor a size of zero (no elements); otherwise throwing an exception \n+     * with the specified message.\n+     *\n+     * <pre>Validate.notEmpty(myMap, \"The map must not be empty\");</pre>\n+     * \n+     * @param <T> the map type\n+     * @param map the map to check\n+     * @param message the exception message if invalid\n+     * @return the validated map (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the map is <code>null</code>\n+     * @throws IllegalArgumentException if the map is empty\n+     * @see #notEmpty(Object[])\n+     */\n+    public static <T extends Map<?, ?>> T notEmpty(T map, String message, Object... values) {\n+        if (map == null) {\n+            throw new NullPointerException(String.format(message, values));\n+        }\n+        if (map.size() == 0) {\n+            throw new IllegalArgumentException(String.format(message, values));\n+        }\n+        return map;\n+    }\n+\n+    /**\n+     * <p>Validate that the specified argument map is neither <code>null</code> \n+     * nor a size of zero (no elements); otherwise throwing an exception. \n+     *\n+     * <pre>Validate.notEmpty(myMap);</pre>\n+     * \n+     * <p>The message in the exception is &quot;The validated map is \n+     * empty&quot;.</p>\n+     * \n+     * @param <T> the map type\n+     * @param map the map to check\n+     * @return the validated map (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the map is <code>null</code>\n+     * @throws IllegalArgumentException if the map is empty\n+     * @see #notEmpty(Map, String, Object...)\n+     */\n+    public static <T extends Map<?, ?>> T notEmpty(T map) {\n+        return notEmpty(map, DEFAULT_NOT_EMPTY_MAP_EXCEPTION_MESSAGE);\n+    }\n+\n+    // notEmpty string\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate that the specified argument character sequence is \n+     * neither <code>null</code> nor a length of zero (no characters); \n+     * otherwise throwing an exception with the specified message.\n+     *\n+     * <pre>Validate.notEmpty(myString, \"The string must not be empty\");</pre>\n+     * \n+     * @param <T> the character sequence type\n+     * @param chars the character sequence to check\n+     * @param message the exception message if invalid\n+     * @return the validated character sequence (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the character sequence is <code>null</code>\n+     * @throws IllegalArgumentException if the character sequence is empty\n+     * @see #notEmpty(CharSequence)\n+     */\n+    public static <T extends CharSequence> T notEmpty(T chars, String message, Object... values) {\n+        if (chars == null) {\n+            throw new NullPointerException(String.format(message, values));\n+        }\n+        if (chars.length() == 0) {\n+            throw new IllegalArgumentException(String.format(message, values));\n+        }\n+        return chars;\n+    }\n+\n+    /**\n+     * <p>Validate that the specified argument character sequence is \n+     * neither <code>null</code> nor a length of zero (no characters); \n+     * otherwise throwing an exception with the specified message.\n+     *\n+     * <pre>Validate.notEmpty(myString);</pre>\n+     * \n+     * <p>The message in the exception is &quot;The validated \n+     * character sequence is empty&quot;.</p>\n+     * \n+     * @param <T> the character sequence type\n+     * @param chars the character sequence to check\n+     * @return the validated character sequence (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the character sequence is <code>null</code>\n+     * @throws IllegalArgumentException if the character sequence is empty\n+     * @see #notEmpty(CharSequence, String, Object...)\n+     */\n+    public static <T extends CharSequence> T notEmpty(T chars) {\n+        return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EXCEPTION_MESSAGE);\n+    }\n+\n+    // notBlank string\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate that the specified argument character sequence is \n+     * neither <code>null</code>, a length of zero (no characters), empty\n+     * nor whitespace; otherwise throwing an exception with the specified \n+     * message.\n+     *\n+     * <pre>Validate.notBlank(myString, \"The string must not be blank\");</pre>\n+     * \n+     * @param <T> the character sequence type\n+     * @param chars the character sequence to check\n+     * @param message the exception message if invalid\n+     * @return the validated character sequence (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the character sequence is <code>null</code>\n+     * @throws IllegalArgumentException if the character sequence is blank\n+     * @see #notBlank(CharSequence)\n+     */\n+    public static <T extends CharSequence> T notBlank(T chars, String message, Object... values) {\n+        if (chars == null) {\n+            throw new NullPointerException(String.format(message, values));\n+        }\n+        if (StringUtils.isBlank(chars)) {\n+            throw new IllegalArgumentException(String.format(message, values));\n+        }\n+        return chars;\n+    }\n+\n+    /**\n+     * <p>Validate that the specified argument character sequence is \n+     * neither <code>null</code>, a length of zero (no characters), empty\n+     * nor whitespace; otherwise throwing an exception.\n+     *\n+     * <pre>Validate.notBlank(myString);</pre>\n+     * \n+     * <p>The message in the exception is &quot;The validated character \n+     * sequence is blank&quot;.</p>\n+     * \n+     * @param <T> the character sequence type\n+     * @param chars the character sequence to check\n+     * @return the validated character sequence (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the character sequence is <code>null</code>\n+     * @throws IllegalArgumentException if the character sequence is blank\n+     * @see #notBlank(CharSequence, String, Object...)\n+     */\n+    public static <T extends CharSequence> T notBlank(T chars) {\n+        return notBlank(chars, DEFAULT_NOT_BLANK_EXCEPTION_MESSAGE);\n+    }\n+\n+    // notNullElements array\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate that the specified argument array is neither \n+     * <code>null</code> nor contains any elements that are <code>null</code>;\n+     * otherwise throwing an exception with the specified message.\n+     *\n+     * <pre>Validate.noNullElements(myArray, \"The array contain null at position %d\");</pre>\n+     * \n+     * <p>If the array is <code>null</code>, then the message in the exception \n+     * is &quot;The validated object is null&quot;.</p>\n+     * \n+     * <p>If the array has a <code>null</code> element, then the iteration \n+     * index of the invalid element is appended to the <code>values</code> \n+     * argument.</p>\n+     * \n+     * @param <T> the array type\n+     * @param array the array to check\n+     * @return the validated array (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the array is <code>null</code>\n+     * @throws IllegalArgumentException if an element is <code>null</code>\n+     * @see #noNullElements(Object[])\n+     */\n+    public static <T> T[] noNullElements(T[] array, String message, Object... values) {\n+        Validate.notNull(array);\n+        for (int i = 0; i < array.length; i++) {\n+            if (array[i] == null) {\n+                Object[] values2 = ArrayUtils.add(values, i);\n+                throw new IllegalArgumentException(String.format(message, values2));\n+            }\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * <p>Validate that the specified argument array is neither \n+     * <code>null</code> nor contains any elements that are <code>null</code>;\n+     * otherwise throwing an exception.\n+     *\n+     * <pre>Validate.noNullElements(myArray);</pre>\n+     * \n+     * <p>If the array is <code>null</code>, then the message in the exception \n+     * is &quot;The validated object is null&quot;.</p>\n+     * \n+     * <p>If the array has a <code>null</code> element, then the message in the\n+     * exception is &quot;The validated array contains null element at index: \n+     * &quot followed by the index.</p>\n+     *\n+     * @param <T> the array type\n+     * @param array the array to check\n+     * @return the validated array (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the array is <code>null</code>\n+     * @throws IllegalArgumentException if an element is <code>null</code>\n+     * @see #noNullElements(Object[], String, Object...)\n+     */\n+    public static <T> T[] noNullElements(T[] array) {\n+        return noNullElements(array, DEFAULT_NO_NULL_ELEMENTS_ARRAY_EXCEPTION_MESSAGE);\n+    }\n+\n+    // notNullElements collection\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate that the specified argument collection is neither \n+     * <code>null</code> nor contains any elements that are <code>null</code>;\n+     * otherwise throwing an exception with the specified message.\n+     *\n+     * <pre>Validate.noNullElements(myCollection, \"The collection contains null at position %d\");</pre>\n+     * \n+     * <p>If the collection is <code>null</code>, then the message in the exception \n+     * is &quot;The validated object is null&quot;.</p>\n+     * \n+     * <p>If the collection has a <code>null</code> element, then the iteration \n+     * index of the invalid element is appended to the <code>values</code> \n+     * argument.</p>\n+     *\n+     * @param <T> the collection type\n+     * @param collection the collection to check\n+     * @return the validated collection (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the array is <code>null</code>\n+     * @throws IllegalArgumentException if an element is <code>null</code>\n+     * @see #noNullElements(Collection, String, Object...)\n+     */\n+    public static <T extends Collection<?>> T noNullElements(T collection, String message, Object... values) {\n+        Validate.notNull(collection);\n+        int i = 0;\n+        for (Iterator<?> it = collection.iterator(); it.hasNext(); i++) {\n+            if (it.next() == null) {\n+                Object[] values2 = ArrayUtils.addAll(values, i);\n+                throw new IllegalArgumentException(String.format(message, values2));\n+            }\n+        }\n+        return collection;\n+    }\n+\n+    /**\n+     * <p>Validate that the specified argument collection is neither \n+     * <code>null</code> nor contains any elements that are <code>null</code>;\n+     * otherwise throwing an exception.\n+     *\n+     * <pre>Validate.noNullElements(myCollection);</pre>\n+     * \n+     * <p>If the collection is <code>null</code>, then the message in the exception \n+     * is &quot;The validated object is null&quot;.</p>\n+     * \n+     * <p>If the array has a <code>null</code> element, then the message in the\n+     * exception is &quot;The validated collection contains null element at index: \n+     * &quot followed by the index.</p>\n+     *\n+     * @param <T> the collection type\n+     * @param collection the collection to check\n+     * @return the validated collection (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the array is <code>null</code>\n+     * @throws IllegalArgumentException if an element is <code>null</code>\n+     * @see #noNullElements(Collection, String, Object...)\n+     */\n+    public static <T extends Collection<?>> T noNullElements(T collection) {\n+        return noNullElements(collection, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EXCEPTION_MESSAGE);\n+    }\n+\n+    // validIndex array\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validates that the index is within the bounds of the argument \n+     * array; otherwise throwing an exception with the specified message.</p>\n+     *\n+     * <pre>Validate.validIndex(myArray, 2, \"The array index is invalid: \");</pre>\n+     * \n+     * <p>If the array is <code>null</code>, then the message of the exception \n+     * is &quot;The validated object is null&quot;.</p>\n+     * \n+     * @param <T> the array type\n+     * @param array the array to check\n+     * @param index the index\n+     * @param message the exception message if invalid\n+     * @return the validated array (never <code>null</code> for method chaining)\n+     * @throws NullPointerException if the array is <code>null</code>\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @see #validIndex(Object[], int)\n+     */\n+    public static <T> T[] validIndex(T[] array, int index, String message, Object... values) {\n+        Validate.notNull(array);\n+        if (index < 0 || index >= array.length) {\n+            throw new IndexOutOfBoundsException(String.format(message, values));\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * <p>Validates that the index is within the bounds of the argument \n+     * array; otherwise throwing an exception.</p>\n+     *\n+     * <pre>Validate.validIndex(myArray, 2);</pre>\n+     *\n+     * <p>If the array is <code>null</code>, then the message of the exception\n+     * is &quot;The validated object is null&quot;.</p>\n+     * \n+     * <p>If the index is invalid, then the message of the exception is \n+     * &quot;The validated array index is invalid: &quot; followed by the \n+     * index.</p>\n+     * \n+     * @param <T> the array type\n+     * @param array the array to check\n+     * @param index the index\n+     * @return the validated array (never <code>null</code> for method chaining)\n+     * @throws NullPointerException if the array is <code>null</code>\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @see #validIndex(Object[], int, String, Object...)\n+     */\n+    public static <T> T[] validIndex(T[] array, int index) {\n+        return validIndex(array, index, DEFAULT_VALID_INDEX_ARRAY_EXCEPTION_MESSAGE, index);\n+    }\n+\n+    // validIndex collection\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validates that the index is within the bounds of the argument \n+     * collection; otherwise throwing an exception with the specified message.</p>\n+     *\n+     * <pre>Validate.validIndex(myCollection, 2, \"The collection index is invalid: \");</pre>\n+     * \n+     * <p>If the collection is <code>null</code>, then the message of the \n+     * exception is &quot;The validated object is null&quot;.</p>\n+     *\n+     * @param <T> the collection type\n+     * @param collection the collection to check\n+     * @param index the index\n+     * @param message the exception message if invalid\n+     * @return the validated collection (never <code>null</code> for chaining)\n+     * @throws NullPointerException if the collection is <code>null</code>\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @see #validIndex(Collection, int)\n+     */\n+    public static <T extends Collection<?>> T validIndex(T collection, int index, String message, Object... values) {\n+        Validate.notNull(collection);\n+        if (index < 0 || index >= collection.size()) {\n+            throw new IndexOutOfBoundsException(String.format(message, values));\n+        }\n+        return collection;\n+    }\n+\n+    /**\n+     * <p>Validates that the index is within the bounds of the argument \n+     * collection; otherwise throwing an exception.</p>\n+     *\n+     * <pre>Validate.validIndex(myCollection, 2);</pre>\n+     *\n+     * <p>If the index is invalid, then the message of the exception \n+     * is &quot;The validated collection index is invalid: &quot; \n+     * followed by the index.</p>\n+     * \n+     * @param <T> the collection type\n+     * @param collection the collection to check\n+     * @param index the index\n+     * @return the validated collection (never <code>null</code> for method chaining)\n+     * @throws NullPointerException if the collection is <code>null</code>\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @see #validIndex(Collection, int, String, Object...)\n+     */\n+    public static <T extends Collection<?>> T validIndex(T collection, int index) {\n+        return validIndex(collection, index, DEFAULT_VALID_INDEX_COLLECTION_EXCEPTION_MESSAGE, index);\n+    }\n+\n+    // validIndex string\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validates that the index is within the bounds of the argument \n+     * character sequence; otherwise throwing an exception with the \n+     * specified message.</p>\n+     *\n+     * <pre>Validate.validIndex(myStr, 2, \"The string index is invalid: \");</pre>\n+     * \n+     * <p>If the character sequence is <code>null</code>, then the message \n+     * of the exception is &quot;The validated object is null&quot;.</p>\n+     *\n+     * @param <T> the character sequence type\n+     * @param chars the character sequence to check\n+     * @param index the index\n+     * @param message the exception message if invalid\n+     * @return the validated character sequence (never <code>null</code> for method chaining)\n+     * @throws NullPointerException if the character sequence is <code>null</code>\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @see #validIndex(CharSequence, int)\n+     */\n+    public static <T extends CharSequence> T validIndex(T chars, int index, String message, Object... values) {\n+        Validate.notNull(chars);\n+        if (index < 0 || index >= chars.length()) {\n+            throw new IndexOutOfBoundsException(String.format(message, values));\n+        }\n+        return chars;\n+    }\n+\n+    /**\n+     * <p>Validates that the index is within the bounds of the argument \n+     * character sequence; otherwise throwing an exception.</p>\n+     * \n+     * <pre>Validate.validIndex(myStr, 2);</pre>\n+     *\n+     * <p>If the character sequence is <code>null</code>, then the message \n+     * of the exception is &quot;The validated object is \n+     * null&quot;.</p>\n+     * \n+     * <p>If the index is invalid, then the message of the exception \n+     * is &quot;The validated character sequence index is invalid: &quot; \n+     * followed by the index.</p>\n+     * \n+     * @param <T> the character sequence type\n+     * @param chars the character sequence to check\n+     * @param index the index\n+     * @return the validated character sequence (never <code>null</code> for method chaining)\n+     * @throws NullPointerException if the character sequence is <code>null</code>\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @see #validIndex(CharSequence, int, String, Object...)\n+     */\n+    public static <T extends CharSequence> T validIndex(T chars, int index) {\n+        return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EXCEPTION_MESSAGE, index);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/WordUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+/**\n+ * <p>Operations on Strings that contain words.</p>\n+ * \n+ * <p>This class tries to handle <code>null</code> input gracefully.\n+ * An exception will not be thrown for a <code>null</code> input.\n+ * Each method documents its behaviour in more detail.</p>\n+ * \n+ * @author Apache Software Foundation\n+ * @author Apache Jakarta Velocity\n+ * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n+ * @author Gary Gregory\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class WordUtils {\n+\n+    /**\n+     * <p><code>WordUtils</code> instances should NOT be constructed in\n+     * standard programming. Instead, the class should be used as\n+     * <code>WordUtils.wrap(\"foo bar\", 20);</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public WordUtils() {\n+      super();\n+    }\n+\n+    // Wrapping\n+    //--------------------------------------------------------------------------\n+//    /**\n+//     * <p>Wraps a block of text to a specified line length using '\\n' as\n+//     * a newline.</p>\n+//     *\n+//     * <p>This method takes a block of text, which might have long lines in it\n+//     * and wraps the long lines based on the supplied lineLength parameter.</p>\n+//     * \n+//     * <p>If a single word is longer than the line length (eg. a URL), it will\n+//     * not be broken, and will display beyond the expected width.</p>\n+//     * \n+//     * <p>If there are tabs in inString, you are going to get results that are\n+//     * a bit strange. Tabs are a single character but are displayed as 4 or 8\n+//     * spaces. Remove the tabs.</p>\n+//     *\n+//     * @param str  text which is in need of word-wrapping, may be null\n+//     * @param lineLength  the column to wrap the words at\n+//     * @return the text with all the long lines word-wrapped\n+//     *  <code>null</code> if null string input\n+//     */\n+//    public static String wrapText(String str, int lineLength) {\n+//        return wrap(str, null, lineLength);\n+//    }\n+    \n+//    /**\n+//     * <p>Wraps a block of text to a specified line length.</p>\n+//     *\n+//     * <p>This method takes a block of text, which might have long lines in it\n+//     * and wraps the long lines based on the supplied lineLength parameter.</p>\n+//     * \n+//     * <p>If a single word is longer than the wrapColumn (eg. a URL), it will\n+//     * not be broken, and will display beyond the expected width.</p>\n+//     * \n+//     * <p>If there are tabs in inString, you are going to get results that are\n+//     * a bit strange. Tabs are a single character but are displayed as 4 or 8\n+//     * spaces. Remove the tabs.</p>\n+//     *\n+//     * @param str  text which is in need of word-wrapping, may be null\n+//     * @param newLineChars  the characters that define a newline, null treated as \\n\n+//     * @param lineLength  the column to wrap the words at\n+//     * @return the text with all the long lines word-wrapped\n+//     *  <code>null</code> if null string input\n+//     */\n+//    public static String wrapText(String str, String newLineChars, int lineLength) {\n+//        if (str == null) {\n+//            return null;\n+//        }\n+//        if (newLineChars == null) {\n+//            newLineChars = \"\\n\";\n+//        }\n+//        StringTokenizer lineTokenizer = new StringTokenizer(str, newLineChars, true);\n+//        StringBuffer stringBuffer = new StringBuffer();\n+//\n+//        while (lineTokenizer.hasMoreTokens()) {\n+//            try {\n+//                String nextLine = lineTokenizer.nextToken();\n+//\n+//                if (nextLine.length() > lineLength) {\n+//                    // This line is long enough to be wrapped.\n+//                    nextLine = wrapLine(nextLine, null, lineLength, false);\n+//                }\n+//\n+//                stringBuffer.append(nextLine);\n+//\n+//            } catch (NoSuchElementException nsee) {\n+//                // thrown by nextToken(), but I don't know why it would\n+//                break;\n+//            }\n+//        }\n+//\n+//        return stringBuffer.toString();\n+//    }\n+\n+    // Wrapping\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Wraps a single line of text, identifying words by <code>' '</code>.</p>\n+     * \n+     * <p>New lines will be separated by the system property line separator.\n+     * Very long words, such as URLs will <i>not</i> be wrapped.</p>\n+     * \n+     * <p>Leading spaces on a new line are stripped.\n+     * Trailing spaces are not stripped.</p>\n+     *\n+     * <pre>\n+     * WordUtils.wrap(null, *) = null\n+     * WordUtils.wrap(\"\", *) = \"\"\n+     * </pre>\n+     *\n+     * @param str  the String to be word wrapped, may be null\n+     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n+     * @return a line with newlines inserted, <code>null</code> if null input\n+     */\n+    public static String wrap(String str, int wrapLength) {\n+        return wrap(str, wrapLength, null, false);\n+    }\n+    \n+    /**\n+     * <p>Wraps a single line of text, identifying words by <code>' '</code>.</p>\n+     * \n+     * <p>Leading spaces on a new line are stripped.\n+     * Trailing spaces are not stripped.</p>\n+     * \n+     * <pre>\n+     * WordUtils.wrap(null, *, *, *) = null\n+     * WordUtils.wrap(\"\", *, *, *) = \"\"\n+     * </pre>\n+     *\n+     * @param str  the String to be word wrapped, may be null\n+     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n+     * @param newLineStr  the string to insert for a new line, \n+     *  <code>null</code> uses the system property line separator\n+     * @param wrapLongWords  true if long words (such as URLs) should be wrapped\n+     * @return a line with newlines inserted, <code>null</code> if null input\n+     */\n+    public static String wrap(String str, int wrapLength, String newLineStr, boolean wrapLongWords) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (newLineStr == null) {\n+            newLineStr = SystemUtils.LINE_SEPARATOR;\n+        }\n+        if (wrapLength < 1) {\n+            wrapLength = 1;\n+        }\n+        int inputLineLength = str.length();\n+        int offset = 0;\n+        StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);\n+        \n+        while ((inputLineLength - offset) > wrapLength) {\n+            if (str.charAt(offset) == ' ') {\n+                offset++;\n+                continue;\n+            }\n+            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);\n+\n+            if (spaceToWrapAt >= offset) {\n+                // normal case\n+                wrappedLine.append(str.substring(offset, spaceToWrapAt));\n+                wrappedLine.append(newLineStr);\n+                offset = spaceToWrapAt + 1;\n+                \n+            } else {\n+                // really long word or URL\n+                if (wrapLongWords) {\n+                    // wrap really long word one line at a time\n+                    wrappedLine.append(str.substring(offset, wrapLength + offset));\n+                    wrappedLine.append(newLineStr);\n+                    offset += wrapLength;\n+                } else {\n+                    // do not wrap really long word, just extend beyond limit\n+                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);\n+                    if (spaceToWrapAt >= 0) {\n+                        wrappedLine.append(str.substring(offset, spaceToWrapAt));\n+                        wrappedLine.append(newLineStr);\n+                        offset = spaceToWrapAt + 1;\n+                    } else {\n+                        wrappedLine.append(str.substring(offset));\n+                        offset = inputLineLength;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Whatever is left in line is short enough to just pass through\n+        wrappedLine.append(str.substring(offset));\n+\n+        return wrappedLine.toString();\n+    }\n+\n+    // Capitalizing\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Capitalizes all the whitespace separated words in a String.\n+     * Only the first letter of each word is changed. To convert the \n+     * rest of each word to lowercase at the same time, \n+     * use {@link #capitalizeFully(String)}.</p>\n+     *\n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.\n+     * Capitalization uses the unicode title case, normally equivalent to\n+     * upper case.</p>\n+     *\n+     * <pre>\n+     * WordUtils.capitalize(null)        = null\n+     * WordUtils.capitalize(\"\")          = \"\"\n+     * WordUtils.capitalize(\"i am FINE\") = \"I Am FINE\"\n+     * </pre>\n+     * \n+     * @param str  the String to capitalize, may be null\n+     * @return capitalized String, <code>null</code> if null String input\n+     * @see #uncapitalize(String)\n+     * @see #capitalizeFully(String)\n+     */\n+    public static String capitalize(String str) {\n+        return capitalize(str, null);\n+    }\n+\n+    /**\n+     * <p>Capitalizes all the delimiter separated words in a String.\n+     * Only the first letter of each word is changed. To convert the \n+     * rest of each word to lowercase at the same time, \n+     * use {@link #capitalizeFully(String, char[])}.</p>\n+     *\n+     * <p>The delimiters represent a set of characters understood to separate words.\n+     * The first string character and the first non-delimiter character after a\n+     * delimiter will be capitalized. </p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * Capitalization uses the unicode title case, normally equivalent to\n+     * upper case.</p>\n+     *\n+     * <pre>\n+     * WordUtils.capitalize(null, *)            = null\n+     * WordUtils.capitalize(\"\", *)              = \"\"\n+     * WordUtils.capitalize(*, new char[0])     = *\n+     * WordUtils.capitalize(\"i am fine\", null)  = \"I Am Fine\"\n+     * WordUtils.capitalize(\"i aM.fine\", {'.'}) = \"I aM.Fine\"\n+     * </pre>\n+     * \n+     * @param str  the String to capitalize, may be null\n+     * @param delimiters  set of characters to determine capitalization, null means whitespace\n+     * @return capitalized String, <code>null</code> if null String input\n+     * @see #uncapitalize(String)\n+     * @see #capitalizeFully(String)\n+     * @since 2.1\n+     */\n+    public static String capitalize(String str, char[] delimiters) {\n+        int delimLen = (delimiters == null ? -1 : delimiters.length);\n+        if (str == null || str.length() == 0 || delimLen == 0) {\n+            return str;\n+        }\n+        int strLen = str.length();\n+        StringBuilder buffer = new StringBuilder(strLen);\n+        boolean capitalizeNext = true;\n+        for (int i = 0; i < strLen; i++) {\n+            char ch = str.charAt(i);\n+\n+            if (isDelimiter(ch, delimiters)) {\n+                buffer.append(ch);\n+                capitalizeNext = true;\n+            } else if (capitalizeNext) {\n+                buffer.append(Character.toTitleCase(ch));\n+                capitalizeNext = false;\n+            } else {\n+                buffer.append(ch);\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts all the whitespace separated words in a String into capitalized words, \n+     * that is each word is made up of a titlecase character and then a series of \n+     * lowercase characters.  </p>\n+     *\n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.\n+     * Capitalization uses the unicode title case, normally equivalent to\n+     * upper case.</p>\n+     *\n+     * <pre>\n+     * WordUtils.capitalizeFully(null)        = null\n+     * WordUtils.capitalizeFully(\"\")          = \"\"\n+     * WordUtils.capitalizeFully(\"i am FINE\") = \"I Am Fine\"\n+     * </pre>\n+     * \n+     * @param str  the String to capitalize, may be null\n+     * @return capitalized String, <code>null</code> if null String input\n+     */\n+    public static String capitalizeFully(String str) {\n+        return capitalizeFully(str, null);\n+    }\n+\n+    /**\n+     * <p>Converts all the delimiter separated words in a String into capitalized words, \n+     * that is each word is made up of a titlecase character and then a series of \n+     * lowercase characters. </p>\n+     *\n+     * <p>The delimiters represent a set of characters understood to separate words.\n+     * The first string character and the first non-delimiter character after a\n+     * delimiter will be capitalized. </p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * Capitalization uses the unicode title case, normally equivalent to\n+     * upper case.</p>\n+     *\n+     * <pre>\n+     * WordUtils.capitalizeFully(null, *)            = null\n+     * WordUtils.capitalizeFully(\"\", *)              = \"\"\n+     * WordUtils.capitalizeFully(*, null)            = *\n+     * WordUtils.capitalizeFully(*, new char[0])     = *\n+     * WordUtils.capitalizeFully(\"i aM.fine\", {'.'}) = \"I am.Fine\"\n+     * </pre>\n+     * \n+     * @param str  the String to capitalize, may be null\n+     * @param delimiters  set of characters to determine capitalization, null means whitespace\n+     * @return capitalized String, <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String capitalizeFully(String str, char[] delimiters) {\n+        int delimLen = (delimiters == null ? -1 : delimiters.length);\n+        if (str == null || str.length() == 0 || delimLen == 0) {\n+            return str;\n+        }\n+        str = str.toLowerCase();\n+        return capitalize(str, delimiters);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Uncapitalizes all the whitespace separated words in a String.\n+     * Only the first letter of each word is changed.</p>\n+     *\n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * WordUtils.uncapitalize(null)        = null\n+     * WordUtils.uncapitalize(\"\")          = \"\"\n+     * WordUtils.uncapitalize(\"I Am FINE\") = \"i am fINE\"\n+     * </pre>\n+     * \n+     * @param str  the String to uncapitalize, may be null\n+     * @return uncapitalized String, <code>null</code> if null String input\n+     * @see #capitalize(String)\n+     */\n+    public static String uncapitalize(String str) {\n+        return uncapitalize(str, null);\n+    }\n+\n+    /**\n+     * <p>Uncapitalizes all the whitespace separated words in a String.\n+     * Only the first letter of each word is changed.</p>\n+     *\n+     * <p>The delimiters represent a set of characters understood to separate words.\n+     * The first string character and the first non-delimiter character after a\n+     * delimiter will be uncapitalized. </p>\n+     *\n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * WordUtils.uncapitalize(null, *)            = null\n+     * WordUtils.uncapitalize(\"\", *)              = \"\"\n+     * WordUtils.uncapitalize(*, null)            = *\n+     * WordUtils.uncapitalize(*, new char[0])     = *\n+     * WordUtils.uncapitalize(\"I AM.FINE\", {'.'}) = \"i AM.fINE\"\n+     * </pre>\n+     * \n+     * @param str  the String to uncapitalize, may be null\n+     * @param delimiters  set of characters to determine uncapitalization, null means whitespace\n+     * @return uncapitalized String, <code>null</code> if null String input\n+     * @see #capitalize(String)\n+     * @since 2.1\n+     */\n+    public static String uncapitalize(String str, char[] delimiters) {\n+        int delimLen = (delimiters == null ? -1 : delimiters.length);\n+        if (str == null || str.length() == 0 || delimLen == 0) {\n+            return str;\n+        }\n+        int strLen = str.length();\n+        StringBuilder buffer = new StringBuilder(strLen);\n+        boolean uncapitalizeNext = true;\n+        for (int i = 0; i < strLen; i++) {\n+            char ch = str.charAt(i);\n+\n+            if (isDelimiter(ch, delimiters)) {\n+                buffer.append(ch);\n+                uncapitalizeNext = true;\n+            } else if (uncapitalizeNext) {\n+                buffer.append(Character.toLowerCase(ch));\n+                uncapitalizeNext = false;\n+            } else {\n+                buffer.append(ch);\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Swaps the case of a String using a word based algorithm.</p>\n+     * \n+     * <ul>\n+     *  <li>Upper case character converts to Lower case</li>\n+     *  <li>Title case character converts to Lower case</li>\n+     *  <li>Lower case character after Whitespace or at start converts to Title case</li>\n+     *  <li>Other Lower case character converts to Upper case</li>\n+     * </ul>\n+     * \n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     * \n+     * <pre>\n+     * StringUtils.swapCase(null)                 = null\n+     * StringUtils.swapCase(\"\")                   = \"\"\n+     * StringUtils.swapCase(\"The dog has a BONE\") = \"tHE DOG HAS A bone\"\n+     * </pre>\n+     * \n+     * @param str  the String to swap case, may be null\n+     * @return the changed String, <code>null</code> if null String input\n+     */\n+    public static String swapCase(String str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return str;\n+        }\n+        StringBuilder buffer = new StringBuilder(strLen);\n+\n+        boolean whitespace = true;\n+        char ch = 0;\n+        char tmp = 0;\n+\n+        for (int i = 0; i < strLen; i++) {\n+            ch = str.charAt(i);\n+            if (Character.isUpperCase(ch)) {\n+                tmp = Character.toLowerCase(ch);\n+            } else if (Character.isTitleCase(ch)) {\n+                tmp = Character.toLowerCase(ch);\n+            } else if (Character.isLowerCase(ch)) {\n+                if (whitespace) {\n+                    tmp = Character.toTitleCase(ch);\n+                } else {\n+                    tmp = Character.toUpperCase(ch);\n+                }\n+            } else {\n+                tmp = ch;\n+            }\n+            buffer.append(tmp);\n+            whitespace = Character.isWhitespace(ch);\n+        }\n+        return buffer.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Extracts the initial letters from each word in the String.</p>\n+     * \n+     * <p>The first letter of the string and all first letters after\n+     * whitespace are returned as a new string.\n+     * Their case is not changed.</p>\n+     *\n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * WordUtils.initials(null)             = null\n+     * WordUtils.initials(\"\")               = \"\"\n+     * WordUtils.initials(\"Ben John Lee\")   = \"BJL\"\n+     * WordUtils.initials(\"Ben J.Lee\")      = \"BJ\"\n+     * </pre>\n+     *\n+     * @param str  the String to get initials from, may be null\n+     * @return String of initial letters, <code>null</code> if null String input\n+     * @see #initials(String,char[])\n+     * @since 2.2\n+     */\n+    public static String initials(String str) {\n+        return initials(str, null);\n+    }\n+\n+    /**\n+     * <p>Extracts the initial letters from each word in the String.</p>\n+     * \n+     * <p>The first letter of the string and all first letters after the\n+     * defined delimiters are returned as a new string.\n+     * Their case is not changed.</p>\n+     *\n+     * <p>If the delimiters array is null, then Whitespace is used.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.\n+     * An empty delimiter array returns an empty String.</p>\n+     *\n+     * <pre>\n+     * WordUtils.initials(null, *)                = null\n+     * WordUtils.initials(\"\", *)                  = \"\"\n+     * WordUtils.initials(\"Ben John Lee\", null)   = \"BJL\"\n+     * WordUtils.initials(\"Ben J.Lee\", null)      = \"BJ\"\n+     * WordUtils.initials(\"Ben J.Lee\", [' ','.']) = \"BJL\"\n+     * WordUtils.initials(*, new char[0])         = \"\"\n+     * </pre>\n+     * \n+     * @param str  the String to get initials from, may be null\n+     * @param delimiters  set of characters to determine words, null means whitespace\n+     * @return String of initial letters, <code>null</code> if null String input\n+     * @see #initials(String)\n+     * @since 2.2\n+     */\n+    public static String initials(String str, char[] delimiters) {\n+        if (str == null || str.length() == 0) {\n+            return str;\n+        }\n+        if (delimiters != null && delimiters.length == 0) {\n+            return \"\";\n+        }\n+        int strLen = str.length();\n+        char[] buf = new char[strLen / 2 + 1];\n+        int count = 0;\n+        boolean lastWasGap = true;\n+        for (int i = 0; i < strLen; i++) {\n+            char ch = str.charAt(i);\n+\n+            if (isDelimiter(ch, delimiters)) {\n+                lastWasGap = true;\n+            } else if (lastWasGap) {\n+                buf[count++] = ch;\n+                lastWasGap = false;\n+            } else {\n+                // ignore ch\n+            }\n+        }\n+        return new String(buf, 0, count);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is the character a delimiter.\n+     *\n+     * @param ch  the character to check\n+     * @param delimiters  the delimiters\n+     * @return true if it is a delimiter\n+     */\n+    private static boolean isDelimiter(char ch, char[] delimiters) {\n+        if (delimiters == null) {\n+            return Character.isWhitespace(ch);\n+        }\n+        for (int i = 0, isize = delimiters.length; i < isize; i++) {\n+            if (ch == delimiters[i]) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Abbreviates a string nicely.\n+     * \n+     * This method searches for the first space after the lower limit and abbreviates\n+     * the String there. It will also append any String passed as a parameter\n+     * to the end of the String. The upper limit can be specified to forcibly\n+     * abbreviate a String.\n+     * \n+     * @param str         the string to be abbreviated. If null is passed, null is returned.\n+     *                    If the empty String is passed, the empty string is returned.\n+     * @param lower       the lower limit.\n+     * @param upper       the upper limit; specify -1 if no limit is desired.\n+     *                    If the upper limit is lower than the lower limit, it will be\n+     *                    adjusted to be the same as the lower limit.\n+     * @param appendToEnd String to be appended to the end of the abbreviated string.\n+     *                    This is appended ONLY if the string was indeed abbreviated.\n+     *                    The append does not count towards the lower or upper limits.\n+     * @return the abbreviated String.\n+     * @since 2.4\n+     */\n+    public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n+        // initial parameter checks\n+        if (str == null) {\n+            return null;\n+        }\n+        if (str.length() == 0) {\n+            return StringUtils.EMPTY;\n+        }\n+\n+        // if the lower value is greater than the length of the string,\n+        // set to the length of the string\n+        if (lower > str.length()) {\n+            lower = str.length();    \n+        }\n+        // if the upper value is -1 (i.e. no limit) or is greater\n+        // than the length of the string, set to the length of the string\n+        if (upper == -1 || upper > str.length()) {\n+            upper = str.length();\n+        }\n+        // if upper is less than lower, raise it to lower\n+        if (upper < lower) {\n+            upper = lower;\n+        }\n+\n+        StringBuilder result = new StringBuilder();\n+        int index = StringUtils.indexOf(str, \" \", lower);\n+        if (index == -1) {\n+            result.append(str.substring(0, upper));\n+            // only if abbreviation has occured do we append the appendToEnd value\n+            if (upper != str.length()) {\n+                result.append(StringUtils.defaultString(appendToEnd));\n+            }\n+        } else if (index > upper) {\n+            result.append(str.substring(0, upper));\n+            result.append(StringUtils.defaultString(appendToEnd));\n+        } else {\n+            result.append(str.substring(0, index));\n+            result.append(StringUtils.defaultString(appendToEnd));\n+        }\n+        return result.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/builder/CompareToBuilder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+/** \n+ * Assists in implementing {@link java.lang.Comparable#compareTo(Object)} methods.\n+ *\n+ * It is consistent with <code>equals(Object)</code> and\n+ * <code>hashcode()</code> built with {@link EqualsBuilder} and\n+ * {@link HashCodeBuilder}.</p>\n+ *\n+ * <p>Two Objects that compare equal using <code>equals(Object)</code> should normally\n+ * also compare equal using <code>compareTo(Object)</code>.</p>\n+ *\n+ * <p>All relevant fields should be included in the calculation of the\n+ * comparison. Derived fields may be ignored. The same fields, in the same\n+ * order, should be used in both <code>compareTo(Object)</code> and\n+ * <code>equals(Object)</code>.</p>\n+ *\n+ * <p>To use this class write code as follows:</p>\n+ *\n+ * <pre>\n+ * public class MyClass {\n+ *   String field1;\n+ *   int field2;\n+ *   boolean field3;\n+ *\n+ *   ...\n+ *\n+ *   public int compareTo(Object o) {\n+ *     MyClass myClass = (MyClass) o;\n+ *     return new CompareToBuilder()\n+ *       .appendSuper(super.compareTo(o)\n+ *       .append(this.field1, myClass.field1)\n+ *       .append(this.field2, myClass.field2)\n+ *       .append(this.field3, myClass.field3)\n+ *       .toComparison();\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>Alternatively, there are {@link #reflectionCompare(Object, Object) reflectionCompare} methods that use\n+ * reflection to determine the fields to append. Because fields can be private,\n+ * <code>reflectionCompare</code> uses {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} to\n+ * bypass normal access control checks. This will fail under a security manager,\n+ * unless the appropriate permissions are set up correctly. It is also\n+ * slower than appending explicitly.</p>\n+ *\n+ * <p>A typical implementation of <code>compareTo(Object)</code> using\n+ * <code>reflectionCompare</code> looks like:</p>\n+\n+ * <pre>\n+ * public int compareTo(Object o) {\n+ *   return CompareToBuilder.reflectionCompare(this, o);\n+ * }\n+ * </pre>\n+ *\n+ * @see java.lang.Comparable\n+ * @see java.lang.Object#equals(Object)\n+ * @see java.lang.Object#hashCode()\n+ * @see EqualsBuilder\n+ * @see HashCodeBuilder\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:steve.downey@netfolio.com\">Steve Downey</a>\n+ * @author Gary Gregory\n+ * @author Pete Gieser\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class CompareToBuilder {\n+    \n+    /**\n+     * Current state of the comparison as appended fields are checked.\n+     */\n+    private int comparison;\n+\n+    /**\n+     * <p>Constructor for CompareToBuilder.</p>\n+     *\n+     * <p>Starts off assuming that the objects are equal. Multiple calls are \n+     * then made to the various append methods, followed by a call to \n+     * {@link #toComparison} to get the result.</p>\n+     */\n+    public CompareToBuilder() {\n+        super();\n+        comparison = 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** \n+     * <p>Compares two <code>Object</code>s via reflection.</p>\n+     *\n+     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n+     * is used to bypass normal access control checks. This will fail under a \n+     * security manager unless the appropriate permissions are set.</p>\n+     *\n+     * <ul>\n+     * <li>Static fields will not be compared</li>\n+     * <li>Transient members will be not be compared, as they are likely derived\n+     *     fields</li>\n+     * <li>Superclass fields will be compared</li>\n+     * </ul>\n+     *\n+     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n+     * they are considered equal.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n+     *  is less than, equal to, or greater than <code>rhs</code>\n+     * @throws NullPointerException  if either (but not both) parameters are\n+     *  <code>null</code>\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     */\n+    public static int reflectionCompare(Object lhs, Object rhs) {\n+        return reflectionCompare(lhs, rhs, false, null, null);\n+    }\n+\n+    /**\n+     * <p>Compares two <code>Object</code>s via reflection.</p>\n+     *\n+     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n+     * is used to bypass normal access control checks. This will fail under a \n+     * security manager unless the appropriate permissions are set.</p>\n+     *\n+     * <ul>\n+     * <li>Static fields will not be compared</li>\n+     * <li>If <code>compareTransients</code> is <code>true</code>,\n+     *     compares transient members.  Otherwise ignores them, as they\n+     *     are likely derived fields.</li>\n+     * <li>Superclass fields will be compared</li>\n+     * </ul>\n+     *\n+     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n+     * they are considered equal.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param compareTransients  whether to compare transient fields\n+     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n+     *  is less than, equal to, or greater than <code>rhs</code>\n+     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>\n+     *  (but not both) is <code>null</code>\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     */\n+    public static int reflectionCompare(Object lhs, Object rhs, boolean compareTransients) {\n+        return reflectionCompare(lhs, rhs, compareTransients, null, null);\n+    }\n+\n+    /**\n+     * <p>Compares two <code>Object</code>s via reflection.</p>\n+     *\n+     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n+     * is used to bypass normal access control checks. This will fail under a \n+     * security manager unless the appropriate permissions are set.</p>\n+     *\n+     * <ul>\n+     * <li>Static fields will not be compared</li>\n+     * <li>If <code>compareTransients</code> is <code>true</code>,\n+     *     compares transient members.  Otherwise ignores them, as they\n+     *     are likely derived fields.</li>\n+     * <li>Superclass fields will be compared</li>\n+     * </ul>\n+     *\n+     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n+     * they are considered equal.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param excludeFields  Collection of String fields to exclude\n+     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n+     *  is less than, equal to, or greater than <code>rhs</code>\n+     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>\n+     *  (but not both) is <code>null</code>\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     * @since 2.2\n+     */\n+    public static int reflectionCompare(Object lhs, Object rhs, Collection<String> excludeFields) {\n+        return reflectionCompare(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n+    }\n+\n+    /**\n+     * <p>Compares two <code>Object</code>s via reflection.</p>\n+     *\n+     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n+     * is used to bypass normal access control checks. This will fail under a \n+     * security manager unless the appropriate permissions are set.</p>\n+     *\n+     * <ul>\n+     * <li>Static fields will not be compared</li>\n+     * <li>If <code>compareTransients</code> is <code>true</code>,\n+     *     compares transient members.  Otherwise ignores them, as they\n+     *     are likely derived fields.</li>\n+     * <li>Superclass fields will be compared</li>\n+     * </ul>\n+     *\n+     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n+     * they are considered equal.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param excludeFields  array of fields to exclude\n+     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n+     *  is less than, equal to, or greater than <code>rhs</code>\n+     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>\n+     *  (but not both) is <code>null</code>\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     * @since 2.2\n+     */\n+    public static int reflectionCompare(Object lhs, Object rhs, String[] excludeFields) {\n+        return reflectionCompare(lhs, rhs, false, null, excludeFields);\n+    }\n+\n+    /**\n+     * <p>Compares two <code>Object</code>s via reflection.</p>\n+     *\n+     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n+     * is used to bypass normal access control checks. This will fail under a \n+     * security manager unless the appropriate permissions are set.</p>\n+     *\n+     * <ul>\n+     * <li>Static fields will not be compared</li>\n+     * <li>If the <code>compareTransients</code> is <code>true</code>,\n+     *     compares transient members.  Otherwise ignores them, as they\n+     *     are likely derived fields.</li>\n+     * <li>Compares superclass fields up to and including <code>reflectUpToClass</code>.\n+     *     If <code>reflectUpToClass</code> is <code>null</code>, compares all superclass fields.</li>\n+     * </ul>\n+     *\n+     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n+     * they are considered equal.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param compareTransients  whether to compare transient fields\n+     * @param reflectUpToClass  last superclass for which fields are compared\n+     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n+     *  is less than, equal to, or greater than <code>rhs</code>\n+     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>\n+     *  (but not both) is <code>null</code>\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     * @since 2.0\n+     */\n+    public static int reflectionCompare(Object lhs, Object rhs, boolean compareTransients, \n+                                        Class<?> reflectUpToClass) \n+    {\n+        return reflectionCompare(lhs, rhs, false, reflectUpToClass, null);\n+    }\n+\n+    /**\n+     * <p>Compares two <code>Object</code>s via reflection.</p>\n+     *\n+     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n+     * is used to bypass normal access control checks. This will fail under a \n+     * security manager unless the appropriate permissions are set.</p>\n+     *\n+     * <ul>\n+     * <li>Static fields will not be compared</li>\n+     * <li>If the <code>compareTransients</code> is <code>true</code>,\n+     *     compares transient members.  Otherwise ignores them, as they\n+     *     are likely derived fields.</li>\n+     * <li>Compares superclass fields up to and including <code>reflectUpToClass</code>.\n+     *     If <code>reflectUpToClass</code> is <code>null</code>, compares all superclass fields.</li>\n+     * </ul>\n+     *\n+     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n+     * they are considered equal.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param compareTransients  whether to compare transient fields\n+     * @param reflectUpToClass  last superclass for which fields are compared\n+     * @param excludeFields  fields to exclude\n+     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n+     *  is less than, equal to, or greater than <code>rhs</code>\n+     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>\n+     *  (but not both) is <code>null</code>\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     * @since 2.2\n+     */\n+    public static int reflectionCompare(\n+        Object lhs, \n+        Object rhs, \n+        boolean compareTransients, \n+        Class<?> reflectUpToClass, \n+        String[] excludeFields) {\n+\n+        if (lhs == rhs) {\n+            return 0;\n+        }\n+        if (lhs == null || rhs == null) {\n+            throw new NullPointerException();\n+        }\n+        Class<?> lhsClazz = lhs.getClass();\n+        if (!lhsClazz.isInstance(rhs)) {\n+            throw new ClassCastException();\n+        }\n+        CompareToBuilder compareToBuilder = new CompareToBuilder();\n+        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n+        while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {\n+            lhsClazz = lhsClazz.getSuperclass();\n+            reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n+        }\n+        return compareToBuilder.toComparison();\n+    }\n+\n+    /**\n+     * <p>Appends to <code>builder</code> the comparison of <code>lhs</code>\n+     * to <code>rhs</code> using the fields defined in <code>clazz</code>.</p>\n+     * \n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param clazz  <code>Class</code> that defines fields to be compared\n+     * @param builder  <code>CompareToBuilder</code> to append to\n+     * @param useTransients  whether to compare transient fields\n+     * @param excludeFields  fields to exclude\n+     */\n+    private static void reflectionAppend(\n+        Object lhs,\n+        Object rhs,\n+        Class<?> clazz,\n+        CompareToBuilder builder,\n+        boolean useTransients,\n+        String[] excludeFields) {\n+        \n+        Field[] fields = clazz.getDeclaredFields();\n+        List<String> excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.<String>emptyList();\n+        AccessibleObject.setAccessible(fields, true);\n+        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n+            Field f = fields[i];\n+            if (!excludedFieldList.contains(f.getName())\n+                && (f.getName().indexOf('$') == -1)\n+                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n+                && (!Modifier.isStatic(f.getModifiers()))) {\n+                try {\n+                    builder.append(f.get(lhs), f.get(rhs));\n+                } catch (IllegalAccessException e) {\n+                    // This can't happen. Would get a Security exception instead.\n+                    // Throw a runtime exception in case the impossible happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException\");\n+                }\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Appends to the <code>builder</code> the <code>compareTo(Object)</code>\n+     * result of the superclass.</p>\n+     *\n+     * @param superCompareTo  result of calling <code>super.compareTo(Object)</code>\n+     * @return this - used to chain append calls\n+     * @since 2.0\n+     */\n+    public CompareToBuilder appendSuper(int superCompareTo) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = superCompareTo;\n+        return this;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Appends to the <code>builder</code> the comparison of\n+     * two <code>Object</code>s.</p>\n+     *\n+     * <ol>\n+     * <li>Check if <code>lhs == rhs</code></li>\n+     * <li>Check if either <code>lhs</code> or <code>rhs</code> is <code>null</code>,\n+     *     a <code>null</code> object is less than a non-<code>null</code> object</li>\n+     * <li>Check the object contents</li>\n+     * </ol>\n+     * \n+     * <p><code>lhs</code> must either be an array or implement {@link Comparable}.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @return this - used to chain append calls\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     */\n+    public CompareToBuilder append(Object lhs, Object rhs) {\n+        return append(lhs, rhs, null);\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the comparison of\n+     * two <code>Object</code>s.</p>\n+     *\n+     * <ol>\n+     * <li>Check if <code>lhs == rhs</code></li>\n+     * <li>Check if either <code>lhs</code> or <code>rhs</code> is <code>null</code>,\n+     *     a <code>null</code> object is less than a non-<code>null</code> object</li>\n+     * <li>Check the object contents</li>\n+     * </ol>\n+     *\n+     * <p>If <code>lhs</code> is an array, array comparison methods will be used.\n+     * Otherwise <code>comparator</code> will be used to compare the objects.\n+     * If <code>comparator</code> is <code>null</code>, <code>lhs</code> must\n+     * implement {@link Comparable} instead.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param comparator  <code>Comparator</code> used to compare the objects,\n+     *  <code>null</code> means treat lhs as <code>Comparable</code>\n+     * @return this - used to chain append calls\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     * @since 2.0\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public CompareToBuilder append(Object lhs, Object rhs, Comparator<?> comparator) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.getClass().isArray()) {\n+            // switch on type of array, to dispatch to the correct handler\n+            // handles multi dimensional arrays\n+            // throws a ClassCastException if rhs is not the correct array type\n+            if (lhs instanceof long[]) {\n+                append((long[]) lhs, (long[]) rhs);\n+            } else if (lhs instanceof int[]) {\n+                append((int[]) lhs, (int[]) rhs);\n+            } else if (lhs instanceof short[]) {\n+                append((short[]) lhs, (short[]) rhs);\n+            } else if (lhs instanceof char[]) {\n+                append((char[]) lhs, (char[]) rhs);\n+            } else if (lhs instanceof byte[]) {\n+                append((byte[]) lhs, (byte[]) rhs);\n+            } else if (lhs instanceof double[]) {\n+                append((double[]) lhs, (double[]) rhs);\n+            } else if (lhs instanceof float[]) {\n+                append((float[]) lhs, (float[]) rhs);\n+            } else if (lhs instanceof boolean[]) {\n+                append((boolean[]) lhs, (boolean[]) rhs);\n+            } else {\n+                // not an array of primitives\n+                // throws a ClassCastException if rhs is not an array\n+                append((Object[]) lhs, (Object[]) rhs, comparator);\n+            }\n+        } else {\n+            // the simple case, not an array, just test the element\n+            if (comparator == null) {\n+                comparison = ((Comparable) lhs).compareTo(rhs);\n+            } else {\n+                comparison = ((Comparator) comparator).compare(lhs, rhs);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Appends to the <code>builder</code> the comparison of\n+     * two <code>long</code>s.\n+     *\n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(long lhs, long rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n+        return this;\n+    }\n+\n+    /**\n+     * Appends to the <code>builder</code> the comparison of\n+     * two <code>int</code>s.\n+     *\n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(int lhs, int rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n+        return this;\n+    }\n+\n+    /**\n+     * Appends to the <code>builder</code> the comparison of\n+     * two <code>short</code>s.\n+     * \n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(short lhs, short rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n+        return this;\n+    }\n+\n+    /**\n+     * Appends to the <code>builder</code> the comparison of\n+     * two <code>char</code>s.\n+     *\n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(char lhs, char rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n+        return this;\n+    }\n+\n+    /**\n+     * Appends to the <code>builder</code> the comparison of\n+     * two <code>byte</code>s.\n+     * \n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(byte lhs, byte rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the comparison of\n+     * two <code>double</code>s.</p>\n+     *\n+     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\n+     *\n+     * <p>It is compatible with the hash code generated by\n+     * <code>HashCodeBuilder</code>.</p>\n+     *\n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(double lhs, double rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = Double.compare(lhs, rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the comparison of\n+     * two <code>float</code>s.</p>\n+     *\n+     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\n+     *\n+     * <p>It is compatible with the hash code generated by\n+     * <code>HashCodeBuilder</code>.</p>\n+     *\n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(float lhs, float rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = Float.compare(lhs, rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * Appends to the <code>builder</code> the comparison of\n+     * two <code>booleans</code>s.\n+     *\n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+      */\n+    public CompareToBuilder append(boolean lhs, boolean rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == false) {\n+            comparison = -1;\n+        } else {\n+            comparison = +1;\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>Object</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a short length array is less than a long length array</li>\n+     *  <li>Check array contents element by element using {@link #append(Object, Object, Comparator)}</li>\n+     * </ol>\n+     *\n+     * <p>This method will also will be called for the top level of multi-dimensional,\n+     * ragged, and multi-typed arrays.</p>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     */\n+    public CompareToBuilder append(Object[] lhs, Object[] rhs) {\n+        return append(lhs, rhs, null);\n+    }\n+    \n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>Object</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a short length array is less than a long length array</li>\n+     *  <li>Check array contents element by element using {@link #append(Object, Object, Comparator)}</li>\n+     * </ol>\n+     *\n+     * <p>This method will also will be called for the top level of multi-dimensional,\n+     * ragged, and multi-typed arrays.</p>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @param comparator  <code>Comparator</code> to use to compare the array elements,\n+     *  <code>null</code> means to treat <code>lhs</code> elements as <code>Comparable</code>.\n+     * @return this - used to chain append calls\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     * @since 2.0\n+     */\n+    public CompareToBuilder append(Object[] lhs, Object[] rhs, Comparator<?> comparator) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i], comparator);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>long</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(long, long)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(long[] lhs, long[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>int</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(int, int)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(int[] lhs, int[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>short</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(short, short)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(short[] lhs, short[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>char</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(char, char)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(char[] lhs, char[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>byte</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(byte, byte)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(byte[] lhs, byte[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>double</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(double, double)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(double[] lhs, double[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>float</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(float, float)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(float[] lhs, float[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>boolean</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(boolean, boolean)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(boolean[] lhs, boolean[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a negative integer, a positive integer, or zero as\n+     * the <code>builder</code> has judged the \"left-hand\" side\n+     * as less than, greater than, or equal to the \"right-hand\"\n+     * side.\n+     * \n+     * @return final comparison result\n+     */\n+    public int toComparison() {\n+        return comparison;\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/builder/EqualsBuilder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * <p>Assists in implementing {@link Object#equals(Object)} methods.</p>\n+ *\n+ * <p> This class provides methods to build a good equals method for any\n+ * class. It follows rules laid out in\n+ * <a href=\"http://java.sun.com/docs/books/effective/index.html\">Effective Java</a>\n+ * , by Joshua Bloch. In particular the rule for comparing <code>doubles</code>,\n+ * <code>floats</code>, and arrays can be tricky. Also, making sure that\n+ * <code>equals()</code> and <code>hashCode()</code> are consistent can be\n+ * difficult.</p>\n+ *\n+ * <p>Two Objects that compare as equals must generate the same hash code,\n+ * but two Objects with the same hash code do not have to be equal.</p>\n+ *\n+ * <p>All relevant fields should be included in the calculation of equals.\n+ * Derived fields may be ignored. In particular, any field used in\n+ * generating a hash code must be used in the equals method, and vice\n+ * versa.</p>\n+ *\n+ * <p>Typical use for the code is as follows:</p>\n+ * <pre>\n+ * public boolean equals(Object obj) {\n+ *   if (obj == null) { return false; }\n+ *   if (obj == this) { return true; }\n+ *   if (obj.getClass() != getClass()) {\n+ *     return false;\n+ *   }\n+ *   MyClass rhs = (MyClass) obj;\n+ *   return new EqualsBuilder()\n+ *                 .appendSuper(super.equals(obj))\n+ *                 .append(field1, rhs.field1)\n+ *                 .append(field2, rhs.field2)\n+ *                 .append(field3, rhs.field3)\n+ *                 .isEquals();\n+ *  }\n+ * </pre>\n+ *\n+ * <p> Alternatively, there is a method that uses reflection to determine\n+ * the fields to test. Because these fields are usually private, the method,\n+ * <code>reflectionEquals</code>, uses <code>AccessibleObject.setAccessible</code> to\n+ * change the visibility of the fields. This will fail under a security\n+ * manager, unless the appropriate permissions are set up correctly. It is\n+ * also slower than testing explicitly.</p>\n+ *\n+ * <p> A typical invocation for this method would look like:</p>\n+ * <pre>\n+ * public boolean equals(Object obj) {\n+ *   return EqualsBuilder.reflectionEquals(this, obj);\n+ * }\n+ * </pre>\n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:steve.downey@netfolio.com\">Steve Downey</a>\n+ * @author Gary Gregory\n+ * @author Pete Gieser\n+ * @author Arun Mammen Thomas\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class EqualsBuilder {\n+    \n+    /**\n+     * If the fields tested are equals.\n+     * The default value is <code>true</code>.\n+     */\n+    private boolean isEquals = true;\n+\n+    /**\n+     * <p>Constructor for EqualsBuilder.</p>\n+     *\n+     * <p>Starts off assuming that equals is <code>true</code>.</p>\n+     * @see Object#equals(Object)\n+     */\n+    public EqualsBuilder() {\n+        // do nothing for now.\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be tested, as they are likely derived\n+     * fields, and not part of the value of the Object.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs) {\n+        return reflectionEquals(lhs, rhs, false, null, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be tested, as they are likely derived\n+     * fields, and not part of the value of the Object.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param excludeFields  Collection of String field names to exclude from testing\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, Collection<String> excludeFields) {\n+        return reflectionEquals(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be tested, as they are likely derived\n+     * fields, and not part of the value of the Object.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param excludeFields  array of field names to exclude from testing\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, String[] excludeFields) {\n+        return reflectionEquals(lhs, rhs, false, null, excludeFields);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the TestTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param testTransients  whether to include transient fields\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {\n+        return reflectionEquals(lhs, rhs, testTransients, null, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the testTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be included. Superclass fields will be appended\n+     * up to and including the specified superclass. A null superclass is treated\n+     * as java.lang.Object.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param testTransients  whether to include transient fields\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n+     *  may be <code>null</code>\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     * @since 2.0\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass) {\n+        return reflectionEquals(lhs, rhs, testTransients, reflectUpToClass, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the testTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be included. Superclass fields will be appended\n+     * up to and including the specified superclass. A null superclass is treated\n+     * as java.lang.Object.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param testTransients  whether to include transient fields\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n+     *  may be <code>null</code>\n+     * @param excludeFields  array of field names to exclude from testing\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     * @since 2.0\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass,\n+            String[] excludeFields) {\n+        if (lhs == rhs) {\n+            return true;\n+        }\n+        if (lhs == null || rhs == null) {\n+            return false;\n+        }\n+        // Find the leaf class since there may be transients in the leaf \n+        // class or in classes between the leaf and root.\n+        // If we are not testing transients or a subclass has no ivars, \n+        // then a subclass can test equals to a superclass.\n+        Class<?> lhsClass = lhs.getClass();\n+        Class<?> rhsClass = rhs.getClass();\n+        Class<?> testClass;\n+        if (lhsClass.isInstance(rhs)) {\n+            testClass = lhsClass;\n+            if (!rhsClass.isInstance(lhs)) {\n+                // rhsClass is a subclass of lhsClass\n+                testClass = rhsClass;\n+            }\n+        } else if (rhsClass.isInstance(lhs)) {\n+            testClass = rhsClass;\n+            if (!lhsClass.isInstance(rhs)) {\n+                // lhsClass is a subclass of rhsClass\n+                testClass = lhsClass;\n+            }\n+        } else {\n+            // The two classes are not related.\n+            return false;\n+        }\n+        EqualsBuilder equalsBuilder = new EqualsBuilder();\n+        try {\n+            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\n+            while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\n+                testClass = testClass.getSuperclass();\n+                reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            // In this case, we tried to test a subclass vs. a superclass and\n+            // the subclass has ivars or the ivars are transient and \n+            // we are testing transients.\n+            // If a subclass has ivars that we are trying to test them, we get an\n+            // exception and we know that the objects are not equal.\n+            return false;\n+        }\n+        return equalsBuilder.isEquals();\n+    }\n+\n+    /**\n+     * <p>Appends the fields and values defined by the given object of the\n+     * given Class.</p>\n+     * \n+     * @param lhs  the left hand object\n+     * @param rhs  the right hand object\n+     * @param clazz  the class to append details of\n+     * @param builder  the builder to append to\n+     * @param useTransients  whether to test transient fields\n+     * @param excludeFields  array of field names to exclude from testing\n+     */\n+    private static void reflectionAppend(\n+        Object lhs,\n+        Object rhs,\n+        Class<?> clazz,\n+        EqualsBuilder builder,\n+        boolean useTransients,\n+        String[] excludeFields) {\n+        Field[] fields = clazz.getDeclaredFields();\n+        List<String> excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.<String>emptyList();\n+        AccessibleObject.setAccessible(fields, true);\n+        for (int i = 0; i < fields.length && builder.isEquals; i++) {\n+            Field f = fields[i];\n+            if (!excludedFieldList.contains(f.getName())\n+                && (f.getName().indexOf('$') == -1)\n+                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n+                && (!Modifier.isStatic(f.getModifiers()))) {\n+                try {\n+                    builder.append(f.get(lhs), f.get(rhs));\n+                } catch (IllegalAccessException e) {\n+                    //this can't happen. Would get a Security exception instead\n+                    //throw a runtime exception in case the impossible happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException\");\n+                }\n+            }\n+        }\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Adds the result of <code>super.equals()</code> to this builder.</p>\n+     *\n+     * @param superEquals  the result of calling <code>super.equals()</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     * @since 2.0\n+     */\n+    public EqualsBuilder appendSuper(boolean superEquals) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = superEquals;\n+        return this;\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Test if two <code>Object</code>s are equal using their\n+     * <code>equals</code> method.</p>\n+     *\n+     * @param lhs  the left hand object\n+     * @param rhs  the right hand object\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(Object lhs, Object rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        Class<?> lhsClass = lhs.getClass();\n+        if (!lhsClass.isArray()) {\n+            // The simple case, not an array, just test the element\n+            isEquals = lhs.equals(rhs);\n+        } else if (lhs.getClass() != rhs.getClass()) {\n+            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] \n+            this.setEquals(false);\n+        }\n+        // 'Switch' on type of array, to dispatch to the correct handler\n+        // This handles multi dimensional arrays of the same depth\n+        else if (lhs instanceof long[]) {\n+            append((long[]) lhs, (long[]) rhs);\n+        } else if (lhs instanceof int[]) {\n+            append((int[]) lhs, (int[]) rhs);\n+        } else if (lhs instanceof short[]) {\n+            append((short[]) lhs, (short[]) rhs);\n+        } else if (lhs instanceof char[]) {\n+            append((char[]) lhs, (char[]) rhs);\n+        } else if (lhs instanceof byte[]) {\n+            append((byte[]) lhs, (byte[]) rhs);\n+        } else if (lhs instanceof double[]) {\n+            append((double[]) lhs, (double[]) rhs);\n+        } else if (lhs instanceof float[]) {\n+            append((float[]) lhs, (float[]) rhs);\n+        } else if (lhs instanceof boolean[]) {\n+            append((boolean[]) lhs, (boolean[]) rhs);\n+        } else {\n+            // Not an array of primitives\n+            append((Object[]) lhs, (Object[]) rhs);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Test if two <code>long</code> s are equal.\n+     * </p>\n+     * \n+     * @param lhs\n+     *                  the left hand <code>long</code>\n+     * @param rhs\n+     *                  the right hand <code>long</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(long lhs, long rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>int</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>int</code>\n+     * @param rhs  the right hand <code>int</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(int lhs, int rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>short</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>short</code>\n+     * @param rhs  the right hand <code>short</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(short lhs, short rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>char</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>char</code>\n+     * @param rhs  the right hand <code>char</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(char lhs, char rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>byte</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>byte</code>\n+     * @param rhs  the right hand <code>byte</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(byte lhs, byte rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>double</code>s are equal by testing that the\n+     * pattern of bits returned by <code>doubleToLong</code> are equal.</p>\n+     *\n+     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\n+     *\n+     * <p>It is compatible with the hash code generated by\n+     * <code>HashCodeBuilder</code>.</p>\n+     *\n+     * @param lhs  the left hand <code>double</code>\n+     * @param rhs  the right hand <code>double</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(double lhs, double rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        return append(Double.doubleToLongBits(lhs), Double.doubleToLongBits(rhs));\n+    }\n+\n+    /**\n+     * <p>Test if two <code>float</code>s are equal byt testing that the\n+     * pattern of bits returned by doubleToLong are equal.</p>\n+     *\n+     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\n+     *\n+     * <p>It is compatible with the hash code generated by\n+     * <code>HashCodeBuilder</code>.</p>\n+     *\n+     * @param lhs  the left hand <code>float</code>\n+     * @param rhs  the right hand <code>float</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(float lhs, float rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        return append(Float.floatToIntBits(lhs), Float.floatToIntBits(rhs));\n+    }\n+\n+    /**\n+     * <p>Test if two <code>booleans</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>boolean</code>\n+     * @param rhs  the right hand <code>boolean</code>\n+     * @return EqualsBuilder - used to chain calls.\n+      */\n+    public EqualsBuilder append(boolean lhs, boolean rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Performs a deep comparison of two <code>Object</code> arrays.</p>\n+     *\n+     * <p>This also will be called for the top level of\n+     * multi-dimensional, ragged, and multi-typed arrays.</p>\n+     *\n+     * @param lhs  the left hand <code>Object[]</code>\n+     * @param rhs  the right hand <code>Object[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(Object[] lhs, Object[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>long</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(long, long)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>long[]</code>\n+     * @param rhs  the right hand <code>long[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(long[] lhs, long[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>int</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(int, int)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>int[]</code>\n+     * @param rhs  the right hand <code>int[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(int[] lhs, int[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>short</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(short, short)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>short[]</code>\n+     * @param rhs  the right hand <code>short[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(short[] lhs, short[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>char</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(char, char)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>char[]</code>\n+     * @param rhs  the right hand <code>char[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(char[] lhs, char[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>byte</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(byte, byte)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>byte[]</code>\n+     * @param rhs  the right hand <code>byte[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(byte[] lhs, byte[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>double</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(double, double)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>double[]</code>\n+     * @param rhs  the right hand <code>double[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(double[] lhs, double[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>float</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(float, float)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>float[]</code>\n+     * @param rhs  the right hand <code>float[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(float[] lhs, float[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>boolean</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(boolean, boolean)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>boolean[]</code>\n+     * @param rhs  the right hand <code>boolean[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(boolean[] lhs, boolean[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Returns <code>true</code> if the fields that have been checked\n+     * are all equal.</p>\n+     *\n+     * @return boolean\n+     */\n+    public boolean isEquals() {\n+        return this.isEquals;\n+    }\n+\n+    /**\n+     * Sets the <code>isEquals</code> value.\n+     * \n+     * @param isEquals The value to set.\n+     * @since 2.1\n+     */\n+    protected void setEquals(boolean isEquals) {\n+        this.isEquals = isEquals;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/builder/HashCodeBuilder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * <p>\n+ * Assists in implementing {@link Object#hashCode()} methods.\n+ * </p>\n+ * \n+ * <p>\n+ * This class enables a good <code>hashCode</code> method to be built for any class. It follows the rules laid out in\n+ * the book <a href=\"http://java.sun.com/docs/books/effective/index.html\">Effective Java</a> by Joshua Bloch. Writing a\n+ * good <code>hashCode</code> method is actually quite difficult. This class aims to simplify the process.\n+ * </p>\n+ * \n+ * <p>\n+ * All relevant fields from the object should be included in the <code>hashCode</code> method. Derived fields may be\n+ * excluded. In general, any field used in the <code>equals</code> method must be used in the <code>hashCode</code>\n+ * method.\n+ * </p>\n+ * \n+ * <p>\n+ * To use this class write code as follows:\n+ * </p>\n+ * \n+ * <pre>\n+ * public class Person {\n+ *   String name;\n+ *   int age;\n+ *   boolean smoker;\n+ *   ...\n+ *\n+ *   public int hashCode() {\n+ *     // you pick a hard-coded, randomly chosen, non-zero, odd number\n+ *     // ideally different for each class\n+ *     return new HashCodeBuilder(17, 37).\n+ *       append(name).\n+ *       append(age).\n+ *       append(smoker).\n+ *       toHashCode();\n+ *   }\n+ * }\n+ * </pre>\n+ * \n+ * <p>\n+ * If required, the superclass <code>hashCode()</code> can be added using {@link #appendSuper}.\n+ * </p>\n+ * \n+ * <p>\n+ * Alternatively, there is a method that uses reflection to determine the fields to test. Because these fields are\n+ * usually private, the method, <code>reflectionHashCode</code>, uses <code>AccessibleObject.setAccessible</code>\n+ * to change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions\n+ * are set up correctly. It is also slower than testing explicitly.\n+ * </p>\n+ * \n+ * <p>\n+ * A typical invocation for this method would look like:\n+ * </p>\n+ * \n+ * <pre>\n+ * public int hashCode() {\n+ *   return HashCodeBuilder.reflectionHashCode(this);\n+ * }\n+ * </pre>\n+ * \n+ * @author Apache Software Foundation\n+ * @author Gary Gregory\n+ * @author Pete Gieser\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class HashCodeBuilder {\n+    /**\n+     * <p>\n+     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\n+     * </p>\n+     * \n+     * @since 2.3\n+     */\n+    private static final ThreadLocal<Set<IDKey>> registry = new ThreadLocal<Set<IDKey>>() {\n+        @Override\n+        protected Set<IDKey> initialValue() {\n+            // The HashSet implementation is not synchronized,\n+            // which is just what we need here.\n+            return new HashSet<IDKey>();\n+        }\n+    };\n+\n+    /*\n+     * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()\n+     * we are in the process of calculating.\n+     * \n+     * So we generate a one-to-one mapping from the original object to a new object.\n+     * \n+     * Now HashSet uses equals() to determine if two elements with the same hashcode really\n+     * are equal, so we also need to ensure that the replacement objects are only equal\n+     * if the original objects are identical.\n+     * \n+     * The original implementation (2.4 and before) used the System.indentityHashCode()\n+     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\n+     *  \n+     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\n+     * to disambiguate the duplicate ids.\n+     */\n+    \n+    /**\n+     * <p>\n+     * Returns the registry of objects being traversed by the reflection methods in the current thread.\n+     * </p>\n+     * \n+     * @return Set the registry of objects being traversed\n+     * @since 2.3\n+     */\n+    static Set<IDKey> getRegistry() {\n+        return registry.get();\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\n+     * infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *            The object to lookup in the registry.\n+     * @return boolean <code>true</code> if the registry contains the given object.\n+     * @since 2.3\n+     */\n+    static boolean isRegistered(Object value) {\n+        return getRegistry().contains(new IDKey(value));\n+    }\n+\n+    /**\n+     * <p>\n+     * Appends the fields and values defined by the given object of the given <code>Class</code>.\n+     * </p>\n+     * \n+     * @param object\n+     *            the object to append details of\n+     * @param clazz\n+     *            the class to append details of\n+     * @param builder\n+     *            the builder to append to\n+     * @param useTransients\n+     *            whether to use transient fields\n+     * @param excludeFields\n+     *            Collection of String field names to exclude from use in calculation of hash code\n+     */\n+    private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\n+            String[] excludeFields) {\n+        if (isRegistered(object)) {\n+            return;\n+        }\n+        try {\n+            register(object);\n+            Field[] fields = clazz.getDeclaredFields();\n+            List<String> excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.<String>emptyList();\n+            AccessibleObject.setAccessible(fields, true);\n+            for (Field field : fields) {\n+                if (!excludedFieldList.contains(field.getName())\n+                    && (field.getName().indexOf('$') == -1)\n+                    && (useTransients || !Modifier.isTransient(field.getModifiers()))\n+                    && (!Modifier.isStatic(field.getModifiers()))) {\n+                    try {\n+                        Object fieldValue = field.get(object);\n+                        builder.append(fieldValue);\n+                    } catch (IllegalAccessException e) {\n+                        // this can't happen. Would get a Security exception instead\n+                        // throw a runtime exception in case the impossible happens.\n+                        throw new InternalError(\"Unexpected IllegalAccessException\");\n+                    }\n+                }\n+            }\n+        } finally {\n+            unregister(object);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n+     * <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     * \n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n+     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n+     * </p>\n+     * \n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the number is zero or even\n+     */\n+    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     * \n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n+     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n+     * </p>\n+     * \n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param testTransients\n+     *            whether to include transient fields\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the number is zero or even\n+     */\n+    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\n+            boolean testTransients) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null,\n+                null);\n+    }\n+\n+    /**\n+     * Calls {@link #reflectionHashCode(int, int, Object, boolean, Class, String[])} with excludeFields set to\n+     * <code>null</code>.\n+     * \n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param testTransients\n+     *            whether to include transient fields\n+     * @param reflectUpToClass\n+     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @return int hash code\n+     */\n+    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\n+            boolean testTransients, Class<? super T> reflectUpToClass) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients,\n+                reflectUpToClass, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be included. Superclass fields will be included up to and including the specified\n+     * superclass. A null superclass is treated as java.lang.Object.\n+     * </p>\n+     * \n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n+     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n+     * </p>\n+     * \n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param testTransients\n+     *            whether to include transient fields\n+     * @param reflectUpToClass\n+     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @param excludeFields\n+     *            array of field names to exclude from use in calculation of hash code\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the number is zero or even\n+     * @since 2.0\n+     */\n+    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\n+            boolean testTransients, Class<? super T> reflectUpToClass, String[] excludeFields) {\n+\n+        if (object == null) {\n+            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n+        }\n+        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n+        Class<?> clazz = object.getClass();\n+        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n+        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n+            clazz = clazz.getSuperclass();\n+            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n+        }\n+        return builder.toHashCode();\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n+     * <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object) {\n+        return reflectionHashCode(17, 37, object, false, null, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <P>\n+     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param testTransients\n+     *            whether to include transient fields\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object, boolean testTransients) {\n+        return reflectionHashCode(17, 37, object, testTransients, null, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n+     * <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param excludeFields\n+     *            Collection of String field names to exclude from use in calculation of hash code\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object, Collection<String> excludeFields) {\n+        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n+    }\n+\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n+     * <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param excludeFields\n+     *            array of field names to exclude from use in calculation of hash code\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object, String[] excludeFields) {\n+        return reflectionHashCode(17, 37, object, false, null, excludeFields);\n+    }\n+\n+    /**\n+     * <p>\n+     * Registers the given object. Used by the reflection methods to avoid infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *            The object to register.\n+     */\n+    static void register(Object value) {\n+        getRegistry().add(new IDKey(value));\n+    }\n+\n+    /**\n+     * <p>\n+     * Unregisters the given object.\n+     * </p>\n+     * \n+     * <p>\n+     * Used by the reflection methods to avoid infinite loops.\n+     * \n+     * @param value\n+     *            The object to unregister.\n+     * @since 2.3\n+     */\n+    static void unregister(Object value) {\n+        getRegistry().remove(new IDKey(value));\n+    }\n+\n+    /**\n+     * Constant to use in building the hashCode.\n+     */\n+    private final int iConstant;\n+\n+    /**\n+     * Running total of the hashCode.\n+     */\n+    private int iTotal = 0;\n+\n+    /**\n+     * <p>\n+     * Uses two hard coded choices for the constants needed to build a <code>hashCode</code>.\n+     * </p>\n+     */\n+    public HashCodeBuilder() {\n+        iConstant = 37;\n+        iTotal = 17;\n+    }\n+\n+    /**\n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n+     * however this is not vital.\n+     * </p>\n+     * \n+     * <p>\n+     * Prime numbers are preferred, especially for the multiplier.\n+     * </p>\n+     * \n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @throws IllegalArgumentException\n+     *             if the number is zero or even\n+     */\n+    public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\n+        if (initialNonZeroOddNumber == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\n+        }\n+        if (initialNonZeroOddNumber % 2 == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\n+        }\n+        if (multiplierNonZeroOddNumber == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\n+        }\n+        if (multiplierNonZeroOddNumber % 2 == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\n+        }\n+        iConstant = multiplierNonZeroOddNumber;\n+        iTotal = initialNonZeroOddNumber;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>boolean</code>.\n+     * </p>\n+     * <p>\n+     * This adds <code>iConstant * 1</code> to the <code>hashCode</code> and not a <code>1231</code> or\n+     * <code>1237</code> as done in java.lang.Boolean. This is in accordance with the <quote>Effective Java</quote>\n+     * design.\n+     * </p>\n+     * \n+     * @param value\n+     *            the boolean to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(boolean value) {\n+        iTotal = iTotal * iConstant + (value ? 0 : 1);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>boolean</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(boolean[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>byte</code>.\n+     * </p>\n+     * \n+     * @param value\n+     *            the byte to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(byte value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>byte</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(byte[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>char</code>.\n+     * </p>\n+     * \n+     * @param value\n+     *            the char to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(char value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>char</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(char[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>double</code>.\n+     * </p>\n+     * \n+     * @param value\n+     *            the double to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(double value) {\n+        return append(Double.doubleToLongBits(value));\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>double</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(double[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>float</code>.\n+     * </p>\n+     * \n+     * @param value\n+     *            the float to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(float value) {\n+        iTotal = iTotal * iConstant + Float.floatToIntBits(value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>float</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(float[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for an <code>int</code>.\n+     * </p>\n+     * \n+     * @param value\n+     *            the int to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(int value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for an <code>int</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(int[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>long</code>.\n+     * </p>\n+     * <p>\n+     * \n+     * @param value\n+     *            the long to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    // NOTE: This method uses >> and not >>> as Effective Java and \n+    //       Long.hashCode do. Ideally we should switch to >>> at \n+    //       some stage. There are backwards compat issues, so \n+    //       that will have to wait for the time being. cf LANG-342.\n+    public HashCodeBuilder append(long value) {\n+        iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>long</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(long[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for an <code>Object</code>.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(Object object) {\n+        if (object == null) {\n+            iTotal = iTotal * iConstant;\n+\n+        } else {\n+                // 'Switch' on type of array, to dispatch to the correct handler\n+                // This handles multi dimensional arrays\n+                if (object instanceof long[]) {\n+                    append((long[]) object);\n+                } else if (object instanceof int[]) {\n+                    append((int[]) object);\n+                } else if (object instanceof short[]) {\n+                    append((short[]) object);\n+                } else if (object instanceof char[]) {\n+                    append((char[]) object);\n+                } else if (object instanceof byte[]) {\n+                    append((byte[]) object);\n+                } else if (object instanceof double[]) {\n+                    append((double[]) object);\n+                } else if (object instanceof float[]) {\n+                    append((float[]) object);\n+                } else if (object instanceof boolean[]) {\n+                    append((boolean[]) object);\n+                } else if (object instanceof Object[]) {\n+                    // Not an array of primitives\n+                    append((Object[]) object);\n+                } else {\n+                    iTotal = iTotal * iConstant + object.hashCode();\n+                }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for an <code>Object</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(Object[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>short</code>.\n+     * </p>\n+     * \n+     * @param value\n+     *            the short to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(short value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>short</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(short[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Adds the result of super.hashCode() to this builder.\n+     * </p>\n+     * \n+     * @param superHashCode\n+     *            the result of calling <code>super.hashCode()</code>\n+     * @return this HashCodeBuilder, used to chain calls.\n+     * @since 2.0\n+     */\n+    public HashCodeBuilder appendSuper(int superHashCode) {\n+        iTotal = iTotal * iConstant + superHashCode;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Return the computed <code>hashCode</code>.\n+     * </p>\n+     * \n+     * @return <code>hashCode</code> based on the fields appended\n+     */\n+    public int toHashCode() {\n+        return iTotal;\n+    }\n+\n+    /**\n+     * <p>\n+     * The computed <code>hashCode</code> from toHashCode() is returned due to the likelyhood \n+     * of bugs in mis-calling toHashCode() and the unlikelyness of it mattering what the hashCode for \n+     * HashCodeBuilder itself is.\n+     * \n+     * @return <code>hashCode</code> based on the fields appended\n+     */\n+    @Override\n+    public int hashCode() {\n+        return toHashCode();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/builder/IDKey.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \n+ */\n+\n+package org.apache.commons.lang.builder;\n+\n+// adapted from org.apache.axis.utils.IDKey\n+\n+/**\n+ * Wrap an identity key (System.identityHashCode()) \n+ * so that an object can only be equal() to itself.\n+ * \n+ * This is necessary to disambiguate the occasional duplicate\n+ * identityHashCodes that can occur.\n+ * \n+ * @author Apache Software Foundation\n+ */ \n+final class IDKey {\n+        private final Object value;\n+        private final int id;\n+\n+        /**\n+         * Constructor for IDKey\n+         * @param _value\n+         */ \n+        public IDKey(Object _value) {\n+            // This is the Object hashcode \n+            id = System.identityHashCode(_value);  \n+            // There have been some cases (LANG-459) that return the \n+            // same identity hash code for different objects.  So \n+            // the value is also added to disambiguate these cases.\n+            value = _value;\n+        }\n+\n+        /**\n+         * returns hashcode - i.e. the system identity hashcode.\n+         * @return the hashcode\n+         */ \n+        @Override\n+        public int hashCode() {\n+           return id;\n+        }\n+\n+        /**\n+         * checks if instances are equal\n+         * @param other\n+         * @return if the instances are for the same object\n+         */ \n+        @Override\n+        public boolean equals(Object other) {\n+            if (!(other instanceof IDKey)) {\n+                return false;\n+            }\n+            IDKey idKey = (IDKey) other;\n+            if (id != idKey.id) {\n+                return false;\n+            }\n+            // Note that identity equals is used.\n+            return value == idKey.value;\n+         }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.ClassUtils;\n+\n+/**\n+ * <p>\n+ * Assists in implementing {@link Object#toString()} methods using reflection.\n+ * </p>\n+ * \n+ * <p>\n+ * This class uses reflection to determine the fields to append. Because these fields are usually private, the class\n+ * uses {@link java.lang.reflect.AccessibleObject#setAccessible(java.lang.reflect.AccessibleObject[], boolean)} to\n+ * change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions are\n+ * set up correctly.\n+ * </p>\n+ * \n+ * <p>\n+ * A typical invocation for this method would look like:\n+ * </p>\n+ * \n+ * <pre>\n+ * public String toString() {\n+ *   return ReflectionToStringBuilder.toString(this);\n+ * }</pre>\n+ * \n+ * \n+ * \n+ * <p>\n+ * You can also use the builder to debug 3rd party objects:\n+ * </p>\n+ * \n+ * <pre>\n+ * System.out.println(\"An object: \" + ReflectionToStringBuilder.toString(anObject));</pre>\n+ * \n+ * \n+ * \n+ * <p>\n+ * A subclass can control field output by overriding the methods:\n+ * <ul>\n+ * <li>{@link #accept(java.lang.reflect.Field)}</li>\n+ * <li>{@link #getValue(java.lang.reflect.Field)}</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * For example, this method does <i>not</i> include the <code>password</code> field in the returned\n+ * <code>String</code>:\n+ * </p>\n+ * \n+ * <pre>\n+ * public String toString() {\n+ *     return (new ReflectionToStringBuilder(this) {\n+ *         protected boolean accept(Field f) {\n+ *             return super.accept(f) && !f.getName().equals(\"password\");\n+ *         }\n+ *     }).toString();\n+ * }</pre>\n+ * \n+ * \n+ * \n+ * <p>\n+ * The exact format of the <code>toString</code> is determined by the {@link ToStringStyle} passed into the\n+ * constructor.\n+ * </p>\n+ * \n+ * @author Apache Software Foundation\n+ * @author Gary Gregory\n+ * @author Pete Gieser\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class ReflectionToStringBuilder extends ToStringBuilder {\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n+     * Superclass fields will be appended.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to be output\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     */\n+    public static String toString(Object object) {\n+        return toString(object, null, false, false, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n+     * Superclass fields will be appended.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object or <code>ToStringStyle</code> is <code>null</code>\n+     */\n+    public static String toString(Object object, ToStringStyle style) {\n+        return toString(object, style, false, false, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputTransients</code> is <code>true</code>, transient members will be output, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be included. Superclass fields will be appended.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     */\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\n+        return toString(object, style, outputTransients, false, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n+     * ignored.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be included. Superclass fields will be appended.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @param outputStatics\n+     *            whether to include transient fields\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\n+        return toString(object, style, outputTransients, outputStatics, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n+     * ignored.\n+     * </p>\n+     * \n+     * <p>\n+     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n+     * <code>java.lang.Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @param outputStatics\n+     *            whether to include static fields\n+     * @param reflectUpToClass\n+     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static <T> String toString(\n+            T object, ToStringStyle style, boolean outputTransients,\n+            boolean outputStatics, Class<? super T> reflectUpToClass) {\n+        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n+                .toString();\n+    }\n+\n+    /**\n+     * Builds a String for a toString method excluding the given field name.\n+     * \n+     * @param object\n+     *            The object to \"toString\".\n+     * @param excludeFieldName\n+     *            The field name to exclude\n+     * @return The toString value.\n+     */\n+    public static String toStringExclude(Object object, final String excludeFieldName) {\n+        return toStringExclude(object, new String[]{excludeFieldName});\n+    }\n+\n+    /**\n+     * Builds a String for a toString method excluding the given field names.\n+     * \n+     * @param object\n+     *            The object to \"toString\".\n+     * @param excludeFieldNames\n+     *            The field names to exclude. Null excludes nothing.\n+     * @return The toString value.\n+     */\n+    public static String toStringExclude(Object object, Collection<String> excludeFieldNames) {\n+        return toStringExclude(object, toNoNullStringArray(excludeFieldNames));\n+    }\n+\n+    /**\n+     * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code>\n+     * entries. Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element \n+     * is <code>null</code>.\n+     * \n+     * @param collection\n+     *            The collection to convert\n+     * @return A new array of Strings.\n+     */\n+    static String[] toNoNullStringArray(Collection<String> collection) {\n+        if (collection == null) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        return toNoNullStringArray(collection.toArray());\n+    }\n+\n+    /**\n+     * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists\n+     * (arrays and collections). Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} \n+     * if an array element is <code>null</code>.\n+     * \n+     * @param array\n+     *            The array to check\n+     * @return The given array or a new array without null.\n+     */\n+    static String[] toNoNullStringArray(Object[] array) {\n+        List<String> list = new ArrayList<String>(array.length);\n+        for (Object e : array) {\n+            if (e != null) {\n+                list.add(e.toString());\n+            }\n+        }\n+        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n+    }\n+    \n+\n+    /**\n+     * Builds a String for a toString method excluding the given field names.\n+     * \n+     * @param object\n+     *            The object to \"toString\".\n+     * @param excludeFieldNames\n+     *            The field names to exclude\n+     * @return The toString value.\n+     */\n+    public static String toStringExclude(Object object, String[] excludeFieldNames) {\n+        return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\n+    }\n+\n+    /**\n+     * Whether or not to append static fields.\n+     */\n+    private boolean appendStatics = false;\n+\n+    /**\n+     * Whether or not to append transient fields.\n+     */\n+    private boolean appendTransients = false;\n+\n+    /**\n+     * Which field names to exclude from output. Intended for fields like <code>\"password\"</code>.\n+     */\n+    protected String[] excludeFieldNames;\n+\n+    /**\n+     * The last super class to stop appending fields for.\n+     */\n+    private Class<?> upToClass = null;\n+\n+    /**\n+     * <p>\n+     * Constructor.\n+     * </p>\n+     * \n+     * <p>\n+     * This constructor outputs using the default style set with <code>setDefaultStyle</code>.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the Object passed in is <code>null</code>\n+     */\n+    public ReflectionToStringBuilder(Object object) {\n+        super(object);\n+    }\n+\n+    /**\n+     * <p>\n+     * Constructor.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default style is used.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the Object passed in is <code>null</code>\n+     */\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style) {\n+        super(object, style);\n+    }\n+\n+    /**\n+     * <p>\n+     * Constructor.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default style is used.\n+     * </p>\n+     * \n+     * <p>\n+     * If the buffer is <code>null</code>, a new one is created.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to build a <code>toString</code> for\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param buffer\n+     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the Object passed in is <code>null</code>\n+     */\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\n+        super(object, style, buffer);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param object\n+     *            the Object to build a <code>toString</code> for\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param buffer\n+     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\n+     * @param reflectUpToClass\n+     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @param outputStatics\n+     *            whether to include static fields\n+     * @since 2.1\n+     */\n+    public <T> ReflectionToStringBuilder(\n+            T object, ToStringStyle style, StringBuffer buffer,\n+            Class<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\n+        super(object, style, buffer);\n+        this.setUpToClass(reflectUpToClass);\n+        this.setAppendTransients(outputTransients);\n+        this.setAppendStatics(outputStatics);\n+    }\n+\n+    /**\n+     * Returns whether or not to append the given <code>Field</code>.\n+     * <ul>\n+     * <li>Transient fields are appended only if {@link #isAppendTransients()} returns <code>true</code>.\n+     * <li>Static fields are appended only if {@link #isAppendStatics()} returns <code>true</code>.\n+     * <li>Inner class fields are not appened.</li>\n+     * </ul>\n+     * \n+     * @param field\n+     *            The Field to test.\n+     * @return Whether or not to append the given <code>Field</code>.\n+     */\n+    protected boolean accept(Field field) {\n+        if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n+            // Reject field from inner class.\n+            return false;\n+        }\n+        if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\n+            // Reject transient fields.\n+            return false;\n+        }\n+        if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\n+            // Reject static fields.\n+            return false;\n+        }\n+        if (this.excludeFieldNames != null\n+            && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\n+            // Reject fields from the getExcludeFieldNames list.\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>\n+     * Appends the fields and values defined by the given object of the given Class.\n+     * </p>\n+     * \n+     * <p>\n+     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n+     * <code>Object.toString()</code> had been called and not implemented by the object.\n+     * </p>\n+     * \n+     * @param clazz\n+     *            The class of object parameter\n+     */\n+    protected void appendFieldsIn(Class<?> clazz) {\n+        if (clazz.isArray()) {\n+            this.reflectionAppendArray(this.getObject());\n+            return;\n+        }\n+        Field[] fields = clazz.getDeclaredFields();\n+        AccessibleObject.setAccessible(fields, true);\n+        for (Field field : fields) {\n+            String fieldName = field.getName();\n+            if (this.accept(field)) {\n+                try {\n+                    // Warning: Field.get(Object) creates wrappers objects\n+                    // for primitive types.\n+                    Object fieldValue = this.getValue(field);\n+                    this.append(fieldName, fieldValue);\n+                } catch (IllegalAccessException ex) {\n+                    //this can't happen. Would get a Security exception\n+                    // instead\n+                    //throw a runtime exception in case the impossible\n+                    // happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @return Returns the excludeFieldNames.\n+     */\n+    public String[] getExcludeFieldNames() {\n+        return this.excludeFieldNames.clone();\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the last super class to stop appending fields for.\n+     * </p>\n+     * \n+     * @return The last super class to stop appending fields for.\n+     */\n+    public Class<?> getUpToClass() {\n+        return this.upToClass;\n+    }\n+\n+    /**\n+     * <p>\n+     * Calls <code>java.lang.reflect.Field.get(Object)</code>.\n+     * </p>\n+     * \n+     * @param field\n+     *            The Field to query.\n+     * @return The Object from the given Field.\n+     * \n+     * @throws IllegalArgumentException\n+     *             see {@link java.lang.reflect.Field#get(Object)}\n+     * @throws IllegalAccessException\n+     *             see {@link java.lang.reflect.Field#get(Object)}\n+     * \n+     * @see java.lang.reflect.Field#get(Object)\n+     */\n+    protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\n+        return field.get(this.getObject());\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets whether or not to append static fields.\n+     * </p>\n+     * \n+     * @return Whether or not to append static fields.\n+     * @since 2.1\n+     */\n+    public boolean isAppendStatics() {\n+        return this.appendStatics;\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets whether or not to append transient fields.\n+     * </p>\n+     * \n+     * @return Whether or not to append transient fields.\n+     */\n+    public boolean isAppendTransients() {\n+        return this.appendTransients;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append to the <code>toString</code> an <code>Object</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n+        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets whether or not to append static fields.\n+     * </p>\n+     * \n+     * @param appendStatics\n+     *            Whether or not to append static fields.\n+     * @since 2.1\n+     */\n+    public void setAppendStatics(boolean appendStatics) {\n+        this.appendStatics = appendStatics;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets whether or not to append transient fields.\n+     * </p>\n+     * \n+     * @param appendTransients\n+     *            Whether or not to append transient fields.\n+     */\n+    public void setAppendTransients(boolean appendTransients) {\n+        this.appendTransients = appendTransients;\n+    }\n+\n+    /**\n+     * Sets the field names to exclude.\n+     * \n+     * @param excludeFieldNamesParam\n+     *            The excludeFieldNames to excluding from toString or <code>null</code>.\n+     * @return <code>this</code>\n+     */\n+    public ReflectionToStringBuilder setExcludeFieldNames(String[] excludeFieldNamesParam) {\n+        if (excludeFieldNamesParam == null) {\n+            this.excludeFieldNames = null;\n+        } else {\n+            this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);\n+            Arrays.sort(this.excludeFieldNames);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets the last super class to stop appending fields for.\n+     * </p>\n+     * \n+     * @param clazz\n+     *            The last super class to stop appending fields for.\n+     */\n+    public void setUpToClass(Class<?> clazz) {\n+        if (clazz != null) {\n+            Object object = getObject();\n+            if (object != null && clazz.isInstance(object) == false) {\n+                throw new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n+            }\n+        }\n+        this.upToClass = clazz;\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the String built by this builder.\n+     * </p>\n+     * \n+     * @return the built string\n+     */\n+    @Override\n+    public String toString() {\n+        if (this.getObject() == null) {\n+            return this.getStyle().getNullText();\n+        }\n+        Class<?> clazz = this.getObject().getClass();\n+        this.appendFieldsIn(clazz);\n+        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n+            clazz = clazz.getSuperclass();\n+            this.appendFieldsIn(clazz);\n+        }\n+        return super.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/builder/StandardToStringStyle.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+/**\n+ * <p>Works with {@link ToStringBuilder} to create a <code>toString</code>.</p>\n+ *\n+ * <p>This class is intended to be used as a singleton.\n+ * There is no need to instantiate a new style each time.\n+ * Simply instantiate the class once, customize the values as required, and\n+ * store the result in a public static final variable for the rest of the\n+ * program to access.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Pete Gieser\n+ * @author Gary Gregory\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class StandardToStringStyle extends ToStringStyle {\n+    \n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * <p>Constructor.</p>\n+     */\n+    public StandardToStringStyle() {\n+        super();\n+    }\n+    \n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether to use the class name.</p>\n+     *\n+     * @return the current useClassName flag\n+     */\n+    @Override\n+    public boolean isUseClassName() {\n+        return super.isUseClassName();\n+    }\n+\n+    /**\n+     * <p>Sets whether to use the class name.</p>\n+     *\n+     * @param useClassName  the new useClassName flag\n+     */\n+    @Override\n+    public void setUseClassName(boolean useClassName) {\n+        super.setUseClassName(useClassName);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether to output short or long class names.</p>\n+     *\n+     * @return the current useShortClassName flag\n+     * @since 2.0\n+     */\n+    @Override\n+    public boolean isUseShortClassName() {\n+        return super.isUseShortClassName();\n+    }\n+\n+    /**\n+     * <p>Sets whether to output short or long class names.</p>\n+     *\n+     * @param useShortClassName  the new useShortClassName flag\n+     * @since 2.0\n+     */\n+    @Override\n+    public void setUseShortClassName(boolean useShortClassName) {\n+        super.setUseShortClassName(useShortClassName);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether to use the identity hash code.</p>\n+     * @return the current useIdentityHashCode flag\n+     */\n+    @Override\n+    public boolean isUseIdentityHashCode() {\n+        return super.isUseIdentityHashCode();\n+    }\n+\n+    /**\n+     * <p>Sets whether to use the identity hash code.</p>\n+     *\n+     * @param useIdentityHashCode  the new useIdentityHashCode flag\n+     */\n+    @Override\n+    public void setUseIdentityHashCode(boolean useIdentityHashCode) {\n+        super.setUseIdentityHashCode(useIdentityHashCode);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether to use the field names passed in.</p>\n+     *\n+     * @return the current useFieldNames flag\n+     */\n+    @Override\n+    public boolean isUseFieldNames() {\n+        return super.isUseFieldNames();\n+    }\n+\n+    /**\n+     * <p>Sets whether to use the field names passed in.</p>\n+     *\n+     * @param useFieldNames  the new useFieldNames flag\n+     */\n+    @Override\n+    public void setUseFieldNames(boolean useFieldNames) {\n+        super.setUseFieldNames(useFieldNames);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether to use full detail when the caller doesn't\n+     * specify.</p>\n+     *\n+     * @return the current defaultFullDetail flag\n+     */\n+    @Override\n+    public boolean isDefaultFullDetail() {\n+        return super.isDefaultFullDetail();\n+    }\n+\n+    /**\n+     * <p>Sets whether to use full detail when the caller doesn't\n+     * specify.</p>\n+     *\n+     * @param defaultFullDetail  the new defaultFullDetail flag\n+     */\n+    @Override\n+    public void setDefaultFullDetail(boolean defaultFullDetail) {\n+        super.setDefaultFullDetail(defaultFullDetail);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether to output array content detail.</p>\n+     *\n+     * @return the current array content detail setting\n+     */\n+    @Override\n+    public boolean isArrayContentDetail() {\n+        return super.isArrayContentDetail();\n+    }\n+    \n+    /**\n+     * <p>Sets whether to output array content detail.</p>\n+     *\n+     * @param arrayContentDetail  the new arrayContentDetail flag\n+     */\n+    @Override\n+    public void setArrayContentDetail(boolean arrayContentDetail) {\n+        super.setArrayContentDetail(arrayContentDetail);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the array start text.</p>\n+     *\n+     * @return the current array start text\n+     */\n+    @Override\n+    public String getArrayStart() {\n+        return super.getArrayStart();\n+    }\n+\n+    /**\n+     * <p>Sets the array start text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param arrayStart  the new array start text\n+     */\n+    @Override\n+    public void setArrayStart(String arrayStart) {\n+        super.setArrayStart(arrayStart);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the array end text.</p>\n+     *\n+     * @return the current array end text\n+     */\n+    @Override\n+    public String getArrayEnd() {\n+        return super.getArrayEnd();\n+    }\n+\n+    /**\n+     * <p>Sets the array end text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param arrayEnd  the new array end text\n+     */\n+    @Override\n+    public void setArrayEnd(String arrayEnd) {\n+        super.setArrayEnd(arrayEnd);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the array separator text.</p>\n+     *\n+     * @return the current array separator text\n+     */\n+    @Override\n+    public String getArraySeparator() {\n+        return super.getArraySeparator();\n+    }\n+\n+    /**\n+     * <p>Sets the array separator text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param arraySeparator  the new array separator text\n+     */\n+    @Override\n+    public void setArraySeparator(String arraySeparator) {\n+        super.setArraySeparator(arraySeparator);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the content start text.</p>\n+     *\n+     * @return the current content start text\n+     */\n+    @Override\n+    public String getContentStart() {\n+        return super.getContentStart();\n+    }\n+\n+    /**\n+     * <p>Sets the content start text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param contentStart  the new content start text\n+     */\n+    @Override\n+    public void setContentStart(String contentStart) {\n+        super.setContentStart(contentStart);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the content end text.</p>\n+     *\n+     * @return the current content end text\n+     */\n+    @Override\n+    public String getContentEnd() {\n+        return super.getContentEnd();\n+    }\n+\n+    /**\n+     * <p>Sets the content end text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param contentEnd  the new content end text\n+     */\n+    @Override\n+    public void setContentEnd(String contentEnd) {\n+        super.setContentEnd(contentEnd);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the field name value separator text.</p>\n+     *\n+     * @return the current field name value separator text\n+     */\n+    @Override\n+    public String getFieldNameValueSeparator() {\n+        return super.getFieldNameValueSeparator();\n+    }\n+\n+    /**\n+     * <p>Sets the field name value separator text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param fieldNameValueSeparator  the new field name value separator text\n+     */\n+    @Override\n+    public void setFieldNameValueSeparator(String fieldNameValueSeparator) {\n+        super.setFieldNameValueSeparator(fieldNameValueSeparator);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the field separator text.</p>\n+     *\n+     * @return the current field separator text\n+     */\n+    @Override\n+    public String getFieldSeparator() {\n+        return super.getFieldSeparator();\n+    }\n+\n+    /**\n+     * <p>Sets the field separator text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param fieldSeparator  the new field separator text\n+     */\n+    @Override\n+    public void setFieldSeparator(String fieldSeparator) {\n+        super.setFieldSeparator(fieldSeparator);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether the field separator should be added at the start \n+     * of each buffer.</p>\n+     * \n+     * @return the fieldSeparatorAtStart flag\n+     * @since 2.0\n+     */\n+    @Override\n+    public boolean isFieldSeparatorAtStart() {\n+        return super.isFieldSeparatorAtStart();\n+    }\n+\n+    /**\n+     * <p>Sets whether the field separator should be added at the start \n+     * of each buffer.</p>\n+     * \n+     * @param fieldSeparatorAtStart  the fieldSeparatorAtStart flag\n+     * @since 2.0\n+     */\n+    @Override\n+    public void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\n+        super.setFieldSeparatorAtStart(fieldSeparatorAtStart);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether the field separator should be added at the end \n+     * of each buffer.</p>\n+     * \n+     * @return fieldSeparatorAtEnd flag\n+     * @since 2.0\n+     */\n+    @Override\n+    public boolean isFieldSeparatorAtEnd() {\n+        return super.isFieldSeparatorAtEnd();\n+    }\n+\n+    /**\n+     * <p>Sets whether the field separator should be added at the end \n+     * of each buffer.</p>\n+     * \n+     * @param fieldSeparatorAtEnd  the fieldSeparatorAtEnd flag\n+     * @since 2.0\n+     */\n+    @Override\n+    public void setFieldSeparatorAtEnd(boolean fieldSeparatorAtEnd) {\n+        super.setFieldSeparatorAtEnd(fieldSeparatorAtEnd);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the text to output when <code>null</code> found.</p>\n+     *\n+     * @return the current text to output when <code>null</code> found\n+     */\n+    @Override\n+    public String getNullText() {\n+        return super.getNullText();\n+    }\n+\n+    /**\n+     * <p>Sets the text to output when <code>null</code> found.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param nullText  the new text to output when <code>null</code> found\n+     */\n+    @Override\n+    public void setNullText(String nullText) {\n+        super.setNullText(nullText);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the text to output when a <code>Collection</code>,\n+     * <code>Map</code> or <code>Array</code> size is output.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * @return the current start of size text\n+     */\n+    @Override\n+    public String getSizeStartText() {\n+        return super.getSizeStartText();\n+    }\n+\n+    /**\n+     * <p>Sets the start text to output when a <code>Collection</code>,\n+     * <code>Map</code> or <code>Array</code> size is output.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param sizeStartText  the new start of size text\n+     */\n+    @Override\n+    public void setSizeStartText(String sizeStartText) {\n+        super.setSizeStartText(sizeStartText);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets the end text to output when a <code>Collection</code>,\n+     * <code>Map</code> or <code>Array</code> size is output.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * @return the current end of size text\n+     */\n+    @Override\n+    public String getSizeEndText() {\n+        return super.getSizeEndText();\n+    }\n+\n+    /**\n+     * <p>Sets the end text to output when a <code>Collection</code>,\n+     * <code>Map</code> or <code>Array</code> size is output.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param sizeEndText  the new end of size text\n+     */\n+    @Override\n+    public void setSizeEndText(String sizeEndText) {\n+        super.setSizeEndText(sizeEndText);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the start text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <P>This is output before the size value.</p>\n+     *\n+     * @return the current start of summary text\n+     */\n+    @Override\n+    public String getSummaryObjectStartText() {\n+        return super.getSummaryObjectStartText();\n+    }\n+\n+    /**\n+     * <p>Sets the start text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param summaryObjectStartText  the new start of summary text\n+     */\n+    @Override\n+    public void setSummaryObjectStartText(String summaryObjectStartText) {\n+        super.setSummaryObjectStartText(summaryObjectStartText);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the end text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * @return the current end of summary text\n+     */\n+    @Override\n+    public String getSummaryObjectEndText() {\n+        return super.getSummaryObjectEndText();\n+    }\n+\n+    /**\n+     * <p>Sets the end text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param summaryObjectEndText  the new end of summary text\n+     */\n+    @Override\n+    public void setSummaryObjectEndText(String summaryObjectEndText) {\n+        super.setSummaryObjectEndText(summaryObjectEndText);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/builder/ToStringBuilder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import org.apache.commons.lang.ObjectUtils;\n+\n+/**\n+ * <p>Assists in implementing {@link Object#toString()} methods.</p>\n+ *\n+ * <p>This class enables a good and consistent <code>toString()</code> to be built for any\n+ * class or object. This class aims to simplify the process by:</p>\n+ * <ul>\n+ *  <li>allowing field names</li>\n+ *  <li>handling all types consistently</li>\n+ *  <li>handling nulls consistently</li>\n+ *  <li>outputting arrays and multi-dimensional arrays</li>\n+ *  <li>enabling the detail level to be controlled for Objects and Collections</li>\n+ *  <li>handling class hierarchies</li>\n+ * </ul>\n+ *\n+ * <p>To use this class write code as follows:</p>\n+ *\n+ * <pre>\n+ * public class Person {\n+ *   String name;\n+ *   int age;\n+ *   boolean smoker;\n+ * \n+ *   ...\n+ * \n+ *   public String toString() {\n+ *     return new ToStringBuilder(this).\n+ *       append(\"name\", name).\n+ *       append(\"age\", age).\n+ *       append(\"smoker\", smoker).\n+ *       toString();\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>This will produce a toString of the format:\n+ * <code>Person@7f54[name=Stephen,age=29,smoker=false]</code></p>\n+ * \n+ * <p>To add the superclass <code>toString</code>, use {@link #appendSuper}.\n+ * To append the <code>toString</code> from an object that is delegated\n+ * to (or any other object), use {@link #appendToString}.</p>\n+ *\n+ * <p>Alternatively, there is a method that uses reflection to determine\n+ * the fields to test. Because these fields are usually private, the method, \n+ * <code>reflectionToString</code>, uses <code>AccessibleObject.setAccessible</code> to\n+ * change the visibility of the fields. This will fail under a security manager,\n+ * unless the appropriate permissions are set up correctly. It is also\n+ * slower than testing explicitly.</p>\n+ *\n+ * <p>A typical invocation for this method would look like:</p>\n+ *\n+ * <pre>\n+ * public String toString() {\n+ *   return ToStringBuilder.reflectionToString(this);\n+ * }\n+ * </pre>\n+ *\n+ * <p>You can also use the builder to debug 3rd party objects:</p>\n+ *\n+ * <pre>\n+ * System.out.println(\"An object: \" + ToStringBuilder.reflectionToString(anObject));\n+ * </pre>\n+ * \n+ * <p>The exact format of the <code>toString</code> is determined by\n+ * the {@link ToStringStyle} passed into the constructor.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Gary Gregory\n+ * @author Pete Gieser\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class ToStringBuilder {\n+\n+    /**\n+     * The default style of output to use, not null.\n+     */\n+    private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the default <code>ToStringStyle</code> to use.</p>\n+     * \n+     * <p>This method gets a singleton default value, typically for the whole JVM.\n+     * Changing this default should generally only be done during application startup.\n+     * It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n+     * of using this global default.</p>\n+     * \n+     * <p>This method can be used from multiple threads.\n+     * Internally, a <code>volatile</code> variable is used to provide the guarantee\n+     * that the latest value set using {@link #setDefaultStyle} is the value returned.\n+     * It is strongly recommended that the default style is only changed during application startup.</p>\n+     * \n+     * <p>One reason for changing the default could be to have a verbose style during\n+     * development and a compact style in production.</p>\n+     * \n+     * @return the default <code>ToStringStyle</code>, never null\n+     */\n+    public static ToStringStyle getDefaultStyle() {\n+        return defaultStyle;\n+    }\n+\n+    /**\n+     * <p>Sets the default <code>ToStringStyle</code> to use.</p>\n+     * \n+     * <p>This method sets a singleton default value, typically for the whole JVM.\n+     * Changing this default should generally only be done during application startup.\n+     * It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n+     * of changing this global default.</p>\n+     * \n+     * <p>This method is not intended for use from multiple threads.\n+     * Internally, a <code>volatile</code> variable is used to provide the guarantee\n+     * that the latest value set is the value returned from {@link #getDefaultStyle}.</p>\n+     * \n+     * @param style  the default <code>ToStringStyle</code>\n+     * @throws IllegalArgumentException if the style is <code>null</code>\n+     */\n+    public static void setDefaultStyle(ToStringStyle style) {\n+        if (style == null) {\n+            throw new IllegalArgumentException(\"The style must not be null\");\n+        }\n+        defaultStyle = style;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    /**\n+     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n+     * <code>toString</code> for the specified object.</p>\n+     * \n+     * @param object  the Object to be output\n+     * @return the String result\n+     * @see ReflectionToStringBuilder#toString(Object)\n+     */\n+    public static String reflectionToString(Object object) {\n+        return ReflectionToStringBuilder.toString(object);\n+    }\n+\n+    /**\n+     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n+     * <code>toString</code> for the specified object.</p>\n+     * \n+     * @param object  the Object to be output\n+     * @param style  the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @return the String result\n+     * @see ReflectionToStringBuilder#toString(Object,ToStringStyle)\n+     */\n+    public static String reflectionToString(Object object, ToStringStyle style) {\n+        return ReflectionToStringBuilder.toString(object, style);\n+    }\n+\n+    /**\n+     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n+     * <code>toString</code> for the specified object.</p>\n+     * \n+     * @param object  the Object to be output\n+     * @param style  the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param outputTransients  whether to include transient fields\n+     * @return the String result\n+     * @see ReflectionToStringBuilder#toString(Object,ToStringStyle,boolean)\n+     */\n+    public static String reflectionToString(Object object, ToStringStyle style, boolean outputTransients) {\n+        return ReflectionToStringBuilder.toString(object, style, outputTransients, false, null);\n+    }\n+\n+    /**\n+     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n+     * <code>toString</code> for the specified object.</p>\n+     * \n+     * @param object  the Object to be output\n+     * @param style  the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param outputTransients  whether to include transient fields\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @return the String result\n+     * @see ReflectionToStringBuilder#toString(Object,ToStringStyle,boolean,boolean,Class)\n+     * @since 2.0\n+     */\n+    public static <T> String reflectionToString(\n+        T object,\n+        ToStringStyle style,\n+        boolean outputTransients,\n+        Class<? super T> reflectUpToClass) {\n+        return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * Current toString buffer, not null.\n+     */\n+    private final StringBuffer buffer;\n+    /**\n+     * The object being output, may be null.\n+     */\n+    private final Object object;\n+    /**\n+     * The style of output to use, not null.\n+     */\n+    private final ToStringStyle style;\n+\n+    /**\n+     * <p>Constructs a builder for the specified object using the default output style.</p>\n+     *\n+     * <p>This default style is obtained from {@link #getDefaultStyle()}.</p>\n+     * \n+     * @param object  the Object to build a <code>toString</code> for, not recommended to be null\n+     */\n+    public ToStringBuilder(Object object) {\n+        this(object, null, null);\n+    }\n+\n+    /**\n+     * <p>Constructs a builder for the specified object using the a defined output style.</p>\n+     *\n+     * <p>If the style is <code>null</code>, the default style is used.</p>\n+     * \n+     * @param object  the Object to build a <code>toString</code> for, not recommended to be null\n+     * @param style  the style of the <code>toString</code> to create, null uses the default style\n+     */\n+    public ToStringBuilder(Object object, ToStringStyle style) {\n+        this(object, style, null);\n+    }\n+\n+    /**\n+     * <p>Constructs a builder for the specified object.</p>\n+     *\n+     * <p>If the style is <code>null</code>, the default style is used.</p>\n+     *\n+     * <p>If the buffer is <code>null</code>, a new one is created.</p>\n+     * \n+     * @param object  the Object to build a <code>toString</code> for, not recommended to be null\n+     * @param style  the style of the <code>toString</code> to create, null uses the default style\n+     * @param buffer  the <code>StringBuffer</code> to populate, may be null\n+     */\n+    public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\n+        if (style == null) {\n+            style = getDefaultStyle();\n+        }\n+        if (buffer == null) {\n+            buffer = new StringBuffer(512);\n+        }\n+        this.buffer = buffer;\n+        this.style = style;\n+        this.object = object;\n+\n+        style.appendStart(buffer, object);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(boolean value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(boolean[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(byte value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(byte[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(char value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(char[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(double value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(double[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(float value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(float[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(int value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(int[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(long value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(long[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value.</p>\n+     *\n+     * @param obj  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(Object obj) {\n+        style.append(buffer, null, obj, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(Object[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(short value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(short[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, boolean value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, boolean[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, boolean[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>byte</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, byte value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code> array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, byte[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, byte[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, char value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, char[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, char[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, double value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, double[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, double[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>float</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, float value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, float[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, float[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, int value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, int[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, int[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, long value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, long[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, long[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param obj  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, Object obj) {\n+        style.append(buffer, fieldName, obj, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param obj  the value to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail,\n+     *  <code>false</code> for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, Object obj, boolean fullDetail) {\n+        style.append(buffer, fieldName, obj, Boolean.valueOf(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, Object[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, Object[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>short</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, short value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, short[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, short[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends with the same format as the default <code>Object toString()\n+     * </code> method. Appends the class name followed by \n+     * {@link System#identityHashCode(java.lang.Object)}.</p>\n+     * \n+     * @param object  the <code>Object</code> whose class name and id to output\n+     * @return this\n+     * @since 2.0\n+     */\n+    public ToStringBuilder appendAsObjectToString(Object object) {\n+        ObjectUtils.identityToString(this.getStringBuffer(), object);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append the <code>toString</code> from the superclass.</p>\n+     * \n+     * <p>This method assumes that the superclass uses the same <code>ToStringStyle</code>\n+     * as this one.</p>\n+     * \n+     * <p>If <code>superToString</code> is <code>null</code>, no change is made.</p>\n+     *\n+     * @param superToString  the result of <code>super.toString()</code>\n+     * @return this\n+     * @since 2.0\n+     */\n+    public ToStringBuilder appendSuper(String superToString) {\n+        if (superToString != null) {\n+            style.appendSuper(buffer, superToString);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append the <code>toString</code> from another object.</p>\n+     * \n+     * <p>This method is useful where a class delegates most of the implementation of\n+     * its properties to another class. You can then call <code>toString()</code> on\n+     * the other class and pass the result into this method.</p>\n+     * \n+     * <pre>\n+     *   private AnotherObject delegate;\n+     *   private String fieldInThisClass;\n+     * \n+     *   public String toString() {\n+     *     return new ToStringBuilder(this).\n+     *       appendToString(delegate.toString()).\n+     *       append(fieldInThisClass).\n+     *       toString();\n+     *   }</pre>\n+     * \n+     * <p>This method assumes that the other object uses the same <code>ToStringStyle</code>\n+     * as this one.</p>\n+     * \n+     * <p>If the <code>toString</code> is <code>null</code>, no change is made.</p>\n+     *\n+     * @param toString  the result of <code>toString()</code> on another object\n+     * @return this\n+     * @since 2.0\n+     */\n+    public ToStringBuilder appendToString(String toString) {\n+        if (toString != null) {\n+            style.appendToString(buffer, toString);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Returns the <code>Object</code> being output.</p>\n+     * \n+     * @return The object being output.\n+     * @since 2.0\n+     */\n+    public Object getObject() {\n+        return object;\n+    }\n+\n+    /**\n+     * <p>Gets the <code>StringBuffer</code> being populated.</p>\n+     * \n+     * @return the <code>StringBuffer</code> being populated\n+     */\n+    public StringBuffer getStringBuffer() {\n+        return buffer;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the <code>ToStringStyle</code> being used.</p>\n+     * \n+     * @return the <code>ToStringStyle</code> being used\n+     * @since 2.0\n+     */\n+    public ToStringStyle getStyle() {\n+        return style;\n+    }\n+\n+    /**\n+     * <p>Returns the built <code>toString</code>.</p>\n+     * \n+     * <p>This method appends the end of data indicator, and can only be called once.\n+     * Use {@link #getStringBuffer} to get the current string state.</p>\n+     * \n+     * <p>If the object is <code>null</code>, return the style's <code>nullText</code></p>\n+     * \n+     * @return the String <code>toString</code>\n+     */\n+    @Override\n+    public String toString() {\n+        if (this.getObject() == null) {\n+            this.getStringBuffer().append(this.getStyle().getNullText());\n+        } else {\n+            style.appendEnd(this.getStringBuffer(), this.getObject());\n+        }\n+        return this.getStringBuffer().toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/builder/ToStringStyle.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.ClassUtils;\n+import org.apache.commons.lang.ObjectUtils;\n+import org.apache.commons.lang.SystemUtils;\n+\n+/**\n+ * <p>Controls <code>String</code> formatting for {@link ToStringBuilder}.\n+ * The main public interface is always via <code>ToStringBuilder</code>.</p>\n+ *\n+ * <p>These classes are intended to be used as <code>Singletons</code>.\n+ * There is no need to instantiate a new style each time. A program\n+ * will generally use one of the predefined constants on this class.\n+ * Alternatively, the {@link StandardToStringStyle} class can be used\n+ * to set the individual settings. Thus most styles can be achieved\n+ * without subclassing.</p>\n+ *\n+ * <p>If required, a subclass can override as many or as few of the\n+ * methods as it requires. Each object type (from <code>boolean</code>\n+ * to <code>long</code> to <code>Object</code> to <code>int[]</code>) has\n+ * its own methods to output it. Most have two versions, detail and summary.\n+ *\n+ * <p>For example, the detail version of the array based methods will\n+ * output the whole array, whereas the summary method will just output\n+ * the array length.</p>\n+ * \n+ * <p>If you want to format the output of certain objects, such as dates, you\n+ * must create a subclass and override a method.\n+ * <pre>\n+ * public class MyStyle extends ToStringStyle {\n+ *   protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\n+ *     if (value instanceof Date) {\n+ *       value = new SimpleDateFormat(\"yyyy-MM-dd\").format(value);\n+ *     }\n+ *     buffer.append(value);\n+ *   }\n+ * }\n+ * </pre>\n+ * </p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Gary Gregory\n+ * @author Pete Gieser\n+ * @author Masato Tezuka\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public abstract class ToStringStyle implements Serializable {\n+\n+    /**\n+     * The default toString style. Using the Using the <code>Person</code>\n+     * example from {@link ToStringBuilder}, the output would look like this:\n+     * \n+     * <pre>\n+     * Person@182f0db[name=John Doe,age=33,smoker=false]\n+     * </pre>\n+     */\n+    public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n+    \n+    /**\n+     * The multi line toString style. Using the Using the <code>Person</code>\n+     * example from {@link ToStringBuilder}, the output would look like this:\n+     * \n+     * <pre>\n+     * Person@182f0db[\n+     *   name=John Doe\n+     *   age=33\n+     *   smoker=false\n+     * ]\n+     * </pre>\n+     */\n+    public static final ToStringStyle MULTI_LINE_STYLE = new MultiLineToStringStyle();\n+    \n+    /**\n+     * The no field names toString style. Using the Using the\n+     * <code>Person</code> example from {@link ToStringBuilder}, the output\n+     * would look like this:\n+     * \n+     * <pre>\n+     * Person@182f0db[John Doe,33,false]\n+     * </pre>\n+     */\n+    public static final ToStringStyle NO_FIELD_NAMES_STYLE = new NoFieldNameToStringStyle();\n+    \n+    /**\n+     * The short prefix toString style. Using the <code>Person</code> example\n+     * from {@link ToStringBuilder}, the output would look like this:\n+     * \n+     * <pre>\n+     * Person[name=John Doe,age=33,smoker=false]\n+     * </pre>\n+     * \n+     * @since 2.1\n+     */\n+    public static final ToStringStyle SHORT_PREFIX_STYLE = new ShortPrefixToStringStyle();\n+\n+    /**\n+     * The simple toString style. Using the Using the <code>Person</code>\n+     * example from {@link ToStringBuilder}, the output would look like this:\n+     * \n+     * <pre>\n+     * John Doe,33,false\n+     * </pre>\n+     */\n+    public static final ToStringStyle SIMPLE_STYLE = new SimpleToStringStyle();\n+    \n+    /**\n+     * <p>\n+     * A registry of objects used by <code>reflectionToString</code> methods\n+     * to detect cyclical object references and avoid infinite loops.\n+     * </p>\n+     */\n+    private static final ThreadLocal<Set<Object>> registry = new ThreadLocal<Set<Object>>() {\n+        @Override\n+        protected Set<Object> initialValue() {\n+            // The HashSet implementation is not synchronized,\n+            // which is just what we need here.\n+            return new HashSet<Object>();\n+        }\n+    };\n+\n+    /**\n+     * <p>\n+     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n+     * methods in the current thread.\n+     * </p>\n+     * \n+     * @return Set the registry of objects being traversed\n+     */\n+    static Set<Object> getRegistry() {\n+        return registry.get();\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns <code>true</code> if the registry contains the given object.\n+     * Used by the reflection methods to avoid infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *                  The object to lookup in the registry.\n+     * @return boolean <code>true</code> if the registry contains the given\n+     *             object.\n+     */\n+    static boolean isRegistered(Object value) {\n+        return getRegistry().contains(value);\n+    }\n+\n+    /**\n+     * <p>\n+     * Registers the given object. Used by the reflection methods to avoid\n+     * infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *                  The object to register.\n+     */\n+    static void register(Object value) {\n+        if (value != null) {\n+            getRegistry().add(value);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Unregisters the given object.\n+     * </p>\n+     * \n+     * <p>\n+     * Used by the reflection methods to avoid infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *                  The object to unregister.\n+     */\n+    static void unregister(Object value) {\n+        getRegistry().remove(value);\n+    }\n+\n+    /**\n+     * Whether to use the field names, the default is <code>true</code>.\n+     */\n+    private boolean useFieldNames = true;\n+    \n+    /**\n+     * Whether to use the class name, the default is <code>true</code>.\n+     */\n+    private boolean useClassName = true;\n+    \n+    /**\n+     * Whether to use short class names, the default is <code>false</code>.\n+     */\n+    private boolean useShortClassName = false;\n+    \n+    /**\n+     * Whether to use the identity hash code, the default is <code>true</code>.\n+     */\n+    private boolean useIdentityHashCode = true;\n+\n+    /**\n+     * The content start <code>'['</code>.\n+     */\n+    private String contentStart = \"[\";\n+    \n+    /**\n+     * The content end <code>']'</code>.\n+     */\n+    private String contentEnd = \"]\";\n+    \n+    /**\n+     * The field name value separator <code>'='</code>.\n+     */\n+    private String fieldNameValueSeparator = \"=\";\n+    \n+    /**\n+     * Whether the field separator should be added before any other fields.\n+     */\n+    private boolean fieldSeparatorAtStart = false;\n+    \n+    /**\n+     * Whether the field separator should be added after any other fields.\n+     */\n+    private boolean fieldSeparatorAtEnd = false;\n+    \n+    /**\n+     * The field separator <code>','</code>.\n+     */\n+    private String fieldSeparator = \",\";\n+    \n+    /**\n+     * The array start <code>'{'</code>.\n+     */\n+    private String arrayStart = \"{\";\n+    \n+    /**\n+     * The array separator <code>','</code>.\n+     */\n+    private String arraySeparator = \",\";\n+    \n+    /**\n+     * The detail for array content.\n+     */\n+    private boolean arrayContentDetail = true;\n+    \n+    /**\n+     * The array end <code>'}'</code>.\n+     */\n+    private String arrayEnd = \"}\";\n+    \n+    /**\n+     * The value to use when fullDetail is <code>null</code>,\n+     * the default value is <code>true</code>.\n+     */\n+    private boolean defaultFullDetail = true;\n+    \n+    /**\n+     * The <code>null</code> text <code>'&lt;null&gt;'</code>.\n+     */\n+    private String nullText = \"<null>\";\n+    \n+    /**\n+     * The summary size text start <code>'<size'</code>.\n+     */\n+    private String sizeStartText = \"<size=\";\n+    \n+    /**\n+     * The summary size text start <code>'&gt;'</code>.\n+     */\n+    private String sizeEndText = \">\";\n+    \n+    /**\n+     * The summary object text start <code>'&lt;'</code>.\n+     */\n+    private String summaryObjectStartText = \"<\";\n+    \n+    /**\n+     * The summary object text start <code>'&gt;'</code>.\n+     */\n+    private String summaryObjectEndText = \">\";\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Constructor.</p>\n+     */\n+    protected ToStringStyle() {\n+        super();\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the superclass toString.</p>\n+     * <p>NOTE: It assumes that the toString has been created from the same ToStringStyle. </p>\n+     * \n+     * <p>A <code>null</code> <code>superToString</code> is ignored.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param superToString  the <code>super.toString()</code>\n+     * @since 2.0\n+     */\n+    public void appendSuper(StringBuffer buffer, String superToString) {\n+        appendToString(buffer, superToString);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> another toString.</p>\n+     * <p>NOTE: It assumes that the toString has been created from the same ToStringStyle. </p>\n+     * \n+     * <p>A <code>null</code> <code>toString</code> is ignored.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param toString  the additional <code>toString</code>\n+     * @since 2.0\n+     */\n+    public void appendToString(StringBuffer buffer, String toString) {\n+        if (toString != null) {\n+            int pos1 = toString.indexOf(contentStart) + contentStart.length();\n+            int pos2 = toString.lastIndexOf(contentEnd);\n+            if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) {\n+                String data = toString.substring(pos1, pos2);\n+                if (fieldSeparatorAtStart) {\n+                    removeLastFieldSeparator(buffer);\n+                }\n+                buffer.append(data);\n+                appendFieldSeparator(buffer);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the start of data indicator.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param object  the <code>Object</code> to build a <code>toString</code> for\n+     */\n+    public void appendStart(StringBuffer buffer, Object object) {\n+        if (object != null) {\n+            appendClassName(buffer, object);\n+            appendIdentityHashCode(buffer, object);\n+            appendContentStart(buffer);\n+            if (fieldSeparatorAtStart) {\n+                appendFieldSeparator(buffer);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the end of data indicator.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param object  the <code>Object</code> to build a\n+     *  <code>toString</code> for.\n+     */\n+    public void appendEnd(StringBuffer buffer, Object object) {\n+        if (this.fieldSeparatorAtEnd == false) {\n+            removeLastFieldSeparator(buffer);\n+        }\n+        appendContentEnd(buffer);\n+        unregister(object);\n+    }\n+\n+    /**\n+     * <p>Remove the last field separator from the buffer.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @since 2.0\n+     */\n+    protected void removeLastFieldSeparator(StringBuffer buffer) {\n+        int len = buffer.length();\n+        int sepLen = fieldSeparator.length();\n+        if (len > 0 && sepLen > 0 && len >= sepLen) {\n+            boolean match = true;\n+            for (int i = 0; i < sepLen; i++) {\n+                if (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\n+                    match = false;\n+                    break;\n+                }\n+            }\n+            if (match) {\n+                buffer.setLength(len - sepLen);\n+            }\n+        }\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value, printing the full <code>toString</code> of the\n+     * <code>Object</code> passed in.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (value == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else {\n+            appendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>,\n+     * correctly interpreting its type.</p>\n+     *\n+     * <p>This method performs the main lookup by Class type to correctly\n+     * route arrays, <code>Collections</code>, <code>Maps</code> and\n+     * <code>Objects</code> to the appropriate method.</p>\n+     *\n+     * <p>Either detail or summary views can be specified.</p>\n+     *\n+     * <p>If a cycle is detected, an object will be appended with the\n+     * <code>Object.toString()</code> format.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     * @param detail  output detail or not\n+     */\n+    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n+        if (isRegistered(value)\n+            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n+           appendCyclicObject(buffer, fieldName, value);\n+           return;\n+        }   \n+\n+        register(value);\n+\n+        try {\n+            if (value instanceof Collection<?>) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (Collection<?>) value);\n+                } else {\n+                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n+                }\n+    \n+            } else if (value instanceof Map<?, ?>) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n+                } else {\n+                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n+                }\n+    \n+            } else if (value instanceof long[]) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (long[]) value);\n+                } else {\n+                    appendSummary(buffer, fieldName, (long[]) value);\n+                }\n+    \n+            } else if (value instanceof int[]) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (int[]) value);\n+                } else {\n+                    appendSummary(buffer, fieldName, (int[]) value);\n+                }\n+    \n+            } else if (value instanceof short[]) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (short[]) value);\n+                } else {\n+                    appendSummary(buffer, fieldName, (short[]) value);\n+                }\n+    \n+            } else if (value instanceof byte[]) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (byte[]) value);\n+                } else {\n+                    appendSummary(buffer, fieldName, (byte[]) value);\n+                }\n+    \n+            } else if (value instanceof char[]) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (char[]) value);\n+                } else {\n+                    appendSummary(buffer, fieldName, (char[]) value);\n+                }\n+    \n+            } else if (value instanceof double[]) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (double[]) value);\n+                } else {\n+                    appendSummary(buffer, fieldName, (double[]) value);\n+                }\n+    \n+            } else if (value instanceof float[]) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (float[]) value);\n+                } else {\n+                    appendSummary(buffer, fieldName, (float[]) value);\n+                }\n+    \n+            } else if (value instanceof boolean[]) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (boolean[]) value);\n+                } else {\n+                    appendSummary(buffer, fieldName, (boolean[]) value);\n+                }\n+    \n+            } else if (value.getClass().isArray()) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (Object[]) value);\n+                } else {\n+                    appendSummary(buffer, fieldName, (Object[]) value);\n+                }\n+    \n+            } else {\n+                    if (detail) {\n+                        appendDetail(buffer, fieldName, value);\n+                    } else {\n+                        appendSummary(buffer, fieldName, value);\n+                    }\n+            }\n+        } finally {\n+            unregister(value);\n+        }\n+    }\n+    \n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value that has been detected to participate in a cycle. This\n+     * implementation will print the standard string value of the value.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     *  \n+     * @since 2.2\n+     */\n+    protected void appendCyclicObject(StringBuffer buffer, String fieldName, Object value) {\n+       ObjectUtils.identityToString(buffer, value);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value, printing the full detail of the <code>Object</code>.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\n+        buffer.append(value);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>Collection</code>.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param coll  the <code>Collection</code> to add to the\n+     *  <code>toString</code>, not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, Collection<?> coll) {\n+        buffer.append(coll);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>Map<code>.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param map  the <code>Map</code> to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, Map<?, ?> map) {\n+        buffer.append(map);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value, printing a summary of the <code>Object</code>.</P>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, Object value) {\n+        buffer.append(summaryObjectStartText);\n+        buffer.append(getShortClassName(value.getClass()));\n+        buffer.append(summaryObjectEndText);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, long value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, long value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, int value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, int value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, short value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, short value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, byte value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, byte value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, char value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, char value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, double value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, double value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, float value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, float value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, boolean value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, boolean value) {\n+        buffer.append(value);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, Object[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of an\n+     * <code>Object</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, Object[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            Object item = array[i];\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            if (item == null) {\n+                appendNullText(buffer, fieldName);\n+\n+            } else {\n+                appendInternal(buffer, fieldName, item, arrayContentDetail);\n+            }\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     * @since 2.0\n+     */\n+    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n+        buffer.append(arrayStart);\n+        int length = Array.getLength(array);\n+        for (int i = 0; i < length; i++) {\n+            Object item = Array.get(array, i);\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            if (item == null) {\n+                appendNullText(buffer, fieldName);\n+\n+            } else {\n+                appendInternal(buffer, fieldName, item, arrayContentDetail);\n+            }\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of an\n+     * <code>Object</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, Object[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, long[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>long</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, long[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>long</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, long[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, int[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of an\n+     * <code>int</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of an\n+     * <code>int</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, int[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, short[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>short</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, short[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>short</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, short[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, byte[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>byte</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>byte</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, byte[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, char[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>char</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, char[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>char</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, char[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, double[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>double</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, double[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>double</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, double[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, float[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>float</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, float[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>float</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, float[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, boolean[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>boolean</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, boolean[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>boolean</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, boolean[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the class name.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param object  the <code>Object</code> whose name to output\n+     */\n+    protected void appendClassName(StringBuffer buffer, Object object) {\n+        if (useClassName && object != null) {\n+            register(object);\n+            if (useShortClassName) {\n+                buffer.append(getShortClassName(object.getClass()));\n+            } else {\n+                buffer.append(object.getClass().getName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Append the {@link System#identityHashCode(java.lang.Object)}.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param object  the <code>Object</code> whose id to output\n+     */\n+    protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\n+        if (this.isUseIdentityHashCode() && object!=null) {\n+            register(object);\n+            buffer.append('@');\n+            buffer.append(Integer.toHexString(System.identityHashCode(object)));\n+        }\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the content start.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     */\n+    protected void appendContentStart(StringBuffer buffer) {\n+        buffer.append(contentStart);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the content end.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     */\n+    protected void appendContentEnd(StringBuffer buffer) {\n+        buffer.append(contentEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an indicator for <code>null</code>.</p>\n+     *\n+     * <p>The default indicator is <code>'&lt;null&gt;'</code>.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     */\n+    protected void appendNullText(StringBuffer buffer, String fieldName) {\n+        buffer.append(nullText);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the field separator.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     */\n+    protected void appendFieldSeparator(StringBuffer buffer) {\n+        buffer.append(fieldSeparator);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the field start.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     */\n+    protected void appendFieldStart(StringBuffer buffer, String fieldName) {\n+        if (useFieldNames && fieldName != null) {\n+            buffer.append(fieldName);\n+            buffer.append(fieldNameValueSeparator);\n+        }\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString<code> the field end.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     */\n+    protected void appendFieldEnd(StringBuffer buffer, String fieldName) {\n+        appendFieldSeparator(buffer);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a size summary.</p>\n+     *\n+     * <p>The size summary is used to summarize the contents of\n+     * <code>Collections</code>, <code>Maps</code> and arrays.</p>\n+     *\n+     * <p>The output consists of a prefix, the passed in size\n+     * and a suffix.</p>\n+     *\n+     * <p>The default format is <code>'&lt;size=n&gt;'<code>.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param size  the size to append\n+     */\n+    protected void appendSummarySize(StringBuffer buffer, String fieldName, int size) {\n+        buffer.append(sizeStartText);\n+        buffer.append(size);\n+        buffer.append(sizeEndText);\n+    }\n+\n+    /**\n+     * <p>Is this field to be output in full detail.</p>\n+     *\n+     * <p>This method converts a detail request into a detail level.\n+     * The calling code may request full detail (<code>true</code>),\n+     * but a subclass might ignore that and always return\n+     * <code>false</code>. The calling code may pass in\n+     * <code>null</code> indicating that it doesn't care about\n+     * the detail level. In this case the default detail level is\n+     * used.</p>\n+     * \n+     * @param fullDetailRequest  the detail level requested\n+     * @return whether full detail is to be shown\n+     */\n+    protected boolean isFullDetail(Boolean fullDetailRequest) {\n+        if (fullDetailRequest == null) {\n+            return defaultFullDetail;\n+        }\n+        return fullDetailRequest.booleanValue();\n+    }\n+\n+    /**\n+     * <p>Gets the short class name for a class.</p>\n+     *\n+     * <p>The short class name is the classname excluding\n+     * the package name.</p>\n+     *\n+     * @param cls  the <code>Class</code> to get the short name of\n+     * @return the short name\n+     */\n+    protected String getShortClassName(Class<?> cls) {\n+        return ClassUtils.getShortClassName(cls);\n+    }\n+\n+    // Setters and getters for the customizable parts of the style\n+    // These methods are not expected to be overridden, except to make public\n+    // (They are not public so that immutable subclasses can be written)\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether to use the class name.</p>\n+     *\n+     * @return the current useClassName flag\n+     */\n+    protected boolean isUseClassName() {\n+        return useClassName;\n+    }\n+\n+    /**\n+     * <p>Sets whether to use the class name.</p>\n+     *\n+     * @param useClassName  the new useClassName flag\n+     */\n+    protected void setUseClassName(boolean useClassName) {\n+        this.useClassName = useClassName;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether to output short or long class names.</p>\n+     *\n+     * @return the current useShortClassName flag\n+     * @since 2.0\n+     */\n+    protected boolean isUseShortClassName() {\n+        return useShortClassName;\n+    }\n+\n+    /**\n+     * <p>Sets whether to output short or long class names.</p>\n+     *\n+     * @param useShortClassName  the new useShortClassName flag\n+     * @since 2.0\n+     */\n+    protected void setUseShortClassName(boolean useShortClassName) {\n+        this.useShortClassName = useShortClassName;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether to use the identity hash code.</p>\n+     *\n+     * @return the current useIdentityHashCode flag\n+     */\n+    protected boolean isUseIdentityHashCode() {\n+        return useIdentityHashCode;\n+    }\n+\n+    /**\n+     * <p>Sets whether to use the identity hash code.</p>\n+     *\n+     * @param useIdentityHashCode  the new useIdentityHashCode flag\n+     */\n+    protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\n+        this.useIdentityHashCode = useIdentityHashCode;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether to use the field names passed in.</p>\n+     *\n+     * @return the current useFieldNames flag\n+     */\n+    protected boolean isUseFieldNames() {\n+        return useFieldNames;\n+    }\n+\n+    /**\n+     * <p>Sets whether to use the field names passed in.</p>\n+     *\n+     * @param useFieldNames  the new useFieldNames flag\n+     */\n+    protected void setUseFieldNames(boolean useFieldNames) {\n+        this.useFieldNames = useFieldNames;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether to use full detail when the caller doesn't\n+     * specify.</p>\n+     *\n+     * @return the current defaultFullDetail flag\n+     */\n+    protected boolean isDefaultFullDetail() {\n+        return defaultFullDetail;\n+    }\n+\n+    /**\n+     * <p>Sets whether to use full detail when the caller doesn't\n+     * specify.</p>\n+     *\n+     * @param defaultFullDetail  the new defaultFullDetail flag\n+     */\n+    protected void setDefaultFullDetail(boolean defaultFullDetail) {\n+        this.defaultFullDetail = defaultFullDetail;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether to output array content detail.</p>\n+     *\n+     * @return the current array content detail setting\n+     */\n+    protected boolean isArrayContentDetail() {\n+        return arrayContentDetail;\n+    }\n+\n+    /**\n+     * <p>Sets whether to output array content detail.</p>\n+     *\n+     * @param arrayContentDetail  the new arrayContentDetail flag\n+     */\n+    protected void setArrayContentDetail(boolean arrayContentDetail) {\n+        this.arrayContentDetail = arrayContentDetail;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the array start text.</p>\n+     *\n+     * @return the current array start text\n+     */\n+    protected String getArrayStart() {\n+        return arrayStart;\n+    }\n+\n+    /**\n+     * <p>Sets the array start text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param arrayStart  the new array start text\n+     */\n+    protected void setArrayStart(String arrayStart) {\n+        if (arrayStart == null) {\n+            arrayStart = \"\";\n+        }\n+        this.arrayStart = arrayStart;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the array end text.</p>\n+     *\n+     * @return the current array end text\n+     */\n+    protected String getArrayEnd() {\n+        return arrayEnd;\n+    }\n+\n+    /**\n+     * <p>Sets the array end text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param arrayEnd  the new array end text\n+     */\n+    protected void setArrayEnd(String arrayEnd) {\n+        if (arrayEnd == null) {\n+            arrayEnd = \"\";\n+        }\n+        this.arrayEnd = arrayEnd;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the array separator text.</p>\n+     *\n+     * @return the current array separator text\n+     */\n+    protected String getArraySeparator() {\n+        return arraySeparator;\n+    }\n+\n+    /**\n+     * <p>Sets the array separator text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param arraySeparator  the new array separator text\n+     */\n+    protected void setArraySeparator(String arraySeparator) {\n+        if (arraySeparator == null) {\n+            arraySeparator = \"\";\n+        }\n+        this.arraySeparator = arraySeparator;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the content start text.</p>\n+     *\n+     * @return the current content start text\n+     */\n+    protected String getContentStart() {\n+        return contentStart;\n+    }\n+\n+    /**\n+     * <p>Sets the content start text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param contentStart  the new content start text\n+     */\n+    protected void setContentStart(String contentStart) {\n+        if (contentStart == null) {\n+            contentStart = \"\";\n+        }\n+        this.contentStart = contentStart;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the content end text.</p>\n+     *\n+     * @return the current content end text\n+     */\n+    protected String getContentEnd() {\n+        return contentEnd;\n+    }\n+\n+    /**\n+     * <p>Sets the content end text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param contentEnd  the new content end text\n+     */\n+    protected void setContentEnd(String contentEnd) {\n+        if (contentEnd == null) {\n+            contentEnd = \"\";\n+        }\n+        this.contentEnd = contentEnd;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the field name value separator text.</p>\n+     *\n+     * @return the current field name value separator text\n+     */\n+    protected String getFieldNameValueSeparator() {\n+        return fieldNameValueSeparator;\n+    }\n+\n+    /**\n+     * <p>Sets the field name value separator text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param fieldNameValueSeparator  the new field name value separator text\n+     */\n+    protected void setFieldNameValueSeparator(String fieldNameValueSeparator) {\n+        if (fieldNameValueSeparator == null) {\n+            fieldNameValueSeparator = \"\";\n+        }\n+        this.fieldNameValueSeparator = fieldNameValueSeparator;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the field separator text.</p>\n+     *\n+     * @return the current field separator text\n+     */\n+    protected String getFieldSeparator() {\n+        return fieldSeparator;\n+    }\n+\n+    /**\n+     * <p>Sets the field separator text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param fieldSeparator  the new field separator text\n+     */\n+    protected void setFieldSeparator(String fieldSeparator) {\n+        if (fieldSeparator == null) {\n+            fieldSeparator = \"\";\n+        }\n+        this.fieldSeparator = fieldSeparator;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether the field separator should be added at the start \n+     * of each buffer.</p>\n+     * \n+     * @return the fieldSeparatorAtStart flag\n+     * @since 2.0\n+     */\n+    protected boolean isFieldSeparatorAtStart() {\n+        return fieldSeparatorAtStart;\n+    }\n+\n+    /**\n+     * <p>Sets whether the field separator should be added at the start \n+     * of each buffer.</p>\n+     * \n+     * @param fieldSeparatorAtStart  the fieldSeparatorAtStart flag\n+     * @since 2.0\n+     */\n+    protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\n+        this.fieldSeparatorAtStart = fieldSeparatorAtStart;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether the field separator should be added at the end \n+     * of each buffer.</p>\n+     * \n+     * @return fieldSeparatorAtEnd flag\n+     * @since 2.0\n+     */\n+    protected boolean isFieldSeparatorAtEnd() {\n+        return fieldSeparatorAtEnd;\n+    }\n+\n+    /**\n+     * <p>Sets whether the field separator should be added at the end \n+     * of each buffer.</p>\n+     * \n+     * @param fieldSeparatorAtEnd  the fieldSeparatorAtEnd flag\n+     * @since 2.0\n+     */\n+    protected void setFieldSeparatorAtEnd(boolean fieldSeparatorAtEnd) {\n+        this.fieldSeparatorAtEnd = fieldSeparatorAtEnd;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the text to output when <code>null</code> found.</p>\n+     *\n+     * @return the current text to output when null found\n+     */\n+    protected String getNullText() {\n+        return nullText;\n+    }\n+\n+    /**\n+     * <p>Sets the text to output when <code>null</code> found.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param nullText  the new text to output when null found\n+     */\n+    protected void setNullText(String nullText) {\n+        if (nullText == null) {\n+            nullText = \"\";\n+        }\n+        this.nullText = nullText;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the start text to output when a <code>Collection</code>,\n+     * <code>Map</code> or array size is output.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * @return the current start of size text\n+     */\n+    protected String getSizeStartText() {\n+        return sizeStartText;\n+    }\n+\n+    /**\n+     * <p>Sets the start text to output when a <code>Collection</code>,\n+     * <code>Map</code> or array size is output.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param sizeStartText  the new start of size text\n+     */\n+    protected void setSizeStartText(String sizeStartText) {\n+        if (sizeStartText == null) {\n+            sizeStartText = \"\";\n+        }\n+        this.sizeStartText = sizeStartText;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the end text to output when a <code>Collection</code>,\n+     * <code>Map</code> or array size is output.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * @return the current end of size text\n+     */\n+    protected String getSizeEndText() {\n+        return sizeEndText;\n+    }\n+\n+    /**\n+     * <p>Sets the end text to output when a <code>Collection</code>,\n+     * <code>Map</code> or array size is output.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param sizeEndText  the new end of size text\n+     */\n+    protected void setSizeEndText(String sizeEndText) {\n+        if (sizeEndText == null) {\n+            sizeEndText = \"\";\n+        }\n+        this.sizeEndText = sizeEndText;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the start text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * @return the current start of summary text\n+     */\n+    protected String getSummaryObjectStartText() {\n+        return summaryObjectStartText;\n+    }\n+\n+    /**\n+     * <p>Sets the start text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param summaryObjectStartText  the new start of summary text\n+     */\n+    protected void setSummaryObjectStartText(String summaryObjectStartText) {\n+        if (summaryObjectStartText == null) {\n+            summaryObjectStartText = \"\";\n+        }\n+        this.summaryObjectStartText = summaryObjectStartText;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the end text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * @return the current end of summary text\n+     */\n+    protected String getSummaryObjectEndText() {\n+        return summaryObjectEndText;\n+    }\n+\n+    /**\n+     * <p>Sets the end text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param summaryObjectEndText  the new end of summary text\n+     */\n+    protected void setSummaryObjectEndText(String summaryObjectEndText) {\n+        if (summaryObjectEndText == null) {\n+            summaryObjectEndText = \"\";\n+        }\n+        this.summaryObjectEndText = summaryObjectEndText;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Default <code>ToStringStyle</code>.</p>\n+     *\n+     * <p>This is an inner class rather than using\n+     * <code>StandardToStringStyle</code> to ensure its immutability.</p>\n+     */\n+    private static final class DefaultToStringStyle extends ToStringStyle {\n+\n+        /**\n+         * Required for serialization support.\n+         * \n+         * @see java.io.Serializable\n+         */\n+        private static final long serialVersionUID = 1L;\n+\n+        /**\n+         * <p>Constructor.</p>\n+         *\n+         * <p>Use the static constant rather than instantiating.</p>\n+         */\n+        DefaultToStringStyle() {\n+            super();\n+        }\n+\n+        /**\n+         * <p>Ensure <code>Singleton</code> after serialization.</p>\n+         *\n+         * @return the singleton\n+         */\n+        private Object readResolve() {\n+            return ToStringStyle.DEFAULT_STYLE;\n+        }\n+\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p><code>ToStringStyle</code> that does not print out\n+     * the field names.</p>\n+     *\n+     * <p>This is an inner class rather than using\n+     * <code>StandardToStringStyle</code> to ensure its immutability.\n+     */\n+    private static final class NoFieldNameToStringStyle extends ToStringStyle {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        /**\n+         * <p>Constructor.</p>\n+         *\n+         * <p>Use the static constant rather than instantiating.</p>\n+         */\n+        NoFieldNameToStringStyle() {\n+            super();\n+            this.setUseFieldNames(false);\n+        }\n+\n+        /**\n+         * <p>Ensure <code>Singleton</code> after serialization.</p>\n+         *\n+         * @return the singleton\n+         */\n+        private Object readResolve() {\n+            return ToStringStyle.NO_FIELD_NAMES_STYLE;\n+        }\n+\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * <p><code>ToStringStyle</code> that prints out the short\n+     * class name and no identity hashcode.</p>\n+     *\n+     * <p>This is an inner class rather than using\n+     * <code>StandardToStringStyle</code> to ensure its immutability.</p>\n+     */\n+    private static final class ShortPrefixToStringStyle extends ToStringStyle {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        /**\n+         * <p>Constructor.</p>\n+         *\n+         * <p>Use the static constant rather than instantiating.</p>\n+         */\n+        ShortPrefixToStringStyle() {\n+            super();\n+            this.setUseShortClassName(true);\n+            this.setUseIdentityHashCode(false);\n+        }\n+\n+        /**\n+         * <p>Ensure <code>Singleton</ode> after serialization.</p>\n+         * @return the singleton\n+         */\n+        private Object readResolve() {\n+            return ToStringStyle.SHORT_PREFIX_STYLE;\n+        }\n+\n+    }\n+\n+    /**\n+     * <p><code>ToStringStyle</code> that does not print out the\n+     * classname, identity hashcode, content start or field name.</p>\n+     *\n+     * <p>This is an inner class rather than using\n+     * <code>StandardToStringStyle</code> to ensure its immutability.</p>\n+     */\n+    private static final class SimpleToStringStyle extends ToStringStyle {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        /**\n+         * <p>Constructor.</p>\n+         *\n+         * <p>Use the static constant rather than instantiating.</p>\n+         */\n+        SimpleToStringStyle() {\n+            super();\n+            this.setUseClassName(false);\n+            this.setUseIdentityHashCode(false);\n+            this.setUseFieldNames(false);\n+            this.setContentStart(\"\");\n+            this.setContentEnd(\"\");\n+        }\n+\n+        /**\n+         * <p>Ensure <code>Singleton</ode> after serialization.</p>\n+         * @return the singleton\n+         */\n+        private Object readResolve() {\n+            return ToStringStyle.SIMPLE_STYLE;\n+        }\n+\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p><code>ToStringStyle</code> that outputs on multiple lines.</p>\n+     *\n+     * <p>This is an inner class rather than using\n+     * <code>StandardToStringStyle</code> to ensure its immutability.</p>\n+     */\n+    private static final class MultiLineToStringStyle extends ToStringStyle {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        /**\n+         * <p>Constructor.</p>\n+         *\n+         * <p>Use the static constant rather than instantiating.</p>\n+         */\n+        MultiLineToStringStyle() {\n+            super();\n+            this.setContentStart(\"[\");\n+            this.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\n+            this.setFieldSeparatorAtStart(true);\n+            this.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n+        }\n+\n+        /**\n+         * <p>Ensure <code>Singleton</code> after serialization.</p>\n+         *\n+         * @return the singleton\n+         */\n+        private Object readResolve() {\n+            return ToStringStyle.MULTI_LINE_STYLE;\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/concurrent/BackgroundInitializer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.concurrent;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * <p>\n+ * A class that allows complex initialization operations in a background task.\n+ * </p>\n+ * <p>\n+ * Applications often have to do some expensive initialization steps when they\n+ * are started, e.g. constructing a connection to a database, reading a\n+ * configuration file, etc. Doing these things in parallel can enhance\n+ * performance as the CPU load can be improved. However, when access to the\n+ * resources initialized in a background thread is actually required,\n+ * synchronization has to be performed to ensure that their initialization is\n+ * complete.\n+ * </p>\n+ * <p>\n+ * This abstract base class provides support for this use case. A concrete\n+ * subclass must implement the {@link #initialize()} method. Here an arbitrary\n+ * initialization can be implemented, and a result object can be returned. With\n+ * this method in place the basic usage of this class is as follows (where\n+ * {@code MyBackgroundInitializer} is a concrete subclass):\n+ *\n+ * <pre>\n+ * MyBackgroundInitializer initializer = new MyBackgroundInitializer();\n+ * initializer.start();\n+ * // Now do some other things. Initialization runs in a parallel thread\n+ * ...\n+ * // Wait for the end of initialization and access the result object\n+ * Object result = initializer.get();\n+ * </pre>\n+ *\n+ * </p>\n+ * <p>\n+ * After the construction of a {@code BackgroundInitializer} object its\n+ * {@link #start()} method has to be called. This starts the background\n+ * processing. The application can now continue to do other things. When it\n+ * needs access to the object produced by the {@code BackgroundInitializer} it\n+ * calls its {@link #get()} method. If initialization is already complete,\n+ * {@link #get()} returns the result object immediately. Otherwise it blocks\n+ * until the result object is fully constructed.\n+ * </p>\n+ * <p>\n+ * {@code BackgroundInitializer} is a thin wrapper around a {@code Future}\n+ * object and uses an {@code ExecutorService} for running the background\n+ * initialization task. It is possible to pass in an {@code ExecutorService} at\n+ * construction time or set one using {@code setExternalExecutor()} before\n+ * {@code start()} was called. Then this object is used to spawn the background\n+ * task. If no {@code ExecutorService} has been provided, {@code\n+ * BackgroundInitializer} creates a temporary {@code ExecutorService} and\n+ * destroys it when initialization is complete.\n+ * </p>\n+ * <p>\n+ * The methods provided by {@code BackgroundInitializer} provide for minimal\n+ * interaction with the wrapped {@code Future} object. It is also possible to\n+ * obtain the {@code Future} object directly. Then the enhanced functionality\n+ * offered by {@code Future} can be used, e.g. to check whether the background\n+ * operation is complete or to cancel the operation.\n+ * </p>\n+ *\n+ * @version $Id$\n+ * @param <T> the type of the object managed by this initializer class\n+ */\n+public abstract class BackgroundInitializer<T> {\n+    /** The external executor service for executing tasks. */\n+    private ExecutorService externalExecutor;\n+\n+    /** A reference to the executor service that is actually used. */\n+    private ExecutorService executor;\n+\n+    /** Stores the handle to the background task. */\n+    private Future<T> future;\n+\n+    /**\n+     * Creates a new instance of {@code BackgroundInitializer}. No external\n+     * {@code ExecutorService} is used.\n+     */\n+    protected BackgroundInitializer() {\n+        this(null);\n+    }\n+\n+    /**\n+     * Creates a new instance of {@code BackgroundInitializer} and initializes\n+     * it with the given {@code ExecutorService}. If the {@code ExecutorService}\n+     * is not null, the background task for initializing this object will be\n+     * scheduled at this service. Otherwise a new temporary {@code\n+     * ExecutorService} is created.\n+     *\n+     * @param exec an external {@code ExecutorService} to be used for task\n+     * execution\n+     */\n+    protected BackgroundInitializer(ExecutorService exec) {\n+        setExternalExecutor(exec);\n+    }\n+\n+    /**\n+     * Returns the external {@code ExecutorService} to be used by this class.\n+     *\n+     * @return the {@code ExecutorService}\n+     */\n+    public final synchronized ExecutorService getExternalExecutor() {\n+        return externalExecutor;\n+    }\n+\n+    /**\n+     * Returns a flag whether this {@code BackgroundInitializer} has already\n+     * been started.\n+     *\n+     * @return a flag whether the {@link #start()} method has already been\n+     * called\n+     */\n+    public synchronized boolean isStarted() {\n+        return future != null;\n+    }\n+\n+    /**\n+     * Sets an {@code ExecutorService} to be used by this class. The {@code\n+     * ExecutorService} passed to this method is used for executing the\n+     * background task. Thus it is possible to re-use an already existing\n+     * {@code ExecutorService} or to use a specially configured one. If no\n+     * {@code ExecutorService} is set, this instance creates a temporary one and\n+     * destroys it after background initialization is complete. Note that this\n+     * method must be called before {@link #start()}; otherwise an exception is\n+     * thrown.\n+     *\n+     * @param externalExecutor the {@code ExecutorService} to be used\n+     * @throws IllegalStateException if this initializer has already been\n+     * started\n+     */\n+    public final synchronized void setExternalExecutor(\n+            ExecutorService externalExecutor) {\n+        if (isStarted()) {\n+            throw new IllegalStateException(\n+                    \"Cannot set ExecutorService after start()!\");\n+        }\n+\n+        this.externalExecutor = externalExecutor;\n+    }\n+\n+    /**\n+     * Starts the background initialization. With this method the initializer\n+     * becomes active and invokes the {@link #initialize()} method in a\n+     * background task. A {@code BackgroundInitializer} can be started exactly\n+     * once. The return value of this method determines whether the start was\n+     * successful: only the first invocation of this method returns <b>true</b>,\n+     * following invocations will return <b>false</b>.\n+     *\n+     * @return a flag whether the initializer could be started successfully\n+     */\n+    public synchronized boolean start() {\n+        // Not yet started?\n+        if (!isStarted()) {\n+\n+            // Determine the executor to use and whether a temporary one has to\n+            // be created\n+            ExecutorService tempExec;\n+            executor = getExternalExecutor();\n+            if (executor == null) {\n+                executor = tempExec = createExecutor();\n+            } else {\n+                tempExec = null;\n+            }\n+\n+            future = executor.submit(createTask(tempExec));\n+\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Returns the result of the background initialization. This method blocks\n+     * until initialization is complete. If the background processing caused a\n+     * runtime exception, it is directly thrown by this method. Checked\n+     * exceptions, including {@code InterruptedException} are wrapped in a\n+     * {@link ConcurrentException}. Calling this method before {@link #start()}\n+     * was called causes an {@code IllegalStateException} exception to be\n+     * thrown.\n+     *\n+     * @return the object produced by this initializer\n+     * @throws ConcurrentException if a checked exception occurred during\n+     * background processing\n+     * @throws IllegalStateException if {@link #start()} has not been called\n+     */\n+    public T get() throws ConcurrentException {\n+        try {\n+            return getFuture().get();\n+        } catch (ExecutionException execex) {\n+            ConcurrentUtils.handleCause(execex);\n+            return null; // should not be reached\n+        } catch (InterruptedException iex) {\n+            // reset interrupted state\n+            Thread.currentThread().interrupt();\n+            throw new ConcurrentException(iex);\n+        }\n+    }\n+\n+    /**\n+     * Returns the {@code Future} object that was created when {@link #start()}\n+     * was called. Therefore this method can only be called after {@code\n+     * start()}.\n+     *\n+     * @return the {@code Future} object wrapped by this initializer\n+     * @throws IllegalStateException if {@link #start()} has not been called\n+     */\n+    public synchronized Future<T> getFuture() {\n+        if (future == null) {\n+            throw new IllegalStateException(\"start() must be called first!\");\n+        }\n+\n+        return future;\n+    }\n+\n+    /**\n+     * Returns the {@code ExecutorService} that is actually used for executing\n+     * the background task. This method can be called after {@link #start()}\n+     * (before {@code start()} it returns <b>null</b>). If an external executor\n+     * was set, this is also the active executor. Otherwise this method returns\n+     * the temporary executor that was created by this object.\n+     *\n+     * @return the {@code ExecutorService} for executing the background task\n+     */\n+    protected synchronized final ExecutorService getActiveExecutor() {\n+        return executor;\n+    }\n+\n+    /**\n+     * Returns the number of background tasks to be created for this\n+     * initializer. This information is evaluated when a temporary {@code\n+     * ExecutorService} is created. This base implementation returns 1. Derived\n+     * classes that do more complex background processing can override it. This\n+     * method is called from a synchronized block by the {@link #start()}\n+     * method. Therefore overriding methods should be careful with obtaining\n+     * other locks and return as fast as possible.\n+     *\n+     * @return the number of background tasks required by this initializer\n+     */\n+    protected int getTaskCount() {\n+        return 1;\n+    }\n+\n+    /**\n+     * Performs the initialization. This method is called in a background task\n+     * when this {@code BackgroundInitializer} is started. It must be\n+     * implemented by a concrete subclass. An implementation is free to perform\n+     * arbitrary initialization. The object returned by this method can be\n+     * queried using the {@link #get()} method.\n+     *\n+     * @return a result object\n+     * @throws Exception if an error occurs\n+     */\n+    protected abstract T initialize() throws Exception;\n+\n+    /**\n+     * Creates a task for the background initialization. The {@code Callable}\n+     * object returned by this method is passed to the {@code ExecutorService}.\n+     * This implementation returns a task that invokes the {@link #initialize()}\n+     * method. If a temporary {@code ExecutorService} is used, it is destroyed\n+     * at the end of the task.\n+     *\n+     * @param execDestroy the {@code ExecutorService} to be destroyed by the\n+     * task\n+     * @return a task for the background initialization\n+     */\n+    private Callable<T> createTask(ExecutorService execDestroy) {\n+        return new InitializationTask(execDestroy);\n+    }\n+\n+    /**\n+     * Creates the {@code ExecutorService} to be used. This method is called if\n+     * no {@code ExecutorService} was provided at construction time.\n+     *\n+     * @return the {@code ExecutorService} to be used\n+     */\n+    private ExecutorService createExecutor() {\n+        return Executors.newFixedThreadPool(getTaskCount());\n+    }\n+\n+    private class InitializationTask implements Callable<T> {\n+        /** Stores the executor service to be destroyed at the end. */\n+        private final ExecutorService execFinally;\n+\n+        /**\n+         * Creates a new instance of {@code InitializationTask} and initializes\n+         * it with the {@code ExecutorService} to be destroyed at the end.\n+         *\n+         * @param exec the {@code ExecutorService}\n+         */\n+        public InitializationTask(ExecutorService exec) {\n+            execFinally = exec;\n+        }\n+\n+        /**\n+         * Initiates initialization and returns the result.\n+         *\n+         * @return the result object\n+         * @throws Exception if an error occurs\n+         */\n+        public T call() throws Exception {\n+            try {\n+                return initialize();\n+            } finally {\n+                if (execFinally != null) {\n+                    execFinally.shutdown();\n+                }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/concurrent/CallableBackgroundInitializer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.concurrent;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+\n+/**\n+ * <p>\n+ * A specialized {@link BackgroundInitializer} implementation that wraps a\n+ * {@code Callable} object.\n+ * </p>\n+ * <p>\n+ * An instance of this class is initialized with a {@code Callable} object when\n+ * it is constructed. The implementation of the {@link #initialize()} method\n+ * defined in the super class delegates to this {@code Callable} so that the\n+ * {@code Callable} is executed in the background thread.\n+ * </p>\n+ * <p>\n+ * The {@code java.util.concurrent.Callable} interface is a standard mechanism\n+ * of the JDK to define tasks to be executed by another thread. The {@code\n+ * CallableBackgroundInitializer} class allows combining this standard interface\n+ * with the background initializer API.\n+ * </p>\n+ * <p>\n+ * Usage of this class is very similar to the default usage pattern of the\n+ * {@link BackgroundInitializer} class: Just create an instance and provide the\n+ * {@code Callable} object to be executed, then call the initializer's\n+ * {@link #start()} method. This causes the {@code Callable} to be executed in\n+ * another thread. When the results of the {@code Callable} are needed the\n+ * initializer's {@link #get()} method can be called (which may block until\n+ * background execution is complete). The following code fragment shows a\n+ * typical usage example:\n+ *\n+ * <pre>\n+ * // a Callable that performs a complex computation\n+ * Callable&lt;Integer&gt; computationCallable = new MyComputationCallable();\n+ * // setup the background initializer\n+ * CallableBackgroundInitializer&lt;Integer&gt; initializer =\n+ *     new CallableBackgroundInitializer(computationCallable);\n+ * initializer.start();\n+ * // Now do some other things. Initialization runs in a parallel thread\n+ * ...\n+ * // Wait for the end of initialization and access the result\n+ * Integer result = initializer.get();\n+ * </pre>\n+ *\n+ * </p>\n+ *\n+ * @version $Id$\n+ * @param <T> the type of the object managed by this initializer class\n+ */\n+public class CallableBackgroundInitializer<T> extends BackgroundInitializer<T> {\n+    /** The Callable to be executed. */\n+    private final Callable<T> callable;\n+\n+    /**\n+     * Creates a new instance of {@code CallableBackgroundInitializer} and sets\n+     * the {@code Callable} to be executed in a background thread.\n+     *\n+     * @param call the {@code Callable} (must not be <b>null</b>)\n+     * @throws IllegalArgumentException if the {@code Callable} is <b>null</b>\n+     */\n+    public CallableBackgroundInitializer(Callable<T> call) {\n+        checkCallable(call);\n+        callable = call;\n+    }\n+\n+    /**\n+     * Creates a new instance of {@code CallableBackgroundInitializer} and\n+     * initializes it with the {@code Callable} to be executed in a background\n+     * thread and the {@code ExecutorService} for managing the background\n+     * execution.\n+     *\n+     * @param call the {@code Callable} (must not be <b>null</b>)\n+     * @param exec an external {@code ExecutorService} to be used for task\n+     * execution\n+     * @throws IllegalArgumentException if the {@code Callable} is <b>null</b>\n+     */\n+    public CallableBackgroundInitializer(Callable<T> call, ExecutorService exec) {\n+        super(exec);\n+        checkCallable(call);\n+        callable = call;\n+    }\n+\n+    /**\n+     * Performs initialization in a background thread. This implementation\n+     * delegates to the {@code Callable} passed at construction time of this\n+     * object.\n+     *\n+     * @return the result of the initialization\n+     * @throws Exception if an error occurs\n+     */\n+    @Override\n+    protected T initialize() throws Exception {\n+        return callable.call();\n+    }\n+\n+    /**\n+     * Tests the passed in {@code Callable} and throws an exception if it is\n+     * undefined.\n+     *\n+     * @param call the object to check\n+     * @throws IllegalArgumentException if the {@code Callable} is <b>null</b>\n+     */\n+    private void checkCallable(Callable<T> call) {\n+        if (call == null) {\n+            throw new IllegalArgumentException(\"Callable must not be null!\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/concurrent/ConcurrentException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.concurrent;\n+\n+/**\n+ * <p>\n+ * An exception class used for reporting error conditions related to accessing\n+ * data of background tasks.\n+ * </p>\n+ * <p>\n+ * The purpose of this exception class is analogous to the default JDK exception\n+ * class {@link java.util.concurrent.ExecutionException}, i.e. it wraps an\n+ * exception that occurred during the execution of a task. However, in contrast\n+ * to {@code ExecutionException}, it wraps only checked exceptions. Runtime\n+ * exceptions are thrown directly.\n+ * </p>\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class ConcurrentException extends Exception {\n+    /**\n+     * The serial version UID.\n+     */\n+    private static final long serialVersionUID = 6622707671812226130L;\n+\n+    /**\n+     * Creates a new, uninitialized instance of {@code ConcurrentException}.\n+     */\n+    protected ConcurrentException() {\n+        super();\n+    }\n+\n+    /**\n+     * Creates a new instance of {@code ConcurrentException} and initializes it\n+     * with the given cause.\n+     *\n+     * @param cause the cause of this exception\n+     * @throws IllegalArgumentException if the cause is not a checked exception\n+     */\n+    public ConcurrentException(Throwable cause) {\n+        super(ConcurrentUtils.checkedException(cause));\n+    }\n+\n+    /**\n+     * Creates a new instance of {@code ConcurrentException} and initializes it\n+     * with the given message and cause.\n+     *\n+     * @param msg the error message\n+     * @param cause the cause of this exception\n+     * @throws IllegalArgumentException if the cause is not a checked exception\n+     */\n+    public ConcurrentException(String msg, Throwable cause) {\n+        super(msg, ConcurrentUtils.checkedException(cause));\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/concurrent/ConcurrentUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.concurrent;\n+\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * <p>\n+ * An utility class providing functionality related to the {@code\n+ * java.util.concurrent} package.\n+ * </p>\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class ConcurrentUtils {\n+\n+    /**\n+     * Private constructor so that no instances can be created. This class\n+     * contains only static utility methods.\n+     */\n+    private ConcurrentUtils() {\n+    }\n+\n+    /**\n+     * Inspects the cause of the specified {@code ExecutionException} and\n+     * creates a {@code ConcurrentException} with the checked cause if\n+     * necessary. This method performs the following checks on the cause of the\n+     * passed in exception:\n+     * <ul>\n+     * <li>If the passed in exception is <b>null</b> or the cause is\n+     * <b>null</b>, this method returns <b>null</b>.</li>\n+     * <li>If the cause is a runtime exception, it is directly thrown.</li>\n+     * <li>If the cause is an error, it is directly thrown, too.</li>\n+     * <li>In any other case the cause is a checked exception. The method then\n+     * creates a {@link ConcurrentException}, initializes it with the cause, and\n+     * returns it.</li>\n+     * </ul>\n+     *\n+     * @param ex the exception to be processed\n+     * @return a {@code ConcurrentException} with the checked cause\n+     */\n+    public static ConcurrentException extractCause(ExecutionException ex) {\n+        if (ex == null || ex.getCause() == null) {\n+            return null;\n+        }\n+\n+        throwCause(ex);\n+        return new ConcurrentException(ex.getMessage(), ex.getCause());\n+    }\n+\n+    /**\n+     * Handles the specified {@code ExecutionException}. This method calls\n+     * {@link #extractCause(ExecutionException)} for obtaining the cause of the\n+     * exception - which might already cause an unchecked exception or an error\n+     * being thrown. If the cause is a checked exception however, it is wrapped\n+     * in a {@code ConcurrentException}, which is thrown. If the passed in\n+     * exception is <b>null</b> or has no cause, the method simply returns\n+     * without throwing an exception.\n+     *\n+     * @param ex the exception to be handled\n+     * @throws ConcurrentException if the cause of the {@code\n+     * ExecutionException} is a checked exception\n+     */\n+    public static void handleCause(ExecutionException ex)\n+            throws ConcurrentException {\n+        ConcurrentException cex = extractCause(ex);\n+\n+        if (cex != null) {\n+            throw cex;\n+        }\n+    }\n+\n+    /**\n+     * Tests whether the specified {@code Throwable} is a checked exception. If\n+     * not, an exception is thrown.\n+     *\n+     * @param ex the {@code Throwable} to check\n+     * @return a flag whether the passed in exception is a checked exception\n+     * @throws IllegalArgumentException if the {@code Throwable} is not a\n+     * checked exception\n+     */\n+    static Throwable checkedException(Throwable ex) {\n+        if (ex != null && !(ex instanceof RuntimeException)\n+                && !(ex instanceof Error)) {\n+            return ex;\n+        } else {\n+            throw new IllegalArgumentException(\"Not a checked exception: \" + ex);\n+        }\n+    }\n+\n+    /**\n+     * Tests whether the cause of the specified {@code ExecutionException}\n+     * should be thrown and does it if necessary.\n+     *\n+     * @param ex the exception in question\n+     */\n+    private static void throwCause(ExecutionException ex) {\n+        if (ex.getCause() instanceof RuntimeException) {\n+            throw (RuntimeException) ex.getCause();\n+        }\n+\n+        if (ex.getCause() instanceof Error) {\n+            throw (Error) ex.getCause();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>\n+     * Gets an implementation of <code>Future</code> that is immediately done\n+     * and returns the specified constant value.\n+     * </p>\n+     * <p>\n+     * This can be useful to return a simple constant immediately from the\n+     * concurrent processing, perhaps as part of avoiding nulls.\n+     * A constant future can also be useful in testing.\n+     * </p>\n+     * \n+     * @param value  the constant value to return, may be null\n+     * @return an instance of Future that will return the value, never null\n+     */\n+    public static <T> Future<T> constantFuture(T value) {\n+        return new ConstantFuture<T>(value);\n+    }\n+\n+    static final class ConstantFuture<T> implements Future<T> {\n+        /** The constant value. */\n+        private final T value;\n+\n+        ConstantFuture(T value) {\n+            this.value = value;\n+        }\n+\n+        public boolean isDone() {\n+            return true;\n+        }\n+\n+        public T get() {\n+            return value;\n+        }\n+\n+        public T get(long timeout, TimeUnit unit) {\n+            return value;\n+        }\n+\n+        public boolean isCancelled() {\n+            return false;\n+        }\n+\n+        public boolean cancel(boolean mayInterruptIfRunning) {\n+            return false;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/concurrent/LazyInitializer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.concurrent;\n+\n+/**\n+ * <p>\n+ * This class provides a generic implementation of the lazy initialization\n+ * pattern.\n+ * </p>\n+ * <p>\n+ * Sometimes an application has to deal with an object only under certain\n+ * circumstances, e.g. when the user selects a specific menu item or if a\n+ * special event is received. If the creation of the object is costly or the\n+ * consumption of memory or other system resources is significant, it may make\n+ * sense to defer the creation of this object until it is really needed. This is\n+ * a use case for the lazy initialization pattern.\n+ * </p>\n+ * <p>\n+ * This abstract base class provides an implementation of the double-check idiom\n+ * for an instance field as discussed in Joshua Bloch's \"Effective Java\", 2nd\n+ * edition, item 71. The class already implements all necessary synchronization.\n+ * A concrete subclass has to implement the {@code initialize()} method, which\n+ * actually creates the wrapped data object.\n+ * </p>\n+ * <p>\n+ * As an usage example consider that we have a class {@code ComplexObject} whose\n+ * instantiation is a complex operation. In order to apply lazy initialization\n+ * to this class, a subclass of {@code LazyInitializer} has to be created:\n+ *\n+ * <pre>\n+ * public class ComplexObjectInitializer extends LazyInitializer&lt;ComplexObject&gt; {\n+ *     &#064;Override\n+ *     protected ComplexObject initialize() {\n+ *         return new ComplexObject();\n+ *     }\n+ * }\n+ * </pre>\n+ *\n+ * Access to the data object is provided through the {@code get()} method. So,\n+ * code that wants to obtain the {@code ComplexObject} instance would simply\n+ * look like this:\n+ *\n+ * <pre>\n+ * // Create an instance of the lazy initializer\n+ * ComplexObjectInitializer initializer = new ComplexObjectInitializer();\n+ * ...\n+ * // When the object is actually needed:\n+ * ComplexObject cobj = initializer.get();\n+ * </pre>\n+ *\n+ * </p>\n+ * <p>\n+ * If multiple threads call the {@code get()} method when the object has not yet\n+ * been created, they are blocked until initialization completes. The algorithm\n+ * guarantees that only a single instance of the wrapped object class is\n+ * created, which is passed to all callers. Once initialized, calls to the\n+ * {@code get()} method are pretty fast because no synchronization is needed\n+ * (only an access to a <b>volatile</b> member field).\n+ * </p>\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ * @param <T> the type of the object managed by this initializer class\n+ */\n+public abstract class LazyInitializer<T> {\n+    /** Stores the managed object. */\n+    private volatile T object;\n+\n+    /**\n+     * Returns the object wrapped by this instance. On first access the object\n+     * is created. After that it is cached and can be accessed pretty fast.\n+     *\n+     * @return the object initialized by this {@code LazyInitializer}\n+     */\n+    public T get() {\n+        // use a temporary variable to reduce the number of reads of the\n+        // volatile field\n+        T result = object;\n+\n+        if (result == null) {\n+            synchronized (this) {\n+                result = object;\n+                if (result == null) {\n+                    object = result = initialize();\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Creates and initializes the object managed by this {@code\n+     * LazyInitializer}. This method is called by {@link #get()} when the object\n+     * is accessed for the first time. An implementation can focus on the\n+     * creation of the object. No synchronization is needed, as this is already\n+     * handled by {@code get()}.\n+     *\n+     * @return the managed data object\n+     */\n+    protected abstract T initialize();\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.concurrent;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+/**\n+ * <p>\n+ * A specialized {@link BackgroundInitializer} implementation that can deal with\n+ * multiple background initialization tasks.\n+ * </p>\n+ * <p>\n+ * This class has a similar purpose as {@link BackgroundInitializer}. However,\n+ * it is not limited to a single background initialization task. Rather it\n+ * manages an arbitrary number of {@code BackgroundInitializer} objects,\n+ * executes them, and waits until they are completely initialized. This is\n+ * useful for applications that have to perform multiple initialization tasks\n+ * that can run in parallel (i.e. that do not depend on each other). This class\n+ * takes care about the management of an {@code ExecutorService} and shares it\n+ * with the {@code BackgroundInitializer} objects it is responsible for; so the\n+ * using application need not bother with these details.\n+ * </p>\n+ * <p>\n+ * The typical usage scenario for {@code MultiBackgroundInitializer} is as\n+ * follows:\n+ * <ul>\n+ * <li>Create a new instance of the class. Optionally pass in a pre-configured\n+ * {@code ExecutorService}. Alternatively {@code MultiBackgroundInitializer} can\n+ * create a temporary {@code ExecutorService} and delete it after initialization\n+ * is complete.</li>\n+ * <li>Create specialized {@link BackgroundInitializer} objects for the\n+ * initialization tasks to be performed and add them to the {@code\n+ * MultiBackgroundInitializer} using the\n+ * {@link #addInitializer(String, BackgroundInitializer)} method.</li>\n+ * <li>After all initializers have been added, call the {@link #start()} method.\n+ * </li>\n+ * <li>When access to the result objects produced by the {@code\n+ * BackgroundInitializer} objects is needed call the {@link #get()} method. The\n+ * object returned here provides access to all result objects created during\n+ * initialization. It also stores information about exceptions that have\n+ * occurred.</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * {@code MultiBackgroundInitializer} starts a special controller task that\n+ * starts all {@code BackgroundInitializer} objects added to the instance.\n+ * Before the an initializer is started it is checked whether this initializer\n+ * already has an {@code ExecutorService} set. If this is the case, this {@code\n+ * ExecutorService} is used for running the background task. Otherwise the\n+ * current {@code ExecutorService} of this {@code MultiBackgroundInitializer} is\n+ * shared with the initializer.\n+ * </p>\n+ * <p>\n+ * The easiest way of using this class is to let it deal with the management of\n+ * an {@code ExecutorService} itself: If no external {@code ExecutorService} is\n+ * provided, the class creates a temporary {@code ExecutorService} (that is\n+ * capable of executing all background tasks in parallel) and destroys it at the\n+ * end of background processing.\n+ * </p>\n+ * <p>\n+ * Alternatively an external {@code ExecutorService} can be provided - either at\n+ * construction time or later by calling the\n+ * {@link #setExternalExecutor(ExecutorService)} method. In this case all\n+ * background tasks are scheduled at this external {@code ExecutorService}.\n+ * <strong>Important note:</strong> When using an external {@code\n+ * ExecutorService} be sure that the number of threads managed by the service is\n+ * large enough. Otherwise a deadlock can happen! This is the case in the\n+ * following scenario: {@code MultiBackgroundInitializer} starts a task that\n+ * starts all registered {@code BackgroundInitializer} objects and waits for\n+ * their completion. If for instance a single threaded {@code ExecutorService}\n+ * is used, none of the background tasks can be executed, and the task created\n+ * by {@code MultiBackgroundInitializer} waits forever.\n+ * </p>\n+ *\n+ * @version $Id$\n+ */\n+public class MultiBackgroundInitializer\n+        extends\n+        BackgroundInitializer<MultiBackgroundInitializer.MultiBackgroundInitializerResults> {\n+    /** A map with the child initializers. */\n+    private final Map<String, BackgroundInitializer<?>> childInitializers = new HashMap<String, BackgroundInitializer<?>>();\n+\n+    /**\n+     * Creates a new instance of {@code MultiBackgroundInitializer}.\n+     */\n+    public MultiBackgroundInitializer() {\n+        super();\n+    }\n+\n+    /**\n+     * Creates a new instance of {@code MultiBackgroundInitializer} and\n+     * initializes it with the given external {@code ExecutorService}.\n+     *\n+     * @param exec the {@code ExecutorService} for executing the background\n+     * tasks\n+     */\n+    public MultiBackgroundInitializer(ExecutorService exec) {\n+        super(exec);\n+    }\n+\n+    /**\n+     * Adds a new {@code BackgroundInitializer} to this object. When this\n+     * {@code MultiBackgroundInitializer} is started, the given initializer will\n+     * be processed. This method must not be called after {@link #start()} has\n+     * been invoked.\n+     *\n+     * @param name the name of the initializer (must not be <b>null</b>)\n+     * @param init the {@code BackgroundInitializer} to add (must not be\n+     * <b>null</b>)\n+     * @throws IllegalArgumentException if a required parameter is missing\n+     * @throws IllegalStateException if {@code start()} has already been called\n+     */\n+    public void addInitializer(String name, BackgroundInitializer<?> init) {\n+        if (name == null) {\n+            throw new IllegalArgumentException(\n+                    \"Name of child initializer must not be null!\");\n+        }\n+        if (init == null) {\n+            throw new IllegalArgumentException(\n+                    \"Child initializer must not be null!\");\n+        }\n+\n+        synchronized (this) {\n+            if (isStarted()) {\n+                throw new IllegalStateException(\n+                        \"addInitializer() must not be called after start()!\");\n+            }\n+            childInitializers.put(name, init);\n+        }\n+    }\n+\n+    /**\n+     * Returns the number of tasks needed for executing all child {@code\n+     * BackgroundInitializer} objects in parallel. This implementation sums up\n+     * the required tasks for all child initializers (which is necessary if one\n+     * of the child initializers is itself a {@code MultiBackgroundInitializer}\n+     * ). Then it adds 1 for the control task that waits for the completion of\n+     * the children.\n+     *\n+     * @return the number of tasks required for background processing\n+     */\n+    @Override\n+    protected int getTaskCount() {\n+        int result = 1;\n+\n+        for (BackgroundInitializer<?> bi : childInitializers.values()) {\n+            result += bi.getTaskCount();\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Creates the results object. This implementation starts all child {@code\n+     * BackgroundInitializer} objects. Then it collects their results and\n+     * creates a {@code MultiBackgroundInitializerResults} object with this\n+     * data. If a child initializer throws a checked exceptions, it is added to\n+     * the results object. Unchecked exceptions are propagated.\n+     *\n+     * @return the results object\n+     * @throws Exception if an error occurs\n+     */\n+    @Override\n+    protected MultiBackgroundInitializerResults initialize() throws Exception {\n+        Map<String, BackgroundInitializer<?>> inits;\n+        synchronized (this) {\n+            // create a snapshot to operate on\n+            inits = new HashMap<String, BackgroundInitializer<?>>(\n+                    childInitializers);\n+        }\n+\n+        // start the child initializers\n+        ExecutorService exec = getActiveExecutor();\n+        for (BackgroundInitializer<?> bi : inits.values()) {\n+            if (bi.getExternalExecutor() == null) {\n+                // share the executor service if necessary\n+                bi.setExternalExecutor(exec);\n+            }\n+            bi.start();\n+        }\n+\n+        // collect the results\n+        Map<String, Object> results = new HashMap<String, Object>();\n+        Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>();\n+        for (Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) {\n+            try {\n+                results.put(e.getKey(), e.getValue().get());\n+            } catch (ConcurrentException cex) {\n+                excepts.put(e.getKey(), cex);\n+            }\n+        }\n+\n+        return new MultiBackgroundInitializerResults(inits, results, excepts);\n+    }\n+\n+    /**\n+     * A data class for storing the results of the background initialization\n+     * performed by {@code MultiBackgroundInitializer}. Objects of this inner\n+     * class are returned by {@link MultiBackgroundInitializer#initialize()}.\n+     * They allow access to all result objects produced by the\n+     * {@link BackgroundInitializer} objects managed by the owning instance. It\n+     * is also possible to retrieve status information about single\n+     * {@link BackgroundInitializer}s, i.e. whether they completed normally or\n+     * caused an exception.\n+     */\n+    public static class MultiBackgroundInitializerResults {\n+        /** A map with the child initializers. */\n+        private final Map<String, BackgroundInitializer<?>> initializers;\n+\n+        /** A map with the result objects. */\n+        private final Map<String, Object> resultObjects;\n+\n+        /** A map with the exceptions. */\n+        private final Map<String, ConcurrentException> exceptions;\n+\n+        /**\n+         * Creates a new instance of {@code MultiBackgroundInitializerResults}\n+         * and initializes it with maps for the {@code BackgroundInitializer}\n+         * objects, their result objects and the exceptions thrown by them.\n+         *\n+         * @param inits the {@code BackgroundInitializer} objects\n+         * @param results the result objects\n+         * @param excepts the exceptions\n+         */\n+        private MultiBackgroundInitializerResults(\n+                Map<String, BackgroundInitializer<?>> inits,\n+                Map<String, Object> results,\n+                Map<String, ConcurrentException> excepts) {\n+            initializers = inits;\n+            resultObjects = results;\n+            exceptions = excepts;\n+        }\n+\n+        /**\n+         * Returns the {@code BackgroundInitializer} with the given name. If the\n+         * name cannot be resolved, an exception is thrown.\n+         *\n+         * @param name the name of the {@code BackgroundInitializer}\n+         * @return the {@code BackgroundInitializer} with this name\n+         * @throws NoSuchElementException if the name cannot be resolved\n+         */\n+        public BackgroundInitializer<?> getInitializer(String name) {\n+            return checkName(name);\n+        }\n+\n+        /**\n+         * Returns the result object produced by the {@code\n+         * BackgroundInitializer} with the given name. This is the object\n+         * returned by the initializer's {@code initialize()} method. If this\n+         * {@code BackgroundInitializer} caused an exception, <b>null</b> is\n+         * returned. If the name cannot be resolved, an exception is thrown.\n+         *\n+         * @param name the name of the {@code BackgroundInitializer}\n+         * @return the result object produced by this {@code\n+         * BackgroundInitializer}\n+         * @throws NoSuchElementException if the name cannot be resolved\n+         */\n+        public Object getResultObject(String name) {\n+            checkName(name);\n+            return resultObjects.get(name);\n+        }\n+\n+        /**\n+         * Returns a flag whether the {@code BackgroundInitializer} with the\n+         * given name caused an exception.\n+         *\n+         * @param name the name of the {@code BackgroundInitializer}\n+         * @return a flag whether this initializer caused an exception\n+         * @throws NoSuchElementException if the name cannot be resolved\n+         */\n+        public boolean isException(String name) {\n+            checkName(name);\n+            return exceptions.containsKey(name);\n+        }\n+\n+        /**\n+         * Returns the {@code ConcurrentException} object that was thrown by the\n+         * {@code BackgroundInitializer} with the given name. If this\n+         * initializer did not throw an exception, the return value is\n+         * <b>null</b>. If the name cannot be resolved, an exception is thrown.\n+         *\n+         * @param name the name of the {@code BackgroundInitializer}\n+         * @return the exception thrown by this initializer\n+         * @throws NoSuchElementException if the name cannot be resolved\n+         */\n+        public ConcurrentException getException(String name) {\n+            checkName(name);\n+            return exceptions.get(name);\n+        }\n+\n+        /**\n+         * Returns a set with the names of all {@code BackgroundInitializer}\n+         * objects managed by the {@code MultiBackgroundInitializer}.\n+         *\n+         * @return an (unmodifiable) set with the names of the managed {@code\n+         * BackgroundInitializer} objects\n+         */\n+        public Set<String> initializerNames() {\n+            return Collections.unmodifiableSet(initializers.keySet());\n+        }\n+\n+        /**\n+         * Checks whether an initializer with the given name exists. If not,\n+         * throws an exception. If it exists, the associated child initializer\n+         * is returned.\n+         *\n+         * @param name the name to check\n+         * @return the initializer with this name\n+         * @throws NoSuchElementException if the name is unknown\n+         */\n+        private BackgroundInitializer<?> checkName(String name) {\n+            BackgroundInitializer<?> init = initializers.get(name);\n+            if (init == null) {\n+                throw new NoSuchElementException(\n+                        \"No child initializer with name \" + name);\n+            }\n+\n+            return init;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/exception/ContextedException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.util.Set;\n+\n+/**\n+ * <p>\n+ * An exception that provides an easy and safe way to add contextual information.\n+ * </p><p>\n+ * An exception trace itself is often insufficient to provide rapid diagnosis of the issue.\n+ * Frequently what is needed is a select few pieces of local contextual data.\n+ * Providing this data is tricky however, due to concerns over formatting and nulls.\n+ * </p><p>\n+ * The contexted exception approach allows the exception to be created together with a\n+ * map of context values. This additional information is automatically included in the\n+ * message and printed stack trace.\n+ * </p><p>\n+ * An unchecked version of this exception is provided by ContextedRuntimeException.\n+ * </p>\n+ * <p>\n+ * To use this class write code as follows:\n+ * </p>\n+ * <pre>\n+ *   try {\n+ *     ...\n+ *   } catch (Throwable e) {\n+ *     throw new ContextedException(\"Error posting account transaction\", e)\n+ *          .addValue(\"accountNumber\", accountNumber)\n+ *          .addValue(\"amountPosted\", amountPosted)\n+ *          .addValue(\"previousBalance\", previousBalance)\n+ *   }\n+ * }\n+ * </pre>\n+ * </p><p>\n+ * The output in a printStacktrace() (which often is written to a log) would look something like the following:\n+ * <pre>\n+ * org.apache.commons.lang.exception.ContextedException: java.lang.Exception: Error posting account transaction\n+ *  Exception Context:\n+ *  [accountNumber=null]\n+ *  [amountPosted=100.00]\n+ *  [previousBalance=-2.17]\n+ *\n+ *  ---------------------------------\n+ *  at org.apache.commons.lang.exception.ContextedExceptionTest.testAddValue(ContextedExceptionTest.java:88)\n+ *  ..... (rest of trace)\n+ * </pre>\n+ * </p>\n+ * \n+ * @see ContextedRuntimeException\n+ * @author Apache Software Foundation\n+ * @author D. Ashmore\n+ * @since 3.0\n+ */\n+public class ContextedException extends Exception implements ExceptionContext {\n+\n+    /** The serialization version. */\n+    private static final long serialVersionUID = 8940917952810290164L;\n+    /** The context where the data is stored. */\n+    private final ExceptionContext exceptionContext;\n+\n+    /**\n+     * Instantiates ContextedException without message or cause.\n+     * <p>\n+     * The context information is stored using a default implementation.\n+     */\n+    public ContextedException() {\n+        super();\n+        exceptionContext = new DefaultExceptionContext();\n+    }\n+\n+    /**\n+     * Instantiates ContextedException with message, but without cause.\n+     * <p>\n+     * The context information is stored using a default implementation.\n+     * \n+     * @param message  the exception message, may be null\n+     */\n+    public ContextedException(String message) {\n+        super(message);\n+        exceptionContext = new DefaultExceptionContext();\n+    }\n+\n+    /**\n+     * Instantiates ContextedException with cause, but without message.\n+     * <p>\n+     * The context information is stored using a default implementation.\n+     * \n+     * @param cause  the underlying cause of the exception, may be null\n+     */\n+    public ContextedException(Throwable cause) {\n+        super(cause);\n+        exceptionContext = new DefaultExceptionContext();\n+    }\n+\n+    /**\n+     * Instantiates ContextedException with cause and message.\n+     * <p>\n+     * The context information is stored using a default implementation.\n+     * \n+     * @param message  the exception message, may be null\n+     * @param cause  the underlying cause of the exception, may be null\n+     */\n+    public ContextedException(String message, Throwable cause) {\n+        super(message, cause);\n+        exceptionContext = new DefaultExceptionContext();\n+    }\n+\n+    /**\n+     * Instantiates ContextedException with cause, message, and ExceptionContext.\n+     * \n+     * @param message  the exception message, may be null\n+     * @param cause  the underlying cause of the exception, may be null\n+     * @param context  the context used to store the additional information, null uses default implementation\n+     */\n+    public ContextedException(String message, Throwable cause, ExceptionContext context) {\n+        super(message, cause);\n+        if (context == null) {\n+            context = new DefaultExceptionContext();\n+        }\n+        exceptionContext = context;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds information helpful to a developer in diagnosing and correcting\n+     * the problem.  For the information to be meaningful, the value passed\n+     * should have a reasonable toString() implementation.\n+     * <p>\n+     * Note: This exception is only serializable if the object added is serializable.\n+     * \n+     * @param label  a textual label associated with information, null not recommended\n+     * @param value  information needed to understand exception, may be null\n+     * @return this, for method chaining\n+     */\n+    public ContextedException addValue(String label, Object value) {        \n+        exceptionContext.addValue(label, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Retrieves a contextual data value associated with the label.\n+     * \n+     * @param label  the label to get the contextual value for, may be null\n+     * @return the contextual value associated with the label, may be null\n+     */\n+    public Object getValue(String label) {\n+        return exceptionContext.getValue(label);\n+    }\n+\n+    /**\n+     * Retrieves the labels defined in the contextual data.\n+     * \n+     * @return the set of labels, never null\n+     */\n+    public Set<String> getLabelSet() {\n+        return exceptionContext.getLabelSet();\n+    }\n+\n+    /**\n+     * Provides the message explaining the exception, including the contextual data.\n+     * \n+     * @see java.lang.Throwable#getMessage()\n+     * @return the message, never null\n+     */\n+    @Override\n+    public String getMessage(){\n+        return getFormattedExceptionMessage(super.getMessage());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public String getFormattedExceptionMessage(String baseMessage) {\n+        return exceptionContext.getFormattedExceptionMessage(baseMessage);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/exception/ContextedRuntimeException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.util.Set;\n+\n+/**\n+ * <p>\n+ * A runtime exception that provides an easy and safe way to add contextual information.\n+ * </p><p>\n+ * An exception trace itself is often insufficient to provide rapid diagnosis of the issue.\n+ * Frequently what is needed is a select few pieces of local contextual data.\n+ * Providing this data is tricky however, due to concerns over formatting and nulls.\n+ * </p><p>\n+ * The contexted exception approach allows the exception to be created together with a\n+ * map of context values. This additional information is automatically included in the\n+ * message and printed stack trace.\n+ * </p><p>\n+ * An checked version of this exception is provided by ContextedException.\n+ * </p>\n+ * <p>\n+ * To use this class write code as follows:\n+ * </p>\n+ * <pre>\n+ *   try {\n+ *     ...\n+ *   } catch (Throwable e) {\n+ *     throw new ContextedException(\"Error posting account transaction\", e)\n+ *          .addValue(\"accountNumber\", accountNumber)\n+ *          .addValue(\"amountPosted\", amountPosted)\n+ *          .addValue(\"previousBalance\", previousBalance)\n+ *   }\n+ * }\n+ * </pre>\n+ * </p><p>\n+ * The output in a printStacktrace() (which often is written to a log) would look something like the following:\n+ * <pre>\n+ * org.apache.commons.lang.exception.ContextedRuntimeException: java.lang.Exception: Error posting account transaction\n+ *  Exception Context:\n+ *  [accountNumber=null]\n+ *  [amountPosted=100.00]\n+ *  [previousBalance=-2.17]\n+ *\n+ *  ---------------------------------\n+ *  at org.apache.commons.lang.exception.ContextedRuntimeExceptionTest.testAddValue(ContextedExceptionTest.java:88)\n+ *  ..... (rest of trace)\n+ * </pre>\n+ * </p>\n+ * \n+ * @see ContextedException\n+ * @author Apache Software Foundation\n+ * @author D. Ashmore\n+ * @author J&ouml;rg Schaible\n+ * @since 3.0\n+ */\n+public class ContextedRuntimeException extends Exception implements ExceptionContext {\n+\n+    /** The serialization version. */\n+    private static final long serialVersionUID = 1459691936045811817L;\n+    /** The context where the data is stored. */\n+    private final ExceptionContext exceptionContext;\n+\n+    /**\n+     * Instantiates ContextedRuntimeException without message or cause.\n+     * <p>\n+     * The context information is stored using a default implementation.\n+     */\n+    public ContextedRuntimeException() {\n+        super();\n+        exceptionContext = new DefaultExceptionContext();\n+    }\n+\n+    /**\n+     * Instantiates ContextedRuntimeException with message, but without cause.\n+     * <p>\n+     * The context information is stored using a default implementation.\n+     * \n+     * @param message  the exception message, may be null\n+     */\n+    public ContextedRuntimeException(String message) {\n+        super(message);\n+        exceptionContext = new DefaultExceptionContext();\n+    }\n+\n+    /**\n+     * Instantiates ContextedRuntimeException with cause, but without message.\n+     * <p>\n+     * The context information is stored using a default implementation.\n+     * \n+     * @param cause  the underlying cause of the exception, may be null\n+     */\n+    public ContextedRuntimeException(Throwable cause) {\n+        super(cause);\n+        exceptionContext = new DefaultExceptionContext();\n+    }\n+\n+    /**\n+     * Instantiates ContextedRuntimeException with cause and message.\n+     * <p>\n+     * The context information is stored using a default implementation.\n+     * \n+     * @param message  the exception message, may be null\n+     * @param cause  the underlying cause of the exception, may be null\n+     */\n+    public ContextedRuntimeException(String message, Throwable cause) {\n+        super(message, cause);\n+        exceptionContext = new DefaultExceptionContext();\n+    }\n+\n+    /**\n+     * Instantiates ContextedRuntimeException with cause, message, and ExceptionContext.\n+     * \n+     * @param message  the exception message, may be null\n+     * @param cause  the underlying cause of the exception, may be null\n+     * @param context  the context used to store the additional information, null uses default implementation\n+     */\n+    public ContextedRuntimeException(String message, Throwable cause, ExceptionContext context) {\n+        super(message, cause);\n+        if (context == null) {\n+            context = new DefaultExceptionContext();\n+        }\n+        exceptionContext = context;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds information helpful to a developer in diagnosing and correcting\n+     * the problem.  For the information to be meaningful, the value passed\n+     * should have a reasonable toString() implementation.\n+     * <p>\n+     * Note: This exception is only serializable if the object added is serializable.\n+     * \n+     * @param label  a textual label associated with information, null not recommended\n+     * @param value  information needed to understand exception, may be null\n+     * @return this, for method chaining\n+     */\n+    public ContextedRuntimeException addValue(String label, Object value) {        \n+        exceptionContext.addValue(label, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Retrieves a contextual data value associated with the label.\n+     * \n+     * @param label  the label to get the contextual value for, may be null\n+     * @return the contextual value associated with the label, may be null\n+     */\n+    public Object getValue(String label) {\n+        return exceptionContext.getValue(label);\n+    }\n+\n+    /**\n+     * Retrieves the labels defined in the contextual data.\n+     * \n+     * @return the set of labels, never null\n+     */\n+    public Set<String> getLabelSet() {\n+        return exceptionContext.getLabelSet();\n+    }\n+\n+    /**\n+     * Provides the message explaining the exception, including the contextual data.\n+     * \n+     * @see java.lang.Throwable#getMessage()\n+     * @return the message, never null\n+     */\n+    @Override\n+    public String getMessage(){\n+        return getFormattedExceptionMessage(super.getMessage());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public String getFormattedExceptionMessage(String baseMessage) {\n+        return exceptionContext.getFormattedExceptionMessage(baseMessage);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/exception/DefaultExceptionContext.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.io.Serializable;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.SystemUtils;\n+\n+/**\n+ * Default implementation of the context storing the label-value pairs for contexted exceptions.\n+ * <p>\n+ * This implementation is serializable, however this is dependent on the values that\n+ * are added also being serializable.\n+ * \n+ * @author Apache Software Foundation\n+ * @author D. Ashmore\n+ * @since 3.0\n+ */\n+class DefaultExceptionContext implements ExceptionContext, Serializable {\n+\n+    /** The serialization version. */\n+    private static final long serialVersionUID = 293747957535772807L;\n+    /** The ordered map storing the label-data pairs. */\n+    private Map<String, Object> contextValueMap = new LinkedHashMap<String, Object>();\n+\n+    /**\n+     * Adds a contextual label-value pair into this context.\n+     * <p>\n+     * This label-value pair provides information useful for debugging.\n+     * \n+     * @param label  the label of the item to add, null not recommended\n+     * @param value  the value of item to add, may be null\n+     * @return this, for method chaining\n+     */\n+    public ExceptionContext addValue(String label, Object value) {        \n+        contextValueMap.put(label, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Retrieves a contextual data value associated with the label.\n+     * \n+     * @param label  the label to get the contextual value for, may be null\n+     * @return the contextual value associated with the label, may be null\n+     */\n+    public Object getValue(String label) {\n+        return contextValueMap.get(label);\n+    }\n+\n+    /**\n+     * Retrieves the labels defined in the contextual data.\n+     * \n+     * @return the set of labels, never null\n+     */\n+    public Set<String> getLabelSet() {\n+        return contextValueMap.keySet();\n+    }\n+\n+    /**\n+     * Builds the message containing the contextual information.\n+     * \n+     * @param baseMessage  the base exception message <b>without</b> context information appended\n+     * @return the exception message <b>with</b> context information appended, never null\n+     */\n+    public String getFormattedExceptionMessage(String baseMessage){\n+        StringBuilder buffer = new StringBuilder(256);\n+        if (baseMessage != null) {\n+            buffer.append(baseMessage);\n+        }\n+        \n+        if (contextValueMap.size() > 0) {\n+            if (buffer.length() > 0l) {\n+                buffer.append(SystemUtils.LINE_SEPARATOR);\n+            }\n+            buffer.append(\"Exception Context:\");\n+            buffer.append(SystemUtils.LINE_SEPARATOR); \n+            buffer.append(\"\\t\");  \n+            \n+            Object value;\n+            String valueStr;\n+            for (String label : contextValueMap.keySet()) {\n+                buffer.append(\"[\");\n+                buffer.append(label);\n+                buffer.append(\"=\");\n+                value = this.contextValueMap.get(label);\n+                if (value == null) {\n+                    buffer.append(\"null\");\n+                }\n+                else {\n+                    try {valueStr = value.toString();}\n+                    catch (Throwable t) {\n+                        valueStr = \"Excepted on toString(): \" + \n+                            ExceptionUtils.getStackTrace(t);\n+                    }\n+                    buffer.append(valueStr);\n+                }\n+                buffer.append(\"]\");\n+                buffer.append(SystemUtils.LINE_SEPARATOR);  \n+                buffer.append(\"\\t\");  \n+            }\n+            buffer.append(\"---------------------------------\");\n+        }\n+        return buffer.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/exception/ExceptionContext.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.util.Set;\n+\n+/**\n+ * Allows the storage and retrieval of contextual information based on label-value\n+ * pairs for exceptions.\n+ * \n+ * @see ContextedException\n+ * @see ContextedRuntimeException\n+ * @author Apache Software Foundation\n+ * @author D. Ashmore\n+ * @since 3.0\n+ */\n+public interface ExceptionContext {\n+\n+    /**\n+     * Adds a contextual label-value pair into this context.\n+     * <p>\n+     * This label-value pair provides information useful for debugging.\n+     * \n+     * @param label  the label of the item to add, null not recommended\n+     * @param value  the value of item to add, may be null\n+     * @return context itself to allow method chaining\n+     */\n+    public ExceptionContext addValue(String label, Object value);\n+\n+    /**\n+     * Retrieves a contextual data value associated with the label.\n+     * \n+     * @param label  the label to get the contextual value for, may be null\n+     * @return the contextual value associated with the label, may be null\n+     */\n+    public Object getValue(String label);\n+\n+    /**\n+     * Retrieves the labels defined in the contextual data.\n+     * \n+     * @return the set of labels, never null\n+     */\n+    public Set<String> getLabelSet();\n+\n+    /**\n+     * Implementors provide the given base message with context label/value item \n+     * information appended.\n+     * \n+     * @param baseMessage  the base exception message <b>without</b> context information appended\n+     * @return the exception message <b>with</b> context information appended, never null\n+     */\n+    public String getFormattedExceptionMessage(String baseMessage);\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/exception/ExceptionUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.StringTokenizer;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.ClassUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.commons.lang.SystemUtils;\n+\n+/**\n+ * <p>Provides utilities for manipulating and examining \n+ * <code>Throwable</code> objects.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Daniel L. Rall\n+ * @author Dmitri Plotnikov\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author Pete Gieser\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+//@ThreadSafe\n+public class ExceptionUtils {\n+    \n+    /**\n+     * <p>Used when printing stack frames to denote the start of a\n+     * wrapped exception.</p>\n+     *\n+     * <p>Package private for accessibility by test suite.</p>\n+     */\n+    static final String WRAPPED_MARKER = \" [wrapped] \";\n+\n+    // Lock object for CAUSE_METHOD_NAMES\n+    private static final Object CAUSE_METHOD_NAMES_LOCK = new Object();\n+    \n+    /**\n+     * <p>The names of methods commonly used to access a wrapped exception.</p>\n+     */\n+//    @GuardedBy(\"CAUSE_METHOD_NAMES_LOCK\")\n+    private static String[] CAUSE_METHOD_NAMES = {\n+        \"getCause\",\n+        \"getNextException\",\n+        \"getTargetException\",\n+        \"getException\",\n+        \"getSourceException\",\n+        \"getRootCause\",\n+        \"getCausedByException\",\n+        \"getNested\",\n+        \"getLinkedException\",\n+        \"getNestedException\",\n+        \"getLinkedCause\",\n+        \"getThrowable\",\n+    };\n+\n+    /**\n+     * <p>The Method object for Java 1.4 getCause.</p>\n+     */\n+    private static final Method THROWABLE_CAUSE_METHOD;\n+    /**\n+     * <p>The Method object for Java 1.4 initCause.</p>\n+     */\n+    private static final Method THROWABLE_INITCAUSE_METHOD;\n+    static {\n+        Method causeMethod;\n+        try {\n+            causeMethod = Throwable.class.getMethod(\"getCause\", (Class[]) null);\n+        } catch (Exception e) {\n+            causeMethod = null;\n+        }\n+        THROWABLE_CAUSE_METHOD = causeMethod;\n+        try {\n+            causeMethod = Throwable.class.getMethod(\"initCause\", new Class[]{Throwable.class});\n+        } catch (Exception e) {\n+            causeMethod = null;\n+        }\n+        THROWABLE_INITCAUSE_METHOD = causeMethod;\n+    }\n+\n+    /**\n+     * <p>\n+     * Public constructor allows an instance of <code>ExceptionUtils</code> to be created, although that is not\n+     * normally necessary.\n+     * </p>\n+     */\n+    public ExceptionUtils() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Adds to the list of method names used in the search for <code>Throwable</code>\n+     * objects.</p>\n+     * \n+     * @param methodName  the methodName to add to the list, <code>null</code>\n+     *  and empty strings are ignored\n+     * @since 2.0\n+     */\n+    public static void addCauseMethodName(String methodName) {\n+        if (StringUtils.isNotEmpty(methodName) && !isCauseMethodName(methodName)) {            \n+            List<String> list = getCauseMethodNameList();\n+            if (list.add(methodName)) {\n+                synchronized(CAUSE_METHOD_NAMES_LOCK) {\n+                    CAUSE_METHOD_NAMES = toArray(list);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Removes from the list of method names used in the search for <code>Throwable</code>\n+     * objects.</p>\n+     * \n+     * @param methodName  the methodName to remove from the list, <code>null</code>\n+     *  and empty strings are ignored\n+     * @since 2.1\n+     */\n+    public static void removeCauseMethodName(String methodName) {\n+        if (StringUtils.isNotEmpty(methodName)) {\n+            List<String> list = getCauseMethodNameList();\n+            if (list.remove(methodName)) {\n+                synchronized(CAUSE_METHOD_NAMES_LOCK) {\n+                    CAUSE_METHOD_NAMES = toArray(list);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Sets the cause of a <code>Throwable</code> using introspection, allowing\n+     * source code compatibility between pre-1.4 and post-1.4 Java releases.</p>\n+     *\n+     * <p>The typical use of this method is inside a constructor as in\n+     * the following example:</p>\n+     *\n+     * <pre>\n+     * import org.apache.commons.lang.exception.ExceptionUtils;\n+     *  \n+     * public class MyException extends Exception {\n+     *  \n+     *    public MyException(String msg) {\n+     *       super(msg);\n+     *    }\n+     *\n+     *    public MyException(String msg, Throwable cause) {\n+     *       super(msg);\n+     *       ExceptionUtils.setCause(this, cause);\n+     *    }\n+     * }\n+     * </pre>\n+     *\n+     * @param target  the target <code>Throwable</code>\n+     * @param cause  the <code>Throwable</code> to set in the target\n+     * @return a <code>true</code> if the target has been modified\n+     * @since 2.2\n+     */\n+    public static boolean setCause(Throwable target, Throwable cause) {\n+        if (target == null) {\n+            throw new NullPointerException(\"target must not be null.\");\n+        }\n+        Object[] causeArgs = new Object[]{cause};\n+        boolean modifiedTarget = false;\n+        if (THROWABLE_INITCAUSE_METHOD != null) {\n+            try {\n+                THROWABLE_INITCAUSE_METHOD.invoke(target, causeArgs);\n+                modifiedTarget = true;\n+            } catch (IllegalAccessException ignored) {\n+                // Exception ignored.\n+            } catch (InvocationTargetException ignored) {\n+                // Exception ignored.\n+            }\n+        }\n+        try {\n+            Method setCauseMethod = target.getClass().getMethod(\"setCause\", new Class[]{Throwable.class});\n+            setCauseMethod.invoke(target, causeArgs);\n+            modifiedTarget = true;\n+        } catch (NoSuchMethodException ignored) {\n+            // Exception ignored.\n+        } catch (IllegalAccessException ignored) {\n+            // Exception ignored.\n+        } catch (InvocationTargetException ignored) {\n+            // Exception ignored.\n+        }\n+        return modifiedTarget;\n+    }\n+\n+    /**\n+     * Returns the given list as a <code>String[]</code>.\n+     * @param list a list to transform.\n+     * @return the given list as a <code>String[]</code>.\n+     */\n+    private static String[] toArray(List<String> list) {\n+        return list.toArray(new String[list.size()]);\n+    }\n+\n+    /**\n+     * Returns {@link #CAUSE_METHOD_NAMES} as a List.\n+     *\n+     * @return {@link #CAUSE_METHOD_NAMES} as a List.\n+     */\n+    private static ArrayList<String> getCauseMethodNameList() {\n+        synchronized(CAUSE_METHOD_NAMES_LOCK) {\n+            return new ArrayList<String>(Arrays.asList(CAUSE_METHOD_NAMES));\n+        }\n+    }\n+\n+    /**\n+     * <p>Tests if the list of method names used in the search for <code>Throwable</code>\n+     * objects include the given name.</p>\n+     * \n+     * @param methodName  the methodName to search in the list.\n+     * @return if the list of method names used in the search for <code>Throwable</code>\n+     *  objects include the given name.\n+     * @since 2.1\n+     */\n+    public static boolean isCauseMethodName(String methodName) {\n+        synchronized(CAUSE_METHOD_NAMES_LOCK) {\n+            return ArrayUtils.indexOf(CAUSE_METHOD_NAMES, methodName) >= 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Introspects the <code>Throwable</code> to obtain the cause.</p>\n+     *\n+     * <p>The method searches for methods with specific names that return a \n+     * <code>Throwable</code> object. This will pick up most wrapping exceptions,\n+     * including those from JDK 1.4.\n+     * The method names can be added to using {@link #addCauseMethodName(String)}.</p>\n+     *\n+     * <p>The default list searched for are:</p>\n+     * <ul>\n+     *  <li><code>getCause()</code></li>\n+     *  <li><code>getNextException()</code></li>\n+     *  <li><code>getTargetException()</code></li>\n+     *  <li><code>getException()</code></li>\n+     *  <li><code>getSourceException()</code></li>\n+     *  <li><code>getRootCause()</code></li>\n+     *  <li><code>getCausedByException()</code></li>\n+     *  <li><code>getNested()</code></li>\n+     * </ul>\n+     * \n+     * <p>In the absence of any such method, the object is inspected for a\n+     * <code>detail</code> field assignable to a <code>Throwable</code>.</p>\n+     *\n+     * <p>If none of the above is found, returns <code>null</code>.</p>\n+     *\n+     * @param throwable  the throwable to introspect for a cause, may be null\n+     * @return the cause of the <code>Throwable</code>,\n+     *  <code>null</code> if none found or null throwable input\n+     * @since 1.0\n+     */\n+    public static Throwable getCause(Throwable throwable) {\n+        synchronized(CAUSE_METHOD_NAMES_LOCK) {\n+            return getCause(throwable, CAUSE_METHOD_NAMES);\n+        }\n+    }\n+\n+    /**\n+     * <p>Introspects the <code>Throwable</code> to obtain the cause.</p>\n+     *\n+     * <ol>\n+     * <li>Try known exception types.</li>\n+     * <li>Try the supplied array of method names.</li>\n+     * <li>Try the field 'detail'.</li>\n+     * </ol>\n+     *\n+     * <p>A <code>null</code> set of method names means use the default set.\n+     * A <code>null</code> in the set of method names will be ignored.</p>\n+     *\n+     * @param throwable  the throwable to introspect for a cause, may be null\n+     * @param methodNames  the method names, null treated as default set\n+     * @return the cause of the <code>Throwable</code>,\n+     *  <code>null</code> if none found or null throwable input\n+     * @since 1.0\n+     */\n+    public static Throwable getCause(Throwable throwable, String[] methodNames) {\n+        if (throwable == null) {\n+            return null;\n+        }\n+        Throwable cause = getCauseUsingWellKnownTypes(throwable);\n+        if (cause == null) {\n+            if (methodNames == null) {\n+                synchronized(CAUSE_METHOD_NAMES_LOCK) {\n+                    methodNames = CAUSE_METHOD_NAMES;\n+                }\n+            }\n+            for (int i = 0; i < methodNames.length; i++) {\n+                String methodName = methodNames[i];\n+                if (methodName != null) {\n+                    cause = getCauseUsingMethodName(throwable, methodName);\n+                    if (cause != null) {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (cause == null) {\n+                cause = getCauseUsingFieldName(throwable, \"detail\");\n+            }\n+        }\n+        return cause;\n+    }\n+\n+    /**\n+     * <p>Introspects the <code>Throwable</code> to obtain the root cause.</p>\n+     *\n+     * <p>This method walks through the exception chain to the last element,\n+     * \"root\" of the tree, using {@link #getCause(Throwable)}, and\n+     * returns that exception.</p>\n+     *\n+     * <p>From version 2.2, this method handles recursive cause structures\n+     * that might otherwise cause infinite loops. If the throwable parameter\n+     * has a cause of itself, then null will be returned. If the throwable\n+     * parameter cause chain loops, the last element in the chain before the\n+     * loop is returned.</p>\n+     *\n+     * @param throwable  the throwable to get the root cause for, may be null\n+     * @return the root cause of the <code>Throwable</code>,\n+     *  <code>null</code> if none found or null throwable input\n+     */\n+    public static Throwable getRootCause(Throwable throwable) {\n+        List<Throwable> list = getThrowableList(throwable);\n+        return (list.size() < 2 ? null : (Throwable)list.get(list.size() - 1));\n+    }\n+\n+    /**\n+     * <p>Finds a <code>Throwable</code> for known types.</p>\n+     * \n+     * <p>Uses <code>instanceof</code> checks to examine the exception,\n+     * looking for well known types which could contain chained or\n+     * wrapped exceptions.</p>\n+     *\n+     * @param throwable  the exception to examine\n+     * @return the wrapped exception, or <code>null</code> if not found\n+     */\n+    private static Throwable getCauseUsingWellKnownTypes(Throwable throwable) {\n+        if (throwable instanceof SQLException) {\n+            return ((SQLException) throwable).getNextException();\n+        } else if (throwable instanceof InvocationTargetException) {\n+            return ((InvocationTargetException) throwable).getTargetException();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * <p>Finds a <code>Throwable</code> by method name.</p>\n+     *\n+     * @param throwable  the exception to examine\n+     * @param methodName  the name of the method to find and invoke\n+     * @return the wrapped exception, or <code>null</code> if not found\n+     */\n+    private static Throwable getCauseUsingMethodName(Throwable throwable, String methodName) {\n+        Method method = null;\n+        try {\n+            method = throwable.getClass().getMethod(methodName, (Class[]) null);\n+        } catch (NoSuchMethodException ignored) {\n+            // exception ignored\n+        } catch (SecurityException ignored) {\n+            // exception ignored\n+        }\n+\n+        if (method != null && Throwable.class.isAssignableFrom(method.getReturnType())) {\n+            try {\n+                return (Throwable) method.invoke(throwable, ArrayUtils.EMPTY_OBJECT_ARRAY);\n+            } catch (IllegalAccessException ignored) {\n+                // exception ignored\n+            } catch (IllegalArgumentException ignored) {\n+                // exception ignored\n+            } catch (InvocationTargetException ignored) {\n+                // exception ignored\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Finds a <code>Throwable</code> by field name.</p>\n+     *\n+     * @param throwable  the exception to examine\n+     * @param fieldName  the name of the attribute to examine\n+     * @return the wrapped exception, or <code>null</code> if not found\n+     */\n+    private static Throwable getCauseUsingFieldName(Throwable throwable, String fieldName) {\n+        Field field = null;\n+        try {\n+            field = throwable.getClass().getField(fieldName);\n+        } catch (NoSuchFieldException ignored) {\n+            // exception ignored\n+        } catch (SecurityException ignored) {\n+            // exception ignored\n+        }\n+\n+        if (field != null && Throwable.class.isAssignableFrom(field.getType())) {\n+            try {\n+                return (Throwable) field.get(throwable);\n+            } catch (IllegalAccessException ignored) {\n+                // exception ignored\n+            } catch (IllegalArgumentException ignored) {\n+                // exception ignored\n+            }\n+        }\n+        return null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if the Throwable class has a <code>getCause</code> method.</p>\n+     *\n+     * <p>This is true for JDK 1.4 and above.</p>\n+     *\n+     * @return true if Throwable is nestable\n+     * @since 2.0\n+     */\n+    public static boolean isThrowableNested() {\n+        return THROWABLE_CAUSE_METHOD != null;\n+    }\n+    \n+    /**\n+     * <p>Checks whether this <code>Throwable</code> class can store a cause.</p>\n+     *\n+     * <p>This method does <b>not</b> check whether it actually does store a cause.<p>\n+     *\n+     * @param throwable  the <code>Throwable</code> to examine, may be null\n+     * @return boolean <code>true</code> if nested otherwise <code>false</code>\n+     * @since 2.0\n+     */\n+    public static boolean isNestedThrowable(Throwable throwable) {\n+        if (throwable == null) {\n+            return false;\n+        }\n+\n+        if (throwable instanceof SQLException) {\n+            return true;\n+        } else if (throwable instanceof InvocationTargetException) {\n+            return true;\n+        } else if (isThrowableNested()) {\n+            return true;\n+        }\n+\n+        Class<? extends Throwable> cls = throwable.getClass();\n+        synchronized(CAUSE_METHOD_NAMES_LOCK) {\n+            for (int i = 0, isize = CAUSE_METHOD_NAMES.length; i < isize; i++) {\n+                try {\n+                    Method method = cls.getMethod(CAUSE_METHOD_NAMES[i], (Class[]) null);\n+                    if (method != null && Throwable.class.isAssignableFrom(method.getReturnType())) {\n+                        return true;\n+                    }\n+                } catch (NoSuchMethodException ignored) {\n+                    // exception ignored\n+                } catch (SecurityException ignored) {\n+                    // exception ignored\n+                }\n+            }\n+        }\n+\n+        try {\n+            Field field = cls.getField(\"detail\");\n+            if (field != null) {\n+                return true;\n+            }\n+        } catch (NoSuchFieldException ignored) {\n+            // exception ignored\n+        } catch (SecurityException ignored) {\n+            // exception ignored\n+        }\n+\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Counts the number of <code>Throwable</code> objects in the\n+     * exception chain.</p>\n+     *\n+     * <p>A throwable without cause will return <code>1</code>.\n+     * A throwable with one cause will return <code>2</code> and so on.\n+     * A <code>null</code> throwable will return <code>0</code>.</p>\n+     *\n+     * <p>From version 2.2, this method handles recursive cause structures\n+     * that might otherwise cause infinite loops. The cause chain is\n+     * processed until the end is reached, or until the next item in the\n+     * chain is already in the result set.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @return the count of throwables, zero if null input\n+     */\n+    public static int getThrowableCount(Throwable throwable) {\n+        return getThrowableList(throwable).size();\n+    }\n+\n+    /**\n+     * <p>Returns the list of <code>Throwable</code> objects in the\n+     * exception chain.</p>\n+     *\n+     * <p>A throwable without cause will return an array containing\n+     * one element - the input throwable.\n+     * A throwable with one cause will return an array containing\n+     * two elements. - the input throwable and the cause throwable.\n+     * A <code>null</code> throwable will return an array of size zero.</p>\n+     *\n+     * <p>From version 2.2, this method handles recursive cause structures\n+     * that might otherwise cause infinite loops. The cause chain is\n+     * processed until the end is reached, or until the next item in the\n+     * chain is already in the result set.</p>\n+     *\n+     * @see #getThrowableList(Throwable)\n+     * @param throwable  the throwable to inspect, may be null\n+     * @return the array of throwables, never null\n+     */\n+    public static Throwable[] getThrowables(Throwable throwable) {\n+        List<Throwable> list = getThrowableList(throwable);\n+        return list.toArray(new Throwable[list.size()]);\n+    }\n+\n+    /**\n+     * <p>Returns the list of <code>Throwable</code> objects in the\n+     * exception chain.</p>\n+     *\n+     * <p>A throwable without cause will return a list containing\n+     * one element - the input throwable.\n+     * A throwable with one cause will return a list containing\n+     * two elements. - the input throwable and the cause throwable.\n+     * A <code>null</code> throwable will return a list of size zero.</p>\n+     *\n+     * <p>This method handles recursive cause structures that might\n+     * otherwise cause infinite loops. The cause chain is processed until\n+     * the end is reached, or until the next item in the chain is already\n+     * in the result set.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @return the list of throwables, never null\n+     * @since Commons Lang 2.2\n+     */\n+    public static List<Throwable> getThrowableList(Throwable throwable) {\n+        List<Throwable> list = new ArrayList<Throwable>();\n+        while (throwable != null && list.contains(throwable) == false) {\n+            list.add(throwable);\n+            throwable = ExceptionUtils.getCause(throwable);\n+        }\n+        return list;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns the (zero based) index of the first <code>Throwable</code>\n+     * that matches the specified class (exactly) in the exception chain.\n+     * Subclasses of the specified class do not match - see\n+     * {@link #indexOfType(Throwable, Class)} for the opposite.</p>\n+     *\n+     * <p>A <code>null</code> throwable returns <code>-1</code>.\n+     * A <code>null</code> type returns <code>-1</code>.\n+     * No match in the chain returns <code>-1</code>.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @param clazz  the class to search for, subclasses do not match, null returns -1\n+     * @return the index into the throwable chain, -1 if no match or null input\n+     */\n+    public static int indexOfThrowable(Throwable throwable, Class<?> clazz) {\n+        return indexOf(throwable, clazz, 0, false);\n+    }\n+\n+    /**\n+     * <p>Returns the (zero based) index of the first <code>Throwable</code>\n+     * that matches the specified type in the exception chain from\n+     * a specified index.\n+     * Subclasses of the specified class do not match - see\n+     * {@link #indexOfType(Throwable, Class, int)} for the opposite.</p>\n+     *\n+     * <p>A <code>null</code> throwable returns <code>-1</code>.\n+     * A <code>null</code> type returns <code>-1</code>.\n+     * No match in the chain returns <code>-1</code>.\n+     * A negative start index is treated as zero.\n+     * A start index greater than the number of throwables returns <code>-1</code>.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @param clazz  the class to search for, subclasses do not match, null returns -1\n+     * @param fromIndex  the (zero based) index of the starting position,\n+     *  negative treated as zero, larger than chain size returns -1\n+     * @return the index into the throwable chain, -1 if no match or null input\n+     */\n+    public static int indexOfThrowable(Throwable throwable, Class<?> clazz, int fromIndex) {\n+        return indexOf(throwable, clazz, fromIndex, false);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns the (zero based) index of the first <code>Throwable</code>\n+     * that matches the specified class or subclass in the exception chain.\n+     * Subclasses of the specified class do match - see\n+     * {@link #indexOfThrowable(Throwable, Class)} for the opposite.</p>\n+     *\n+     * <p>A <code>null</code> throwable returns <code>-1</code>.\n+     * A <code>null</code> type returns <code>-1</code>.\n+     * No match in the chain returns <code>-1</code>.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @param type  the type to search for, subclasses match, null returns -1\n+     * @return the index into the throwable chain, -1 if no match or null input\n+     * @since 2.1\n+     */\n+    public static int indexOfType(Throwable throwable, Class<?> type) {\n+        return indexOf(throwable, type, 0, true);\n+    }\n+\n+    /**\n+     * <p>Returns the (zero based) index of the first <code>Throwable</code>\n+     * that matches the specified type in the exception chain from\n+     * a specified index.\n+     * Subclasses of the specified class do match - see\n+     * {@link #indexOfThrowable(Throwable, Class)} for the opposite.</p>\n+     *\n+     * <p>A <code>null</code> throwable returns <code>-1</code>.\n+     * A <code>null</code> type returns <code>-1</code>.\n+     * No match in the chain returns <code>-1</code>.\n+     * A negative start index is treated as zero.\n+     * A start index greater than the number of throwables returns <code>-1</code>.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @param type  the type to search for, subclasses match, null returns -1\n+     * @param fromIndex  the (zero based) index of the starting position,\n+     *  negative treated as zero, larger than chain size returns -1\n+     * @return the index into the throwable chain, -1 if no match or null input\n+     * @since 2.1\n+     */\n+    public static int indexOfType(Throwable throwable, Class<?> type, int fromIndex) {\n+        return indexOf(throwable, type, fromIndex, true);\n+    }\n+\n+    /**\n+     * <p>Worker method for the <code>indexOfType</code> methods.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @param type  the type to search for, subclasses match, null returns -1\n+     * @param fromIndex  the (zero based) index of the starting position,\n+     *  negative treated as zero, larger than chain size returns -1\n+     * @param subclass if <code>true</code>, compares with {@link Class#isAssignableFrom(Class)}, otherwise compares\n+     * using references\n+     * @return index of the <code>type</code> within throwables nested withing the specified <code>throwable</code>\n+     */\n+    private static int indexOf(Throwable throwable, Class<?> type, int fromIndex, boolean subclass) {\n+        if (throwable == null || type == null) {\n+            return -1;\n+        }\n+        if (fromIndex < 0) {\n+            fromIndex = 0;\n+        }\n+        Throwable[] throwables = ExceptionUtils.getThrowables(throwable);\n+        if (fromIndex >= throwables.length) {\n+            return -1;\n+        }\n+        if (subclass) {\n+            for (int i = fromIndex; i < throwables.length; i++) {\n+                if (type.isAssignableFrom(throwables[i].getClass())) {\n+                    return i;\n+                }\n+            }\n+        } else {\n+            for (int i = fromIndex; i < throwables.length; i++) {\n+                if (type.equals(throwables[i].getClass())) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Prints a compact stack trace for the root cause of a throwable\n+     * to <code>System.err</code>.</p>\n+     *\n+     * <p>The compact stack trace starts with the root cause and prints\n+     * stack frames up to the place where it was caught and wrapped.\n+     * Then it prints the wrapped exception and continues with stack frames\n+     * until the wrapper exception is caught and wrapped again, etc.</p>\n+     *\n+     * <p>The output of this method is consistent across JDK versions.\n+     * Note that this is the opposite order to the JDK1.4 display.</p>\n+     *\n+     * <p>The method is equivalent to <code>printStackTrace</code> for throwables\n+     * that don't have nested causes.</p>\n+     *\n+     * @param throwable  the throwable to output\n+     * @since 2.0\n+     */\n+    public static void printRootCauseStackTrace(Throwable throwable) {\n+        printRootCauseStackTrace(throwable, System.err);\n+    }\n+\n+    /**\n+     * <p>Prints a compact stack trace for the root cause of a throwable.</p>\n+     *\n+     * <p>The compact stack trace starts with the root cause and prints\n+     * stack frames up to the place where it was caught and wrapped.\n+     * Then it prints the wrapped exception and continues with stack frames\n+     * until the wrapper exception is caught and wrapped again, etc.</p>\n+     *\n+     * <p>The output of this method is consistent across JDK versions.\n+     * Note that this is the opposite order to the JDK1.4 display.</p>\n+     *\n+     * <p>The method is equivalent to <code>printStackTrace</code> for throwables\n+     * that don't have nested causes.</p>\n+     *\n+     * @param throwable  the throwable to output, may be null\n+     * @param stream  the stream to output to, may not be null\n+     * @throws IllegalArgumentException if the stream is <code>null</code>\n+     * @since 2.0\n+     */\n+    public static void printRootCauseStackTrace(Throwable throwable, PrintStream stream) {\n+        if (throwable == null) {\n+            return;\n+        }\n+        if (stream == null) {\n+            throw new IllegalArgumentException(\"The PrintStream must not be null\");\n+        }\n+        String trace[] = getRootCauseStackTrace(throwable);\n+        for (int i = 0; i < trace.length; i++) {\n+            stream.println(trace[i]);\n+        }\n+        stream.flush();\n+    }\n+\n+    /**\n+     * <p>Prints a compact stack trace for the root cause of a throwable.</p>\n+     *\n+     * <p>The compact stack trace starts with the root cause and prints\n+     * stack frames up to the place where it was caught and wrapped.\n+     * Then it prints the wrapped exception and continues with stack frames\n+     * until the wrapper exception is caught and wrapped again, etc.</p>\n+     *\n+     * <p>The output of this method is consistent across JDK versions.\n+     * Note that this is the opposite order to the JDK1.4 display.</p>\n+     *\n+     * <p>The method is equivalent to <code>printStackTrace</code> for throwables\n+     * that don't have nested causes.</p>\n+     *\n+     * @param throwable  the throwable to output, may be null\n+     * @param writer  the writer to output to, may not be null\n+     * @throws IllegalArgumentException if the writer is <code>null</code>\n+     * @since 2.0\n+     */\n+    public static void printRootCauseStackTrace(Throwable throwable, PrintWriter writer) {\n+        if (throwable == null) {\n+            return;\n+        }\n+        if (writer == null) {\n+            throw new IllegalArgumentException(\"The PrintWriter must not be null\");\n+        }\n+        String trace[] = getRootCauseStackTrace(throwable);\n+        for (int i = 0; i < trace.length; i++) {\n+            writer.println(trace[i]);\n+        }\n+        writer.flush();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Creates a compact stack trace for the root cause of the supplied\n+     * <code>Throwable</code>.</p>\n+     *\n+     * <p>The output of this method is consistent across JDK versions.\n+     * It consists of the root exception followed by each of its wrapping\n+     * exceptions separated by '[wrapped]'. Note that this is the opposite\n+     * order to the JDK1.4 display.</p>\n+     *\n+     * @param throwable  the throwable to examine, may be null\n+     * @return an array of stack trace frames, never null\n+     * @since 2.0\n+     */\n+    public static String[] getRootCauseStackTrace(Throwable throwable) {\n+        if (throwable == null) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        Throwable throwables[] = getThrowables(throwable);\n+        int count = throwables.length;\n+        List<String> frames = new ArrayList<String>();\n+        List<String> nextTrace = getStackFrameList(throwables[count - 1]);\n+        for (int i = count; --i >= 0;) {\n+            List<String> trace = nextTrace;\n+            if (i != 0) {\n+                nextTrace = getStackFrameList(throwables[i - 1]);\n+                removeCommonFrames(trace, nextTrace);\n+            }\n+            if (i == count - 1) {\n+                frames.add(throwables[i].toString());\n+            } else {\n+                frames.add(WRAPPED_MARKER + throwables[i].toString());\n+            }\n+            for (int j = 0; j < trace.size(); j++) {\n+                frames.add(trace.get(j));\n+            }\n+        }\n+        return frames.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * <p>Removes common frames from the cause trace given the two stack traces.</p>\n+     *\n+     * @param causeFrames  stack trace of a cause throwable\n+     * @param wrapperFrames  stack trace of a wrapper throwable\n+     * @throws IllegalArgumentException if either argument is null\n+     * @since 2.0\n+     */\n+    public static void removeCommonFrames(List<String> causeFrames, List<String> wrapperFrames) {\n+        if (causeFrames == null || wrapperFrames == null) {\n+            throw new IllegalArgumentException(\"The List must not be null\");\n+        }\n+        int causeFrameIndex = causeFrames.size() - 1;\n+        int wrapperFrameIndex = wrapperFrames.size() - 1;\n+        while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0) {\n+            // Remove the frame from the cause trace if it is the same\n+            // as in the wrapper trace\n+            String causeFrame = causeFrames.get(causeFrameIndex);\n+            String wrapperFrame = wrapperFrames.get(wrapperFrameIndex);\n+            if (causeFrame.equals(wrapperFrame)) {\n+                causeFrames.remove(causeFrameIndex);\n+            }\n+            causeFrameIndex--;\n+            wrapperFrameIndex--;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>A way to get the entire nested stack-trace of an throwable.</p>\n+     *\n+     * <p>The result of this method is highly dependent on the JDK version\n+     * and whether the exceptions override printStackTrace or not.</p>\n+     *\n+     * @param throwable  the <code>Throwable</code> to be examined\n+     * @return the nested stack trace, with the root cause first\n+     * @since 2.0\n+     */\n+    public static String getFullStackTrace(Throwable throwable) {\n+        StringWriter sw = new StringWriter();\n+        PrintWriter pw = new PrintWriter(sw, true);\n+        Throwable[] ts = getThrowables(throwable);\n+        for (int i = 0; i < ts.length; i++) {\n+            ts[i].printStackTrace(pw);\n+            if (isNestedThrowable(ts[i])) {\n+                break;\n+            }\n+        }\n+        return sw.getBuffer().toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the stack trace from a Throwable as a String.</p>\n+     *\n+     * <p>The result of this method vary by JDK version as this method\n+     * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.\n+     * On JDK1.3 and earlier, the cause exception will not be shown\n+     * unless the specified throwable alters printStackTrace.</p>\n+     *\n+     * @param throwable  the <code>Throwable</code> to be examined\n+     * @return the stack trace as generated by the exception's\n+     *  <code>printStackTrace(PrintWriter)</code> method\n+     */\n+    public static String getStackTrace(Throwable throwable) {\n+        StringWriter sw = new StringWriter();\n+        PrintWriter pw = new PrintWriter(sw, true);\n+        throwable.printStackTrace(pw);\n+        return sw.getBuffer().toString();\n+    }\n+\n+    /**\n+     * <p>Captures the stack trace associated with the specified\n+     * <code>Throwable</code> object, decomposing it into a list of\n+     * stack frames.</p>\n+     *\n+     * <p>The result of this method vary by JDK version as this method\n+     * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.\n+     * On JDK1.3 and earlier, the cause exception will not be shown\n+     * unless the specified throwable alters printStackTrace.</p>\n+     *\n+     * @param throwable  the <code>Throwable</code> to examine, may be null\n+     * @return an array of strings describing each stack frame, never null\n+     */\n+    public static String[] getStackFrames(Throwable throwable) {\n+        if (throwable == null) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        return getStackFrames(getStackTrace(throwable));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns an array where each element is a line from the argument.</p>\n+     *\n+     * <p>The end of line is determined by the value of {@link SystemUtils#LINE_SEPARATOR}.</p>\n+     *\n+     * @param stackTrace  a stack trace String\n+     * @return an array where each element is a line from the argument\n+     */\n+    static String[] getStackFrames(String stackTrace) {\n+        String linebreak = SystemUtils.LINE_SEPARATOR;\n+        StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n+        List<String> list = new ArrayList<String>();\n+        while (frames.hasMoreTokens()) {\n+            list.add(frames.nextToken());\n+        }\n+        return toArray(list);\n+    }\n+\n+    /**\n+     * <p>Produces a <code>List</code> of stack frames - the message\n+     * is not included. Only the trace of the specified exception is\n+     * returned, any caused by trace is stripped.</p>\n+     *\n+     * <p>This works in most cases - it will only fail if the exception\n+     * message contains a line that starts with:\n+     * <code>&quot;&nbsp;&nbsp;&nbsp;at&quot;.</code></p>\n+     * \n+     * @param t is any throwable\n+     * @return List of stack frames\n+     */\n+    static List<String> getStackFrameList(Throwable t) {\n+        String stackTrace = getStackTrace(t);\n+        String linebreak = SystemUtils.LINE_SEPARATOR;\n+        StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n+        List<String> list = new ArrayList<String>();\n+        boolean traceStarted = false;\n+        while (frames.hasMoreTokens()) {\n+            String token = frames.nextToken();\n+            // Determine if the line starts with <whitespace>at\n+            int at = token.indexOf(\"at\");\n+            if (at != -1 && token.substring(0, at).trim().length() == 0) {\n+                traceStarted = true;\n+                list.add(token);\n+            } else if (traceStarted) {\n+                break;\n+            }\n+        }\n+        return list;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a short message summarising the exception.\n+     * <p>\n+     * The message returned is of the form\n+     * {ClassNameWithoutPackage}: {ThrowableMessage}\n+     *\n+     * @param th  the throwable to get a message for, null returns empty string\n+     * @return the message, non-null\n+     * @since Commons Lang 2.2\n+     */\n+    public static String getMessage(Throwable th) {\n+        if (th == null) {\n+            return \"\";\n+        }\n+        String clsName = ClassUtils.getShortClassName(th, null);\n+        String msg = th.getMessage();\n+        return clsName + \": \" + StringUtils.defaultString(msg);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a short message summarising the root cause exception.\n+     * <p>\n+     * The message returned is of the form\n+     * {ClassNameWithoutPackage}: {ThrowableMessage}\n+     *\n+     * @param th  the throwable to get a message for, null returns empty string\n+     * @return the message, non-null\n+     * @since Commons Lang 2.2\n+     */\n+    public static String getRootCauseMessage(Throwable th) {\n+        Throwable root = ExceptionUtils.getRootCause(th);\n+        root = (root == null ? th : root);\n+        return getMessage(root);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/math/Fraction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import java.math.BigInteger;\n+\n+/**\n+ * <p><code>Fraction</code> is a <code>Number</code> implementation that\n+ * stores fractions accurately.</p>\n+ *\n+ * <p>This class is immutable, and interoperable with most methods that accept\n+ * a <code>Number</code>.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Travis Reeder\n+ * @author Tim O'Brien\n+ * @author Pete Gieser\n+ * @author C. Scott Ananian\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public final class Fraction extends Number implements Comparable<Fraction> {\n+\n+    /**\n+     * Required for serialization support. Lang version 2.0.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 65382027393090L;\n+\n+    /**\n+     * <code>Fraction</code> representation of 0.\n+     */\n+    public static final Fraction ZERO = new Fraction(0, 1);\n+    /**\n+     * <code>Fraction</code> representation of 1.\n+     */\n+    public static final Fraction ONE = new Fraction(1, 1);\n+    /**\n+     * <code>Fraction</code> representation of 1/2.\n+     */\n+    public static final Fraction ONE_HALF = new Fraction(1, 2);\n+    /**\n+     * <code>Fraction</code> representation of 1/3.\n+     */\n+    public static final Fraction ONE_THIRD = new Fraction(1, 3);\n+    /**\n+     * <code>Fraction</code> representation of 2/3.\n+     */\n+    public static final Fraction TWO_THIRDS = new Fraction(2, 3);\n+    /**\n+     * <code>Fraction</code> representation of 1/4.\n+     */\n+    public static final Fraction ONE_QUARTER = new Fraction(1, 4);\n+    /**\n+     * <code>Fraction</code> representation of 2/4.\n+     */\n+    public static final Fraction TWO_QUARTERS = new Fraction(2, 4);\n+    /**\n+     * <code>Fraction</code> representation of 3/4.\n+     */\n+    public static final Fraction THREE_QUARTERS = new Fraction(3, 4);\n+    /**\n+     * <code>Fraction</code> representation of 1/5.\n+     */\n+    public static final Fraction ONE_FIFTH = new Fraction(1, 5);\n+    /**\n+     * <code>Fraction</code> representation of 2/5.\n+     */\n+    public static final Fraction TWO_FIFTHS = new Fraction(2, 5);\n+    /**\n+     * <code>Fraction</code> representation of 3/5.\n+     */\n+    public static final Fraction THREE_FIFTHS = new Fraction(3, 5);\n+    /**\n+     * <code>Fraction</code> representation of 4/5.\n+     */\n+    public static final Fraction FOUR_FIFTHS = new Fraction(4, 5);\n+\n+\n+    /**\n+     * The numerator number part of the fraction (the three in three sevenths).\n+     */\n+    private final int numerator;\n+    /**\n+     * The denominator number part of the fraction (the seven in three sevenths).\n+     */\n+    private final int denominator;\n+\n+    /**\n+     * Cached output hashCode (class is immutable).\n+     */\n+    private transient int hashCode = 0;\n+    /**\n+     * Cached output toString (class is immutable).\n+     */\n+    private transient String toString = null;\n+    /**\n+     * Cached output toProperString (class is immutable).\n+     */\n+    private transient String toProperString = null;\n+\n+    /**\n+     * <p>Constructs a <code>Fraction</code> instance with the 2 parts\n+     * of a fraction Y/Z.</p>\n+     *\n+     * @param numerator  the numerator, for example the three in 'three sevenths'\n+     * @param denominator  the denominator, for example the seven in 'three sevenths'\n+     */\n+    private Fraction(int numerator, int denominator) {\n+        super();\n+        this.numerator = numerator;\n+        this.denominator = denominator;\n+    }\n+\n+    /**\n+     * <p>Creates a <code>Fraction</code> instance with the 2 parts\n+     * of a fraction Y/Z.</p>\n+     *\n+     * <p>Any negative signs are resolved to be on the numerator.</p>\n+     *\n+     * @param numerator  the numerator, for example the three in 'three sevenths'\n+     * @param denominator  the denominator, for example the seven in 'three sevenths'\n+     * @return a new fraction instance\n+     * @throws ArithmeticException if the denomiator is <code>zero</code>\n+     */\n+    public static Fraction getFraction(int numerator, int denominator) {\n+        if (denominator == 0) {\n+            throw new ArithmeticException(\"The denominator must not be zero\");\n+        }\n+        if (denominator < 0) {\n+            if (numerator==Integer.MIN_VALUE ||\n+                    denominator==Integer.MIN_VALUE) {\n+                throw new ArithmeticException(\"overflow: can't negate\");\n+            }\n+            numerator = -numerator;\n+            denominator = -denominator;\n+        }\n+        return new Fraction(numerator, denominator);\n+    }\n+\n+    /**\n+     * <p>Creates a <code>Fraction</code> instance with the 3 parts\n+     * of a fraction X Y/Z.</p>\n+     *\n+     * <p>The negative sign must be passed in on the whole number part.</p>\n+     *\n+     * @param whole  the whole number, for example the one in 'one and three sevenths'\n+     * @param numerator  the numerator, for example the three in 'one and three sevenths'\n+     * @param denominator  the denominator, for example the seven in 'one and three sevenths'\n+     * @return a new fraction instance\n+     * @throws ArithmeticException if the denomiator is <code>zero</code>\n+     * @throws ArithmeticException if the denominator is negative\n+     * @throws ArithmeticException if the numerator is negative\n+     * @throws ArithmeticException if the resulting numerator exceeds \n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public static Fraction getFraction(int whole, int numerator, int denominator) {\n+        if (denominator == 0) {\n+            throw new ArithmeticException(\"The denominator must not be zero\");\n+        }\n+        if (denominator < 0) {\n+            throw new ArithmeticException(\"The denominator must not be negative\");\n+        }\n+        if (numerator < 0) {\n+            throw new ArithmeticException(\"The numerator must not be negative\");\n+        }\n+        long numeratorValue;\n+        if (whole < 0) {\n+            numeratorValue = whole * (long)denominator - numerator;\n+        } else {\n+            numeratorValue = whole * (long)denominator + numerator;\n+        }\n+        if (numeratorValue < Integer.MIN_VALUE ||\n+                numeratorValue > Integer.MAX_VALUE)  {\n+            throw new ArithmeticException(\"Numerator too large to represent as an Integer.\");\n+        }\n+        return new Fraction((int) numeratorValue, denominator);\n+    }\n+\n+    /**\n+     * <p>Creates a reduced <code>Fraction</code> instance with the 2 parts\n+     * of a fraction Y/Z.</p>\n+     *\n+     * <p>For example, if the input parameters represent 2/4, then the created\n+     * fraction will be 1/2.</p>\n+     *\n+     * <p>Any negative signs are resolved to be on the numerator.</p>\n+     *\n+     * @param numerator  the numerator, for example the three in 'three sevenths'\n+     * @param denominator  the denominator, for example the seven in 'three sevenths'\n+     * @return a new fraction instance, with the numerator and denominator reduced\n+     * @throws ArithmeticException if the denominator is <code>zero</code>\n+     */\n+    public static Fraction getReducedFraction(int numerator, int denominator) {\n+        if (denominator == 0) {\n+            throw new ArithmeticException(\"The denominator must not be zero\");\n+        }\n+        if (numerator==0) {\n+            return ZERO; // normalize zero.\n+        }\n+        // allow 2^k/-2^31 as a valid fraction (where k>0)\n+        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n+            numerator/=2; denominator/=2;\n+        }\n+        if (denominator < 0) {\n+            if (numerator==Integer.MIN_VALUE ||\n+                    denominator==Integer.MIN_VALUE) {\n+                throw new ArithmeticException(\"overflow: can't negate\");\n+            }\n+            numerator = -numerator;\n+            denominator = -denominator;\n+        }\n+        // simplify fraction.\n+        int gcd = greatestCommonDivisor(numerator, denominator);\n+        numerator /= gcd;\n+        denominator /= gcd;\n+        return new Fraction(numerator, denominator);\n+    }\n+\n+    /**\n+     * <p>Creates a <code>Fraction</code> instance from a <code>double</code> value.</p>\n+     *\n+     * <p>This method uses the <a href=\"http://archives.math.utk.edu/articles/atuyl/confrac/\">\n+     *  continued fraction algorithm</a>, computing a maximum of\n+     *  25 convergents and bounding the denominator by 10,000.</p>\n+     *\n+     * @param value  the double value to convert\n+     * @return a new fraction instance that is close to the value\n+     * @throws ArithmeticException if <code>|value| > Integer.MAX_VALUE</code> \n+     *  or <code>value = NaN</code>\n+     * @throws ArithmeticException if the calculated denominator is <code>zero</code>\n+     * @throws ArithmeticException if the the algorithm does not converge\n+     */\n+    public static Fraction getFraction(double value) {\n+        int sign = (value < 0 ? -1 : 1);\n+        value = Math.abs(value);\n+        if (value  > Integer.MAX_VALUE || Double.isNaN(value)) {\n+            throw new ArithmeticException\n+                (\"The value must not be greater than Integer.MAX_VALUE or NaN\");\n+        }\n+        int wholeNumber = (int) value;\n+        value -= wholeNumber;\n+        \n+        int numer0 = 0;  // the pre-previous\n+        int denom0 = 1;  // the pre-previous\n+        int numer1 = 1;  // the previous\n+        int denom1 = 0;  // the previous\n+        int numer2 = 0;  // the current, setup in calculation\n+        int denom2 = 0;  // the current, setup in calculation\n+        int a1 = (int) value;\n+        int a2 = 0;\n+        double x1 = 1;\n+        double x2 = 0;\n+        double y1 = value - a1;\n+        double y2 = 0;\n+        double delta1, delta2 = Double.MAX_VALUE;\n+        double fraction;\n+        int i = 1;\n+//        System.out.println(\"---\");\n+        do {\n+            delta1 = delta2;\n+            a2 = (int) (x1 / y1);\n+            x2 = y1;\n+            y2 = x1 - a2 * y1;\n+            numer2 = a1 * numer1 + numer0;\n+            denom2 = a1 * denom1 + denom0;\n+            fraction = (double) numer2 / (double) denom2;\n+            delta2 = Math.abs(value - fraction);\n+//            System.out.println(numer2 + \" \" + denom2 + \" \" + fraction + \" \" + delta2 + \" \" + y1);\n+            a1 = a2;\n+            x1 = x2;\n+            y1 = y2;\n+            numer0 = numer1;\n+            denom0 = denom1;\n+            numer1 = numer2;\n+            denom1 = denom2;\n+            i++;\n+//            System.out.println(\">>\" + delta1 +\" \"+ delta2+\" \"+(delta1 > delta2)+\" \"+i+\" \"+denom2);\n+        } while ((delta1 > delta2) && (denom2 <= 10000) && (denom2 > 0) && (i < 25));\n+        if (i == 25) {\n+            throw new ArithmeticException(\"Unable to convert double to fraction\");\n+        }\n+        return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0);\n+    }\n+\n+    /**\n+     * <p>Creates a Fraction from a <code>String</code>.</p>\n+     *\n+     * <p>The formats accepted are:</p>\n+     *\n+     * <ol>\n+     *  <li><code>double</code> String containing a dot</li>\n+     *  <li>'X Y/Z'</li>\n+     *  <li>'Y/Z'</li>\n+     *  <li>'X' (a simple whole number)</li>\n+     * </ol>\n+     * and a .</p>\n+     *\n+     * @param str  the string to parse, must not be <code>null</code>\n+     * @return the new <code>Fraction</code> instance\n+     * @throws IllegalArgumentException if the string is <code>null</code>\n+     * @throws NumberFormatException if the number format is invalid\n+     */\n+    public static Fraction getFraction(String str) {\n+        if (str == null) {\n+            throw new IllegalArgumentException(\"The string must not be null\");\n+        }\n+        // parse double format\n+        int pos = str.indexOf('.');\n+        if (pos >= 0) {\n+            return getFraction(Double.parseDouble(str));\n+        }\n+\n+        // parse X Y/Z format\n+        pos = str.indexOf(' ');\n+        if (pos > 0) {\n+            int whole = Integer.parseInt(str.substring(0, pos));\n+            str = str.substring(pos + 1);\n+            pos = str.indexOf('/');\n+            if (pos < 0) {\n+                throw new NumberFormatException(\"The fraction could not be parsed as the format X Y/Z\");\n+            } else {\n+                int numer = Integer.parseInt(str.substring(0, pos));\n+                int denom = Integer.parseInt(str.substring(pos + 1));\n+                return getFraction(whole, numer, denom);\n+            }\n+        }\n+\n+        // parse Y/Z format\n+        pos = str.indexOf('/');\n+        if (pos < 0) {\n+            // simple whole number\n+            return getFraction(Integer.parseInt(str), 1);\n+        } else {\n+            int numer = Integer.parseInt(str.substring(0, pos));\n+            int denom = Integer.parseInt(str.substring(pos + 1));\n+            return getFraction(numer, denom);\n+        }\n+    }\n+\n+    // Accessors\n+    //-------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the numerator part of the fraction.</p>\n+     *\n+     * <p>This method may return a value greater than the denominator, an\n+     * improper fraction, such as the seven in 7/4.</p>\n+     *\n+     * @return the numerator fraction part\n+     */\n+    public int getNumerator() {\n+        return numerator;\n+    }\n+\n+    /**\n+     * <p>Gets the denominator part of the fraction.</p>\n+     *\n+     * @return the denominator fraction part\n+     */\n+    public int getDenominator() {\n+        return denominator;\n+    }\n+\n+    /**\n+     * <p>Gets the proper numerator, always positive.</p>\n+     *\n+     * <p>An improper fraction 7/4 can be resolved into a proper one, 1 3/4.\n+     * This method returns the 3 from the proper fraction.</p>\n+     *\n+     * <p>If the fraction is negative such as -7/4, it can be resolved into\n+     * -1 3/4, so this method returns the positive proper numerator, 3.</p>\n+     *\n+     * @return the numerator fraction part of a proper fraction, always positive\n+     */\n+    public int getProperNumerator() {\n+        return Math.abs(numerator % denominator);\n+    }\n+\n+    /**\n+     * <p>Gets the proper whole part of the fraction.</p>\n+     *\n+     * <p>An improper fraction 7/4 can be resolved into a proper one, 1 3/4.\n+     * This method returns the 1 from the proper fraction.</p>\n+     *\n+     * <p>If the fraction is negative such as -7/4, it can be resolved into\n+     * -1 3/4, so this method returns the positive whole part -1.</p>\n+     *\n+     * @return the whole fraction part of a proper fraction, that includes the sign\n+     */\n+    public int getProperWhole() {\n+        return numerator / denominator;\n+    }\n+\n+    // Number methods\n+    //-------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the fraction as an <code>int</code>. This returns the whole number\n+     * part of the fraction.</p>\n+     *\n+     * @return the whole number fraction part\n+     */\n+    @Override\n+    public int intValue() {\n+        return numerator / denominator;\n+    }\n+\n+    /**\n+     * <p>Gets the fraction as a <code>long</code>. This returns the whole number\n+     * part of the fraction.</p>\n+     *\n+     * @return the whole number fraction part\n+     */\n+    @Override\n+    public long longValue() {\n+        return (long) numerator / denominator;\n+    }\n+\n+    /**\n+     * <p>Gets the fraction as a <code>float</code>. This calculates the fraction\n+     * as the numerator divided by denominator.</p>\n+     *\n+     * @return the fraction as a <code>float</code>\n+     */\n+    @Override\n+    public float floatValue() {\n+        return ((float) numerator) / ((float) denominator);\n+    }\n+\n+    /**\n+     * <p>Gets the fraction as a <code>double</code>. This calculates the fraction\n+     * as the numerator divided by denominator.</p>\n+     *\n+     * @return the fraction as a <code>double</code>\n+     */\n+    @Override\n+    public double doubleValue() {\n+        return ((double) numerator) / ((double) denominator);\n+    }\n+\n+    // Calculations\n+    //-------------------------------------------------------------------\n+\n+    /**\n+     * <p>Reduce the fraction to the smallest values for the numerator and\n+     * denominator, returning the result.</p>\n+     * \n+     * <p>For example, if this fraction represents 2/4, then the result\n+     * will be 1/2.</p>\n+     *\n+     * @return a new reduced fraction instance, or this if no simplification possible\n+     */\n+    public Fraction reduce() {\n+        if (numerator == 0) {\n+            return equals(ZERO) ? this : ZERO;\n+        }\n+        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n+        if (gcd == 1) {\n+            return this;\n+        }\n+        return Fraction.getFraction(numerator / gcd, denominator / gcd);\n+    }\n+\n+    /**\n+     * <p>Gets a fraction that is the inverse (1/fraction) of this one.</p>\n+     * \n+     * <p>The returned fraction is not reduced.</p>\n+     *\n+     * @return a new fraction instance with the numerator and denominator\n+     *         inverted.\n+     * @throws ArithmeticException if the fraction represents zero.\n+     */\n+    public Fraction invert() {\n+        if (numerator == 0) {\n+            throw new ArithmeticException(\"Unable to invert zero.\");\n+        }\n+        if (numerator==Integer.MIN_VALUE) {\n+            throw new ArithmeticException(\"overflow: can't negate numerator\");\n+        }\n+        if (numerator<0) {\n+            return new Fraction(-denominator, -numerator);\n+        } else {\n+            return new Fraction(denominator, numerator);\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets a fraction that is the negative (-fraction) of this one.</p>\n+     *\n+     * <p>The returned fraction is not reduced.</p>\n+     *\n+     * @return a new fraction instance with the opposite signed numerator\n+     */\n+    public Fraction negate() {\n+        // the positive range is one smaller than the negative range of an int.\n+        if (numerator==Integer.MIN_VALUE) {\n+            throw new ArithmeticException(\"overflow: too large to negate\");\n+        }\n+        return new Fraction(-numerator, denominator);\n+    }\n+\n+    /**\n+     * <p>Gets a fraction that is the positive equivalent of this one.</p>\n+     * <p>More precisely: <code>(fraction >= 0 ? this : -fraction)</code></p>\n+     *\n+     * <p>The returned fraction is not reduced.</p>\n+     *\n+     * @return <code>this</code> if it is positive, or a new positive fraction\n+     *  instance with the opposite signed numerator\n+     */\n+    public Fraction abs() {\n+        if (numerator >= 0) {\n+            return this;\n+        }\n+        return negate();\n+    }\n+\n+    /**\n+     * <p>Gets a fraction that is raised to the passed in power.</p>\n+     *\n+     * <p>The returned fraction is in reduced form.</p>\n+     *\n+     * @param power  the power to raise the fraction to\n+     * @return <code>this</code> if the power is one, <code>ONE</code> if the power\n+     * is zero (even if the fraction equals ZERO) or a new fraction instance \n+     * raised to the appropriate power\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction pow(int power) {\n+        if (power == 1) {\n+            return this;\n+        } else if (power == 0) {\n+            return ONE;\n+        } else if (power < 0) {\n+            if (power==Integer.MIN_VALUE) { // MIN_VALUE can't be negated.\n+                return this.invert().pow(2).pow(-(power/2));\n+            }\n+            return this.invert().pow(-power);\n+        } else {\n+            Fraction f = this.multiplyBy(this);\n+            if ((power % 2) == 0) { // if even...\n+                return f.pow(power/2);\n+            } else { // if odd...\n+                return f.pow(power/2).multiplyBy(this);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets the greatest common divisor of the absolute value of\n+     * two numbers, using the \"binary gcd\" method which avoids\n+     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n+     * This algorithm is due to Josef Stein (1961).</p>\n+     *\n+     * @param u  a non-zero number\n+     * @param v  a non-zero number\n+     * @return the greatest common divisor, never zero\n+     */\n+    private static int greatestCommonDivisor(int u, int v) {\n+        //if either op. is abs 0 or 1, return 1:\n+        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+            return 1;\n+        }\n+        // keep u and v negative, as negative integers range down to\n+        // -2^31, while positive numbers can only be as large as 2^31-1\n+        // (i.e. we can't necessarily negate a negative number without\n+        // overflow)\n+        if (u>0) { u=-u; } // make u negative\n+        if (v>0) { v=-v; } // make v negative\n+        // B1. [Find power of 2]\n+        int k=0;\n+        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n+            u/=2; v/=2; k++; // cast out twos.\n+        }\n+        if (k==31) {\n+            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n+        }\n+        // B2. Initialize: u and v have been divided by 2^k and at least\n+        //     one is odd.\n+        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n+        // t negative: u was odd, v may be even (t replaces v)\n+        // t positive: u was even, v is odd (t replaces u)\n+        do {\n+            /* assert u<0 && v<0; */\n+            // B4/B3: cast out twos from t.\n+            while ((t&1)==0) { // while t is even..\n+                t/=2; // cast out twos\n+            }\n+            // B5 [reset max(u,v)]\n+            if (t>0) {\n+                u = -t;\n+            } else {\n+                v = t;\n+            }\n+            // B6/B3. at this point both u and v should be odd.\n+            t = (v - u)/2;\n+            // |u| larger: t positive (replace u)\n+            // |v| larger: t negative (replace v)\n+        } while (t!=0);\n+        return -u*(1<<k); // gcd is u*2^k\n+    }\n+\n+    // Arithmetic\n+    //-------------------------------------------------------------------\n+\n+    /** \n+     * Multiply two integers, checking for overflow.\n+     * \n+     * @param x a factor\n+     * @param y a factor\n+     * @return the product <code>x*y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     *                             an int\n+     */\n+    private static int mulAndCheck(int x, int y) {\n+        long m = ((long)x)*((long)y);\n+        if (m < Integer.MIN_VALUE ||\n+            m > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: mul\");\n+        }\n+        return (int)m;\n+    }\n+    \n+    /**\n+     *  Multiply two non-negative integers, checking for overflow.\n+     * \n+     * @param x a non-negative factor\n+     * @param y a non-negative factor\n+     * @return the product <code>x*y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     * an int\n+     */\n+    private static int mulPosAndCheck(int x, int y) {\n+        /* assert x>=0 && y>=0; */\n+        long m = ((long)x)*((long)y);\n+        if (m > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: mulPos\");\n+        }\n+        return (int)m;\n+    }\n+    \n+    /** \n+     * Add two integers, checking for overflow.\n+     * \n+     * @param x an addend\n+     * @param y an addend\n+     * @return the sum <code>x+y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     * an int\n+     */\n+    private static int addAndCheck(int x, int y) {\n+        long s = (long)x+(long)y;\n+        if (s < Integer.MIN_VALUE ||\n+            s > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: add\");\n+        }\n+        return (int)s;\n+    }\n+    \n+    /** \n+     * Subtract two integers, checking for overflow.\n+     * \n+     * @param x the minuend\n+     * @param y the subtrahend\n+     * @return the difference <code>x-y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     * an int\n+     */\n+    private static int subAndCheck(int x, int y) {\n+        long s = (long)x-(long)y;\n+        if (s < Integer.MIN_VALUE ||\n+            s > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: add\");\n+        }\n+        return (int)s;\n+    }\n+    \n+    /**\n+     * <p>Adds the value of this fraction to another, returning the result in reduced form.\n+     * The algorithm follows Knuth, 4.5.1.</p>\n+     *\n+     * @param fraction  the fraction to add, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction add(Fraction fraction) {\n+        return addSub(fraction, true /* add */);\n+    }\n+\n+    /**\n+     * <p>Subtracts the value of another fraction from the value of this one, \n+     * returning the result in reduced form.</p>\n+     *\n+     * @param fraction  the fraction to subtract, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator\n+     *   cannot be represented in an <code>int</code>.\n+     */\n+    public Fraction subtract(Fraction fraction) {\n+        return addSub(fraction, false /* subtract */);\n+    }\n+\n+    /** \n+     * Implement add and subtract using algorithm described in Knuth 4.5.1.\n+     * \n+     * @param fraction the fraction to subtract, must not be <code>null</code>\n+     * @param isAdd true to add, false to subtract\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator\n+     *   cannot be represented in an <code>int</code>.\n+     */\n+    private Fraction addSub(Fraction fraction, boolean isAdd) {\n+        if (fraction == null) {\n+            throw new IllegalArgumentException(\"The fraction must not be null\");\n+        }\n+        // zero is identity for addition.\n+        if (numerator == 0) {\n+            return isAdd ? fraction : fraction.negate();\n+        }\n+        if (fraction.numerator == 0) {\n+            return this;\n+        }     \n+        // if denominators are randomly distributed, d1 will be 1 about 61%\n+        // of the time.\n+        int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n+        if (d1==1) {\n+            // result is ( (u*v' +/- u'v) / u'v')\n+            int uvp = mulAndCheck(numerator, fraction.denominator);\n+            int upv = mulAndCheck(fraction.numerator, denominator);\n+            return new Fraction\n+                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n+                 mulPosAndCheck(denominator, fraction.denominator));\n+        }\n+        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n+        // exercise 7.  we're going to use a BigInteger.\n+        // t = u(v'/d1) +/- v(u'/d1)\n+        BigInteger uvp = BigInteger.valueOf(numerator)\n+            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n+        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n+            .multiply(BigInteger.valueOf(denominator/d1));\n+        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n+        // but d2 doesn't need extra precision because\n+        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n+        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n+        int d2 = (tmodd1==0)?d1:greatestCommonDivisor(tmodd1, d1);\n+\n+        // result is (t/d2) / (u'/d1)(v'/d2)\n+        BigInteger w = t.divide(BigInteger.valueOf(d2));\n+        if (w.bitLength() > 31) {\n+            throw new ArithmeticException\n+                (\"overflow: numerator too large after multiply\");\n+        }\n+        return new Fraction\n+            (w.intValue(),\n+             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n+    }\n+\n+    /**\n+     * <p>Multiplies the value of this fraction by another, returning the \n+     * result in reduced form.</p>\n+     *\n+     * @param fraction  the fraction to multiply by, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction multiplyBy(Fraction fraction) {\n+        if (fraction == null) {\n+            throw new IllegalArgumentException(\"The fraction must not be null\");\n+        }\n+        if (numerator == 0 || fraction.numerator == 0) {\n+            return ZERO;\n+        }\n+        // knuth 4.5.1\n+        // make sure we don't overflow unless the result *must* overflow.\n+        int d1 = greatestCommonDivisor(numerator, fraction.denominator);\n+        int d2 = greatestCommonDivisor(fraction.numerator, denominator);\n+        return getReducedFraction\n+            (mulAndCheck(numerator/d1, fraction.numerator/d2),\n+             mulPosAndCheck(denominator/d2, fraction.denominator/d1));\n+    }\n+\n+    /**\n+     * <p>Divide the value of this fraction by another.</p>\n+     *\n+     * @param fraction  the fraction to divide by, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the fraction to divide by is zero\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction divideBy(Fraction fraction) {\n+        if (fraction == null) {\n+            throw new IllegalArgumentException(\"The fraction must not be null\");\n+        }\n+        if (fraction.numerator == 0) {\n+            throw new ArithmeticException(\"The fraction to divide by must not be zero\");\n+        }\n+        return multiplyBy(fraction.invert());\n+    }\n+\n+    // Basics\n+    //-------------------------------------------------------------------\n+\n+    /**\n+     * <p>Compares this fraction to another object to test if they are equal.</p>.\n+     *\n+     * <p>To be equal, both values must be equal. Thus 2/4 is not equal to 1/2.</p>\n+     *\n+     * @param obj the reference object with which to compare\n+     * @return <code>true</code> if this object is equal\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Fraction == false) {\n+            return false;\n+        }\n+        Fraction other = (Fraction) obj;\n+        return (getNumerator() == other.getNumerator() &&\n+                getDenominator() == other.getDenominator());\n+    }\n+\n+    /**\n+     * <p>Gets a hashCode for the fraction.</p>\n+     *\n+     * @return a hash code value for this object\n+     */\n+    @Override\n+    public int hashCode() {\n+        if (hashCode == 0) {\n+            // hashcode update should be atomic.\n+            hashCode = 37 * (37 * 17 + getNumerator()) + getDenominator();\n+        }\n+        return hashCode;\n+    }\n+\n+    /**\n+     * <p>Compares this object to another based on size.</p>\n+     *\n+     * <p>Note: this class has a natural ordering that is inconsistent\n+     * with equals, because, for example, equals treats 1/2 and 2/4 as\n+     * different, whereas compareTo treats them as equal.\n+     *\n+     * @param other  the object to compare to\n+     * @return -1 if this is less, 0 if equal, +1 if greater\n+     * @throws ClassCastException if the object is not a <code>Fraction</code>\n+     * @throws NullPointerException if the object is <code>null</code>\n+     */\n+    public int compareTo(Fraction other) {\n+        if (this==other) {\n+            return 0;\n+        }\n+        if (numerator == other.numerator && denominator == other.denominator) {\n+            return 0;\n+        }\n+\n+        // otherwise see which is less\n+        long first = (long) numerator * (long) other.denominator;\n+        long second = (long) other.numerator * (long) denominator;\n+        if (first == second) {\n+            return 0;\n+        } else if (first < second) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets the fraction as a <code>String</code>.</p>\n+     *\n+     * <p>The format used is '<i>numerator</i>/<i>denominator</i>' always.\n+     *\n+     * @return a <code>String</code> form of the fraction\n+     */\n+    @Override\n+    public String toString() {\n+        if (toString == null) {\n+            toString = new StringBuilder(32)\n+                .append(getNumerator())\n+                .append('/')\n+                .append(getDenominator()).toString();\n+        }\n+        return toString;\n+    }\n+\n+    /**\n+     * <p>Gets the fraction as a proper <code>String</code> in the format X Y/Z.</p>\n+     *\n+     * <p>The format used in '<i>wholeNumber</i> <i>numerator</i>/<i>denominator</i>'.\n+     * If the whole number is zero it will be ommitted. If the numerator is zero,\n+     * only the whole number is returned.</p>\n+     *\n+     * @return a <code>String</code> form of the fraction\n+     */\n+    public String toProperString() {\n+        if (toProperString == null) {\n+            if (numerator == 0) {\n+                toProperString = \"0\";\n+            } else if (numerator == denominator) {\n+                toProperString = \"1\";\n+            } else if (numerator == -1 * denominator) {\n+                toProperString = \"-1\";\n+            } else if ((numerator>0?-numerator:numerator) < -denominator) {\n+                // note that we do the magnitude comparison test above with\n+                // NEGATIVE (not positive) numbers, since negative numbers\n+                // have a larger range.  otherwise numerator==Integer.MIN_VALUE\n+                // is handled incorrectly.\n+                int properNumerator = getProperNumerator();\n+                if (properNumerator == 0) {\n+                    toProperString = Integer.toString(getProperWhole());\n+                } else {\n+                    toProperString = new StringBuilder(32)\n+                        .append(getProperWhole()).append(' ')\n+                        .append(properNumerator).append('/')\n+                        .append(getDenominator()).toString();\n+                }\n+            } else {\n+                toProperString = new StringBuilder(32)\n+                    .append(getNumerator()).append('/')\n+                    .append(getDenominator()).toString();\n+            }\n+        }\n+        return toProperString;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/math/IEEE754rUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+/**\n+ * <p>Provides IEEE-754r variants of NumberUtils methods. </p>\n+ *\n+ * <p>See: <a href=\"http://en.wikipedia.org/wiki/IEEE_754r\">http://en.wikipedia.org/wiki/IEEE_754r</a></p>\n+ *\n+ * @since 2.4\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class IEEE754rUtils {\n+    \n+     /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static double min(double[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        double min = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            min = min(array[i], min);\n+        }\n+    \n+        return min;\n+    }\n+\n+    /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static float min(float[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        float min = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            min = min(array[i], min);\n+        }\n+    \n+        return min;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>double</code> values.</p>\n+     * \n+     * <p>NaN is only returned if all numbers are NaN as per IEEE-754r. </p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+    public static double min(double a, double b, double c) {\n+        return min(min(a, b), c);\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of two <code>double</code> values.</p>\n+     * \n+     * <p>NaN is only returned if all numbers are NaN as per IEEE-754r. </p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @return  the smallest of the values\n+     */\n+    public static double min(double a, double b) {\n+        if(Double.isNaN(a)) {\n+            return b;\n+        } else\n+        if(Double.isNaN(b)) {\n+            return a;\n+        } else {\n+            return Math.min(a, b);\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>float</code> values.</p>\n+     * \n+     * <p>NaN is only returned if all numbers are NaN as per IEEE-754r. </p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+    public static float min(float a, float b, float c) {\n+        return min(min(a, b), c);\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of two <code>float</code> values.</p>\n+     * \n+     * <p>NaN is only returned if all numbers are NaN as per IEEE-754r. </p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @return  the smallest of the values\n+     */\n+    public static float min(float a, float b) {\n+        if(Float.isNaN(a)) {\n+            return b;\n+        } else\n+        if(Float.isNaN(b)) {\n+            return a;\n+        } else {\n+            return Math.min(a, b);\n+        }\n+    }\n+\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static double max(double[] array) {\n+        // Validates input\n+        if (array== null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns max\n+        double max = array[0];\n+        for (int j = 1; j < array.length; j++) {\n+            max = max(array[j], max);\n+        }\n+    \n+        return max;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static float max(float[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+\n+        // Finds and returns max\n+        float max = array[0];\n+        for (int j = 1; j < array.length; j++) {\n+            max = max(array[j], max);\n+        }\n+\n+        return max;\n+    }\n+     \n+    /**\n+     * <p>Gets the maximum of three <code>double</code> values.</p>\n+     * \n+     * <p>NaN is only returned if all numbers are NaN as per IEEE-754r. </p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static double max(double a, double b, double c) {\n+        return max(max(a, b), c);\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of two <code>double</code> values.</p>\n+     * \n+     * <p>NaN is only returned if all numbers are NaN as per IEEE-754r. </p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @return  the largest of the values\n+     */\n+    public static double max(double a, double b) {\n+        if(Double.isNaN(a)) {\n+            return b;\n+        } else\n+        if(Double.isNaN(b)) {\n+            return a;\n+        } else {\n+            return Math.max(a, b);\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of three <code>float</code> values.</p>\n+     * \n+     * <p>NaN is only returned if all numbers are NaN as per IEEE-754r. </p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static float max(float a, float b, float c) {\n+        return max(max(a, b), c);\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of two <code>float</code> values.</p>\n+     * \n+     * <p>NaN is only returned if all numbers are NaN as per IEEE-754r. </p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @return  the largest of the values\n+     */\n+    public static float max(float a, float b) {\n+        if(Float.isNaN(a)) {\n+            return b;\n+        } else\n+        if(Float.isNaN(b)) {\n+            return a;\n+        } else {\n+            return Math.max(a, b);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/math/NumberUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import org.apache.commons.lang.StringUtils;\n+\n+/**\n+ * <p>Provides extra functionality for Java Number classes.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:rand_mcneely@yahoo.com\">Rand McNeely</a>\n+ * @author <a href=\"mailto:steve.downey@netfolio.com\">Steve Downey</a>\n+ * @author Eric Pugh\n+ * @author Phil Steitz\n+ * @author Matthew Hawthorne\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author <a href=\"mailto:fredrik@westermarck.com\">Fredrik Westermarck</a>\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class NumberUtils {\n+    \n+    /** Reusable Long constant for zero. */\n+    public static final Long LONG_ZERO = new Long(0L);\n+    /** Reusable Long constant for one. */\n+    public static final Long LONG_ONE = new Long(1L);\n+    /** Reusable Long constant for minus one. */\n+    public static final Long LONG_MINUS_ONE = new Long(-1L);\n+    /** Reusable Integer constant for zero. */\n+    public static final Integer INTEGER_ZERO = new Integer(0);\n+    /** Reusable Integer constant for one. */\n+    public static final Integer INTEGER_ONE = new Integer(1);\n+    /** Reusable Integer constant for minus one. */\n+    public static final Integer INTEGER_MINUS_ONE = new Integer(-1);\n+    /** Reusable Short constant for zero. */\n+    public static final Short SHORT_ZERO = new Short((short) 0);\n+    /** Reusable Short constant for one. */\n+    public static final Short SHORT_ONE = new Short((short) 1);\n+    /** Reusable Short constant for minus one. */\n+    public static final Short SHORT_MINUS_ONE = new Short((short) -1);\n+    /** Reusable Byte constant for zero. */\n+    public static final Byte BYTE_ZERO = Byte.valueOf((byte) 0);\n+    /** Reusable Byte constant for one. */\n+    public static final Byte BYTE_ONE = Byte.valueOf((byte) 1);\n+    /** Reusable Byte constant for minus one. */\n+    public static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1);\n+    /** Reusable Double constant for zero. */\n+    public static final Double DOUBLE_ZERO = new Double(0.0d);\n+    /** Reusable Double constant for one. */\n+    public static final Double DOUBLE_ONE = new Double(1.0d);\n+    /** Reusable Double constant for minus one. */\n+    public static final Double DOUBLE_MINUS_ONE = new Double(-1.0d);\n+    /** Reusable Float constant for zero. */\n+    public static final Float FLOAT_ZERO = new Float(0.0f);\n+    /** Reusable Float constant for one. */\n+    public static final Float FLOAT_ONE = new Float(1.0f);\n+    /** Reusable Float constant for minus one. */\n+    public static final Float FLOAT_MINUS_ONE = new Float(-1.0f);\n+\n+    /**\n+     * <p><code>NumberUtils</code> instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>NumberUtils.toInt(\"6\");</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public NumberUtils() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Convert a <code>String</code> to an <code>int</code>, returning\n+     * <code>zero</code> if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, <code>zero</code> is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toInt(null) = 0\n+     *   NumberUtils.toInt(\"\")   = 0\n+     *   NumberUtils.toInt(\"1\")  = 1\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @return the int represented by the string, or <code>zero</code> if\n+     *  conversion fails\n+     * @since 2.1\n+     */\n+    public static int toInt(String str) {\n+        return toInt(str, 0);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to an <code>int</code>, returning a\n+     * default value if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, the default value is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toInt(null, 1) = 1\n+     *   NumberUtils.toInt(\"\", 1)   = 1\n+     *   NumberUtils.toInt(\"1\", 0)  = 1\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @param defaultValue  the default value\n+     * @return the int represented by the string, or the default if conversion fails\n+     * @since 2.1\n+     */\n+    public static int toInt(String str, int defaultValue) {\n+        if(str == null) {\n+            return defaultValue;\n+        }\n+        try {\n+            return Integer.parseInt(str);\n+        } catch (NumberFormatException nfe) {\n+            return defaultValue;\n+        }\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>long</code>, returning\n+     * <code>zero</code> if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, <code>zero</code> is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toLong(null) = 0L\n+     *   NumberUtils.toLong(\"\")   = 0L\n+     *   NumberUtils.toLong(\"1\")  = 1L\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @return the long represented by the string, or <code>0</code> if\n+     *  conversion fails\n+     * @since 2.1\n+     */\n+    public static long toLong(String str) {\n+        return toLong(str, 0L);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>long</code>, returning a\n+     * default value if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, the default value is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toLong(null, 1L) = 1L\n+     *   NumberUtils.toLong(\"\", 1L)   = 1L\n+     *   NumberUtils.toLong(\"1\", 0L)  = 1L\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @param defaultValue  the default value\n+     * @return the long represented by the string, or the default if conversion fails\n+     * @since 2.1\n+     */\n+    public static long toLong(String str, long defaultValue) {\n+        if (str == null) {\n+            return defaultValue;\n+        }\n+        try {\n+            return Long.parseLong(str);\n+        } catch (NumberFormatException nfe) {\n+            return defaultValue;\n+        }\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>float</code>, returning\n+     * <code>0.0f</code> if the conversion fails.</p>\n+     *\n+     * <p>If the string <code>str</code> is <code>null</code>,\n+     * <code>0.0f</code> is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toFloat(null)   = 0.0f\n+     *   NumberUtils.toFloat(\"\")     = 0.0f\n+     *   NumberUtils.toFloat(\"1.5\")  = 1.5f\n+     * </pre>\n+     *\n+     * @param str the string to convert, may be <code>null</code>\n+     * @return the float represented by the string, or <code>0.0f</code>\n+     *  if conversion fails\n+     * @since 2.1\n+     */\n+    public static float toFloat(String str) {\n+        return toFloat(str, 0.0f);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>float</code>, returning a\n+     * default value if the conversion fails.</p>\n+     *\n+     * <p>If the string <code>str</code> is <code>null</code>, the default\n+     * value is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toFloat(null, 1.1f)   = 1.0f\n+     *   NumberUtils.toFloat(\"\", 1.1f)     = 1.1f\n+     *   NumberUtils.toFloat(\"1.5\", 0.0f)  = 1.5f\n+     * </pre>\n+     *\n+     * @param str the string to convert, may be <code>null</code>\n+     * @param defaultValue the default value\n+     * @return the float represented by the string, or defaultValue\n+     *  if conversion fails\n+     * @since 2.1\n+     */\n+    public static float toFloat(String str, float defaultValue) {\n+      if (str == null) {\n+          return defaultValue;\n+      }     \n+      try {\n+          return Float.parseFloat(str);\n+      } catch (NumberFormatException nfe) {\n+          return defaultValue;\n+      }\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>double</code>, returning\n+     * <code>0.0d</code> if the conversion fails.</p>\n+     *\n+     * <p>If the string <code>str</code> is <code>null</code>,\n+     * <code>0.0d</code> is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toDouble(null)   = 0.0d\n+     *   NumberUtils.toDouble(\"\")     = 0.0d\n+     *   NumberUtils.toDouble(\"1.5\")  = 1.5d\n+     * </pre>\n+     *\n+     * @param str the string to convert, may be <code>null</code>\n+     * @return the double represented by the string, or <code>0.0d</code>\n+     *  if conversion fails\n+     * @since 2.1\n+     */\n+    public static double toDouble(String str) {\n+        return toDouble(str, 0.0d);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>double</code>, returning a\n+     * default value if the conversion fails.</p>\n+     *\n+     * <p>If the string <code>str</code> is <code>null</code>, the default\n+     * value is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toDouble(null, 1.1d)   = 1.1d\n+     *   NumberUtils.toDouble(\"\", 1.1d)     = 1.1d\n+     *   NumberUtils.toDouble(\"1.5\", 0.0d)  = 1.5d\n+     * </pre>\n+     *\n+     * @param str the string to convert, may be <code>null</code>\n+     * @param defaultValue the default value\n+     * @return the double represented by the string, or defaultValue\n+     *  if conversion fails\n+     * @since 2.1\n+     */\n+    public static double toDouble(String str, double defaultValue) {\n+      if (str == null) {\n+          return defaultValue;\n+      }\n+      try {\n+          return Double.parseDouble(str);\n+      } catch (NumberFormatException nfe) {\n+          return defaultValue;\n+      }\n+    }\n+\n+     //-----------------------------------------------------------------------\n+     /**\n+     * <p>Convert a <code>String</code> to a <code>byte</code>, returning\n+     * <code>zero</code> if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, <code>zero</code> is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toByte(null) = 0\n+     *   NumberUtils.toByte(\"\")   = 0\n+     *   NumberUtils.toByte(\"1\")  = 1\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @return the byte represented by the string, or <code>zero</code> if\n+     *  conversion fails\n+     */\n+    public static byte toByte(String str) {\n+        return toByte(str, (byte) 0);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>byte</code>, returning a\n+     * default value if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, the default value is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toByte(null, 1) = 1\n+     *   NumberUtils.toByte(\"\", 1)   = 1\n+     *   NumberUtils.toByte(\"1\", 0)  = 1\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @param defaultValue  the default value\n+     * @return the byte represented by the string, or the default if conversion fails\n+     */\n+    public static byte toByte(String str, byte defaultValue) {\n+        if(str == null) {\n+            return defaultValue;\n+        }\n+        try {\n+            return Byte.parseByte(str);\n+        } catch (NumberFormatException nfe) {\n+            return defaultValue;\n+        }\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>short</code>, returning\n+     * <code>zero</code> if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, <code>zero</code> is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toShort(null) = 0\n+     *   NumberUtils.toShort(\"\")   = 0\n+     *   NumberUtils.toShort(\"1\")  = 1\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @return the short represented by the string, or <code>zero</code> if\n+     *  conversion fails\n+     */\n+    public static short toShort(String str) {\n+        return toShort(str, (short) 0);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to an <code>short</code>, returning a\n+     * default value if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, the default value is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toShort(null, 1) = 1\n+     *   NumberUtils.toShort(\"\", 1)   = 1\n+     *   NumberUtils.toShort(\"1\", 0)  = 1\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @param defaultValue  the default value\n+     * @return the short represented by the string, or the default if conversion fails\n+     */\n+    public static short toShort(String str, short defaultValue) {\n+        if(str == null) {\n+            return defaultValue;\n+        }\n+        try {\n+            return Short.parseShort(str);\n+        } catch (NumberFormatException nfe) {\n+            return defaultValue;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // must handle Long, Float, Integer, Float, Short,\n+    //                  BigDecimal, BigInteger and Byte\n+    // useful methods:\n+    // Byte.decode(String)\n+    // Byte.valueOf(String,int radix)\n+    // Byte.valueOf(String)\n+    // Double.valueOf(String)\n+    // Float.valueOf(String)\n+    // new Float(String)\n+    // Integer.valueOf(String,int radix)\n+    // Integer.valueOf(String)\n+    // Integer.decode(String)\n+    // Integer.getInteger(String)\n+    // Integer.getInteger(String,int val)\n+    // Integer.getInteger(String,Integer val)\n+    // new Integer(String)\n+    // new Double(String)\n+    // new Byte(String)\n+    // new Long(String)\n+    // Long.getLong(String)\n+    // Long.getLong(String,int)\n+    // Long.getLong(String,Integer)\n+    // Long.valueOf(String,int)\n+    // Long.valueOf(String)\n+    // new Short(String)\n+    // Short.decode(String)\n+    // Short.valueOf(String,int)\n+    // Short.valueOf(String)\n+    // new BigDecimal(String)\n+    // new BigInteger(String)\n+    // new BigInteger(String,int radix)\n+    // Possible inputs:\n+    // 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd\n+    // plus minus everything. Prolly more. A lot are not separable.\n+\n+    /**\n+     * <p>Turns a string value into a java.lang.Number.</p>\n+     *\n+     * <p>First, the value is examined for a type qualifier on the end\n+     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n+     * trying to create successively larger types from the type specified\n+     * until one is found that can represent the value.</p>\n+     *\n+     * <p>If a type specifier is not found, it will check for a decimal point\n+     * and then try successively larger types from <code>Integer</code> to\n+     * <code>BigInteger</code> and from <code>Float</code> to\n+     * <code>BigDecimal</code>.</p>\n+     *\n+     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n+     * will be interpreted as a hexadecimal integer.  Values with leading\n+     * <code>0</code>'s will not be interpreted as octal.</p>\n+     *\n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     *\n+     * <p>This method does not trim the input string, i.e., strings with leading\n+     * or trailing spaces will generate NumberFormatExceptions.</p>\n+     *\n+     * @param str  String containing a number, may be null\n+     * @return Number created from the string\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Number createNumber(String str) throws NumberFormatException {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (StringUtils.isBlank(str)) {\n+            throw new NumberFormatException(\"A blank string is not a valid number\");\n+        }  \n+        if (str.startsWith(\"--\")) {\n+            // this is protection for poorness in java.lang.BigDecimal.\n+            // it accepts this as a legal value, but it does not appear \n+            // to be in specification of class. OS X Java parses it to \n+            // a wrong value.\n+            return null;\n+        }\n+        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+            return createInteger(str);\n+        }   \n+        char lastChar = str.charAt(str.length() - 1);\n+        String mant;\n+        String dec;\n+        String exp;\n+        int decPos = str.indexOf('.');\n+        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n+\n+        if (decPos > -1) {\n+\n+            if (expPos > -1) {\n+                if (expPos < decPos) {\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n+                }\n+                dec = str.substring(decPos + 1, expPos);\n+            } else {\n+                dec = str.substring(decPos + 1);\n+            }\n+            mant = str.substring(0, decPos);\n+        } else {\n+            if (expPos > -1) {\n+                mant = str.substring(0, expPos);\n+            } else {\n+                mant = str;\n+            }\n+            dec = null;\n+        }\n+        if (!Character.isDigit(lastChar)) {\n+            if (expPos > -1 && expPos < str.length() - 1) {\n+                exp = str.substring(expPos + 1, str.length() - 1);\n+            } else {\n+                exp = null;\n+            }\n+            //Requesting a specific type..\n+            String numeric = str.substring(0, str.length() - 1);\n+            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n+            switch (lastChar) {\n+                case 'l' :\n+                case 'L' :\n+                    if (dec == null\n+                        && exp == null\n+                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n+                        try {\n+                            return createLong(numeric);\n+                        } catch (NumberFormatException nfe) {\n+                            //Too big for a long\n+                        }\n+                        return createBigInteger(numeric);\n+\n+                    }\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n+                case 'f' :\n+                case 'F' :\n+                    try {\n+                        Float f = NumberUtils.createFloat(numeric);\n+                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n+                            //If it's too big for a float or the float value = 0 and the string\n+                            //has non-zeros in it, then float does not have the precision we want\n+                            return f;\n+                        }\n+\n+                    } catch (NumberFormatException nfe) {\n+                        // ignore the bad number\n+                    }\n+                    //$FALL-THROUGH$\n+                case 'd' :\n+                case 'D' :\n+                    try {\n+                        Double d = NumberUtils.createDouble(numeric);\n+                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n+                            return d;\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        // ignore the bad number\n+                    }\n+                    try {\n+                        return createBigDecimal(numeric);\n+                    } catch (NumberFormatException e) {\n+                        // ignore the bad number\n+                    }\n+                    //$FALL-THROUGH$\n+                default :\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n+\n+            }\n+        } else {\n+            //User doesn't have a preference on the return type, so let's start\n+            //small and go from there...\n+            if (expPos > -1 && expPos < str.length() - 1) {\n+                exp = str.substring(expPos + 1, str.length());\n+            } else {\n+                exp = null;\n+            }\n+            if (dec == null && exp == null) {\n+                //Must be an int,long,bigint\n+                try {\n+                    return createInteger(str);\n+                } catch (NumberFormatException nfe) {\n+                    // ignore the bad number\n+                }\n+                try {\n+                    return createLong(str);\n+                } catch (NumberFormatException nfe) {\n+                    // ignore the bad number\n+                }\n+                return createBigInteger(str);\n+\n+            } else {\n+                //Must be a float,double,BigDec\n+                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n+                try {\n+                    Float f = createFloat(str);\n+                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n+                        return f;\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                    // ignore the bad number\n+                }\n+                try {\n+                    Double d = createDouble(str);\n+                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n+                        return d;\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                    // ignore the bad number\n+                }\n+\n+                return createBigDecimal(str);\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Utility method for {@link #createNumber(java.lang.String)}.</p>\n+     *\n+     * <p>Returns <code>true</code> if s is <code>null</code>.</p>\n+     * \n+     * @param str  the String to check\n+     * @return if it is all zeros or <code>null</code>\n+     */\n+    private static boolean isAllZeros(String str) {\n+        if (str == null) {\n+            return true;\n+        }\n+        for (int i = str.length() - 1; i >= 0; i--) {\n+            if (str.charAt(i) != '0') {\n+                return false;\n+            }\n+        }\n+        return str.length() > 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>Float</code>.</p>\n+     *\n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     * \n+     * @param str  a <code>String</code> to convert, may be null\n+     * @return converted <code>Float</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Float createFloat(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return Float.valueOf(str);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>Double</code>.</p>\n+     * \n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     *\n+     * @param str  a <code>String</code> to convert, may be null\n+     * @return converted <code>Double</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Double createDouble(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return Double.valueOf(str);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n+     * hex and octal notations.</p>\n+     *\n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     * \n+     * @param str  a <code>String</code> to convert, may be null\n+     * @return converted <code>Integer</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Integer createInteger(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        // decode() handles 0xAABD and 0777 (hex and octal) as well.\n+        return Integer.decode(str);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>Long</code>.</p>\n+     * \n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     *\n+     * @param str  a <code>String</code> to convert, may be null\n+     * @return converted <code>Long</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Long createLong(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return Long.valueOf(str);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>BigInteger</code>.</p>\n+     *\n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     * \n+     * @param str  a <code>String</code> to convert, may be null\n+     * @return converted <code>BigInteger</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static BigInteger createBigInteger(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return new BigInteger(str);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n+     * \n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     *\n+     * @param str  a <code>String</code> to convert, may be null\n+     * @return converted <code>BigDecimal</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static BigDecimal createBigDecimal(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n+        if (StringUtils.isBlank(str)) {\n+            throw new NumberFormatException(\"A blank string is not a valid number\");\n+        }  \n+        return new BigDecimal(str);\n+    }\n+\n+    // Min in array\n+    //--------------------------------------------------------------------\n+    /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static long min(long[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        long min = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            if (array[i] < min) {\n+                min = array[i];\n+            }\n+        }\n+    \n+        return min;\n+    }\n+\n+    /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static int min(int[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        int min = array[0];\n+        for (int j = 1; j < array.length; j++) {\n+            if (array[j] < min) {\n+                min = array[j];\n+            }\n+        }\n+    \n+        return min;\n+    }\n+\n+    /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static short min(short[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        short min = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            if (array[i] < min) {\n+                min = array[i];\n+            }\n+        }\n+    \n+        return min;\n+    }\n+\n+    /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static byte min(byte[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        byte min = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            if (array[i] < min) {\n+                min = array[i];\n+            }\n+        }\n+    \n+        return min;\n+    }\n+\n+     /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     * @see IEEE754rUtils#min(double[]) IEEE754rUtils for a version of this method that handles NaN differently\n+     */\n+    public static double min(double[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        double min = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            if (Double.isNaN(array[i])) {\n+                return Double.NaN;\n+            }\n+            if (array[i] < min) {\n+                min = array[i];\n+            }\n+        }\n+    \n+        return min;\n+    }\n+\n+    /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     * @see IEEE754rUtils#min(float[]) IEEE754rUtils for a version of this method that handles NaN differently\n+     */\n+    public static float min(float[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        float min = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            if (Float.isNaN(array[i])) {\n+                return Float.NaN;\n+            }\n+            if (array[i] < min) {\n+                min = array[i];\n+            }\n+        }\n+    \n+        return min;\n+    }\n+\n+    // Max in array\n+    //--------------------------------------------------------------------\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static long max(long[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+\n+        // Finds and returns max\n+        long max = array[0];\n+        for (int j = 1; j < array.length; j++) {\n+            if (array[j] > max) {\n+                max = array[j];\n+            }\n+        }\n+\n+        return max;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static int max(int[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns max\n+        int max = array[0];\n+        for (int j = 1; j < array.length; j++) {\n+            if (array[j] > max) {\n+                max = array[j];\n+            }\n+        }\n+    \n+        return max;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static short max(short[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns max\n+        short max = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            if (array[i] > max) {\n+                max = array[i];\n+            }\n+        }\n+    \n+        return max;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static byte max(byte[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns max\n+        byte max = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            if (array[i] > max) {\n+                max = array[i];\n+            }\n+        }\n+    \n+        return max;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     * @see IEEE754rUtils#max(double[]) IEEE754rUtils for a version of this method that handles NaN differently\n+     */\n+    public static double max(double[] array) {\n+        // Validates input\n+        if (array== null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns max\n+        double max = array[0];\n+        for (int j = 1; j < array.length; j++) {\n+            if (Double.isNaN(array[j])) {\n+                return Double.NaN;\n+            }\n+            if (array[j] > max) {\n+                max = array[j];\n+            }\n+        }\n+    \n+        return max;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     * @see IEEE754rUtils#max(float[]) IEEE754rUtils for a version of this method that handles NaN differently\n+     */\n+    public static float max(float[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+\n+        // Finds and returns max\n+        float max = array[0];\n+        for (int j = 1; j < array.length; j++) {\n+            if (Float.isNaN(array[j])) {\n+                return Float.NaN;\n+            }\n+            if (array[j] > max) {\n+                max = array[j];\n+            }\n+        }\n+\n+        return max;\n+    }\n+     \n+    // 3 param min\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the minimum of three <code>long</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+    public static long min(long a, long b, long c) {\n+        if (b < a) {\n+            a = b;\n+        }\n+        if (c < a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>int</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+    public static int min(int a, int b, int c) {\n+        if (b < a) {\n+            a = b;\n+        }\n+        if (c < a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>short</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+    public static short min(short a, short b, short c) {\n+        if (b < a) {\n+            a = b;\n+        }\n+        if (c < a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>byte</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+    public static byte min(byte a, byte b, byte c) {\n+        if (b < a) {\n+            a = b;\n+        }\n+        if (c < a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>double</code> values.</p>\n+     * \n+     * <p>If any value is <code>NaN</code>, <code>NaN</code> is\n+     * returned. Infinity is handled.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     * @see IEEE754rUtils#min(double, double, double) for a version of this method that handles NaN differently\n+     */\n+    public static double min(double a, double b, double c) {\n+        return Math.min(Math.min(a, b), c);\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>float</code> values.</p>\n+     * \n+     * <p>If any value is <code>NaN</code>, <code>NaN</code> is\n+     * returned. Infinity is handled.</p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     * @see IEEE754rUtils#min(float, float, float) for a version of this method that handles NaN differently\n+     */\n+    public static float min(float a, float b, float c) {\n+        return Math.min(Math.min(a, b), c);\n+    }\n+\n+    // 3 param max\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the maximum of three <code>long</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static long max(long a, long b, long c) {\n+        if (b > a) {\n+            a = b;\n+        }\n+        if (c > a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of three <code>int</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static int max(int a, int b, int c) {\n+        if (b > a) {\n+            a = b;\n+        }\n+        if (c > a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of three <code>short</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static short max(short a, short b, short c) {\n+        if (b > a) {\n+            a = b;\n+        }\n+        if (c > a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of three <code>byte</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static byte max(byte a, byte b, byte c) {\n+        if (b > a) {\n+            a = b;\n+        }\n+        if (c > a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of three <code>double</code> values.</p>\n+     * \n+     * <p>If any value is <code>NaN</code>, <code>NaN</code> is\n+     * returned. Infinity is handled.</p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     * @see IEEE754rUtils#max(double, double, double) for a version of this method that handles NaN differently\n+     */\n+    public static double max(double a, double b, double c) {\n+        return Math.max(Math.max(a, b), c);\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of three <code>float</code> values.</p>\n+     * \n+     * <p>If any value is <code>NaN</code>, <code>NaN</code> is\n+     * returned. Infinity is handled.</p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     * @see IEEE754rUtils#max(float, float, float) for a version of this method that handles NaN differently\n+     */\n+    public static float max(float a, float b, float c) {\n+        return Math.max(Math.max(a, b), c);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks whether the <code>String</code> contains only\n+     * digit characters.</p>\n+     *\n+     * <p><code>Null</code> and empty String will return\n+     * <code>false</code>.</p>\n+     *\n+     * @param str  the <code>String</code> to check\n+     * @return <code>true</code> if str contains only unicode numeric\n+     */\n+    public static boolean isDigits(String str) {\n+        if (StringUtils.isEmpty(str)) {\n+            return false;\n+        }\n+        for (int i = 0; i < str.length(); i++) {\n+            if (!Character.isDigit(str.charAt(i))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether the String a valid Java number.</p>\n+     *\n+     * <p>Valid numbers include hexadecimal marked with the <code>0x</code>\n+     * qualifier, scientific notation and numbers marked with a type\n+     * qualifier (e.g. 123L).</p>\n+     *\n+     * <p><code>Null</code> and empty String will return\n+     * <code>false</code>.</p>\n+     *\n+     * @param str  the <code>String</code> to check\n+     * @return <code>true</code> if the string is a correctly formatted number\n+     */\n+    public static boolean isNumber(String str) {\n+        if (StringUtils.isEmpty(str)) {\n+            return false;\n+        }\n+        char[] chars = str.toCharArray();\n+        int sz = chars.length;\n+        boolean hasExp = false;\n+        boolean hasDecPoint = false;\n+        boolean allowSigns = false;\n+        boolean foundDigit = false;\n+        // deal with any possible sign up front\n+        int start = (chars[0] == '-') ? 1 : 0;\n+        if (sz > start + 1) {\n+            if (chars[start] == '0' && chars[start + 1] == 'x') {\n+                int i = start + 2;\n+                if (i == sz) {\n+                    return false; // str == \"0x\"\n+                }\n+                // checking hex (it can't be anything else)\n+                for (; i < chars.length; i++) {\n+                    if ((chars[i] < '0' || chars[i] > '9')\n+                        && (chars[i] < 'a' || chars[i] > 'f')\n+                        && (chars[i] < 'A' || chars[i] > 'F')) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        }\n+        sz--; // don't want to loop to the last char, check it afterwords\n+              // for type qualifiers\n+        int i = start;\n+        // loop to the next to last char or to the last char if we need another digit to\n+        // make a valid number (e.g. chars[0..5] = \"1234E\")\n+        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n+            if (chars[i] >= '0' && chars[i] <= '9') {\n+                foundDigit = true;\n+                allowSigns = false;\n+\n+            } else if (chars[i] == '.') {\n+                if (hasDecPoint || hasExp) {\n+                    // two decimal points or dec in exponent   \n+                    return false;\n+                }\n+                hasDecPoint = true;\n+            } else if (chars[i] == 'e' || chars[i] == 'E') {\n+                // we've already taken care of hex.\n+                if (hasExp) {\n+                    // two E's\n+                    return false;\n+                }\n+                if (!foundDigit) {\n+                    return false;\n+                }\n+                hasExp = true;\n+                allowSigns = true;\n+            } else if (chars[i] == '+' || chars[i] == '-') {\n+                if (!allowSigns) {\n+                    return false;\n+                }\n+                allowSigns = false;\n+                foundDigit = false; // we need a digit after the E\n+            } else {\n+                return false;\n+            }\n+            i++;\n+        }\n+        if (i < chars.length) {\n+            if (chars[i] >= '0' && chars[i] <= '9') {\n+                // no type qualifier, OK\n+                return true;\n+            }\n+            if (chars[i] == 'e' || chars[i] == 'E') {\n+                // can't have an E at the last byte\n+                return false;\n+            }\n+            if (!allowSigns\n+                && (chars[i] == 'd'\n+                    || chars[i] == 'D'\n+                    || chars[i] == 'f'\n+                    || chars[i] == 'F')) {\n+                return foundDigit;\n+            }\n+            if (chars[i] == 'l'\n+                || chars[i] == 'L') {\n+                // not allowing L with an exponent\n+                return foundDigit && !hasExp;\n+            }\n+            // last character is illegal\n+            return false;\n+        }\n+        // allowSigns is true iff the val ends in 'E'\n+        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n+        return !allowSigns && foundDigit;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/mutable/Mutable.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.mutable;\n+\n+/**\n+ * Provides mutable access to a value.\n+ * <p>\n+ * <code>Mutable</code> is used as a generic interface to the implementations in this package.\n+ * <p>\n+ * A typical use case would be to enable a primitive or string to be passed to a method and allow that method to\n+ * effectively change the value of the primitive/string. Another use case is to store a frequently changing primitive in\n+ * a collection (for example a total in a map) without needing to create new Integer/Long wrapper objects.\n+ * \n+ * @author Apache Software Foundation\n+ * @author Matthew Hawthorne\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public interface Mutable<T> {\n+\n+    /**\n+     * Gets the value of this mutable.\n+     * \n+     * @return the stored value\n+     */\n+    T getValue();\n+\n+    /**\n+     * Sets the value of this mutable.\n+     * \n+     * @param value\n+     *            the value to store\n+     * @throws NullPointerException\n+     *             if the object is null and null is invalid\n+     * @throws ClassCastException\n+     *             if the type is invalid\n+     */\n+    void setValue(T value);\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/mutable/MutableBoolean.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.mutable;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * A mutable <code>boolean</code> wrapper.\n+ * \n+ * @see Boolean\n+ * @since 2.2\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MutableBoolean implements Mutable<Boolean>, Serializable, Comparable<MutableBoolean> {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = -4830728138360036487L;\n+\n+    /** The mutable value. */\n+    private boolean value;\n+\n+    /**\n+     * Constructs a new MutableBoolean with the default value of false.\n+     */\n+    public MutableBoolean() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableBoolean with the specified value.\n+     * \n+     * @param value  the initial value to store\n+     */\n+    public MutableBoolean(boolean value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableBoolean with the specified value.\n+     * \n+     * @param value  the initial value to store, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public MutableBoolean(Boolean value) {\n+        super();\n+        this.value = value.booleanValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Boolean instance.\n+     * \n+     * @return the value as a Boolean, never null\n+     */\n+    public Boolean getValue() {\n+        return Boolean.valueOf(this.value);\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value  the value to set\n+     */\n+    public void setValue(boolean value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Boolean instance.\n+     * \n+     * @param value  the value to set, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public void setValue(Boolean value) {\n+        this.value = value.booleanValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks if the current value is <code>true</code>.\n+     * \n+     * @return <code>true</code> if the current value is <code>true</code>\n+     */\n+    public boolean isTrue() {\n+        return value == true;\n+    }\n+\n+    /**\n+     * Checks if the current value is <code>false</code>.\n+     * \n+     * @return <code>true</code> if the current value is <code>false</code>\n+     */\n+    public boolean isFalse() {\n+        return value == false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the value of this MutableBoolean as a boolean.\n+     * \n+     * @return the boolean value represented by this object.\n+     */\n+    public boolean booleanValue() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this mutable as an instance of Boolean.\n+     *\n+     * @return a Boolean instance containing the value from this mutable, never null\n+     */\n+    public Boolean toBoolean() {\n+        return Boolean.valueOf(booleanValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object to the specified object. The result is <code>true</code> if and only if the argument is\n+     * not <code>null</code> and is an <code>MutableBoolean</code> object that contains the same\n+     * <code>boolean</code> value as this object.\n+     * \n+     * @param obj  the object to compare with, null returns false\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof MutableBoolean) {\n+            return value == ((MutableBoolean) obj).booleanValue();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns a suitable hash code for this mutable.\n+     * \n+     * @return the hash code returned by <code>Boolean.TRUE</code> or <code>Boolean.FALSE</code>\n+     */\n+    @Override\n+    public int hashCode() {\n+        return value ? Boolean.TRUE.hashCode() : Boolean.FALSE.hashCode();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param other  the other mutable to compare to, not null\n+     * @return negative if this is less, zero if equal, positive if greater\n+     *  where false is less than true\n+     */\n+    public int compareTo(MutableBoolean other) {\n+        boolean anotherVal = other.value;\n+        return value == anotherVal ? 0 : (value ? 1 : -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    @Override\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/mutable/MutableByte.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+/**\n+ * A mutable <code>byte</code> wrapper.\n+ * \n+ * @see Byte\n+ * @since 2.1\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MutableByte extends Number implements Comparable<MutableByte>, Mutable<Number> {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = -1585823265L;\n+\n+    /** The mutable value. */\n+    private byte value;\n+\n+    /**\n+     * Constructs a new MutableByte with the default value of zero.\n+     */\n+    public MutableByte() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableByte with the specified value.\n+     * \n+     * @param value  the initial value to store\n+     */\n+    public MutableByte(byte value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableByte with the specified value.\n+     * \n+     * @param value  the initial value to store, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public MutableByte(Number value) {\n+        super();\n+        this.value = value.byteValue();\n+    }\n+\n+    /**\n+     * Constructs a new MutableByte parsing the given string.\n+     * \n+     * @param value  the string to parse, not null\n+     * @throws NumberFormatException if the string cannot be parsed into a byte\n+     */\n+    public MutableByte(String value) throws NumberFormatException {\n+        super();\n+        this.value = Byte.parseByte(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Byte instance.\n+     * \n+     * @return the value as a Byte, never null\n+     */\n+    public Byte getValue() {\n+        return Byte.valueOf(this.value);\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value  the value to set\n+     */\n+    public void setValue(byte value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Number instance.\n+     * \n+     * @param value  the value to set, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public void setValue(Number value) {\n+        this.value = value.byteValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Increments the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void increment() {\n+        value++;\n+    }\n+\n+    /**\n+     * Decrements the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void decrement() {\n+        value--;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(byte operand) {\n+        this.value += operand;\n+    }\n+\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(Number operand) {\n+        this.value += operand.byteValue();\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(byte operand) {\n+        this.value -= operand;\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(Number operand) {\n+        this.value -= operand.byteValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // shortValue relies on Number implementation\n+    /**\n+     * Returns the value of this MutableByte as a byte.\n+     *\n+     * @return the numeric value represented by this object after conversion to type byte.\n+     */\n+    @Override\n+    public byte byteValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableByte as an int.\n+     *\n+     * @return the numeric value represented by this object after conversion to type int.\n+     */\n+    @Override\n+    public int intValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableByte as a long.\n+     *\n+     * @return the numeric value represented by this object after conversion to type long.\n+     */\n+    @Override\n+    public long longValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableByte as a float.\n+     *\n+     * @return the numeric value represented by this object after conversion to type float.\n+     */\n+    @Override\n+    public float floatValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableByte as a double.\n+     *\n+     * @return the numeric value represented by this object after conversion to type double.\n+     */\n+    @Override\n+    public double doubleValue() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this mutable as an instance of Byte.\n+     *\n+     * @return a Byte instance containing the value from this mutable\n+     */\n+    public Byte toByte() {\n+        return Byte.valueOf(byteValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object to the specified object. The result is <code>true</code> if and only if the argument is\n+     * not <code>null</code> and is a <code>MutableByte</code> object that contains the same <code>byte</code> value\n+     * as this object.\n+     * \n+     * @param obj  the object to compare with, null returns false\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof MutableByte) {\n+            return value == ((MutableByte) obj).byteValue();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns a suitable hash code for this mutable.\n+     * \n+     * @return a suitable hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param other  the other mutable to compare to, not null\n+     * @return negative if this is less, zero if equal, positive if greater\n+     */\n+    public int compareTo(MutableByte other) {\n+        byte anotherVal = other.value;\n+        return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    @Override\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/mutable/MutableDouble.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+/**\n+ * A mutable <code>double</code> wrapper.\n+ * \n+ * @see Double\n+ * @since 2.1\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MutableDouble extends Number implements Comparable<MutableDouble>, Mutable<Number> {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 1587163916L;\n+\n+    /** The mutable value. */\n+    private double value;\n+\n+    /**\n+     * Constructs a new MutableDouble with the default value of zero.\n+     */\n+    public MutableDouble() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableDouble with the specified value.\n+     * \n+     * @param value  the initial value to store\n+     */\n+    public MutableDouble(double value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableDouble with the specified value.\n+     * \n+     * @param value  the initial value to store, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public MutableDouble(Number value) {\n+        super();\n+        this.value = value.doubleValue();\n+    }\n+\n+    /**\n+     * Constructs a new MutableDouble parsing the given string.\n+     * \n+     * @param value  the string to parse, not null\n+     * @throws NumberFormatException if the string cannot be parsed into a double\n+     */\n+    public MutableDouble(String value) throws NumberFormatException {\n+        super();\n+        this.value = Double.parseDouble(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Double instance.\n+     * \n+     * @return the value as a Double, never null\n+     */\n+    public Double getValue() {\n+        return new Double(this.value);\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value  the value to set\n+     */\n+    public void setValue(double value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Number instance.\n+     * \n+     * @param value  the value to set, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public void setValue(Number value) {\n+        this.value = value.doubleValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the double value is the special NaN value.\n+     * \n+     * @return true if NaN\n+     */\n+    public boolean isNaN() {\n+        return Double.isNaN(value);\n+    }\n+\n+    /**\n+     * Checks whether the double value is infinite.\n+     * \n+     * @return true if infinite\n+     */\n+    public boolean isInfinite() {\n+        return Double.isInfinite(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Increments the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void increment() {\n+        value++;\n+    }\n+\n+    /**\n+     * Decrements the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void decrement() {\n+        value--;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(double operand) {\n+        this.value += operand;\n+    }\n+\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(Number operand) {\n+        this.value += operand.doubleValue();\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(double operand) {\n+        this.value -= operand;\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(Number operand) {\n+        this.value -= operand.doubleValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // shortValue and bytValue rely on Number implementation\n+    /**\n+     * Returns the value of this MutableDouble as an int.\n+     *\n+     * @return the numeric value represented by this object after conversion to type int.\n+     */\n+    @Override\n+    public int intValue() {\n+        return (int) value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableDouble as a long.\n+     *\n+     * @return the numeric value represented by this object after conversion to type long.\n+     */\n+    @Override\n+    public long longValue() {\n+        return (long) value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableDouble as a float.\n+     *\n+     * @return the numeric value represented by this object after conversion to type float.\n+     */\n+    @Override\n+    public float floatValue() {\n+        return (float) value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableDouble as a double.\n+     *\n+     * @return the numeric value represented by this object after conversion to type double.\n+     */\n+    @Override\n+    public double doubleValue() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this mutable as an instance of Double.\n+     *\n+     * @return a Double instance containing the value from this mutable, never null\n+     */\n+    public Double toDouble() {\n+        return Double.valueOf(doubleValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object against the specified object. The result is <code>true</code> if and only if the argument\n+     * is not <code>null</code> and is a <code>Double</code> object that represents a double that has the identical\n+     * bit pattern to the bit pattern of the double represented by this object. For this purpose, two\n+     * <code>double</code> values are considered to be the same if and only if the method\n+     * {@link Double#doubleToLongBits(double)}returns the same long value when applied to each.\n+     * <p>\n+     * Note that in most cases, for two instances of class <code>Double</code>,<code>d1</code> and <code>d2</code>,\n+     * the value of <code>d1.equals(d2)</code> is <code>true</code> if and only if <blockquote>\n+     * \n+     * <pre>\n+     *   d1.doubleValue()&nbsp;== d2.doubleValue()\n+     * </pre>\n+     * \n+     * </blockquote>\n+     * <p>\n+     * also has the value <code>true</code>. However, there are two exceptions:\n+     * <ul>\n+     * <li>If <code>d1</code> and <code>d2</code> both represent <code>Double.NaN</code>, then the\n+     * <code>equals</code> method returns <code>true</code>, even though <code>Double.NaN==Double.NaN</code> has\n+     * the value <code>false</code>.\n+     * <li>If <code>d1</code> represents <code>+0.0</code> while <code>d2</code> represents <code>-0.0</code>,\n+     * or vice versa, the <code>equal</code> test has the value <code>false</code>, even though\n+     * <code>+0.0==-0.0</code> has the value <code>true</code>. This allows hashtables to operate properly.\n+     * </ul>\n+     * \n+     * @param obj  the object to compare with, null returns false\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        return (obj instanceof MutableDouble)\n+            && (Double.doubleToLongBits(((MutableDouble) obj).value) == Double.doubleToLongBits(value));\n+    }\n+\n+    /**\n+     * Returns a suitable hash code for this mutable.\n+     * \n+     * @return a suitable hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        long bits = Double.doubleToLongBits(value);\n+        return (int) (bits ^ (bits >>> 32));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param other  the other mutable to compare to, not null\n+     * @return negative if this is less, zero if equal, positive if greater\n+     */\n+    public int compareTo(MutableDouble other) {\n+        double anotherVal = other.value;\n+        return Double.compare(value, anotherVal);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    @Override\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/mutable/MutableFloat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+/**\n+ * A mutable <code>float</code> wrapper.\n+ * \n+ * @see Float\n+ * @since 2.1\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MutableFloat extends Number implements Comparable<MutableFloat>, Mutable<Number> {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 5787169186L;\n+\n+    /** The mutable value. */\n+    private float value;\n+\n+    /**\n+     * Constructs a new MutableFloat with the default value of zero.\n+     */\n+    public MutableFloat() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableFloat with the specified value.\n+     * \n+     * @param value  the initial value to store\n+     */\n+    public MutableFloat(float value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableFloat with the specified value.\n+     * \n+     * @param value  the initial value to store, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public MutableFloat(Number value) {\n+        super();\n+        this.value = value.floatValue();\n+    }\n+\n+    /**\n+     * Constructs a new MutableFloat parsing the given string.\n+     * \n+     * @param value  the string to parse, not null\n+     * @throws NumberFormatException if the string cannot be parsed into a float\n+     */\n+    public MutableFloat(String value) throws NumberFormatException {\n+        super();\n+        this.value = Float.parseFloat(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Float instance.\n+     * \n+     * @return the value as a Float, never null\n+     */\n+    public Float getValue() {\n+        return new Float(this.value);\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value  the value to set\n+     */\n+    public void setValue(float value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Number instance.\n+     * \n+     * @param value  the value to set, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public void setValue(Number value) {\n+        this.value = value.floatValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the float value is the special NaN value.\n+     * \n+     * @return true if NaN\n+     */\n+    public boolean isNaN() {\n+        return Float.isNaN(value);\n+    }\n+\n+    /**\n+     * Checks whether the float value is infinite.\n+     * \n+     * @return true if infinite\n+     */\n+    public boolean isInfinite() {\n+        return Float.isInfinite(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Increments the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void increment() {\n+        value++;\n+    }\n+\n+    /**\n+     * Decrements the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void decrement() {\n+        value--;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(float operand) {\n+        this.value += operand;\n+    }\n+\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(Number operand) {\n+        this.value += operand.floatValue();\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(float operand) {\n+        this.value -= operand;\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(Number operand) {\n+        this.value -= operand.floatValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // shortValue and bytValue rely on Number implementation\n+    /**\n+     * Returns the value of this MutableFloat as an int.\n+     *\n+     * @return the numeric value represented by this object after conversion to type int.\n+     */\n+    @Override\n+    public int intValue() {\n+        return (int) value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableFloat as a long.\n+     *\n+     * @return the numeric value represented by this object after conversion to type long.\n+     */\n+    @Override\n+    public long longValue() {\n+        return (long) value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableFloat as a float.\n+     *\n+     * @return the numeric value represented by this object after conversion to type float.\n+     */\n+    @Override\n+    public float floatValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableFloat as a double.\n+     *\n+     * @return the numeric value represented by this object after conversion to type double.\n+     */\n+    @Override\n+    public double doubleValue() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this mutable as an instance of Float.\n+     *\n+     * @return a Float instance containing the value from this mutable, never null\n+     */\n+    public Float toFloat() {\n+        return Float.valueOf(floatValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object against some other object. The result is <code>true</code> if and only if the argument is\n+     * not <code>null</code> and is a <code>Float</code> object that represents a <code>float</code> that has the\n+     * identical bit pattern to the bit pattern of the <code>float</code> represented by this object. For this\n+     * purpose, two float values are considered to be the same if and only if the method\n+     * {@link Float#floatToIntBits(float)}returns the same int value when applied to each.\n+     * <p>\n+     * Note that in most cases, for two instances of class <code>Float</code>,<code>f1</code> and <code>f2</code>,\n+     * the value of <code>f1.equals(f2)</code> is <code>true</code> if and only if <blockquote>\n+     * \n+     * <pre>\n+     *   f1.floatValue() == f2.floatValue()\n+     * </pre>\n+     * \n+     * </blockquote>\n+     * <p>\n+     * also has the value <code>true</code>. However, there are two exceptions:\n+     * <ul>\n+     * <li>If <code>f1</code> and <code>f2</code> both represent <code>Float.NaN</code>, then the\n+     * <code>equals</code> method returns <code>true</code>, even though <code>Float.NaN==Float.NaN</code> has\n+     * the value <code>false</code>.\n+     * <li>If <code>f1</code> represents <code>+0.0f</code> while <code>f2</code> represents <code>-0.0f</code>,\n+     * or vice versa, the <code>equal</code> test has the value <code>false</code>, even though\n+     * <code>0.0f==-0.0f</code> has the value <code>true</code>.\n+     * </ul>\n+     * This definition allows hashtables to operate properly.\n+     * \n+     * @param obj  the object to compare with, null returns false\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     * @see java.lang.Float#floatToIntBits(float)\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        return (obj instanceof MutableFloat)\n+            && (Float.floatToIntBits(((MutableFloat) obj).value) == Float.floatToIntBits(value));\n+    }\n+\n+    /**\n+     * Returns a suitable hash code for this mutable.\n+     * \n+     * @return a suitable hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        return Float.floatToIntBits(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param other  the other mutable to compare to, not null\n+     * @return negative if this is less, zero if equal, positive if greater\n+     */\n+    public int compareTo(MutableFloat other) {\n+        float anotherVal = other.value;\n+        return Float.compare(value, anotherVal);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    @Override\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/mutable/MutableInt.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+/**\n+ * A mutable <code>int</code> wrapper.\n+ * \n+ * @see Integer\n+ * @since 2.1\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MutableInt extends Number implements Comparable<MutableInt>, Mutable<Number> {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 512176391864L;\n+\n+    /** The mutable value. */\n+    private int value;\n+\n+    /**\n+     * Constructs a new MutableInt with the default value of zero.\n+     */\n+    public MutableInt() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableInt with the specified value.\n+     * \n+     * @param value  the initial value to store\n+     */\n+    public MutableInt(int value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableInt with the specified value.\n+     * \n+     * @param value  the initial value to store, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public MutableInt(Number value) {\n+        super();\n+        this.value = value.intValue();\n+    }\n+\n+    /**\n+     * Constructs a new MutableInt parsing the given string.\n+     * \n+     * @param value  the string to parse, not null\n+     * @throws NumberFormatException if the string cannot be parsed into an int\n+     */\n+    public MutableInt(String value) throws NumberFormatException {\n+        super();\n+        this.value = Integer.parseInt(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Integer instance.\n+     * \n+     * @return the value as a Integer, never null\n+     */\n+    public Integer getValue() {\n+        return new Integer(this.value);\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value  the value to set\n+     */\n+    public void setValue(int value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Number instance.\n+     * \n+     * @param value  the value to set, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public void setValue(Number value) {\n+        this.value = value.intValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Increments the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void increment() {\n+        value++;\n+    }\n+\n+    /**\n+     * Decrements the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void decrement() {\n+        value--;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(int operand) {\n+        this.value += operand;\n+    }\n+\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(Number operand) {\n+        this.value += operand.intValue();\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(int operand) {\n+        this.value -= operand;\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(Number operand) {\n+        this.value -= operand.intValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // shortValue and bytValue rely on Number implementation\n+    /**\n+     * Returns the value of this MutableInt as an int.\n+     *\n+     * @return the numeric value represented by this object after conversion to type int.\n+     */\n+    @Override\n+    public int intValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableInt as a long.\n+     *\n+     * @return the numeric value represented by this object after conversion to type long.\n+     */\n+    @Override\n+    public long longValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableInt as a float.\n+     *\n+     * @return the numeric value represented by this object after conversion to type float.\n+     */\n+    @Override\n+    public float floatValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableInt as a double.\n+     *\n+     * @return the numeric value represented by this object after conversion to type double.\n+     */\n+    @Override\n+    public double doubleValue() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this mutable as an instance of Integer.\n+     *\n+     * @return a Integer instance containing the value from this mutable, never null\n+     */\n+    public Integer toInteger() {\n+        return Integer.valueOf(intValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object to the specified object. The result is <code>true</code> if and only if the argument is\n+     * not <code>null</code> and is a <code>MutableInt</code> object that contains the same <code>int</code> value\n+     * as this object.\n+     * \n+     * @param obj  the object to compare with, null returns false\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof MutableInt) {\n+            return value == ((MutableInt) obj).intValue();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns a suitable hash code for this mutable.\n+     * \n+     * @return a suitable hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param other  the other mutable to compare to, not null\n+     * @return negative if this is less, zero if equal, positive if greater\n+     */\n+    public int compareTo(MutableInt other) {\n+        int anotherVal = other.value;\n+        return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    @Override\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/mutable/MutableLong.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+/**\n+ * A mutable <code>long</code> wrapper.\n+ * \n+ * @see Long\n+ * @since 2.1\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MutableLong extends Number implements Comparable<MutableLong>, Mutable<Number> {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 62986528375L;\n+\n+    /** The mutable value. */\n+    private long value;\n+\n+    /**\n+     * Constructs a new MutableLong with the default value of zero.\n+     */\n+    public MutableLong() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableLong with the specified value.\n+     * \n+     * @param value  the initial value to store\n+     */\n+    public MutableLong(long value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableLong with the specified value.\n+     * \n+     * @param value  the initial value to store, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public MutableLong(Number value) {\n+        super();\n+        this.value = value.longValue();\n+    }\n+\n+    /**\n+     * Constructs a new MutableLong parsing the given string.\n+     * \n+     * @param value  the string to parse, not null\n+     * @throws NumberFormatException if the string cannot be parsed into a long\n+     */\n+    public MutableLong(String value) throws NumberFormatException {\n+        super();\n+        this.value = Long.parseLong(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Long instance.\n+     * \n+     * @return the value as a Long, never null\n+     */\n+    public Long getValue() {\n+        return new Long(this.value);\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value  the value to set\n+     */\n+    public void setValue(long value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Number instance.\n+     * \n+     * @param value  the value to set, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public void setValue(Number value) {\n+        this.value = value.longValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Increments the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void increment() {\n+        value++;\n+    }\n+\n+    /**\n+     * Decrements the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void decrement() {\n+        value--;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(long operand) {\n+        this.value += operand;\n+    }\n+\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(Number operand) {\n+        this.value += operand.longValue();\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(long operand) {\n+        this.value -= operand;\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(Number operand) {\n+        this.value -= operand.longValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // shortValue and bytValue rely on Number implementation\n+    /**\n+     * Returns the value of this MutableLong as an int.\n+     *\n+     * @return the numeric value represented by this object after conversion to type int.\n+     */\n+    @Override\n+    public int intValue() {\n+        return (int) value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableLong as a long.\n+     *\n+     * @return the numeric value represented by this object after conversion to type long.\n+     */\n+    @Override\n+    public long longValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableLong as a float.\n+     *\n+     * @return the numeric value represented by this object after conversion to type float.\n+     */\n+    @Override\n+    public float floatValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableLong as a double.\n+     *\n+     * @return the numeric value represented by this object after conversion to type double.\n+     */\n+    @Override\n+    public double doubleValue() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this mutable as an instance of Long.\n+     *\n+     * @return a Long instance containing the value from this mutable, never null\n+     */\n+    public Long toLong() {\n+        return Long.valueOf(longValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object to the specified object. The result is <code>true</code> if and only if the argument\n+     * is not <code>null</code> and is a <code>MutableLong</code> object that contains the same <code>long</code>\n+     * value as this object.\n+     * \n+     * @param obj  the object to compare with, null returns false\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof MutableLong) {\n+            return value == ((MutableLong) obj).longValue();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns a suitable hash code for this mutable.\n+     * \n+     * @return a suitable hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        return (int) (value ^ (value >>> 32));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param other  the other mutable to compare to, not null\n+     * @return negative if this is less, zero if equal, positive if greater\n+     */\n+    public int compareTo(MutableLong other) {\n+        long anotherVal = other.value;\n+        return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    @Override\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/mutable/MutableObject.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.mutable;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * A mutable <code>Object</code> wrapper.\n+ * \n+ * @since 2.1\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MutableObject<T> implements Mutable<T>, Serializable {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 86241875189L;\n+\n+    /** The mutable value. */\n+    private T value;\n+\n+    /**\n+     * Constructs a new MutableObject with the default value of <code>null</code>.\n+     */\n+    public MutableObject() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableObject with the specified value.\n+     * \n+     * @param value  the initial value to store\n+     */\n+    public MutableObject(T value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value.\n+     * \n+     * @return the value, may be null\n+     */\n+    public T getValue() {\n+        return this.value;\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value  the value to set\n+     */\n+    public void setValue(T value) {\n+        this.value = value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object against the specified object. The result is <code>true</code> if and only if the argument\n+     * is not <code>null</code> and is a <code>MutableObject</code> object that contains the same <code>T</code>\n+     * value as this object.\n+     * \n+     * @param obj  the object to compare with, null returns false\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    public boolean equals(MutableObject<T> obj) {\n+        if(obj == null) {\n+            return false;\n+        }\n+\n+        T other = obj.value;\n+        return value == other || (value != null && value.equals(other));\n+    }\n+\n+    /**\n+     * Returns the value's hash code or <code>0</code> if the value is <code>null</code>.\n+     * \n+     * @return the value's hash code or <code>0</code> if the value is <code>null</code>.\n+     */\n+    @Override\n+    public int hashCode() {\n+        return value == null ? 0 : value.hashCode();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    @Override\n+    public String toString() {\n+        return value == null ? \"null\" : value.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/mutable/MutableShort.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+/**\n+ * A mutable <code>short</code> wrapper.\n+ * \n+ * @see Short\n+ * @since 2.1\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MutableShort extends Number implements Comparable<MutableShort>, Mutable<Number> {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = -2135791679L;\n+\n+    /** The mutable value. */\n+    private short value;\n+\n+    /**\n+     * Constructs a new MutableShort with the default value of zero.\n+     */\n+    public MutableShort() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableShort with the specified value.\n+     * \n+     * @param value  the initial value to store\n+     */\n+    public MutableShort(short value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableShort with the specified value.\n+     * \n+     * @param value  the initial value to store, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public MutableShort(Number value) {\n+        super();\n+        this.value = value.shortValue();\n+    }\n+\n+    /**\n+     * Constructs a new MutableShort parsing the given string.\n+     * \n+     * @param value  the string to parse, not null\n+     * @throws NumberFormatException if the string cannot be parsed into a short\n+     */\n+    public MutableShort(String value) throws NumberFormatException {\n+        super();\n+        this.value = Short.parseShort(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Short instance.\n+     * \n+     * @return the value as a Short, never null\n+     */\n+    public Short getValue() {\n+        return new Short(this.value);\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value  the value to set\n+     */\n+    public void setValue(short value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Number instance.\n+     * \n+     * @param value  the value to set, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public void setValue(Number value) {\n+        this.value = value.shortValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Increments the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void increment() {\n+        value++;\n+    }\n+\n+    /**\n+     * Decrements the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void decrement() {\n+        value--;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(short operand) {\n+        this.value += operand;\n+    }\n+\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(Number operand) {\n+        this.value += operand.shortValue();\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(short operand) {\n+        this.value -= operand;\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(Number operand) {\n+        this.value -= operand.shortValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // bytValue relies on Number implementation\n+    /**\n+     * Returns the value of this MutableShort as a short.\n+     *\n+     * @return the numeric value represented by this object after conversion to type short.\n+     */\n+    @Override\n+    public short shortValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableShort as an int.\n+     *\n+     * @return the numeric value represented by this object after conversion to type int.\n+     */\n+    @Override\n+    public int intValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableShort as a long.\n+     *\n+     * @return the numeric value represented by this object after conversion to type long.\n+     */\n+    @Override\n+    public long longValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableShort as a float.\n+     *\n+     * @return the numeric value represented by this object after conversion to type float.\n+     */\n+    @Override\n+    public float floatValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableShort as a double.\n+     *\n+     * @return the numeric value represented by this object after conversion to type double.\n+     */\n+    @Override\n+    public double doubleValue() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this mutable as an instance of Short.\n+     *\n+     * @return a Short instance containing the value from this mutable, never null\n+     */\n+    public Short toShort() {\n+        return Short.valueOf(shortValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object to the specified object. The result is <code>true</code> if and only if the argument\n+     * is not <code>null</code> and is a <code>MutableShort</code> object that contains the same <code>short</code>\n+     * value as this object.\n+     * \n+     * @param obj  the object to compare with, null returns false\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof MutableShort) {\n+            return value == ((MutableShort) obj).shortValue();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns a suitable hash code for this mutable.\n+     * \n+     * @return a suitable hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param other  the other mutable to compare to, not null\n+     * @return negative if this is less, zero if equal, positive if greater\n+     */\n+    public int compareTo(MutableShort other) {\n+        short anotherVal = other.value;\n+        return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    @Override\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/reflect/ConstructorUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Modifier;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.ClassUtils;\n+\n+/**\n+ * <p> Utility reflection methods focussed on constructors, modelled after {@link MethodUtils}. </p>\n+ *\n+ * <h3>Known Limitations</h3>\n+ * <h4>Accessing Public Constructors In A Default Access Superclass</h4>\n+ * <p>There is an issue when invoking public constructors contained in a default access superclass.\n+ * Reflection locates these constructors fine and correctly assigns them as public.\n+ * However, an <code>IllegalAccessException</code> is thrown if the constructors is invoked.</p>\n+ *\n+ * <p><code>ConstructorUtils</code> contains a workaround for this situation.\n+ * It will attempt to call <code>setAccessible</code> on this constructor.\n+ * If this call succeeds, then the method can be invoked as normal.\n+ * This call will only succeed when the application has sufficient security privilages.\n+ * If this call fails then a warning will be logged and the method may fail.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Craig R. McClanahan\n+ * @author Ralph Schaer\n+ * @author Chris Audley\n+ * @author Rey Francois\n+ * @author Gregor Rayman\n+ * @author Jan Sorensen\n+ * @author Robert Burrell Donkin\n+ * @author Rodney Waldhoff\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class ConstructorUtils {\n+\n+    /**\n+     * <p>ConstructorUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as\n+     * <code>ConstructorUtils.invokeConstructor(cls, args)</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public ConstructorUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * <p>Convenience method returning new instance of <code>klazz</code> using a single argument constructor.\n+     * The formal parameter type is inferred from the actual values of <code>arg</code>.\n+     * See {@link #invokeExactConstructor(Class, Object[], Class[])} for more details.</p>\n+     *\n+     * <p>The signatures should be assignment compatible.</p>\n+     *\n+     * @param cls the class to be constructed.\n+     * @param arg the actual argument\n+     * @return new instance of <code>klazz</code>\n+     *\n+     * @throws NoSuchMethodException If the constructor cannot be found\n+     * @throws IllegalAccessException If an error occurs accessing the constructor\n+     * @throws InvocationTargetException If an error occurs invoking the constructor\n+     * @throws InstantiationException If an error occurs instantiating the class\n+     *\n+     * @see #invokeConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])\n+     */\n+    public static Object invokeConstructor(Class<?> cls, Object arg)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException, InstantiationException {\n+        return invokeConstructor(cls, new Object[] { arg });\n+    }\n+\n+    /**\n+     * <p>Returns new instance of <code>klazz</code> created using the actual arguments <code>args</code>.\n+     * The formal parameter types are inferred from the actual values of <code>args</code>.\n+     * See {@link #invokeExactConstructor(Class, Object[], Class[])} for more details.</p>\n+     *\n+     * <p>The signatures should be assignment compatible.</p>\n+     *\n+     * @param cls the class to be constructed.\n+     * @param args actual argument array\n+     * @return new instance of <code>klazz</code>\n+     *\n+     * @throws NoSuchMethodException If the constructor cannot be found\n+     * @throws IllegalAccessException If an error occurs accessing the constructor\n+     * @throws InvocationTargetException If an error occurs invoking the constructor\n+     * @throws InstantiationException If an error occurs instantiating the class\n+     *\n+     * @see #invokeConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])\n+     */\n+    public static Object invokeConstructor(Class<?> cls, Object[] args)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException, InstantiationException {\n+        if (null == args) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        Class<?> parameterTypes[] = new Class[args.length];\n+        for (int i = 0; i < args.length; i++) {\n+            parameterTypes[i] = args[i].getClass();\n+        }\n+        return invokeConstructor(cls, args, parameterTypes);\n+    }\n+\n+    /**\n+     * <p>Returns new instance of <code>klazz</code> created using constructor\n+     * with signature <code>parameterTypes</code> and actual arguments <code>args</code>.</p>\n+     *\n+     * <p>The signatures should be assignment compatible.</p>\n+     *\n+     * @param cls the class to be constructed.\n+     * @param args actual argument array\n+     * @param parameterTypes parameter types array\n+     * @return new instance of <code>klazz</code>\n+     *\n+     * @throws NoSuchMethodException if matching constructor cannot be found\n+     * @throws IllegalAccessException thrown on the constructor's invocation\n+     * @throws InvocationTargetException thrown on the constructor's invocation\n+     * @throws InstantiationException thrown on the constructor's invocation\n+     * @see Constructor#newInstance\n+     */\n+    public static Object invokeConstructor(Class<?> cls, Object[] args,\n+            Class<?>[] parameterTypes) throws NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException,\n+            InstantiationException {\n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        Constructor<?> ctor = getMatchingAccessibleConstructor(cls, parameterTypes);\n+        if (null == ctor) {\n+            throw new NoSuchMethodException(\n+                    \"No such accessible constructor on object: \"\n+                            + cls.getName());\n+        }\n+        return ctor.newInstance(args);\n+    }\n+\n+    /**\n+     * <p>Convenience method returning new instance of <code>klazz</code> using a single argument constructor.\n+     * The formal parameter type is inferred from the actual values of <code>arg</code>.\n+     * See {@link #invokeExactConstructor(Class, Object[], Class[])} for more details.</p>\n+     *\n+     * <p>The signatures should match exactly.</p>\n+     *\n+     * @param cls the class to be constructed.\n+     * @param arg the actual argument\n+     * @return new instance of <code>klazz</code>\n+     *\n+     * @throws NoSuchMethodException If the constructor cannot be found\n+     * @throws IllegalAccessException If an error occurs accessing the constructor\n+     * @throws InvocationTargetException If an error occurs invoking the constructor\n+     * @throws InstantiationException If an error occurs instantiating the class\n+     *\n+     * @see #invokeExactConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])\n+     */\n+    public static Object invokeExactConstructor(Class<?> cls, Object arg)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException, InstantiationException {\n+        return invokeExactConstructor(cls, new Object[] { arg });\n+    }\n+\n+    /**\n+     * <p>Returns new instance of <code>klazz</code> created using the actual arguments <code>args</code>.\n+     * The formal parameter types are inferred from the actual values of <code>args</code>.\n+     * See {@link #invokeExactConstructor(Class, Object[], Class[])} for more details.</p>\n+     *\n+     * <p>The signatures should match exactly.</p>\n+     *\n+     * @param cls the class to be constructed.\n+     * @param args actual argument array\n+     * @return new instance of <code>klazz</code>\n+     *\n+     * @throws NoSuchMethodException If the constructor cannot be found\n+     * @throws IllegalAccessException If an error occurs accessing the constructor\n+     * @throws InvocationTargetException If an error occurs invoking the constructor\n+     * @throws InstantiationException If an error occurs instantiating the class\n+     *\n+     * @see #invokeExactConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])\n+     */\n+    public static Object invokeExactConstructor(Class<?> cls, Object[] args)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException, InstantiationException {\n+        if (null == args) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        int arguments = args.length;\n+        Class<?> parameterTypes[] = new Class[arguments];\n+        for (int i = 0; i < arguments; i++) {\n+            parameterTypes[i] = args[i].getClass();\n+        }\n+        return invokeExactConstructor(cls, args, parameterTypes);\n+    }\n+\n+    /**\n+     * <p>Returns new instance of <code>klazz</code> created using constructor\n+     * with signature <code>parameterTypes</code> and actual arguments\n+     * <code>args</code>.</p>\n+     *\n+     * <p>The signatures should match exactly.</p>\n+     *\n+     * @param cls the class to be constructed.\n+     * @param args actual argument array\n+     * @param parameterTypes parameter types array\n+     * @return new instance of <code>klazz</code>\n+     *\n+     * @throws NoSuchMethodException if matching constructor cannot be found\n+     * @throws IllegalAccessException thrown on the constructor's invocation\n+     * @throws InvocationTargetException thrown on the constructor's invocation\n+     * @throws InstantiationException thrown on the constructor's invocation\n+     * @see Constructor#newInstance\n+     */\n+    public static Object invokeExactConstructor(Class<?> cls, Object[] args,\n+            Class<?>[] parameterTypes) throws NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException,\n+            InstantiationException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        Constructor<?> ctor = getAccessibleConstructor(cls, parameterTypes);\n+        if (null == ctor) {\n+            throw new NoSuchMethodException(\n+                    \"No such accessible constructor on object: \"\n+                            + cls.getName());\n+        }\n+        return ctor.newInstance(args);\n+    }\n+\n+    /**\n+     * Returns a constructor with single argument.\n+     * @param cls the class to be constructed\n+     * @param parameterType The constructor parameter type\n+     * @return null if matching accessible constructor can not be found.\n+     * @see Class#getConstructor\n+     * @see #getAccessibleConstructor(java.lang.reflect.Constructor)\n+     */\n+    public static Constructor<?> getAccessibleConstructor(Class<?> cls,\n+            Class<?> parameterType) {\n+        return getAccessibleConstructor(cls, new Class[] { parameterType });\n+    }\n+\n+    /**\n+     * Returns a constructor given a class and signature.\n+     * @param cls the class to be constructed\n+     * @param parameterTypes the parameter array\n+     * @return null if matching accessible constructor can not be found\n+     * @see Class#getConstructor\n+     * @see #getAccessibleConstructor(java.lang.reflect.Constructor)\n+     */\n+    public static Constructor<?> getAccessibleConstructor(Class<?> cls,\n+            Class<?>[] parameterTypes) {\n+        try {\n+            return getAccessibleConstructor(cls.getConstructor(parameterTypes));\n+        } catch (NoSuchMethodException e) {\n+            return (null);\n+        }\n+    }\n+\n+    /**\n+     * Returns accessible version of the given constructor.\n+     * @param ctor prototype constructor object.\n+     * @return <code>null</code> if accessible constructor can not be found.\n+     * @see java.lang.SecurityManager\n+     */\n+    public static Constructor<?> getAccessibleConstructor(Constructor<?> ctor) {\n+        return MemberUtils.isAccessible(ctor)\n+                && Modifier.isPublic(ctor.getDeclaringClass().getModifiers()) ? ctor\n+                : null;\n+    }\n+\n+    /**\n+     * <p>Find an accessible constructor with compatible parameters.\n+     * Compatible parameters mean that every method parameter is assignable from\n+     * the given parameters. In other words, it finds constructor that will take\n+     * the parameters given.</p>\n+     *\n+     * <p>First it checks if there is constructor matching the exact signature.\n+     * If no such, all the constructors of the class are tested if their signatures\n+     * are assignment compatible with the parameter types.\n+     * The first matching constructor is returned.</p>\n+     *\n+     * @param cls find constructor for this class\n+     * @param parameterTypes find method with compatible parameters\n+     * @return a valid Constructor object. If there's no matching constructor, returns <code>null</code>.\n+     */\n+    public static Constructor<?> getMatchingAccessibleConstructor(Class<?> cls,\n+            Class<?>[] parameterTypes) {\n+        // see if we can find the constructor directly\n+        // most of the time this works and it's much faster\n+        try {\n+            Constructor<?> ctor = cls.getConstructor(parameterTypes);\n+            MemberUtils.setAccessibleWorkaround(ctor);\n+            return ctor;\n+        } catch (NoSuchMethodException e) { /* SWALLOW */\n+        }\n+        Constructor<?> result = null;\n+        // search through all constructors\n+        Constructor<?>[] ctors = cls.getConstructors();\n+        for (int i = 0; i < ctors.length; i++) {\n+            // compare parameters\n+            if (ClassUtils.isAssignable(parameterTypes, ctors[i]\n+                    .getParameterTypes(), true)) {\n+                // get accessible version of method\n+                Constructor<?> ctor = getAccessibleConstructor(ctors[i]);\n+                if (ctor != null) {\n+                    MemberUtils.setAccessibleWorkaround(ctor);\n+                    if (result == null\n+                            || MemberUtils.compareParameterTypes(ctor\n+                                    .getParameterTypes(), result\n+                                    .getParameterTypes(), parameterTypes) < 0) {\n+                        result = ctor;\n+                    }\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/reflect/FieldUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Iterator;\n+\n+import org.apache.commons.lang.ClassUtils;\n+\n+/**\n+ * Utilities for working with fields by reflection. Adapted and refactored\n+ * from the dormant [reflect] Commons sandbox component.\n+ * <p>\n+ * The ability is provided to break the scoping restrictions coded by the\n+ * programmer. This can allow fields to be changed that shouldn't be. This\n+ * facility should be used with care.\n+ *\n+ * @author Apache Software Foundation\n+ * @author Matt Benson\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class FieldUtils {\n+\n+    /**\n+     * FieldUtils instances should NOT be constructed in standard programming.\n+     * <p>\n+     * This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.\n+     */\n+    public FieldUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Gets an accessible <code>Field</code> by name repecting scope.\n+     * Superclasses/interfaces will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     */\n+    public static Field getField(Class<?> cls, String fieldName) {\n+        Field field = getField(cls, fieldName, false);\n+        MemberUtils.setAccessibleWorkaround(field);\n+        return field;\n+    }\n+\n+    /**\n+     * Gets an accessible <code>Field</code> by name breaking scope\n+     * if requested. Superclasses/interfaces will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     */\n+    public static Field getField(final Class<?> cls, String fieldName, boolean forceAccess) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        if (fieldName == null) {\n+            throw new IllegalArgumentException(\"The field name must not be null\");\n+        }\n+        // Sun Java 1.3 has a bugged implementation of getField hence we write the\n+        // code ourselves\n+\n+        // getField() will return the Field object with the declaring class\n+        // set correctly to the class that declares the field. Thus requesting the\n+        // field on a subclass will return the field from the superclass.\n+        //\n+        // priority order for lookup:\n+        // searchclass private/protected/package/public\n+        // superclass protected/package/public\n+        //  private/different package blocks access to further superclasses\n+        // implementedinterface public\n+\n+        // check up the superclass hierarchy\n+        for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {\n+            try {\n+                Field field = acls.getDeclaredField(fieldName);\n+                // getDeclaredField checks for non-public scopes as well\n+                // and it returns accurate results\n+                if (!Modifier.isPublic(field.getModifiers())) {\n+                    if (forceAccess) {\n+                        field.setAccessible(true);\n+                    } else {\n+                        continue;\n+                    }\n+                }\n+                return field;\n+            } catch (NoSuchFieldException ex) {\n+                // ignore\n+            }\n+        }\n+        // check the public interface case. This must be manually searched for\n+        // incase there is a public supersuperclass field hidden by a private/package\n+        // superclass field.\n+        Field match = null;\n+        for (Iterator<Class<?>> intf = ClassUtils.getAllInterfaces(cls).iterator(); intf\n+                .hasNext();) {\n+            try {\n+                Field test = ((Class<?>) intf.next()).getField(fieldName);\n+                if (match != null) {\n+                    throw new IllegalArgumentException(\n+                            \"Reference to field \"\n+                                    + fieldName\n+                                    + \" is ambiguous relative to \"\n+                                    + cls\n+                                    + \"; a matching field exists on two or more implemented interfaces.\");\n+                }\n+                match = test;\n+            } catch (NoSuchFieldException ex) {\n+                // ignore\n+            }\n+        }\n+        return match;\n+    }\n+\n+    /**\n+     * Gets an accessible <code>Field</code> by name respecting scope.\n+     * Only the specified class will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     */\n+    public static Field getDeclaredField(Class<?> cls, String fieldName) {\n+        return getDeclaredField(cls, fieldName, false);\n+    }\n+\n+    /**\n+     * Gets an accessible <code>Field</code> by name breaking scope\n+     * if requested. Only the specified class will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. False will only match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     */\n+    public static Field getDeclaredField(Class<?> cls, String fieldName, boolean forceAccess) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        if (fieldName == null) {\n+            throw new IllegalArgumentException(\"The field name must not be null\");\n+        }\n+        try {\n+            // only consider the specified class by using getDeclaredField()\n+            Field field = cls.getDeclaredField(fieldName);\n+            if (!MemberUtils.isAccessible(field)) {\n+                if (forceAccess) {\n+                    field.setAccessible(true);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            return field;\n+        } catch (NoSuchFieldException e) {\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Read an accessible static Field.\n+     * @param field to read\n+     * @return the field value\n+     * @throws IllegalArgumentException if the field is null or not static\n+     * @throws IllegalAccessException if the field is not accessible\n+     */\n+    public static Object readStaticField(Field field) throws IllegalAccessException {\n+        return readStaticField(field, false);\n+    }\n+\n+    /**\n+     * Read a static Field.\n+     * @param field to read\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method.\n+     * @return the field value\n+     * @throws IllegalArgumentException if the field is null or not static\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static Object readStaticField(Field field, boolean forceAccess) throws IllegalAccessException {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (!Modifier.isStatic(field.getModifiers())) {\n+            throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n+        }\n+        return readField(field, (Object) null, forceAccess);\n+    }\n+\n+    /**\n+     * Read the named public static field. Superclasses will be considered.\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the value of the field\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the field is not accessible\n+     */\n+    public static Object readStaticField(Class<?> cls, String fieldName) throws IllegalAccessException {\n+        return readStaticField(cls, fieldName, false);\n+    }\n+\n+    /**\n+     * Read the named static field. Superclasses will be considered.\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static Object readStaticField(Class<?> cls, String fieldName, boolean forceAccess) throws IllegalAccessException {\n+        Field field = getField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n+        }\n+        //already forced access above, don't repeat it here:\n+        return readStaticField(field, false);\n+    }\n+\n+    /**\n+     * Gets a static Field value by name. The field must be public.\n+     * Only the specified class will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the value of the field\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the field is not accessible\n+     */\n+    public static Object readDeclaredStaticField(Class<?> cls, String fieldName) throws IllegalAccessException {\n+        return readDeclaredStaticField(cls, fieldName, false);\n+    }\n+\n+    /**\n+     * Gets a static Field value by name. Only the specified class will\n+     * be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static Object readDeclaredStaticField(Class<?> cls, String fieldName, boolean forceAccess)\n+            throws IllegalAccessException {\n+        Field field = getDeclaredField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n+        }\n+        //already forced access above, don't repeat it here:\n+        return readStaticField(field, false);\n+    }\n+\n+    /**\n+     * Read an accessible Field.\n+     * @param field  the field to use\n+     * @param target  the object to call on, may be null for static fields\n+     * @return the field value\n+     * @throws IllegalArgumentException if the field is null\n+     * @throws IllegalAccessException if the field is not accessible\n+     */\n+    public static Object readField(Field field, Object target) throws IllegalAccessException {\n+        return readField(field, target, false);\n+    }\n+\n+    /**\n+     * Read a Field.\n+     * @param field  the field to use\n+     * @param target  the object to call on, may be null for static fields\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method.\n+     * @return the field value\n+     * @throws IllegalArgumentException if the field is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static Object readField(Field field, Object target, boolean forceAccess) throws IllegalAccessException {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (forceAccess && !field.isAccessible()) {\n+            field.setAccessible(true);\n+        } else {\n+            MemberUtils.setAccessibleWorkaround(field);\n+        }\n+        return field.get(target);\n+    }\n+\n+    /**\n+     * Read the named public field. Superclasses will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the value of the field\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the named field is not public\n+     */\n+    public static Object readField(Object target, String fieldName) throws IllegalAccessException {\n+        return readField(target, fieldName, false);\n+    }\n+\n+    /**\n+     * Read the named field. Superclasses will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @return the field value\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the named field is not made accessible\n+     */\n+    public static Object readField(Object target, String fieldName, boolean forceAccess) throws IllegalAccessException {\n+        if (target == null) {\n+            throw new IllegalArgumentException(\"target object must not be null\");\n+        }\n+        Class<?> cls = target.getClass();\n+        Field field = getField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n+        }\n+        //already forced access above, don't repeat it here:\n+        return readField(field, target);\n+    }\n+\n+    /**\n+     * Read the named public field. Only the class of the specified object will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the value of the field\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the named field is not public\n+     */\n+    public static Object readDeclaredField(Object target, String fieldName) throws IllegalAccessException {\n+        return readDeclaredField(target, fieldName, false);\n+    }\n+\n+    /**\n+     * <p<>Gets a Field value by name. Only the class of the specified\n+     * object will be considered.\n+     *\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static Object readDeclaredField(Object target, String fieldName, boolean forceAccess) throws IllegalAccessException {\n+        if (target == null) {\n+            throw new IllegalArgumentException(\"target object must not be null\");\n+        }\n+        Class<?> cls = target.getClass();\n+        Field field = getDeclaredField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n+        }\n+        //already forced access above, don't repeat it here:\n+        return readField(field, target);\n+    }\n+\n+    /**\n+     * Write a public static Field.\n+     * @param field to write\n+     * @param value to set\n+     * @throws IllegalArgumentException if the field is null or not static\n+     * @throws IllegalAccessException if the field is not public or is final\n+     */\n+    public static void writeStaticField(Field field, Object value) throws IllegalAccessException {\n+        writeStaticField(field, value, false);\n+    }\n+\n+    /**\n+     * Write a static Field.\n+     * @param field to write\n+     * @param value to set\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @throws IllegalArgumentException if the field is null or not static\n+     * @throws IllegalAccessException if the field is not made accessible or is final\n+     */\n+    public static void writeStaticField(Field field, Object value, boolean forceAccess) throws IllegalAccessException {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (!Modifier.isStatic(field.getModifiers())) {\n+            throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n+        }\n+        writeField(field, (Object) null, value, forceAccess);\n+    }\n+\n+    /**\n+     * Write a named public static Field. Superclasses will be considered.\n+     * @param cls Class on which the Field is to be found\n+     * @param fieldName to write\n+     * @param value to set\n+     * @throws IllegalArgumentException if the field cannot be located or is not static\n+     * @throws IllegalAccessException if the field is not public or is final\n+     */\n+    public static void writeStaticField(Class<?> cls, String fieldName, Object value) throws IllegalAccessException {\n+        writeStaticField(cls, fieldName, value, false);\n+    }\n+\n+    /**\n+     * Write a named static Field. Superclasses will be considered.\n+     * @param cls Class on which the Field is to be found\n+     * @param fieldName to write\n+     * @param value to set\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @throws IllegalArgumentException if the field cannot be located or is not static\n+     * @throws IllegalAccessException if the field is not made accessible or is final\n+     */\n+    public static void writeStaticField(Class<?> cls, String fieldName, Object value, boolean forceAccess)\n+            throws IllegalAccessException {\n+        Field field = getField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n+        }\n+        //already forced access above, don't repeat it here:\n+        writeStaticField(field, value);\n+    }\n+\n+    /**\n+     * Write a named public static Field. Only the specified class will be considered.\n+     * @param cls Class on which the Field is to be found\n+     * @param fieldName to write\n+     * @param value to set\n+     * @throws IllegalArgumentException if the field cannot be located or is not static\n+     * @throws IllegalAccessException if the field is not public or is final\n+     */\n+    public static void writeDeclaredStaticField(Class<?> cls, String fieldName, Object value)\n+            throws IllegalAccessException {\n+        writeDeclaredStaticField(cls, fieldName, value, false);\n+    }\n+\n+    /**\n+     * Write a named static Field. Only the specified class will be considered.\n+     * @param cls Class on which the Field is to be found\n+     * @param fieldName to write\n+     * @param value to set\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @throws IllegalArgumentException if the field cannot be located or is not static\n+     * @throws IllegalAccessException if the field is not made accessible or is final\n+      */\n+    public static void writeDeclaredStaticField(Class<?> cls, String fieldName, Object value, boolean forceAccess)\n+            throws IllegalAccessException {\n+        Field field = getDeclaredField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n+        }\n+        //already forced access above, don't repeat it here:\n+        writeField(field, (Object) null, value);\n+    }\n+\n+    /**\n+     * Write an accessible field.\n+     * @param field to write\n+     * @param target  the object to call on, may be null for static fields\n+     * @param value to set\n+     * @throws IllegalArgumentException if the field is null\n+     * @throws IllegalAccessException if the field is not accessible or is final\n+     */\n+    public static void writeField(Field field, Object target, Object value) throws IllegalAccessException {\n+        writeField(field, target, value, false);\n+    }\n+\n+    /**\n+     * Write a field.\n+     * @param field to write\n+     * @param target  the object to call on, may be null for static fields\n+     * @param value to set\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @throws IllegalArgumentException if the field is null\n+     * @throws IllegalAccessException if the field is not made accessible or is final\n+     */\n+    public static void writeField(Field field, Object target, Object value, boolean forceAccess) throws IllegalAccessException {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (forceAccess && !field.isAccessible()) {\n+            field.setAccessible(true);\n+        } else {\n+            MemberUtils.setAccessibleWorkaround(field);\n+        }\n+        field.set(target, value);\n+    }\n+\n+    /**\n+     * Write a public field. Superclasses will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param value to set\n+     * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n+     * @throws IllegalAccessException if the field is not accessible\n+     */\n+    public static void writeField(Object target, String fieldName, Object value) throws IllegalAccessException {\n+        writeField(target, fieldName, value, false);\n+    }\n+\n+    /**\n+     * Write a field. Superclasses will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param value to set\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static void writeField(Object target, String fieldName, Object value, boolean forceAccess)\n+            throws IllegalAccessException {\n+        if (target == null) {\n+            throw new IllegalArgumentException(\"target object must not be null\");\n+        }\n+        Class<?> cls = target.getClass();\n+        Field field = getField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n+        }\n+        //already forced access above, don't repeat it here:\n+        writeField(field, target, value);\n+    }\n+\n+    /**\n+     * Write a public field. Only the specified class will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param value to set\n+     * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static void writeDeclaredField(Object target, String fieldName, Object value) throws IllegalAccessException {\n+        writeDeclaredField(target, fieldName, value, false);\n+    }\n+\n+    /**\n+     * Write a public field. Only the specified class will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param value to set\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static void writeDeclaredField(Object target, String fieldName, Object value, boolean forceAccess)\n+            throws IllegalAccessException {\n+        if (target == null) {\n+            throw new IllegalArgumentException(\"target object must not be null\");\n+        }\n+        Class<?> cls = target.getClass();\n+        Field field = getDeclaredField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n+        }\n+        //already forced access above, don't repeat it here:\n+        writeField(field, target, value);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/reflect/MemberUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.ClassUtils;\n+import org.apache.commons.lang.SystemUtils;\n+\n+/**\n+ * Contains common code for working with Methods/Constructors, extracted and\n+ * refactored from <code>MethodUtils</code> when it was imported from Commons BeanUtils.\n+ *\n+ * @author Apache Software Foundation\n+ * @author Steve Cohen\n+ * @author Matt Benson\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+abstract class MemberUtils {\n+    // TODO extract an interface to implement compareParameterSets(...)?\n+\n+    private static final int ACCESS_TEST = Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE;\n+\n+    private static final Method IS_SYNTHETIC;\n+    static {\n+        Method isSynthetic = null;\n+        if (SystemUtils.isJavaVersionAtLeast(1.5f)) {\n+            // cannot call synthetic methods:\n+            try {\n+                isSynthetic = Member.class.getMethod(\"isSynthetic\",\n+                        ArrayUtils.EMPTY_CLASS_ARRAY);\n+            } catch (Exception e) {\n+            }\n+        }\n+        IS_SYNTHETIC = isSynthetic;\n+    }\n+\n+    /** Array of primitive number types ordered by \"promotability\" */\n+    private static final Class<?>[] ORDERED_PRIMITIVE_TYPES = { Byte.TYPE,\n+            Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE,\n+            Double.TYPE };\n+\n+    /**\n+     * XXX Default access superclass workaround\n+     *\n+     * When a public class has a default access superclass with public\n+     * members, these members are accessible. Calling them from\n+     * compiled code works fine. Unfortunately, on some JVMs, using reflection to invoke these\n+     * members seems to (wrongly) to prevent access even when the\n+     * modifer is public. Calling setAccessible(true) solves the problem\n+     * but will only work from sufficiently privileged code. Better\n+     * workarounds would be gratefully accepted.\n+     * @param o the AccessibleObject to set as accessible\n+     */\n+    static void setAccessibleWorkaround(AccessibleObject o) {\n+        if (o == null || o.isAccessible()) {\n+            return;\n+        }\n+        Member m = (Member) o;\n+        if (Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) {\n+            try {\n+                o.setAccessible(true);\n+            } catch (SecurityException e) {\n+                // ignore in favor of subsequent IllegalAccessException\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Learn whether a given set of modifiers implies package access.\n+     * @param modifiers to test\n+     * @return true unless package/protected/private modifier detected\n+     */\n+    static boolean isPackageAccess(int modifiers) {\n+        return (modifiers & ACCESS_TEST) == 0;\n+    }\n+\n+    /**\n+     * Check a Member for basic accessibility.\n+     * @param m Member to check\n+     * @return true if <code>m</code> is accessible\n+     */\n+    static boolean isAccessible(Member m) {\n+        return m != null && Modifier.isPublic(m.getModifiers())\n+                && !isSynthetic(m);\n+    }\n+\n+    /**\n+     * Try to learn whether a given member, on JDK >= 1.5, is synthetic.\n+     * @param m Member to check\n+     * @return true if <code>m</code> was introduced by the compiler.\n+     */\n+    static boolean isSynthetic(Member m) {\n+        if (IS_SYNTHETIC != null) {\n+            try {\n+                return ((Boolean) IS_SYNTHETIC.invoke(m, (Object[]) null)).booleanValue();\n+            } catch (Exception e) {\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Compare the relative fitness of two sets of parameter types in terms of\n+     * matching a third set of runtime parameter types, such that a list ordered\n+     * by the results of the comparison would return the best match first (least).\n+     *\n+     * @param left the \"left\" parameter set\n+     * @param right the \"right\" parameter set\n+     * @param actual the runtime parameter types to match against <code>left</code>/<code>right</code>\n+     * @return int consistent with <code>compare</code> semantics\n+     */\n+    static int compareParameterTypes(Class<?>[] left, Class<?>[] right, Class<?>[] actual) {\n+        float leftCost = getTotalTransformationCost(actual, left);\n+        float rightCost = getTotalTransformationCost(actual, right);\n+        return leftCost < rightCost ? -1 : rightCost < leftCost ? 1 : 0;\n+    }\n+\n+    /**\n+     * Returns the sum of the object transformation cost for each class in the source\n+     * argument list.\n+     * @param srcArgs The source arguments\n+     * @param destArgs The destination arguments\n+     * @return The total transformation cost\n+     */\n+    private static float getTotalTransformationCost(Class<?>[] srcArgs,\n+            Class<?>[] destArgs) {\n+        float totalCost = 0.0f;\n+        for (int i = 0; i < srcArgs.length; i++) {\n+            Class<?> srcClass, destClass;\n+            srcClass = srcArgs[i];\n+            destClass = destArgs[i];\n+            totalCost += getObjectTransformationCost(srcClass, destClass);\n+        }\n+        return totalCost;\n+    }\n+\n+    /**\n+     * Gets the number of steps required needed to turn the source class into the \n+     * destination class. This represents the number of steps in the object hierarchy \n+     * graph.\n+     * @param srcClass The source class\n+     * @param destClass The destination class\n+     * @return The cost of transforming an object\n+     */\n+    private static float getObjectTransformationCost(Class<?> srcClass,\n+            Class<?> destClass) {\n+        if (destClass.isPrimitive()) {\n+            return getPrimitivePromotionCost(srcClass, destClass);\n+        }\n+        float cost = 0.0f;\n+        while (destClass != null && !destClass.equals(srcClass)) {\n+            if (destClass.isInterface()\n+                    && ClassUtils.isAssignable(srcClass, destClass)) {\n+                // slight penalty for interface match.\n+                // we still want an exact match to override an interface match,\n+                // but\n+                // an interface match should override anything where we have to\n+                // get a superclass.\n+                cost += 0.25f;\n+                break;\n+            }\n+            cost++;\n+            destClass = destClass.getSuperclass();\n+        }\n+        /*\n+         * If the destination class is null, we've travelled all the way up to\n+         * an Object match. We'll penalize this by adding 1.5 to the cost.\n+         */\n+        if (destClass == null) {\n+            cost += 1.5f;\n+        }\n+        return cost;\n+    }\n+\n+    /**\n+     * Get the number of steps required to promote a primitive number to another type.\n+     * @param srcClass the (primitive) source class\n+     * @param destClass the (primitive) destination class\n+     * @return The cost of promoting the primitive\n+     */\n+    private static float getPrimitivePromotionCost(final Class<?> srcClass,\n+            final Class<?> destClass) {\n+        float cost = 0.0f;\n+        Class<?> cls = srcClass;\n+        if (!cls.isPrimitive()) {\n+            // slight unwrapping penalty\n+            cost += 0.1f;\n+            cls = ClassUtils.wrapperToPrimitive(cls);\n+        }\n+        for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) {\n+            if (cls == ORDERED_PRIMITIVE_TYPES[i]) {\n+                cost += 0.1f;\n+                if (i < ORDERED_PRIMITIVE_TYPES.length - 1) {\n+                    cls = ORDERED_PRIMITIVE_TYPES[i + 1];\n+                }\n+            }\n+        }\n+        return cost;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/reflect/MethodUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.ClassUtils;\n+\n+/**\n+ * <p> Utility reflection methods focused on methods, originally from Commons BeanUtils.\n+ * Differences from the BeanUtils version may be noted, especially where similar functionality\n+ * already existed within Lang.\n+ * </p>\n+ *\n+ * <h3>Known Limitations</h3>\n+ * <h4>Accessing Public Methods In A Default Access Superclass</h4>\n+ * <p>There is an issue when invoking public methods contained in a default access superclass on JREs prior to 1.4.\n+ * Reflection locates these methods fine and correctly assigns them as public.\n+ * However, an <code>IllegalAccessException</code> is thrown if the method is invoked.</p>\n+ *\n+ * <p><code>MethodUtils</code> contains a workaround for this situation. \n+ * It will attempt to call <code>setAccessible</code> on this method.\n+ * If this call succeeds, then the method can be invoked as normal.\n+ * This call will only succeed when the application has sufficient security privileges. \n+ * If this call fails then the method may fail.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Craig R. McClanahan\n+ * @author Ralph Schaer\n+ * @author Chris Audley\n+ * @author Rey Fran&#231;ois\n+ * @author Gregor Ra&#253;man\n+ * @author Jan Sorensen\n+ * @author Robert Burrell Donkin\n+ * @author Niall Pemberton\n+ * @author Matt Benson\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class MethodUtils {\n+\n+    /**\n+     * <p>MethodUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as\n+     * <code>MethodUtils.getAccessibleMethod(method)</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public MethodUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * <p>Invoke a named method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> object\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeMethod(Object object, String methodName, Object[] args)}.\n+     * </p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param arg use this argument\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible via reflection\n+     */\n+    public static Object invokeMethod(Object object, String methodName,\n+            Object arg) throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        return invokeMethod(object, methodName, new Object[] { arg });\n+    }\n+\n+    /**\n+     * <p>Invoke a named method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> object\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeMethod(Object object,String methodName, Object[] args, Class[] parameterTypes)}.\n+     * </p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible via reflection\n+     */\n+    public static Object invokeMethod(Object object, String methodName,\n+            Object[] args) throws NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        int arguments = args.length;\n+        Class<?>[] parameterTypes = new Class[arguments];\n+        for (int i = 0; i < arguments; i++) {\n+            parameterTypes[i] = args[i].getClass();\n+        }\n+        return invokeMethod(object, methodName, args, parameterTypes);\n+    }\n+\n+    /**\n+     * <p>Invoke a named method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> object\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @param parameterTypes match these parameters - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible via reflection\n+     */\n+    public static Object invokeMethod(Object object, String methodName,\n+            Object[] args, Class<?>[] parameterTypes)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        Method method = getMatchingAccessibleMethod(object.getClass(),\n+                methodName, parameterTypes);\n+        if (method == null) {\n+            throw new NoSuchMethodException(\"No such accessible method: \"\n+                    + methodName + \"() on object: \"\n+                    + object.getClass().getName());\n+        }\n+        return method.invoke(object, args);\n+    }\n+\n+    /**\n+     * <p>Invoke a method whose parameter type matches exactly the object\n+     * type.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeExactMethod(Object object,String methodName,Object [] args)}.\n+     * </p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param arg use this argument\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactMethod(Object object, String methodName,\n+            Object arg) throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        return invokeExactMethod(object, methodName, new Object[] { arg });\n+    }\n+\n+    /**\n+     * <p>Invoke a method whose parameter types match exactly the object\n+     * types.</p>\n+     *\n+     * <p> This uses reflection to invoke the method obtained from a call to\n+     * <code>getAccessibleMethod()</code>.</p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactMethod(Object object, String methodName,\n+            Object[] args) throws NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        int arguments = args.length;\n+        Class<?>[] parameterTypes = new Class[arguments];\n+        for (int i = 0; i < arguments; i++) {\n+            parameterTypes[i] = args[i].getClass();\n+        }\n+        return invokeExactMethod(object, methodName, args, parameterTypes);\n+    }\n+\n+    /**\n+     * <p>Invoke a method whose parameter types match exactly the parameter\n+     * types given.</p>\n+     *\n+     * <p>This uses reflection to invoke the method obtained from a call to\n+     * <code>getAccessibleMethod()</code>.</p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @param parameterTypes match these parameters - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactMethod(Object object, String methodName,\n+            Object[] args, Class<?>[] parameterTypes)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        Method method = getAccessibleMethod(object.getClass(), methodName,\n+                parameterTypes);\n+        if (method == null) {\n+            throw new NoSuchMethodException(\"No such accessible method: \"\n+                    + methodName + \"() on object: \"\n+                    + object.getClass().getName());\n+        }\n+        return method.invoke(object, args);\n+    }\n+\n+    /**\n+     * <p>Invoke a static method whose parameter types match exactly the parameter\n+     * types given.</p>\n+     *\n+     * <p>This uses reflection to invoke the method obtained from a call to\n+     * {@link #getAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * @param cls invoke static method on this class\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @param parameterTypes match these parameters - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactStaticMethod(Class<?> cls, String methodName,\n+            Object[] args, Class<?>[] parameterTypes)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        Method method = getAccessibleMethod(cls, methodName, parameterTypes);\n+        if (method == null) {\n+            throw new NoSuchMethodException(\"No such accessible method: \"\n+                    + methodName + \"() on class: \" + cls.getName());\n+        }\n+        return method.invoke(null, args);\n+    }\n+\n+    /**\n+     * <p>Invoke a named static method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeStaticMethod(Class objectClass,String methodName,Object [] args)}.\n+     * </p>\n+     *\n+     * @param cls invoke static method on this class\n+     * @param methodName get method with this name\n+     * @param arg use this argument\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeStaticMethod(Class<?> cls, String methodName,\n+            Object arg) throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        return invokeStaticMethod(cls, methodName, new Object[] { arg });\n+    }\n+\n+    /**\n+     * <p>Invoke a named static method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeStaticMethod(Class objectClass,String methodName,Object [] args,Class[] parameterTypes)}.\n+     * </p>\n+     *\n+     * @param cls invoke static method on this class\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeStaticMethod(Class<?> cls, String methodName,\n+            Object[] args) throws NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        int arguments = args.length;\n+        Class<?>[] parameterTypes = new Class[arguments];\n+        for (int i = 0; i < arguments; i++) {\n+            parameterTypes[i] = args[i].getClass();\n+        }\n+        return invokeStaticMethod(cls, methodName, args, parameterTypes);\n+    }\n+\n+    /**\n+     * <p>Invoke a named static method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     *\n+     * @param cls invoke static method on this class\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @param parameterTypes match these parameters - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeStaticMethod(Class<?> cls, String methodName,\n+            Object[] args, Class<?>[] parameterTypes)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        Method method = getMatchingAccessibleMethod(cls, methodName,\n+                parameterTypes);\n+        if (method == null) {\n+            throw new NoSuchMethodException(\"No such accessible method: \"\n+                    + methodName + \"() on class: \" + cls.getName());\n+        }\n+        return method.invoke(null, args);\n+    }\n+\n+    /**\n+     * <p>Invoke a static method whose parameter type matches exactly the object\n+     * type.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeExactStaticMethod(Class objectClass,String methodName,Object [] args)}.\n+     * </p>\n+     *\n+     * @param cls invoke static method on this class\n+     * @param methodName get method with this name\n+     * @param arg use this argument\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactStaticMethod(Class<?> cls, String methodName,\n+            Object arg) throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        return invokeExactStaticMethod(cls, methodName, new Object[] { arg });\n+    }\n+\n+    /**\n+     * <p>Invoke a static method whose parameter types match exactly the object\n+     * types.</p>\n+     *\n+     * <p> This uses reflection to invoke the method obtained from a call to\n+     * {@link #getAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * @param cls invoke static method on this class\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactStaticMethod(Class<?> cls, String methodName,\n+            Object[] args) throws NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        int arguments = args.length;\n+        Class<?>[] parameterTypes = new Class[arguments];\n+        for (int i = 0; i < arguments; i++) {\n+            parameterTypes[i] = args[i].getClass();\n+        }\n+        return invokeExactStaticMethod(cls, methodName, args, parameterTypes);\n+    }\n+\n+    /**\n+     * <p>Return an accessible method (that is, one that can be invoked via\n+     * reflection) with given name and a single parameter.  If no such method\n+     * can be found, return <code>null</code>.\n+     * Basically, a convenience wrapper that constructs a <code>Class</code>\n+     * array for you.</p>\n+     *\n+     * @param cls get method from this class\n+     * @param methodName get method with this name\n+     * @param parameterType taking this type of parameter\n+     * @return The accessible method\n+     */\n+    public static Method getAccessibleMethod(Class<?> cls, String methodName,\n+            Class<?> parameterType) {\n+        return getAccessibleMethod(cls, methodName,\n+                new Class<?>[] { parameterType });\n+    }\n+\n+    /**\n+     * <p>Return an accessible method (that is, one that can be invoked via\n+     * reflection) with given name and parameters.  If no such method\n+     * can be found, return <code>null</code>.\n+     * This is just a convenient wrapper for\n+     * {@link #getAccessibleMethod(Method method)}.</p>\n+     *\n+     * @param cls get method from this class\n+     * @param methodName get method with this name\n+     * @param parameterTypes with these parameters types\n+     * @return The accessible method\n+     */\n+    public static Method getAccessibleMethod(Class<?> cls, String methodName,\n+            Class<?>[] parameterTypes) {\n+        try {\n+            return getAccessibleMethod(cls.getMethod(methodName,\n+                    parameterTypes));\n+        } catch (NoSuchMethodException e) {\n+            return (null);\n+        }\n+    }\n+\n+    /**\n+     * <p>Return an accessible method (that is, one that can be invoked via\n+     * reflection) that implements the specified Method.  If no such method\n+     * can be found, return <code>null</code>.</p>\n+     *\n+     * @param method The method that we wish to call\n+     * @return The accessible method\n+     */\n+    public static Method getAccessibleMethod(Method method) {\n+        if (!MemberUtils.isAccessible(method)) {\n+            return null;\n+        }\n+        // If the declaring class is public, we are done\n+        Class<?> cls = method.getDeclaringClass();\n+        if (Modifier.isPublic(cls.getModifiers())) {\n+            return method;\n+        }\n+        String methodName = method.getName();\n+        Class<?>[] parameterTypes = method.getParameterTypes();\n+\n+        // Check the implemented interfaces and subinterfaces\n+        method = getAccessibleMethodFromInterfaceNest(cls, methodName,\n+                parameterTypes);\n+\n+        // Check the superclass chain\n+        if (method == null) {\n+            method = getAccessibleMethodFromSuperclass(cls, methodName,\n+                    parameterTypes);\n+        }\n+        return method;\n+    }\n+\n+    /**\n+     * <p>Return an accessible method (that is, one that can be invoked via\n+     * reflection) by scanning through the superclasses. If no such method\n+     * can be found, return <code>null</code>.</p>\n+     *\n+     * @param cls Class to be checked\n+     * @param methodName Method name of the method we wish to call\n+     * @param parameterTypes The parameter type signatures\n+     */\n+    private static Method getAccessibleMethodFromSuperclass(Class<?> cls,\n+            String methodName, Class<?>[] parameterTypes) {\n+        Class<?> parentClass = cls.getSuperclass();\n+        while (parentClass != null) {\n+            if (Modifier.isPublic(parentClass.getModifiers())) {\n+                try {\n+                    return parentClass.getMethod(methodName, parameterTypes);\n+                } catch (NoSuchMethodException e) {\n+                    return null;\n+                }\n+            }\n+            parentClass = parentClass.getSuperclass();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Return an accessible method (that is, one that can be invoked via\n+     * reflection) that implements the specified method, by scanning through\n+     * all implemented interfaces and subinterfaces.  If no such method\n+     * can be found, return <code>null</code>.</p>\n+     *\n+     * <p> There isn't any good reason why this method must be private.\n+     * It is because there doesn't seem any reason why other classes should\n+     * call this rather than the higher level methods.</p>\n+     *\n+     * @param cls Parent class for the interfaces to be checked\n+     * @param methodName Method name of the method we wish to call\n+     * @param parameterTypes The parameter type signatures\n+     */\n+    private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls,\n+            String methodName, Class<?>[] parameterTypes) {\n+        Method method = null;\n+\n+        // Search up the superclass chain\n+        for (; cls != null; cls = cls.getSuperclass()) {\n+\n+            // Check the implemented interfaces of the parent class\n+            Class<?>[] interfaces = cls.getInterfaces();\n+            for (int i = 0; i < interfaces.length; i++) {\n+                // Is this interface public?\n+                if (!Modifier.isPublic(interfaces[i].getModifiers())) {\n+                    continue;\n+                }\n+                // Does the method exist on this interface?\n+                try {\n+                    method = interfaces[i].getDeclaredMethod(methodName,\n+                            parameterTypes);\n+                } catch (NoSuchMethodException e) {\n+                    /*\n+                     * Swallow, if no method is found after the loop then this\n+                     * method returns null.\n+                     */\n+                }\n+                if (method != null) {\n+                    break;\n+                }\n+                // Recursively check our parent interfaces\n+                method = getAccessibleMethodFromInterfaceNest(interfaces[i],\n+                        methodName, parameterTypes);\n+                if (method != null) {\n+                    break;\n+                }\n+            }\n+        }\n+        return method;\n+    }\n+\n+    /**\n+     * <p>Find an accessible method that matches the given name and has compatible parameters.\n+     * Compatible parameters mean that every method parameter is assignable from \n+     * the given parameters.\n+     * In other words, it finds a method with the given name \n+     * that will take the parameters given.<p>\n+     *\n+     * <p>This method is used by \n+     * {@link \n+     * #invokeMethod(Object object, String methodName, Object[] args, Class[] parameterTypes)}.\n+     *\n+     * <p>This method can match primitive parameter by passing in wrapper classes.\n+     * For example, a <code>Boolean</code> will match a primitive <code>boolean</code>\n+     * parameter.\n+     *\n+     * @param cls find method in this class\n+     * @param methodName find method with this name\n+     * @param parameterTypes find method with most compatible parameters \n+     * @return The accessible method\n+     */\n+    public static Method getMatchingAccessibleMethod(Class<?> cls,\n+            String methodName, Class<?>[] parameterTypes) {\n+        try {\n+            Method method = cls.getMethod(methodName, parameterTypes);\n+            MemberUtils.setAccessibleWorkaround(method);\n+            return method;\n+        } catch (NoSuchMethodException e) { /* SWALLOW */\n+        }\n+        // search through all methods\n+        Method bestMatch = null;\n+        Method[] methods = cls.getMethods();\n+        for (int i = 0, size = methods.length; i < size; i++) {\n+            if (methods[i].getName().equals(methodName)) {\n+                // compare parameters\n+                if (ClassUtils.isAssignable(parameterTypes, methods[i]\n+                        .getParameterTypes(), true)) {\n+                    // get accessible version of method\n+                    Method accessibleMethod = getAccessibleMethod(methods[i]);\n+                    if (accessibleMethod != null) {\n+                        if (bestMatch == null\n+                                || MemberUtils.compareParameterTypes(\n+                                        accessibleMethod.getParameterTypes(),\n+                                        bestMatch.getParameterTypes(),\n+                                        parameterTypes) < 0) {\n+                            bestMatch = accessibleMethod;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if (bestMatch != null) {\n+            MemberUtils.setAccessibleWorkaround(bestMatch);\n+        }\n+        return bestMatch;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/reflect/TypeUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+\n+import org.apache.commons.lang.Validate;\n+\n+/**\n+ * <p>Utility methods focusing on type inspection, particularly with regard to\n+ * generics.</p>\n+ * @author James Carman\n+ * @author Matt Benson\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TypeUtils {\n+\n+    /**\n+     * Get the raw type of a Java type, given its context. Primarily for use\n+     * with {@link TypeVariable}s and {@link GenericArrayType}s, or when you do\n+     * not know the runtime type of <code>type</code>: if you know you have a\n+     * {@link Class} instance, it is already raw; if you know you have a\n+     * {@link ParameterizedType}, its raw type is only a method call away.\n+     * @param enclosingType context\n+     * @param type to read\n+     * @return Class<?>\n+     */\n+    // original code stolen from commons [proxy]'s 2.0 branch, then kneaded until firm\n+    public static Class<?> getRawType(Type enclosingType, Type type) {\n+        if (type instanceof Class<?>) {\n+            // it is raw, no problem\n+            return (Class<?>) type;\n+        }\n+        if (type instanceof ParameterizedType) {\n+            // simple enough to get the raw type of a ParameterizedType\n+            return (Class<?>) ((ParameterizedType) type).getRawType();\n+        }\n+        if (type instanceof TypeVariable<?>) {\n+            Validate.notNull(enclosingType,\n+                    \"Cannot get raw type of TypeVariable without enclosing type\");\n+            // resolve the variable against the enclosing type, hope for the best (casting)\n+            return (Class<?>) resolveVariable(enclosingType, (TypeVariable<?>) type);\n+        }\n+        if (type instanceof GenericArrayType) {\n+            Validate.notNull(enclosingType,\n+                    \"Cannot get raw type of GenericArrayType without enclosing type\");\n+            // not included in original code, but not too difficult:  just have to get raw component type...\n+            Class<?> rawComponentType = getRawType(enclosingType, ((GenericArrayType) type)\n+                    .getGenericComponentType());\n+            // ...and know how to reflectively create array types, uncommon but not unheard of:\n+            return Array.newInstance(rawComponentType, 0).getClass();\n+        }\n+        throw new IllegalArgumentException(String.valueOf(type));\n+    }\n+\n+    /**\n+     * We plan to return Class<?> from the top-level call, as evidenced by the\n+     * cast in the above method, but to handle recursion and falling back up the\n+     * graph, as it were, return Type\n+     * @param enclosingType\n+     * @param typeVar\n+     * @return Type resolved\n+     */\n+    // original code stolen from commons [proxy]'s 2.0 branch, then kneaded until firm\n+    private static Type resolveVariable(Type enclosingType, TypeVariable<?> typeVar) {\n+        if (enclosingType instanceof ParameterizedType) {\n+            ParameterizedType parameterizedEnclosingType = (ParameterizedType) enclosingType;\n+            TypeVariable<?>[] typeVariables = getRawType(null,\n+                    parameterizedEnclosingType.getRawType()).getTypeParameters();\n+            //look for the matching variable:\n+            for (int i = 0; i < typeVariables.length; i++) {\n+                if (typeVariables[i].equals(typeVar)) {\n+                    return parameterizedEnclosingType.getActualTypeArguments()[i];\n+                }\n+            }\n+            //otherwise recurse to try against raw class\n+            Type result = resolveVariable(parameterizedEnclosingType.getRawType(), typeVar);\n+            //unroll variable if returned\n+            if (result instanceof TypeVariable<?>) {\n+                return resolveVariable(enclosingType, (TypeVariable<?>) result);\n+            }\n+            return result;\n+        }\n+        if (enclosingType instanceof Class<?>) {\n+            Class<?> enclosingClass = (Class<?>) enclosingType;\n+            Type result = null;\n+            Type genericSuperclass = enclosingClass.getGenericSuperclass();\n+            if (genericSuperclass != null && !Object.class.equals(genericSuperclass)) {\n+                result = resolveVariable(genericSuperclass, typeVar);\n+            }\n+            if (result == null) {\n+                for (Type genericInterface : enclosingClass.getGenericInterfaces()) {\n+                    result = resolveVariable(genericInterface, typeVar);\n+                    if (result != null) {\n+                        break;\n+                    }\n+                }\n+            }\n+            if (result != null) {\n+                return result;\n+            }\n+        }\n+        throw new IllegalArgumentException(String.valueOf(typeVar));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/text/CompositeFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+\n+/**\n+ * Formats using one formatter and parses using a different formatter. An\n+ * example of use for this would be a webapp where data is taken in one way and\n+ * stored in a database another way.\n+ * \n+ * @author Apache Software Foundation\n+ * @author Archimedes Trajano\n+ * @version $Id$\n+ */\n+public class CompositeFormat extends Format {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = -4329119827877627683L;\n+\n+    /** The parser to use. */\n+    private final Format parser;\n+    /** The formatter to use. */\n+    private final Format formatter;\n+\n+    /**\n+     * Create a format that points its parseObject method to one implementation\n+     * and its format method to another.\n+     * \n+     * @param parser implementation\n+     * @param formatter implementation\n+     */\n+    public CompositeFormat(Format parser, Format formatter) {\n+        this.parser = parser;\n+        this.formatter = formatter;\n+    }\n+\n+    /**\n+     * Uses the formatter Format instance.\n+     * \n+     * @param obj the object to format\n+     * @param toAppendTo the {@link StringBuffer} to append to\n+     * @param pos the FieldPosition to use (or ignore).\n+     * @return <code>toAppendTo</code>\n+     * @see Format#format(Object, StringBuffer, FieldPosition)\n+     */\n+    @Override\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+            FieldPosition pos) {\n+        return formatter.format(obj, toAppendTo, pos);\n+    }\n+\n+    /**\n+     * Uses the parser Format instance.\n+     * \n+     * @param source the String source\n+     * @param pos the ParsePosition containing the position to parse from, will\n+     *            be updated according to parsing success (index) or failure\n+     *            (error index)\n+     * @return the parsed Object\n+     * @see Format#parseObject(String, ParsePosition)\n+     */\n+    @Override\n+    public Object parseObject(String source, ParsePosition pos) {\n+        return parser.parseObject(source, pos);\n+    }\n+\n+    /**\n+     * Provides access to the parser Format implementation.\n+     * \n+     * @return parser Format implementation\n+     */\n+    public Format getParser() {\n+        return this.parser;\n+    }\n+\n+    /**\n+     * Provides access to the parser Format implementation.\n+     * \n+     * @return formatter Format implementation\n+     */\n+    public Format getFormatter() {\n+        return this.formatter;\n+    }\n+\n+    /**\n+     * Utility method to parse and then reformat a String.\n+     * \n+     * @param input String to reformat\n+     * @return A reformatted String\n+     * @throws ParseException thrown by parseObject(String) call\n+     */\n+    public String reformat(String input) throws ParseException {\n+        return format(parseObject(input));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.text.Format;\n+import java.text.MessageFormat;\n+import java.text.ParsePosition;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.Validate;\n+\n+/**\n+ * Extends <code>java.text.MessageFormat</code> to allow pluggable/additional formatting\n+ * options for embedded format elements.  Client code should specify a registry\n+ * of <code>FormatFactory</code> instances associated with <code>String</code>\n+ * format names.  This registry will be consulted when the format elements are \n+ * parsed from the message pattern.  In this way custom patterns can be specified,\n+ * and the formats supported by <code>java.text.MessageFormat</code> can be overridden\n+ * at the format and/or format style level (see MessageFormat).  A \"format element\"\n+ * embedded in the message pattern is specified (<b>()?</b> signifies optionality):<br />\n+ * <code>{</code><i>argument-number</i><b>(</b><code>,</code><i>format-name</i><b>(</b><code>,</code><i>format-style</i><b>)?)?</b><code>}</code>\n+ *\n+ * <p>\n+ * <i>format-name</i> and <i>format-style</i> values are trimmed of surrounding whitespace\n+ * in the manner of <code>java.text.MessageFormat</code>.  If <i>format-name</i> denotes\n+ * <code>FormatFactory formatFactoryInstance</code> in <code>registry</code>, a <code>Format</code>\n+ * matching <i>format-name</i> and <i>format-style</i> is requested from\n+ * <code>formatFactoryInstance</code>.  If this is successful, the <code>Format</code>\n+ * found is used for this format element.\n+ * </p>\n+ *\n+ * <p>NOTICE: The various subformat mutator methods are considered unnecessary; they exist on the parent\n+ * class to allow the type of customization which it is the job of this class to provide in\n+ * a configurable fashion.  These methods have thus been disabled and will throw\n+ * <code>UnsupportedOperationException</code> if called.\n+ * </p>\n+ * \n+ * <p>Limitations inherited from <code>java.text.MessageFormat</code>:\n+ * <ul>\n+ * <li>When using \"choice\" subformats, support for nested formatting instructions is limited\n+ *     to that provided by the base class.</li>\n+ * <li>Thread-safety of <code>Format</code>s, including <code>MessageFormat</code> and thus\n+ *     <code>ExtendedMessageFormat</code>, is not guaranteed.</li>\n+ * </ul>\n+ * </p>\n+ * \n+ * @author Apache Software Foundation\n+ * @author Matt Benson\n+ * @author Niall Pemberton\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+public class ExtendedMessageFormat extends MessageFormat {\n+    private static final long serialVersionUID = -2362048321261811743L;\n+\n+    private static final String DUMMY_PATTERN = \"\";\n+    private static final String ESCAPED_QUOTE = \"''\";\n+    private static final char START_FMT = ',';\n+    private static final char END_FE = '}';\n+    private static final char START_FE = '{';\n+    private static final char QUOTE = '\\'';\n+\n+    private String toPattern;\n+    private final Map<String, ? extends FormatFactory> registry;\n+\n+    /**\n+     * Create a new ExtendedMessageFormat for the default locale.\n+     * \n+     * @param pattern  the pattern to use, not null\n+     * @throws IllegalArgumentException in case of a bad pattern.\n+     */\n+    public ExtendedMessageFormat(String pattern) {\n+        this(pattern, Locale.getDefault());\n+    }\n+\n+    /**\n+     * Create a new ExtendedMessageFormat.\n+     * \n+     * @param pattern  the pattern to use, not null\n+     * @param locale  the locale to use, not null\n+     * @throws IllegalArgumentException in case of a bad pattern.\n+     */\n+    public ExtendedMessageFormat(String pattern, Locale locale) {\n+        this(pattern, locale, null);\n+    }\n+\n+    /**\n+     * Create a new ExtendedMessageFormat for the default locale.\n+     * \n+     * @param pattern  the pattern to use, not null\n+     * @param registry  the registry of format factories, may be null\n+     * @throws IllegalArgumentException in case of a bad pattern.\n+     */\n+    public ExtendedMessageFormat(String pattern, Map<String, ? extends FormatFactory> registry) {\n+        this(pattern, Locale.getDefault(), registry);\n+    }\n+\n+    /**\n+     * Create a new ExtendedMessageFormat.\n+     * \n+     * @param pattern  the pattern to use, not null\n+     * @param locale  the locale to use, not null\n+     * @param registry  the registry of format factories, may be null\n+     * @throws IllegalArgumentException in case of a bad pattern.\n+     */\n+    public ExtendedMessageFormat(String pattern, Locale locale, Map<String, ? extends FormatFactory> registry) {\n+        super(DUMMY_PATTERN);\n+        setLocale(locale);\n+        this.registry = registry;\n+        applyPattern(pattern);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String toPattern() {\n+        return toPattern;\n+    }\n+\n+    /**\n+     * Apply the specified pattern.\n+     * \n+     * @param pattern String\n+     */\n+    @Override\n+    public final void applyPattern(String pattern) {\n+        if (registry == null) {\n+            super.applyPattern(pattern);\n+            toPattern = super.toPattern();\n+            return;\n+        }\n+        ArrayList<Format> foundFormats = new ArrayList<Format>();\n+        ArrayList<String> foundDescriptions = new ArrayList<String>();\n+        StringBuilder stripCustom = new StringBuilder(pattern.length());\n+\n+        ParsePosition pos = new ParsePosition(0);\n+        char[] c = pattern.toCharArray();\n+        int fmtCount = 0;\n+        while (pos.getIndex() < pattern.length()) {\n+            switch (c[pos.getIndex()]) {\n+            case QUOTE:\n+                appendQuotedString(pattern, pos, stripCustom, true);\n+                break;\n+            case START_FE:\n+                fmtCount++;\n+                seekNonWs(pattern, pos);\n+                int start = pos.getIndex();\n+                int index = readArgumentIndex(pattern, next(pos));\n+                stripCustom.append(START_FE).append(index);\n+                seekNonWs(pattern, pos);\n+                Format format = null;\n+                String formatDescription = null;\n+                if (c[pos.getIndex()] == START_FMT) {\n+                    formatDescription = parseFormatDescription(pattern,\n+                            next(pos));\n+                    format = getFormat(formatDescription);\n+                    if (format == null) {\n+                        stripCustom.append(START_FMT).append(formatDescription);\n+                    }\n+                }\n+                foundFormats.add(format);\n+                foundDescriptions.add(format == null ? null : formatDescription);\n+                Validate.isTrue(foundFormats.size() == fmtCount);\n+                Validate.isTrue(foundDescriptions.size() == fmtCount);\n+                if (c[pos.getIndex()] != END_FE) {\n+                    throw new IllegalArgumentException(\n+                            \"Unreadable format element at position \" + start);\n+                }\n+                //$FALL-THROUGH$\n+            default:\n+                stripCustom.append(c[pos.getIndex()]);\n+                next(pos);\n+            }\n+        }\n+        super.applyPattern(stripCustom.toString());\n+        toPattern = insertFormats(super.toPattern(), foundDescriptions);\n+        if (containsElements(foundFormats)) {\n+            Format[] origFormats = getFormats();\n+            // only loop over what we know we have, as MessageFormat on Java 1.3 \n+            // seems to provide an extra format element:\n+            int i = 0;\n+            for (Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) {\n+                Format f = it.next();\n+                if (f != null) {\n+                    origFormats[i] = f;\n+                }\n+            }\n+            super.setFormats(origFormats);\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @throws UnsupportedOperationException\n+     */\n+    @Override\n+    public void setFormat(int formatElementIndex, Format newFormat) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @throws UnsupportedOperationException\n+     */\n+    @Override\n+    public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @throws UnsupportedOperationException\n+     */\n+    @Override\n+    public void setFormats(Format[] newFormats) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @throws UnsupportedOperationException\n+     */\n+    @Override\n+    public void setFormatsByArgumentIndex(Format[] newFormats) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Get a custom format from a format description.\n+     * \n+     * @param desc String\n+     * @return Format\n+     */\n+    private Format getFormat(String desc) {\n+        if (registry != null) {\n+            String name = desc;\n+            String args = null;\n+            int i = desc.indexOf(START_FMT);\n+            if (i > 0) {\n+                name = desc.substring(0, i).trim();\n+                args = desc.substring(i + 1).trim();\n+            }\n+            FormatFactory factory = registry.get(name);\n+            if (factory != null) {\n+                return factory.getFormat(name, args, getLocale());\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Read the argument index from the current format element\n+     * \n+     * @param pattern pattern to parse\n+     * @param pos current parse position\n+     * @return argument index\n+     */\n+    private int readArgumentIndex(String pattern, ParsePosition pos) {\n+        int start = pos.getIndex();\n+        seekNonWs(pattern, pos);\n+        StringBuffer result = new StringBuffer();\n+        boolean error = false;\n+        for (; !error && pos.getIndex() < pattern.length(); next(pos)) {\n+            char c = pattern.charAt(pos.getIndex());\n+            if (Character.isWhitespace(c)) {\n+                seekNonWs(pattern, pos);\n+                c = pattern.charAt(pos.getIndex());\n+                if (c != START_FMT && c != END_FE) {\n+                    error = true;\n+                    continue;\n+                }\n+            }\n+            if ((c == START_FMT || c == END_FE) && result.length() > 0) {\n+                try {\n+                    return Integer.parseInt(result.toString());\n+                } catch (NumberFormatException e) {\n+                    // we've already ensured only digits, so unless something\n+                    // outlandishly large was specified we should be okay.\n+                }\n+            }\n+            error = !Character.isDigit(c);\n+            result.append(c);\n+        }\n+        if (error) {\n+            throw new IllegalArgumentException(\n+                    \"Invalid format argument index at position \" + start + \": \"\n+                            + pattern.substring(start, pos.getIndex()));\n+        }\n+        throw new IllegalArgumentException(\n+                \"Unterminated format element at position \" + start);\n+    }\n+\n+    /**\n+     * Parse the format component of a format element.\n+     * \n+     * @param pattern string to parse\n+     * @param pos current parse position\n+     * @return Format description String\n+     */\n+    private String parseFormatDescription(String pattern, ParsePosition pos) {\n+        int start = pos.getIndex();\n+        seekNonWs(pattern, pos);\n+        int text = pos.getIndex();\n+        int depth = 1;\n+        for (; pos.getIndex() < pattern.length(); next(pos)) {\n+            switch (pattern.charAt(pos.getIndex())) {\n+            case START_FE:\n+                depth++;\n+                break;\n+            case END_FE:\n+                depth--;\n+                if (depth == 0) {\n+                    return pattern.substring(text, pos.getIndex());\n+                }\n+                break;\n+            case QUOTE:\n+                getQuotedString(pattern, pos, false);\n+                break;\n+            }\n+        }\n+        throw new IllegalArgumentException(\n+                \"Unterminated format element at position \" + start);\n+    }\n+\n+    /**\n+     * Insert formats back into the pattern for toPattern() support.\n+     *\n+     * @param pattern source\n+     * @param customPatterns The custom patterns to re-insert, if any\n+     * @return full pattern\n+     */\n+    private String insertFormats(String pattern, ArrayList<String> customPatterns) {\n+        if (!containsElements(customPatterns)) {\n+            return pattern;\n+        }\n+        StringBuilder sb = new StringBuilder(pattern.length() * 2);\n+        ParsePosition pos = new ParsePosition(0);\n+        int fe = -1;\n+        int depth = 0;\n+        while (pos.getIndex() < pattern.length()) {\n+            char c = pattern.charAt(pos.getIndex());\n+            switch (c) {\n+            case QUOTE:\n+                appendQuotedString(pattern, pos, sb, false);\n+                break;\n+            case START_FE:\n+                depth++;\n+                if (depth == 1) {\n+                    fe++;\n+                    sb.append(START_FE).append(\n+                            readArgumentIndex(pattern, next(pos)));\n+                    String customPattern = customPatterns.get(fe);\n+                    if (customPattern != null) {\n+                        sb.append(START_FMT).append(customPattern);\n+                    }\n+                }\n+                break;\n+            case END_FE:\n+                depth--;\n+                //$FALL-THROUGH$\n+            default:\n+                sb.append(c);\n+                next(pos);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Consume whitespace from the current parse position.\n+     * \n+     * @param pattern String to read\n+     * @param pos current position\n+     */\n+    private void seekNonWs(String pattern, ParsePosition pos) {\n+        int len = 0;\n+        char[] buffer = pattern.toCharArray();\n+        do {\n+            len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n+            pos.setIndex(pos.getIndex() + len);\n+        } while (len > 0 && pos.getIndex() < pattern.length());\n+    }\n+\n+    /**\n+     * Convenience method to advance parse position by 1\n+     * \n+     * @param pos ParsePosition\n+     * @return <code>pos</code>\n+     */\n+    private ParsePosition next(ParsePosition pos) {\n+        pos.setIndex(pos.getIndex() + 1);\n+        return pos;\n+    }\n+\n+    /**\n+     * Consume a quoted string, adding it to <code>appendTo</code> if\n+     * specified.\n+     * \n+     * @param pattern pattern to parse\n+     * @param pos current parse position\n+     * @param appendTo optional StringBuffer to append\n+     * @param escapingOn whether to process escaped quotes\n+     * @return <code>appendTo</code>\n+     */\n+    private StringBuilder appendQuotedString(String pattern, ParsePosition pos,\n+            StringBuilder appendTo, boolean escapingOn) {\n+        int start = pos.getIndex();\n+        char[] c = pattern.toCharArray();\n+        if (escapingOn && c[start] == QUOTE) {\n+            next(pos);\n+            return appendTo == null ? null : appendTo.append(QUOTE);\n+        }\n+        int lastHold = start;\n+        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n+            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n+                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n+                        QUOTE);\n+                pos.setIndex(i + ESCAPED_QUOTE.length());\n+                lastHold = pos.getIndex();\n+                continue;\n+            }\n+            switch (c[pos.getIndex()]) {\n+            case QUOTE:\n+                next(pos);\n+                return appendTo == null ? null : appendTo.append(c, lastHold,\n+                        pos.getIndex() - lastHold);\n+            default:\n+                next(pos);\n+            }\n+        }\n+        throw new IllegalArgumentException(\n+                \"Unterminated quoted string at position \" + start);\n+    }\n+\n+    /**\n+     * Consume quoted string only\n+     * \n+     * @param pattern pattern to parse\n+     * @param pos current parse position\n+     * @param escapingOn whether to process escaped quotes\n+     */\n+    private void getQuotedString(String pattern, ParsePosition pos,\n+            boolean escapingOn) {\n+        appendQuotedString(pattern, pos, null, escapingOn);\n+    }\n+\n+    /**\n+     * Learn whether the specified Collection contains non-null elements.\n+     * @param coll to check\n+     * @return <code>true</code> if some Object was found, <code>false</code> otherwise.\n+     */\n+    private boolean containsElements(Collection<?> coll) {\n+        if (coll == null || coll.size() == 0) {\n+            return false;\n+        }\n+        for (Iterator<?> iter = coll.iterator(); iter.hasNext();) {\n+            if (iter.next() != null) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/text/FormatFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.text.Format;\n+import java.util.Locale;\n+\n+/**\n+ * Format factory.\n+ * \n+ * @author Apache Software Foundation\n+ * @author Niall Pemberton\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+public interface FormatFactory {\n+\n+    /**\n+     * Create or retrieve a format instance.\n+     *\n+     * @param name The format type name\n+     * @param arguments Arguments used to create the format instance. This allows the\n+     *                  <code>FormatFactory</code> to implement the \"format style\"\n+     *                  concept from <code>java.text.MessageFormat</code>.\n+     * @param locale The locale, may be null\n+     * @return The format instance\n+     */\n+    Format getFormat(String name, String arguments, Locale locale);\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/text/StrBuilder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.SystemUtils;\n+\n+/**\n+ * Builds a string from constituent parts providing a more flexible and powerful API\n+ * than StringBuffer.\n+ * <p>\n+ * The main differences from StringBuffer/StringBuilder are:\n+ * <ul>\n+ * <li>Not synchronized</li>\n+ * <li>Not final</li>\n+ * <li>Subclasses have direct access to character array</li>\n+ * <li>Additional methods\n+ *  <ul>\n+ *   <li>appendWithSeparators - adds an array of values, with a separator</li>\n+ *   <li>appendPadding - adds a length padding characters</li>\n+ *   <li>appendFixedLength - adds a fixed width field to the builder</li>\n+ *   <li>toCharArray/getChars - simpler ways to get a range of the character array</li>\n+ *   <li>delete - delete char or string</li>\n+ *   <li>replace - search and replace for a char or string</li>\n+ *   <li>leftString/rightString/midString - substring without exceptions</li>\n+ *   <li>contains - whether the builder contains a char or string</li>\n+ *   <li>size/clear/isEmpty - collections style API methods</li>\n+ *  </ul>\n+ * </li>\n+ * </ul>\n+ * <li>Views\n+ *  <ul>\n+ *   <li>asTokenizer - uses the internal buffer as the source of a StrTokenizer</li>\n+ *   <li>asReader - uses the internal buffer as the source of a Reader</li>\n+ *   <li>asWriter - allows a Writer to write directly to the internal buffer</li>\n+ *  </ul>\n+ * </li>\n+ * </ul>\n+ * <p>\n+ * The aim has been to provide an API that mimics very closely what StringBuffer\n+ * provides, but with additional methods. It should be noted that some edge cases,\n+ * with invalid indices or null input, have been altered - see individual methods.\n+ * The biggest of these changes is that by default, null will not output the text\n+ * 'null'. This can be controlled by a property, {@link #setNullText(String)}.\n+ * <p>\n+ * Prior to 3.0, this class implemented Cloneable but did not implement the \n+ * clone method so could not be used. From 3.0 onwards it no longer implements \n+ * the interface. \n+ *\n+ * @author Apache Software Foundation\n+ * @author Robert Scholte\n+ * @since 2.2\n+ * @version $Id$\n+ */\n+public class StrBuilder implements CharSequence, Appendable {\n+\n+    /**\n+     * The extra capacity for new builders.\n+     */\n+    static final int CAPACITY = 32;\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 7628716375283629643L;\n+\n+    /** Internal data storage. */\n+    protected char[] buffer; // TODO make private?\n+    /** Current size of the buffer. */\n+    protected int size; // TODO make private?\n+    /** The new line. */\n+    private String newLine;\n+    /** The null text. */\n+    private String nullText;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that creates an empty builder initial capacity 32 characters.\n+     */\n+    public StrBuilder() {\n+        this(CAPACITY);\n+    }\n+\n+    /**\n+     * Constructor that creates an empty builder the specified initial capacity.\n+     *\n+     * @param initialCapacity  the initial capacity, zero or less will be converted to 32\n+     */\n+    public StrBuilder(int initialCapacity) {\n+        super();\n+        if (initialCapacity <= 0) {\n+            initialCapacity = CAPACITY;\n+        }\n+        buffer = new char[initialCapacity];\n+    }\n+\n+    /**\n+     * Constructor that creates a builder from the string, allocating\n+     * 32 extra characters for growth.\n+     *\n+     * @param str  the string to copy, null treated as blank string\n+     */\n+    public StrBuilder(String str) {\n+        super();\n+        if (str == null) {\n+            buffer = new char[CAPACITY];\n+        } else {\n+            buffer = new char[str.length() + CAPACITY];\n+            append(str);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the text to be appended when a new line is added.\n+     *\n+     * @return the new line text, null means use system default\n+     */\n+    public String getNewLineText() {\n+        return newLine;\n+    }\n+\n+    /**\n+     * Sets the text to be appended when a new line is added.\n+     *\n+     * @param newLine  the new line text, null means use system default\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder setNewLineText(String newLine) {\n+        this.newLine = newLine;\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the text to be appended when null is added.\n+     *\n+     * @return the null text, null means no append\n+     */\n+    public String getNullText() {\n+        return nullText;\n+    }\n+\n+    /**\n+     * Sets the text to be appended when null is added.\n+     *\n+     * @param nullText  the null text, null means no append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder setNullText(String nullText) {\n+        if (nullText != null && nullText.length() == 0) {\n+            nullText = null;\n+        }\n+        this.nullText = nullText;\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the length of the string builder.\n+     *\n+     * @return the length\n+     */\n+    public int length() {\n+        return size;\n+    }\n+\n+    /**\n+     * Updates the length of the builder by either dropping the last characters\n+     * or adding filler of unicode zero.\n+     *\n+     * @param length  the length to set to, must be zero or positive\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the length is negative\n+     */\n+    public StrBuilder setLength(int length) {\n+        if (length < 0) {\n+            throw new StringIndexOutOfBoundsException(length);\n+        }\n+        if (length < size) {\n+            size = length;\n+        } else if (length > size) {\n+            ensureCapacity(length);\n+            int oldEnd = size;\n+            int newEnd = length;\n+            size = length;\n+            for (int i = oldEnd; i < newEnd; i++) {\n+                buffer[i] = '\\0';\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the current size of the internal character array buffer.\n+     *\n+     * @return the capacity\n+     */\n+    public int capacity() {\n+        return buffer.length;\n+    }\n+\n+    /**\n+     * Checks the capacity and ensures that it is at least the size specified.\n+     *\n+     * @param capacity  the capacity to ensure\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder ensureCapacity(int capacity) {\n+        if (capacity > buffer.length) {\n+            char[] old = buffer;\n+            buffer = new char[capacity * 2];\n+            System.arraycopy(old, 0, buffer, 0, size);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Minimizes the capacity to the actual length of the string.\n+     *\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder minimizeCapacity() {\n+        if (buffer.length > length()) {\n+            char[] old = buffer;\n+            buffer = new char[length()];\n+            System.arraycopy(old, 0, buffer, 0, size);\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the length of the string builder.\n+     * <p>\n+     * This method is the same as {@link #length()} and is provided to match the\n+     * API of Collections.\n+     *\n+     * @return the length\n+     */\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Checks is the string builder is empty (convenience Collections API style method).\n+     * <p>\n+     * This method is the same as checking {@link #length()} and is provided to match the\n+     * API of Collections.\n+     *\n+     * @return <code>true</code> if the size is <code>0</code>.\n+     */\n+    public boolean isEmpty() {\n+        return size == 0;\n+    }\n+\n+    /**\n+     * Clears the string builder (convenience Collections API style method).\n+     * <p>\n+     * This method does not reduce the size of the internal character buffer.\n+     * To do that, call <code>clear()</code> followed by {@link #minimizeCapacity()}.\n+     * <p>\n+     * This method is the same as {@link #setLength(int)} called with zero\n+     * and is provided to match the API of Collections.\n+     *\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder clear() {\n+        size = 0;\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the character at the specified index.\n+     *\n+     * @see #setCharAt(int, char)\n+     * @see #deleteCharAt(int)\n+     * @param index  the index to retrieve, must be valid\n+     * @return the character at the index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public char charAt(int index) {\n+        if (index < 0 || index >= length()) {\n+            throw new StringIndexOutOfBoundsException(index);\n+        }\n+        return buffer[index];\n+    }\n+\n+    /**\n+     * Sets the character at the specified index.\n+     *\n+     * @see #charAt(int)\n+     * @see #deleteCharAt(int)\n+     * @param index  the index to set\n+     * @param ch  the new character\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder setCharAt(int index, char ch) {\n+        if (index < 0 || index >= length()) {\n+            throw new StringIndexOutOfBoundsException(index);\n+        }\n+        buffer[index] = ch;\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the character at the specified index.\n+     *\n+     * @see #charAt(int)\n+     * @see #setCharAt(int, char)\n+     * @param index  the index to delete\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder deleteCharAt(int index) {\n+        if (index < 0 || index >= size) {\n+            throw new StringIndexOutOfBoundsException(index);\n+        }\n+        deleteImpl(index, index + 1, 1);\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Copies the builder's character array into a new character array.\n+     * \n+     * @return a new array that represents the contents of the builder\n+     */\n+    public char[] toCharArray() {\n+        if (size == 0) {\n+            return ArrayUtils.EMPTY_CHAR_ARRAY;\n+        }\n+        char chars[] = new char[size];\n+        System.arraycopy(buffer, 0, chars, 0, size);\n+        return chars;\n+    }\n+\n+    /**\n+     * Copies part of the builder's character array into a new character array.\n+     * \n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except that\n+     *  if too large it is treated as end of string\n+     * @return a new array that holds part of the contents of the builder\n+     * @throws IndexOutOfBoundsException if startIndex is invalid,\n+     *  or if endIndex is invalid (but endIndex greater than size is valid)\n+     */\n+    public char[] toCharArray(int startIndex, int endIndex) {\n+        endIndex = validateRange(startIndex, endIndex);\n+        int len = endIndex - startIndex;\n+        if (len == 0) {\n+            return ArrayUtils.EMPTY_CHAR_ARRAY;\n+        }\n+        char chars[] = new char[len];\n+        System.arraycopy(buffer, startIndex, chars, 0, len);\n+        return chars;\n+    }\n+\n+    /**\n+     * Copies the character array into the specified array.\n+     * \n+     * @param destination  the destination array, null will cause an array to be created\n+     * @return the input array, unless that was null or too small\n+     */\n+    public char[] getChars(char[] destination) {\n+        int len = length();\n+        if (destination == null || destination.length < len) {\n+            destination = new char[len];\n+        }\n+        System.arraycopy(buffer, 0, destination, 0, len);\n+        return destination;\n+    }\n+\n+    /**\n+     * Copies the character array into the specified array.\n+     *\n+     * @param startIndex  first index to copy, inclusive, must be valid\n+     * @param endIndex  last index, exclusive, must be valid\n+     * @param destination  the destination array, must not be null or too small\n+     * @param destinationIndex  the index to start copying in destination\n+     * @throws NullPointerException if the array is null\n+     * @throws IndexOutOfBoundsException if any index is invalid\n+     */\n+    public void getChars(int startIndex, int endIndex, char destination[], int destinationIndex) {\n+        if (startIndex < 0) {\n+            throw new StringIndexOutOfBoundsException(startIndex);\n+        }\n+        if (endIndex < 0 || endIndex > length()) {\n+            throw new StringIndexOutOfBoundsException(endIndex);\n+        }\n+        if (startIndex > endIndex) {\n+            throw new StringIndexOutOfBoundsException(\"end < start\");\n+        }\n+        System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends the new line string to this string builder.\n+     * <p>\n+     * The new line string can be altered using {@link #setNewLineText(String)}.\n+     * This might be used to force the output to always use Unix line endings\n+     * even when on Windows.\n+     *\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendNewLine() {\n+        if (newLine == null)  {\n+            append(SystemUtils.LINE_SEPARATOR);\n+            return this;\n+        }\n+        return append(newLine);\n+    }\n+\n+    /**\n+     * Appends the text representing <code>null</code> to this string builder.\n+     *\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendNull() {\n+        if (nullText == null)  {\n+            return this;\n+        }\n+        return append(nullText);\n+    }\n+\n+    /**\n+     * Appends an object to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param obj  the object to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(Object obj) {\n+        if (obj == null) {\n+            return appendNull();\n+        } \n+        return append(obj.toString());        \n+    }\n+\n+    /**\n+     * Appends a CharSequence to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param seq  the CharSequence to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(CharSequence seq) {\n+        if (seq == null) {\n+            return appendNull();\n+        } \n+        return append(seq.toString());        \n+    }\n+\n+    /**\n+     * Appends part of a CharSequence to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param seq  the CharSequence to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(CharSequence seq, int startIndex, int length) {\n+        if (seq == null) {\n+            return appendNull();\n+        } \n+        return append(seq.toString(), startIndex, length);\n+    }\n+\n+    /**\n+     * Appends a string to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(String str) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        int strLen = str.length();\n+        if (strLen > 0) {\n+            int len = length();\n+            ensureCapacity(len + strLen);\n+            str.getChars(0, strLen, buffer, len);\n+            size += strLen;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends part of a string to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(String str, int startIndex, int length) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        if (startIndex < 0 || startIndex > str.length()) {\n+            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n+        }\n+        if (length < 0 || (startIndex + length) > str.length()) {\n+            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n+        }\n+        if (length > 0) {\n+            int len = length();\n+            ensureCapacity(len + length);\n+            str.getChars(startIndex, startIndex + length, buffer, len);\n+            size += length;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a string buffer to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string buffer to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(StringBuffer str) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        int strLen = str.length();\n+        if (strLen > 0) {\n+            int len = length();\n+            ensureCapacity(len + strLen);\n+            str.getChars(0, strLen, buffer, len);\n+            size += strLen;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends part of a string buffer to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(StringBuffer str, int startIndex, int length) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        if (startIndex < 0 || startIndex > str.length()) {\n+            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n+        }\n+        if (length < 0 || (startIndex + length) > str.length()) {\n+            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n+        }\n+        if (length > 0) {\n+            int len = length();\n+            ensureCapacity(len + length);\n+            str.getChars(startIndex, startIndex + length, buffer, len);\n+            size += length;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends another string builder to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string builder to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(StrBuilder str) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        int strLen = str.length();\n+        if (strLen > 0) {\n+            int len = length();\n+            ensureCapacity(len + strLen);\n+            System.arraycopy(str.buffer, 0, buffer, len, strLen);\n+            size += strLen;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends part of a string builder to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(StrBuilder str, int startIndex, int length) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        if (startIndex < 0 || startIndex > str.length()) {\n+            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n+        }\n+        if (length < 0 || (startIndex + length) > str.length()) {\n+            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n+        }\n+        if (length > 0) {\n+            int len = length();\n+            ensureCapacity(len + length);\n+            str.getChars(startIndex, startIndex + length, buffer, len);\n+            size += length;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a char array to the string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param chars  the char array to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(char[] chars) {\n+        if (chars == null) {\n+            return appendNull();\n+        }\n+        int strLen = chars.length;\n+        if (strLen > 0) {\n+            int len = length();\n+            ensureCapacity(len + strLen);\n+            System.arraycopy(chars, 0, buffer, len, strLen);\n+            size += strLen;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a char array to the string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param chars  the char array to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(char[] chars, int startIndex, int length) {\n+        if (chars == null) {\n+            return appendNull();\n+        }\n+        if (startIndex < 0 || startIndex > chars.length) {\n+            throw new StringIndexOutOfBoundsException(\"Invalid startIndex: \" + length);\n+        }\n+        if (length < 0 || (startIndex + length) > chars.length) {\n+            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n+        }\n+        if (length > 0) {\n+            int len = length();\n+            ensureCapacity(len + length);\n+            System.arraycopy(chars, startIndex, buffer, len, length);\n+            size += length;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a boolean value to the string builder.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(boolean value) {\n+        if (value) {\n+            ensureCapacity(size + 4);\n+            buffer[size++] = 't';\n+            buffer[size++] = 'r';\n+            buffer[size++] = 'u';\n+            buffer[size++] = 'e';\n+        } else {\n+            ensureCapacity(size + 5);\n+            buffer[size++] = 'f';\n+            buffer[size++] = 'a';\n+            buffer[size++] = 'l';\n+            buffer[size++] = 's';\n+            buffer[size++] = 'e';\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a char value to the string builder.\n+     *\n+     * @param ch  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(char ch) {\n+        int len = length();\n+        ensureCapacity(len + 1);\n+        buffer[size++] = ch;\n+        return this;\n+    }\n+\n+    /**\n+     * Appends an int value to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(int value) {\n+        return append(String.valueOf(value));\n+    }\n+\n+    /**\n+     * Appends a long value to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(long value) {\n+        return append(String.valueOf(value));\n+    }\n+\n+    /**\n+     * Appends a float value to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(float value) {\n+        return append(String.valueOf(value));\n+    }\n+\n+    /**\n+     * Appends a double value to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(double value) {\n+        return append(String.valueOf(value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends an object followed by a new line to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param obj  the object to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(Object obj) {\n+        return append(obj).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends a string followed by a new line to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(String str) {\n+        return append(str).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends part of a string followed by a new line to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(String str, int startIndex, int length) {\n+        return append(str, startIndex, length).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends a string buffer followed by a new line to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string buffer to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(StringBuffer str) {\n+        return append(str).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends part of a string buffer followed by a new line to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(StringBuffer str, int startIndex, int length) {\n+        return append(str, startIndex, length).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends another string builder followed by a new line to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string builder to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(StrBuilder str) {\n+        return append(str).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends part of a string builder followed by a new line to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(StrBuilder str, int startIndex, int length) {\n+        return append(str, startIndex, length).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends a char array followed by a new line to the string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param chars  the char array to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(char[] chars) {\n+        return append(chars).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends a char array followed by a new line to the string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param chars  the char array to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(char[] chars, int startIndex, int length) {\n+        return append(chars, startIndex, length).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends a boolean value followed by a new line to the string builder.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(boolean value) {\n+        return append(value).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends a char value followed by a new line to the string builder.\n+     *\n+     * @param ch  the value to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(char ch) {\n+        return append(ch).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends an int value followed by a new line to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(int value) {\n+        return append(value).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends a long value followed by a new line to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(long value) {\n+        return append(value).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends a float value followed by a new line to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(float value) {\n+        return append(value).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends a double value followed by a new line to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(double value) {\n+        return append(value).appendNewLine();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends each item in an array to the builder without any separators.\n+     * Appending a null array will have no effect.\n+     * Each object is appended using {@link #append(Object)}.\n+     *\n+     * @param array  the array to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendAll(Object[] array) {\n+        if (array != null && array.length > 0) {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends each item in a collection to the builder without any separators.\n+     * Appending a null collection will have no effect.\n+     * Each object is appended using {@link #append(Object)}.\n+     *\n+     * @param coll  the collection to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendAll(Collection<?> coll) {\n+        if (coll != null && coll.size() > 0) {\n+            Iterator<?> it = coll.iterator();\n+            while (it.hasNext()) {\n+                append(it.next());\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends each item in an iterator to the builder without any separators.\n+     * Appending a null iterator will have no effect.\n+     * Each object is appended using {@link #append(Object)}.\n+     *\n+     * @param it  the iterator to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendAll(Iterator<?> it) {\n+        if (it != null) {\n+            while (it.hasNext()) {\n+                append(it.next());\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends an array placing separators between each value, but\n+     * not before the first or after the last.\n+     * Appending a null array will have no effect.\n+     * Each object is appended using {@link #append(Object)}.\n+     *\n+     * @param array  the array to append\n+     * @param separator  the separator to use, null means no separator\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendWithSeparators(Object[] array, String separator) {\n+        if (array != null && array.length > 0) {\n+            separator = (separator == null ? \"\" : separator);\n+            append(array[0]);\n+            for (int i = 1; i < array.length; i++) {\n+                append(separator);\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a collection placing separators between each value, but\n+     * not before the first or after the last.\n+     * Appending a null collection will have no effect.\n+     * Each object is appended using {@link #append(Object)}.\n+     *\n+     * @param coll  the collection to append\n+     * @param separator  the separator to use, null means no separator\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendWithSeparators(Collection<?> coll, String separator) {\n+        if (coll != null && coll.size() > 0) {\n+            separator = (separator == null ? \"\" : separator);\n+            Iterator<?> it = coll.iterator();\n+            while (it.hasNext()) {\n+                append(it.next());\n+                if (it.hasNext()) {\n+                    append(separator);\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends an iterator placing separators between each value, but\n+     * not before the first or after the last.\n+     * Appending a null iterator will have no effect.\n+     * Each object is appended using {@link #append(Object)}.\n+     *\n+     * @param it  the iterator to append\n+     * @param separator  the separator to use, null means no separator\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendWithSeparators(Iterator<?> it, String separator) {\n+        if (it != null) {\n+            separator = (separator == null ? \"\" : separator);\n+            while (it.hasNext()) {\n+                append(it.next());\n+                if (it.hasNext()) {\n+                    append(separator);\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends a separator if the builder is currently non-empty.\n+     * Appending a null separator will have no effect.\n+     * The separator is appended using {@link #append(String)}.\n+     * <p>\n+     * This method is useful for adding a separator each time around the\n+     * loop except the first.\n+     * <pre>\n+     * for (Iterator it = list.iterator(); it.hasNext(); ) {\n+     *   appendSeparator(\",\");\n+     *   append(it.next());\n+     * }\n+     * </pre>\n+     * Note that for this simple example, you should use\n+     * {@link #appendWithSeparators(Collection, String)}.\n+     * \n+     * @param separator  the separator to use, null means no separator\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendSeparator(String separator) {\n+        return appendSeparator(separator, null);\n+    }\n+\n+    /**\n+     * Appends one of both separators to the StrBuilder.\n+     * If the builder is currently empty it will append the defaultIfEmpty-separator\n+     * Otherwise it will append the standard-separator\n+     * \n+     * Appending a null separator will have no effect.\n+     * The separator is appended using {@link #append(String)}.\n+     * <p>\n+     * This method is for example useful for constructing queries\n+     * <pre>\n+     * StrBuilder whereClause = new StrBuilder();\n+     * if(searchCommand.getPriority() != null) {\n+     *  whereClause.appendSeparator(\" and\", \" where\");\n+     *  whereClause.append(\" priority = ?\")\n+     * }\n+     * if(searchCommand.getComponent() != null) {\n+     *  whereClause.appendSeparator(\" and\", \" where\");\n+     *  whereClause.append(\" component = ?\")\n+     * }\n+     * selectClause.append(whereClause)\n+     * </pre>\n+     * \n+     * @param standard the separator if builder is not empty, null means no separator\n+     * @param defaultIfEmpty the separator if builder is empty, null means no separator\n+     * @return this, to enable chaining\n+     * @since 3.0\n+     */\n+    public StrBuilder appendSeparator(String standard, String defaultIfEmpty) {\n+        String str = isEmpty() ? defaultIfEmpty : standard;\n+        if (str != null) {\n+            append(str);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a separator if the builder is currently non-empty.\n+     * The separator is appended using {@link #append(char)}.\n+     * <p>\n+     * This method is useful for adding a separator each time around the\n+     * loop except the first.\n+     * <pre>\n+     * for (Iterator it = list.iterator(); it.hasNext(); ) {\n+     *   appendSeparator(',');\n+     *   append(it.next());\n+     * }\n+     * </pre>\n+     * Note that for this simple example, you should use\n+     * {@link #appendWithSeparators(Collection, String)}.\n+     * \n+     * @param separator  the separator to use\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendSeparator(char separator) {\n+        if (size() > 0) {\n+            append(separator);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Append one of both separators to the builder\n+     * If the builder is currently empty it will append the defaultIfEmpty-separator\n+     * Otherwise it will append the standard-separator\n+     *\n+     * The separator is appended using {@link #append(char)}.\n+     * @param standard the separator if builder is not empty\n+     * @param defaultIfEmpty the separator if builder is empty\n+     * @return this, to enable chaining\n+     * @since 3.0\n+     */\n+    public StrBuilder appendSeparator(char standard, char defaultIfEmpty) {\n+        if (size() > 0) {\n+            append(standard);\n+        }\n+        else {\n+            append(defaultIfEmpty);\n+        }\n+        return this;\n+    }\n+    /**\n+     * Appends a separator to the builder if the loop index is greater than zero.\n+     * Appending a null separator will have no effect.\n+     * The separator is appended using {@link #append(String)}.\n+     * <p>\n+     * This method is useful for adding a separator each time around the\n+     * loop except the first.\n+     * <pre>\n+     * for (int i = 0; i < list.size(); i++) {\n+     *   appendSeparator(\",\", i);\n+     *   append(list.get(i));\n+     * }\n+     * </pre>\n+     * Note that for this simple example, you should use\n+     * {@link #appendWithSeparators(Collection, String)}.\n+     * \n+     * @param separator  the separator to use, null means no separator\n+     * @param loopIndex  the loop index\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendSeparator(String separator, int loopIndex) {\n+        if (separator != null && loopIndex > 0) {\n+            append(separator);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a separator to the builder if the loop index is greater than zero.\n+     * The separator is appended using {@link #append(char)}.\n+     * <p>\n+     * This method is useful for adding a separator each time around the\n+     * loop except the first.\n+     * <pre>\n+     * for (int i = 0; i < list.size(); i++) {\n+     *   appendSeparator(\",\", i);\n+     *   append(list.get(i));\n+     * }\n+     * </pre>\n+     * Note that for this simple example, you should use\n+     * {@link #appendWithSeparators(Collection, String)}.\n+     * \n+     * @param separator  the separator to use\n+     * @param loopIndex  the loop index\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendSeparator(char separator, int loopIndex) {\n+        if (loopIndex > 0) {\n+            append(separator);\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends the pad character to the builder the specified number of times.\n+     * \n+     * @param length  the length to append, negative means no append\n+     * @param padChar  the character to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendPadding(int length, char padChar) {\n+        if (length >= 0) {\n+            ensureCapacity(size + length);\n+            for (int i = 0; i < length; i++) {\n+                buffer[size++] = padChar;\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends an object to the builder padding on the left to a fixed width.\n+     * The <code>toString</code> of the object is used.\n+     * If the object is larger than the length, the left hand side is lost.\n+     * If the object is null, the null text value is used.\n+     * \n+     * @param obj  the object to append, null uses null text\n+     * @param width  the fixed field width, zero or negative has no effect\n+     * @param padChar  the pad character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n+        if (width > 0) {\n+            ensureCapacity(size + width);\n+            String str = (obj == null ? getNullText() : obj.toString());\n+            if (str == null) {\n+                str = \"\";\n+            }\n+            int strLen = str.length();\n+            if (strLen >= width) {\n+                str.getChars(strLen - width, strLen, buffer, size);\n+            } else {\n+                int padLen = width - strLen;\n+                for (int i = 0; i < padLen; i++) {\n+                    buffer[size + i] = padChar;\n+                }\n+                str.getChars(0, strLen, buffer, size + padLen);\n+            }\n+            size += width;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends an object to the builder padding on the left to a fixed width.\n+     * The <code>String.valueOf</code> of the <code>int</code> value is used.\n+     * If the formatted value is larger than the length, the left hand side is lost.\n+     * \n+     * @param value  the value to append\n+     * @param width  the fixed field width, zero or negative has no effect\n+     * @param padChar  the pad character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendFixedWidthPadLeft(int value, int width, char padChar) {\n+        return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);\n+    }\n+\n+    /**\n+     * Appends an object to the builder padding on the right to a fixed length.\n+     * The <code>toString</code> of the object is used.\n+     * If the object is larger than the length, the right hand side is lost.\n+     * If the object is null, null text value is used.\n+     * \n+     * @param obj  the object to append, null uses null text\n+     * @param width  the fixed field width, zero or negative has no effect\n+     * @param padChar  the pad character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n+        if (width > 0) {\n+            ensureCapacity(size + width);\n+            String str = (obj == null ? getNullText() : obj.toString());\n+            if (str == null) {\n+                str = \"\";\n+            }\n+            int strLen = str.length();\n+            if (strLen >= width) {\n+                str.getChars(0, width, buffer, size);\n+            } else {\n+                int padLen = width - strLen;\n+                str.getChars(0, strLen, buffer, size);\n+                for (int i = 0; i < padLen; i++) {\n+                    buffer[size + strLen + i] = padChar;\n+                }\n+            }\n+            size += width;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends an object to the builder padding on the right to a fixed length.\n+     * The <code>String.valueOf</code> of the <code>int</code> value is used.\n+     * If the object is larger than the length, the right hand side is lost.\n+     * \n+     * @param value  the value to append\n+     * @param width  the fixed field width, zero or negative has no effect\n+     * @param padChar  the pad character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendFixedWidthPadRight(int value, int width, char padChar) {\n+        return appendFixedWidthPadRight(String.valueOf(value), width, padChar);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inserts the string representation of an object into this builder.\n+     * Inserting null will use the stored null text value.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param obj  the object to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, Object obj) {\n+        if (obj == null) {\n+            return insert(index, nullText);\n+        }\n+        return insert(index, obj.toString());\n+    }\n+\n+    /**\n+     * Inserts the string into this builder.\n+     * Inserting null will use the stored null text value.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param str  the string to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    @SuppressWarnings(\"null\") // str cannot be null\n+    public StrBuilder insert(int index, String str) {\n+        validateIndex(index);\n+        if (str == null) {\n+            str = nullText;\n+        }\n+        int strLen = (str == null ? 0 : str.length());\n+        if (strLen > 0) {\n+            int newSize = size + strLen;\n+            ensureCapacity(newSize);\n+            System.arraycopy(buffer, index, buffer, index + strLen, size - index);\n+            size = newSize;\n+            str.getChars(0, strLen, buffer, index); // str cannot be null here\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts the character array into this builder.\n+     * Inserting null will use the stored null text value.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param chars  the char array to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, char chars[]) {\n+        validateIndex(index);\n+        if (chars == null) {\n+            return insert(index, nullText);\n+        }\n+        int len = chars.length;\n+        if (len > 0) {\n+            ensureCapacity(size + len);\n+            System.arraycopy(buffer, index, buffer, index + len, size - index);\n+            System.arraycopy(chars, 0, buffer, index, len);\n+            size += len;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts part of the character array into this builder.\n+     * Inserting null will use the stored null text value.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param chars  the char array to insert\n+     * @param offset  the offset into the character array to start at, must be valid\n+     * @param length  the length of the character array part to copy, must be positive\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if any index is invalid\n+     */\n+    public StrBuilder insert(int index, char chars[], int offset, int length) {\n+        validateIndex(index);\n+        if (chars == null) {\n+            return insert(index, nullText);\n+        }\n+        if (offset < 0 || offset > chars.length) {\n+            throw new StringIndexOutOfBoundsException(\"Invalid offset: \" + offset);\n+        }\n+        if (length < 0 || offset + length > chars.length) {\n+            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n+        }\n+        if (length > 0) {\n+            ensureCapacity(size + length);\n+            System.arraycopy(buffer, index, buffer, index + length, size - index);\n+            System.arraycopy(chars, offset, buffer, index, length);\n+            size += length;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, boolean value) {\n+        validateIndex(index);\n+        if (value) {\n+            ensureCapacity(size + 4);\n+            System.arraycopy(buffer, index, buffer, index + 4, size - index);\n+            buffer[index++] = 't';\n+            buffer[index++] = 'r';\n+            buffer[index++] = 'u';\n+            buffer[index] = 'e';\n+            size += 4;\n+        } else {\n+            ensureCapacity(size + 5);\n+            System.arraycopy(buffer, index, buffer, index + 5, size - index);\n+            buffer[index++] = 'f';\n+            buffer[index++] = 'a';\n+            buffer[index++] = 'l';\n+            buffer[index++] = 's';\n+            buffer[index] = 'e';\n+            size += 5;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, char value) {\n+        validateIndex(index);\n+        ensureCapacity(size + 1);\n+        System.arraycopy(buffer, index, buffer, index + 1, size - index);\n+        buffer[index] = value;\n+        size++;\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, int value) {\n+        return insert(index, String.valueOf(value));\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, long value) {\n+        return insert(index, String.valueOf(value));\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, float value) {\n+        return insert(index, String.valueOf(value));\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, double value) {\n+        return insert(index, String.valueOf(value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Internal method to delete a range without validation.\n+     *\n+     * @param startIndex  the start index, must be valid\n+     * @param endIndex  the end index (exclusive), must be valid\n+     * @param len  the length, must be valid\n+     * @throws IndexOutOfBoundsException if any index is invalid\n+     */\n+    private void deleteImpl(int startIndex, int endIndex, int len) {\n+        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n+        size -= len;\n+    }\n+\n+    /**\n+     * Deletes the characters between the two specified indices.\n+     *\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder delete(int startIndex, int endIndex) {\n+        endIndex = validateRange(startIndex, endIndex);\n+        int len = endIndex - startIndex;\n+        if (len > 0) {\n+            deleteImpl(startIndex, endIndex, len);\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Deletes the character wherever it occurs in the builder.\n+     *\n+     * @param ch  the character to delete\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder deleteAll(char ch) {\n+        for (int i = 0; i < size; i++) {\n+            if (buffer[i] == ch) {\n+                int start = i;\n+                while (++i < size) {\n+                    if (buffer[i] != ch) {\n+                        break;\n+                    }\n+                }\n+                int len = i - start;\n+                deleteImpl(start, i, len);\n+                i -= len;\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the character wherever it occurs in the builder.\n+     *\n+     * @param ch  the character to delete\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder deleteFirst(char ch) {\n+        for (int i = 0; i < size; i++) {\n+            if (buffer[i] == ch) {\n+                deleteImpl(i, i + 1, 1);\n+                break;\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Deletes the string wherever it occurs in the builder.\n+     *\n+     * @param str  the string to delete, null causes no action\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder deleteAll(String str) {\n+        int len = (str == null ? 0 : str.length());\n+        if (len > 0) {\n+            int index = indexOf(str, 0);\n+            while (index >= 0) {\n+                deleteImpl(index, index + len, len);\n+                index = indexOf(str, index);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the string wherever it occurs in the builder.\n+     *\n+     * @param str  the string to delete, null causes no action\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder deleteFirst(String str) {\n+        int len = (str == null ? 0 : str.length());\n+        if (len > 0) {\n+            int index = indexOf(str, 0);\n+            if (index >= 0) {\n+                deleteImpl(index, index + len, len);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Deletes all parts of the builder that the matcher matches.\n+     * <p>\n+     * Matchers can be used to perform advanced deletion behaviour.\n+     * For example you could write a matcher to delete all occurances\n+     * where the character 'a' is followed by a number.\n+     *\n+     * @param matcher  the matcher to use to find the deletion, null causes no action\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder deleteAll(StrMatcher matcher) {\n+        return replace(matcher, null, 0, size, -1);\n+    }\n+\n+    /**\n+     * Deletes the first match within the builder using the specified matcher.\n+     * <p>\n+     * Matchers can be used to perform advanced deletion behaviour.\n+     * For example you could write a matcher to delete\n+     * where the character 'a' is followed by a number.\n+     *\n+     * @param matcher  the matcher to use to find the deletion, null causes no action\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder deleteFirst(StrMatcher matcher) {\n+        return replace(matcher, null, 0, size, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Internal method to delete a range without validation.\n+     *\n+     * @param startIndex  the start index, must be valid\n+     * @param endIndex  the end index (exclusive), must be valid\n+     * @param removeLen  the length to remove (endIndex - startIndex), must be valid\n+     * @param insertStr  the string to replace with, null means delete range\n+     * @param insertLen  the length of the insert string, must be valid\n+     * @throws IndexOutOfBoundsException if any index is invalid\n+     */\n+    private void replaceImpl(int startIndex, int endIndex, int removeLen, String insertStr, int insertLen) {\n+        int newSize = size - removeLen + insertLen;\n+        if (insertLen != removeLen) {\n+            ensureCapacity(newSize);\n+            System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex);\n+            size = newSize;\n+        }\n+        if (insertLen > 0) {\n+            insertStr.getChars(0, insertLen, buffer, startIndex);\n+        }\n+    }\n+\n+    /**\n+     * Replaces a portion of the string builder with another string.\n+     * The length of the inserted string does not have to match the removed length.\n+     *\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @param replaceStr  the string to replace with, null means delete range\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder replace(int startIndex, int endIndex, String replaceStr) {\n+        endIndex = validateRange(startIndex, endIndex);\n+        int insertLen = (replaceStr == null ? 0 : replaceStr.length());\n+        replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen);\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces the search character with the replace character\n+     * throughout the builder.\n+     *\n+     * @param search  the search character\n+     * @param replace  the replace character\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder replaceAll(char search, char replace) {\n+        if (search != replace) {\n+            for (int i = 0; i < size; i++) {\n+                if (buffer[i] == search) {\n+                    buffer[i] = replace;\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Replaces the first instance of the search character with the\n+     * replace character in the builder.\n+     *\n+     * @param search  the search character\n+     * @param replace  the replace character\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder replaceFirst(char search, char replace) {\n+        if (search != replace) {\n+            for (int i = 0; i < size; i++) {\n+                if (buffer[i] == search) {\n+                    buffer[i] = replace;\n+                    break;\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces the search string with the replace string throughout the builder.\n+     *\n+     * @param searchStr  the search string, null causes no action to occur\n+     * @param replaceStr  the replace string, null is equivalent to an empty string\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder replaceAll(String searchStr, String replaceStr) {\n+        int searchLen = (searchStr == null ? 0 : searchStr.length());\n+        if (searchLen > 0) {\n+            int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n+            int index = indexOf(searchStr, 0);\n+            while (index >= 0) {\n+                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n+                index = indexOf(searchStr, index + replaceLen);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Replaces the first instance of the search string with the replace string.\n+     *\n+     * @param searchStr  the search string, null causes no action to occur\n+     * @param replaceStr  the replace string, null is equivalent to an empty string\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder replaceFirst(String searchStr, String replaceStr) {\n+        int searchLen = (searchStr == null ? 0 : searchStr.length());\n+        if (searchLen > 0) {\n+            int index = indexOf(searchStr, 0);\n+            if (index >= 0) {\n+                int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n+                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all matches within the builder with the replace string.\n+     * <p>\n+     * Matchers can be used to perform advanced replace behaviour.\n+     * For example you could write a matcher to replace all occurances\n+     * where the character 'a' is followed by a number.\n+     *\n+     * @param matcher  the matcher to use to find the deletion, null causes no action\n+     * @param replaceStr  the replace string, null is equivalent to an empty string\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder replaceAll(StrMatcher matcher, String replaceStr) {\n+        return replace(matcher, replaceStr, 0, size, -1);\n+    }\n+\n+    /**\n+     * Replaces the first match within the builder with the replace string.\n+     * <p>\n+     * Matchers can be used to perform advanced replace behaviour.\n+     * For example you could write a matcher to replace\n+     * where the character 'a' is followed by a number.\n+     *\n+     * @param matcher  the matcher to use to find the deletion, null causes no action\n+     * @param replaceStr  the replace string, null is equivalent to an empty string\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder replaceFirst(StrMatcher matcher, String replaceStr) {\n+        return replace(matcher, replaceStr, 0, size, 1);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Advanced search and replaces within the builder using a matcher.\n+     * <p>\n+     * Matchers can be used to perform advanced behaviour.\n+     * For example you could write a matcher to delete all occurances\n+     * where the character 'a' is followed by a number.\n+     *\n+     * @param matcher  the matcher to use to find the deletion, null causes no action\n+     * @param replaceStr  the string to replace the match with, null is a delete\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @param replaceCount  the number of times to replace, -1 for replace all\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if start index is invalid\n+     */\n+    public StrBuilder replace(\n+            StrMatcher matcher, String replaceStr,\n+            int startIndex, int endIndex, int replaceCount) {\n+        endIndex = validateRange(startIndex, endIndex);\n+        return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);\n+    }\n+\n+    /**\n+     * Replaces within the builder using a matcher.\n+     * <p>\n+     * Matchers can be used to perform advanced behaviour.\n+     * For example you could write a matcher to delete all occurances\n+     * where the character 'a' is followed by a number.\n+     *\n+     * @param matcher  the matcher to use to find the deletion, null causes no action\n+     * @param replaceStr  the string to replace the match with, null is a delete\n+     * @param from  the start index, must be valid\n+     * @param to  the end index (exclusive), must be valid\n+     * @param replaceCount  the number of times to replace, -1 for replace all\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if any index is invalid\n+     */\n+    private StrBuilder replaceImpl(\n+            StrMatcher matcher, String replaceStr,\n+            int from, int to, int replaceCount) {\n+        if (matcher == null || size == 0) {\n+            return this;\n+        }\n+        int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n+        char[] buf = buffer;\n+        for (int i = from; i < to && replaceCount != 0; i++) {\n+            int removeLen = matcher.isMatch(buf, i, from, to);\n+            if (removeLen > 0) {\n+                replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen);\n+                to = to - removeLen + replaceLen;\n+                i = i + replaceLen - 1;\n+                if (replaceCount > 0) {\n+                    replaceCount--;\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Reverses the string builder placing each character in the opposite index.\n+     * \n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder reverse() {\n+        if (size == 0) {\n+            return this;\n+        }\n+        \n+        int half = size / 2;\n+        char[] buf = buffer;\n+        for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++,rightIdx--) {\n+            char swap = buf[leftIdx];\n+            buf[leftIdx] = buf[rightIdx];\n+            buf[rightIdx] = swap;\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Trims the builder by removing characters less than or equal to a space\n+     * from the beginning and end.\n+     *\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder trim() {\n+        if (size == 0) {\n+            return this;\n+        }\n+        int len = size;\n+        char[] buf = buffer;\n+        int pos = 0;\n+        while (pos < len && buf[pos] <= ' ') {\n+            pos++;\n+        }\n+        while (pos < len && buf[len - 1] <= ' ') {\n+            len--;\n+        }\n+        if (len < size) {\n+            delete(len, size);\n+        }\n+        if (pos > 0) {\n+            delete(0, pos);\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether this builder starts with the specified string.\n+     * <p>\n+     * Note that this method handles null input quietly, unlike String.\n+     * \n+     * @param str  the string to search for, null returns false\n+     * @return true if the builder starts with the string\n+     */\n+    public boolean startsWith(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int len = str.length();\n+        if (len == 0) {\n+            return true;\n+        }\n+        if (len > size) {\n+            return false;\n+        }\n+        for (int i = 0; i < len; i++) {\n+            if (buffer[i] != str.charAt(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks whether this builder ends with the specified string.\n+     * <p>\n+     * Note that this method handles null input quietly, unlike String.\n+     * \n+     * @param str  the string to search for, null returns false\n+     * @return true if the builder ends with the string\n+     */\n+    public boolean endsWith(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int len = str.length();\n+        if (len == 0) {\n+            return true;\n+        }\n+        if (len > size) {\n+            return false;\n+        }\n+        int pos = size - len;\n+        for (int i = 0; i < len; i++,pos++) {\n+            if (buffer[pos] != str.charAt(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public CharSequence subSequence(int startIndex, int endIndex) {\n+      if (startIndex < 0) {\n+          throw new StringIndexOutOfBoundsException(startIndex);\n+      }\n+      if (endIndex > size) {\n+          throw new StringIndexOutOfBoundsException(endIndex);\n+      }\n+      if (startIndex > endIndex) {\n+          throw new StringIndexOutOfBoundsException(endIndex - startIndex);\n+      }\n+      return substring(startIndex, endIndex);\n+    }\n+\n+    /**\n+     * Extracts a portion of this string builder as a string.\n+     * \n+     * @param start  the start index, inclusive, must be valid\n+     * @return the new string\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public String substring(int start) {\n+        return substring(start, size);\n+    }\n+\n+    /**\n+     * Extracts a portion of this string builder as a string.\n+     * <p>\n+     * Note: This method treats an endIndex greater than the length of the\n+     * builder as equal to the length of the builder, and continues\n+     * without error, unlike StringBuffer or String.\n+     * \n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @return the new string\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public String substring(int startIndex, int endIndex) {\n+        endIndex = validateRange(startIndex, endIndex);\n+        return new String(buffer, startIndex, endIndex - startIndex);\n+    }\n+\n+    /**\n+     * Extracts the leftmost characters from the string builder without\n+     * throwing an exception.\n+     * <p>\n+     * This method extracts the left <code>length</code> characters from\n+     * the builder. If this many characters are not available, the whole\n+     * builder is returned. Thus the returned string may be shorter than the\n+     * length requested.\n+     * \n+     * @param length  the number of characters to extract, negative returns empty string\n+     * @return the new string\n+     */\n+    public String leftString(int length) {\n+        if (length <= 0) {\n+            return \"\";\n+        } else if (length >= size) {\n+            return new String(buffer, 0, size);\n+        } else {\n+            return new String(buffer, 0, length);\n+        }\n+    }\n+\n+    /**\n+     * Extracts the rightmost characters from the string builder without\n+     * throwing an exception.\n+     * <p>\n+     * This method extracts the right <code>length</code> characters from\n+     * the builder. If this many characters are not available, the whole\n+     * builder is returned. Thus the returned string may be shorter than the\n+     * length requested.\n+     * \n+     * @param length  the number of characters to extract, negative returns empty string\n+     * @return the new string\n+     */\n+    public String rightString(int length) {\n+        if (length <= 0) {\n+            return \"\";\n+        } else if (length >= size) {\n+            return new String(buffer, 0, size);\n+        } else {\n+            return new String(buffer, size - length, length);\n+        }\n+    }\n+\n+    /**\n+     * Extracts some characters from the middle of the string builder without\n+     * throwing an exception.\n+     * <p>\n+     * This method extracts <code>length</code> characters from the builder\n+     * at the specified index.\n+     * If the index is negative it is treated as zero.\n+     * If the index is greater than the builder size, it is treated as the builder size.\n+     * If the length is negative, the empty string is returned.\n+     * If insufficient characters are available in the builder, as much as possible is returned.\n+     * Thus the returned string may be shorter than the length requested.\n+     * \n+     * @param index  the index to start at, negative means zero\n+     * @param length  the number of characters to extract, negative returns empty string\n+     * @return the new string\n+     */\n+    public String midString(int index, int length) {\n+        if (index < 0) {\n+            index = 0;\n+        }\n+        if (length <= 0 || index >= size) {\n+            return \"\";\n+        }\n+        if (size <= index + length) {\n+            return new String(buffer, index, size - index);\n+        } else {\n+            return new String(buffer, index, length);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks if the string builder contains the specified char.\n+     *\n+     * @param ch  the character to find\n+     * @return true if the builder contains the character\n+     */\n+    public boolean contains(char ch) {\n+        char[] thisBuf = buffer;\n+        for (int i = 0; i < this.size; i++) {\n+            if (thisBuf[i] == ch) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks if the string builder contains the specified string.\n+     *\n+     * @param str  the string to find\n+     * @return true if the builder contains the string\n+     */\n+    public boolean contains(String str) {\n+        return indexOf(str, 0) >= 0;\n+    }\n+\n+    /**\n+     * Checks if the string builder contains a string matched using the\n+     * specified matcher.\n+     * <p>\n+     * Matchers can be used to perform advanced searching behaviour.\n+     * For example you could write a matcher to search for the character\n+     * 'a' followed by a number.\n+     *\n+     * @param matcher  the matcher to use, null returns -1\n+     * @return true if the matcher finds a match in the builder\n+     */\n+    public boolean contains(StrMatcher matcher) {\n+        return indexOf(matcher, 0) >= 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Searches the string builder to find the first reference to the specified char.\n+     * \n+     * @param ch  the character to find\n+     * @return the first index of the character, or -1 if not found\n+     */\n+    public int indexOf(char ch) {\n+        return indexOf(ch, 0);\n+    }\n+\n+    /**\n+     * Searches the string builder to find the first reference to the specified char.\n+     * \n+     * @param ch  the character to find\n+     * @param startIndex  the index to start at, invalid index rounded to edge\n+     * @return the first index of the character, or -1 if not found\n+     */\n+    public int indexOf(char ch, int startIndex) {\n+        startIndex = (startIndex < 0 ? 0 : startIndex);\n+        if (startIndex >= size) {\n+            return -1;\n+        }\n+        char[] thisBuf = buffer;\n+        for (int i = startIndex; i < size; i++) {\n+            if (thisBuf[i] == ch) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Searches the string builder to find the first reference to the specified string.\n+     * <p>\n+     * Note that a null input string will return -1, whereas the JDK throws an exception.\n+     * \n+     * @param str  the string to find, null returns -1\n+     * @return the first index of the string, or -1 if not found\n+     */\n+    public int indexOf(String str) {\n+        return indexOf(str, 0);\n+    }\n+\n+    /**\n+     * Searches the string builder to find the first reference to the specified\n+     * string starting searching from the given index.\n+     * <p>\n+     * Note that a null input string will return -1, whereas the JDK throws an exception.\n+     * \n+     * @param str  the string to find, null returns -1\n+     * @param startIndex  the index to start at, invalid index rounded to edge\n+     * @return the first index of the string, or -1 if not found\n+     */\n+    public int indexOf(String str, int startIndex) {\n+        startIndex = (startIndex < 0 ? 0 : startIndex);\n+        if (str == null || startIndex >= size) {\n+            return -1;\n+        }\n+        int strLen = str.length();\n+        if (strLen == 1) {\n+            return indexOf(str.charAt(0), startIndex);\n+        }\n+        if (strLen == 0) {\n+            return startIndex;\n+        }\n+        if (strLen > size) {\n+            return -1;\n+        }\n+        char[] thisBuf = buffer;\n+        int len = size - strLen + 1;\n+        outer:\n+        for (int i = startIndex; i < len; i++) {\n+            for (int j = 0; j < strLen; j++) {\n+                if (str.charAt(j) != thisBuf[i + j]) {\n+                    continue outer;\n+                }\n+            }\n+            return i;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Searches the string builder using the matcher to find the first match.\n+     * <p>\n+     * Matchers can be used to perform advanced searching behaviour.\n+     * For example you could write a matcher to find the character 'a'\n+     * followed by a number.\n+     *\n+     * @param matcher  the matcher to use, null returns -1\n+     * @return the first index matched, or -1 if not found\n+     */\n+    public int indexOf(StrMatcher matcher) {\n+        return indexOf(matcher, 0);\n+    }\n+\n+    /**\n+     * Searches the string builder using the matcher to find the first\n+     * match searching from the given index.\n+     * <p>\n+     * Matchers can be used to perform advanced searching behaviour.\n+     * For example you could write a matcher to find the character 'a'\n+     * followed by a number.\n+     *\n+     * @param matcher  the matcher to use, null returns -1\n+     * @param startIndex  the index to start at, invalid index rounded to edge\n+     * @return the first index matched, or -1 if not found\n+     */\n+    public int indexOf(StrMatcher matcher, int startIndex) {\n+        startIndex = (startIndex < 0 ? 0 : startIndex);\n+        if (matcher == null || startIndex >= size) {\n+            return -1;\n+        }\n+        int len = size;\n+        char[] buf = buffer;\n+        for (int i = startIndex; i < len; i++) {\n+            if (matcher.isMatch(buf, i, startIndex, len) > 0) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Searches the string builder to find the last reference to the specified char.\n+     * \n+     * @param ch  the character to find\n+     * @return the last index of the character, or -1 if not found\n+     */\n+    public int lastIndexOf(char ch) {\n+        return lastIndexOf(ch, size - 1);\n+    }\n+\n+    /**\n+     * Searches the string builder to find the last reference to the specified char.\n+     * \n+     * @param ch  the character to find\n+     * @param startIndex  the index to start at, invalid index rounded to edge\n+     * @return the last index of the character, or -1 if not found\n+     */\n+    public int lastIndexOf(char ch, int startIndex) {\n+        startIndex = (startIndex >= size ? size - 1 : startIndex);\n+        if (startIndex < 0) {\n+            return -1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (buffer[i] == ch) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Searches the string builder to find the last reference to the specified string.\n+     * <p>\n+     * Note that a null input string will return -1, whereas the JDK throws an exception.\n+     * \n+     * @param str  the string to find, null returns -1\n+     * @return the last index of the string, or -1 if not found\n+     */\n+    public int lastIndexOf(String str) {\n+        return lastIndexOf(str, size - 1);\n+    }\n+\n+    /**\n+     * Searches the string builder to find the last reference to the specified\n+     * string starting searching from the given index.\n+     * <p>\n+     * Note that a null input string will return -1, whereas the JDK throws an exception.\n+     * \n+     * @param str  the string to find, null returns -1\n+     * @param startIndex  the index to start at, invalid index rounded to edge\n+     * @return the last index of the string, or -1 if not found\n+     */\n+    public int lastIndexOf(String str, int startIndex) {\n+        startIndex = (startIndex >= size ? size - 1 : startIndex);\n+        if (str == null || startIndex < 0) {\n+            return -1;\n+        }\n+        int strLen = str.length();\n+        if (strLen > 0 && strLen <= size) {\n+            if (strLen == 1) {\n+                return lastIndexOf(str.charAt(0), startIndex);\n+            }\n+\n+            outer:\n+            for (int i = startIndex - strLen + 1; i >= 0; i--) {\n+                for (int j = 0; j < strLen; j++) {\n+                    if (str.charAt(j) != buffer[i + j]) {\n+                        continue outer;\n+                    }\n+                }\n+                return i;\n+            }\n+            \n+        } else if (strLen == 0) {\n+            return startIndex;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Searches the string builder using the matcher to find the last match.\n+     * <p>\n+     * Matchers can be used to perform advanced searching behaviour.\n+     * For example you could write a matcher to find the character 'a'\n+     * followed by a number.\n+     *\n+     * @param matcher  the matcher to use, null returns -1\n+     * @return the last index matched, or -1 if not found\n+     */\n+    public int lastIndexOf(StrMatcher matcher) {\n+        return lastIndexOf(matcher, size);\n+    }\n+\n+    /**\n+     * Searches the string builder using the matcher to find the last\n+     * match searching from the given index.\n+     * <p>\n+     * Matchers can be used to perform advanced searching behaviour.\n+     * For example you could write a matcher to find the character 'a'\n+     * followed by a number.\n+     *\n+     * @param matcher  the matcher to use, null returns -1\n+     * @param startIndex  the index to start at, invalid index rounded to edge\n+     * @return the last index matched, or -1 if not found\n+     */\n+    public int lastIndexOf(StrMatcher matcher, int startIndex) {\n+        startIndex = (startIndex >= size ? size - 1 : startIndex);\n+        if (matcher == null || startIndex < 0) {\n+            return -1;\n+        }\n+        char[] buf = buffer;\n+        int endIndex = startIndex + 1;\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (matcher.isMatch(buf, i, 0, endIndex) > 0) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a tokenizer that can tokenize the contents of this builder.\n+     * <p>\n+     * This method allows the contents of this builder to be tokenized.\n+     * The tokenizer will be setup by default to tokenize on space, tab,\n+     * newline and formfeed (as per StringTokenizer). These values can be\n+     * changed on the tokenizer class, before retrieving the tokens.\n+     * <p>\n+     * The returned tokenizer is linked to this builder. You may intermix\n+     * calls to the buider and tokenizer within certain limits, however\n+     * there is no synchronization. Once the tokenizer has been used once,\n+     * it must be {@link StrTokenizer#reset() reset} to pickup the latest\n+     * changes in the builder. For example:\n+     * <pre>\n+     * StrBuilder b = new StrBuilder();\n+     * b.append(\"a b \");\n+     * StrTokenizer t = b.asTokenizer();\n+     * String[] tokens1 = t.getTokenArray();  // returns a,b\n+     * b.append(\"c d \");\n+     * String[] tokens2 = t.getTokenArray();  // returns a,b (c and d ignored)\n+     * t.reset();              // reset causes builder changes to be picked up\n+     * String[] tokens3 = t.getTokenArray();  // returns a,b,c,d\n+     * </pre>\n+     * In addition to simply intermixing appends and tokenization, you can also\n+     * call the set methods on the tokenizer to alter how it tokenizes. Just\n+     * remember to call reset when you want to pickup builder changes.\n+     * <p>\n+     * Calling {@link StrTokenizer#reset(String)} or {@link StrTokenizer#reset(char[])}\n+     * with a non-null value will break the link with the builder.\n+     *\n+     * @return a tokenizer that is linked to this builder\n+     */\n+    public StrTokenizer asTokenizer() {\n+        return new StrBuilderTokenizer();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the contents of this builder as a Reader.\n+     * <p>\n+     * This method allows the contents of the builder to be read\n+     * using any standard method that expects a Reader.\n+     * <p>\n+     * To use, simply create a <code>StrBuilder</code>, populate it with\n+     * data, call <code>asReader</code>, and then read away.\n+     * <p>\n+     * The internal character array is shared between the builder and the reader.\n+     * This allows you to append to the builder after creating the reader,\n+     * and the changes will be picked up.\n+     * Note however, that no synchronization occurs, so you must perform\n+     * all operations with the builder and the reader in one thread.\n+     * <p>\n+     * The returned reader supports marking, and ignores the flush method.\n+     *\n+     * @return a reader that reads from this builder\n+     */\n+    public Reader asReader() {\n+        return new StrBuilderReader();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this builder as a Writer that can be written to.\n+     * <p>\n+     * This method allows you to populate the contents of the builder\n+     * using any standard method that takes a Writer.\n+     * <p>\n+     * To use, simply create a <code>StrBuilder</code>,\n+     * call <code>asWriter</code>, and populate away. The data is available\n+     * at any time using the methods of the <code>StrBuilder</code>.\n+     * <p>\n+     * The internal character array is shared between the builder and the writer.\n+     * This allows you to intermix calls that append to the builder and\n+     * write using the writer and the changes will be occur correctly.\n+     * Note however, that no synchronization occurs, so you must perform\n+     * all operations with the builder and the writer in one thread.\n+     * <p>\n+     * The returned writer ignores the close and flush methods.\n+     *\n+     * @return a writer that populates this builder\n+     */\n+    public Writer asWriter() {\n+        return new StrBuilderWriter();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+//    /**\n+//     * Gets a String version of the string builder by calling the internal\n+//     * constructor of String by reflection.\n+//     * <p>\n+//     * WARNING: You must not use the StrBuilder after calling this method\n+//     * as the buffer is now shared with the String object. To ensure this,\n+//     * the internal character array is set to null, so you will get\n+//     * NullPointerExceptions on all method calls.\n+//     *\n+//     * @return the builder as a String\n+//     */\n+//    public String toSharedString() {\n+//        try {\n+//            Constructor con = String.class.getDeclaredConstructor(\n+//                new Class[] {int.class, int.class, char[].class});\n+//            con.setAccessible(true);\n+//            char[] buffer = buf;\n+//            buf = null;\n+//            size = -1;\n+//            nullText = null;\n+//            return (String) con.newInstance(\n+//                new Object[] {new Integer(0), new Integer(size), buffer});\n+//            \n+//        } catch (Exception ex) {\n+//            ex.printStackTrace();\n+//            throw new UnsupportedOperationException(\"StrBuilder.toSharedString is unsupported: \" + ex.getMessage());\n+//        }\n+//    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks the contents of this builder against another to see if they\n+     * contain the same character content ignoring case.\n+     *\n+     * @param other  the object to check, null returns false\n+     * @return true if the builders contain the same characters in the same order\n+     */\n+    public boolean equalsIgnoreCase(StrBuilder other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (this.size != other.size) {\n+            return false;\n+        }\n+        char thisBuf[] = this.buffer;\n+        char otherBuf[] = other.buffer;\n+        for (int i = size - 1; i >= 0; i--) {\n+            char c1 = thisBuf[i];\n+            char c2 = otherBuf[i];\n+            if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks the contents of this builder against another to see if they\n+     * contain the same character content.\n+     *\n+     * @param other  the object to check, null returns false\n+     * @return true if the builders contain the same characters in the same order\n+     */\n+    public boolean equals(StrBuilder other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (this.size != other.size) {\n+            return false;\n+        }\n+        char thisBuf[] = this.buffer;\n+        char otherBuf[] = other.buffer;\n+        for (int i = size - 1; i >= 0; i--) {\n+            if (thisBuf[i] != otherBuf[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks the contents of this builder against another to see if they\n+     * contain the same character content.\n+     *\n+     * @param obj  the object to check, null returns false\n+     * @return true if the builders contain the same characters in the same order\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof StrBuilder) {\n+            return equals((StrBuilder) obj);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets a suitable hash code for this builder.\n+     *\n+     * @return a hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        char buf[] = buffer;\n+        int hash = 0;\n+        for (int i = size - 1; i >= 0; i--) {\n+            hash = 31 * hash + buf[i];\n+        }\n+        return hash;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a String version of the string builder, creating a new instance\n+     * each time the method is called.\n+     * <p>\n+     * Note that unlike StringBuffer, the string version returned is\n+     * independent of the string builder.\n+     *\n+     * @return the builder as a String\n+     */\n+    @Override\n+    public String toString() {\n+        return new String(buffer, 0, size);\n+    }\n+\n+    /**\n+     * Gets a StringBuffer version of the string builder, creating a\n+     * new instance each time the method is called.\n+     *\n+     * @return the builder as a StringBuffer\n+     */\n+    public StringBuffer toStringBuffer() {\n+        return new StringBuffer(size).append(buffer, 0, size);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates parameters defining a range of the builder.\n+     * \n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @return the new string\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected int validateRange(int startIndex, int endIndex) {\n+        if (startIndex < 0) {\n+            throw new StringIndexOutOfBoundsException(startIndex);\n+        }\n+        if (endIndex > size) {\n+            endIndex = size;\n+        }\n+        if (startIndex > endIndex) {\n+            throw new StringIndexOutOfBoundsException(\"end < start\");\n+        }\n+        return endIndex;\n+    }\n+\n+    /**\n+     * Validates parameters defining a single index in the builder.\n+     * \n+     * @param index  the index, must be valid\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected void validateIndex(int index) {\n+        if (index < 0 || index > size) {\n+            throw new StringIndexOutOfBoundsException(index);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class to allow StrBuilder to operate as a tokenizer.\n+     */\n+    class StrBuilderTokenizer extends StrTokenizer {\n+\n+        StrBuilderTokenizer() {\n+            super();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        protected List<String> tokenize(char[] chars, int offset, int count) {\n+            if (chars == null) {\n+                return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size());\n+            } else {\n+                return super.tokenize(chars, offset, count);\n+            }\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public String getContent() {\n+            String str = super.getContent();\n+            if (str == null) {\n+                return StrBuilder.this.toString();\n+            } else {\n+                return str;\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class to allow StrBuilder to operate as a writer.\n+     */\n+    class StrBuilderReader extends Reader {\n+        /** The current stream position. */\n+        private int pos;\n+        /** The last mark position. */\n+        private int mark;\n+\n+        StrBuilderReader() {\n+            super();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void close() {\n+            // do nothing\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public int read() {\n+            if (ready() == false) {\n+                return -1;\n+            }\n+            return StrBuilder.this.charAt(pos++);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public int read(char b[], int off, int len) {\n+            if (off < 0 || len < 0 || off > b.length ||\n+                    (off + len) > b.length || (off + len) < 0) {\n+                throw new IndexOutOfBoundsException();\n+            }\n+            if (len == 0) {\n+                return 0;\n+            }\n+            if (pos >= StrBuilder.this.size()) {\n+                return -1;\n+            }\n+            if (pos + len > size()) {\n+                len = StrBuilder.this.size() - pos;\n+            }\n+            StrBuilder.this.getChars(pos, pos + len, b, off);\n+            pos += len;\n+            return len;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public long skip(long n) {\n+            if (pos + n > StrBuilder.this.size()) {\n+                n = StrBuilder.this.size() - pos;\n+            }\n+            if (n < 0) {\n+                return 0;\n+            }\n+            pos += n;\n+            return n;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public boolean ready() {\n+            return pos < StrBuilder.this.size();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public boolean markSupported() {\n+            return true;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void mark(int readAheadLimit) {\n+            mark = pos;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void reset() {\n+            pos = mark;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class to allow StrBuilder to operate as a writer.\n+     */\n+    class StrBuilderWriter extends Writer {\n+\n+        StrBuilderWriter() {\n+            super();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void close() {\n+            // do nothing\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void flush() {\n+            // do nothing\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void write(int c) {\n+            StrBuilder.this.append((char) c);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void write(char[] cbuf) {\n+            StrBuilder.this.append(cbuf);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void write(char[] cbuf, int off, int len) {\n+            StrBuilder.this.append(cbuf, off, len);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void write(String str) {\n+            StrBuilder.this.append(str);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void write(String str, int off, int len) {\n+            StrBuilder.this.append(str, off, len);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/text/StrLookup.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.util.Map;\n+\n+/**\n+ * Lookup a String key to a String value.\n+ * <p>\n+ * This class represents the simplest form of a string to string map.\n+ * It has a benefit over a map in that it can create the result on\n+ * demand based on the key.\n+ * <p>\n+ * This class comes complete with various factory methods.\n+ * If these do not suffice, you can subclass and implement your own matcher.\n+ * <p>\n+ * For example, it would be possible to implement a lookup that used the\n+ * key as a primary key, and looked up the value on demand from the database\n+ *\n+ * @author Apache Software Foundation\n+ * @since 2.2\n+ * @version $Id$\n+ */\n+public abstract class StrLookup<V> {\n+\n+    /**\n+     * Lookup that always returns null.\n+     */\n+    private static final StrLookup<?> NONE_LOOKUP;\n+    /**\n+     * Lookup that uses System properties.\n+     */\n+    private static final StrLookup<Object> SYSTEM_PROPERTIES_LOOKUP;\n+    static {\n+        NONE_LOOKUP = new MapStrLookup(null);\n+        StrLookup lookup = null;\n+        try {\n+            lookup = new MapStrLookup(System.getProperties());\n+        } catch (SecurityException ex) {\n+            lookup = NONE_LOOKUP;\n+        }\n+        SYSTEM_PROPERTIES_LOOKUP = lookup;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a lookup which always returns null.\n+     *\n+     * @return a lookup that always returns null, not null\n+     */\n+    public static StrLookup<?> noneLookup() {\n+        return NONE_LOOKUP;\n+    }\n+\n+    /**\n+     * Returns a lookup which uses {@link System#getProperties() System properties}\n+     * to lookup the key to value.\n+     * <p>\n+     * If a security manager blocked access to system properties, then null will\n+     * be returned from every lookup.\n+     * <p>\n+     * If a null key is used, this lookup will throw a NullPointerException.\n+     *\n+     * @return a lookup using system properties, not null\n+     */\n+    public static StrLookup<Object> systemPropertiesLookup() {\n+        return SYSTEM_PROPERTIES_LOOKUP;\n+    }\n+\n+    /**\n+     * Returns a lookup which looks up values using a map.\n+     * <p>\n+     * If the map is null, then null will be returned from every lookup.\n+     * The map result object is converted to a string using toString().\n+     *\n+     * @param map  the map of keys to values, may be null\n+     * @return a lookup using the map, not null\n+     */\n+    public static <V> StrLookup mapLookup(Map<String, V> map) {\n+        return new MapStrLookup<V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     */\n+    protected StrLookup() {\n+        super();\n+    }\n+\n+    /**\n+     * Looks up a String key to a String value.\n+     * <p>\n+     * The internal implementation may use any mechanism to return the value.\n+     * The simplest implementation is to use a Map. However, virtually any\n+     * implementation is possible.\n+     * <p>\n+     * For example, it would be possible to implement a lookup that used the\n+     * key as a primary key, and looked up the value on demand from the database\n+     * Or, a numeric based implementation could be created that treats the key\n+     * as an integer, increments the value and return the result as a string -\n+     * converting 1 to 2, 15 to 16 etc.\n+     *\n+     * @param key  the key to be looked up, may be null\n+     * @return the matching value, null if no match\n+     */\n+    public abstract String lookup(String key);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Lookup implementation that uses a Map.\n+     */\n+    static class MapStrLookup<V> extends StrLookup {\n+\n+        /** Map keys are variable names and value. */\n+        private final Map<String, V> map;\n+\n+        /**\n+         * Creates a new instance backed by a Map.\n+         *\n+         * @param map  the map of keys to values, may be null\n+         */\n+        MapStrLookup(Map<String, V> map) {\n+            this.map = map;\n+        }\n+\n+        /**\n+         * Looks up a String key to a String value using the map.\n+         * <p>\n+         * If the map is null, then null is returned.\n+         * The map result object is converted to a string using toString().\n+         *\n+         * @param key  the key to be looked up, may be null\n+         * @return the matching value, null if no match\n+         */\n+        @Override\n+        public String lookup(String key) {\n+            if (map == null) {\n+                return null;\n+            }\n+            Object obj = map.get(key);\n+            if (obj == null) {\n+                return null;\n+            }\n+            return obj.toString();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/text/StrMatcher.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * A matcher class that can be queried to determine if a character array\n+ * portion matches.\n+ * <p>\n+ * This class comes complete with various factory methods.\n+ * If these do not suffice, you can subclass and implement your own matcher.\n+ *\n+ * @author Apache Software Foundation\n+ * @since 2.2\n+ * @version $Id$\n+ */\n+public abstract class StrMatcher {\n+\n+    /**\n+     * Matches the comma character.\n+     */\n+    private static final StrMatcher COMMA_MATCHER = new CharMatcher(',');\n+    /**\n+     * Matches the tab character.\n+     */\n+    private static final StrMatcher TAB_MATCHER = new CharMatcher('\\t');\n+    /**\n+     * Matches the space character.\n+     */\n+    private static final StrMatcher SPACE_MATCHER = new CharMatcher(' ');\n+    /**\n+     * Matches the same characters as StringTokenizer,\n+     * namely space, tab, newline, formfeed.\n+     */\n+    private static final StrMatcher SPLIT_MATCHER = new CharSetMatcher(\" \\t\\n\\r\\f\".toCharArray());\n+    /**\n+     * Matches the String trim() whitespace characters.\n+     */\n+    private static final StrMatcher TRIM_MATCHER = new TrimMatcher();\n+    /**\n+     * Matches the double quote character.\n+     */\n+    private static final StrMatcher SINGLE_QUOTE_MATCHER = new CharMatcher('\\'');\n+    /**\n+     * Matches the double quote character.\n+     */\n+    private static final StrMatcher DOUBLE_QUOTE_MATCHER = new CharMatcher('\"');\n+    /**\n+     * Matches the single or double quote character.\n+     */\n+    private static final StrMatcher QUOTE_MATCHER = new CharSetMatcher(\"'\\\"\".toCharArray());\n+    /**\n+     * Matches no characters.\n+     */\n+    private static final StrMatcher NONE_MATCHER = new NoMatcher();\n+\n+    // -----------------------------------------------------------------------\n+\n+    /**\n+     * Returns a matcher which matches the comma character.\n+     *\n+     * @return a matcher for a comma\n+     */\n+    public static StrMatcher commaMatcher() {\n+        return COMMA_MATCHER;\n+    }\n+\n+    /**\n+     * Returns a matcher which matches the tab character.\n+     *\n+     * @return a matcher for a tab\n+     */\n+    public static StrMatcher tabMatcher() {\n+        return TAB_MATCHER;\n+    }\n+\n+    /**\n+     * Returns a matcher which matches the space character.\n+     *\n+     * @return a matcher for a space\n+     */\n+    public static StrMatcher spaceMatcher() {\n+        return SPACE_MATCHER;\n+    }\n+\n+    /**\n+     * Matches the same characters as StringTokenizer,\n+     * namely space, tab, newline and formfeed.\n+     *\n+     * @return the split matcher\n+     */\n+    public static StrMatcher splitMatcher() {\n+        return SPLIT_MATCHER;\n+    }\n+\n+    /**\n+     * Matches the String trim() whitespace characters.\n+     *\n+     * @return the trim matcher\n+     */\n+    public static StrMatcher trimMatcher() {\n+        return TRIM_MATCHER;\n+    }\n+\n+    /**\n+     * Returns a matcher which matches the single quote character.\n+     *\n+     * @return a matcher for a single quote\n+     */\n+    public static StrMatcher singleQuoteMatcher() {\n+        return SINGLE_QUOTE_MATCHER;\n+    }\n+\n+    /**\n+     * Returns a matcher which matches the double quote character.\n+     *\n+     * @return a matcher for a double quote\n+     */\n+    public static StrMatcher doubleQuoteMatcher() {\n+        return DOUBLE_QUOTE_MATCHER;\n+    }\n+\n+    /**\n+     * Returns a matcher which matches the single or double quote character.\n+     *\n+     * @return a matcher for a single or double quote\n+     */\n+    public static StrMatcher quoteMatcher() {\n+        return QUOTE_MATCHER;\n+    }\n+\n+    /**\n+     * Matches no characters.\n+     *\n+     * @return a matcher that matches nothing\n+     */\n+    public static StrMatcher noneMatcher() {\n+        return NONE_MATCHER;\n+    }\n+\n+    /**\n+     * Constructor that creates a matcher from a character.\n+     *\n+     * @param ch  the character to match, must not be null\n+     * @return a new Matcher for the given char\n+     */\n+    public static StrMatcher charMatcher(char ch) {\n+        return new CharMatcher(ch);\n+    }\n+\n+    /**\n+     * Constructor that creates a matcher from a set of characters.\n+     *\n+     * @param chars  the characters to match, null or empty matches nothing\n+     * @return a new matcher for the given char[]\n+     */\n+    public static StrMatcher charSetMatcher(char[] chars) {\n+        if (chars == null || chars.length == 0) {\n+            return NONE_MATCHER;\n+        }\n+        if (chars.length == 1) {\n+            return new CharMatcher(chars[0]);\n+        }\n+        return new CharSetMatcher(chars);\n+    }\n+\n+    /**\n+     * Constructor that creates a matcher from a string representing a set of characters.\n+     *\n+     * @param chars  the characters to match, null or empty matches nothing\n+     * @return a new Matcher for the given characters\n+     */\n+    public static StrMatcher charSetMatcher(String chars) {\n+        if (chars == null || chars.length() == 0) {\n+            return NONE_MATCHER;\n+        }\n+        if (chars.length() == 1) {\n+            return new CharMatcher(chars.charAt(0));\n+        }\n+        return new CharSetMatcher(chars.toCharArray());\n+    }\n+\n+    /**\n+     * Constructor that creates a matcher from a string.\n+     *\n+     * @param str  the string to match, null or empty matches nothing\n+     * @return a new Matcher for the given String\n+     */\n+    public static StrMatcher stringMatcher(String str) {\n+        if (str == null || str.length() == 0) {\n+            return NONE_MATCHER;\n+        }\n+        return new StringMatcher(str);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     */\n+    protected StrMatcher() {\n+        super();\n+    }\n+\n+    /**\n+     * Returns the number of matching characters, zero for no match.\n+     * <p>\n+     * This method is called to check for a match.\n+     * The parameter <code>pos</code> represents the current position to be\n+     * checked in the string <code>buffer</code> (a character array which must\n+     * not be changed).\n+     * The API guarantees that <code>pos</code> is a valid index for <code>buffer</code>.\n+     * <p>\n+     * The character array may be larger than the active area to be matched.\n+     * Only values in the buffer between the specifed indices may be accessed.\n+     * <p>\n+     * The matching code may check one character or many.\n+     * It may check characters preceeding <code>pos</code> as well as those\n+     * after, so long as no checks exceed the bounds specified.\n+     * <p>\n+     * It must return zero for no match, or a positive number if a match was found.\n+     * The number indicates the number of characters that matched.\n+     *\n+     * @param buffer  the text content to match against, do not change\n+     * @param pos  the starting position for the match, valid for buffer\n+     * @param bufferStart  the first active index in the buffer, valid for buffer\n+     * @param bufferEnd  the end index (exclusive) of the active buffer, valid for buffer\n+     * @return the number of matching characters, zero for no match\n+     */\n+    public abstract int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd);\n+\n+    /**\n+     * Returns the number of matching characters, zero for no match.\n+     * <p>\n+     * This method is called to check for a match.\n+     * The parameter <code>pos</code> represents the current position to be\n+     * checked in the string <code>buffer</code> (a character array which must\n+     * not be changed).\n+     * The API guarantees that <code>pos</code> is a valid index for <code>buffer</code>.\n+     * <p>\n+     * The matching code may check one character or many.\n+     * It may check characters preceeding <code>pos</code> as well as those after.\n+     * <p>\n+     * It must return zero for no match, or a positive number if a match was found.\n+     * The number indicates the number of characters that matched.\n+     *\n+     * @param buffer  the text content to match against, do not change\n+     * @param pos  the starting position for the match, valid for buffer\n+     * @return the number of matching characters, zero for no match\n+     * @since 2.4\n+     */\n+    public int isMatch(char[] buffer, int pos) {\n+        return isMatch(buffer, pos, 0, buffer.length);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Class used to define a set of characters for matching purposes.\n+     */\n+    static final class CharSetMatcher extends StrMatcher {\n+        /** The set of characters to match. */\n+        private final char[] chars;\n+\n+        /**\n+         * Constructor that creates a matcher from a character array.\n+         *\n+         * @param chars  the characters to match, must not be null\n+         */\n+        CharSetMatcher(char chars[]) {\n+            super();\n+            this.chars = chars.clone();\n+            Arrays.sort(this.chars);\n+        }\n+\n+        /**\n+         * Returns whether or not the given character matches.\n+         *\n+         * @param buffer  the text content to match against, do not change\n+         * @param pos  the starting position for the match, valid for buffer\n+         * @param bufferStart  the first active index in the buffer, valid for buffer\n+         * @param bufferEnd  the end index of the active buffer, valid for buffer\n+         * @return the number of matching characters, zero for no match\n+         */\n+        @Override\n+        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+            return Arrays.binarySearch(chars, buffer[pos]) >= 0 ? 1 : 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Class used to define a character for matching purposes.\n+     */\n+    static final class CharMatcher extends StrMatcher {\n+        /** The character to match. */\n+        private final char ch;\n+\n+        /**\n+         * Constructor that creates a matcher that matches a single character.\n+         *\n+         * @param ch  the character to match\n+         */\n+        CharMatcher(char ch) {\n+            super();\n+            this.ch = ch;\n+        }\n+\n+        /**\n+         * Returns whether or not the given character matches.\n+         *\n+         * @param buffer  the text content to match against, do not change\n+         * @param pos  the starting position for the match, valid for buffer\n+         * @param bufferStart  the first active index in the buffer, valid for buffer\n+         * @param bufferEnd  the end index of the active buffer, valid for buffer\n+         * @return the number of matching characters, zero for no match\n+         */\n+        @Override\n+        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+            return ch == buffer[pos] ? 1 : 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Class used to define a set of characters for matching purposes.\n+     */\n+    static final class StringMatcher extends StrMatcher {\n+        /** The string to match, as a character array. */\n+        private final char[] chars;\n+\n+        /**\n+         * Constructor that creates a matcher from a String.\n+         *\n+         * @param str  the string to match, must not be null\n+         */\n+        StringMatcher(String str) {\n+            super();\n+            chars = str.toCharArray();\n+        }\n+\n+        /**\n+         * Returns whether or not the given text matches the stored string.\n+         *\n+         * @param buffer  the text content to match against, do not change\n+         * @param pos  the starting position for the match, valid for buffer\n+         * @param bufferStart  the first active index in the buffer, valid for buffer\n+         * @param bufferEnd  the end index of the active buffer, valid for buffer\n+         * @return the number of matching characters, zero for no match\n+         */\n+        @Override\n+        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+            int len = chars.length;\n+            if (pos + len > bufferEnd) {\n+                return 0;\n+            }\n+            for (int i = 0; i < chars.length; i++, pos++) {\n+                if (chars[i] != buffer[pos]) {\n+                    return 0;\n+                }\n+            }\n+            return len;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Class used to match no characters.\n+     */\n+    static final class NoMatcher extends StrMatcher {\n+\n+        /**\n+         * Constructs a new instance of <code>NoMatcher</code>.\n+         */\n+        NoMatcher() {\n+            super();\n+        }\n+\n+        /**\n+         * Always returns <code>false</code>.\n+         *\n+         * @param buffer  the text content to match against, do not change\n+         * @param pos  the starting position for the match, valid for buffer\n+         * @param bufferStart  the first active index in the buffer, valid for buffer\n+         * @param bufferEnd  the end index of the active buffer, valid for buffer\n+         * @return the number of matching characters, zero for no match\n+         */\n+        @Override\n+        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+            return 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Class used to match whitespace as per trim().\n+     */\n+    static final class TrimMatcher extends StrMatcher {\n+\n+        /**\n+         * Constructs a new instance of <code>TrimMatcher</code>.\n+         */\n+        TrimMatcher() {\n+            super();\n+        }\n+\n+        /**\n+         * Returns whether or not the given character matches.\n+         *\n+         * @param buffer  the text content to match against, do not change\n+         * @param pos  the starting position for the match, valid for buffer\n+         * @param bufferStart  the first active index in the buffer, valid for buffer\n+         * @param bufferEnd  the end index of the active buffer, valid for buffer\n+         * @return the number of matching characters, zero for no match\n+         */\n+        @Override\n+        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+            return buffer[pos] <= 32 ? 1 : 0;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/text/StrSubstitutor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Substitutes variables within a string by values.\n+ * <p>\n+ * This class takes a piece of text and substitutes all the variables within it.\n+ * The default definition of a variable is <code>${variableName}</code>.\n+ * The prefix and suffix can be changed via constructors and set methods.\n+ * <p>\n+ * Variable values are typically resolved from a map, but could also be resolved\n+ * from system properties, or by supplying a custom variable resolver.\n+ * <p>\n+ * The simplest example is to use this class to replace Java System properties. For example:\n+ * <pre>\n+ * StrSubstitutor.replaceSystemProperties(\n+ *      \"You are running with java.version = ${java.version} and os.name = ${os.name}.\");\n+ * </pre>\n+ * <p>\n+ * Typical usage of this class follows the following pattern: First an instance is created\n+ * and initialized with the map that contains the values for the available variables.\n+ * If a prefix and/or suffix for variables should be used other than the default ones,\n+ * the appropriate settings can be performed. After that the <code>replace()</code>\n+ * method can be called passing in the source text for interpolation. In the returned\n+ * text all variable references (as long as their values are known) will be resolved.\n+ * The following example demonstrates this:\n+ * <pre>\n+ * Map valuesMap = HashMap();\n+ * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\n+ * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\n+ * String templateString = &quot;The ${animal} jumped over the ${target}.&quot;;\n+ * StrSubstitutor sub = new StrSubstitutor(valuesMap);\n+ * String resolvedString = sub.replace(templateString);\n+ * </pre>\n+ * yielding:\n+ * <pre>\n+ *      The quick brown fox jumped over the lazy dog.\n+ * </pre>\n+ * <p>\n+ * In addition to this usage pattern there are some static convenience methods that\n+ * cover the most common use cases. These methods can be used without the need of\n+ * manually creating an instance. However if multiple replace operations are to be\n+ * performed, creating and reusing an instance of this class will be more efficient.\n+ * <p>\n+ * Variable replacement works in a recursive way. Thus, if a variable value contains\n+ * a variable then that variable will also be replaced. Cyclic replacements are\n+ * detected and will cause an exception to be thrown.\n+ * <p>\n+ * Sometimes the interpolation's result must contain a variable prefix. As an example\n+ * take the following source text:\n+ * <pre>\n+ *   The variable ${${name}} must be used.\n+ * </pre>\n+ * Here only the variable's name refered to in the text should be replaced resulting\n+ * in the text (assuming that the value of the <code>name</code> variable is <code>x</code>):\n+ * <pre>\n+ *   The variable ${x} must be used.\n+ * </pre>\n+ * To achieve this effect there are two possibilities: Either set a different prefix\n+ * and suffix for variables which do not conflict with the result text you want to\n+ * produce. The other possibility is to use the escape character, by default '$'.\n+ * If this character is placed before a variable reference, this reference is ignored\n+ * and won't be replaced. For example:\n+ * <pre>\n+ *   The variable $${${name}} must be used.\n+ * </pre>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Oliver Heger\n+ * @version $Id$\n+ * @since 2.2\n+ */\n+public class StrSubstitutor {\n+\n+    /**\n+     * Constant for the default escape character.\n+     */\n+    public static final char DEFAULT_ESCAPE = '$';\n+    /**\n+     * Constant for the default variable prefix.\n+     */\n+    public static final StrMatcher DEFAULT_PREFIX = StrMatcher.stringMatcher(\"${\");\n+    /**\n+     * Constant for the default variable suffix.\n+     */\n+    public static final StrMatcher DEFAULT_SUFFIX = StrMatcher.stringMatcher(\"}\");\n+\n+    /**\n+     * Stores the escape character.\n+     */\n+    private char escapeChar;\n+    /**\n+     * Stores the variable prefix.\n+     */\n+    private StrMatcher prefixMatcher;\n+    /**\n+     * Stores the variable suffix.\n+     */\n+    private StrMatcher suffixMatcher;\n+    /**\n+     * Variable resolution is delegated to an implementor of VariableResolver.\n+     */\n+    private StrLookup variableResolver;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables in the given source object with\n+     * their matching values from the map.\n+     *\n+     * @param source  the source text containing the variables to substitute, null returns null\n+     * @param valueMap  the map with the values, may be null\n+     * @return the result of the replace operation\n+     */\n+    public static <V> String replace(Object source, Map<String, V> valueMap) {\n+        return new StrSubstitutor(valueMap).replace(source);\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables in the given source object with\n+     * their matching values from the map. This method allows to specifiy a\n+     * custom variable prefix and suffix\n+     *\n+     * @param source  the source text containing the variables to substitute, null returns null\n+     * @param valueMap  the map with the values, may be null\n+     * @param prefix  the prefix of variables, not null\n+     * @param suffix  the suffix of variables, not null\n+     * @return the result of the replace operation\n+     * @throws IllegalArgumentException if the prefix or suffix is null\n+     */\n+    public static <V> String replace(Object source, Map<String, V> valueMap, String prefix, String suffix) {\n+        return new StrSubstitutor(valueMap, prefix, suffix).replace(source);\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables in the given source object with\n+     * their matching values from the system properties.\n+     *\n+     * @param source  the source text containing the variables to substitute, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public static String replaceSystemProperties(Object source) {\n+        return new StrSubstitutor(StrLookup.systemPropertiesLookup()).replace(source);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance with defaults for variable prefix and suffix\n+     * and the escaping character.\n+     */\n+    public StrSubstitutor() {\n+        this((StrLookup) null, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it. Uses defaults for variable\n+     * prefix and suffix and the escaping character.\n+     *\n+     * @param valueMap  the map with the variables' values, may be null\n+     */\n+    public <V> StrSubstitutor(Map<String, V> valueMap) {\n+        this(StrLookup.mapLookup(valueMap), DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it. Uses a default escaping character.\n+     *\n+     * @param valueMap  the map with the variables' values, may be null\n+     * @param prefix  the prefix for variables, not null\n+     * @param suffix  the suffix for variables, not null\n+     * @throws IllegalArgumentException if the prefix or suffix is null\n+     */\n+    public <V> StrSubstitutor(Map<String, V> valueMap, String prefix, String suffix) {\n+        this(StrLookup.mapLookup(valueMap), prefix, suffix, DEFAULT_ESCAPE);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it.\n+     *\n+     * @param valueMap  the map with the variables' values, may be null\n+     * @param prefix  the prefix for variables, not null\n+     * @param suffix  the suffix for variables, not null\n+     * @param escape  the escape character\n+     * @throws IllegalArgumentException if the prefix or suffix is null\n+     */\n+    public <V> StrSubstitutor(Map<String, V> valueMap, String prefix, String suffix, char escape) {\n+        this(StrLookup.mapLookup(valueMap), prefix, suffix, escape);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it.\n+     *\n+     * @param variableResolver  the variable resolver, may be null\n+     */\n+    public StrSubstitutor(StrLookup variableResolver) {\n+        this(variableResolver, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it.\n+     *\n+     * @param variableResolver  the variable resolver, may be null\n+     * @param prefix  the prefix for variables, not null\n+     * @param suffix  the suffix for variables, not null\n+     * @param escape  the escape character\n+     * @throws IllegalArgumentException if the prefix or suffix is null\n+     */\n+    public StrSubstitutor(StrLookup variableResolver, String prefix, String suffix, char escape) {\n+        this.setVariableResolver(variableResolver);\n+        this.setVariablePrefix(prefix);\n+        this.setVariableSuffix(suffix);\n+        this.setEscapeChar(escape);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it.\n+     *\n+     * @param variableResolver  the variable resolver, may be null\n+     * @param prefixMatcher  the prefix for variables, not null\n+     * @param suffixMatcher  the suffix for variables, not null\n+     * @param escape  the escape character\n+     * @throws IllegalArgumentException if the prefix or suffix is null\n+     */\n+    public StrSubstitutor(\n+            StrLookup variableResolver, StrMatcher prefixMatcher, StrMatcher suffixMatcher, char escape) {\n+        this.setVariableResolver(variableResolver);\n+        this.setVariablePrefixMatcher(prefixMatcher);\n+        this.setVariableSuffixMatcher(suffixMatcher);\n+        this.setEscapeChar(escape);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source string as a template.\n+     *\n+     * @param source  the string to replace in, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(String source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(source);\n+        if (substitute(buf, 0, source.length()) == false) {\n+            return source;\n+        }\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source string as a template.\n+     * <p>\n+     * Only the specified portion of the string will be processed.\n+     * The rest of the string is not processed, and is not returned.\n+     *\n+     * @param source  the string to replace in, null returns null\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the array to be processed, must be valid\n+     * @return the result of the replace operation\n+     */\n+    public String replace(String source, int offset, int length) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        if (substitute(buf, 0, length) == false) {\n+            return source.substring(offset, offset + length);\n+        }\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source array as a template.\n+     * The array is not altered by this method.\n+     *\n+     * @param source  the character array to replace in, not altered, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(char[] source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(source.length).append(source);\n+        substitute(buf, 0, source.length);\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source array as a template.\n+     * The array is not altered by this method.\n+     * <p>\n+     * Only the specified portion of the array will be processed.\n+     * The rest of the array is not processed, and is not returned.\n+     *\n+     * @param source  the character array to replace in, not altered, null returns null\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the array to be processed, must be valid\n+     * @return the result of the replace operation\n+     */\n+    public String replace(char[] source, int offset, int length) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        substitute(buf, 0, length);\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source buffer as a template.\n+     * The buffer is not altered by this method.\n+     *\n+     * @param source  the buffer to use as a template, not changed, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(StringBuffer source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(source.length()).append(source);\n+        substitute(buf, 0, buf.length());\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source buffer as a template.\n+     * The buffer is not altered by this method.\n+     * <p>\n+     * Only the specified portion of the buffer will be processed.\n+     * The rest of the buffer is not processed, and is not returned.\n+     *\n+     * @param source  the buffer to use as a template, not changed, null returns null\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the array to be processed, must be valid\n+     * @return the result of the replace operation\n+     */\n+    public String replace(StringBuffer source, int offset, int length) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        substitute(buf, 0, length);\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source builder as a template.\n+     * The builder is not altered by this method.\n+     *\n+     * @param source  the builder to use as a template, not changed, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(StrBuilder source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(source.length()).append(source);\n+        substitute(buf, 0, buf.length());\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source builder as a template.\n+     * The builder is not altered by this method.\n+     * <p>\n+     * Only the specified portion of the builder will be processed.\n+     * The rest of the builder is not processed, and is not returned.\n+     *\n+     * @param source  the builder to use as a template, not changed, null returns null\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the array to be processed, must be valid\n+     * @return the result of the replace operation\n+     */\n+    public String replace(StrBuilder source, int offset, int length) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        substitute(buf, 0, length);\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables in the given source object with\n+     * their matching values from the resolver. The input source object is\n+     * converted to a string using <code>toString</code> and is not altered.\n+     *\n+     * @param source  the source to replace in, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(Object source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder().append(source);\n+        substitute(buf, 0, buf.length());\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables within the given source buffer\n+     * with their matching values from the resolver.\n+     * The buffer is updated with the result.\n+     *\n+     * @param source  the buffer to replace in, updated, null returns zero\n+     * @return true if altered\n+     */\n+    public boolean replaceIn(StringBuffer source) {\n+        if (source == null) {\n+            return false;\n+        }\n+        return replaceIn(source, 0, source.length());\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables within the given source buffer\n+     * with their matching values from the resolver.\n+     * The buffer is updated with the result.\n+     * <p>\n+     * Only the specified portion of the buffer will be processed.\n+     * The rest of the buffer is not processed, but it is not deleted.\n+     *\n+     * @param source  the buffer to replace in, updated, null returns zero\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the buffer to be processed, must be valid\n+     * @return true if altered\n+     */\n+    public boolean replaceIn(StringBuffer source, int offset, int length) {\n+        if (source == null) {\n+            return false;\n+        }\n+        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        if (substitute(buf, 0, length) == false) {\n+            return false;\n+        }\n+        source.replace(offset, offset + length, buf.toString());\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables within the given source\n+     * builder with their matching values from the resolver.\n+     *\n+     * @param source  the builder to replace in, updated, null returns zero\n+     * @return true if altered\n+     */\n+    public boolean replaceIn(StrBuilder source) {\n+        if (source == null) {\n+            return false;\n+        }\n+        return substitute(source, 0, source.length());\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables within the given source\n+     * builder with their matching values from the resolver.\n+     * <p>\n+     * Only the specified portion of the builder will be processed.\n+     * The rest of the builder is not processed, but it is not deleted.\n+     *\n+     * @param source  the builder to replace in, null returns zero\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the builder to be processed, must be valid\n+     * @return true if altered\n+     */\n+    public boolean replaceIn(StrBuilder source, int offset, int length) {\n+        if (source == null) {\n+            return false;\n+        }\n+        return substitute(source, offset, length);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Internal method that substitutes the variables.\n+     * <p>\n+     * Most users of this class do not need to call this method. This method will\n+     * be called automatically by another (public) method.\n+     * <p>\n+     * Writers of subclasses can override this method if they need access to\n+     * the substitution process at the start or end.\n+     *\n+     * @param buf  the string builder to substitute into, not null\n+     * @param offset  the start offset within the builder, must be valid\n+     * @param length  the length within the builder to be processed, must be valid\n+     * @return true if altered\n+     */\n+    protected boolean substitute(StrBuilder buf, int offset, int length) {\n+        return substitute(buf, offset, length, null) > 0;\n+    }\n+\n+    /**\n+     * Recursive handler for multiple levels of interpolation. This is the main\n+     * interpolation method, which resolves the values of all variable references\n+     * contained in the passed in text.\n+     *\n+     * @param buf  the string builder to substitute into, not null\n+     * @param offset  the start offset within the builder, must be valid\n+     * @param length  the length within the builder to be processed, must be valid\n+     * @param priorVariables  the stack keeping track of the replaced variables, may be null\n+     * @return the length change that occurs, unless priorVariables is null when the int\n+     *  represents a boolean flag as to whether any change occurred.\n+     */\n+    private int substitute(StrBuilder buf, int offset, int length, List<String> priorVariables) {\n+        StrMatcher prefixMatcher = getVariablePrefixMatcher();\n+        StrMatcher suffixMatcher = getVariableSuffixMatcher();\n+        char escape = getEscapeChar();\n+        \n+        boolean top = (priorVariables == null);\n+        boolean altered = false;\n+        int lengthChange = 0;\n+        char[] chars = buf.buffer;\n+        int bufEnd = offset + length;\n+        int pos = offset;\n+        while (pos < bufEnd) {\n+            int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n+            if (startMatchLen == 0) {\n+                pos++;\n+            } else {\n+                // found variable start marker\n+                if (pos > offset && chars[pos - 1] == escape) {\n+                    // escaped\n+                    buf.deleteCharAt(pos - 1);\n+                    chars = buf.buffer;  // in case buffer was altered\n+                    lengthChange--;\n+                    altered = true;\n+                    bufEnd--;\n+                } else {\n+                    // find suffix\n+                    int startPos = pos;\n+                    pos += startMatchLen;\n+                    int endMatchLen = 0;\n+                    while (pos < bufEnd) {\n+                        endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n+                        if (endMatchLen == 0) {\n+                            pos++;\n+                        } else {\n+                            // found variable end marker\n+                            String varName = new String(chars, startPos + startMatchLen, \n+                                                        pos - startPos - startMatchLen);\n+                            pos += endMatchLen;\n+                            int endPos = pos;\n+                            \n+                            // on the first call initialize priorVariables\n+                            if (priorVariables == null) {\n+                                priorVariables = new ArrayList<String>();\n+                                priorVariables.add(new String(chars, offset, length));\n+                            }\n+                            \n+                            // handle cyclic substitution\n+                            checkCyclicSubstitution(varName, priorVariables);\n+                            priorVariables.add(varName);\n+                            \n+                            // resolve the variable\n+                            String varValue = resolveVariable(varName, buf, startPos, endPos);\n+                            if (varValue != null) {\n+                                // recursive replace\n+                                int varLen = varValue.length();\n+                                buf.replace(startPos, endPos, varValue);\n+                                altered = true;\n+                                int change = substitute(buf, startPos, varLen, priorVariables);\n+                                change = change + (varLen - (endPos - startPos));\n+                                pos += change;\n+                                bufEnd += change;\n+                                lengthChange += change;\n+                                chars = buf.buffer;  // in case buffer was altered\n+                            }\n+                            \n+                            // remove variable from the cyclic stack\n+                            priorVariables.remove(priorVariables.size() - 1);\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if (top) {\n+            return (altered ? 1 : 0);\n+        }\n+        return lengthChange;\n+    }\n+\n+    /**\n+     * Checks if the specified variable is already in the stack (list) of variables.\n+     *\n+     * @param varName  the variable name to check\n+     * @param priorVariables  the list of prior variables\n+     */\n+    private void checkCyclicSubstitution(String varName, List<String> priorVariables) {\n+        if (priorVariables.contains(varName) == false) {\n+            return;\n+        }\n+        StrBuilder buf = new StrBuilder(256);\n+        buf.append(\"Infinite loop in property interpolation of \");\n+        buf.append(priorVariables.remove(0));\n+        buf.append(\": \");\n+        buf.appendWithSeparators(priorVariables, \"->\");\n+        throw new IllegalStateException(buf.toString());\n+    }\n+\n+    /**\n+     * Internal method that resolves the value of a variable.\n+     * <p>\n+     * Most users of this class do not need to call this method. This method is\n+     * called automatically by the substitution process.\n+     * <p>\n+     * Writers of subclasses can override this method if they need to alter\n+     * how each substitution occurs. The method is passed the variable's name\n+     * and must return the corresponding value. This implementation uses the\n+     * {@link #getVariableResolver()} with the variable's name as the key.\n+     *\n+     * @param variableName  the name of the variable, not null\n+     * @param buf  the buffer where the substitution is occurring, not null\n+     * @param startPos  the start position of the variable including the prefix, valid\n+     * @param endPos  the end position of the variable including the suffix, valid\n+     * @return the variable's value or <b>null</b> if the variable is unknown\n+     */\n+    protected String resolveVariable(String variableName, StrBuilder buf, int startPos, int endPos) {\n+        StrLookup resolver = getVariableResolver();\n+        if (resolver == null) {\n+            return null;\n+        }\n+        return resolver.lookup(variableName);\n+    }\n+\n+    // Escape\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the escape character.\n+     *\n+     * @return the character used for escaping variable references\n+     */\n+    public char getEscapeChar() {\n+        return this.escapeChar;\n+    }\n+\n+    /**\n+     * Sets the escape character.\n+     * If this character is placed before a variable reference in the source\n+     * text, this variable will be ignored.\n+     *\n+     * @param escapeCharacter  the escape character (0 for disabling escaping)\n+     */\n+    public void setEscapeChar(char escapeCharacter) {\n+        this.escapeChar = escapeCharacter;\n+    }\n+\n+    // Prefix\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the variable prefix matcher currently in use.\n+     * <p>\n+     * The variable prefix is the characer or characters that identify the\n+     * start of a variable. This prefix is expressed in terms of a matcher\n+     * allowing advanced prefix matches.\n+     *\n+     * @return the prefix matcher in use\n+     */\n+    public StrMatcher getVariablePrefixMatcher() {\n+        return prefixMatcher;\n+    }\n+\n+    /**\n+     * Sets the variable prefix matcher currently in use.\n+     * <p>\n+     * The variable prefix is the characer or characters that identify the\n+     * start of a variable. This prefix is expressed in terms of a matcher\n+     * allowing advanced prefix matches.\n+     *\n+     * @param prefixMatcher  the prefix matcher to use, null ignored\n+     * @return this, to enable chaining\n+     * @throws IllegalArgumentException if the prefix matcher is null\n+     */\n+    public StrSubstitutor setVariablePrefixMatcher(StrMatcher prefixMatcher) {\n+        if (prefixMatcher == null) {\n+            throw new IllegalArgumentException(\"Variable prefix matcher must not be null!\");\n+        }\n+        this.prefixMatcher = prefixMatcher;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the variable prefix to use.\n+     * <p>\n+     * The variable prefix is the characer or characters that identify the\n+     * start of a variable. This method allows a single character prefix to\n+     * be easily set.\n+     *\n+     * @param prefix  the prefix character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrSubstitutor setVariablePrefix(char prefix) {\n+        return setVariablePrefixMatcher(StrMatcher.charMatcher(prefix));\n+    }\n+\n+    /**\n+     * Sets the variable prefix to use.\n+     * <p>\n+     * The variable prefix is the characer or characters that identify the\n+     * start of a variable. This method allows a string prefix to be easily set.\n+     *\n+     * @param prefix  the prefix for variables, not null\n+     * @return this, to enable chaining\n+     * @throws IllegalArgumentException if the prefix is null\n+     */\n+    public StrSubstitutor setVariablePrefix(String prefix) {\n+       if (prefix == null) {\n+            throw new IllegalArgumentException(\"Variable prefix must not be null!\");\n+        }\n+        return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix));\n+    }\n+\n+    // Suffix\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the variable suffix matcher currently in use.\n+     * <p>\n+     * The variable suffix is the characer or characters that identify the\n+     * end of a variable. This suffix is expressed in terms of a matcher\n+     * allowing advanced suffix matches.\n+     *\n+     * @return the suffix matcher in use\n+     */\n+    public StrMatcher getVariableSuffixMatcher() {\n+        return suffixMatcher;\n+    }\n+\n+    /**\n+     * Sets the variable suffix matcher currently in use.\n+     * <p>\n+     * The variable suffix is the characer or characters that identify the\n+     * end of a variable. This suffix is expressed in terms of a matcher\n+     * allowing advanced suffix matches.\n+     *\n+     * @param suffixMatcher  the suffix matcher to use, null ignored\n+     * @return this, to enable chaining\n+     * @throws IllegalArgumentException if the suffix matcher is null\n+     */\n+    public StrSubstitutor setVariableSuffixMatcher(StrMatcher suffixMatcher) {\n+        if (suffixMatcher == null) {\n+            throw new IllegalArgumentException(\"Variable suffix matcher must not be null!\");\n+        }\n+        this.suffixMatcher = suffixMatcher;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the variable suffix to use.\n+     * <p>\n+     * The variable suffix is the characer or characters that identify the\n+     * end of a variable. This method allows a single character suffix to\n+     * be easily set.\n+     *\n+     * @param suffix  the suffix character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrSubstitutor setVariableSuffix(char suffix) {\n+        return setVariableSuffixMatcher(StrMatcher.charMatcher(suffix));\n+    }\n+\n+    /**\n+     * Sets the variable suffix to use.\n+     * <p>\n+     * The variable suffix is the characer or characters that identify the\n+     * end of a variable. This method allows a string suffix to be easily set.\n+     *\n+     * @param suffix  the suffix for variables, not null\n+     * @return this, to enable chaining\n+     * @throws IllegalArgumentException if the suffix is null\n+     */\n+    public StrSubstitutor setVariableSuffix(String suffix) {\n+       if (suffix == null) {\n+            throw new IllegalArgumentException(\"Variable suffix must not be null!\");\n+        }\n+        return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix));\n+    }\n+\n+    // Resolver\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the VariableResolver that is used to lookup variables.\n+     *\n+     * @return the VariableResolver\n+     */\n+    public StrLookup getVariableResolver() {\n+        return this.variableResolver;\n+    }\n+\n+    /**\n+     * Sets the VariableResolver that is used to lookup variables.\n+     *\n+     * @param variableResolver  the VariableResolver\n+     */\n+    public void setVariableResolver(StrLookup variableResolver) {\n+        this.variableResolver = variableResolver;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/text/StrTokenizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+\n+/**\n+ * Tokenizes a string based based on delimiters (separators)\n+ * and supporting quoting and ignored character concepts.\n+ * <p>\n+ * This class can split a String into many smaller strings. It aims\n+ * to do a similar job to {@link java.util.StringTokenizer StringTokenizer},\n+ * however it offers much more control and flexibility including implementing\n+ * the <code>ListIterator</code> interface. By default, it is set up\n+ * like <code>StringTokenizer</code>.\n+ * <p>\n+ * The input String is split into a number of <i>tokens</i>.\n+ * Each token is separated from the next String by a <i>delimiter</i>.\n+ * One or more delimiter characters must be specified.\n+ * <p>\n+ * Each token may be surrounded by quotes.\n+ * The <i>quote</i> matcher specifies the quote character(s).\n+ * A quote may be escaped within a quoted section by duplicating itself.\n+ * <p>\n+ * Between each token and the delimiter are potentially characters that need trimming.\n+ * The <i>trimmer</i> matcher specifies these characters.\n+ * One usage might be to trim whitespace characters.\n+ * <p>\n+ * At any point outside the quotes there might potentially be invalid characters.\n+ * The <i>ignored</i> matcher specifies these characters to be removed.\n+ * One usage might be to remove new line characters.\n+ * <p>\n+ * Empty tokens may be removed or returned as null.\n+ * <pre>\n+ * \"a,b,c\"         - Three tokens \"a\",\"b\",\"c\"   (comma delimiter)\n+ * \" a, b , c \"    - Three tokens \"a\",\"b\",\"c\"   (default CSV processing trims whitespace)\n+ * \"a, \", b ,\", c\" - Three tokens \"a, \" , \" b \", \", c\" (quoted text untouched)\n+ * </pre>\n+ * <p>\n+ *\n+ * This tokenizer has the following properties and options:\n+ *\n+ * <table>\n+ *  <tr>\n+ *   <th>Property</th><th>Type</th><th>Default</th>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>delim</td><td>CharSetMatcher</td><td>{ \\t\\n\\r\\f}</td>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>quote</td><td>NoneMatcher</td><td>{}</td>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>ignore</td><td>NoneMatcher</td><td>{}</td>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>emptyTokenAsNull</td><td>boolean</td><td>false</td>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>ignoreEmptyTokens</td><td>boolean</td><td>true</td>\n+ *  </tr>\n+ * </table>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Matthew Inger\n+ * @author Gary D. Gregory\n+ * @since 2.2\n+ * @version $Id$\n+ */\n+public class StrTokenizer implements ListIterator<String>, Cloneable {\n+\n+    private static final StrTokenizer CSV_TOKENIZER_PROTOTYPE;\n+    private static final StrTokenizer TSV_TOKENIZER_PROTOTYPE;\n+    static {\n+        CSV_TOKENIZER_PROTOTYPE = new StrTokenizer();\n+        CSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(StrMatcher.commaMatcher());\n+        CSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());\n+        CSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(StrMatcher.noneMatcher());\n+        CSV_TOKENIZER_PROTOTYPE.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        CSV_TOKENIZER_PROTOTYPE.setEmptyTokenAsNull(false);\n+        CSV_TOKENIZER_PROTOTYPE.setIgnoreEmptyTokens(false);\n+\n+        TSV_TOKENIZER_PROTOTYPE = new StrTokenizer();\n+        TSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(StrMatcher.tabMatcher());\n+        TSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());\n+        TSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(StrMatcher.noneMatcher());\n+        TSV_TOKENIZER_PROTOTYPE.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        TSV_TOKENIZER_PROTOTYPE.setEmptyTokenAsNull(false);\n+        TSV_TOKENIZER_PROTOTYPE.setIgnoreEmptyTokens(false);\n+    }\n+\n+    /** The text to work on. */\n+    private char chars[];\n+    /** The parsed tokens */\n+    private String tokens[];\n+    /** The current iteration position */\n+    private int tokenPos;\n+\n+    /** The delimiter matcher */\n+    private StrMatcher delimMatcher = StrMatcher.splitMatcher();\n+    /** The quote matcher */\n+    private StrMatcher quoteMatcher = StrMatcher.noneMatcher();\n+    /** The ignored matcher */\n+    private StrMatcher ignoredMatcher = StrMatcher.noneMatcher();\n+    /** The trimmer matcher */\n+    private StrMatcher trimmerMatcher = StrMatcher.noneMatcher();\n+\n+    /** Whether to return empty tokens as null */\n+    private boolean emptyAsNull = false;\n+    /** Whether to ignore empty tokens */\n+    private boolean ignoreEmptyTokens = true;\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Returns a clone of <code>CSV_TOKENIZER_PROTOTYPE</code>.\n+     * \n+     * @return a clone of <code>CSV_TOKENIZER_PROTOTYPE</code>.\n+     */\n+    private static StrTokenizer getCSVClone() {\n+        return (StrTokenizer) CSV_TOKENIZER_PROTOTYPE.clone();\n+    }\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Comma Separated Value strings\n+     * initializing it with the given input.  The default for CSV processing\n+     * will be trim whitespace from both ends (which can be overridden with\n+     * the setTrimmer method).\n+     * <p>\n+     * You must call a \"reset\" method to set the string which you want to parse.\n+     * @return a new tokenizer instance which parses Comma Separated Value strings\n+     */\n+    public static StrTokenizer getCSVInstance() {\n+        return getCSVClone();\n+    }\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Comma Separated Value strings\n+     * initializing it with the given input.  The default for CSV processing\n+     * will be trim whitespace from both ends (which can be overridden with\n+     * the setTrimmer method).\n+     *\n+     * @param input  the text to parse\n+     * @return a new tokenizer instance which parses Comma Separated Value strings\n+     */\n+    public static StrTokenizer getCSVInstance(String input) {\n+        StrTokenizer tok = getCSVClone();\n+        tok.reset(input);\n+        return tok;\n+    }\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Comma Separated Value strings\n+     * initializing it with the given input.  The default for CSV processing\n+     * will be trim whitespace from both ends (which can be overridden with\n+     * the setTrimmer method).\n+     *\n+     * @param input  the text to parse\n+     * @return a new tokenizer instance which parses Comma Separated Value strings\n+     */\n+    public static StrTokenizer getCSVInstance(char[] input) {\n+        StrTokenizer tok = getCSVClone();\n+        tok.reset(input);\n+        return tok;\n+    }\n+\n+    /**\n+     * Returns a clone of <code>TSV_TOKENIZER_PROTOTYPE</code>.\n+     * \n+     * @return a clone of <code>TSV_TOKENIZER_PROTOTYPE</code>.\n+     */\n+    private static StrTokenizer getTSVClone() {\n+        return (StrTokenizer) TSV_TOKENIZER_PROTOTYPE.clone();\n+    }\n+\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Tab Separated Value strings.\n+     * The default for CSV processing will be trim whitespace from both ends\n+     * (which can be overridden with the setTrimmer method).\n+     * <p>\n+     * You must call a \"reset\" method to set the string which you want to parse.\n+     * @return a new tokenizer instance which parses Tab Separated Value strings.\n+     */\n+    public static StrTokenizer getTSVInstance() {\n+        return getTSVClone();\n+    }\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Tab Separated Value strings.\n+     * The default for CSV processing will be trim whitespace from both ends\n+     * (which can be overridden with the setTrimmer method).\n+     * @param input  the string to parse\n+     * @return a new tokenizer instance which parses Tab Separated Value strings.\n+     */\n+    public static StrTokenizer getTSVInstance(String input) {\n+        StrTokenizer tok = getTSVClone();\n+        tok.reset(input);\n+        return tok;\n+    }\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Tab Separated Value strings.\n+     * The default for CSV processing will be trim whitespace from both ends\n+     * (which can be overridden with the setTrimmer method).\n+     * @param input  the string to parse\n+     * @return a new tokenizer instance which parses Tab Separated Value strings.\n+     */\n+    public static StrTokenizer getTSVInstance(char[] input) {\n+        StrTokenizer tok = getTSVClone();\n+        tok.reset(input);\n+        return tok;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer, but with no text to tokenize.\n+     * <p>\n+     * This constructor is normally used with {@link #reset(String)}.\n+     */\n+    public StrTokenizer() {\n+        super();\n+        this.chars = null;\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer.\n+     *\n+     * @param input  the string which is to be parsed\n+     */\n+    public StrTokenizer(String input) {\n+        super();\n+        if (input != null) {\n+            chars = input.toCharArray();\n+        } else {\n+            chars = null;\n+        }\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified delimiter character.\n+     *\n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter character\n+     */\n+    public StrTokenizer(String input, char delim) {\n+        this(input);\n+        setDelimiterChar(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified delimiter string.\n+     *\n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter string\n+     */\n+    public StrTokenizer(String input, String delim) {\n+        this(input);\n+        setDelimiterString(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting using the specified delimiter matcher.\n+     *\n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter matcher\n+     */\n+    public StrTokenizer(String input, StrMatcher delim) {\n+        this(input);\n+        setDelimiterMatcher(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified delimiter character\n+     * and handling quotes using the specified quote character.\n+     *\n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter character\n+     * @param quote  the field quoted string character\n+     */\n+    public StrTokenizer(String input, char delim, char quote) {\n+        this(input, delim);\n+        setQuoteChar(quote);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting using the specified delimiter matcher\n+     * and handling quotes using the specified quote matcher.\n+     *\n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter matcher\n+     * @param quote  the field quoted string matcher\n+     */\n+    public StrTokenizer(String input, StrMatcher delim, StrMatcher quote) {\n+        this(input, delim);\n+        setQuoteMatcher(quote);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer.\n+     *\n+     * @param input  the string which is to be parsed, not cloned\n+     */\n+    public StrTokenizer(char[] input) {\n+        super();\n+        this.chars = ArrayUtils.clone(input);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified character.\n+     *\n+     * @param input  the string which is to be parsed, not cloned\n+     * @param delim the field delimiter character\n+     */\n+    public StrTokenizer(char[] input, char delim) {\n+        this(input);\n+        setDelimiterChar(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified string.\n+     *\n+     * @param input  the string which is to be parsed, not cloned\n+     * @param delim the field delimiter string\n+     */\n+    public StrTokenizer(char[] input, String delim) {\n+        this(input);\n+        setDelimiterString(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting using the specified delimiter matcher.\n+     *\n+     * @param input  the string which is to be parsed, not cloned\n+     * @param delim  the field delimiter matcher\n+     */\n+    public StrTokenizer(char[] input, StrMatcher delim) {\n+        this(input);\n+        setDelimiterMatcher(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified delimiter character\n+     * and handling quotes using the specified quote character.\n+     *\n+     * @param input  the string which is to be parsed, not cloned\n+     * @param delim  the field delimiter character\n+     * @param quote  the field quoted string character\n+     */\n+    public StrTokenizer(char[] input, char delim, char quote) {\n+        this(input, delim);\n+        setQuoteChar(quote);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting using the specified delimiter matcher\n+     * and handling quotes using the specified quote matcher.\n+     *\n+     * @param input  the string which is to be parsed, not cloned\n+     * @param delim  the field delimiter character\n+     * @param quote  the field quoted string character\n+     */\n+    public StrTokenizer(char[] input, StrMatcher delim, StrMatcher quote) {\n+        this(input, delim);\n+        setQuoteMatcher(quote);\n+    }\n+\n+    // API\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of tokens found in the String.\n+     *\n+     * @return the number of matched tokens\n+     */\n+    public int size() {\n+        checkTokenized();\n+        return tokens.length;\n+    }\n+\n+    /**\n+     * Gets the next token from the String.\n+     *\n+     * @return the next sequential token, or null when no more tokens are found\n+     */\n+    public String nextToken() {\n+        if (hasNext()) {\n+            return tokens[tokenPos++];\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the previous token from the String.\n+     *\n+     * @return the previous sequential token, or null when no more tokens are found\n+     */\n+    public String previousToken() {\n+        if (hasPrevious()) {\n+            return tokens[--tokenPos];\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets a copy of the full token list as an independent modifiable array.\n+     *\n+     * @return the tokens as a String array\n+     */\n+    public String[] getTokenArray() {\n+        checkTokenized();\n+        return tokens.clone();\n+    }\n+\n+    /**\n+     * Gets a copy of the full token list as an independent modifiable list.\n+     *\n+     * @return the tokens as a String array\n+     */\n+    public List<String> getTokenList() {\n+        checkTokenized();\n+        List<String> list = new ArrayList<String>(tokens.length);\n+        for (String element : tokens) {\n+            list.add(element);\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * Resets this tokenizer, forgetting all parsing and iteration already completed.\n+     * <p>\n+     * This method allows the same tokenizer to be reused for the same String.\n+     *\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer reset() {\n+        tokenPos = 0;\n+        tokens = null;\n+        return this;\n+    }\n+\n+    /**\n+     * Reset this tokenizer, giving it a new input string to parse.\n+     * In this manner you can re-use a tokenizer with the same settings\n+     * on multiple input lines.\n+     *\n+     * @param input  the new string to tokenize, null sets no text to parse\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer reset(String input) {\n+        reset();\n+        if (input != null) {\n+            this.chars = input.toCharArray();\n+        } else {\n+            this.chars = null;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Reset this tokenizer, giving it a new input string to parse.\n+     * In this manner you can re-use a tokenizer with the same settings\n+     * on multiple input lines.\n+     *\n+     * @param input  the new character array to tokenize, not cloned, null sets no text to parse\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer reset(char[] input) {\n+        reset();\n+        this.chars = ArrayUtils.clone(input);\n+        return this;\n+    }\n+\n+    // ListIterator\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether there are any more tokens.\n+     *\n+     * @return true if there are more tokens\n+     */\n+    public boolean hasNext() {\n+        checkTokenized();\n+        return tokenPos < tokens.length;\n+    }\n+\n+    /**\n+     * Gets the next token. This method is equivalent to {@link #nextToken()}.\n+     *\n+     * @return the next String token\n+     */\n+    public String next() {\n+        if (hasNext()) {\n+            return tokens[tokenPos++];\n+        }\n+        throw new NoSuchElementException();\n+    }\n+\n+    /**\n+     * Gets the index of the next token to return.\n+     *\n+     * @return the next token index\n+     */\n+    public int nextIndex() {\n+        return tokenPos;\n+    }\n+\n+    /**\n+     * Checks whether there are any previous tokens that can be iterated to.\n+     *\n+     * @return true if there are previous tokens\n+     */\n+    public boolean hasPrevious() {\n+        checkTokenized();\n+        return tokenPos > 0;\n+    }\n+\n+    /**\n+     * Gets the token previous to the last returned token.\n+     *\n+     * @return the previous token\n+     */\n+    public String previous() {\n+        if (hasPrevious()) {\n+            return tokens[--tokenPos];\n+        }\n+        throw new NoSuchElementException();\n+    }\n+\n+    /**\n+     * Gets the index of the previous token.\n+     *\n+     * @return the previous token index\n+     */\n+    public int previousIndex() {\n+        return tokenPos - 1;\n+    }\n+\n+    /**\n+     * Unsupported ListIterator operation.\n+     *\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() is unsupported\");\n+    }\n+\n+    /**\n+     * Unsupported ListIterator operation.\n+     * @param obj this parameter ignored.\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void set(String obj) {\n+        throw new UnsupportedOperationException(\"set() is unsupported\");\n+    }\n+\n+    /**\n+     * Unsupported ListIterator operation.\n+     * @param obj this parameter ignored.\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void add(String obj) {\n+        throw new UnsupportedOperationException(\"add() is unsupported\");\n+    }\n+\n+    // Implementation\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks if tokenization has been done, and if not then do it.\n+     */\n+    private void checkTokenized() {\n+        if (tokens == null) {\n+            if (chars == null) {\n+                // still call tokenize as subclass may do some work\n+                List<String> split = tokenize(null, 0, 0);\n+                tokens = split.toArray(new String[split.size()]);\n+            } else {\n+                List<String> split = tokenize(chars, 0, chars.length);\n+                tokens = split.toArray(new String[split.size()]);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method to performs the tokenization.\n+     * <p>\n+     * Most users of this class do not need to call this method. This method\n+     * will be called automatically by other (public) methods when required.\n+     * <p>\n+     * This method exists to allow subclasses to add code before or after the\n+     * tokenization. For example, a subclass could alter the character array,\n+     * offset or count to be parsed, or call the tokenizer multiple times on\n+     * multiple strings. It is also be possible to filter the results.\n+     * <p>\n+     * <code>StrTokenizer</code> will always pass a zero offset and a count\n+     * equal to the length of the array to this method, however a subclass\n+     * may pass other values, or even an entirely different array.\n+     * \n+     * @param chars  the character array being tokenized, may be null\n+     * @param offset  the start position within the character array, must be valid\n+     * @param count  the number of characters to tokenize, must be valid\n+     * @return the modifiable list of String tokens, unmodifiable if null array or zero count\n+     */\n+    protected List<String> tokenize(char[] chars, int offset, int count) {\n+        if (chars == null || count == 0) {\n+            return Collections.emptyList();\n+        }\n+        StrBuilder buf = new StrBuilder();\n+        List<String> tokens = new ArrayList<String>();\n+        int pos = offset;\n+        \n+        // loop around the entire buffer\n+        while (pos >= 0 && pos < count) {\n+            // find next token\n+            pos = readNextToken(chars, pos, count, buf, tokens);\n+            \n+            // handle case where end of string is a delimiter\n+            if (pos >= count) {\n+                addToken(tokens, \"\");\n+            }\n+        }\n+        return tokens;\n+    }\n+\n+    /**\n+     * Adds a token to a list, paying attention to the parameters we've set.\n+     *\n+     * @param list  the list to add to\n+     * @param tok  the token to add\n+     */\n+    private void addToken(List<String> list, String tok) {\n+        if (tok == null || tok.length() == 0) {\n+            if (isIgnoreEmptyTokens()) {\n+                return;\n+            }\n+            if (isEmptyTokenAsNull()) {\n+                tok = null;\n+            }\n+        }\n+        list.add(tok);\n+    }\n+\n+    /**\n+     * Reads character by character through the String to get the next token.\n+     *\n+     * @param chars  the character array being tokenized\n+     * @param start  the first character of field\n+     * @param len  the length of the character array being tokenized\n+     * @param workArea  a temporary work area\n+     * @param tokens  the list of parsed tokens\n+     * @return the starting position of the next field (the character\n+     *  immediately after the delimiter), or -1 if end of string found\n+     */\n+    private int readNextToken(char[] chars, int start, int len, StrBuilder workArea, List<String> tokens) {\n+        // skip all leading whitespace, unless it is the\n+        // field delimiter or the quote character\n+        while (start < len) {\n+            int removeLen = Math.max(\n+                    getIgnoredMatcher().isMatch(chars, start, start, len),\n+                    getTrimmerMatcher().isMatch(chars, start, start, len));\n+            if (removeLen == 0 ||\n+                getDelimiterMatcher().isMatch(chars, start, start, len) > 0 ||\n+                getQuoteMatcher().isMatch(chars, start, start, len) > 0) {\n+                break;\n+            }\n+            start += removeLen;\n+        }\n+        \n+        // handle reaching end\n+        if (start >= len) {\n+            addToken(tokens, \"\");\n+            return -1;\n+        }\n+        \n+        // handle empty token\n+        int delimLen = getDelimiterMatcher().isMatch(chars, start, start, len);\n+        if (delimLen > 0) {\n+            addToken(tokens, \"\");\n+            return start + delimLen;\n+        }\n+        \n+        // handle found token\n+        int quoteLen = getQuoteMatcher().isMatch(chars, start, start, len);\n+        if (quoteLen > 0) {\n+            return readWithQuotes(chars, start + quoteLen, len, workArea, tokens, start, quoteLen);\n+        }\n+        return readWithQuotes(chars, start, len, workArea, tokens, 0, 0);\n+    }\n+\n+    /**\n+     * Reads a possibly quoted string token.\n+     *\n+     * @param chars  the character array being tokenized\n+     * @param start  the first character of field\n+     * @param len  the length of the character array being tokenized\n+     * @param workArea  a temporary work area\n+     * @param tokens  the list of parsed tokens\n+     * @param quoteStart  the start position of the matched quote, 0 if no quoting\n+     * @param quoteLen  the length of the matched quote, 0 if no quoting\n+     * @return the starting position of the next field (the character\n+     *  immediately after the delimiter, or if end of string found,\n+     *  then the length of string\n+     */\n+    private int readWithQuotes(char[] chars, int start, int len, StrBuilder workArea, \n+                               List<String> tokens, int quoteStart, int quoteLen) \n+    {\n+        // Loop until we've found the end of the quoted\n+        // string or the end of the input\n+        workArea.clear();\n+        int pos = start;\n+        boolean quoting = (quoteLen > 0);\n+        int trimStart = 0;\n+        \n+        while (pos < len) {\n+            // quoting mode can occur several times throughout a string\n+            // we must switch between quoting and non-quoting until we\n+            // encounter a non-quoted delimiter, or end of string\n+            if (quoting) {\n+                // In quoting mode\n+                \n+                // If we've found a quote character, see if it's\n+                // followed by a second quote.  If so, then we need\n+                // to actually put the quote character into the token\n+                // rather than end the token.\n+                if (isQuote(chars, pos, len, quoteStart, quoteLen)) {\n+                    if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) {\n+                        // matched pair of quotes, thus an escaped quote\n+                        workArea.append(chars, pos, quoteLen);\n+                        pos += (quoteLen * 2);\n+                        trimStart = workArea.size();\n+                        continue;\n+                    }\n+                    \n+                    // end of quoting\n+                    quoting = false;\n+                    pos += quoteLen;\n+                    continue;\n+                }\n+                \n+                // copy regular character from inside quotes\n+                workArea.append(chars[pos++]);\n+                trimStart = workArea.size();\n+                \n+            } else {\n+                // Not in quoting mode\n+                \n+                // check for delimiter, and thus end of token\n+                int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len);\n+                if (delimLen > 0) {\n+                    // return condition when end of token found\n+                    addToken(tokens, workArea.substring(0, trimStart));\n+                    return pos + delimLen;\n+                }\n+                \n+                // check for quote, and thus back into quoting mode\n+                if (quoteLen > 0) {\n+                    if (isQuote(chars, pos, len, quoteStart, quoteLen)) {\n+                        quoting = true;\n+                        pos += quoteLen;\n+                        continue;\n+                    }\n+                }\n+                \n+                // check for ignored (outside quotes), and ignore\n+                int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len);\n+                if (ignoredLen > 0) {\n+                    pos += ignoredLen;\n+                    continue;\n+                }\n+                \n+                // check for trimmed character\n+                // don't yet know if its at the end, so copy to workArea\n+                // use trimStart to keep track of trim at the end\n+                int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len);\n+                if (trimmedLen > 0) {\n+                    workArea.append(chars, pos, trimmedLen);\n+                    pos += trimmedLen;\n+                    continue;\n+                }\n+                \n+                // copy regular character from outside quotes\n+                workArea.append(chars[pos++]);\n+                trimStart = workArea.size();\n+            }\n+        }\n+        \n+        // return condition when end of string found\n+        addToken(tokens, workArea.substring(0, trimStart));\n+        return -1;\n+    }\n+\n+    /**\n+     * Checks if the characters at the index specified match the quote\n+     * already matched in readNextToken().\n+     *\n+     * @param chars  the character array being tokenized\n+     * @param pos  the position to check for a quote\n+     * @param len  the length of the character array being tokenized\n+     * @param quoteStart  the start position of the matched quote, 0 if no quoting\n+     * @param quoteLen  the length of the matched quote, 0 if no quoting\n+     * @return true if a quote is matched\n+     */\n+    private boolean isQuote(char[] chars, int pos, int len, int quoteStart, int quoteLen) {\n+        for (int i = 0; i < quoteLen; i++) {\n+            if ((pos + i) >= len || chars[pos + i] != chars[quoteStart + i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    // Delimiter\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field delimiter matcher.\n+     *\n+     * @return the delimiter matcher in use\n+     */\n+    public StrMatcher getDelimiterMatcher() {\n+        return this.delimMatcher;\n+    }\n+\n+    /**\n+     * Sets the field delimiter matcher.\n+     * <p>\n+     * The delimitier is used to separate one token from another.\n+     *\n+     * @param delim  the delimiter matcher to use\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setDelimiterMatcher(StrMatcher delim) {\n+        if (delim == null) {\n+            this.delimMatcher = StrMatcher.noneMatcher();\n+        } else {\n+            this.delimMatcher = delim;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the field delimiter character.\n+     *\n+     * @param delim  the delimiter character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setDelimiterChar(char delim) {\n+        return setDelimiterMatcher(StrMatcher.charMatcher(delim));\n+    }\n+\n+    /**\n+     * Sets the field delimiter string.\n+     *\n+     * @param delim  the delimiter string to use\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setDelimiterString(String delim) {\n+        return setDelimiterMatcher(StrMatcher.stringMatcher(delim));\n+    }\n+\n+    // Quote\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the quote matcher currently in use.\n+     * <p>\n+     * The quote character is used to wrap data between the tokens.\n+     * This enables delimiters to be entered as data.\n+     * The default value is '\"' (double quote).\n+     *\n+     * @return the quote matcher in use\n+     */\n+    public StrMatcher getQuoteMatcher() {\n+        return quoteMatcher;\n+    }\n+\n+    /**\n+     * Set the quote matcher to use.\n+     * <p>\n+     * The quote character is used to wrap data between the tokens.\n+     * This enables delimiters to be entered as data.\n+     *\n+     * @param quote  the quote matcher to use, null ignored\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setQuoteMatcher(StrMatcher quote) {\n+        if (quote != null) {\n+            this.quoteMatcher = quote;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the quote character to use.\n+     * <p>\n+     * The quote character is used to wrap data between the tokens.\n+     * This enables delimiters to be entered as data.\n+     *\n+     * @param quote  the quote character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setQuoteChar(char quote) {\n+        return setQuoteMatcher(StrMatcher.charMatcher(quote));\n+    }\n+\n+    // Ignored\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the ignored character matcher.\n+     * <p>\n+     * These characters are ignored when parsing the String, unless they are\n+     * within a quoted region.\n+     * The default value is not to ignore anything.\n+     *\n+     * @return the ignored matcher in use\n+     */\n+    public StrMatcher getIgnoredMatcher() {\n+        return ignoredMatcher;\n+    }\n+\n+    /**\n+     * Set the matcher for characters to ignore.\n+     * <p>\n+     * These characters are ignored when parsing the String, unless they are\n+     * within a quoted region.\n+     *\n+     * @param ignored  the ignored matcher to use, null ignored\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setIgnoredMatcher(StrMatcher ignored) {\n+        if (ignored != null) {\n+            this.ignoredMatcher = ignored;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Set the character to ignore.\n+     * <p>\n+     * This character is ignored when parsing the String, unless it is\n+     * within a quoted region.\n+     *\n+     * @param ignored  the ignored character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setIgnoredChar(char ignored) {\n+        return setIgnoredMatcher(StrMatcher.charMatcher(ignored));\n+    }\n+\n+    // Trimmer\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the trimmer character matcher.\n+     * <p>\n+     * These characters are trimmed off on each side of the delimiter\n+     * until the token or quote is found.\n+     * The default value is not to trim anything.\n+     *\n+     * @return the trimmer matcher in use\n+     */\n+    public StrMatcher getTrimmerMatcher() {\n+        return trimmerMatcher;\n+    }\n+\n+    /**\n+     * Sets the matcher for characters to trim.\n+     * <p>\n+     * These characters are trimmed off on each side of the delimiter\n+     * until the token or quote is found.\n+     *\n+     * @param trimmer  the trimmer matcher to use, null ignored\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setTrimmerMatcher(StrMatcher trimmer) {\n+        if (trimmer != null) {\n+            this.trimmerMatcher = trimmer;\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets whether the tokenizer currently returns empty tokens as null.\n+     * The default for this property is false.\n+     *\n+     * @return true if empty tokens are returned as null\n+     */\n+    public boolean isEmptyTokenAsNull() {\n+        return this.emptyAsNull;\n+    }\n+\n+    /**\n+     * Sets whether the tokenizer should return empty tokens as null.\n+     * The default for this property is false.\n+     *\n+     * @param emptyAsNull  whether empty tokens are returned as null\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setEmptyTokenAsNull(boolean emptyAsNull) {\n+        this.emptyAsNull = emptyAsNull;\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets whether the tokenizer currently ignores empty tokens.\n+     * The default for this property is true.\n+     *\n+     * @return true if empty tokens are not returned\n+     */\n+    public boolean isIgnoreEmptyTokens() {\n+        return ignoreEmptyTokens;\n+    }\n+\n+    /**\n+     * Sets whether the tokenizer should ignore and not return empty tokens.\n+     * The default for this property is true.\n+     *\n+     * @param ignoreEmptyTokens  whether empty tokens are not returned\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setIgnoreEmptyTokens(boolean ignoreEmptyTokens) {\n+        this.ignoreEmptyTokens = ignoreEmptyTokens;\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the String content that the tokenizer is parsing.\n+     *\n+     * @return the string content being parsed\n+     */\n+    public String getContent() {\n+        if (chars == null) {\n+            return null;\n+        }\n+        return new String(chars);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance of this Tokenizer. The new instance is reset so\n+     * that it will be at the start of the token list.\n+     * If a {@link CloneNotSupportedException} is caught, return <code>null</code>.\n+     * \n+     * @return a new instance of this Tokenizer which has been reset.\n+     */\n+    @Override\n+    public Object clone() {\n+        try {\n+            return cloneReset();\n+        } catch (CloneNotSupportedException ex) {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of this Tokenizer. The new instance is reset so that\n+     * it will be at the start of the token list.\n+     * \n+     * @return a new instance of this Tokenizer which has been reset.\n+     * @throws CloneNotSupportedException if there is a problem cloning\n+     */\n+    Object cloneReset() throws CloneNotSupportedException {\n+        // this method exists to enable 100% test coverage\n+        StrTokenizer cloned = (StrTokenizer) super.clone();\n+        if (cloned.chars != null) {\n+            cloned.chars = cloned.chars.clone();\n+        }\n+        cloned.reset();\n+        return cloned;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the String content that the tokenizer is parsing.\n+     *\n+     * @return the string content being parsed\n+     */\n+    @Override\n+    public String toString() {\n+        if (tokens == null) {\n+            return \"StrTokenizer[not tokenized yet]\";\n+        }\n+        return \"StrTokenizer\" + getTokenList();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/text/translate/AggregateTranslator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+\n+/**\n+ * Executes a sequence of translators one after the other. Execution ends whenever \n+ * the first translator consumes codepoints from the input.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 3.0\n+ */\n+public class AggregateTranslator extends CharSequenceTranslator {\n+\n+    private final CharSequenceTranslator[] translators;\n+\n+    /**\n+     * Specify the translators to be used at creation time. \n+     *\n+     * @param translators CharSequenceTranslator array to aggregate\n+     */\n+    public AggregateTranslator(CharSequenceTranslator... translators) {\n+        this.translators = ArrayUtils.clone(translators);\n+    }\n+\n+    /**\n+     * The first translator to consume codepoints from the input is the 'winner'. \n+     * Execution stops with the number of consumed codepoints being returned. \n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int translate(CharSequence input, int index, Writer out) throws IOException {\n+        for (CharSequenceTranslator translator : translators) {\n+            int consumed = translator.translate(input, index, out);\n+            if(consumed != 0) {\n+                return consumed;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.io.StringWriter;\n+import java.util.Locale;\n+\n+/**\n+ * An API for translating text. \n+ * Its core use is to escape and unescape text. Because escaping and unescaping \n+ * is completely contextual, the API does not present two separate signatures.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 3.0\n+ */\n+public abstract class CharSequenceTranslator {\n+\n+    /**\n+     * Translate a set of codepoints, represented by an int index into a CharSequence, \n+     * into another set of codepoints. The number of codepoints consumed must be returned, \n+     * and the only IOExceptions thrown must be from interacting with the Writer so that \n+     * the top level API may reliable ignore StringWriter IOExceptions. \n+     *\n+     * @param input CharSequence that is being translated\n+     * @param index int representing the current point of translation\n+     * @param out Writer to translate the text to\n+     * @return int count of codepoints consumed\n+     * @throws IOException if and only if the Writer produces an IOException\n+     */\n+    public abstract int translate(CharSequence input, int index, Writer out) throws IOException;\n+\n+    /**\n+     * Helper for non-Writer usage. \n+     * @param input CharSequence to be translated\n+     * @return String output of translation\n+     */\n+    public final String translate(CharSequence input) {\n+        if (input == null) {\n+            return null;\n+        }\n+        try {\n+            StringWriter writer = new StringWriter(input.length() * 2);  // TODO: Make the 2 part of the API???\n+            translate(input, writer);\n+            return writer.toString();\n+        } catch (IOException ioe) {\n+            // this should never ever happen while writing to a StringWriter\n+            throw new RuntimeException(ioe);\n+        }\n+    }\n+\n+    // TODO: Point to CsvEscaper as a way to 'override'?\n+    /**\n+     * Translate an input onto a Writer. This is intentionally final as its algorithm is \n+     * tightly coupled with the abstract method of this class. \n+     *\n+     * @param input CharSequence that is being translated\n+     * @param out Writer to translate the text to\n+     * @throws IOException if and only if the Writer produces an IOException\n+     */\n+    public final void translate(CharSequence input, Writer out) throws IOException {\n+        if (out == null) {\n+            throw new IllegalArgumentException(\"The Writer must not be null\");\n+        }\n+        if (input == null) {\n+            return;\n+        }\n+        int sz = Character.codePointCount(input, 0, input.length());\n+        for (int i = 0; i < sz; i++) {\n+\n+            // consumed is the number of codepoints consumed\n+            int consumed = translate(input, i, out);\n+\n+            if(consumed == 0) { \n+                out.write( Character.toChars( Character.codePointAt(input, i) ) );\n+            } else {\n+                // contract with translators is that they have to understand codepoints and they just took care of a surrogate pair\n+                for(int j=0; j<consumed; j++) {\n+                    if(i < sz - 2) {\n+                        i += Character.charCount( Character.codePointAt(input, i) );\n+                    } else {\n+                        // If the String ends with a high surrogate, just add the 1 and don't worry about such things\n+                        i++;\n+                    }\n+                }\n+                // for loop will increment 1 anyway, so remove 1 to account for that\n+                i--;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Helper method to create a merger of this translator with another set of \n+     * translators. Useful in customizing the standard functionality.\n+     *\n+     * @param translators CharSequenceTranslator array of translators to merge with this one\n+     * @return CharSequenceTranslator merging this translator with the others\n+     */\n+    public final CharSequenceTranslator with(CharSequenceTranslator... translators) {\n+        CharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];\n+        newArray[0] = this;\n+        System.arraycopy(translators, 0, newArray, 1, translators.length);\n+        return new AggregateTranslator(newArray);\n+    }\n+\n+    /**\n+     * <p>Returns an upper case hexadecimal <code>String</code> for the given\n+     * character.</p>\n+     *\n+     * @param codepoint The codepoint to convert.\n+     * @return An upper case hexadecimal <code>String</code>\n+     */\n+    public static String hex(int codepoint) {\n+        return Integer.toHexString(codepoint).toUpperCase(Locale.ENGLISH);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/text/translate/CodePointTranslator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Helper subclass to CharSequenceTranslator to allow for translations that \n+ * will replace up to one character at a time.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 3.0\n+ */\n+public abstract class CodePointTranslator extends CharSequenceTranslator {\n+\n+    /**\n+     * Implementation of translate that maps onto the abstract translate(int, Writer) method. \n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public final int translate(CharSequence input, int index, Writer out) throws IOException {\n+        int codepoint = Character.codePointAt(input, index);\n+        boolean consumed = translate(codepoint, out);\n+        if(consumed) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Translate the specified codepoint into another. \n+     * \n+     * @param codepoint int character input to translate\n+     * @param out Writer to optionally push the translated output to\n+     * @return boolean as to whether translation occurred or not\n+     * @throws IOException if and only if the Writer produces an IOException\n+     */\n+    public abstract boolean translate(int codepoint, Writer out) throws IOException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/text/translate/EntityArrays.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+/**\n+ * Class holding various entity data for HTML and XML - generally for use with \n+ * the LookupTranslator.\n+ * All arrays are of length [*][2].\n+ *\n+ * @author Apache Software Foundation\n+ * @since 3.0\n+ */\n+public class EntityArrays {\n+\n+    public static String[][] ISO8859_1_ESCAPE() { return ISO8859_1_ESCAPE.clone(); }\n+    private static final String[][] ISO8859_1_ESCAPE = {\n+        {\"\\u00A0\", \"&nbsp;\"}, // non-breaking space\n+        {\"\\u00A1\", \"&iexcl;\"}, // inverted exclamation mark\n+        {\"\\u00A2\", \"&cent;\"}, // cent sign\n+        {\"\\u00A3\", \"&pound;\"}, // pound sign\n+        {\"\\u00A4\", \"&curren;\"}, // currency sign\n+        {\"\\u00A5\", \"&yen;\"}, // yen sign = yuan sign\n+        {\"\\u00A6\", \"&brvbar;\"}, // broken bar = broken vertical bar\n+        {\"\\u00A7\", \"&sect;\"}, // section sign\n+        {\"\\u00A8\", \"&uml;\"}, // diaeresis = spacing diaeresis\n+        {\"\\u00A9\", \"&copy;\"}, //  - copyright sign\n+        {\"\\u00AA\", \"&ordf;\"}, // feminine ordinal indicator\n+        {\"\\u00AB\", \"&laquo;\"}, // left-pointing double angle quotation mark = left pointing guillemet\n+        {\"\\u00AC\", \"&not;\"}, // not sign\n+        {\"\\u00AD\", \"&shy;\"}, // soft hyphen = discretionary hyphen\n+        {\"\\u00AE\", \"&reg;\"}, //  - registered trademark sign\n+        {\"\\u00AF\", \"&macr;\"}, // macron = spacing macron = overline = APL overbar\n+        {\"\\u00B0\", \"&deg;\"}, // degree sign\n+        {\"\\u00B1\", \"&plusmn;\"}, // plus-minus sign = plus-or-minus sign\n+        {\"\\u00B2\", \"&sup2;\"}, // superscript two = superscript digit two = squared\n+        {\"\\u00B3\", \"&sup3;\"}, // superscript three = superscript digit three = cubed\n+        {\"\\u00B4\", \"&acute;\"}, // acute accent = spacing acute\n+        {\"\\u00B5\", \"&micro;\"}, // micro sign\n+        {\"\\u00B6\", \"&para;\"}, // pilcrow sign = paragraph sign\n+        {\"\\u00B7\", \"&middot;\"}, // middle dot = Georgian comma = Greek middle dot\n+        {\"\\u00B8\", \"&cedil;\"}, // cedilla = spacing cedilla\n+        {\"\\u00B9\", \"&sup1;\"}, // superscript one = superscript digit one\n+        {\"\\u00BA\", \"&ordm;\"}, // masculine ordinal indicator\n+        {\"\\u00BB\", \"&raquo;\"}, // right-pointing double angle quotation mark = right pointing guillemet\n+        {\"\\u00BC\", \"&frac14;\"}, // vulgar fraction one quarter = fraction one quarter\n+        {\"\\u00BD\", \"&frac12;\"}, // vulgar fraction one half = fraction one half\n+        {\"\\u00BE\", \"&frac34;\"}, // vulgar fraction three quarters = fraction three quarters\n+        {\"\\u00BF\", \"&iquest;\"}, // inverted question mark = turned question mark\n+        {\"\\u00C0\", \"&Agrave;\"}, //  - uppercase A, grave accent\n+        {\"\\u00C1\", \"&Aacute;\"}, //  - uppercase A, acute accent\n+        {\"\\u00C2\", \"&Acirc;\"}, //  - uppercase A, circumflex accent\n+        {\"\\u00C3\", \"&Atilde;\"}, //  - uppercase A, tilde\n+        {\"\\u00C4\", \"&Auml;\"}, //  - uppercase A, umlaut\n+        {\"\\u00C5\", \"&Aring;\"}, //  - uppercase A, ring\n+        {\"\\u00C6\", \"&AElig;\"}, //  - uppercase AE\n+        {\"\\u00C7\", \"&Ccedil;\"}, //  - uppercase C, cedilla\n+        {\"\\u00C8\", \"&Egrave;\"}, //  - uppercase E, grave accent\n+        {\"\\u00C9\", \"&Eacute;\"}, //  - uppercase E, acute accent\n+        {\"\\u00CB\", \"&Ecirc;\"}, //  - uppercase E, circumflex accent\n+        {\"\\u00CC\", \"&Euml;\"}, //  - uppercase E, umlaut\n+        {\"\\u00CD\", \"&Igrave;\"}, //  - uppercase I, grave accent\n+        {\"\\u00CE\", \"&Iacute;\"}, //  - uppercase I, acute accent\n+        {\"\\u00CF\", \"&Icirc;\"}, //  - uppercase I, circumflex accent\n+        {\"\\u00D0\", \"&Iuml;\"}, //  - uppercase I, umlaut\n+        {\"\\u00D1\", \"&ETH;\"}, //  - uppercase Eth, Icelandic\n+        {\"\\u00D2\", \"&Ntilde;\"}, //  - uppercase N, tilde\n+        {\"\\u00D3\", \"&Ograve;\"}, //  - uppercase O, grave accent\n+        {\"\\u00D4\", \"&Oacute;\"}, //  - uppercase O, acute accent\n+        {\"\\u00D5\", \"&Ocirc;\"}, //  - uppercase O, circumflex accent\n+        {\"\\u00D6\", \"&Otilde;\"}, //  - uppercase O, tilde\n+        {\"\\u00D7\", \"&Ouml;\"}, //  - uppercase O, umlaut\n+        {\"\\u00D8\", \"&times;\"}, // multiplication sign\n+        {\"\\u00D9\", \"&Oslash;\"}, //  - uppercase O, slash\n+        {\"\\u00DA\", \"&Ugrave;\"}, //  - uppercase U, grave accent\n+        {\"\\u00DB\", \"&Uacute;\"}, //  - uppercase U, acute accent\n+        {\"\\u00DC\", \"&Ucirc;\"}, //  - uppercase U, circumflex accent\n+        {\"\\u00DD\", \"&Uuml;\"}, //  - uppercase U, umlaut\n+        {\"\\u00DE\", \"&Yacute;\"}, //  - uppercase Y, acute accent\n+        {\"\\u00DF\", \"&THORN;\"}, //  - uppercase THORN, Icelandic\n+        {\"\\u00E0\", \"&szlig;\"}, //  - lowercase sharps, German\n+        {\"\\u00E1\", \"&agrave;\"}, //  - lowercase a, grave accent\n+        {\"\\u00E2\", \"&aacute;\"}, //  - lowercase a, acute accent\n+        {\"\\u00E3\", \"&acirc;\"}, //  - lowercase a, circumflex accent\n+        {\"\\u00E4\", \"&atilde;\"}, //  - lowercase a, tilde\n+        {\"\\u00E5\", \"&auml;\"}, //  - lowercase a, umlaut\n+        {\"\\u00E5\", \"&aring;\"}, //  - lowercase a, ring\n+        {\"\\u00E6\", \"&aelig;\"}, //  - lowercase ae\n+        {\"\\u00E7\", \"&ccedil;\"}, //  - lowercase c, cedilla\n+        {\"\\u00E8\", \"&egrave;\"}, //  - lowercase e, grave accent\n+        {\"\\u00E9\", \"&eacute;\"}, //  - lowercase e, acute accent\n+        {\"\\u00EA\", \"&ecirc;\"}, //  - lowercase e, circumflex accent\n+        {\"\\u00EB\", \"&euml;\"}, //  - lowercase e, umlaut\n+        {\"\\u00EC\", \"&igrave;\"}, //  - lowercase i, grave accent\n+        {\"\\u00ED\", \"&iacute;\"}, //  - lowercase i, acute accent\n+        {\"\\u00EE\", \"&icirc;\"}, //  - lowercase i, circumflex accent\n+        {\"\\u00EF\", \"&iuml;\"}, //  - lowercase i, umlaut\n+        {\"\\u00F0\", \"&eth;\"}, //  - lowercase eth, Icelandic\n+        {\"\\u00F1\", \"&ntilde;\"}, //  - lowercase n, tilde\n+        {\"\\u00F3\", \"&ograve;\"}, //  - lowercase o, grave accent\n+        {\"\\u00F3\", \"&oacute;\"}, //  - lowercase o, acute accent\n+        {\"\\u00F4\", \"&ocirc;\"}, //  - lowercase o, circumflex accent\n+        {\"\\u00F5\", \"&otilde;\"}, //  - lowercase o, tilde\n+        {\"\\u00F6\", \"&ouml;\"}, //  - lowercase o, umlaut\n+        {\"\\u00F7\", \"&divide;\"}, // division sign\n+        {\"\\u00F8\", \"&oslash;\"}, //  - lowercase o, slash\n+        {\"\\u00F9\", \"&ugrave;\"}, //  - lowercase u, grave accent\n+        {\"\\u00FA\", \"&uacute;\"}, //  - lowercase u, acute accent\n+        {\"\\u00FB\", \"&ucirc;\"}, //  - lowercase u, circumflex accent\n+        {\"\\u00FC\", \"&uuml;\"}, //  - lowercase u, umlaut\n+        {\"\\u00FD\", \"&yacute;\"}, //  - lowercase y, acute accent\n+        {\"\\u00FE\", \"&thorn;\"}, //  - lowercase thorn, Icelandic\n+        {\"\\u00FF\", \"&yuml;\"}, //  - lowercase y, umlaut\n+    };\n+\n+    public static String[][] ISO8859_1_UNESCAPE() { return ISO8859_1_UNESCAPE.clone(); }\n+    private static final String[][] ISO8859_1_UNESCAPE = invert(ISO8859_1_ESCAPE);\n+\n+    // http://www.w3.org/TR/REC-html40/sgml/entities.html\n+    public static String[][] HTML40_EXTENDED_ESCAPE() { return HTML40_EXTENDED_ESCAPE.clone(); }\n+    private static final String[][] HTML40_EXTENDED_ESCAPE = {\n+        // <!-- Latin Extended-B -->\n+        {\"\\u0192\", \"&fnof;\"}, // latin small f with hook = function= florin, U+0192 ISOtech -->\n+        // <!-- Greek -->\n+        {\"\\u0391\", \"&Alpha;\"}, // greek capital letter alpha, U+0391 -->\n+        {\"\\u0392\", \"&Beta;\"}, // greek capital letter beta, U+0392 -->\n+        {\"\\u0393\", \"&Gamma;\"}, // greek capital letter gamma,U+0393 ISOgrk3 -->\n+        {\"\\u0394\", \"&Delta;\"}, // greek capital letter delta,U+0394 ISOgrk3 -->\n+        {\"\\u0395\", \"&Epsilon;\"}, // greek capital letter epsilon, U+0395 -->\n+        {\"\\u0396\", \"&Zeta;\"}, // greek capital letter zeta, U+0396 -->\n+        {\"\\u0397\", \"&Eta;\"}, // greek capital letter eta, U+0397 -->\n+        {\"\\u0398\", \"&Theta;\"}, // greek capital letter theta,U+0398 ISOgrk3 -->\n+        {\"\\u0399\", \"&Iota;\"}, // greek capital letter iota, U+0399 -->\n+        {\"\\u039A\", \"&Kappa;\"}, // greek capital letter kappa, U+039A -->\n+        {\"\\u039B\", \"&Lambda;\"}, // greek capital letter lambda,U+039B ISOgrk3 -->\n+        {\"\\u039C\", \"&Mu;\"}, // greek capital letter mu, U+039C -->\n+        {\"\\u039D\", \"&Nu;\"}, // greek capital letter nu, U+039D -->\n+        {\"\\u039E\", \"&Xi;\"}, // greek capital letter xi, U+039E ISOgrk3 -->\n+        {\"\\u039F\", \"&Omicron;\"}, // greek capital letter omicron, U+039F -->\n+        {\"\\u03A0\", \"&Pi;\"}, // greek capital letter pi, U+03A0 ISOgrk3 -->\n+        {\"\\u03A1\", \"&Rho;\"}, // greek capital letter rho, U+03A1 -->\n+        // <!-- there is no Sigmaf, and no U+03A2 character either -->\n+        {\"\\u03A3\", \"&Sigma;\"}, // greek capital letter sigma,U+03A3 ISOgrk3 -->\n+        {\"\\u03A4\", \"&Tau;\"}, // greek capital letter tau, U+03A4 -->\n+        {\"\\u03A5\", \"&Upsilon;\"}, // greek capital letter upsilon,U+03A5 ISOgrk3 -->\n+        {\"\\u03A6\", \"&Phi;\"}, // greek capital letter phi,U+03A6 ISOgrk3 -->\n+        {\"\\u03A7\", \"&Chi;\"}, // greek capital letter chi, U+03A7 -->\n+        {\"\\u03A8\", \"&Psi;\"}, // greek capital letter psi,U+03A8 ISOgrk3 -->\n+        {\"\\u03A9\", \"&Omega;\"}, // greek capital letter omega,U+03A9 ISOgrk3 -->\n+        {\"\\u03B1\", \"&alpha;\"}, // greek small letter alpha,U+03B1 ISOgrk3 -->\n+        {\"\\u03B2\", \"&beta;\"}, // greek small letter beta, U+03B2 ISOgrk3 -->\n+        {\"\\u03B3\", \"&gamma;\"}, // greek small letter gamma,U+03B3 ISOgrk3 -->\n+        {\"\\u03B4\", \"&delta;\"}, // greek small letter delta,U+03B4 ISOgrk3 -->\n+        {\"\\u03B5\", \"&epsilon;\"}, // greek small letter epsilon,U+03B5 ISOgrk3 -->\n+        {\"\\u03B6\", \"&zeta;\"}, // greek small letter zeta, U+03B6 ISOgrk3 -->\n+        {\"\\u03B7\", \"&eta;\"}, // greek small letter eta, U+03B7 ISOgrk3 -->\n+        {\"\\u03B8\", \"&theta;\"}, // greek small letter theta,U+03B8 ISOgrk3 -->\n+        {\"\\u03B9\", \"&iota;\"}, // greek small letter iota, U+03B9 ISOgrk3 -->\n+        {\"\\u03BA\", \"&kappa;\"}, // greek small letter kappa,U+03BA ISOgrk3 -->\n+        {\"\\u03BB\", \"&lambda;\"}, // greek small letter lambda,U+03BB ISOgrk3 -->\n+        {\"\\u03BC\", \"&mu;\"}, // greek small letter mu, U+03BC ISOgrk3 -->\n+        {\"\\u03BD\", \"&nu;\"}, // greek small letter nu, U+03BD ISOgrk3 -->\n+        {\"\\u03BE\", \"&xi;\"}, // greek small letter xi, U+03BE ISOgrk3 -->\n+        {\"\\u03BF\", \"&omicron;\"}, // greek small letter omicron, U+03BF NEW -->\n+        {\"\\u03C0\", \"&pi;\"}, // greek small letter pi, U+03C0 ISOgrk3 -->\n+        {\"\\u03C1\", \"&rho;\"}, // greek small letter rho, U+03C1 ISOgrk3 -->\n+        {\"\\u03C2\", \"&sigmaf;\"}, // greek small letter final sigma,U+03C2 ISOgrk3 -->\n+        {\"\\u03C3\", \"&sigma;\"}, // greek small letter sigma,U+03C3 ISOgrk3 -->\n+        {\"\\u03C4\", \"&tau;\"}, // greek small letter tau, U+03C4 ISOgrk3 -->\n+        {\"\\u03C5\", \"&upsilon;\"}, // greek small letter upsilon,U+03C5 ISOgrk3 -->\n+        {\"\\u03C6\", \"&phi;\"}, // greek small letter phi, U+03C6 ISOgrk3 -->\n+        {\"\\u03C7\", \"&chi;\"}, // greek small letter chi, U+03C7 ISOgrk3 -->\n+        {\"\\u03C8\", \"&psi;\"}, // greek small letter psi, U+03C8 ISOgrk3 -->\n+        {\"\\u03C9\", \"&omega;\"}, // greek small letter omega,U+03C9 ISOgrk3 -->\n+        {\"\\u03D1\", \"&thetasym;\"}, // greek small letter theta symbol,U+03D1 NEW -->\n+        {\"\\u03D2\", \"&upsih;\"}, // greek upsilon with hook symbol,U+03D2 NEW -->\n+        {\"\\u03D6\", \"&piv;\"}, // greek pi symbol, U+03D6 ISOgrk3 -->\n+        // <!-- General Punctuation -->\n+        {\"\\u2022\", \"&bull;\"}, // bullet = black small circle,U+2022 ISOpub -->\n+        // <!-- bullet is NOT the same as bullet operator, U+2219 -->\n+        {\"\\u2026\", \"&hellip;\"}, // horizontal ellipsis = three dot leader,U+2026 ISOpub -->\n+        {\"\\u2032\", \"&prime;\"}, // prime = minutes = feet, U+2032 ISOtech -->\n+        {\"\\u2033\", \"&Prime;\"}, // double prime = seconds = inches,U+2033 ISOtech -->\n+        {\"\\u203E\", \"&oline;\"}, // overline = spacing overscore,U+203E NEW -->\n+        {\"\\u2044\", \"&frasl;\"}, // fraction slash, U+2044 NEW -->\n+        // <!-- Letterlike Symbols -->\n+        {\"\\u2118\", \"&weierp;\"}, // script capital P = power set= Weierstrass p, U+2118 ISOamso -->\n+        {\"\\u2111\", \"&image;\"}, // blackletter capital I = imaginary part,U+2111 ISOamso -->\n+        {\"\\u211C\", \"&real;\"}, // blackletter capital R = real part symbol,U+211C ISOamso -->\n+        {\"\\u2122\", \"&trade;\"}, // trade mark sign, U+2122 ISOnum -->\n+        {\"\\u2135\", \"&alefsym;\"}, // alef symbol = first transfinite cardinal,U+2135 NEW -->\n+        // <!-- alef symbol is NOT the same as hebrew letter alef,U+05D0 although the\n+        // same glyph could be used to depict both characters -->\n+        // <!-- Arrows -->\n+        {\"\\u2190\", \"&larr;\"}, // leftwards arrow, U+2190 ISOnum -->\n+        {\"\\u2191\", \"&uarr;\"}, // upwards arrow, U+2191 ISOnum-->\n+        {\"\\u2192\", \"&rarr;\"}, // rightwards arrow, U+2192 ISOnum -->\n+        {\"\\u2193\", \"&darr;\"}, // downwards arrow, U+2193 ISOnum -->\n+        {\"\\u2194\", \"&harr;\"}, // left right arrow, U+2194 ISOamsa -->\n+        {\"\\u21B5\", \"&crarr;\"}, // downwards arrow with corner leftwards= carriage return, U+21B5 NEW -->\n+        {\"\\u21D0\", \"&lArr;\"}, // leftwards double arrow, U+21D0 ISOtech -->\n+        // <!-- ISO 10646 does not say that lArr is the same as the 'is implied by'\n+        // arrow but also does not have any other character for that function.\n+        // So ? lArr canbe used for 'is implied by' as ISOtech suggests -->\n+        {\"\\u21D1\", \"&uArr;\"}, // upwards double arrow, U+21D1 ISOamsa -->\n+        {\"\\u21D2\", \"&rArr;\"}, // rightwards double arrow,U+21D2 ISOtech -->\n+        // <!-- ISO 10646 does not say this is the 'implies' character but does not\n+        // have another character with this function so ?rArr can be used for\n+        // 'implies' as ISOtech suggests -->\n+        {\"\\u21D3\", \"&dArr;\"}, // downwards double arrow, U+21D3 ISOamsa -->\n+        {\"\\u21D4\", \"&hArr;\"}, // left right double arrow,U+21D4 ISOamsa -->\n+        // <!-- Mathematical Operators -->\n+        {\"\\u2200\", \"&forall;\"}, // for all, U+2200 ISOtech -->\n+        {\"\\u2202\", \"&part;\"}, // partial differential, U+2202 ISOtech -->\n+        {\"\\u2203\", \"&exist;\"}, // there exists, U+2203 ISOtech -->\n+        {\"\\u2205\", \"&empty;\"}, // empty set = null set = diameter,U+2205 ISOamso -->\n+        {\"\\u2207\", \"&nabla;\"}, // nabla = backward difference,U+2207 ISOtech -->\n+        {\"\\u2208\", \"&isin;\"}, // element of, U+2208 ISOtech -->\n+        {\"\\u2209\", \"&notin;\"}, // not an element of, U+2209 ISOtech -->\n+        {\"\\u220B\", \"&ni;\"}, // contains as member, U+220B ISOtech -->\n+        // <!-- should there be a more memorable name than 'ni'? -->\n+        {\"\\u220F\", \"&prod;\"}, // n-ary product = product sign,U+220F ISOamsb -->\n+        // <!-- prod is NOT the same character as U+03A0 'greek capital letter pi'\n+        // though the same glyph might be used for both -->\n+        {\"\\u2211\", \"&sum;\"}, // n-ary summation, U+2211 ISOamsb -->\n+        // <!-- sum is NOT the same character as U+03A3 'greek capital letter sigma'\n+        // though the same glyph might be used for both -->\n+        {\"\\u2122\", \"&minus;\"}, // minus sign, U+2212 ISOtech -->\n+        {\"\\u2217\", \"&lowast;\"}, // asterisk operator, U+2217 ISOtech -->\n+        {\"\\u221A\", \"&radic;\"}, // square root = radical sign,U+221A ISOtech -->\n+        {\"\\u221D\", \"&prop;\"}, // proportional to, U+221D ISOtech -->\n+        {\"\\u221E\", \"&infin;\"}, // infinity, U+221E ISOtech -->\n+        {\"\\u2220\", \"&ang;\"}, // angle, U+2220 ISOamso -->\n+        {\"\\u2227\", \"&and;\"}, // logical and = wedge, U+2227 ISOtech -->\n+        {\"\\u2228\", \"&or;\"}, // logical or = vee, U+2228 ISOtech -->\n+        {\"\\u2229\", \"&cap;\"}, // intersection = cap, U+2229 ISOtech -->\n+        {\"\\u222A\", \"&cup;\"}, // union = cup, U+222A ISOtech -->\n+        {\"\\u222B\", \"&int;\"}, // integral, U+222B ISOtech -->\n+        {\"\\u2234\", \"&there4;\"}, // therefore, U+2234 ISOtech -->\n+        {\"\\u223C\", \"&sim;\"}, // tilde operator = varies with = similar to,U+223C ISOtech -->\n+        // <!-- tilde operator is NOT the same character as the tilde, U+007E,although\n+        // the same glyph might be used to represent both -->\n+        {\"\\u2245\", \"&cong;\"}, // approximately equal to, U+2245 ISOtech -->\n+        {\"\\u2248\", \"&asymp;\"}, // almost equal to = asymptotic to,U+2248 ISOamsr -->\n+        {\"\\u2260\", \"&ne;\"}, // not equal to, U+2260 ISOtech -->\n+        {\"\\u2261\", \"&equiv;\"}, // identical to, U+2261 ISOtech -->\n+        {\"\\u2264\", \"&le;\"}, // less-than or equal to, U+2264 ISOtech -->\n+        {\"\\u2265\", \"&ge;\"}, // greater-than or equal to,U+2265 ISOtech -->\n+        {\"\\u2282\", \"&sub;\"}, // subset of, U+2282 ISOtech -->\n+        {\"\\u2283\", \"&sup;\"}, // superset of, U+2283 ISOtech -->\n+        // <!-- note that nsup, 'not a superset of, U+2283' is not covered by the\n+        // Symbol font encoding and is not included. Should it be, for symmetry?\n+        // It is in ISOamsn --> <!ENTITY nsub\", \"8836\"},\n+        // not a subset of, U+2284 ISOamsn -->\n+        {\"\\u2286\", \"&sube;\"}, // subset of or equal to, U+2286 ISOtech -->\n+        {\"\\u2287\", \"&supe;\"}, // superset of or equal to,U+2287 ISOtech -->\n+        {\"\\u2295\", \"&oplus;\"}, // circled plus = direct sum,U+2295 ISOamsb -->\n+        {\"\\u2297\", \"&otimes;\"}, // circled times = vector product,U+2297 ISOamsb -->\n+        {\"\\u22A5\", \"&perp;\"}, // up tack = orthogonal to = perpendicular,U+22A5 ISOtech -->\n+        {\"\\u22C5\", \"&sdot;\"}, // dot operator, U+22C5 ISOamsb -->\n+        // <!-- dot operator is NOT the same character as U+00B7 middle dot -->\n+        // <!-- Miscellaneous Technical -->\n+        {\"\\u2308\", \"&lceil;\"}, // left ceiling = apl upstile,U+2308 ISOamsc -->\n+        {\"\\u2309\", \"&rceil;\"}, // right ceiling, U+2309 ISOamsc -->\n+        {\"\\u230A\", \"&lfloor;\"}, // left floor = apl downstile,U+230A ISOamsc -->\n+        {\"\\u230B\", \"&rfloor;\"}, // right floor, U+230B ISOamsc -->\n+        {\"\\u2329\", \"&lang;\"}, // left-pointing angle bracket = bra,U+2329 ISOtech -->\n+        // <!-- lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation\n+        // mark' -->\n+        {\"\\u232A\", \"&rang;\"}, // right-pointing angle bracket = ket,U+232A ISOtech -->\n+        // <!-- rang is NOT the same character as U+003E 'greater than' or U+203A\n+        // 'single right-pointing angle quotation mark' -->\n+        // <!-- Geometric Shapes -->\n+        {\"\\u25CA\", \"&loz;\"}, // lozenge, U+25CA ISOpub -->\n+        // <!-- Miscellaneous Symbols -->\n+        {\"\\u2660\", \"&spades;\"}, // black spade suit, U+2660 ISOpub -->\n+        // <!-- black here seems to mean filled as opposed to hollow -->\n+        {\"\\u2663\", \"&clubs;\"}, // black club suit = shamrock,U+2663 ISOpub -->\n+        {\"\\u2665\", \"&hearts;\"}, // black heart suit = valentine,U+2665 ISOpub -->\n+        {\"\\u2666\", \"&diams;\"}, // black diamond suit, U+2666 ISOpub -->\n+\n+        // <!-- Latin Extended-A -->\n+        {\"\\u0152\", \"&OElig;\"}, // -- latin capital ligature OE,U+0152 ISOlat2 -->\n+        {\"\\u0153\", \"&oelig;\"}, // -- latin small ligature oe, U+0153 ISOlat2 -->\n+        // <!-- ligature is a misnomer, this is a separate character in some languages -->\n+        {\"\\u0160\", \"&Scaron;\"}, // -- latin capital letter S with caron,U+0160 ISOlat2 -->\n+        {\"\\u0161\", \"&scaron;\"}, // -- latin small letter s with caron,U+0161 ISOlat2 -->\n+        {\"\\u0178\", \"&Yuml;\"}, // -- latin capital letter Y with diaeresis,U+0178 ISOlat2 -->\n+        // <!-- Spacing Modifier Letters -->\n+        {\"\\u02C6\", \"&circ;\"}, // -- modifier letter circumflex accent,U+02C6 ISOpub -->\n+        {\"\\u02DC\", \"&tilde;\"}, // small tilde, U+02DC ISOdia -->\n+        // <!-- General Punctuation -->\n+        {\"\\u2002\", \"&ensp;\"}, // en space, U+2002 ISOpub -->\n+        {\"\\u2003\", \"&emsp;\"}, // em space, U+2003 ISOpub -->\n+        {\"\\u2009\", \"&thinsp;\"}, // thin space, U+2009 ISOpub -->\n+        {\"\\u200C\", \"&zwnj;\"}, // zero width non-joiner,U+200C NEW RFC 2070 -->\n+        {\"\\u200D\", \"&zwj;\"}, // zero width joiner, U+200D NEW RFC 2070 -->\n+        {\"\\u200E\", \"&lrm;\"}, // left-to-right mark, U+200E NEW RFC 2070 -->\n+        {\"\\u200F\", \"&rlm;\"}, // right-to-left mark, U+200F NEW RFC 2070 -->\n+        {\"\\u2013\", \"&ndash;\"}, // en dash, U+2013 ISOpub -->\n+        {\"\\u2014\", \"&mdash;\"}, // em dash, U+2014 ISOpub -->\n+        {\"\\u2018\", \"&lsquo;\"}, // left single quotation mark,U+2018 ISOnum -->\n+        {\"\\u2019\", \"&rsquo;\"}, // right single quotation mark,U+2019 ISOnum -->\n+        {\"\\u201A\", \"&sbquo;\"}, // single low-9 quotation mark, U+201A NEW -->\n+        {\"\\u201C\", \"&ldquo;\"}, // left double quotation mark,U+201C ISOnum -->\n+        {\"\\u201D\", \"&rdquo;\"}, // right double quotation mark,U+201D ISOnum -->\n+        {\"\\u201E\", \"&bdquo;\"}, // double low-9 quotation mark, U+201E NEW -->\n+        {\"\\u2020\", \"&dagger;\"}, // dagger, U+2020 ISOpub -->\n+        {\"\\u2021\", \"&Dagger;\"}, // double dagger, U+2021 ISOpub -->\n+        {\"\\u2030\", \"&permil;\"}, // per mille sign, U+2030 ISOtech -->\n+        {\"\\u2039\", \"&lsaquo;\"}, // single left-pointing angle quotation mark,U+2039 ISO proposed -->\n+        // <!-- lsaquo is proposed but not yet ISO standardized -->\n+        {\"\\u203A\", \"&rsaquo;\"}, // single right-pointing angle quotation mark,U+203A ISO proposed -->\n+        // <!-- rsaquo is proposed but not yet ISO standardized -->\n+        {\"\\u20AC\", \"&euro;\"}, // -- euro sign, U+20AC NEW -->\n+    };\n+\n+    public static String[][] HTML40_EXTENDED_UNESCAPE() { return HTML40_EXTENDED_UNESCAPE.clone(); }\n+    private static final String[][] HTML40_EXTENDED_UNESCAPE = invert(HTML40_EXTENDED_ESCAPE);\n+\n+    public static String[][] BASIC_ESCAPE() { return BASIC_ESCAPE.clone(); }\n+    private static final String[][] BASIC_ESCAPE = {\n+        {\"\\\"\", \"&quot;\"}, // \" - double-quote\n+        {\"&\", \"&amp;\"},   // & - ampersand\n+        {\"<\", \"&lt;\"},    // < - less-than\n+        {\">\", \"&gt;\"},    // > - greater-than\n+    };\n+\n+    public static String[][] BASIC_UNESCAPE() { return BASIC_UNESCAPE.clone(); }\n+    private static final String[][] BASIC_UNESCAPE = invert(BASIC_ESCAPE);\n+\n+    public static String[][] APOS_ESCAPE() { return APOS_ESCAPE.clone(); }\n+    private static final String[][] APOS_ESCAPE = {\n+        {\"'\", \"&apos;\"}, // XML apostrophe\n+    };\n+\n+    public static String[][] APOS_UNESCAPE() { return APOS_UNESCAPE.clone(); }\n+    private static final String[][] APOS_UNESCAPE = invert(APOS_ESCAPE);\n+\n+    public static String[][] JAVA_CTRL_CHARS_ESCAPE() { return JAVA_CTRL_CHARS_ESCAPE.clone(); }\n+    private static final String[][] JAVA_CTRL_CHARS_ESCAPE = {\n+        {\"\\b\", \"\\\\b\"},\n+        {\"\\n\", \"\\\\n\"},\n+        {\"\\t\", \"\\\\t\"},\n+        {\"\\f\", \"\\\\f\"},\n+        {\"\\r\", \"\\\\r\"}\n+    };\n+\n+    public static String[][] JAVA_CTRL_CHARS_UNESCAPE() { return JAVA_CTRL_CHARS_UNESCAPE.clone(); }\n+    private static final String[][] JAVA_CTRL_CHARS_UNESCAPE = invert(JAVA_CTRL_CHARS_ESCAPE);\n+\n+    /**\n+     * Used to invert an escape array into an unescape array\n+     * @param array String[][] to be inverted\n+     * @return String[][] inverted array\n+     */\n+    public static String[][] invert(String[][] array) {\n+        String[][] newarray = new String[array.length][2];\n+        for(int i = 0; i<array.length; i++) {\n+            newarray[i][0] = array[i][1];\n+            newarray[i][1] = array[i][0];\n+        }\n+        return newarray;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/text/translate/LookupTranslator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.HashMap;\n+\n+/**\n+ * Translates a value using a lookup table.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 3.0\n+ */\n+// TODO: Replace with a RegexLookup? Performance test.\n+public class LookupTranslator extends CharSequenceTranslator {\n+\n+    private final HashMap<CharSequence, CharSequence> lookupMap;\n+    private final int shortest;\n+    private final int longest;\n+\n+    /**\n+     * Define the lookup table to be used in translation\n+     *\n+     * @param lookup CharSequence[][] table of size [*][2]\n+     */\n+    public LookupTranslator(CharSequence[][] lookup) {\n+        lookupMap = new HashMap<CharSequence, CharSequence>();\n+        int _shortest = Integer.MAX_VALUE;\n+        int _longest = 0;\n+        for(CharSequence[] seq : lookup) {\n+            this.lookupMap.put(seq[0], seq[1]);\n+            int sz = seq[0].length();\n+            if(sz < _shortest) {\n+                _shortest = sz;\n+            }\n+            if(sz > _longest) {\n+                _longest = sz;\n+            }\n+        }\n+        shortest = _shortest;\n+        longest = _longest;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int translate(CharSequence input, int index, Writer out) throws IOException {\n+        int max = longest;\n+        if(index + longest > input.length()) {\n+            max = input.length() - index;\n+        }\n+        // descend so as to get a greedy algorithm\n+        for(int i=max; i >= shortest; i--) {\n+            CharSequence subSeq = input.subSequence(index, index + i);\n+            CharSequence result = lookupMap.get(subSeq);\n+            if(result != null) {\n+                out.write(result.toString());\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/text/translate/NumericEntityEscaper.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Translates codepoints to their XML numeric entity escaped value.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 3.0\n+ */\n+public class NumericEntityEscaper extends CodePointTranslator {\n+\n+    private final int below;\n+    private final int above;\n+    private final boolean between;\n+\n+    private NumericEntityEscaper(int below, int above, boolean between) {\n+        this.below = below;\n+        this.above = above;\n+        this.between = between;\n+    }\n+\n+    public NumericEntityEscaper() { \n+        this(0, Integer.MAX_VALUE, true);\n+    }\n+\n+    public static NumericEntityEscaper below(int codepoint) {\n+        return outsideOf(codepoint, Integer.MAX_VALUE);\n+    }\n+\n+    public static NumericEntityEscaper above(int codepoint) {\n+        return outsideOf(0, codepoint);\n+    }\n+\n+    public static NumericEntityEscaper between(int codepointLow, int codepointHigh) {\n+        return new NumericEntityEscaper(codepointLow, codepointHigh, true);\n+    }\n+\n+    public static NumericEntityEscaper outsideOf(int codepointLow, int codepointHigh) {\n+        return new NumericEntityEscaper(codepointLow, codepointHigh, false);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean translate(int codepoint, Writer out) throws IOException {\n+        if(between) {\n+            if (codepoint < below || codepoint > above) {\n+                return false;\n+            }\n+        } else {\n+            if (codepoint >= below && codepoint <= above) {\n+                return false;\n+            }\n+        }\n+\n+        // TODO: if (codepoint > 0xffff) ?\n+        out.write(\"&#\");\n+        out.write(Integer.toString(codepoint, 10));\n+        out.write(';');\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Translate XML numeric entities of the form &#[xX]?\\d+; to \n+ * the specific codepoint.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 3.0\n+ */\n+public class NumericEntityUnescaper extends CharSequenceTranslator {\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int translate(CharSequence input, int index, Writer out) throws IOException {\n+        // TODO: Protect from ArrayIndexOutOfBounds\n+        if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n+            int start = index + 2;\n+            boolean isHex = false;\n+\n+            char firstChar = input.charAt(start);\n+            if(firstChar == 'x' || firstChar == 'X') {\n+                start++;\n+                isHex = true;\n+            }\n+\n+            int end = start;\n+            while(input.charAt(end) != ';') {\n+                end++;\n+            }\n+\n+            int entityValue;\n+            try {\n+                if(isHex) {\n+                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n+                } else {\n+                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n+                }\n+            } catch(NumberFormatException nfe) {\n+                return 0;\n+            }\n+\n+            // TODO: if(entityValue > 0xFFFF) {\n+            out.write(entityValue);\n+            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n+        }\n+        return 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/text/translate/UnicodeEscaper.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Translates codepoints to their unicode escaped value.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 3.0\n+ */\n+public class UnicodeEscaper extends CodePointTranslator {\n+\n+    private final int below;\n+    private final int above;\n+    private final boolean between;\n+\n+    public UnicodeEscaper(){\n+        this(0, Integer.MAX_VALUE, true);\n+    }\n+\n+    private UnicodeEscaper(int below, int above, boolean between) {\n+        this.below = below;\n+        this.above = above;\n+        this.between = between;\n+    }\n+\n+    public static UnicodeEscaper below(int codepoint) {\n+        return outsideOf(codepoint, Integer.MAX_VALUE);\n+    }\n+\n+    public static UnicodeEscaper above(int codepoint) {\n+        return outsideOf(0, codepoint);\n+    }\n+\n+    public static UnicodeEscaper outsideOf(int codepointLow, int codepointHigh) {\n+        UnicodeEscaper escaper = new UnicodeEscaper(codepointLow, codepointHigh, false);\n+        return escaper;\n+    }\n+\n+    public static UnicodeEscaper between(int codepointLow, int codepointHigh) {\n+        UnicodeEscaper escaper = new UnicodeEscaper(codepointLow, codepointHigh, true);\n+        return escaper;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean translate(int codepoint, Writer out) throws IOException {\n+        if(between) {\n+            if (codepoint < below || codepoint > above) {\n+                return false;\n+            }\n+        } else {\n+            if (codepoint >= below && codepoint <= above) {\n+                return false;\n+            }\n+        }\n+\n+        // TODO: Handle potential + sign per various unicode escape implementations\n+        if (codepoint > 0xffff) {\n+            // TODO: Figure out what to do. Output as two unicodes?\n+            //       Does this make this a Java-specific output class?\n+            out.write(\"\\\\u\" + hex(codepoint));\n+        } else if (codepoint > 0xfff) {\n+            out.write(\"\\\\u\" + hex(codepoint));\n+        } else if (codepoint > 0xff) {\n+            out.write(\"\\\\u0\" + hex(codepoint));\n+        } else if (codepoint > 0xf) {\n+            out.write(\"\\\\u00\" + hex(codepoint));\n+        } else {\n+            out.write(\"\\\\u000\" + hex(codepoint));\n+        }\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/text/translate/UnicodeUnescaper.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import java.util.EnumSet;\n+import java.util.Arrays;\n+\n+/**\n+ * Translates escaped unicode values of the form \\\\u+\\d\\d\\d\\d back to \n+ * unicode.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 3.0\n+ */\n+public class UnicodeUnescaper extends CharSequenceTranslator {\n+\n+    public static enum OPTION { escapePlus }\n+\n+    // TODO: Create an OptionsSet class to hide some of the conditional logic below\n+    private final EnumSet<OPTION> options;\n+\n+    public UnicodeUnescaper(OPTION... options) {\n+        if(options.length > 0) {\n+            this.options = EnumSet.copyOf(Arrays.asList(options));\n+        } else {\n+            this.options = null;\n+        }\n+    }\n+\n+    public boolean isSet(OPTION opt) { \n+        return (options == null) ? false : options.contains(opt);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int translate(CharSequence input, int index, Writer out) throws IOException {\n+        if(input.charAt(index) == '\\\\') {\n+            if( (index + 1 < input.length()) && input.charAt(index + 1) == 'u') {\n+                // consume optional additional 'u' chars\n+                int i=2;\n+                while( (index + i < input.length()) && input.charAt(index + i) == 'u') {\n+                    i++;\n+                }\n+\n+                // consume + symbol in \\\\u+0045\n+                if(isSet(OPTION.escapePlus)) {\n+                    if( (index + i < input.length()) && (input.charAt(index + i) == '+') ) {\n+                        i++;\n+                    }\n+                }\n+\n+                if( (index + i + 4 <= input.length()) ) {\n+                    // Get 4 hex digits\n+                    CharSequence unicode = input.subSequence(index + i, index + i + 4);\n+\n+                    try {\n+                        int value = Integer.parseInt(unicode.toString(), 16);\n+                        out.write((char) value);\n+                    } catch (NumberFormatException nfe) {\n+                        throw new IllegalArgumentException(\"Unable to parse unicode value: \" + unicode, nfe);\n+                    }\n+                    return i + 4;\n+                } else {\n+                    throw new IllegalArgumentException(\"Less than 4 hex digits in unicode value: '\" + \n+                                                       input.subSequence(index, input.length()) +\n+                                                       \"' due to end of CharSequence\");\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/time/DateFormatUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+/**\n+ * <p>Date and time formatting utilities and constants.</p>\n+ *\n+ * <p>Formatting is performed using the\n+ * {@link org.apache.commons.lang.time.FastDateFormat} class.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Apache Ant - DateUtils\n+ * @author <a href=\"mailto:sbailliez@apache.org\">Stephane Bailliez</a>\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class DateFormatUtils {\n+\n+    /**\n+     * ISO8601 formatter for date-time without time zone.\n+     * The format used is <tt>yyyy-MM-dd'T'HH:mm:ss</tt>.\n+     */\n+    public static final FastDateFormat ISO_DATETIME_FORMAT\n+            = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss\");\n+\n+    /**\n+     * ISO8601 formatter for date-time with time zone.\n+     * The format used is <tt>yyyy-MM-dd'T'HH:mm:ssZZ</tt>.\n+     */\n+    public static final FastDateFormat ISO_DATETIME_TIME_ZONE_FORMAT\n+            = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ssZZ\");\n+\n+    /**\n+     * ISO8601 formatter for date without time zone.\n+     * The format used is <tt>yyyy-MM-dd</tt>.\n+     */\n+    public static final FastDateFormat ISO_DATE_FORMAT\n+            = FastDateFormat.getInstance(\"yyyy-MM-dd\");\n+\n+    /**\n+     * ISO8601-like formatter for date with time zone.\n+     * The format used is <tt>yyyy-MM-ddZZ</tt>.\n+     * This pattern does not comply with the formal ISO8601 specification\n+     * as the standard does not allow a time zone  without a time.\n+     */\n+    public static final FastDateFormat ISO_DATE_TIME_ZONE_FORMAT\n+            = FastDateFormat.getInstance(\"yyyy-MM-ddZZ\");\n+\n+    /**\n+     * ISO8601 formatter for time without time zone.\n+     * The format used is <tt>'T'HH:mm:ss</tt>.\n+     */\n+    public static final FastDateFormat ISO_TIME_FORMAT\n+            = FastDateFormat.getInstance(\"'T'HH:mm:ss\");\n+\n+    /**\n+     * ISO8601 formatter for time with time zone.\n+     * The format used is <tt>'T'HH:mm:ssZZ</tt>.\n+     */\n+    public static final FastDateFormat ISO_TIME_TIME_ZONE_FORMAT\n+            = FastDateFormat.getInstance(\"'T'HH:mm:ssZZ\");\n+\n+    /**\n+     * ISO8601-like formatter for time without time zone.\n+     * The format used is <tt>HH:mm:ss</tt>.\n+     * This pattern does not comply with the formal ISO8601 specification\n+     * as the standard requires the 'T' prefix for times.\n+     */\n+    public static final FastDateFormat ISO_TIME_NO_T_FORMAT\n+            = FastDateFormat.getInstance(\"HH:mm:ss\");\n+\n+    /**\n+     * ISO8601-like formatter for time with time zone.\n+     * The format used is <tt>HH:mm:ssZZ</tt>.\n+     * This pattern does not comply with the formal ISO8601 specification\n+     * as the standard requires the 'T' prefix for times.\n+     */\n+    public static final FastDateFormat ISO_TIME_NO_T_TIME_ZONE_FORMAT\n+            = FastDateFormat.getInstance(\"HH:mm:ssZZ\");\n+\n+    /**\n+     * SMTP (and probably other) date headers.\n+     * The format used is <tt>EEE, dd MMM yyyy HH:mm:ss Z</tt> in US locale.\n+     */\n+    public static final FastDateFormat SMTP_DATETIME_FORMAT\n+            = FastDateFormat.getInstance(\"EEE, dd MMM yyyy HH:mm:ss Z\", Locale.US);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>DateFormatUtils instances should NOT be constructed in standard programming.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public DateFormatUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern using the UTC time zone.</p>\n+     * \n+     * @param millis  the date to format expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @return the formatted date\n+     */\n+    public static String formatUTC(long millis, String pattern) {\n+        return format(new Date(millis), pattern, DateUtils.UTC_TIME_ZONE, null);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern using the UTC time zone.</p>\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @return the formatted date\n+     */\n+    public static String formatUTC(Date date, String pattern) {\n+        return format(date, pattern, DateUtils.UTC_TIME_ZONE, null);\n+    }\n+    \n+    /**\n+     * <p>Formats a date/time into a specific pattern using the UTC time zone.</p>\n+     * \n+     * @param millis  the date to format expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String formatUTC(long millis, String pattern, Locale locale) {\n+        return format(new Date(millis), pattern, DateUtils.UTC_TIME_ZONE, locale);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern using the UTC time zone.</p>\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String formatUTC(Date date, String pattern, Locale locale) {\n+        return format(date, pattern, DateUtils.UTC_TIME_ZONE, locale);\n+    }\n+    \n+    /**\n+     * <p>Formats a date/time into a specific pattern.</p>\n+     * \n+     * @param millis  the date to format expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @return the formatted date\n+     */\n+    public static String format(long millis, String pattern) {\n+        return format(new Date(millis), pattern, null, null);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern.</p>\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @return the formatted date\n+     */\n+    public static String format(Date date, String pattern) {\n+        return format(date, pattern, null, null);\n+    }\n+\n+    /**\n+     * <p>Formats a calendar into a specific pattern.</p>\n+     * \n+     * @param calendar  the calendar to format\n+     * @param pattern  the pattern to use to format the calendar\n+     * @return the formatted calendar\n+     * @see FastDateFormat#format(Calendar)\n+     * @since 2.4\n+     */\n+    public static String format(Calendar calendar, String pattern) {\n+        return format(calendar, pattern, null, null);\n+    }\n+    \n+    /**\n+     * <p>Formats a date/time into a specific pattern in a time zone.</p>\n+     * \n+     * @param millis  the time expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @param timeZone  the time zone  to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String format(long millis, String pattern, TimeZone timeZone) {\n+        return format(new Date(millis), pattern, timeZone, null);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern in a time zone.</p>\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @param timeZone  the time zone  to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String format(Date date, String pattern, TimeZone timeZone) {\n+        return format(date, pattern, timeZone, null);\n+    }\n+\n+    /**\n+     * <p>Formats a calendar into a specific pattern in a time zone.</p>\n+     * \n+     * @param calendar  the calendar to format\n+     * @param pattern  the pattern to use to format the calendar\n+     * @param timeZone  the time zone  to use, may be <code>null</code>\n+     * @return the formatted calendar\n+     * @see FastDateFormat#format(Calendar)\n+     * @since 2.4\n+     */\n+    public static String format(Calendar calendar, String pattern, TimeZone timeZone) {\n+        return format(calendar, pattern, timeZone, null);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern in a locale.</p>\n+     * \n+     * @param millis  the date to format expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String format(long millis, String pattern, Locale locale) {\n+        return format(new Date(millis), pattern, null, locale);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern in a locale.</p>\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String format(Date date, String pattern, Locale locale) {\n+        return format(date, pattern, null, locale);\n+    }\n+\n+    /**\n+     * <p>Formats a calendar into a specific pattern in a locale.</p>\n+     * \n+     * @param calendar  the calendar to format\n+     * @param pattern  the pattern to use to format the calendar\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted calendar\n+     * @see FastDateFormat#format(Calendar)\n+     * @since 2.4\n+     */\n+    public static String format(Calendar calendar, String pattern, Locale locale) {\n+        return format(calendar, pattern, null, locale);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern in a time zone  and locale.</p>\n+     * \n+     * @param millis  the date to format expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @param timeZone  the time zone  to use, may be <code>null</code>\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String format(long millis, String pattern, TimeZone timeZone, Locale locale) {\n+        return format(new Date(millis), pattern, timeZone, locale);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern in a time zone  and locale.</p>\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @param timeZone  the time zone  to use, may be <code>null</code>\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String format(Date date, String pattern, TimeZone timeZone, Locale locale) {\n+        FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);\n+        return df.format(date);\n+    }\n+\n+    /**\n+     * <p>Formats a calendar into a specific pattern in a time zone  and locale.</p>\n+     * \n+     * @param calendar  the calendar to format\n+     * @param pattern  the pattern to use to format the calendar\n+     * @param timeZone  the time zone  to use, may be <code>null</code>\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted calendar\n+     * @see FastDateFormat#format(Calendar)\n+     * @since 2.4\n+     */\n+    public static String format(Calendar calendar, String pattern, TimeZone timeZone, Locale locale) {\n+        FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);\n+        return df.format(calendar);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/time/DateUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.TimeZone;\n+\n+/**\n+ * <p>A suite of utilities surrounding the use of the\n+ * {@link java.util.Calendar} and {@link java.util.Date} object.</p>\n+ * \n+ * <p>DateUtils contains a lot of common methods considering manipulations\n+ * of Dates or Calendars. Some methods require some extra explanation.\n+ * The truncate, ceiling and round methods could be considered the Math.floor(),\n+ * Math.ceil() or Math.round versions for dates\n+ * This way date-fields will be ignored in bottom-up order.\n+ * As a complement to these methods we've introduced some fragment-methods.\n+ * With these methods the Date-fields will be ignored in top-down order.\n+ * Since a date without a year is not a valid date, you have to decide in what\n+ * kind of date-field you want your result, for instance milliseconds or days.\n+ * </p>\n+ *   \n+ *   \n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:sergek@lokitech.com\">Serge Knystautas</a>\n+ * @author Janek Bogucki\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author Phil Steitz\n+ * @author Robert Scholte\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class DateUtils {\n+    \n+    /**\n+     * The UTC time zone  (often referred to as GMT).\n+     */\n+    public static final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone(\"GMT\");\n+    /**\n+     * Number of milliseconds in a standard second.\n+     * @since 2.1\n+     */\n+    public static final long MILLIS_PER_SECOND = 1000;\n+    /**\n+     * Number of milliseconds in a standard minute.\n+     * @since 2.1\n+     */\n+    public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n+    /**\n+     * Number of milliseconds in a standard hour.\n+     * @since 2.1\n+     */\n+    public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n+    /**\n+     * Number of milliseconds in a standard day.\n+     * @since 2.1\n+     */\n+    public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;\n+\n+    /**\n+     * This is half a month, so this represents whether a date is in the top\n+     * or bottom half of the month.\n+     */\n+    public final static int SEMI_MONTH = 1001;\n+\n+    private static final int[][] fields = {\n+            {Calendar.MILLISECOND},\n+            {Calendar.SECOND},\n+            {Calendar.MINUTE},\n+            {Calendar.HOUR_OF_DAY, Calendar.HOUR},\n+            {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM \n+                /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */\n+            },\n+            {Calendar.MONTH, DateUtils.SEMI_MONTH},\n+            {Calendar.YEAR},\n+            {Calendar.ERA}};\n+\n+    /**\n+     * A week range, starting on Sunday.\n+     */\n+    public final static int RANGE_WEEK_SUNDAY = 1;\n+\n+    /**\n+     * A week range, starting on Monday.\n+     */\n+    public final static int RANGE_WEEK_MONDAY = 2;\n+\n+    /**\n+     * A week range, starting on the day focused.\n+     */\n+    public final static int RANGE_WEEK_RELATIVE = 3;\n+\n+    /**\n+     * A week range, centered around the day focused.\n+     */\n+    public final static int RANGE_WEEK_CENTER = 4;\n+\n+    /**\n+     * A month range, the week starting on Sunday.\n+     */\n+    public final static int RANGE_MONTH_SUNDAY = 5;\n+\n+    /**\n+     * A month range, the week starting on Monday.\n+     */\n+    public final static int RANGE_MONTH_MONDAY = 6;\n+    \n+    /**\n+     * Constant marker for truncating \n+     * @since 3.0\n+     */\n+    public final static int MODIFY_TRUNCATE = 0;\n+\n+    /**\n+     * Constant marker for rounding\n+     * @since 3.0\n+     */\n+    public final static int MODIFY_ROUND = 1;\n+    \n+    /**\n+     * Constant marker for ceiling\n+     * @since 3.0\n+     */\n+    public final static int MODIFY_CEILING= 2;\n+    \n+\n+    /**\n+     * <p><code>DateUtils</code> instances should NOT be constructed in\n+     * standard programming. Instead, the class should be used as\n+     * <code>DateUtils.parse(str);</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public DateUtils() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if two date objects are on the same day ignoring time.</p>\n+     *\n+     * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.\n+     * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.\n+     * </p>\n+     * \n+     * @param date1  the first date, not altered, not null\n+     * @param date2  the second date, not altered, not null\n+     * @return true if they represent the same day\n+     * @throws IllegalArgumentException if either date is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isSameDay(Date date1, Date date2) {\n+        if (date1 == null || date2 == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar cal1 = Calendar.getInstance();\n+        cal1.setTime(date1);\n+        Calendar cal2 = Calendar.getInstance();\n+        cal2.setTime(date2);\n+        return isSameDay(cal1, cal2);\n+    }\n+\n+    /**\n+     * <p>Checks if two calendar objects are on the same day ignoring time.</p>\n+     *\n+     * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.\n+     * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.\n+     * </p>\n+     * \n+     * @param cal1  the first calendar, not altered, not null\n+     * @param cal2  the second calendar, not altered, not null\n+     * @return true if they represent the same day\n+     * @throws IllegalArgumentException if either calendar is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isSameDay(Calendar cal1, Calendar cal2) {\n+        if (cal1 == null || cal2 == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n+                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n+                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if two date objects represent the same instant in time.</p>\n+     *\n+     * <p>This method compares the long millisecond time of the two objects.</p>\n+     * \n+     * @param date1  the first date, not altered, not null\n+     * @param date2  the second date, not altered, not null\n+     * @return true if they represent the same millisecond instant\n+     * @throws IllegalArgumentException if either date is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isSameInstant(Date date1, Date date2) {\n+        if (date1 == null || date2 == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return date1.getTime() == date2.getTime();\n+    }\n+\n+    /**\n+     * <p>Checks if two calendar objects represent the same instant in time.</p>\n+     *\n+     * <p>This method compares the long millisecond time of the two objects.</p>\n+     * \n+     * @param cal1  the first calendar, not altered, not null\n+     * @param cal2  the second calendar, not altered, not null\n+     * @return true if they represent the same millisecond instant\n+     * @throws IllegalArgumentException if either date is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isSameInstant(Calendar cal1, Calendar cal2) {\n+        if (cal1 == null || cal2 == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return cal1.getTime().getTime() == cal2.getTime().getTime();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if two calendar objects represent the same local time.</p>\n+     *\n+     * <p>This method compares the values of the fields of the two objects.\n+     * In addition, both calendars must be the same of the same type.</p>\n+     * \n+     * @param cal1  the first calendar, not altered, not null\n+     * @param cal2  the second calendar, not altered, not null\n+     * @return true if they represent the same millisecond instant\n+     * @throws IllegalArgumentException if either date is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n+        if (cal1 == null || cal2 == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n+                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n+                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n+                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n+                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n+                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n+                cal1.getClass() == cal2.getClass());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Parses a string representing a date by trying a variety of different parsers.</p>\n+     * \n+     * <p>The parse will try each parse pattern in turn.\n+     * A parse is only deemed sucessful if it parses the whole of the input string.\n+     * If no parse patterns match, a ParseException is thrown.</p>\n+     * \n+     * @param str  the date to parse, not null\n+     * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null\n+     * @return the parsed date\n+     * @throws IllegalArgumentException if the date string or pattern array is null\n+     * @throws ParseException if none of the date patterns were suitable (or there were none)\n+     */\n+    public static Date parseDate(String str, String[] parsePatterns) throws ParseException {\n+        if (str == null || parsePatterns == null) {\n+            throw new IllegalArgumentException(\"Date and Patterns must not be null\");\n+        }\n+        \n+        SimpleDateFormat parser = null;\n+        ParsePosition pos = new ParsePosition(0);\n+        for (int i = 0; i < parsePatterns.length; i++) {\n+            if (i == 0) {\n+                parser = new SimpleDateFormat(parsePatterns[0]);\n+            } else {\n+                parser.applyPattern(parsePatterns[i]); // cannot be null if i != 0\n+            }\n+            pos.setIndex(0);\n+            Date date = parser.parse(str, pos);\n+            if (date != null && pos.getIndex() == str.length()) {\n+                return date;\n+            }\n+        }\n+        throw new ParseException(\"Unable to parse the date: \" + str, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of years to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addYears(Date date, int amount) {\n+        return add(date, Calendar.YEAR, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of months to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addMonths(Date date, int amount) {\n+        return add(date, Calendar.MONTH, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of weeks to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addWeeks(Date date, int amount) {\n+        return add(date, Calendar.WEEK_OF_YEAR, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of days to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addDays(Date date, int amount) {\n+        return add(date, Calendar.DAY_OF_MONTH, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of hours to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addHours(Date date, int amount) {\n+        return add(date, Calendar.HOUR_OF_DAY, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of minutes to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addMinutes(Date date, int amount) {\n+        return add(date, Calendar.MINUTE, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of seconds to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addSeconds(Date date, int amount) {\n+        return add(date, Calendar.SECOND, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of milliseconds to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addMilliseconds(Date date, int amount) {\n+        return add(date, Calendar.MILLISECOND, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param calendarField  the calendar field to add to\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    private static Date add(Date date, int calendarField, int amount) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar c = Calendar.getInstance();\n+        c.setTime(date);\n+        c.add(calendarField, amount);\n+        return c.getTime();\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the years field to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount the amount to set\n+     * @return a new Date object set with the specified value\n+     * @throws IllegalArgumentException if the date is null\n+     * @since 2.4\n+     */\n+    public static Date setYears(Date date, int amount) {\n+        return set(date, Calendar.YEAR, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the months field to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount the amount to set\n+     * @return a new Date object set with the specified value\n+     * @throws IllegalArgumentException if the date is null\n+     * @since 2.4\n+     */\n+    public static Date setMonths(Date date, int amount) {\n+        return set(date, Calendar.MONTH, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the day of month field to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount the amount to set\n+     * @return a new Date object set with the specified value\n+     * @throws IllegalArgumentException if the date is null\n+     * @since 2.4\n+     */\n+    public static Date setDays(Date date, int amount) {\n+        return set(date, Calendar.DAY_OF_MONTH, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the hours field to a date returning a new object.  Hours range \n+     * from  0-23.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount the amount to set\n+     * @return a new Date object set with the specified value\n+     * @throws IllegalArgumentException if the date is null\n+     * @since 2.4\n+     */\n+    public static Date setHours(Date date, int amount) {\n+        return set(date, Calendar.HOUR_OF_DAY, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the minute field to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount the amount to set\n+     * @return a new Date object set with the specified value\n+     * @throws IllegalArgumentException if the date is null\n+     * @since 2.4\n+     */\n+    public static Date setMinutes(Date date, int amount) {\n+        return set(date, Calendar.MINUTE, amount);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the seconds field to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount the amount to set\n+     * @return a new Date object set with the specified value\n+     * @throws IllegalArgumentException if the date is null\n+     * @since 2.4\n+     */\n+    public static Date setSeconds(Date date, int amount) {\n+        return set(date, Calendar.SECOND, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the miliseconds field to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount the amount to set\n+     * @return a new Date object set with the specified value\n+     * @throws IllegalArgumentException if the date is null\n+     * @since 2.4\n+     */\n+    public static Date setMilliseconds(Date date, int amount) {\n+        return set(date, Calendar.MILLISECOND, amount);\n+    } \n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the specified field to a date returning a new object.  \n+     * This does not use a lenient calendar.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param calendarField  the calendar field to set the amount to\n+     * @param amount the amount to set\n+     * @return a new Date object set with the specified value\n+     * @throws IllegalArgumentException if the date is null\n+     * @since 2.4\n+     */\n+    private static Date set(Date date, int calendarField, int amount) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        // getInstance() returns a new object, so this method is thread safe.\n+        Calendar c = Calendar.getInstance();\n+        c.setLenient(false);\n+        c.setTime(date);\n+        c.set(calendarField, amount);\n+        return c.getTime();\n+    }   \n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Round this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if this was passed with HOUR, it would return\n+     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n+     * would return 1 April 2002 0:00:00.000.</p>\n+     * \n+     * <p>For a date in a timezone that handles the change to daylight\n+     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n+     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a \n+     * date that crosses this time would produce the following values:\n+     * <ul>\n+     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n+     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n+     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n+     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date  the date to work with\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Date round(Date date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar gval = Calendar.getInstance();\n+        gval.setTime(date);\n+        modify(gval, field, MODIFY_ROUND);\n+        return gval.getTime();\n+    }\n+\n+    /**\n+     * <p>Round this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if this was passed with HOUR, it would return\n+     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n+     * would return 1 April 2002 0:00:00.000.</p>\n+     * \n+     * <p>For a date in a timezone that handles the change to daylight\n+     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n+     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a \n+     * date that crosses this time would produce the following values:\n+     * <ul>\n+     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n+     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n+     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n+     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date  the date to work with\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date (a different object)\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Calendar round(Calendar date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar rounded = (Calendar) date.clone();\n+        modify(rounded, field, MODIFY_ROUND);\n+        return rounded;\n+    }\n+\n+    /**\n+     * <p>Round this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if this was passed with HOUR, it would return\n+     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n+     * would return 1 April 2002 0:00:00.000.</p>\n+     * \n+     * <p>For a date in a timezone that handles the change to daylight\n+     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n+     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a \n+     * date that crosses this time would produce the following values:\n+     * <ul>\n+     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n+     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n+     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n+     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date  the date to work with, either Date or Calendar\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws ClassCastException if the object type is not a <code>Date</code>\n+     *  or <code>Calendar</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Date round(Object date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        if (date instanceof Date) {\n+            return round((Date) date, field);\n+        } else if (date instanceof Calendar) {\n+            return round((Calendar) date, field).getTime();\n+        } else {\n+            throw new ClassCastException(\"Could not round \" + date);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Truncate this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n+     * return 1 Mar 2002 0:00:00.000.</p>\n+     * \n+     * @param date  the date to work with\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Date truncate(Date date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar gval = Calendar.getInstance();\n+        gval.setTime(date);\n+        modify(gval, field, MODIFY_TRUNCATE);\n+        return gval.getTime();\n+    }\n+\n+    /**\n+     * <p>Truncate this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n+     * return 1 Mar 2002 0:00:00.000.</p>\n+     * \n+     * @param date  the date to work with\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date (a different object)\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Calendar truncate(Calendar date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar truncated = (Calendar) date.clone();\n+        modify(truncated, field, MODIFY_TRUNCATE);\n+        return truncated;\n+    }\n+\n+    /**\n+     * <p>Truncate this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n+     * return 1 Mar 2002 0:00:00.000.</p>\n+     * \n+     * @param date  the date to work with, either <code>Date</code>\n+     *  or <code>Calendar</code>\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date\n+     * @throws IllegalArgumentException if the date\n+     *  is <code>null</code>\n+     * @throws ClassCastException if the object type is not a\n+     *  <code>Date</code> or <code>Calendar</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Date truncate(Object date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        if (date instanceof Date) {\n+            return truncate((Date) date, field);\n+        } else if (date instanceof Calendar) {\n+            return truncate((Calendar) date, field).getTime();\n+        } else {\n+            throw new ClassCastException(\"Could not truncate \" + date);\n+        }\n+    }\n+    \n+  //-----------------------------------------------------------------------\n+    /**\n+     * <p>Ceil this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n+     * return 1 Mar 2002 0:00:00.000.</p>\n+     * \n+     * @param date  the date to work with\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Date ceiling(Date date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar gval = Calendar.getInstance();\n+        gval.setTime(date);\n+        modify(gval, field, MODIFY_CEILING);\n+        return gval.getTime();\n+    }\n+\n+    /**\n+     * <p>Ceil this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n+     * return 1 Mar 2002 0:00:00.000.</p>\n+     * \n+     * @param date  the date to work with\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date (a different object)\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Calendar ceiling(Calendar date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar ceiled = (Calendar) date.clone();\n+        modify(ceiled, field, MODIFY_CEILING);\n+        return ceiled;\n+    }\n+\n+    /**\n+     * <p>Ceil this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n+     * return 1 Mar 2002 0:00:00.000.</p>\n+     * \n+     * @param date  the date to work with, either <code>Date</code>\n+     *  or <code>Calendar</code>\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date\n+     * @throws IllegalArgumentException if the date\n+     *  is <code>null</code>\n+     * @throws ClassCastException if the object type is not a\n+     *  <code>Date</code> or <code>Calendar</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Date ceiling(Object date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        if (date instanceof Date) {\n+            return ceiling((Date) date, field);\n+        } else if (date instanceof Calendar) {\n+            return ceiling((Calendar) date, field).getTime();\n+        } else {\n+            throw new ClassCastException(\"Could not find ceiling of for type: \" + date.getClass());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Internal calculation method.</p>\n+     * \n+     * @param val  the calendar\n+     * @param field  the field constant\n+     * @param modType  type to truncate, round or ceiling\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    private static void modify(Calendar val, int field, int modType) {\n+        if (val.get(Calendar.YEAR) > 280000000) {\n+            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n+        }\n+        \n+        if (field == Calendar.MILLISECOND) {\n+            return;\n+        }\n+\n+        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n+        // see http://issues.apache.org/jira/browse/LANG-59\n+        //\n+        // Manually truncate milliseconds, seconds and minutes, rather than using\n+        // Calendar methods.\n+\n+        Date date = val.getTime();\n+        long time = date.getTime();\n+        boolean done = false;\n+\n+        // truncate milliseconds\n+        int millisecs = val.get(Calendar.MILLISECOND);\n+        if (MODIFY_TRUNCATE == modType || millisecs < 500) {\n+            time = time - millisecs;\n+        }\n+        if (field == Calendar.SECOND) {\n+            done = true;\n+        }\n+\n+        // truncate seconds\n+        int seconds = val.get(Calendar.SECOND);\n+        if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) {\n+            time = time - (seconds * 1000L);\n+        }\n+        if (field == Calendar.MINUTE) {\n+            done = true;\n+        }\n+\n+        // truncate minutes\n+        int minutes = val.get(Calendar.MINUTE);\n+        if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) {\n+            time = time - (minutes * 60000L);\n+        }\n+\n+        // reset time\n+        if (date.getTime() != time) {\n+            date.setTime(time);\n+            val.setTime(date);\n+        }\n+        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n+\n+        boolean roundUp = false;\n+        for (int i = 0; i < fields.length; i++) {\n+            for (int j = 0; j < fields[i].length; j++) {\n+                if (fields[i][j] == field) {\n+                    //This is our field... we stop looping\n+                    if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) {\n+                        if (field == DateUtils.SEMI_MONTH) {\n+                            //This is a special case that's hard to generalize\n+                            //If the date is 1, we round up to 16, otherwise\n+                            //  we subtract 15 days and add 1 month\n+                            if (val.get(Calendar.DATE) == 1) {\n+                                val.add(Calendar.DATE, 15);\n+                            } else {\n+                                val.add(Calendar.DATE, -15);\n+                                val.add(Calendar.MONTH, 1);\n+                            }\n+// ----------------- Fix for LANG-440 ---------------------- START ---------------\n+                        } else if (field == Calendar.AM_PM) {\n+                            // This is a special case\n+                            // If the time is 0, we round up to 12, otherwise\n+                            //  we subtract 12 hours and add 1 day\n+                            if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n+                                val.add(Calendar.HOUR_OF_DAY, 12);\n+                            } else {\n+                                val.add(Calendar.HOUR_OF_DAY, -12);\n+                                val.add(Calendar.DATE, 1);\n+                            }\n+// ----------------- Fix for LANG-440 ---------------------- END ---------------\n+                        } else {\n+                            //We need at add one to this field since the\n+                            //  last number causes us to round up\n+                            val.add(fields[i][0], 1);\n+                        }\n+                    }\n+                    return;\n+                }\n+            }\n+            //We have various fields that are not easy roundings\n+            int offset = 0;\n+            boolean offsetSet = false;\n+            //These are special types of fields that require different rounding rules\n+            switch (field) {\n+                case DateUtils.SEMI_MONTH:\n+                    if (fields[i][0] == Calendar.DATE) {\n+                        //If we're going to drop the DATE field's value,\n+                        //  we want to do this our own way.\n+                        //We need to subtrace 1 since the date has a minimum of 1\n+                        offset = val.get(Calendar.DATE) - 1;\n+                        //If we're above 15 days adjustment, that means we're in the\n+                        //  bottom half of the month and should stay accordingly.\n+                        if (offset >= 15) {\n+                            offset -= 15;\n+                        }\n+                        //Record whether we're in the top or bottom half of that range\n+                        roundUp = offset > 7;\n+                        offsetSet = true;\n+                    }\n+                    break;\n+                case Calendar.AM_PM:\n+                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n+                        //If we're going to drop the HOUR field's value,\n+                        //  we want to do this our own way.\n+                        offset = val.get(Calendar.HOUR_OF_DAY);\n+                        if (offset >= 12) {\n+                            offset -= 12;\n+                        }\n+                        roundUp = offset >= 6;\n+                        offsetSet = true;\n+                    }\n+                    break;\n+            }\n+            if (!offsetSet) {\n+                int min = val.getActualMinimum(fields[i][0]);\n+                int max = val.getActualMaximum(fields[i][0]);\n+                //Calculate the offset from the minimum allowed value\n+                offset = val.get(fields[i][0]) - min;\n+                //Set roundUp if this is more than half way between the minimum and maximum\n+                roundUp = offset > ((max - min) / 2);\n+            }\n+            //We need to remove this field\n+            if (offset != 0) {\n+                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n+            }\n+        }\n+        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>This constructs an <code>Iterator</code> over each day in a date\n+     * range defined by a focus date and range style.</p>\n+     *\n+     * <p>For instance, passing Thursday, July 4, 2002 and a\n+     * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>\n+     * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,\n+     * 2002, returning a Calendar instance for each intermediate day.</p>\n+     *\n+     * <p>This method provides an iterator that returns Calendar objects.\n+     * The days are progressed using {@link Calendar#add(int, int)}.</p>\n+     *\n+     * @param focus  the date to work with, not null\n+     * @param rangeStyle  the style constant to use. Must be one of\n+     * {@link DateUtils#RANGE_MONTH_SUNDAY}, \n+     * {@link DateUtils#RANGE_MONTH_MONDAY},\n+     * {@link DateUtils#RANGE_WEEK_SUNDAY},\n+     * {@link DateUtils#RANGE_WEEK_MONDAY},\n+     * {@link DateUtils#RANGE_WEEK_RELATIVE},\n+     * {@link DateUtils#RANGE_WEEK_CENTER}\n+     * @return the date iterator, which always returns Calendar instances\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws IllegalArgumentException if the rangeStyle is invalid\n+     */\n+    public static Iterator<Calendar> iterator(Date focus, int rangeStyle) {\n+        if (focus == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar gval = Calendar.getInstance();\n+        gval.setTime(focus);\n+        return iterator(gval, rangeStyle);\n+    }\n+\n+    /**\n+     * <p>This constructs an <code>Iterator</code> over each day in a date\n+     * range defined by a focus date and range style.</p>\n+     *\n+     * <p>For instance, passing Thursday, July 4, 2002 and a\n+     * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>\n+     * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,\n+     * 2002, returning a Calendar instance for each intermediate day.</p>\n+     *\n+     * <p>This method provides an iterator that returns Calendar objects.\n+     * The days are progressed using {@link Calendar#add(int, int)}.</p>\n+     *\n+     * @param focus  the date to work with\n+     * @param rangeStyle  the style constant to use. Must be one of\n+     * {@link DateUtils#RANGE_MONTH_SUNDAY}, \n+     * {@link DateUtils#RANGE_MONTH_MONDAY},\n+     * {@link DateUtils#RANGE_WEEK_SUNDAY},\n+     * {@link DateUtils#RANGE_WEEK_MONDAY},\n+     * {@link DateUtils#RANGE_WEEK_RELATIVE},\n+     * {@link DateUtils#RANGE_WEEK_CENTER}\n+     * @return the date iterator\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws IllegalArgumentException if the rangeStyle is invalid\n+     */\n+    public static Iterator<Calendar> iterator(Calendar focus, int rangeStyle) {\n+        if (focus == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar start = null;\n+        Calendar end = null;\n+        int startCutoff = Calendar.SUNDAY;\n+        int endCutoff = Calendar.SATURDAY;\n+        switch (rangeStyle) {\n+            case RANGE_MONTH_SUNDAY:\n+            case RANGE_MONTH_MONDAY:\n+                //Set start to the first of the month\n+                start = truncate(focus, Calendar.MONTH);\n+                //Set end to the last of the month\n+                end = (Calendar) start.clone();\n+                end.add(Calendar.MONTH, 1);\n+                end.add(Calendar.DATE, -1);\n+                //Loop start back to the previous sunday or monday\n+                if (rangeStyle == RANGE_MONTH_MONDAY) {\n+                    startCutoff = Calendar.MONDAY;\n+                    endCutoff = Calendar.SUNDAY;\n+                }\n+                break;\n+            case RANGE_WEEK_SUNDAY:\n+            case RANGE_WEEK_MONDAY:\n+            case RANGE_WEEK_RELATIVE:\n+            case RANGE_WEEK_CENTER:\n+                //Set start and end to the current date\n+                start = truncate(focus, Calendar.DATE);\n+                end = truncate(focus, Calendar.DATE);\n+                switch (rangeStyle) {\n+                    case RANGE_WEEK_SUNDAY:\n+                        //already set by default\n+                        break;\n+                    case RANGE_WEEK_MONDAY:\n+                        startCutoff = Calendar.MONDAY;\n+                        endCutoff = Calendar.SUNDAY;\n+                        break;\n+                    case RANGE_WEEK_RELATIVE:\n+                        startCutoff = focus.get(Calendar.DAY_OF_WEEK);\n+                        endCutoff = startCutoff - 1;\n+                        break;\n+                    case RANGE_WEEK_CENTER:\n+                        startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3;\n+                        endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3;\n+                        break;\n+                }\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"The range style \" + rangeStyle + \" is not valid.\");\n+        }\n+        if (startCutoff < Calendar.SUNDAY) {\n+            startCutoff += 7;\n+        }\n+        if (startCutoff > Calendar.SATURDAY) {\n+            startCutoff -= 7;\n+        }\n+        if (endCutoff < Calendar.SUNDAY) {\n+            endCutoff += 7;\n+        }\n+        if (endCutoff > Calendar.SATURDAY) {\n+            endCutoff -= 7;\n+        }\n+        while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) {\n+            start.add(Calendar.DATE, -1);\n+        }\n+        while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {\n+            end.add(Calendar.DATE, 1);\n+        }\n+        return new DateIterator(start, end);\n+    }\n+\n+    /**\n+     * <p>This constructs an <code>Iterator</code> over each day in a date\n+     * range defined by a focus date and range style.</p>\n+     *\n+     * <p>For instance, passing Thursday, July 4, 2002 and a\n+     * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>\n+     * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,\n+     * 2002, returning a Calendar instance for each intermediate day.</p>\n+     *\n+     * @param focus  the date to work with, either\n+     *  <code>Date</code> or <code>Calendar</code>\n+     * @param rangeStyle  the style constant to use. Must be one of the range\n+     * styles listed for the {@link #iterator(Calendar, int)} method.\n+     * @return the date iterator\n+     * @throws IllegalArgumentException if the date\n+     *  is <code>null</code>\n+     * @throws ClassCastException if the object type is\n+     *  not a <code>Date</code> or <code>Calendar</code>\n+     */\n+    public static Iterator<?> iterator(Object focus, int rangeStyle) {\n+        if (focus == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        if (focus instanceof Date) {\n+            return iterator((Date) focus, rangeStyle);\n+        } else if (focus instanceof Calendar) {\n+            return iterator((Calendar) focus, rangeStyle);\n+        } else {\n+            throw new ClassCastException(\"Could not iterate based on \" + focus);\n+        }\n+    }\n+    \n+    /**\n+     * <p>Returns the number of milliseconds within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p>\n+     * \n+     * <p>Asking the milliseconds of any date will only return the number of milliseconds\n+     * of the current second (resulting in a number between 0 and 999). This \n+     * method will retrieve the number of milliseconds for any fragment. \n+     * For example, if you want to calculate the number of milliseconds past today, \n+     * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will\n+     * be all milliseconds of the past hour(s), minutes(s) and second(s).</p>\n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a SECOND field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10538 (10*1000 + 538)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n+     *   (a millisecond cannot be split in milliseconds)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date the date to work with, not null\n+     * @param fragment the Calendar field part of date to calculate \n+     * @return number of milliseconds within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or\n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInMilliseconds(Date date, int fragment) {\n+        return getFragment(date, fragment, Calendar.MILLISECOND);    \n+    }\n+    \n+    /**\n+     * <p>Returns the number of seconds within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the seconds of any date will only return the number of seconds\n+     * of the current minute (resulting in a number between 0 and 59). This \n+     * method will retrieve the number of seconds for any fragment. \n+     * For example, if you want to calculate the number of seconds past today, \n+     * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will\n+     * be all seconds of the past hour(s) and minutes(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a SECOND field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10\n+     *   (equivalent to deprecated date.getSeconds())</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10\n+     *   (equivalent to deprecated date.getSeconds())</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 26110\n+     *   (7*3600 + 15*60 + 10)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n+     *   (a millisecond cannot be split in seconds)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date the date to work with, not null\n+     * @param fragment the Calendar field part of date to calculate \n+     * @return number of seconds within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or\n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInSeconds(Date date, int fragment) {\n+        return getFragment(date, fragment, Calendar.SECOND);\n+    }\n+    \n+    /**\n+     * <p>Returns the number of minutes within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the minutes of any date will only return the number of minutes\n+     * of the current hour (resulting in a number between 0 and 59). This \n+     * method will retrieve the number of minutes for any fragment. \n+     * For example, if you want to calculate the number of minutes past this month, \n+     * your fragment is Calendar.MONTH. The result will be all minutes of the \n+     * past day(s) and hour(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a MINUTE field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15\n+     *   (equivalent to deprecated date.getMinutes())</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15\n+     *   (equivalent to deprecated date.getMinutes())</li>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 15</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 435 (7*60 + 15)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n+     *   (a millisecond cannot be split in minutes)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date the date to work with, not null\n+     * @param fragment the Calendar field part of date to calculate \n+     * @return number of minutes within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInMinutes(Date date, int fragment) {\n+        return getFragment(date, fragment, Calendar.MINUTE);\n+    }\n+    \n+    /**\n+     * <p>Returns the number of hours within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the hours of any date will only return the number of hours\n+     * of the current day (resulting in a number between 0 and 23). This \n+     * method will retrieve the number of hours for any fragment. \n+     * For example, if you want to calculate the number of hours past this month, \n+     * your fragment is Calendar.MONTH. The result will be all hours of the \n+     * past day(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a HOUR field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7\n+     *   (equivalent to deprecated date.getHours())</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7\n+     *   (equivalent to deprecated date.getHours())</li>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 7</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 127 (5*24 + 7)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n+     *   (a millisecond cannot be split in hours)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date the date to work with, not null\n+     * @param fragment the Calendar field part of date to calculate \n+     * @return number of hours within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInHours(Date date, int fragment) {\n+        return getFragment(date, fragment, Calendar.HOUR_OF_DAY);\n+    }\n+    \n+    /**\n+     * <p>Returns the number of days within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the days of any date will only return the number of days\n+     * of the current month (resulting in a number between 1 and 31). This \n+     * method will retrieve the number of days for any fragment. \n+     * For example, if you want to calculate the number of days past this year, \n+     * your fragment is Calendar.YEAR. The result will be all days of the \n+     * past month(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a DAY field will return 0.</p> \n+     *  \n+     * <p>\n+     * <ul>\n+     *  <li>January 28, 2008 with Calendar.MONTH as fragment will return 28\n+     *   (equivalent to deprecated date.getDay())</li>\n+     *  <li>February 28, 2008 with Calendar.MONTH as fragment will return 28\n+     *   (equivalent to deprecated date.getDay())</li>\n+     *  <li>January 28, 2008 with Calendar.YEAR as fragment will return 28</li>\n+     *  <li>February 28, 2008 with Calendar.YEAR as fragment will return 59</li>\n+     *  <li>January 28, 2008 with Calendar.MILLISECOND as fragment will return 0\n+     *   (a millisecond cannot be split in days)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date the date to work with, not null\n+     * @param fragment the Calendar field part of date to calculate \n+     * @return number of days  within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInDays(Date date, int fragment) {\n+        return getFragment(date, fragment, Calendar.DAY_OF_YEAR);\n+    }\n+\n+    /**\n+     * <p>Returns the number of milliseconds within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the milliseconds of any date will only return the number of milliseconds\n+     * of the current second (resulting in a number between 0 and 999). This \n+     * method will retrieve the number of milliseconds for any fragment. \n+     * For example, if you want to calculate the number of seconds past today, \n+     * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will\n+     * be all seconds of the past hour(s), minutes(s) and second(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a MILLISECOND field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538\n+     *   (equivalent to calendar.get(Calendar.MILLISECOND))</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538\n+     *   (equivalent to calendar.get(Calendar.MILLISECOND))</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10538\n+     *   (10*1000 + 538)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n+     *   (a millisecond cannot be split in milliseconds)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param calendar the calendar to work with, not null\n+     * @param fragment the Calendar field part of calendar to calculate \n+     * @return number of milliseconds within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+  public static long getFragmentInMilliseconds(Calendar calendar, int fragment) {\n+    return getFragment(calendar, fragment, Calendar.MILLISECOND);\n+  }\n+    /**\n+     * <p>Returns the number of seconds within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the seconds of any date will only return the number of seconds\n+     * of the current minute (resulting in a number between 0 and 59). This \n+     * method will retrieve the number of seconds for any fragment. \n+     * For example, if you want to calculate the number of seconds past today, \n+     * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will\n+     * be all seconds of the past hour(s) and minutes(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a SECOND field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10\n+     *   (equivalent to calendar.get(Calendar.SECOND))</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10\n+     *   (equivalent to calendar.get(Calendar.SECOND))</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 26110\n+     *   (7*3600 + 15*60 + 10)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n+     *   (a millisecond cannot be split in seconds)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param calendar the calendar to work with, not null\n+     * @param fragment the Calendar field part of calendar to calculate \n+     * @return number of seconds within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInSeconds(Calendar calendar, int fragment) {\n+        return getFragment(calendar, fragment, Calendar.SECOND);\n+    }\n+    \n+    /**\n+     * <p>Returns the number of minutes within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the minutes of any date will only return the number of minutes\n+     * of the current hour (resulting in a number between 0 and 59). This \n+     * method will retrieve the number of minutes for any fragment. \n+     * For example, if you want to calculate the number of minutes past this month, \n+     * your fragment is Calendar.MONTH. The result will be all minutes of the \n+     * past day(s) and hour(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a MINUTE field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15\n+     *   (equivalent to calendar.get(Calendar.MINUTES))</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15\n+     *   (equivalent to calendar.get(Calendar.MINUTES))</li>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 15</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 435 (7*60 + 15)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n+     *   (a millisecond cannot be split in minutes)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param calendar the calendar to work with, not null\n+     * @param fragment the Calendar field part of calendar to calculate \n+     * @return number of minutes within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInMinutes(Calendar calendar, int fragment) {\n+        return getFragment(calendar, fragment, Calendar.MINUTE);\n+    }\n+    \n+    /**\n+     * <p>Returns the number of hours within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the hours of any date will only return the number of hours\n+     * of the current day (resulting in a number between 0 and 23). This \n+     * method will retrieve the number of hours for any fragment. \n+     * For example, if you want to calculate the number of hours past this month, \n+     * your fragment is Calendar.MONTH. The result will be all hours of the \n+     * past day(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a HOUR field will return 0.</p> \n+     *  \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7\n+     *   (equivalent to calendar.get(Calendar.HOUR_OF_DAY))</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7\n+     *   (equivalent to calendar.get(Calendar.HOUR_OF_DAY))</li>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 7</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 127 (5*24 + 7)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n+     *   (a millisecond cannot be split in hours)</li>\n+     * </ul>\n+     * </p>\n+     *  \n+     * @param calendar the calendar to work with, not null\n+     * @param fragment the Calendar field part of calendar to calculate \n+     * @return number of hours within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInHours(Calendar calendar, int fragment) {\n+        return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY);\n+    }\n+    \n+    /**\n+     * <p>Returns the number of days within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the days of any date will only return the number of days\n+     * of the current month (resulting in a number between 1 and 31). This \n+     * method will retrieve the number of days for any fragment. \n+     * For example, if you want to calculate the number of days past this year, \n+     * your fragment is Calendar.YEAR. The result will be all days of the \n+     * past month(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a DAY field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 28, 2008 with Calendar.MONTH as fragment will return 28\n+     *   (equivalent to calendar.get(Calendar.DAY_OF_MONTH))</li>\n+     *  <li>February 28, 2008 with Calendar.MONTH as fragment will return 28\n+     *   (equivalent to calendar.get(Calendar.DAY_OF_MONTH))</li>\n+     *  <li>January 28, 2008 with Calendar.YEAR as fragment will return 28\n+     *   (equivalent to calendar.get(Calendar.DAY_OF_YEAR))</li>\n+     *  <li>February 28, 2008 with Calendar.YEAR as fragment will return 59\n+     *   (equivalent to calendar.get(Calendar.DAY_OF_YEAR))</li>\n+     *  <li>January 28, 2008 with Calendar.MILLISECOND as fragment will return 0\n+     *   (a millisecond cannot be split in days)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param calendar the calendar to work with, not null\n+     * @param fragment the Calendar field part of calendar to calculate \n+     * @return number of days within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInDays(Calendar calendar, int fragment) {\n+        return getFragment(calendar, fragment, Calendar.DAY_OF_YEAR);\n+    }\n+    \n+    /**\n+     * Date-version for fragment-calculation in any unit\n+     * \n+     * @param date the date to work with, not null\n+     * @param fragment the Calendar field part of date to calculate \n+     * @param unit Calendar field defining the unit\n+     * @return number of units within the fragment of the date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    private static long getFragment(Date date, int fragment, int unit) {\n+        if(date == null) {\n+            throw  new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar calendar = Calendar.getInstance();\n+        calendar.setTime(date);\n+        return getFragment(calendar, fragment, unit);\n+    }\n+\n+    /**\n+     * Calendar-version for fragment-calculation in any unit\n+     * \n+     * @param calendar the calendar to work with, not null\n+     * @param fragment the Calendar field part of calendar to calculate \n+     * @param unit Calendar field defining the unit\n+     * @return number of units within the fragment of the calendar\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    private static long getFragment(Calendar calendar, int fragment, int unit) {\n+        if(calendar == null) {\n+            throw  new IllegalArgumentException(\"The date must not be null\"); \n+        }\n+        long millisPerUnit = getMillisPerUnit(unit);\n+        long result = 0;\n+        \n+        // Fragments bigger than a day require a breakdown to days\n+        switch (fragment) {\n+            case Calendar.YEAR:\n+                result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;\n+                break;\n+            case Calendar.MONTH:\n+                result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;\n+                break;\n+        }\n+\n+        switch (fragment) {\n+            // Number of days already calculated for these cases\n+            case Calendar.YEAR:\n+            case Calendar.MONTH:\n+            \n+            // The rest of the valid cases\n+            case Calendar.DAY_OF_YEAR:\n+            case Calendar.DATE:\n+                result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;\n+                //$FALL-THROUGH$\n+            case Calendar.HOUR_OF_DAY:\n+                result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;\n+                //$FALL-THROUGH$\n+            case Calendar.MINUTE:\n+                result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;\n+                //$FALL-THROUGH$\n+            case Calendar.SECOND:\n+                result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;\n+                break;\n+            case Calendar.MILLISECOND: break;//never useful\n+                default: throw new IllegalArgumentException(\"The fragment \" + fragment + \" is not supported\");\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Returns the number of millis of a datefield, if this is a constant value\n+     * \n+     * @param unit A Calendar field which is a valid unit for a fragment\n+     * @return number of millis\n+     * @throws IllegalArgumentException if date can't be represented in millisenconds\n+     * @since 2.4 \n+     */\n+    private static long getMillisPerUnit(int unit) {\n+        long result = Long.MAX_VALUE;\n+        switch (unit) {\n+            case Calendar.DAY_OF_YEAR:\n+            case Calendar.DATE:\n+                result = MILLIS_PER_DAY;\n+                break;\n+            case Calendar.HOUR_OF_DAY:\n+                result = MILLIS_PER_HOUR;\n+                break;\n+            case Calendar.MINUTE:\n+                result = MILLIS_PER_MINUTE;\n+                break;\n+            case Calendar.SECOND:\n+                result = MILLIS_PER_SECOND;\n+                break;\n+            case Calendar.MILLISECOND:\n+                result = 1;\n+                break;\n+            default: throw new IllegalArgumentException(\"The unit \" + unit + \" cannot be represented is milleseconds\");\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Date iterator.</p>\n+     */\n+    static class DateIterator implements Iterator<Calendar> {\n+        private final Calendar endFinal;\n+        private final Calendar spot;\n+        \n+        /**\n+         * Constructs a DateIterator that ranges from one date to another. \n+         *\n+         * @param startFinal start date (inclusive)\n+         * @param endFinal end date (not inclusive)\n+         */\n+        DateIterator(Calendar startFinal, Calendar endFinal) {\n+            super();\n+            this.endFinal = endFinal;\n+            spot = startFinal;\n+            spot.add(Calendar.DATE, -1);\n+        }\n+\n+        /**\n+         * Has the iterator not reached the end date yet?\n+         *\n+         * @return <code>true</code> if the iterator has yet to reach the end date\n+         */\n+        public boolean hasNext() {\n+            return spot.before(endFinal);\n+        }\n+\n+        /**\n+         * Return the next calendar in the iteration\n+         *\n+         * @return Object calendar for the next date\n+         */\n+        public Calendar next() {\n+            if (spot.equals(endFinal)) {\n+                throw new NoSuchElementException();\n+            }\n+            spot.add(Calendar.DATE, 1);\n+            return (Calendar) spot.clone();\n+        }\n+\n+        /**\n+         * Always throws UnsupportedOperationException.\n+         * \n+         * @throws UnsupportedOperationException\n+         * @see java.util.Iterator#remove()\n+         */\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/time/DurationFormatUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.TimeZone;\n+\n+import org.apache.commons.lang.StringUtils;\n+\n+/**\n+ * <p>Duration formatting utilities and constants. The following table describes the tokens \n+ * used in the pattern language for formatting. </p>\n+ * <table border=\"1\">\n+ *  <tr><th>character</th><th>duration element</th></tr>\n+ *  <tr><td>y</td><td>years</td></tr>\n+ *  <tr><td>M</td><td>months</td></tr>\n+ *  <tr><td>d</td><td>days</td></tr>\n+ *  <tr><td>H</td><td>hours</td></tr>\n+ *  <tr><td>m</td><td>minutes</td></tr>\n+ *  <tr><td>s</td><td>seconds</td></tr>\n+ *  <tr><td>S</td><td>milliseconds</td></tr>\n+ * </table>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Apache Ant - DateUtils\n+ * @author <a href=\"mailto:sbailliez@apache.org\">Stephane Bailliez</a>\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class DurationFormatUtils {\n+\n+    /**\n+     * <p>DurationFormatUtils instances should NOT be constructed in standard programming.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public DurationFormatUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * <p>Pattern used with <code>FastDateFormat</code> and <code>SimpleDateFormat</code>\n+     * for the ISO8601 period format used in durations.</p>\n+     * \n+     * @see org.apache.commons.lang.time.FastDateFormat\n+     * @see java.text.SimpleDateFormat\n+     */\n+    public static final String ISO_EXTENDED_FORMAT_PATTERN = \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.S'S'\";\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Formats the time gap as a string.</p>\n+     * \n+     * <p>The format used is ISO8601-like:\n+     * <i>H</i>:<i>m</i>:<i>s</i>.<i>S</i>.</p>\n+     * \n+     * @param durationMillis  the duration to format\n+     * @return the time as a String\n+     */\n+    public static String formatDurationHMS(long durationMillis) {\n+        return formatDuration(durationMillis, \"H:mm:ss.SSS\");\n+    }\n+\n+    /**\n+     * <p>Formats the time gap as a string.</p>\n+     * \n+     * <p>The format used is the ISO8601 period format.</p>\n+     * \n+     * <p>This method formats durations using the days and lower fields of the\n+     * ISO format pattern, such as P7D6TH5M4.321S.</p>\n+     * \n+     * @param durationMillis  the duration to format\n+     * @return the time as a String\n+     */\n+    public static String formatDurationISO(long durationMillis) {\n+        return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false);\n+    }\n+\n+    /**\n+     * <p>Formats the time gap as a string, using the specified format, and padding with zeros and \n+     * using the default timezone.</p>\n+     * \n+     * <p>This method formats durations using the days and lower fields of the\n+     * format pattern. Months and larger are not used.</p>\n+     * \n+     * @param durationMillis  the duration to format\n+     * @param format  the way in which to format the duration\n+     * @return the time as a String\n+     */\n+    public static String formatDuration(long durationMillis, String format) {\n+        return formatDuration(durationMillis, format, true);\n+    }\n+\n+    /**\n+     * <p>Formats the time gap as a string, using the specified format.\n+     * Padding the left hand side of numbers with zeroes is optional and \n+     * the timezone may be specified.</p>\n+     * \n+     * <p>This method formats durations using the days and lower fields of the\n+     * format pattern. Months and larger are not used.</p>\n+     * \n+     * @param durationMillis  the duration to format\n+     * @param format  the way in which to format the duration\n+     * @param padWithZeros  whether to pad the left hand side of numbers with 0's\n+     * @return the time as a String\n+     */\n+    public static String formatDuration(long durationMillis, String format, boolean padWithZeros) {\n+\n+        Token[] tokens = lexx(format);\n+\n+        int days         = 0;\n+        int hours        = 0;\n+        int minutes      = 0;\n+        int seconds      = 0;\n+        int milliseconds = 0;\n+        \n+        if (Token.containsTokenWithValue(tokens, d) ) {\n+            days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);\n+            durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);\n+        }\n+        if (Token.containsTokenWithValue(tokens, H) ) {\n+            hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);\n+            durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);\n+        }\n+        if (Token.containsTokenWithValue(tokens, m) ) {\n+            minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);\n+            durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);\n+        }\n+        if (Token.containsTokenWithValue(tokens, s) ) {\n+            seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);\n+            durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);\n+        }\n+        if (Token.containsTokenWithValue(tokens, S) ) {\n+            milliseconds = (int) durationMillis;\n+        }\n+\n+        return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);\n+    }\n+\n+    /**\n+     * <p>Formats an elapsed time into a plurialization correct string.</p>\n+     * \n+     * <p>This method formats durations using the days and lower fields of the\n+     * format pattern. Months and larger are not used.</p>\n+     * \n+     * @param durationMillis  the elapsed time to report in milliseconds\n+     * @param suppressLeadingZeroElements  suppresses leading 0 elements\n+     * @param suppressTrailingZeroElements  suppresses trailing 0 elements\n+     * @return the formatted text in days/hours/minutes/seconds\n+     */\n+    public static String formatDurationWords(\n+        long durationMillis,\n+        boolean suppressLeadingZeroElements,\n+        boolean suppressTrailingZeroElements) {\n+\n+        // This method is generally replacable by the format method, but \n+        // there are a series of tweaks and special cases that require \n+        // trickery to replicate.\n+        String duration = formatDuration(durationMillis, \"d' days 'H' hours 'm' minutes 's' seconds'\");\n+        if (suppressLeadingZeroElements) {\n+            // this is a temporary marker on the front. Like ^ in regexp.\n+            duration = \" \" + duration;\n+            String tmp = StringUtils.replaceOnce(duration, \" 0 days\", \"\");\n+            if (tmp.length() != duration.length()) {\n+                duration = tmp;\n+                tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n+                if (tmp.length() != duration.length()) {\n+                    duration = tmp;\n+                    tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\");\n+                    duration = tmp;\n+                    if (tmp.length() != duration.length()) {\n+                        duration = StringUtils.replaceOnce(tmp, \" 0 seconds\", \"\");\n+                    }\n+                }\n+            }\n+            if (duration.length() != 0) {\n+                // strip the space off again\n+                duration = duration.substring(1);\n+            }\n+        }\n+        if (suppressTrailingZeroElements) {\n+            String tmp = StringUtils.replaceOnce(duration, \" 0 seconds\", \"\");\n+            if (tmp.length() != duration.length()) {\n+                duration = tmp;\n+                tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\");\n+                if (tmp.length() != duration.length()) {\n+                    duration = tmp;\n+                    tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n+                    if (tmp.length() != duration.length()) {\n+                        duration = StringUtils.replaceOnce(tmp, \" 0 days\", \"\");\n+                    }\n+                }\n+            }\n+        }\n+        // handle plurals\n+        duration = \" \" + duration;\n+        duration = StringUtils.replaceOnce(duration, \" 1 seconds\", \" 1 second\");\n+        duration = StringUtils.replaceOnce(duration, \" 1 minutes\", \" 1 minute\");\n+        duration = StringUtils.replaceOnce(duration, \" 1 hours\", \" 1 hour\");\n+        duration = StringUtils.replaceOnce(duration, \" 1 days\", \" 1 day\");\n+        return duration.trim();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Formats the time gap as a string.</p>\n+     * \n+     * <p>The format used is the ISO8601 period format.</p>\n+     * \n+     * @param startMillis  the start of the duration to format\n+     * @param endMillis  the end of the duration to format\n+     * @return the time as a String\n+     */\n+    public static String formatPeriodISO(long startMillis, long endMillis) {\n+        return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());\n+    }\n+\n+    /**\n+     * <p>Formats the time gap as a string, using the specified format.\n+     * Padding the left hand side of numbers with zeroes is optional.\n+     * \n+     * @param startMillis  the start of the duration\n+     * @param endMillis  the end of the duration\n+     * @param format  the way in which to format the duration\n+     * @return the time as a String\n+     */\n+    public static String formatPeriod(long startMillis, long endMillis, String format) {\n+        return formatPeriod(startMillis, endMillis, format, true, TimeZone.getDefault());\n+    }\n+\n+    /**\n+     * <p>Formats the time gap as a string, using the specified format.\n+     * Padding the left hand side of numbers with zeroes is optional and \n+     * the timezone may be specified. </p>\n+     *\n+     * <p>When calculating the difference between months/days, it chooses to \n+     * calculate months first. So when working out the number of months and \n+     * days between January 15th and March 10th, it choose 1 month and \n+     * 23 days gained by choosing January->February = 1 month and then \n+     * calculating days forwards, and not the 1 month and 26 days gained by \n+     * choosing March -> February = 1 month and then calculating days \n+     * backwards. </p>\n+     *\n+     * <p>For more control, the <a href=\"http://joda-time.sf.net/\">Joda-Time</a>\n+     * library is recommended.</p>\n+     * \n+     * @param startMillis  the start of the duration\n+     * @param endMillis  the end of the duration\n+     * @param format  the way in which to format the duration\n+     * @param padWithZeros whether to pad the left hand side of numbers with 0's\n+     * @param timezone the millis are defined in\n+     * @return the time as a String\n+     */\n+    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n+            TimeZone timezone) {\n+\n+        // Used to optimise for differences under 28 days and \n+        // called formatDuration(millis, format); however this did not work \n+        // over leap years. \n+        // TODO: Compare performance to see if anything was lost by \n+        // losing this optimisation. \n+        \n+        Token[] tokens = lexx(format);\n+\n+        // timezones get funky around 0, so normalizing everything to GMT \n+        // stops the hours being off\n+        Calendar start = Calendar.getInstance(timezone);\n+        start.setTime(new Date(startMillis));\n+        Calendar end = Calendar.getInstance(timezone);\n+        end.setTime(new Date(endMillis));\n+\n+        // initial estimates\n+        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n+        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n+        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n+        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n+        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n+        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n+        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n+\n+        // each initial estimate is adjusted in case it is under 0\n+        while (milliseconds < 0) {\n+            milliseconds += 1000;\n+            seconds -= 1;\n+        }\n+        while (seconds < 0) {\n+            seconds += 60;\n+            minutes -= 1;\n+        }\n+        while (minutes < 0) {\n+            minutes += 60;\n+            hours -= 1;\n+        }\n+        while (hours < 0) {\n+            hours += 24;\n+            days -= 1;\n+        }\n+       \n+        if (Token.containsTokenWithValue(tokens, M)) {\n+            while (days < 0) {\n+                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n+                months -= 1;\n+                start.add(Calendar.MONTH, 1);\n+            }\n+\n+            while (months < 0) {\n+                months += 12;\n+                years -= 1;\n+            }\n+\n+            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n+                while (years != 0) {\n+                    months += 12 * years;\n+                    years = 0;\n+                }\n+            }\n+        } else {\n+            // there are no M's in the format string\n+\n+            if( !Token.containsTokenWithValue(tokens, y) ) {\n+                int target = end.get(Calendar.YEAR);\n+                if (months < 0) {\n+                    // target is end-year -1\n+                    target -= 1;\n+                }\n+                \n+                while ( (start.get(Calendar.YEAR) != target)) {\n+                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n+                    \n+                    // Not sure I grok why this is needed, but the brutal tests show it is\n+                    if(start instanceof GregorianCalendar) {\n+                        if( (start.get(Calendar.MONTH) == Calendar.FEBRUARY) &&\n+                            (start.get(Calendar.DAY_OF_MONTH) == 29 ) )\n+                        {\n+                            days += 1;\n+                        }\n+                    }\n+                    \n+                    start.add(Calendar.YEAR, 1);\n+                    \n+                    days += start.get(Calendar.DAY_OF_YEAR);\n+                }\n+                \n+                years = 0;\n+            }\n+            \n+            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n+                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n+                start.add(Calendar.MONTH, 1);\n+            }\n+            \n+            months = 0;            \n+\n+            while (days < 0) {\n+                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n+                months -= 1;\n+                start.add(Calendar.MONTH, 1);\n+            }\n+            \n+        }\n+\n+        // The rest of this code adds in values that \n+        // aren't requested. This allows the user to ask for the \n+        // number of months and get the real count and not just 0->11.\n+\n+        if (!Token.containsTokenWithValue(tokens, d)) {\n+            hours += 24 * days;\n+            days = 0;\n+        }\n+        if (!Token.containsTokenWithValue(tokens, H)) {\n+            minutes += 60 * hours;\n+            hours = 0;\n+        }\n+        if (!Token.containsTokenWithValue(tokens, m)) {\n+            seconds += 60 * minutes;\n+            minutes = 0;\n+        }\n+        if (!Token.containsTokenWithValue(tokens, s)) {\n+            milliseconds += 1000 * seconds;\n+            seconds = 0;\n+        }\n+\n+        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>The internal method to do the formatting.</p>\n+     * \n+     * @param tokens  the tokens\n+     * @param years  the number of years\n+     * @param months  the number of months\n+     * @param days  the number of days\n+     * @param hours  the number of hours\n+     * @param minutes  the number of minutes\n+     * @param seconds  the number of seconds\n+     * @param milliseconds  the number of millis\n+     * @param padWithZeros  whether to pad\n+     * @return the formatted string\n+     */\n+    static String format(Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds,\n+            int milliseconds, boolean padWithZeros) {\n+        StringBuffer buffer = new StringBuffer();\n+        boolean lastOutputSeconds = false;\n+        int sz = tokens.length;\n+        for (int i = 0; i < sz; i++) {\n+            Token token = tokens[i];\n+            Object value = token.getValue();\n+            int count = token.getCount();\n+            if (value instanceof StringBuffer) {\n+                buffer.append(value.toString());\n+            } else {\n+                if (value == y) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer\n+                            .toString(years));\n+                    lastOutputSeconds = false;\n+                } else if (value == M) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer\n+                            .toString(months));\n+                    lastOutputSeconds = false;\n+                } else if (value == d) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer\n+                            .toString(days));\n+                    lastOutputSeconds = false;\n+                } else if (value == H) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer\n+                            .toString(hours));\n+                    lastOutputSeconds = false;\n+                } else if (value == m) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer\n+                            .toString(minutes));\n+                    lastOutputSeconds = false;\n+                } else if (value == s) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer\n+                            .toString(seconds));\n+                    lastOutputSeconds = true;\n+                } else if (value == S) {\n+                    if (lastOutputSeconds) {\n+                        milliseconds += 1000;\n+                        String str = padWithZeros\n+                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n+                                : Integer.toString(milliseconds);\n+                        buffer.append(str.substring(1));\n+                    } else {\n+                        buffer.append(padWithZeros\n+                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n+                                : Integer.toString(milliseconds));\n+                    }\n+                    lastOutputSeconds = false;\n+                }\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    static final Object y = \"y\";\n+    static final Object M = \"M\";\n+    static final Object d = \"d\";\n+    static final Object H = \"H\";\n+    static final Object m = \"m\";\n+    static final Object s = \"s\";\n+    static final Object S = \"S\";\n+    \n+    /**\n+     * Parses a classic date format string into Tokens\n+     *\n+     * @param format to parse\n+     * @return array of Token[]\n+     */\n+    static Token[] lexx(String format) {\n+        char[] array = format.toCharArray();\n+        ArrayList<Token> list = new ArrayList<Token>(array.length);\n+\n+        boolean inLiteral = false;\n+        StringBuffer buffer = null;\n+        Token previous = null;\n+        int sz = array.length;\n+        for(int i=0; i<sz; i++) {\n+            char ch = array[i];\n+            if(inLiteral && ch != '\\'') {\n+                buffer.append(ch); // buffer can't be null if inLiteral is true\n+                continue;\n+            }\n+            Object value = null;\n+            switch(ch) {\n+                // TODO: Need to handle escaping of '\n+                case '\\'' : \n+                  if(inLiteral) {\n+                      buffer = null;\n+                      inLiteral = false;\n+                  } else {\n+                      buffer = new StringBuffer();\n+                      list.add(new Token(buffer));\n+                      inLiteral = true;\n+                  }\n+                  break;\n+                case 'y'  : value = y; break;\n+                case 'M'  : value = M; break;\n+                case 'd'  : value = d; break;\n+                case 'H'  : value = H; break;\n+                case 'm'  : value = m; break;\n+                case 's'  : value = s; break;\n+                case 'S'  : value = S; break;\n+                default   : \n+                  if(buffer == null) {\n+                      buffer = new StringBuffer();\n+                      list.add(new Token(buffer));\n+                  }\n+                  buffer.append(ch);\n+            }\n+\n+            if(value != null) {\n+                if(previous != null && previous.getValue() == value) {\n+                    previous.increment();\n+                } else {\n+                    Token token = new Token(value);\n+                    list.add(token); \n+                    previous = token;\n+                }\n+                buffer = null; \n+            }\n+        }\n+        return list.toArray( new Token[list.size()] );\n+    }\n+\n+    /**\n+     * Element that is parsed from the format pattern.\n+     */\n+    static class Token {\n+\n+        /**\n+         * Helper method to determine if a set of tokens contain a value\n+         *\n+         * @param tokens set to look in\n+         * @param value to look for\n+         * @return boolean <code>true</code> if contained\n+         */\n+        static boolean containsTokenWithValue(Token[] tokens, Object value) {\n+            int sz = tokens.length;\n+            for (int i = 0; i < sz; i++) {\n+                if (tokens[i].getValue() == value) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private Object value;\n+        private int count;\n+\n+        /**\n+         * Wraps a token around a value. A value would be something like a 'Y'.\n+         *\n+         * @param value to wrap\n+         */\n+        Token(Object value) {\n+            this.value = value;\n+            this.count = 1;\n+        }\n+\n+        /**\n+         * Wraps a token around a repeated number of a value, for example it would \n+         * store 'yyyy' as a value for y and a count of 4.\n+         *\n+         * @param value to wrap\n+         * @param count to wrap\n+         */\n+        Token(Object value, int count) {\n+            this.value = value;\n+            this.count = count;\n+        }\n+\n+        /**\n+         * Adds another one of the value\n+         */\n+        void increment() { \n+            count++;\n+        }\n+\n+        /**\n+         * Gets the current number of values represented\n+         *\n+         * @return int number of values represented\n+         */\n+        int getCount() {\n+            return count;\n+        }\n+\n+        /**\n+         * Gets the particular value this token represents.\n+         * \n+         * @return Object value\n+         */\n+        Object getValue() {\n+            return value;\n+        }\n+\n+        /**\n+         * Supports equality of this Token to another Token.\n+         *\n+         * @param obj2 Object to consider equality of\n+         * @return boolean <code>true</code> if equal\n+         */\n+        @Override\n+        public boolean equals(Object obj2) {\n+            if (obj2 instanceof Token) {\n+                Token tok2 = (Token) obj2;\n+                if (this.value.getClass() != tok2.value.getClass()) {\n+                    return false;\n+                }\n+                if (this.count != tok2.count) {\n+                    return false;\n+                }\n+                if (this.value instanceof StringBuffer) {\n+                    return this.value.toString().equals(tok2.value.toString());\n+                } else if (this.value instanceof Number) {\n+                    return this.value.equals(tok2.value);\n+                } else {\n+                    return this.value == tok2.value;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        /**\n+         * Returns a hashcode for the token equal to the \n+         * hashcode for the token's value. Thus 'TT' and 'TTTT' \n+         * will have the same hashcode. \n+         *\n+         * @return The hashcode for the token\n+         */\n+        @Override\n+        public int hashCode() {\n+            return this.value.hashCode();\n+        }\n+\n+        /**\n+         * Represents this token as a String.\n+         *\n+         * @return String representation of the token\n+         */\n+        @Override\n+        public String toString() {\n+            return StringUtils.repeat(this.value.toString(), this.count);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/time/FastDateFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.text.DateFormat;\n+import java.text.DateFormatSymbols;\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.ParsePosition;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.TimeZone;\n+\n+import org.apache.commons.lang.Validate;\n+\n+/**\n+ * <p>FastDateFormat is a fast and thread-safe version of\n+ * {@link java.text.SimpleDateFormat}.</p>\n+ * \n+ * <p>This class can be used as a direct replacement to\n+ * <code>SimpleDateFormat</code> in most formatting situations.\n+ * This class is especially useful in multi-threaded server environments.\n+ * <code>SimpleDateFormat</code> is not thread-safe in any JDK version,\n+ * nor will it be as Sun have closed the bug/RFE.\n+ * </p>\n+ *\n+ * <p>Only formatting is supported, but all patterns are compatible with\n+ * SimpleDateFormat (except time zones - see below).</p>\n+ *\n+ * <p>Java 1.4 introduced a new pattern letter, <code>'Z'</code>, to represent\n+ * time zones in RFC822 format (eg. <code>+0800</code> or <code>-1100</code>).\n+ * This pattern letter can be used here (on all JDK versions).</p>\n+ *\n+ * <p>In addition, the pattern <code>'ZZ'</code> has been made to represent\n+ * ISO8601 full format time zones (eg. <code>+08:00</code> or <code>-11:00</code>).\n+ * This introduces a minor incompatibility with Java 1.4, but at a gain of\n+ * useful functionality.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author TeaTrove project\n+ * @author Brian S O'Neill\n+ * @author Sean Schofield\n+ * @author Gary Gregory\n+ * @author Nikolay Metchev\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class FastDateFormat extends Format {\n+    // A lot of the speed in this class comes from caching, but some comes\n+    // from the special int to StringBuffer conversion.\n+    //\n+    // The following produces a padded 2 digit number:\n+    //   buffer.append((char)(value / 10 + '0'));\n+    //   buffer.append((char)(value % 10 + '0'));\n+    //\n+    // Note that the fastest append to StringBuffer is a single char (used here).\n+    // Note that Integer.toString() is not called, the conversion is simply\n+    // taking the value and adding (mathematically) the ASCII value for '0'.\n+    // So, don't change this code! It works and is very fast.\n+    \n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * FULL locale dependent date or time style.\n+     */\n+    public static final int FULL = DateFormat.FULL;\n+    /**\n+     * LONG locale dependent date or time style.\n+     */\n+    public static final int LONG = DateFormat.LONG;\n+    /**\n+     * MEDIUM locale dependent date or time style.\n+     */\n+    public static final int MEDIUM = DateFormat.MEDIUM;\n+    /**\n+     * SHORT locale dependent date or time style.\n+     */\n+    public static final int SHORT = DateFormat.SHORT;\n+    \n+    //@GuardedBy(\"this\")\n+    private static String cDefaultPattern; // lazily initialised by getInstance()\n+\n+    private static final Map<FastDateFormat, FastDateFormat> cInstanceCache = new HashMap<FastDateFormat, FastDateFormat>(7);\n+    private static final Map<Object, FastDateFormat> cDateInstanceCache = new HashMap<Object, FastDateFormat>(7);\n+    private static final Map<Object, FastDateFormat> cTimeInstanceCache = new HashMap<Object, FastDateFormat>(7);\n+    private static final Map<Object, FastDateFormat> cDateTimeInstanceCache = new HashMap<Object, FastDateFormat>(7);\n+    private static final Map<Object, String> cTimeZoneDisplayCache = new HashMap<Object, String>(7);\n+\n+    /**\n+     * The pattern.\n+     */\n+    private final String mPattern;\n+    /**\n+     * The time zone.\n+     */\n+    private final TimeZone mTimeZone;\n+    /**\n+     * Whether the time zone overrides any on Calendars.\n+     */\n+    private final boolean mTimeZoneForced;\n+    /**\n+     * The locale.\n+     */\n+    private final Locale mLocale;\n+    /**\n+     * Whether the locale overrides the default.\n+     */\n+    private final boolean mLocaleForced;\n+    /**\n+     * The parsed rules.\n+     */\n+    private transient Rule[] mRules;\n+    /**\n+     * The estimated maximum length.\n+     */\n+    private transient int mMaxLengthEstimate;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a formatter instance using the default pattern in the\n+     * default locale.</p>\n+     * \n+     * @return a date/time formatter\n+     */\n+    public static FastDateFormat getInstance() {\n+        return getInstance(getDefaultPattern(), null, null);\n+    }\n+\n+    /**\n+     * <p>Gets a formatter instance using the specified pattern in the\n+     * default locale.</p>\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n+     *  pattern\n+     * @return a pattern based date/time formatter\n+     * @throws IllegalArgumentException if pattern is invalid\n+     */\n+    public static FastDateFormat getInstance(String pattern) {\n+        return getInstance(pattern, null, null);\n+    }\n+\n+    /**\n+     * <p>Gets a formatter instance using the specified pattern and\n+     * time zone.</p>\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n+     *  pattern\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted date\n+     * @return a pattern based date/time formatter\n+     * @throws IllegalArgumentException if pattern is invalid\n+     */\n+    public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {\n+        return getInstance(pattern, timeZone, null);\n+    }\n+\n+    /**\n+     * <p>Gets a formatter instance using the specified pattern and\n+     * locale.</p>\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n+     *  pattern\n+     * @param locale  optional locale, overrides system locale\n+     * @return a pattern based date/time formatter\n+     * @throws IllegalArgumentException if pattern is invalid\n+     */\n+    public static FastDateFormat getInstance(String pattern, Locale locale) {\n+        return getInstance(pattern, null, locale);\n+    }\n+\n+    /**\n+     * <p>Gets a formatter instance using the specified pattern, time zone\n+     * and locale.</p>\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n+     *  pattern\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted date\n+     * @param locale  optional locale, overrides system locale\n+     * @return a pattern based date/time formatter\n+     * @throws IllegalArgumentException if pattern is invalid\n+     *  or <code>null</code>\n+     */\n+    public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\n+        FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);\n+        FastDateFormat format = cInstanceCache.get(emptyFormat);\n+        if (format == null) {\n+            format = emptyFormat;\n+            format.init();  // convert shell format into usable one\n+            cInstanceCache.put(format, format);  // this is OK!\n+        }\n+        return format;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a date formatter instance using the specified style in the\n+     * default time zone and locale.</p>\n+     * \n+     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @return a localized standard date formatter\n+     * @throws IllegalArgumentException if the Locale has no date\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getDateInstance(int style) {\n+        return getDateInstance(style, null, null);\n+    }\n+\n+    /**\n+     * <p>Gets a date formatter instance using the specified style and\n+     * locale in the default time zone.</p>\n+     * \n+     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard date formatter\n+     * @throws IllegalArgumentException if the Locale has no date\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getDateInstance(int style, Locale locale) {\n+        return getDateInstance(style, null, locale);\n+    }\n+\n+    /**\n+     * <p>Gets a date formatter instance using the specified style and\n+     * time zone in the default locale.</p>\n+     * \n+     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted date\n+     * @return a localized standard date formatter\n+     * @throws IllegalArgumentException if the Locale has no date\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {\n+        return getDateInstance(style, timeZone, null);\n+    }\n+    /**\n+     * <p>Gets a date formatter instance using the specified style, time\n+     * zone and locale.</p>\n+     * \n+     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted date\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard date formatter\n+     * @throws IllegalArgumentException if the Locale has no date\n+     *  pattern defined\n+     */\n+    public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {\n+        Object key = Integer.valueOf(style);\n+        if (timeZone != null) {\n+            key = new Pair(key, timeZone);\n+        }\n+\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+\n+        key = new Pair(key, locale);\n+\n+        FastDateFormat format = cDateInstanceCache.get(key);\n+        if (format == null) {\n+            try {\n+                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n+                String pattern = formatter.toPattern();\n+                format = getInstance(pattern, timeZone, locale);\n+                cDateInstanceCache.put(key, format);\n+                \n+            } catch (ClassCastException ex) {\n+                throw new IllegalArgumentException(\"No date pattern for locale: \" + locale);\n+            }\n+        }\n+        return format;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a time formatter instance using the specified style in the\n+     * default time zone and locale.</p>\n+     * \n+     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @return a localized standard time formatter\n+     * @throws IllegalArgumentException if the Locale has no time\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getTimeInstance(int style) {\n+        return getTimeInstance(style, null, null);\n+    }\n+\n+    /**\n+     * <p>Gets a time formatter instance using the specified style and\n+     * locale in the default time zone.</p>\n+     * \n+     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard time formatter\n+     * @throws IllegalArgumentException if the Locale has no time\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getTimeInstance(int style, Locale locale) {\n+        return getTimeInstance(style, null, locale);\n+    }\n+    \n+    /**\n+     * <p>Gets a time formatter instance using the specified style and\n+     * time zone in the default locale.</p>\n+     * \n+     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted time\n+     * @return a localized standard time formatter\n+     * @throws IllegalArgumentException if the Locale has no time\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) {\n+        return getTimeInstance(style, timeZone, null);\n+    }\n+    \n+    /**\n+     * <p>Gets a time formatter instance using the specified style, time\n+     * zone and locale.</p>\n+     * \n+     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted time\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard time formatter\n+     * @throws IllegalArgumentException if the Locale has no time\n+     *  pattern defined\n+     */\n+    public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {\n+        Object key = Integer.valueOf(style);\n+        if (timeZone != null) {\n+            key = new Pair(key, timeZone);\n+        }\n+        if (locale != null) {\n+            key = new Pair(key, locale);\n+        }\n+\n+        FastDateFormat format = cTimeInstanceCache.get(key);\n+        if (format == null) {\n+            if (locale == null) {\n+                locale = Locale.getDefault();\n+            }\n+\n+            try {\n+                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);\n+                String pattern = formatter.toPattern();\n+                format = getInstance(pattern, timeZone, locale);\n+                cTimeInstanceCache.put(key, format);\n+            \n+            } catch (ClassCastException ex) {\n+                throw new IllegalArgumentException(\"No date pattern for locale: \" + locale);\n+            }\n+        }\n+        return format;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a date/time formatter instance using the specified style\n+     * in the default time zone and locale.</p>\n+     * \n+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @return a localized standard date/time formatter\n+     * @throws IllegalArgumentException if the Locale has no date/time\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getDateTimeInstance(\n+            int dateStyle, int timeStyle) {\n+        return getDateTimeInstance(dateStyle, timeStyle, null, null);\n+    }\n+    \n+    /**\n+     * <p>Gets a date/time formatter instance using the specified style and\n+     * locale in the default time zone.</p>\n+     * \n+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard date/time formatter\n+     * @throws IllegalArgumentException if the Locale has no date/time\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getDateTimeInstance(\n+            int dateStyle, int timeStyle, Locale locale) {\n+        return getDateTimeInstance(dateStyle, timeStyle, null, locale);\n+    }\n+    \n+    /**\n+     * <p>Gets a date/time formatter instance using the specified style and\n+     * time zone in the default locale.</p>\n+     * \n+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted date\n+     * @return a localized standard date/time formatter\n+     * @throws IllegalArgumentException if the Locale has no date/time\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getDateTimeInstance(\n+            int dateStyle, int timeStyle, TimeZone timeZone) {\n+        return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);\n+    }    \n+    /**\n+     * <p>Gets a date/time formatter instance using the specified style,\n+     * time zone and locale.</p>\n+     * \n+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted date\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard date/time formatter\n+     * @throws IllegalArgumentException if the Locale has no date/time\n+     *  pattern defined\n+     */\n+    public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone,\n+            Locale locale) {\n+\n+        Object key = new Pair(Integer.valueOf(dateStyle), Integer.valueOf(timeStyle));\n+        if (timeZone != null) {\n+            key = new Pair(key, timeZone);\n+        }\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+        key = new Pair(key, locale);\n+\n+        FastDateFormat format = cDateTimeInstanceCache.get(key);\n+        if (format == null) {\n+            try {\n+                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n+                        locale);\n+                String pattern = formatter.toPattern();\n+                format = getInstance(pattern, timeZone, locale);\n+                cDateTimeInstanceCache.put(key, format);\n+\n+            } catch (ClassCastException ex) {\n+                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n+            }\n+        }\n+        return format;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the time zone display name, using a cache for performance.</p>\n+     * \n+     * @param tz  the zone to query\n+     * @param daylight  true if daylight savings\n+     * @param style  the style to use <code>TimeZone.LONG</code>\n+     *  or <code>TimeZone.SHORT</code>\n+     * @param locale  the locale to use\n+     * @return the textual name of the time zone\n+     */\n+    static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\n+        Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n+        String value = cTimeZoneDisplayCache.get(key);\n+        if (value == null) {\n+            // This is a very slow call, so cache the results.\n+            value = tz.getDisplayName(daylight, style, locale);\n+            cTimeZoneDisplayCache.put(key, value);\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * <p>Gets the default pattern.</p>\n+     * \n+     * @return the default pattern\n+     */\n+    private static synchronized String getDefaultPattern() {\n+        if (cDefaultPattern == null) {\n+            cDefaultPattern = new SimpleDateFormat().toPattern();\n+        }\n+        return cDefaultPattern;\n+    }\n+\n+    // Constructor\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Constructs a new FastDateFormat.</p>\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n+     *  pattern\n+     * @param timeZone  time zone to use, <code>null</code> means use\n+     *  default for <code>Date</code> and value within for\n+     *  <code>Calendar</code>\n+     * @param locale  locale, <code>null</code> means use system\n+     *  default\n+     * @throws IllegalArgumentException if pattern is invalid or\n+     *  <code>null</code>\n+     */\n+    protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\n+        super();\n+        if (pattern == null) {\n+            throw new IllegalArgumentException(\"The pattern must not be null\");\n+        }\n+        mPattern = pattern;\n+        \n+        mTimeZoneForced = (timeZone != null);\n+        if (timeZone == null) {\n+            timeZone = TimeZone.getDefault();\n+        }\n+        mTimeZone = timeZone;\n+        \n+        mLocaleForced = (locale != null);\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+        mLocale = locale;\n+    }\n+\n+    /**\n+     * <p>Initializes the instance for first use.</p>\n+     */\n+    protected void init() {\n+        List<Rule> rulesList = parsePattern();\n+        mRules = rulesList.toArray(new Rule[rulesList.size()]);\n+\n+        int len = 0;\n+        for (int i=mRules.length; --i >= 0; ) {\n+            len += mRules[i].estimateLength();\n+        }\n+\n+        mMaxLengthEstimate = len;\n+    }\n+\n+    // Parse the pattern\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns a list of Rules given a pattern.</p>\n+     * \n+     * @return a <code>List</code> of Rule objects\n+     * @throws IllegalArgumentException if pattern is invalid\n+     */\n+    protected List<Rule> parsePattern() {\n+        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n+        List<Rule> rules = new ArrayList<Rule>();\n+\n+        String[] ERAs = symbols.getEras();\n+        String[] months = symbols.getMonths();\n+        String[] shortMonths = symbols.getShortMonths();\n+        String[] weekdays = symbols.getWeekdays();\n+        String[] shortWeekdays = symbols.getShortWeekdays();\n+        String[] AmPmStrings = symbols.getAmPmStrings();\n+\n+        int length = mPattern.length();\n+        int[] indexRef = new int[1];\n+\n+        for (int i = 0; i < length; i++) {\n+            indexRef[0] = i;\n+            String token = parseToken(mPattern, indexRef);\n+            i = indexRef[0];\n+\n+            int tokenLen = token.length();\n+            if (tokenLen == 0) {\n+                break;\n+            }\n+\n+            Rule rule;\n+            char c = token.charAt(0);\n+\n+            switch (c) {\n+            case 'G': // era designator (text)\n+                rule = new TextField(Calendar.ERA, ERAs);\n+                break;\n+            case 'y': // year (number)\n+                if (tokenLen >= 4) {\n+                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n+                } else {\n+                    rule = TwoDigitYearField.INSTANCE;\n+                }\n+                break;\n+            case 'M': // month in year (text and number)\n+                if (tokenLen >= 4) {\n+                    rule = new TextField(Calendar.MONTH, months);\n+                } else if (tokenLen == 3) {\n+                    rule = new TextField(Calendar.MONTH, shortMonths);\n+                } else if (tokenLen == 2) {\n+                    rule = TwoDigitMonthField.INSTANCE;\n+                } else {\n+                    rule = UnpaddedMonthField.INSTANCE;\n+                }\n+                break;\n+            case 'd': // day in month (number)\n+                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n+                break;\n+            case 'h': // hour in am/pm (number, 1..12)\n+                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n+                break;\n+            case 'H': // hour in day (number, 0..23)\n+                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n+                break;\n+            case 'm': // minute in hour (number)\n+                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n+                break;\n+            case 's': // second in minute (number)\n+                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n+                break;\n+            case 'S': // millisecond (number)\n+                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n+                break;\n+            case 'E': // day in week (text)\n+                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n+                break;\n+            case 'D': // day in year (number)\n+                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n+                break;\n+            case 'F': // day of week in month (number)\n+                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n+                break;\n+            case 'w': // week in year (number)\n+                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n+                break;\n+            case 'W': // week in month (number)\n+                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n+                break;\n+            case 'a': // am/pm marker (text)\n+                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n+                break;\n+            case 'k': // hour in day (1..24)\n+                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n+                break;\n+            case 'K': // hour in am/pm (0..11)\n+                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n+                break;\n+            case 'z': // time zone (text)\n+                if (tokenLen >= 4) {\n+                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);\n+                } else {\n+                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);\n+                }\n+                break;\n+            case 'Z': // time zone (value)\n+                if (tokenLen == 1) {\n+                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n+                } else {\n+                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n+                }\n+                break;\n+            case '\\'': // literal text\n+                String sub = token.substring(1);\n+                if (sub.length() == 1) {\n+                    rule = new CharacterLiteral(sub.charAt(0));\n+                } else {\n+                    rule = new StringLiteral(sub);\n+                }\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n+            }\n+\n+            rules.add(rule);\n+        }\n+\n+        return rules;\n+    }\n+\n+    /**\n+     * <p>Performs the parsing of tokens.</p>\n+     * \n+     * @param pattern  the pattern\n+     * @param indexRef  index references\n+     * @return parsed token\n+     */\n+    protected String parseToken(String pattern, int[] indexRef) {\n+        StringBuilder buf = new StringBuilder();\n+\n+        int i = indexRef[0];\n+        int length = pattern.length();\n+\n+        char c = pattern.charAt(i);\n+        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n+            // Scan a run of the same character, which indicates a time\n+            // pattern.\n+            buf.append(c);\n+\n+            while (i + 1 < length) {\n+                char peek = pattern.charAt(i + 1);\n+                if (peek == c) {\n+                    buf.append(c);\n+                    i++;\n+                } else {\n+                    break;\n+                }\n+            }\n+        } else {\n+            // This will identify token as text.\n+            buf.append('\\'');\n+\n+            boolean inLiteral = false;\n+\n+            for (; i < length; i++) {\n+                c = pattern.charAt(i);\n+\n+                if (c == '\\'') {\n+                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n+                        // '' is treated as escaped '\n+                        i++;\n+                        buf.append(c);\n+                    } else {\n+                        inLiteral = !inLiteral;\n+                    }\n+                } else if (!inLiteral &&\n+                         (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n+                    i--;\n+                    break;\n+                } else {\n+                    buf.append(c);\n+                }\n+            }\n+        }\n+\n+        indexRef[0] = i;\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * <p>Gets an appropriate rule for the padding required.</p>\n+     * \n+     * @param field  the field to get a rule for\n+     * @param padding  the padding required\n+     * @return a new rule with the correct padding\n+     */\n+    protected NumberRule selectNumberRule(int field, int padding) {\n+        switch (padding) {\n+        case 1:\n+            return new UnpaddedNumberField(field);\n+        case 2:\n+            return new TwoDigitNumberField(field);\n+        default:\n+            return new PaddedNumberField(field, padding);\n+        }\n+    }\n+\n+    // Format methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Formats a <code>Date</code>, <code>Calendar</code> or\n+     * <code>Long</code> (milliseconds) object.</p>\n+     * \n+     * @param obj  the object to format\n+     * @param toAppendTo  the buffer to append to\n+     * @param pos  the position - ignored\n+     * @return the buffer passed in\n+     */\n+    @Override\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+        if (obj instanceof Date) {\n+            return format((Date) obj, toAppendTo);\n+        } else if (obj instanceof Calendar) {\n+            return format((Calendar) obj, toAppendTo);\n+        } else if (obj instanceof Long) {\n+            return format(((Long) obj).longValue(), toAppendTo);\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown class: \" +\n+                (obj == null ? \"<null>\" : obj.getClass().getName()));\n+        }\n+    }\n+\n+    /**\n+     * <p>Formats a millisecond <code>long</code> value.</p>\n+     * \n+     * @param millis  the millisecond value to format\n+     * @return the formatted string\n+     * @since 2.1\n+     */\n+    public String format(long millis) {\n+        return format(new Date(millis));\n+    }\n+\n+    /**\n+     * <p>Formats a <code>Date</code> object.</p>\n+     * \n+     * @param date  the date to format\n+     * @return the formatted string\n+     */\n+    public String format(Date date) {\n+        Calendar c = new GregorianCalendar(mTimeZone);\n+        c.setTime(date);\n+        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n+    }\n+\n+    /**\n+     * <p>Formats a <code>Calendar</code> object.</p>\n+     * \n+     * @param calendar  the calendar to format\n+     * @return the formatted string\n+     */\n+    public String format(Calendar calendar) {\n+        return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n+    }\n+\n+    /**\n+     * <p>Formats a milliseond <code>long</code> value into the\n+     * supplied <code>StringBuffer</code>.</p>\n+     * \n+     * @param millis  the millisecond value to format\n+     * @param buf  the buffer to format into\n+     * @return the specified string buffer\n+     * @since 2.1\n+     */\n+    public StringBuffer format(long millis, StringBuffer buf) {\n+        return format(new Date(millis), buf);\n+    }\n+\n+    /**\n+     * <p>Formats a <code>Date</code> object into the\n+     * supplied <code>StringBuffer</code>.</p>\n+     * \n+     * @param date  the date to format\n+     * @param buf  the buffer to format into\n+     * @return the specified string buffer\n+     */\n+    public StringBuffer format(Date date, StringBuffer buf) {\n+        Calendar c = new GregorianCalendar(mTimeZone);\n+        c.setTime(date);\n+        return applyRules(c, buf);\n+    }\n+\n+    /**\n+     * <p>Formats a <code>Calendar</code> object into the\n+     * supplied <code>StringBuffer</code>.</p>\n+     * \n+     * @param calendar  the calendar to format\n+     * @param buf  the buffer to format into\n+     * @return the specified string buffer\n+     */\n+    public StringBuffer format(Calendar calendar, StringBuffer buf) {\n+        if (mTimeZoneForced) {\n+            calendar = (Calendar) calendar.clone();\n+            calendar.setTimeZone(mTimeZone);\n+        }\n+        return applyRules(calendar, buf);\n+    }\n+\n+    /**\n+     * <p>Performs the formatting by applying the rules to the\n+     * specified calendar.</p>\n+     * \n+     * @param calendar  the calendar to format\n+     * @param buf  the buffer to format into\n+     * @return the specified string buffer\n+     */\n+    protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n+        Rule[] rules = mRules;\n+        int len = mRules.length;\n+        for (int i = 0; i < len; i++) {\n+            rules[i].appendTo(buf, calendar);\n+        }\n+        return buf;\n+    }\n+\n+    // Parsing\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Parsing is not supported.</p>\n+     * \n+     * @param source  the string to parse\n+     * @param pos  the parsing position\n+     * @return <code>null</code> as not supported\n+     */\n+    @Override\n+    public Object parseObject(String source, ParsePosition pos) {\n+        pos.setIndex(0);\n+        pos.setErrorIndex(0);\n+        return null;\n+    }\n+    \n+    // Accessors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the pattern used by this formatter.</p>\n+     * \n+     * @return the pattern, {@link java.text.SimpleDateFormat} compatible\n+     */\n+    public String getPattern() {\n+        return mPattern;\n+    }\n+\n+    /**\n+     * <p>Gets the time zone used by this formatter.</p>\n+     *\n+     * <p>This zone is always used for <code>Date</code> formatting.\n+     * If a <code>Calendar</code> is passed in to be formatted, the\n+     * time zone on that may be used depending on\n+     * {@link #getTimeZoneOverridesCalendar()}.</p>\n+     * \n+     * @return the time zone\n+     */\n+    public TimeZone getTimeZone() {\n+        return mTimeZone;\n+    }\n+\n+    /**\n+     * <p>Returns <code>true</code> if the time zone of the\n+     * calendar overrides the time zone of the formatter.</p>\n+     * \n+     * @return <code>true</code> if time zone of formatter\n+     *  overridden for calendars\n+     */\n+    public boolean getTimeZoneOverridesCalendar() {\n+        return mTimeZoneForced;\n+    }\n+\n+    /**\n+     * <p>Gets the locale used by this formatter.</p>\n+     * \n+     * @return the locale\n+     */\n+    public Locale getLocale() {\n+        return mLocale;\n+    }\n+\n+    /**\n+     * <p>Gets an estimate for the maximum string length that the\n+     * formatter will produce.</p>\n+     *\n+     * <p>The actual formatted length will almost always be less than or\n+     * equal to this amount.</p>\n+     * \n+     * @return the maximum formatted length\n+     */\n+    public int getMaxLengthEstimate() {\n+        return mMaxLengthEstimate;\n+    }\n+\n+    // Basics\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compares two objects for equality.</p>\n+     * \n+     * @param obj  the object to compare to\n+     * @return <code>true</code> if equal\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof FastDateFormat == false) {\n+            return false;\n+        }\n+        FastDateFormat other = (FastDateFormat) obj;\n+        if (\n+            (mPattern == other.mPattern || mPattern.equals(other.mPattern)) &&\n+            (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) &&\n+            (mLocale == other.mLocale || mLocale.equals(other.mLocale)) &&\n+            (mTimeZoneForced == other.mTimeZoneForced) &&\n+            (mLocaleForced == other.mLocaleForced)\n+            ) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Returns a hashcode compatible with equals.</p>\n+     * \n+     * @return a hashcode compatible with equals\n+     */\n+    @Override\n+    public int hashCode() {\n+        int total = 0;\n+        total += mPattern.hashCode();\n+        total += mTimeZone.hashCode();\n+        total += (mTimeZoneForced ? 1 : 0);\n+        total += mLocale.hashCode();\n+        total += (mLocaleForced ? 1 : 0);\n+        return total;\n+    }\n+\n+    /**\n+     * <p>Gets a debugging string version of this formatter.</p>\n+     * \n+     * @return a debugging string\n+     */\n+    @Override\n+    public String toString() {\n+        return \"FastDateFormat[\" + mPattern + \"]\";\n+    }\n+\n+    // Serializing\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Create the object after serialization. This implementation reinitializes the \n+     * transient properties.\n+     *\n+     * @param in ObjectInputStream from which the object is being deserialized.\n+     * @throws IOException if there is an IO issue.\n+     * @throws ClassNotFoundException if a class cannot be found.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        init();\n+    }\n+    \n+    // Rules\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Inner class defining a rule.</p>\n+     */\n+    private interface Rule {\n+        /**\n+         * Returns the estimated lentgh of the result.\n+         * \n+         * @return the estimated length\n+         */\n+        int estimateLength();\n+        \n+        /**\n+         * Appends the value of the specified calendar to the output buffer based on the rule implementation.\n+         * \n+         * @param buffer the output buffer\n+         * @param calendar calendar to be appended\n+         */\n+        void appendTo(StringBuffer buffer, Calendar calendar);\n+    }\n+\n+    /**\n+     * <p>Inner class defining a numeric rule.</p>\n+     */\n+    private interface NumberRule extends Rule {\n+        /**\n+         * Appends the specified value to the output buffer based on the rule implementation.\n+         * \n+         * @param buffer the output buffer\n+         * @param value the value to be appended\n+         */\n+        void appendTo(StringBuffer buffer, int value);\n+    }\n+\n+    /**\n+     * <p>Inner class to output a constant single character.</p>\n+     */\n+    private static class CharacterLiteral implements Rule {\n+        private final char mValue;\n+\n+        /**\n+         * Constructs a new instance of <code>CharacterLiteral</code>\n+         * to hold the specified value.\n+         * \n+         * @param value the character literal\n+         */\n+        CharacterLiteral(char value) {\n+            mValue = value;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 1;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            buffer.append(mValue);\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a constant string.</p>\n+     */\n+    private static class StringLiteral implements Rule {\n+        private final String mValue;\n+\n+        /**\n+         * Constructs a new instance of <code>StringLiteral</code>\n+         * to hold the specified value.\n+         * \n+         * @param value the string literal\n+         */\n+        StringLiteral(String value) {\n+            mValue = value;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return mValue.length();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            buffer.append(mValue);\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output one of a set of values.</p>\n+     */\n+    private static class TextField implements Rule {\n+        private final int mField;\n+        private final String[] mValues;\n+\n+        /**\n+         * Constructs an instance of <code>TextField</code>\n+         * with the specified field and values.\n+         * \n+         * @param field the field\n+         * @param values the field values\n+         */\n+        TextField(int field, String[] values) {\n+            mField = field;\n+            mValues = values;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            int max = 0;\n+            for (int i=mValues.length; --i >= 0; ) {\n+                int len = mValues[i].length();\n+                if (len > max) {\n+                    max = len;\n+                }\n+            }\n+            return max;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            buffer.append(mValues[calendar.get(mField)]);\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output an unpadded number.</p>\n+     */\n+    private static class UnpaddedNumberField implements NumberRule {\n+        private final int mField;\n+\n+        /**\n+         * Constructs an instance of <code>UnpadedNumberField</code> with the specified field.\n+         * \n+         * @param field the field\n+         */\n+        UnpaddedNumberField(int field) {\n+            mField = field;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 4;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(mField));\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            if (value < 10) {\n+                buffer.append((char)(value + '0'));\n+            } else if (value < 100) {\n+                buffer.append((char)(value / 10 + '0'));\n+                buffer.append((char)(value % 10 + '0'));\n+            } else {\n+                buffer.append(Integer.toString(value));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output an unpadded month.</p>\n+     */\n+    private static class UnpaddedMonthField implements NumberRule {\n+        static final UnpaddedMonthField INSTANCE = new UnpaddedMonthField();\n+\n+        /**\n+         * Constructs an instance of <code>UnpaddedMonthField</code>.\n+         *\n+         */\n+        UnpaddedMonthField() {\n+            super();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 2;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            if (value < 10) {\n+                buffer.append((char)(value + '0'));\n+            } else {\n+                buffer.append((char)(value / 10 + '0'));\n+                buffer.append((char)(value % 10 + '0'));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a padded number.</p>\n+     */\n+    private static class PaddedNumberField implements NumberRule {\n+        private final int mField;\n+        private final int mSize;\n+\n+        /**\n+         * Constructs an instance of <code>PaddedNumberField</code>.\n+         * \n+         * @param field the field\n+         * @param size size of the output field\n+         */\n+        PaddedNumberField(int field, int size) {\n+            if (size < 3) {\n+                // Should use UnpaddedNumberField or TwoDigitNumberField.\n+                throw new IllegalArgumentException();\n+            }\n+            mField = field;\n+            mSize = size;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 4;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(mField));\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            if (value < 100) {\n+                for (int i = mSize; --i >= 2; ) {\n+                    buffer.append('0');\n+                }\n+                buffer.append((char)(value / 10 + '0'));\n+                buffer.append((char)(value % 10 + '0'));\n+            } else {\n+                int digits;\n+                if (value < 1000) {\n+                    digits = 3;\n+                } else {\n+                    Validate.isTrue(value > -1, \"Negative values should not be possible\", value);\n+                    digits = Integer.toString(value).length();\n+                }\n+                for (int i = mSize; --i >= digits; ) {\n+                    buffer.append('0');\n+                }\n+                buffer.append(Integer.toString(value));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a two digit number.</p>\n+     */\n+    private static class TwoDigitNumberField implements NumberRule {\n+        private final int mField;\n+\n+        /**\n+         * Constructs an instance of <code>TwoDigitNumberField</code> with the specified field.\n+         * \n+         * @param field the field\n+         */\n+        TwoDigitNumberField(int field) {\n+            mField = field;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 2;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(mField));\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            if (value < 100) {\n+                buffer.append((char)(value / 10 + '0'));\n+                buffer.append((char)(value % 10 + '0'));\n+            } else {\n+                buffer.append(Integer.toString(value));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a two digit year.</p>\n+     */\n+    private static class TwoDigitYearField implements NumberRule {\n+        static final TwoDigitYearField INSTANCE = new TwoDigitYearField();\n+\n+        /**\n+         * Constructs an instance of <code>TwoDigitYearField</code>.\n+         */\n+        TwoDigitYearField() {\n+            super();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 2;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(Calendar.YEAR) % 100);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            buffer.append((char)(value / 10 + '0'));\n+            buffer.append((char)(value % 10 + '0'));\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a two digit month.</p>\n+     */\n+    private static class TwoDigitMonthField implements NumberRule {\n+        static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField();\n+\n+        /**\n+         * Constructs an instance of <code>TwoDigitMonthField</code>.\n+         */\n+        TwoDigitMonthField() {\n+            super();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 2;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            buffer.append((char)(value / 10 + '0'));\n+            buffer.append((char)(value % 10 + '0'));\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output the twelve hour field.</p>\n+     */\n+    private static class TwelveHourField implements NumberRule {\n+        private final NumberRule mRule;\n+\n+        /**\n+         * Constructs an instance of <code>TwelveHourField</code> with the specified\n+         * <code>NumberRule</code>.\n+         * \n+         * @param rule the rule\n+         */\n+        TwelveHourField(NumberRule rule) {\n+            mRule = rule;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return mRule.estimateLength();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            int value = calendar.get(Calendar.HOUR);\n+            if (value == 0) {\n+                value = calendar.getLeastMaximum(Calendar.HOUR) + 1;\n+            }\n+            mRule.appendTo(buffer, value);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, int value) {\n+            mRule.appendTo(buffer, value);\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output the twenty four hour field.</p>\n+     */\n+    private static class TwentyFourHourField implements NumberRule {\n+        private final NumberRule mRule;\n+\n+        /**\n+         * Constructs an instance of <code>TwentyFourHourField</code> with the specified\n+         * <code>NumberRule</code>.\n+         * \n+         * @param rule the rule\n+         */\n+        TwentyFourHourField(NumberRule rule) {\n+            mRule = rule;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return mRule.estimateLength();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            int value = calendar.get(Calendar.HOUR_OF_DAY);\n+            if (value == 0) {\n+                value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1;\n+            }\n+            mRule.appendTo(buffer, value);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, int value) {\n+            mRule.appendTo(buffer, value);\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a time zone name.</p>\n+     */\n+    private static class TimeZoneNameRule implements Rule {\n+        private final TimeZone mTimeZone;\n+        private final boolean mTimeZoneForced;\n+        private final Locale mLocale;\n+        private final int mStyle;\n+        private final String mStandard;\n+        private final String mDaylight;\n+\n+        /**\n+         * Constructs an instance of <code>TimeZoneNameRule</code> with the specified properties.\n+         * \n+         * @param timeZone the time zone\n+         * @param timeZoneForced if <code>true</code> the time zone is forced into standard and daylight\n+         * @param locale the locale\n+         * @param style the style\n+         */\n+        TimeZoneNameRule(TimeZone timeZone, boolean timeZoneForced, Locale locale, int style) {\n+            mTimeZone = timeZone;\n+            mTimeZoneForced = timeZoneForced;\n+            mLocale = locale;\n+            mStyle = style;\n+\n+            if (timeZoneForced) {\n+                mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n+                mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n+            } else {\n+                mStandard = null;\n+                mDaylight = null;\n+            }\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            if (mTimeZoneForced) {\n+                return Math.max(mStandard.length(), mDaylight.length());\n+            } else if (mStyle == TimeZone.SHORT) {\n+                return 4;\n+            } else {\n+                return 40;\n+            }\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            if (mTimeZoneForced) {\n+                if (mTimeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n+                    buffer.append(mDaylight);\n+                } else {\n+                    buffer.append(mStandard);\n+                }\n+            } else {\n+                TimeZone timeZone = calendar.getTimeZone();\n+                if (timeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n+                    buffer.append(getTimeZoneDisplay(timeZone, true, mStyle, mLocale));\n+                } else {\n+                    buffer.append(getTimeZoneDisplay(timeZone, false, mStyle, mLocale));\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a time zone as a number <code>+/-HHMM</code>\n+     * or <code>+/-HH:MM</code>.</p>\n+     */\n+    private static class TimeZoneNumberRule implements Rule {\n+        static final TimeZoneNumberRule INSTANCE_COLON = new TimeZoneNumberRule(true);\n+        static final TimeZoneNumberRule INSTANCE_NO_COLON = new TimeZoneNumberRule(false);\n+        \n+        final boolean mColon;\n+        \n+        /**\n+         * Constructs an instance of <code>TimeZoneNumberRule</code> with the specified properties.\n+         * \n+         * @param colon add colon between HH and MM in the output if <code>true</code>\n+         */\n+        TimeZoneNumberRule(boolean colon) {\n+            mColon = colon;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 5;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n+            \n+            if (offset < 0) {\n+                buffer.append('-');\n+                offset = -offset;\n+            } else {\n+                buffer.append('+');\n+            }\n+            \n+            int hours = offset / (60 * 60 * 1000);\n+            buffer.append((char)(hours / 10 + '0'));\n+            buffer.append((char)(hours % 10 + '0'));\n+            \n+            if (mColon) {\n+                buffer.append(':');\n+            }\n+            \n+            int minutes = offset / (60 * 1000) - 60 * hours;\n+            buffer.append((char)(minutes / 10 + '0'));\n+            buffer.append((char)(minutes % 10 + '0'));\n+        }            \n+    }\n+\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Inner class that acts as a compound key for time zone names.</p>\n+     */\n+    private static class TimeZoneDisplayKey {\n+        private final TimeZone mTimeZone;\n+        private final int mStyle;\n+        private final Locale mLocale;\n+\n+        /**\n+         * Constructs an instance of <code>TimeZoneDisplayKey</code> with the specified properties.\n+         *  \n+         * @param timeZone the time zone\n+         * @param daylight adjust the style for daylight saving time if <code>true</code>\n+         * @param style the timezone style\n+         * @param locale the timezone locale\n+         */\n+        TimeZoneDisplayKey(TimeZone timeZone,\n+                           boolean daylight, int style, Locale locale) {\n+            mTimeZone = timeZone;\n+            if (daylight) {\n+                style |= 0x80000000;\n+            }\n+            mStyle = style;\n+            mLocale = locale;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int hashCode() {\n+            return mStyle * 31 + mLocale.hashCode();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj instanceof TimeZoneDisplayKey) {\n+                TimeZoneDisplayKey other = (TimeZoneDisplayKey)obj;\n+                return\n+                    mTimeZone.equals(other.mTimeZone) &&\n+                    mStyle == other.mStyle &&\n+                    mLocale.equals(other.mLocale);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Helper class for creating compound objects.</p>\n+     *\n+     * <p>One use for this class is to create a hashtable key\n+     * out of multiple objects.</p>\n+     */\n+    private static class Pair {\n+        private final Object mObj1;\n+        private final Object mObj2;\n+\n+        /**\n+         * Constructs an instance of <code>Pair</code> to hold the specified objects.\n+         * @param obj1 one object in the pair\n+         * @param obj2 second object in the pair\n+         */\n+        public Pair(Object obj1, Object obj2) {\n+            mObj1 = obj1;\n+            mObj2 = obj2;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+\n+            if (!(obj instanceof Pair)) {\n+                return false;\n+            }\n+\n+            Pair key = (Pair)obj;\n+\n+            return\n+                (mObj1 == null ?\n+                 key.mObj1 == null : mObj1.equals(key.mObj1)) &&\n+                (mObj2 == null ?\n+                 key.mObj2 == null : mObj2.equals(key.mObj2));\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int hashCode() {\n+            return\n+                (mObj1 == null ? 0 : mObj1.hashCode()) +\n+                (mObj2 == null ? 0 : mObj2.hashCode());\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public String toString() {\n+            return \"[\" + mObj1 + ':' + mObj2 + ']';\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang3/time/StopWatch.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.time;\n+\n+/**\n+ * <p>\n+ * <code>StopWatch</code> provides a convenient API for timings.\n+ * </p>\n+ * \n+ * <p>\n+ * To start the watch, call {@link #start()}. At this point you can:\n+ * </p>\n+ * <ul>\n+ * <li>{@link #split()} the watch to get the time whilst the watch continues in the background. {@link #unsplit()} will\n+ * remove the effect of the split. At this point, these three options are available again.</li>\n+ * <li>{@link #suspend()} the watch to pause it. {@link #resume()} allows the watch to continue. Any time between the\n+ * suspend and resume will not be counted in the total. At this point, these three options are available again.</li>\n+ * <li>{@link #stop()} the watch to complete the timing session.</li>\n+ * </ul>\n+ * \n+ * <p>\n+ * It is intended that the output methods {@link #toString()} and {@link #getTime()} should only be called after stop,\n+ * split or suspend, however a suitable result will be returned at other points.\n+ * </p>\n+ * \n+ * <p>\n+ * NOTE: As from v2.1, the methods protect against inappropriate calls. Thus you cannot now call stop before start,\n+ * resume before suspend or unsplit before split.\n+ * </p>\n+ * \n+ * <p>\n+ * 1. split(), suspend(), or stop() cannot be invoked twice<br />\n+ * 2. unsplit() may only be called if the watch has been split()<br />\n+ * 3. resume() may only be called if the watch has been suspend()<br />\n+ * 4. start() cannot be called twice without calling reset()\n+ * </p>\n+ * \n+ * @author Apache Software Foundation\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class StopWatch {\n+\n+    private static final long NANO_2_MILLIS = 1000000L;\n+\n+    // running states\n+    private static final int STATE_UNSTARTED = 0;\n+\n+    private static final int STATE_RUNNING = 1;\n+\n+    private static final int STATE_STOPPED = 2;\n+\n+    private static final int STATE_SUSPENDED = 3;\n+\n+    // split state\n+    private static final int STATE_UNSPLIT = 10;\n+\n+    private static final int STATE_SPLIT = 11;\n+\n+    /**\n+     * The current running state of the StopWatch.\n+     */\n+    private int runningState = STATE_UNSTARTED;\n+\n+    /**\n+     * Whether the stopwatch has a split time recorded.\n+     */\n+    private int splitState = STATE_UNSPLIT;\n+\n+    /**\n+     * The start time.\n+     */\n+    private long startTime;\n+\n+    /**\n+     * The start time in Millis - nanoTime is only for elapsed time so we \n+     * need to also store the currentTimeMillis to maintain the old \n+     * getStartTime API.\n+     */\n+    private long startTimeMillis;\n+\n+    /**\n+     * The stop time.\n+     */\n+    private long stopTime;\n+\n+    /**\n+     * <p>\n+     * Constructor.\n+     * </p>\n+     */\n+    public StopWatch() {\n+        super();\n+    }\n+\n+    /**\n+     * <p>\n+     * Start the stopwatch.\n+     * </p>\n+     * \n+     * <p>\n+     * This method starts a new timing session, clearing any previous values.\n+     * </p>\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch is already running.\n+     */\n+    public void start() {\n+        if (this.runningState == STATE_STOPPED) {\n+            throw new IllegalStateException(\"Stopwatch must be reset before being restarted. \");\n+        }\n+        if (this.runningState != STATE_UNSTARTED) {\n+            throw new IllegalStateException(\"Stopwatch already started. \");\n+        }\n+        this.startTime = System.nanoTime();\n+        this.startTimeMillis = System.currentTimeMillis();\n+        this.runningState = STATE_RUNNING;\n+    }\n+\n+    /**\n+     * <p>\n+     * Stop the stopwatch.\n+     * </p>\n+     * \n+     * <p>\n+     * This method ends a new timing session, allowing the time to be retrieved.\n+     * </p>\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch is not running.\n+     */\n+    public void stop() {\n+        if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n+            throw new IllegalStateException(\"Stopwatch is not running. \");\n+        }\n+        if (this.runningState == STATE_RUNNING) {\n+            this.stopTime = System.nanoTime();\n+        }\n+        this.runningState = STATE_STOPPED;\n+    }\n+\n+    /**\n+     * <p>\n+     * Resets the stopwatch. Stops it if need be.\n+     * </p>\n+     * \n+     * <p>\n+     * This method clears the internal values to allow the object to be reused.\n+     * </p>\n+     */\n+    public void reset() {\n+        this.runningState = STATE_UNSTARTED;\n+        this.splitState = STATE_UNSPLIT;\n+    }\n+\n+    /**\n+     * <p>\n+     * Split the time.\n+     * </p>\n+     * \n+     * <p>\n+     * This method sets the stop time of the watch to allow a time to be extracted. The start time is unaffected,\n+     * enabling {@link #unsplit()} to continue the timing from the original start point.\n+     * </p>\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch is not running.\n+     */\n+    public void split() {\n+        if (this.runningState != STATE_RUNNING) {\n+            throw new IllegalStateException(\"Stopwatch is not running. \");\n+        }\n+        this.stopTime = System.nanoTime();\n+        this.splitState = STATE_SPLIT;\n+    }\n+\n+    /**\n+     * <p>\n+     * Remove a split.\n+     * </p>\n+     * \n+     * <p>\n+     * This method clears the stop time. The start time is unaffected, enabling timing from the original start point to\n+     * continue.\n+     * </p>\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch has not been split.\n+     */\n+    public void unsplit() {\n+        if (this.splitState != STATE_SPLIT) {\n+            throw new IllegalStateException(\"Stopwatch has not been split. \");\n+        }\n+        this.splitState = STATE_UNSPLIT;\n+    }\n+\n+    /**\n+     * <p>\n+     * Suspend the stopwatch for later resumption.\n+     * </p>\n+     * \n+     * <p>\n+     * This method suspends the watch until it is resumed. The watch will not include time between the suspend and\n+     * resume calls in the total time.\n+     * </p>\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch is not currently running.\n+     */\n+    public void suspend() {\n+        if (this.runningState != STATE_RUNNING) {\n+            throw new IllegalStateException(\"Stopwatch must be running to suspend. \");\n+        }\n+        this.stopTime = System.nanoTime();\n+        this.runningState = STATE_SUSPENDED;\n+    }\n+\n+    /**\n+     * <p>\n+     * Resume the stopwatch after a suspend.\n+     * </p>\n+     * \n+     * <p>\n+     * This method resumes the watch after it was suspended. The watch will not include time between the suspend and\n+     * resume calls in the total time.\n+     * </p>\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch has not been suspended.\n+     */\n+    public void resume() {\n+        if (this.runningState != STATE_SUSPENDED) {\n+            throw new IllegalStateException(\"Stopwatch must be suspended to resume. \");\n+        }\n+        this.startTime += (System.nanoTime() - this.stopTime);\n+        this.runningState = STATE_RUNNING;\n+    }\n+\n+    /**\n+     * <p>\n+     * Get the time on the stopwatch.\n+     * </p>\n+     * \n+     * <p>\n+     * This is either the time between the start and the moment this method is called, or the amount of time between\n+     * start and stop.\n+     * </p>\n+     * \n+     * @return the time in milliseconds\n+     */\n+    public long getTime() {\n+        return getNanoTime() / NANO_2_MILLIS;\n+    }\n+    /**\n+     * <p>\n+     * Get the time on the stopwatch in nanoseconds.\n+     * </p>\n+     * \n+     * <p>\n+     * This is either the time between the start and the moment this method is called, or the amount of time between\n+     * start and stop.\n+     * </p>\n+     * \n+     * @return the time in nanoseconds\n+     * @since 3.0\n+     */\n+    public long getNanoTime() {\n+        if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) {\n+            return this.stopTime - this.startTime;\n+        } else if (this.runningState == STATE_UNSTARTED) {\n+            return 0;\n+        } else if (this.runningState == STATE_RUNNING) {\n+            return System.nanoTime() - this.startTime;\n+        }\n+        throw new RuntimeException(\"Illegal running state has occured. \");\n+    }\n+\n+    /**\n+     * <p>\n+     * Get the split time on the stopwatch.\n+     * </p>\n+     * \n+     * <p>\n+     * This is the time between start and latest split.\n+     * </p>\n+     * \n+     * @return the split time in milliseconds\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch has not yet been split.\n+     * @since 2.1\n+     */\n+    public long getSplitTime() {\n+        return getSplitNanoTime() / NANO_2_MILLIS;\n+    }\n+    /**\n+     * <p>\n+     * Get the split time on the stopwatch in nanoseconds.\n+     * </p>\n+     * \n+     * <p>\n+     * This is the time between start and latest split.\n+     * </p>\n+     * \n+     * @return the split time in nanoseconds\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch has not yet been split.\n+     * @since 3.0\n+     */\n+    public long getSplitNanoTime() {\n+        if (this.splitState != STATE_SPLIT) {\n+            throw new IllegalStateException(\"Stopwatch must be split to get the split time. \");\n+        }\n+        return this.stopTime - this.startTime;\n+    }\n+\n+    /**\n+     * Returns the time this stopwatch was started.\n+     * \n+     * @return the time this stopwatch was started\n+     * @throws IllegalStateException\n+     *             if this StopWatch has not been started\n+     * @since 2.4\n+     */\n+    public long getStartTime() {\n+        if (this.runningState == STATE_UNSTARTED) {\n+            throw new IllegalStateException(\"Stopwatch has not been started\");\n+        }\n+        // System.nanoTime is for elapsed time\n+        return this.startTimeMillis;\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets a summary of the time that the stopwatch recorded as a string.\n+     * </p>\n+     * \n+     * <p>\n+     * The format used is ISO8601-like, <i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.\n+     * </p>\n+     * \n+     * @return the time as a String\n+     */\n+    @Override\n+    public String toString() {\n+        return DurationFormatUtils.formatDurationHMS(getTime());\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets a summary of the split time that the stopwatch recorded as a string.\n+     * </p>\n+     * \n+     * <p>\n+     * The format used is ISO8601-like, <i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.\n+     * </p>\n+     * \n+     * @return the split time as a String\n+     * @since 2.1\n+     */\n+    public String toSplitString() {\n+        return DurationFormatUtils.formatDurationHMS(getSplitTime());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/ArrayUtilsAddTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang;\n+\n+import java.util.Arrays;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Tests ArrayUtils add methods.\n+ *\n+ * @author Gary D. Gregory\n+ * @version $Id$\n+ */\n+public class ArrayUtilsAddTest extends TestCase {\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ArrayUtilsAddTest.class);\n+        suite.setName(\"ArrayUtils add Tests\");\n+        return suite;\n+    }\n+\n+    public void testAddObjectArrayBoolean() {\n+        boolean[] newArray;\n+        newArray = ArrayUtils.add((boolean[])null, false);\n+        assertTrue(Arrays.equals(new boolean[]{false}, newArray));\n+        assertEquals(Boolean.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add((boolean[])null, true);\n+        assertTrue(Arrays.equals(new boolean[]{true}, newArray));\n+        assertEquals(Boolean.TYPE, newArray.getClass().getComponentType());\n+        boolean[] array1 = new boolean[]{true, false, true};\n+        newArray = ArrayUtils.add(array1, false);\n+        assertTrue(Arrays.equals(new boolean[]{true, false, true, false}, newArray));\n+        assertEquals(Boolean.TYPE, newArray.getClass().getComponentType());\n+    }\n+\n+    public void testAddObjectArrayByte() {\n+        byte[] newArray;\n+        newArray = ArrayUtils.add((byte[])null, (byte)0);\n+        assertTrue(Arrays.equals(new byte[]{0}, newArray));\n+        assertEquals(Byte.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add((byte[])null, (byte)1);\n+        assertTrue(Arrays.equals(new byte[]{1}, newArray));\n+        assertEquals(Byte.TYPE, newArray.getClass().getComponentType());\n+        byte[] array1 = new byte[]{1, 2, 3};\n+        newArray = ArrayUtils.add(array1, (byte)0);\n+        assertTrue(Arrays.equals(new byte[]{1, 2, 3, 0}, newArray));\n+        assertEquals(Byte.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add(array1, (byte)4);\n+        assertTrue(Arrays.equals(new byte[]{1, 2, 3, 4}, newArray));\n+        assertEquals(Byte.TYPE, newArray.getClass().getComponentType());\n+    }\n+\n+    public void testAddObjectArrayChar() {\n+        char[] newArray;\n+        newArray = ArrayUtils.add((char[])null, (char)0);\n+        assertTrue(Arrays.equals(new char[]{0}, newArray));\n+        assertEquals(Character.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add((char[])null, (char)1);\n+        assertTrue(Arrays.equals(new char[]{1}, newArray));\n+        assertEquals(Character.TYPE, newArray.getClass().getComponentType());\n+        char[] array1 = new char[]{1, 2, 3};\n+        newArray = ArrayUtils.add(array1, (char)0);\n+        assertTrue(Arrays.equals(new char[]{1, 2, 3, 0}, newArray));\n+        assertEquals(Character.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add(array1, (char)4);\n+        assertTrue(Arrays.equals(new char[]{1, 2, 3, 4}, newArray));\n+        assertEquals(Character.TYPE, newArray.getClass().getComponentType());\n+    }\n+\n+    public void testAddObjectArrayDouble() {\n+        double[] newArray;\n+        newArray = ArrayUtils.add((double[])null, 0);\n+        assertTrue(Arrays.equals(new double[]{0}, newArray));\n+        assertEquals(Double.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add((double[])null, 1);\n+        assertTrue(Arrays.equals(new double[]{1}, newArray));\n+        assertEquals(Double.TYPE, newArray.getClass().getComponentType());\n+        double[] array1 = new double[]{1, 2, 3};\n+        newArray = ArrayUtils.add(array1, 0);\n+        assertTrue(Arrays.equals(new double[]{1, 2, 3, 0}, newArray));\n+        assertEquals(Double.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add(array1, 4);\n+        assertTrue(Arrays.equals(new double[]{1, 2, 3, 4}, newArray));\n+        assertEquals(Double.TYPE, newArray.getClass().getComponentType());\n+    }\n+\n+    public void testAddObjectArrayFloat() {\n+        float[] newArray;\n+        newArray = ArrayUtils.add((float[])null, 0);\n+        assertTrue(Arrays.equals(new float[]{0}, newArray));\n+        assertEquals(Float.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add((float[])null, 1);\n+        assertTrue(Arrays.equals(new float[]{1}, newArray));\n+        assertEquals(Float.TYPE, newArray.getClass().getComponentType());\n+        float[] array1 = new float[]{1, 2, 3};\n+        newArray = ArrayUtils.add(array1, 0);\n+        assertTrue(Arrays.equals(new float[]{1, 2, 3, 0}, newArray));\n+        assertEquals(Float.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add(array1, 4);\n+        assertTrue(Arrays.equals(new float[]{1, 2, 3, 4}, newArray));\n+        assertEquals(Float.TYPE, newArray.getClass().getComponentType());\n+    }\n+\n+    public void testAddObjectArrayInt() {\n+        int[] newArray;\n+        newArray = ArrayUtils.add((int[])null, 0);\n+        assertTrue(Arrays.equals(new int[]{0}, newArray));\n+        assertEquals(Integer.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add((int[])null, 1);\n+        assertTrue(Arrays.equals(new int[]{1}, newArray));\n+        assertEquals(Integer.TYPE, newArray.getClass().getComponentType());\n+        int[] array1 = new int[]{1, 2, 3};\n+        newArray = ArrayUtils.add(array1, 0);\n+        assertTrue(Arrays.equals(new int[]{1, 2, 3, 0}, newArray));\n+        assertEquals(Integer.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add(array1, 4);\n+        assertTrue(Arrays.equals(new int[]{1, 2, 3, 4}, newArray));\n+        assertEquals(Integer.TYPE, newArray.getClass().getComponentType());\n+    }\n+\n+    public void testAddObjectArrayLong() {\n+        long[] newArray;\n+        newArray = ArrayUtils.add((long[])null, 0);\n+        assertTrue(Arrays.equals(new long[]{0}, newArray));\n+        assertEquals(Long.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add((long[])null, 1);\n+        assertTrue(Arrays.equals(new long[]{1}, newArray));\n+        assertEquals(Long.TYPE, newArray.getClass().getComponentType());\n+        long[] array1 = new long[]{1, 2, 3};\n+        newArray = ArrayUtils.add(array1, 0);\n+        assertTrue(Arrays.equals(new long[]{1, 2, 3, 0}, newArray));\n+        assertEquals(Long.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add(array1, 4);\n+        assertTrue(Arrays.equals(new long[]{1, 2, 3, 4}, newArray));\n+        assertEquals(Long.TYPE, newArray.getClass().getComponentType());\n+    }\n+\n+    public void testAddObjectArrayShort() {\n+        short[] newArray;\n+        newArray = ArrayUtils.add((short[])null, (short)0);\n+        assertTrue(Arrays.equals(new short[]{0}, newArray));\n+        assertEquals(Short.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add((short[])null, (short)1);\n+        assertTrue(Arrays.equals(new short[]{1}, newArray));\n+        assertEquals(Short.TYPE, newArray.getClass().getComponentType());\n+        short[] array1 = new short[]{1, 2, 3};\n+        newArray = ArrayUtils.add(array1, (short)0);\n+        assertTrue(Arrays.equals(new short[]{1, 2, 3, 0}, newArray));\n+        assertEquals(Short.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add(array1, (short)4);\n+        assertTrue(Arrays.equals(new short[]{1, 2, 3, 4}, newArray));\n+        assertEquals(Short.TYPE, newArray.getClass().getComponentType());\n+    }\n+\n+    public void testAddObjectArrayObject() {\n+        Object[] newArray;\n+        newArray = ArrayUtils.add((Object[])null, null);\n+        assertTrue(Arrays.equals((new Object[]{null}), newArray));\n+        assertEquals(Object.class, newArray.getClass().getComponentType());\n+\n+        //show that not casting is okay\n+        newArray = ArrayUtils.add(null, null);\n+        assertTrue(Arrays.equals((new Object[]{null}), newArray));\n+        assertEquals(Object.class, newArray.getClass().getComponentType());\n+\n+        newArray = ArrayUtils.add((Object[])null, \"a\");\n+        assertTrue(Arrays.equals((new String[]{\"a\"}), newArray));\n+        assertTrue(Arrays.equals((new Object[]{\"a\"}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+\n+        //show that not casting to Object[] is okay and will assume String based on \"a\"\n+        String[] newStringArray = ArrayUtils.add(null, \"a\");\n+        assertTrue(Arrays.equals((new String[]{\"a\"}), newStringArray));\n+        assertTrue(Arrays.equals((new Object[]{\"a\"}), newStringArray));\n+        assertEquals(String.class, newStringArray.getClass().getComponentType());\n+\n+        String[] stringArray1 = new String[]{\"a\", \"b\", \"c\"};\n+        newArray = ArrayUtils.add(stringArray1, null);\n+        assertTrue(Arrays.equals((new String[]{\"a\", \"b\", \"c\", null}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+\n+        newArray = ArrayUtils.add(stringArray1, \"d\");\n+        assertTrue(Arrays.equals((new String[]{\"a\", \"b\", \"c\", \"d\"}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+\n+        Number[] numberArray1 = new Number[]{new Integer(1), new Double(2)};\n+        newArray = ArrayUtils.add(numberArray1, new Float(3));\n+        assertTrue(Arrays.equals((new Number[]{new Integer(1), new Double(2), new Float(3)}), newArray));\n+        assertEquals(Number.class, newArray.getClass().getComponentType());\n+\n+        numberArray1 = null;\n+        newArray = ArrayUtils.add(numberArray1, new Float(3));\n+        assertTrue(Arrays.equals((new Float[]{new Float(3)}), newArray));\n+        assertEquals(Float.class, newArray.getClass().getComponentType());\n+\n+        numberArray1 = null;\n+        newArray = ArrayUtils.add(numberArray1, null);\n+        assertTrue(Arrays.equals((new Object[]{null}), newArray));\n+        assertEquals(Object.class, newArray.getClass().getComponentType());\n+    }\n+\n+    public void testAddObjectArrayToObjectArray() {\n+        assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null));\n+        Object[] newArray;\n+        String[] stringArray1 = new String[]{\"a\", \"b\", \"c\"};\n+        String[] stringArray2 = new String[]{\"1\", \"2\", \"3\"};\n+        newArray = ArrayUtils.addAll(stringArray1, null);\n+        assertNotSame(stringArray1, newArray);\n+        assertTrue(Arrays.equals(stringArray1, newArray));\n+        assertTrue(Arrays.equals((new String[]{\"a\", \"b\", \"c\"}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.addAll(null, stringArray2);\n+        assertNotSame(stringArray2, newArray);\n+        assertTrue(Arrays.equals(stringArray2, newArray));\n+        assertTrue(Arrays.equals((new String[]{\"1\", \"2\", \"3\"}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.addAll(stringArray1, stringArray2);\n+        assertTrue(Arrays.equals((new String[]{\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, null);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray));\n+        assertTrue(Arrays.equals((new String[]{}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray));\n+        assertTrue(Arrays.equals((new String[]{}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.EMPTY_STRING_ARRAY);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray));\n+        assertTrue(Arrays.equals((new String[]{}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        String[] stringArrayNull = new String []{null};\n+        newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull);\n+        assertTrue(Arrays.equals((new String[]{null, null}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+\n+        // boolean\n+        assertTrue( Arrays.equals( new boolean[] { true, false, false, true },\n+            ArrayUtils.addAll( new boolean[] { true, false }, new boolean[] { false, true } ) ) );\n+\n+        assertTrue( Arrays.equals( new boolean[] { false, true },\n+            ArrayUtils.addAll( null, new boolean[] { false, true } ) ) );\n+\n+        assertTrue( Arrays.equals( new boolean[] { true, false },\n+            ArrayUtils.addAll( new boolean[] { true, false }, null ) ) );\n+\n+        // char\n+        assertTrue( Arrays.equals( new char[] { 'a', 'b', 'c', 'd' },\n+            ArrayUtils.addAll( new char[] { 'a', 'b' }, new char[] { 'c', 'd' } ) ) );\n+\n+        assertTrue( Arrays.equals( new char[] { 'c', 'd' },\n+            ArrayUtils.addAll( null, new char[] { 'c', 'd' } ) ) );\n+\n+        assertTrue( Arrays.equals( new char[] { 'a', 'b' },\n+            ArrayUtils.addAll( new char[] { 'a', 'b' }, null ) ) );\n+\n+        // byte\n+        assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1, (byte) 2, (byte) 3 },\n+            ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, new byte[] { (byte) 2, (byte) 3 } ) ) );\n+\n+        assertTrue( Arrays.equals( new byte[] { (byte) 2, (byte) 3 },\n+            ArrayUtils.addAll( null, new byte[] { (byte) 2, (byte) 3 } ) ) );\n+\n+        assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1 },\n+            ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, null ) ) );\n+\n+        // short\n+        assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20, (short) 30, (short) 40 },\n+            ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, new short[] { (short) 30, (short) 40 } ) ) );\n+\n+        assertTrue( Arrays.equals( new short[] { (short) 30, (short) 40 },\n+            ArrayUtils.addAll( null, new short[] { (short) 30, (short) 40 } ) ) );\n+\n+        assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20 },\n+            ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, null ) ) );\n+\n+        // int\n+        assertTrue( Arrays.equals( new int[] { 1, 1000, -1000, -1 },\n+            ArrayUtils.addAll( new int[] { 1, 1000 }, new int[] { -1000, -1 } ) ) );\n+\n+        assertTrue( Arrays.equals( new int[] { -1000, -1 },\n+            ArrayUtils.addAll( null, new int[] { -1000, -1 } ) ) );\n+\n+        assertTrue( Arrays.equals( new int[] { 1, 1000 },\n+            ArrayUtils.addAll( new int[] { 1, 1000 }, null ) ) );\n+\n+        // long\n+        assertTrue( Arrays.equals( new long[] { 1L, -1L, 1000L, -1000L },\n+            ArrayUtils.addAll( new long[] { 1L, -1L }, new long[] { 1000L, -1000L } ) ) );\n+\n+        assertTrue( Arrays.equals( new long[] { 1000L, -1000L },\n+            ArrayUtils.addAll( null, new long[] { 1000L, -1000L } ) ) );\n+\n+        assertTrue( Arrays.equals( new long[] { 1L, -1L },\n+            ArrayUtils.addAll( new long[] { 1L, -1L }, null ) ) );\n+\n+        // float\n+        assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f, 1.6f, 0.01f },\n+            ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, new float[] { 1.6f, 0.01f } ) ) );\n+\n+        assertTrue( Arrays.equals( new float[] { 1.6f, 0.01f },\n+            ArrayUtils.addAll( null, new float[] { 1.6f, 0.01f } ) ) );\n+\n+        assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f },\n+            ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, null ) ) );\n+\n+        // double\n+        assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI, 0, 9.99 },\n+            ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, new double[] { 0, 9.99 } ) ) );\n+\n+        assertTrue( Arrays.equals( new double[] { 0, 9.99 },\n+            ArrayUtils.addAll( null, new double[] { 0, 9.99 } ) ) );\n+\n+        assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI },\n+            ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, null ) ) );\n+\n+    }\n+\n+    public void testAddObjectAtIndex() {\n+        Object[] newArray;\n+        newArray = ArrayUtils.add((Object[])null, 0, null);\n+        assertTrue(Arrays.equals((new Object[]{null}), newArray));\n+        assertEquals(Object.class, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add((Object[])null, 0, \"a\");\n+        assertTrue(Arrays.equals((new String[]{\"a\"}), newArray));\n+        assertTrue(Arrays.equals((new Object[]{\"a\"}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        String[] stringArray1 = new String[]{\"a\", \"b\", \"c\"};\n+        newArray = ArrayUtils.add(stringArray1, 0, null);\n+        assertTrue(Arrays.equals((new String[]{null, \"a\", \"b\", \"c\"}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add(stringArray1, 1, null);\n+        assertTrue(Arrays.equals((new String[]{\"a\", null, \"b\", \"c\"}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add(stringArray1, 3, null);\n+        assertTrue(Arrays.equals((new String[]{\"a\", \"b\", \"c\", null}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add(stringArray1, 3, \"d\");\n+        assertTrue(Arrays.equals((new String[]{\"a\", \"b\", \"c\", \"d\"}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+\n+        Object[] o = new Object[] {\"1\", \"2\", \"4\"};\n+        Object[] result = ArrayUtils.add(o, 2, \"3\");\n+        Object[] result2 = ArrayUtils.add(o, 3, \"5\");\n+\n+        assertNotNull(result);\n+        assertEquals(4, result.length);\n+        assertEquals(\"1\", result[0]);\n+        assertEquals(\"2\", result[1]);\n+        assertEquals(\"3\", result[2]);\n+        assertEquals(\"4\", result[3]);\n+        assertNotNull(result2);\n+        assertEquals(4, result2.length);\n+        assertEquals(\"1\", result2[0]);\n+        assertEquals(\"2\", result2[1]);\n+        assertEquals(\"4\", result2[2]);\n+        assertEquals(\"5\", result2[3]);\n+\n+        // boolean tests\n+        boolean[] booleanArray = ArrayUtils.add( null, 0, true );\n+        assertTrue( Arrays.equals( new boolean[] { true }, booleanArray ) );\n+        try {\n+            booleanArray = ArrayUtils.add( null, -1, true );\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n+        }\n+        booleanArray = ArrayUtils.add( new boolean[] { true }, 0, false);\n+        assertTrue( Arrays.equals( new boolean[] { false, true }, booleanArray ) );\n+        booleanArray = ArrayUtils.add( new boolean[] { false }, 1, true);\n+        assertTrue( Arrays.equals( new boolean[] { false, true }, booleanArray ) );\n+        booleanArray = ArrayUtils.add( new boolean[] { true, false }, 1, true);\n+        assertTrue( Arrays.equals( new boolean[] { true, true, false }, booleanArray ) );\n+        try {\n+            booleanArray = ArrayUtils.add( new boolean[] { true, false }, 4, true);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n+        }\n+        try {\n+            booleanArray = ArrayUtils.add( new boolean[] { true, false }, -1, true);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n+        }\n+\n+        // char tests\n+        char[] charArray = ArrayUtils.add( (char[]) null, 0, 'a' );\n+        assertTrue( Arrays.equals( new char[] { 'a' }, charArray ) );\n+        try {\n+            charArray = ArrayUtils.add( (char[]) null, -1, 'a' );\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n+        }\n+        charArray = ArrayUtils.add( new char[] { 'a' }, 0, 'b');\n+        assertTrue( Arrays.equals( new char[] { 'b', 'a' }, charArray ) );\n+        charArray = ArrayUtils.add( new char[] { 'a', 'b' }, 0, 'c');\n+        assertTrue( Arrays.equals( new char[] { 'c', 'a', 'b' }, charArray ) );\n+        charArray = ArrayUtils.add( new char[] { 'a', 'b' }, 1, 'k');\n+        assertTrue( Arrays.equals( new char[] { 'a', 'k', 'b' }, charArray ) );\n+        charArray = ArrayUtils.add( new char[] { 'a', 'b', 'c' }, 1, 't');\n+        assertTrue( Arrays.equals( new char[] { 'a', 't', 'b', 'c' }, charArray ) );\n+        try {\n+            charArray = ArrayUtils.add( new char[] { 'a', 'b' }, 4, 'c');\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n+        }\n+        try {\n+            charArray = ArrayUtils.add( new char[] { 'a', 'b' }, -1, 'c');\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n+        }\n+\n+        // short tests\n+        short[] shortArray = ArrayUtils.add( new short[] { 1 }, 0, (short) 2);\n+        assertTrue( Arrays.equals( new short[] { 2, 1 }, shortArray ) );\n+        try {\n+            shortArray = ArrayUtils.add( (short[]) null, -1, (short) 2);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n+        }\n+        shortArray = ArrayUtils.add( new short[] { 2, 6 }, 2, (short) 10);\n+        assertTrue( Arrays.equals( new short[] { 2, 6, 10 }, shortArray ) );\n+        shortArray = ArrayUtils.add( new short[] { 2, 6 }, 0, (short) -4);\n+        assertTrue( Arrays.equals( new short[] { -4, 2, 6 }, shortArray ) );\n+        shortArray = ArrayUtils.add( new short[] { 2, 6, 3 }, 2, (short) 1);\n+        assertTrue( Arrays.equals( new short[] { 2, 6, 1, 3 }, shortArray ) );\n+        try {\n+            shortArray = ArrayUtils.add( new short[] { 2, 6 }, 4, (short) 10);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n+        }\n+        try {\n+            shortArray = ArrayUtils.add( new short[] { 2, 6 }, -1, (short) 10);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n+        }\n+\n+        // byte tests\n+        byte[] byteArray = ArrayUtils.add( new byte[] { 1 }, 0, (byte) 2);\n+        assertTrue( Arrays.equals( new byte[] { 2, 1 }, byteArray ) );\n+        try {\n+            byteArray = ArrayUtils.add( (byte[]) null, -1, (byte) 2);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n+        }\n+        byteArray = ArrayUtils.add( new byte[] { 2, 6 }, 2, (byte) 3);\n+        assertTrue( Arrays.equals( new byte[] { 2, 6, 3 }, byteArray ) );\n+        byteArray = ArrayUtils.add( new byte[] { 2, 6 }, 0, (byte) 1);\n+        assertTrue( Arrays.equals( new byte[] { 1, 2, 6 }, byteArray ) );\n+        byteArray = ArrayUtils.add( new byte[] { 2, 6, 3 }, 2, (byte) 1);\n+        assertTrue( Arrays.equals( new byte[] { 2, 6, 1, 3 }, byteArray ) );\n+        try {\n+            byteArray = ArrayUtils.add( new byte[] { 2, 6 }, 4, (byte) 3);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n+        }\n+        try {\n+            byteArray = ArrayUtils.add( new byte[] { 2, 6 }, -1, (byte) 3);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n+        }\n+\n+        // int tests\n+        int[] intArray = ArrayUtils.add( new int[] { 1 }, 0, 2);\n+        assertTrue( Arrays.equals( new int[] { 2, 1 }, intArray ) );\n+        try {\n+            intArray = ArrayUtils.add( (int[]) null, -1, 2);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n+        }\n+        intArray = ArrayUtils.add( new int[] { 2, 6 }, 2, 10);\n+        assertTrue( Arrays.equals( new int[] { 2, 6, 10 }, intArray ) );\n+        intArray = ArrayUtils.add( new int[] { 2, 6 }, 0, -4);\n+        assertTrue( Arrays.equals( new int[] { -4, 2, 6 }, intArray ) );\n+        intArray = ArrayUtils.add( new int[] { 2, 6, 3 }, 2, 1);\n+        assertTrue( Arrays.equals( new int[] { 2, 6, 1, 3 }, intArray ) );\n+        try {\n+            intArray = ArrayUtils.add( new int[] { 2, 6 }, 4, 10);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n+        }\n+        try {\n+            intArray = ArrayUtils.add( new int[] { 2, 6 }, -1, 10);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n+        }\n+\n+        // long tests\n+        long[] longArray = ArrayUtils.add( new long[] { 1L }, 0, 2L);\n+        assertTrue( Arrays.equals( new long[] { 2L, 1L }, longArray ) );\n+        try {\n+            longArray = ArrayUtils.add( (long[]) null, -1, 2L);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n+        }\n+        longArray = ArrayUtils.add( new long[] { 2L, 6L }, 2, 10L);\n+        assertTrue( Arrays.equals( new long[] { 2L, 6L, 10L }, longArray ) );\n+        longArray = ArrayUtils.add( new long[] { 2L, 6L }, 0, -4L);\n+        assertTrue( Arrays.equals( new long[] { -4L, 2L, 6L }, longArray ) );\n+        longArray = ArrayUtils.add( new long[] { 2L, 6L, 3L }, 2, 1L);\n+        assertTrue( Arrays.equals( new long[] { 2L, 6L, 1L, 3L }, longArray ) );\n+        try {\n+            longArray = ArrayUtils.add( new long[] { 2L, 6L }, 4, 10L);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n+        }\n+        try {\n+            longArray = ArrayUtils.add( new long[] { 2L, 6L }, -1, 10L);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n+        }\n+\n+        // float tests\n+        float[] floatArray = ArrayUtils.add( new float[] { 1.1f }, 0, 2.2f);\n+        assertTrue( Arrays.equals( new float[] { 2.2f, 1.1f }, floatArray ) );\n+        try {\n+            floatArray = ArrayUtils.add( (float[]) null, -1, 2.2f);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n+        }\n+        floatArray = ArrayUtils.add( new float[] { 2.3f, 6.4f }, 2, 10.5f);\n+        assertTrue( Arrays.equals( new float[] { 2.3f, 6.4f, 10.5f }, floatArray ) );\n+        floatArray = ArrayUtils.add( new float[] { 2.6f, 6.7f }, 0, -4.8f);\n+        assertTrue( Arrays.equals( new float[] { -4.8f, 2.6f, 6.7f }, floatArray ) );\n+        floatArray = ArrayUtils.add( new float[] { 2.9f, 6.0f, 0.3f }, 2, 1.0f);\n+        assertTrue( Arrays.equals( new float[] { 2.9f, 6.0f, 1.0f, 0.3f }, floatArray ) );\n+        try {\n+            floatArray = ArrayUtils.add( new float[] { 2.3f, 6.4f }, 4, 10.5f);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n+        }\n+        try {\n+            floatArray = ArrayUtils.add( new float[] { 2.3f, 6.4f }, -1, 10.5f);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n+        }\n+\n+        // double tests\n+        double[] doubleArray = ArrayUtils.add( new double[] { 1.1 }, 0, 2.2);\n+        assertTrue( Arrays.equals( new double[] { 2.2, 1.1 }, doubleArray ) );\n+        try {\n+          doubleArray = ArrayUtils.add( (double[]) null, -1, 2.2);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n+        }\n+        doubleArray = ArrayUtils.add( new double[] { 2.3, 6.4 }, 2, 10.5);\n+        assertTrue( Arrays.equals( new double[] { 2.3, 6.4, 10.5 }, doubleArray ) );\n+        doubleArray = ArrayUtils.add( new double[] { 2.6, 6.7 }, 0, -4.8);\n+        assertTrue( Arrays.equals( new double[] { -4.8, 2.6, 6.7 }, doubleArray ) );\n+        doubleArray = ArrayUtils.add( new double[] { 2.9, 6.0, 0.3 }, 2, 1.0);\n+        assertTrue( Arrays.equals( new double[] { 2.9, 6.0, 1.0, 0.3 }, doubleArray ) );\n+        try {\n+            doubleArray = ArrayUtils.add( new double[] { 2.3, 6.4 }, 4, 10.5);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n+        }\n+        try {\n+            doubleArray = ArrayUtils.add( new double[] { 2.3, 6.4 }, -1, 10.5);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/ArrayUtilsRemoveTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang;\n+\n+import java.util.Arrays;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Tests ArrayUtils remove and removeElement methods.\n+ * \n+ * @author Maarten Coene\n+ * @version $Id$\n+ */\n+public class ArrayUtilsRemoveTest extends TestCase {\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ArrayUtilsRemoveTest.class);\n+        suite.setName(\"ArrayUtils remove Tests\");\n+        return suite;\n+    }\n+\n+    public void testRemoveObjectArray() {\n+        Object[] array;\n+        array = ArrayUtils.remove(new Object[] {\"a\"}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new Object[] {\"a\", \"b\"}, 0);\n+        assertTrue(Arrays.equals(new Object[] {\"b\"}, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new Object[] {\"a\", \"b\"}, 1);\n+        assertTrue(Arrays.equals(new Object[] {\"a\"}, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new Object[] {\"a\", \"b\", \"c\"}, 1);\n+        assertTrue(Arrays.equals(new Object[] {\"a\", \"c\"}, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new Object[] {\"a\", \"b\"}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new Object[] {\"a\", \"b\"}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((Object[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveBooleanArray() {\n+        boolean[] array;\n+        array = ArrayUtils.remove(new boolean[] {true}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new boolean[] {true, false}, 0);\n+        assertTrue(Arrays.equals(new boolean[] {false}, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new boolean[] {true, false}, 1);\n+        assertTrue(Arrays.equals(new boolean[] {true}, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new boolean[] {true, false, true}, 1);\n+        assertTrue(Arrays.equals(new boolean[] {true, true}, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new boolean[] {true, false}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new boolean[] {true, false}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((boolean[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveByteArray() {\n+        byte[] array;\n+        array = ArrayUtils.remove(new byte[] {1}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new byte[] {1, 2}, 0);\n+        assertTrue(Arrays.equals(new byte[] {2}, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new byte[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new byte[] {1}, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new byte[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new byte[] {1, 1}, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new byte[] {1, 2}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new byte[] {1, 2}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((byte[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveCharArray() {\n+        char[] array;\n+        array = ArrayUtils.remove(new char[] {'a'}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new char[] {'a', 'b'}, 0);\n+        assertTrue(Arrays.equals(new char[] {'b'}, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new char[] {'a', 'b'}, 1);\n+        assertTrue(Arrays.equals(new char[] {'a'}, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new char[] {'a', 'b', 'c'}, 1);\n+        assertTrue(Arrays.equals(new char[] {'a', 'c'}, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new char[] {'a', 'b'}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new char[] {'a', 'b'}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((char[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveDoubleArray() {\n+        double[] array;\n+        array = ArrayUtils.remove(new double[] {1}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new double[] {1, 2}, 0);\n+        assertTrue(Arrays.equals(new double[] {2}, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new double[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new double[] {1}, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new double[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new double[] {1, 1}, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new double[] {1, 2}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new double[] {1, 2}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((double[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveFloatArray() {\n+        float[] array;\n+        array = ArrayUtils.remove(new float[] {1}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new float[] {1, 2}, 0);\n+        assertTrue(Arrays.equals(new float[] {2}, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new float[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new float[] {1}, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new float[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new float[] {1, 1}, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new float[] {1, 2}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new float[] {1, 2}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((float[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveIntArray() {\n+        int[] array;\n+        array = ArrayUtils.remove(new int[] {1}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new int[] {1, 2}, 0);\n+        assertTrue(Arrays.equals(new int[] {2}, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new int[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new int[] {1}, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new int[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new int[] {1, 1}, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new int[] {1, 2}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new int[] {1, 2}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((int[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveLongArray() {\n+        long[] array;\n+        array = ArrayUtils.remove(new long[] {1}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new long[] {1, 2}, 0);\n+        assertTrue(Arrays.equals(new long[] {2}, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new long[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new long[] {1}, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new long[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new long[] {1, 1}, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new long[] {1, 2}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new long[] {1, 2}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((long[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveShortArray() {\n+        short[] array;\n+        array = ArrayUtils.remove(new short[] {1}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new short[] {1, 2}, 0);\n+        assertTrue(Arrays.equals(new short[] {2}, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new short[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new short[] {1}, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new short[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new short[] {1, 1}, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new short[] {1, 2}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new short[] {1, 2}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((short[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveElementObjectArray() {\n+        Object[] array;\n+        array = ArrayUtils.removeElement((Object[]) null, \"a\");\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_OBJECT_ARRAY, \"a\");\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new Object[] {\"a\"}, \"a\");\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new Object[] {\"a\", \"b\"}, \"a\");\n+        assertTrue(Arrays.equals(new Object[] {\"b\"}, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new Object[] {\"a\", \"b\", \"a\"}, \"a\");\n+        assertTrue(Arrays.equals(new Object[] {\"b\", \"a\"}, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementBooleanArray() {\n+        boolean[] array;\n+        array = ArrayUtils.removeElement((boolean[]) null, true);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BOOLEAN_ARRAY, true);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new boolean[] {true}, true);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new boolean[] {true, false}, true);\n+        assertTrue(Arrays.equals(new boolean[] {false}, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new boolean[] {true, false, true}, true);\n+        assertTrue(Arrays.equals(new boolean[] {false, true}, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementByteArray() {\n+        byte[] array;\n+        array = ArrayUtils.removeElement((byte[]) null, (byte) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new byte[] {1}, (byte) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new byte[] {1, 2}, (byte) 1);\n+        assertTrue(Arrays.equals(new byte[] {2}, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new byte[] {1, 2, 1}, (byte) 1);\n+        assertTrue(Arrays.equals(new byte[] {2, 1}, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementCharArray() {\n+        char[] array;\n+        array = ArrayUtils.removeElement((char[]) null, 'a');\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_CHAR_ARRAY, 'a');\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new char[] {'a'}, 'a');\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new char[] {'a', 'b'}, 'a');\n+        assertTrue(Arrays.equals(new char[] {'b'}, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new char[] {'a', 'b', 'a'}, 'a');\n+        assertTrue(Arrays.equals(new char[] {'b', 'a'}, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    @SuppressWarnings(\"cast\")\n+    public void testRemoveElementDoubleArray() {\n+        double[] array;\n+        array = ArrayUtils.removeElement((double[]) null, (double) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_DOUBLE_ARRAY, (double) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new double[] {1}, (double) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new double[] {1, 2}, (double) 1);\n+        assertTrue(Arrays.equals(new double[] {2}, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new double[] {1, 2, 1}, (double) 1);\n+        assertTrue(Arrays.equals(new double[] {2, 1}, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    @SuppressWarnings(\"cast\")\n+    public void testRemoveElementFloatArray() {\n+        float[] array;\n+        array = ArrayUtils.removeElement((float[]) null, (float) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new float[] {1}, (float) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new float[] {1, 2}, (float) 1);\n+        assertTrue(Arrays.equals(new float[] {2}, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new float[] {1, 2, 1}, (float) 1);\n+        assertTrue(Arrays.equals(new float[] {2, 1}, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementIntArray() {\n+        int[] array;\n+        array = ArrayUtils.removeElement((int[]) null, 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_INT_ARRAY, 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new int[] {1}, 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new int[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new int[] {2}, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new int[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new int[] {2, 1}, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    @SuppressWarnings(\"cast\")\n+    public void testRemoveElementLongArray() {\n+        long[] array;\n+        array = ArrayUtils.removeElement((long[]) null, (long) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_LONG_ARRAY, (long) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new long[] {1}, (long) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new long[] {1, 2}, (long) 1);\n+        assertTrue(Arrays.equals(new long[] {2}, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new long[] {1, 2, 1}, (long) 1);\n+        assertTrue(Arrays.equals(new long[] {2, 1}, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementShortArray() {\n+        short[] array;\n+        array = ArrayUtils.removeElement((short[]) null, (short) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new short[] {1}, (short) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new short[] {1, 2}, (short) 1);\n+        assertTrue(Arrays.equals(new short[] {2}, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new short[] {1, 2, 1}, (short) 1);\n+        assertTrue(Arrays.equals(new short[] {2, 1}, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/ArrayUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.ArrayUtils}.\n+ *\n+ * @author Apache Software Foundation\n+ * @author Moritz Petersen\n+ * @author Nikolay Metchev\n+ * @author Matthew Hawthorne\n+ * @author Tim O'Brien\n+ * @author <a href=\"mailto:equinus100@hotmail.com\">Ashwin S</a>\n+ * @author Fredrik Westermarck\n+ * @author Gary Gregory\n+ * @author Maarten Coene\n+ * @version $Id$\n+ */\n+public class ArrayUtilsTest extends TestCase {\n+\n+    public ArrayUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ArrayUtilsTest.class);\n+        suite.setName(\"ArrayUtils Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new ArrayUtils());\n+        Constructor<?>[] cons = ArrayUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(ArrayUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(ArrayUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        assertEquals(\"{}\", ArrayUtils.toString(null));\n+        assertEquals(\"{}\", ArrayUtils.toString(new Object[0]));\n+        assertEquals(\"{}\", ArrayUtils.toString(new String[0]));\n+        assertEquals(\"{<null>}\", ArrayUtils.toString(new String[] {null}));\n+        assertEquals(\"{pink,blue}\", ArrayUtils.toString(new String[] {\"pink\",\"blue\"}));\n+        \n+        assertEquals(\"<empty>\", ArrayUtils.toString(null, \"<empty>\"));\n+        assertEquals(\"{}\", ArrayUtils.toString(new Object[0], \"<empty>\"));\n+        assertEquals(\"{}\", ArrayUtils.toString(new String[0], \"<empty>\"));\n+        assertEquals(\"{<null>}\", ArrayUtils.toString(new String[] {null}, \"<empty>\"));\n+        assertEquals(\"{pink,blue}\", ArrayUtils.toString(new String[] {\"pink\",\"blue\"}, \"<empty>\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void assertIsEquals(Object array1, Object array2, Object array3) {\n+        assertEquals(true, ArrayUtils.isEquals(array1, array1));\n+        assertEquals(true, ArrayUtils.isEquals(array2, array2));\n+        assertEquals(true, ArrayUtils.isEquals(array3, array3));\n+        assertEquals(false, ArrayUtils.isEquals(array1, array2));\n+        assertEquals(false, ArrayUtils.isEquals(array2, array1));\n+        assertEquals(false, ArrayUtils.isEquals(array1, array3));\n+        assertEquals(false, ArrayUtils.isEquals(array3, array1));\n+        assertEquals(false, ArrayUtils.isEquals(array1, array2));\n+        assertEquals(false, ArrayUtils.isEquals(array2, array1));\n+    }\n+\n+    public void testIsEquals() {\n+        long[][] larray1 = new long[][]{{2, 5}, {4, 5}};\n+        long[][] larray2 = new long[][]{{2, 5}, {4, 6}};\n+        long[] larray3 = new long[]{2, 5};\n+        this.assertIsEquals(larray1, larray2, larray3);\n+\n+        int[][] iarray1 = new int[][]{{2, 5}, {4, 5}};\n+        int[][] iarray2 = new int[][]{{2, 5}, {4, 6}};\n+        int[] iarray3 = new int[]{2, 5};\n+        this.assertIsEquals(iarray1, iarray2, iarray3);\n+\n+        short[][] sarray1 = new short[][]{{2, 5}, {4, 5}};\n+        short[][] sarray2 = new short[][]{{2, 5}, {4, 6}};\n+        short[] sarray3 = new short[]{2, 5};\n+        this.assertIsEquals(sarray1, sarray2, sarray3);\n+\n+        float[][] farray1 = new float[][]{{2, 5}, {4, 5}};\n+        float[][] farray2 = new float[][]{{2, 5}, {4, 6}};\n+        float[] farray3 = new float[]{2, 5};\n+        this.assertIsEquals(farray1, farray2, farray3);\n+\n+        double[][] darray1 = new double[][]{{2, 5}, {4, 5}};\n+        double[][] darray2 = new double[][]{{2, 5}, {4, 6}};\n+        double[] darray3 = new double[]{2, 5};\n+        this.assertIsEquals(darray1, darray2, darray3);\n+\n+        byte[][] byteArray1 = new byte[][]{{2, 5}, {4, 5}};\n+        byte[][] byteArray2 = new byte[][]{{2, 5}, {4, 6}};\n+        byte[] byteArray3 = new byte[]{2, 5};\n+        this.assertIsEquals(byteArray1, byteArray2, byteArray3);\n+\n+        char[][] charArray1 = new char[][]{{2, 5}, {4, 5}};\n+        char[][] charArray2 = new char[][]{{2, 5}, {4, 6}};\n+        char[] charArray3 = new char[]{2, 5};\n+        this.assertIsEquals(charArray1, charArray2, charArray3);\n+\n+        boolean[][] barray1 = new boolean[][]{{true, false}, {true, true}};\n+        boolean[][] barray2 = new boolean[][]{{true, false}, {true, false}};\n+        boolean[] barray3 = new boolean[]{false, true};\n+        this.assertIsEquals(barray1, barray2, barray3);\n+\n+        Object[] array3 = new Object[]{new String(new char[]{'A', 'B'})};\n+        Object[] array4 = new Object[]{\"AB\"};\n+        assertEquals(true, ArrayUtils.isEquals(array3, array3));\n+        assertEquals(true, ArrayUtils.isEquals(array3, array4));\n+\n+        assertEquals(true, ArrayUtils.isEquals(null, null));\n+        assertEquals(false, ArrayUtils.isEquals(null, array4));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testToMap() {\n+        Map<?, ?> map = ArrayUtils.toMap(new String[][] {{\"foo\", \"bar\"}, {\"hello\", \"world\"}});\n+        \n+        assertEquals(\"bar\", map.get(\"foo\"));\n+        assertEquals(\"world\", map.get(\"hello\"));\n+        \n+        assertEquals(null, ArrayUtils.toMap(null));\n+        try {\n+            ArrayUtils.toMap(new String[][] {{\"foo\", \"bar\"}, {\"short\"}});\n+            fail(\"exception expected\");\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ArrayUtils.toMap(new Object[] {new Object[] {\"foo\", \"bar\"}, \"illegal type\"});\n+            fail(\"exception expected\");\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ArrayUtils.toMap(new Object[] {new Object[] {\"foo\", \"bar\"}, null});\n+            fail(\"exception expected\");\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        map = ArrayUtils.toMap(new Object[] {new Map.Entry<Object, Object>() {\n+            public Object getKey() {\n+                return \"foo\";\n+            }\n+            public Object getValue() {\n+                return \"bar\";\n+            }\n+            public Object setValue(Object value) {\n+                throw new UnsupportedOperationException();\n+            }\n+            @Override\n+            public boolean equals(Object o) {\n+                throw new UnsupportedOperationException();\n+            }\n+            @Override\n+            public int hashCode() {\n+                throw new UnsupportedOperationException();\n+            }\n+        }});\n+        assertEquals(\"bar\", map.get(\"foo\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testClone() {\n+        assertEquals(null, ArrayUtils.clone((Object[]) null));\n+        Object[] original1 = new Object[0];\n+        Object[] cloned1 = ArrayUtils.clone(original1);\n+        assertTrue(Arrays.equals(original1, cloned1));\n+        assertTrue(original1 != cloned1);\n+        \n+        StringBuffer buf = new StringBuffer(\"pick\");\n+        original1 = new Object[] {buf, \"a\", new String[] {\"stick\"}};\n+        cloned1 = ArrayUtils.clone(original1);\n+        assertTrue(Arrays.equals(original1, cloned1));\n+        assertTrue(original1 != cloned1);\n+        assertSame(original1[0], cloned1[0]);\n+        assertSame(original1[1], cloned1[1]);\n+        assertSame(original1[2], cloned1[2]);\n+    }\n+\n+    public void testCloneBoolean() {\n+        assertEquals(null, ArrayUtils.clone((boolean[]) null));\n+        boolean[] original = new boolean[] {true, false};\n+        boolean[] cloned = ArrayUtils.clone(original);\n+        assertTrue(Arrays.equals(original, cloned));\n+        assertTrue(original != cloned);\n+    }\n+    \n+    public void testCloneLong() {\n+        assertEquals(null, ArrayUtils.clone((long[]) null));\n+        long[] original = new long[] {0L, 1L};\n+        long[] cloned = ArrayUtils.clone(original);\n+        assertTrue(Arrays.equals(original, cloned));\n+        assertTrue(original != cloned);\n+    }\n+    \n+    public void testCloneInt() {\n+        assertEquals(null, ArrayUtils.clone((int[]) null));\n+        int[] original = new int[] {5, 8};\n+        int[] cloned = ArrayUtils.clone(original);\n+        assertTrue(Arrays.equals(original, cloned));\n+        assertTrue(original != cloned);\n+    }\n+    \n+    public void testCloneShort() {\n+        assertEquals(null, ArrayUtils.clone((short[]) null));\n+        short[] original = new short[] {1, 4};\n+        short[] cloned = ArrayUtils.clone(original);\n+        assertTrue(Arrays.equals(original, cloned));\n+        assertTrue(original != cloned);\n+    }\n+    \n+    public void testCloneChar() {\n+        assertEquals(null, ArrayUtils.clone((char[]) null));\n+        char[] original = new char[] {'a', '4'};\n+        char[] cloned = ArrayUtils.clone(original);\n+        assertTrue(Arrays.equals(original, cloned));\n+        assertTrue(original != cloned);\n+    }\n+    \n+    public void testCloneByte() {\n+        assertEquals(null, ArrayUtils.clone((byte[]) null));\n+        byte[] original = new byte[] {1, 6};\n+        byte[] cloned = ArrayUtils.clone(original);\n+        assertTrue(Arrays.equals(original, cloned));\n+        assertTrue(original != cloned);\n+    }\n+    \n+    public void testCloneDouble() {\n+        assertEquals(null, ArrayUtils.clone((double[]) null));\n+        double[] original = new double[] {2.4d, 5.7d};\n+        double[] cloned = ArrayUtils.clone(original);\n+        assertTrue(Arrays.equals(original, cloned));\n+        assertTrue(original != cloned);\n+    }\n+    \n+    public void testCloneFloat() {\n+        assertEquals(null, ArrayUtils.clone((float[]) null));\n+        float[] original = new float[] {2.6f, 6.4f};\n+        float[] cloned = ArrayUtils.clone(original);\n+        assertTrue(Arrays.equals(original, cloned));\n+        assertTrue(original != cloned);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testSubarrayObject() {\n+        Object[] nullArray = null;\n+        Object[] objectArray = { \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\n+\n+        assertEquals(\"0 start, mid end\", \"abcd\",\n+            StringUtils.join(ArrayUtils.subarray(objectArray, 0, 4)));\n+        assertEquals(\"0 start, length end\", \"abcdef\",\n+            StringUtils.join(ArrayUtils.subarray(objectArray, 0, objectArray.length)));\n+        assertEquals(\"mid start, mid end\", \"bcd\",\n+            StringUtils.join(ArrayUtils.subarray(objectArray, 1, 4)));\n+        assertEquals(\"mid start, length end\", \"bcdef\",\n+            StringUtils.join(ArrayUtils.subarray(objectArray, 1, objectArray.length)));\n+\n+        assertNull(\"null input\", ArrayUtils.subarray(nullArray, 0, 3));\n+        assertEquals(\"empty array\", \"\",\n+            StringUtils.join(ArrayUtils.subarray(ArrayUtils.EMPTY_OBJECT_ARRAY, 1, 2)));\n+        assertEquals(\"start > end\", \"\",\n+            StringUtils.join(ArrayUtils.subarray(objectArray, 4, 2)));\n+        assertEquals(\"start == end\", \"\",\n+            StringUtils.join(ArrayUtils.subarray(objectArray, 3, 3)));\n+        assertEquals(\"start undershoot, normal end\", \"abcd\",\n+            StringUtils.join(ArrayUtils.subarray(objectArray, -2, 4)));\n+        assertEquals(\"start overshoot, any end\", \"\",\n+            StringUtils.join(ArrayUtils.subarray(objectArray, 33, 4)));\n+        assertEquals(\"normal start, end overshoot\", \"cdef\",\n+            StringUtils.join(ArrayUtils.subarray(objectArray, 2, 33)));\n+        assertEquals(\"start undershoot, end overshoot\", \"abcdef\",\n+            StringUtils.join(ArrayUtils.subarray(objectArray, -2, 12)));\n+            \n+        // array type tests\n+        Date[] dateArray = { new java.sql.Date(new Date().getTime()),\n+            new Date(), new Date(), new Date(), new Date() };\n+\n+        assertSame(\"Object type\", Object.class,\n+            ArrayUtils.subarray(objectArray, 2, 4).getClass().getComponentType());\n+        assertSame(\"java.util.Date type\", java.util.Date.class,\n+            ArrayUtils.subarray(dateArray, 1, 4).getClass().getComponentType());\n+        assertNotSame(\"java.sql.Date type\", java.sql.Date.class,\n+            ArrayUtils.subarray(dateArray, 1, 4).getClass().getComponentType());\n+        try {\n+            @SuppressWarnings(\"unused\")\n+            java.sql.Date[] dummy = (java.sql.Date[])ArrayUtils.subarray(dateArray, 1,3);\n+            fail(\"Invalid downcast\");\n+        } catch (ClassCastException e) {}\n+    }\n+\n+    public void testSubarrayLong() {\n+        long[] nullArray = null;\n+        long[] array = { 999910, 999911, 999912, 999913, 999914, 999915 };\n+        long[] leftSubarray     = { 999910, 999911, 999912, 999913 };\n+        long[] midSubarray      = { 999911, 999912, 999913, 999914 };\n+        long[] rightSubarray    = { 999912, 999913, 999914, 999915 };\n+\n+        assertTrue(\"0 start, mid end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, 0, 4)));\n+\n+        assertTrue(\"0 start, length end\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, 0, array.length)));\n+\n+        assertTrue(\"mid start, mid end\",\n+            ArrayUtils.isEquals(midSubarray,\n+                ArrayUtils.subarray(array, 1, 5)));\n+\n+        assertTrue(\"mid start, length end\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, array.length)));\n+\n+\n+        assertNull(\"null input\", ArrayUtils.subarray(nullArray, 0, 3));\n+\n+        assertEquals(\"empty array\", ArrayUtils.EMPTY_LONG_ARRAY,\n+            ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2));\n+\n+        assertEquals(\"start > end\", ArrayUtils.EMPTY_LONG_ARRAY,\n+            ArrayUtils.subarray(array, 4, 2));\n+\n+        assertEquals(\"start == end\", ArrayUtils.EMPTY_LONG_ARRAY,\n+            ArrayUtils.subarray(array, 3, 3));\n+\n+        assertTrue(\"start undershoot, normal end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, -2, 4)));\n+\n+        assertEquals(\"start overshoot, any end\",\n+            ArrayUtils.EMPTY_LONG_ARRAY,\n+                ArrayUtils.subarray(array, 33, 4));\n+\n+        assertTrue(\"normal start, end overshoot\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, 33)));\n+\n+        assertTrue(\"start undershoot, end overshoot\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, -2, 12)));\n+\n+        // empty-return tests\n+\n+        assertSame(\"empty array, object test\",\n+            ArrayUtils.EMPTY_LONG_ARRAY,\n+                ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2));\n+\n+        assertSame(\"start > end, object test\",\n+            ArrayUtils.EMPTY_LONG_ARRAY,\n+                ArrayUtils.subarray(array, 4, 1));\n+\n+        assertSame(\"start == end, object test\",\n+            ArrayUtils.EMPTY_LONG_ARRAY,\n+                ArrayUtils.subarray(array, 3, 3));\n+\n+        assertSame(\"start overshoot, any end, object test\",\n+            ArrayUtils.EMPTY_LONG_ARRAY,\n+                ArrayUtils.subarray(array, 8733, 4));\n+\n+        // array type tests\n+\n+        assertSame(\"long type\", long.class,\n+            ArrayUtils.subarray(array, 2, 4).getClass().getComponentType());\n+\n+    }\n+\n+    public void testSubarrayInt() {\n+        int[] nullArray = null;\n+        int[] array = { 10, 11, 12, 13, 14, 15 };\n+        int[] leftSubarray  = { 10, 11, 12, 13 };\n+        int[] midSubarray   = { 11, 12, 13, 14 };\n+        int[] rightSubarray = { 12, 13, 14, 15 };\n+\n+\n+        assertTrue(\"0 start, mid end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, 0, 4)));\n+\n+        assertTrue(\"0 start, length end\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, 0, array.length)));\n+\n+        assertTrue(\"mid start, mid end\",\n+            ArrayUtils.isEquals(midSubarray,\n+                ArrayUtils.subarray(array, 1, 5)));\n+\n+        assertTrue(\"mid start, length end\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, array.length)));\n+\n+\n+        assertNull(\"null input\", ArrayUtils.subarray(nullArray, 0, 3));\n+\n+        assertEquals(\"empty array\", ArrayUtils.EMPTY_INT_ARRAY,\n+            ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2));\n+\n+        assertEquals(\"start > end\", ArrayUtils.EMPTY_INT_ARRAY,\n+            ArrayUtils.subarray(array, 4, 2));\n+\n+        assertEquals(\"start == end\", ArrayUtils.EMPTY_INT_ARRAY,\n+            ArrayUtils.subarray(array, 3, 3));\n+\n+        assertTrue(\"start undershoot, normal end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, -2, 4)));\n+\n+        assertEquals(\"start overshoot, any end\",\n+            ArrayUtils.EMPTY_INT_ARRAY,\n+                ArrayUtils.subarray(array, 33, 4));\n+\n+        assertTrue(\"normal start, end overshoot\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, 33)));\n+\n+        assertTrue(\"start undershoot, end overshoot\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, -2, 12)));\n+\n+        // empty-return tests\n+\n+        assertSame(\"empty array, object test\",\n+            ArrayUtils.EMPTY_INT_ARRAY,\n+                ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2));\n+\n+        assertSame(\"start > end, object test\",\n+            ArrayUtils.EMPTY_INT_ARRAY,\n+                ArrayUtils.subarray(array, 4, 1));\n+\n+        assertSame(\"start == end, object test\",\n+            ArrayUtils.EMPTY_INT_ARRAY,\n+                ArrayUtils.subarray(array, 3, 3));\n+\n+        assertSame(\"start overshoot, any end, object test\",\n+            ArrayUtils.EMPTY_INT_ARRAY,\n+                ArrayUtils.subarray(array, 8733, 4));\n+\n+        // array type tests\n+\n+        assertSame(\"int type\", int.class,\n+            ArrayUtils.subarray(array, 2, 4).getClass().getComponentType());\n+\n+    }\n+\n+    public void testSubarrayShort() {\n+        short[] nullArray = null;\n+        short[] array = { 10, 11, 12, 13, 14, 15 };\n+        short[] leftSubarray    = { 10, 11, 12, 13 };\n+        short[] midSubarray     = { 11, 12, 13, 14 };\n+        short[] rightSubarray   = { 12, 13, 14, 15 };\n+\n+\n+        assertTrue(\"0 start, mid end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, 0, 4)));\n+\n+        assertTrue(\"0 start, length end\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, 0, array.length)));\n+\n+        assertTrue(\"mid start, mid end\",\n+            ArrayUtils.isEquals(midSubarray,\n+                ArrayUtils.subarray(array, 1, 5)));\n+\n+        assertTrue(\"mid start, length end\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, array.length)));\n+\n+\n+        assertNull(\"null input\", ArrayUtils.subarray(nullArray, 0, 3));\n+\n+        assertEquals(\"empty array\", ArrayUtils.EMPTY_SHORT_ARRAY,\n+            ArrayUtils.subarray(ArrayUtils.EMPTY_SHORT_ARRAY, 1, 2));\n+\n+        assertEquals(\"start > end\", ArrayUtils.EMPTY_SHORT_ARRAY,\n+            ArrayUtils.subarray(array, 4, 2));\n+\n+        assertEquals(\"start == end\", ArrayUtils.EMPTY_SHORT_ARRAY,\n+            ArrayUtils.subarray(array, 3, 3));\n+\n+        assertTrue(\"start undershoot, normal end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, -2, 4)));\n+\n+        assertEquals(\"start overshoot, any end\",\n+            ArrayUtils.EMPTY_SHORT_ARRAY,\n+                ArrayUtils.subarray(array, 33, 4));\n+\n+        assertTrue(\"normal start, end overshoot\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, 33)));\n+\n+        assertTrue(\"start undershoot, end overshoot\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, -2, 12)));\n+\n+        // empty-return tests\n+\n+        assertSame(\"empty array, object test\",\n+            ArrayUtils.EMPTY_SHORT_ARRAY,\n+                ArrayUtils.subarray(ArrayUtils.EMPTY_SHORT_ARRAY, 1, 2));\n+\n+        assertSame(\"start > end, object test\",\n+            ArrayUtils.EMPTY_SHORT_ARRAY,\n+                ArrayUtils.subarray(array, 4, 1));\n+\n+        assertSame(\"start == end, object test\",\n+            ArrayUtils.EMPTY_SHORT_ARRAY,\n+                ArrayUtils.subarray(array, 3, 3));\n+\n+        assertSame(\"start overshoot, any end, object test\",\n+            ArrayUtils.EMPTY_SHORT_ARRAY,\n+                ArrayUtils.subarray(array, 8733, 4));\n+\n+        // array type tests\n+\n+        assertSame(\"short type\", short.class,\n+            ArrayUtils.subarray(array, 2, 4).getClass().getComponentType());\n+\n+    }\n+\n+    public void testSubarrChar() {\n+        char[] nullArray = null;\n+        char[] array = { 'a', 'b', 'c', 'd', 'e', 'f' };\n+        char[] leftSubarray     = { 'a', 'b', 'c', 'd', };\n+        char[] midSubarray      = { 'b', 'c', 'd', 'e', };\n+        char[] rightSubarray    = { 'c', 'd', 'e', 'f', };\n+\n+\n+        assertTrue(\"0 start, mid end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, 0, 4)));\n+\n+        assertTrue(\"0 start, length end\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, 0, array.length)));\n+\n+        assertTrue(\"mid start, mid end\",\n+            ArrayUtils.isEquals(midSubarray,\n+                ArrayUtils.subarray(array, 1, 5)));\n+\n+        assertTrue(\"mid start, length end\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, array.length)));\n+\n+\n+        assertNull(\"null input\", ArrayUtils.subarray(nullArray, 0, 3));\n+\n+        assertEquals(\"empty array\", ArrayUtils.EMPTY_CHAR_ARRAY,\n+            ArrayUtils.subarray(ArrayUtils.EMPTY_CHAR_ARRAY, 1, 2));\n+\n+        assertEquals(\"start > end\", ArrayUtils.EMPTY_CHAR_ARRAY,\n+            ArrayUtils.subarray(array, 4, 2));\n+\n+        assertEquals(\"start == end\", ArrayUtils.EMPTY_CHAR_ARRAY,\n+            ArrayUtils.subarray(array, 3, 3));\n+\n+        assertTrue(\"start undershoot, normal end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, -2, 4)));\n+\n+        assertEquals(\"start overshoot, any end\",\n+            ArrayUtils.EMPTY_CHAR_ARRAY,\n+                ArrayUtils.subarray(array, 33, 4));\n+\n+        assertTrue(\"normal start, end overshoot\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, 33)));\n+\n+        assertTrue(\"start undershoot, end overshoot\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, -2, 12)));\n+\n+        // empty-return tests\n+\n+        assertSame(\"empty array, object test\",\n+            ArrayUtils.EMPTY_CHAR_ARRAY,\n+                ArrayUtils.subarray(ArrayUtils.EMPTY_CHAR_ARRAY, 1, 2));\n+\n+        assertSame(\"start > end, object test\",\n+            ArrayUtils.EMPTY_CHAR_ARRAY,\n+                ArrayUtils.subarray(array, 4, 1));\n+\n+        assertSame(\"start == end, object test\",\n+            ArrayUtils.EMPTY_CHAR_ARRAY,\n+                ArrayUtils.subarray(array, 3, 3));\n+\n+        assertSame(\"start overshoot, any end, object test\",\n+            ArrayUtils.EMPTY_CHAR_ARRAY,\n+                ArrayUtils.subarray(array, 8733, 4));\n+\n+        // array type tests\n+\n+        assertSame(\"char type\", char.class,\n+            ArrayUtils.subarray(array, 2, 4).getClass().getComponentType());\n+\n+    }\n+\n+    public void testSubarrayByte() {\n+        byte[] nullArray = null;\n+        byte[] array = { 10, 11, 12, 13, 14, 15 };\n+        byte[] leftSubarray     = { 10, 11, 12, 13 };\n+        byte[] midSubarray      = { 11, 12, 13, 14 };\n+        byte[] rightSubarray = { 12, 13, 14, 15 };\n+\n+\n+        assertTrue(\"0 start, mid end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, 0, 4)));\n+\n+        assertTrue(\"0 start, length end\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, 0, array.length)));\n+\n+        assertTrue(\"mid start, mid end\",\n+            ArrayUtils.isEquals(midSubarray,\n+                ArrayUtils.subarray(array, 1, 5)));\n+\n+        assertTrue(\"mid start, length end\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, array.length)));\n+\n+\n+        assertNull(\"null input\", ArrayUtils.subarray(nullArray, 0, 3));\n+\n+        assertEquals(\"empty array\", ArrayUtils.EMPTY_BYTE_ARRAY,\n+            ArrayUtils.subarray(ArrayUtils.EMPTY_BYTE_ARRAY, 1, 2));\n+\n+        assertEquals(\"start > end\", ArrayUtils.EMPTY_BYTE_ARRAY,\n+            ArrayUtils.subarray(array, 4, 2));\n+\n+        assertEquals(\"start == end\", ArrayUtils.EMPTY_BYTE_ARRAY,\n+            ArrayUtils.subarray(array, 3, 3));\n+\n+        assertTrue(\"start undershoot, normal end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, -2, 4)));\n+\n+        assertEquals(\"start overshoot, any end\",\n+            ArrayUtils.EMPTY_BYTE_ARRAY,\n+                ArrayUtils.subarray(array, 33, 4));\n+\n+        assertTrue(\"normal start, end overshoot\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, 33)));\n+\n+        assertTrue(\"start undershoot, end overshoot\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, -2, 12)));\n+\n+        // empty-return tests\n+\n+        assertSame(\"empty array, object test\",\n+            ArrayUtils.EMPTY_BYTE_ARRAY,\n+                ArrayUtils.subarray(ArrayUtils.EMPTY_BYTE_ARRAY, 1, 2));\n+\n+        assertSame(\"start > end, object test\",\n+            ArrayUtils.EMPTY_BYTE_ARRAY,\n+                ArrayUtils.subarray(array, 4, 1));\n+\n+        assertSame(\"start == end, object test\",\n+            ArrayUtils.EMPTY_BYTE_ARRAY,\n+                ArrayUtils.subarray(array, 3, 3));\n+\n+        assertSame(\"start overshoot, any end, object test\",\n+            ArrayUtils.EMPTY_BYTE_ARRAY,\n+                ArrayUtils.subarray(array, 8733, 4));\n+\n+        // array type tests\n+\n+        assertSame(\"byte type\", byte.class,\n+            ArrayUtils.subarray(array, 2, 4).getClass().getComponentType());\n+\n+    }\n+\n+    public void testSubarrayDouble() {\n+        double[] nullArray = null;\n+        double[] array = { 10.123, 11.234, 12.345, 13.456, 14.567, 15.678 };\n+        double[] leftSubarray   = { 10.123, 11.234, 12.345, 13.456, };\n+        double[] midSubarray    = { 11.234, 12.345, 13.456, 14.567, };\n+        double[] rightSubarray  = { 12.345, 13.456, 14.567, 15.678 };\n+\n+\n+        assertTrue(\"0 start, mid end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, 0, 4)));\n+\n+        assertTrue(\"0 start, length end\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, 0, array.length)));\n+\n+        assertTrue(\"mid start, mid end\",\n+            ArrayUtils.isEquals(midSubarray,\n+                ArrayUtils.subarray(array, 1, 5)));\n+\n+        assertTrue(\"mid start, length end\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, array.length)));\n+\n+\n+        assertNull(\"null input\", ArrayUtils.subarray(nullArray, 0, 3));\n+\n+        assertEquals(\"empty array\", ArrayUtils.EMPTY_DOUBLE_ARRAY,\n+            ArrayUtils.subarray(ArrayUtils.EMPTY_DOUBLE_ARRAY, 1, 2));\n+\n+        assertEquals(\"start > end\", ArrayUtils.EMPTY_DOUBLE_ARRAY,\n+            ArrayUtils.subarray(array, 4, 2));\n+\n+        assertEquals(\"start == end\", ArrayUtils.EMPTY_DOUBLE_ARRAY,\n+            ArrayUtils.subarray(array, 3, 3));\n+\n+        assertTrue(\"start undershoot, normal end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, -2, 4)));\n+\n+        assertEquals(\"start overshoot, any end\",\n+            ArrayUtils.EMPTY_DOUBLE_ARRAY,\n+                ArrayUtils.subarray(array, 33, 4));\n+\n+        assertTrue(\"normal start, end overshoot\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, 33)));\n+\n+        assertTrue(\"start undershoot, end overshoot\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, -2, 12)));\n+\n+        // empty-return tests\n+\n+        assertSame(\"empty array, object test\",\n+            ArrayUtils.EMPTY_DOUBLE_ARRAY,\n+                ArrayUtils.subarray(ArrayUtils.EMPTY_DOUBLE_ARRAY, 1, 2));\n+\n+        assertSame(\"start > end, object test\",\n+            ArrayUtils.EMPTY_DOUBLE_ARRAY,\n+                ArrayUtils.subarray(array, 4, 1));\n+\n+        assertSame(\"start == end, object test\",\n+            ArrayUtils.EMPTY_DOUBLE_ARRAY,\n+                ArrayUtils.subarray(array, 3, 3));\n+\n+        assertSame(\"start overshoot, any end, object test\",\n+            ArrayUtils.EMPTY_DOUBLE_ARRAY,\n+                ArrayUtils.subarray(array, 8733, 4));\n+\n+        // array type tests\n+\n+        assertSame(\"double type\", double.class,\n+            ArrayUtils.subarray(array, 2, 4).getClass().getComponentType());\n+\n+    }\n+\n+    public void testSubarrayFloat() {\n+        float[] nullArray = null;\n+        float[] array = { 10, 11, 12, 13, 14, 15 };\n+        float[] leftSubarray    = { 10, 11, 12, 13 };\n+        float[] midSubarray     = { 11, 12, 13, 14 };\n+        float[] rightSubarray   = { 12, 13, 14, 15 };\n+\n+\n+        assertTrue(\"0 start, mid end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, 0, 4)));\n+\n+        assertTrue(\"0 start, length end\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, 0, array.length)));\n+\n+        assertTrue(\"mid start, mid end\",\n+            ArrayUtils.isEquals(midSubarray,\n+                ArrayUtils.subarray(array, 1, 5)));\n+\n+        assertTrue(\"mid start, length end\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, array.length)));\n+\n+\n+        assertNull(\"null input\", ArrayUtils.subarray(nullArray, 0, 3));\n+\n+        assertEquals(\"empty array\", ArrayUtils.EMPTY_FLOAT_ARRAY,\n+            ArrayUtils.subarray(ArrayUtils.EMPTY_FLOAT_ARRAY, 1, 2));\n+\n+        assertEquals(\"start > end\", ArrayUtils.EMPTY_FLOAT_ARRAY,\n+            ArrayUtils.subarray(array, 4, 2));\n+\n+        assertEquals(\"start == end\", ArrayUtils.EMPTY_FLOAT_ARRAY,\n+            ArrayUtils.subarray(array, 3, 3));\n+\n+        assertTrue(\"start undershoot, normal end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, -2, 4)));\n+\n+        assertEquals(\"start overshoot, any end\",\n+            ArrayUtils.EMPTY_FLOAT_ARRAY,\n+                ArrayUtils.subarray(array, 33, 4));\n+\n+        assertTrue(\"normal start, end overshoot\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, 33)));\n+\n+        assertTrue(\"start undershoot, end overshoot\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, -2, 12)));\n+\n+        // empty-return tests\n+\n+        assertSame(\"empty array, object test\",\n+            ArrayUtils.EMPTY_FLOAT_ARRAY,\n+                ArrayUtils.subarray(ArrayUtils.EMPTY_FLOAT_ARRAY, 1, 2));\n+\n+        assertSame(\"start > end, object test\",\n+            ArrayUtils.EMPTY_FLOAT_ARRAY,\n+                ArrayUtils.subarray(array, 4, 1));\n+\n+        assertSame(\"start == end, object test\",\n+            ArrayUtils.EMPTY_FLOAT_ARRAY,\n+                ArrayUtils.subarray(array, 3, 3));\n+\n+        assertSame(\"start overshoot, any end, object test\",\n+            ArrayUtils.EMPTY_FLOAT_ARRAY,\n+                ArrayUtils.subarray(array, 8733, 4));\n+\n+        // array type tests\n+\n+        assertSame(\"float type\", float.class,\n+            ArrayUtils.subarray(array, 2, 4).getClass().getComponentType());\n+\n+    }\n+\n+    public void testSubarrayBoolean() {\n+        boolean[] nullArray = null;\n+        boolean[] array = { true, true, false, true, false, true };\n+        boolean[] leftSubarray  = { true, true, false, true  };\n+        boolean[] midSubarray   = { true, false, true, false };\n+        boolean[] rightSubarray = { false, true, false, true };\n+\n+\n+        assertTrue(\"0 start, mid end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, 0, 4)));\n+\n+        assertTrue(\"0 start, length end\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, 0, array.length)));\n+\n+        assertTrue(\"mid start, mid end\",\n+            ArrayUtils.isEquals(midSubarray,\n+                ArrayUtils.subarray(array, 1, 5)));\n+\n+        assertTrue(\"mid start, length end\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, array.length)));\n+\n+\n+        assertNull(\"null input\", ArrayUtils.subarray(nullArray, 0, 3));\n+\n+        assertEquals(\"empty array\", ArrayUtils.EMPTY_BOOLEAN_ARRAY,\n+            ArrayUtils.subarray(ArrayUtils.EMPTY_BOOLEAN_ARRAY, 1, 2));\n+\n+        assertEquals(\"start > end\", ArrayUtils.EMPTY_BOOLEAN_ARRAY,\n+            ArrayUtils.subarray(array, 4, 2));\n+\n+        assertEquals(\"start == end\", ArrayUtils.EMPTY_BOOLEAN_ARRAY,\n+            ArrayUtils.subarray(array, 3, 3));\n+\n+        assertTrue(\"start undershoot, normal end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, -2, 4)));\n+\n+        assertEquals(\"start overshoot, any end\",\n+            ArrayUtils.EMPTY_BOOLEAN_ARRAY,\n+                ArrayUtils.subarray(array, 33, 4));\n+\n+        assertTrue(\"normal start, end overshoot\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, 33)));\n+\n+        assertTrue(\"start undershoot, end overshoot\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, -2, 12)));\n+\n+        // empty-return tests\n+\n+        assertSame(\"empty array, object test\",\n+            ArrayUtils.EMPTY_BOOLEAN_ARRAY,\n+                ArrayUtils.subarray(ArrayUtils.EMPTY_BOOLEAN_ARRAY, 1, 2));\n+\n+        assertSame(\"start > end, object test\",\n+            ArrayUtils.EMPTY_BOOLEAN_ARRAY,\n+                ArrayUtils.subarray(array, 4, 1));\n+\n+        assertSame(\"start == end, object test\",\n+            ArrayUtils.EMPTY_BOOLEAN_ARRAY,\n+                ArrayUtils.subarray(array, 3, 3));\n+\n+        assertSame(\"start overshoot, any end, object test\",\n+            ArrayUtils.EMPTY_BOOLEAN_ARRAY,\n+                ArrayUtils.subarray(array, 8733, 4));\n+\n+        // array type tests\n+\n+        assertSame(\"boolean type\", boolean.class,\n+            ArrayUtils.subarray(array, 2, 4).getClass().getComponentType());\n+\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testSameLength() {\n+        Object[] nullArray = null;\n+        Object[] emptyArray = new Object[0];\n+        Object[] oneArray = new Object[] {\"pick\"};\n+        Object[] twoArray = new Object[] {\"pick\", \"stick\"};\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));\n+        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));\n+        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));\n+    }\n+\n+    public void testSameLengthBoolean() {\n+        boolean[] nullArray = null;\n+        boolean[] emptyArray = new boolean[0];\n+        boolean[] oneArray = new boolean[] {true};\n+        boolean[] twoArray = new boolean[] {true, false};\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));\n+        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));\n+        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));\n+    }\n+    \n+    public void testSameLengthLong() {\n+        long[] nullArray = null;\n+        long[] emptyArray = new long[0];\n+        long[] oneArray = new long[] {0L};\n+        long[] twoArray = new long[] {0L, 76L};\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));\n+        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));\n+        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));\n+    }\n+    \n+    public void testSameLengthInt() {\n+        int[] nullArray = null;\n+        int[] emptyArray = new int[0];\n+        int[] oneArray = new int[] {4};\n+        int[] twoArray = new int[] {5, 7};\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));\n+        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));\n+        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));\n+    }\n+    \n+    public void testSameLengthShort() {\n+        short[] nullArray = null;\n+        short[] emptyArray = new short[0];\n+        short[] oneArray = new short[] {4};\n+        short[] twoArray = new short[] {6, 8};\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));\n+        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));\n+        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));\n+    }\n+    \n+    public void testSameLengthChar() {\n+        char[] nullArray = null;\n+        char[] emptyArray = new char[0];\n+        char[] oneArray = new char[] {'f'};\n+        char[] twoArray = new char[] {'d', 't'};\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));\n+        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));\n+        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));\n+    }\n+    \n+    public void testSameLengthByte() {\n+        byte[] nullArray = null;\n+        byte[] emptyArray = new byte[0];\n+        byte[] oneArray = new byte[] {3};\n+        byte[] twoArray = new byte[] {4, 6};\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));\n+        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));\n+        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));\n+    }\n+    \n+    public void testSameLengthDouble() {\n+        double[] nullArray = null;\n+        double[] emptyArray = new double[0];\n+        double[] oneArray = new double[] {1.3d};\n+        double[] twoArray = new double[] {4.5d, 6.3d};\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));\n+        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));\n+        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));\n+    }\n+    \n+    public void testSameLengthFloat() {\n+        float[] nullArray = null;\n+        float[] emptyArray = new float[0];\n+        float[] oneArray = new float[] {2.5f};\n+        float[] twoArray = new float[] {6.4f, 5.8f};\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));\n+        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));\n+        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testSameType() {\n+        try {\n+            ArrayUtils.isSameType(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ArrayUtils.isSameType(null, new Object[0]);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ArrayUtils.isSameType(new Object[0], null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        assertEquals(true, ArrayUtils.isSameType(new Object[0], new Object[0]));\n+        assertEquals(false, ArrayUtils.isSameType(new String[0], new Object[0]));\n+        assertEquals(true, ArrayUtils.isSameType(new String[0][0], new String[0][0]));\n+        assertEquals(false, ArrayUtils.isSameType(new String[0], new String[0][0]));\n+        assertEquals(false, ArrayUtils.isSameType(new String[0][0], new String[0]));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testReverse() {\n+        StringBuffer str1 = new StringBuffer(\"pick\");\n+        String str2 = \"a\";\n+        String[] str3 = new String[] {\"stick\"};\n+        String str4 = \"up\";\n+        \n+        Object[] array = new Object[] {str1, str2, str3};\n+        ArrayUtils.reverse(array);\n+        assertEquals(array[0], str3);\n+        assertEquals(array[1], str2);\n+        assertEquals(array[2], str1);\n+        \n+        array = new Object[] {str1, str2, str3, str4};\n+        ArrayUtils.reverse(array);\n+        assertEquals(array[0], str4);\n+        assertEquals(array[1], str3);\n+        assertEquals(array[2], str2);\n+        assertEquals(array[3], str1);\n+\n+        array = null;\n+        ArrayUtils.reverse(array);\n+        assertEquals(null, array);\n+    }\n+\n+    public void testReverseLong() {\n+        long[] array = new long[] {1L, 2L, 3L};\n+        ArrayUtils.reverse(array);\n+        assertEquals(array[0], 3L);\n+        assertEquals(array[1], 2L);\n+        assertEquals(array[2], 1L);\n+\n+        array = null;\n+        ArrayUtils.reverse(array);\n+        assertEquals(null, array);\n+    }\n+    \n+    public void testReverseInt() {\n+        int[] array = new int[] {1, 2, 3};\n+        ArrayUtils.reverse(array);\n+        assertEquals(array[0], 3);\n+        assertEquals(array[1], 2);\n+        assertEquals(array[2], 1);\n+\n+        array = null;\n+        ArrayUtils.reverse(array);\n+        assertEquals(null, array);\n+    }\n+    \n+    public void testReverseShort() {\n+        short[] array = new short[] {1, 2, 3};\n+        ArrayUtils.reverse(array);\n+        assertEquals(array[0], 3);\n+        assertEquals(array[1], 2);\n+        assertEquals(array[2], 1);\n+\n+        array = null;\n+        ArrayUtils.reverse(array);\n+        assertEquals(null, array);\n+    }\n+    \n+    public void testReverseChar() {\n+        char[] array = new char[] {'a', 'f', 'C'};\n+        ArrayUtils.reverse(array);\n+        assertEquals(array[0], 'C');\n+        assertEquals(array[1], 'f');\n+        assertEquals(array[2], 'a');\n+\n+        array = null;\n+        ArrayUtils.reverse(array);\n+        assertEquals(null, array);\n+    }\n+    \n+    public void testReverseByte() {\n+        byte[] array = new byte[] {2, 3, 4};\n+        ArrayUtils.reverse(array);\n+        assertEquals(array[0], 4);\n+        assertEquals(array[1], 3);\n+        assertEquals(array[2], 2);\n+\n+        array = null;\n+        ArrayUtils.reverse(array);\n+        assertEquals(null, array);\n+    }\n+    \n+    public void testReverseDouble() {\n+        double[] array = new double[] {0.3d, 0.4d, 0.5d};\n+        ArrayUtils.reverse(array);\n+        assertEquals(array[0], 0.5d, 0.0d);\n+        assertEquals(array[1], 0.4d, 0.0d);\n+        assertEquals(array[2], 0.3d, 0.0d);\n+\n+        array = null;\n+        ArrayUtils.reverse(array);\n+        assertEquals(null, array);\n+    }\n+    \n+    public void testReverseFloat() {\n+        float[] array = new float[] {0.3f, 0.4f, 0.5f};\n+        ArrayUtils.reverse(array);\n+        assertEquals(array[0], 0.5f, 0.0f);\n+        assertEquals(array[1], 0.4f, 0.0f);\n+        assertEquals(array[2], 0.3f, 0.0f);\n+\n+        array = null;\n+        ArrayUtils.reverse(array);\n+        assertEquals(null, array);\n+    }\n+    \n+    public void testReverseBoolean() {\n+        boolean[] array = new boolean[] {false, false, true};\n+        ArrayUtils.reverse(array);\n+        assertEquals(array[0], true);\n+        assertEquals(array[1], false);\n+        assertEquals(array[2], false);\n+\n+        array = null;\n+        ArrayUtils.reverse(array);\n+        assertEquals(null, array);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIndexOf() {\n+        Object[] array = new Object[] { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n+        assertEquals(-1, ArrayUtils.indexOf(null, null));\n+        assertEquals(-1, ArrayUtils.indexOf(null, \"0\"));\n+        assertEquals(-1, ArrayUtils.indexOf(new Object[0], \"0\"));\n+        assertEquals(0, ArrayUtils.indexOf(array, \"0\"));\n+        assertEquals(1, ArrayUtils.indexOf(array, \"1\"));\n+        assertEquals(2, ArrayUtils.indexOf(array, \"2\"));\n+        assertEquals(3, ArrayUtils.indexOf(array, \"3\"));\n+        assertEquals(4, ArrayUtils.indexOf(array, null));\n+        assertEquals(-1, ArrayUtils.indexOf(array, \"notInArray\"));\n+    }\n+\n+    public void testIndexOfWithStartIndex() {\n+        Object[] array = new Object[] { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n+        assertEquals(-1, ArrayUtils.indexOf(null, null, 2));\n+        assertEquals(-1, ArrayUtils.indexOf(new Object[0], \"0\", 0));\n+        assertEquals(-1, ArrayUtils.indexOf(null, \"0\", 2));\n+        assertEquals(5, ArrayUtils.indexOf(array, \"0\", 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, \"1\", 2));\n+        assertEquals(2, ArrayUtils.indexOf(array, \"2\", 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, \"3\", 2));\n+        assertEquals(4, ArrayUtils.indexOf(array, null, 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, \"notInArray\", 2));\n+        \n+        assertEquals(4, ArrayUtils.indexOf(array, null, -1));\n+        assertEquals(-1, ArrayUtils.indexOf(array, null, 8));\n+        assertEquals(-1, ArrayUtils.indexOf(array, \"0\", 8));\n+    }\n+\n+    public void testLastIndexOf() {\n+        Object[] array = new Object[] { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n+        assertEquals(-1, ArrayUtils.lastIndexOf(null, null));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(null, \"0\"));\n+        assertEquals(5, ArrayUtils.lastIndexOf(array, \"0\"));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, \"1\"));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, \"2\"));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, \"3\"));\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, null));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, \"notInArray\"));\n+    }\n+\n+    public void testLastIndexOfWithStartIndex() {\n+        Object[] array = new Object[] { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n+        assertEquals(-1, ArrayUtils.lastIndexOf(null, null, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(null, \"0\", 2));\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, \"0\", 2));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, \"1\", 2));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, \"2\", 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, \"3\", 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, \"3\", -1));\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, null, 5));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, null, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, \"notInArray\", 5));\n+        \n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, null, -1));\n+        assertEquals(5, ArrayUtils.lastIndexOf(array, \"0\", 88));\n+    }\n+\n+    public void testContains() {\n+        Object[] array = new Object[] { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n+        assertEquals(false, ArrayUtils.contains(null, null));\n+        assertEquals(false, ArrayUtils.contains(null, \"1\"));\n+        assertEquals(true, ArrayUtils.contains(array, \"0\"));\n+        assertEquals(true, ArrayUtils.contains(array, \"1\"));\n+        assertEquals(true, ArrayUtils.contains(array, \"2\"));\n+        assertEquals(true, ArrayUtils.contains(array, \"3\"));\n+        assertEquals(true, ArrayUtils.contains(array, null));\n+        assertEquals(false, ArrayUtils.contains(array, \"notInArray\"));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIndexOfLong() {\n+        long[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, 0));\n+        array = new long[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.indexOf(array, 0));\n+        assertEquals(1, ArrayUtils.indexOf(array, 1));\n+        assertEquals(2, ArrayUtils.indexOf(array, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, 3));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 99));\n+    }\n+\n+    public void testIndexOfLongWithStartIndex() {\n+        long[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, 0, 2));\n+        array = new long[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.indexOf(array, 0, 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 1, 2));\n+        assertEquals(2, ArrayUtils.indexOf(array, 2, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, 3, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, 3, -1));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 99, 0));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 0, 6));\n+    }\n+\n+    public void testLastIndexOfLong() {\n+        long[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 0));\n+        array = new long[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, 0));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, 1));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, 2));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, 3));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 99));\n+    }\n+\n+    public void testLastIndexOfLongWithStartIndex() {\n+        long[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 0, 2));\n+        array = new long[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, 0, 2));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, 1, 2));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, 2, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, -1));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 99, 4));\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, 0, 88));\n+    }\n+\n+    public void testContainsLong() {\n+        long[] array = null;\n+        assertEquals(false, ArrayUtils.contains(array, 1));\n+        array = new long[] { 0, 1, 2, 3, 0 };\n+        assertEquals(true, ArrayUtils.contains(array, 0));\n+        assertEquals(true, ArrayUtils.contains(array, 1));\n+        assertEquals(true, ArrayUtils.contains(array, 2));\n+        assertEquals(true, ArrayUtils.contains(array, 3));\n+        assertEquals(false, ArrayUtils.contains(array, 99));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIndexOfInt() {\n+        int[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, 0));\n+        array = new int[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.indexOf(array, 0));\n+        assertEquals(1, ArrayUtils.indexOf(array, 1));\n+        assertEquals(2, ArrayUtils.indexOf(array, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, 3));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 99));\n+    }\n+\n+    public void testIndexOfIntWithStartIndex() {\n+        int[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, 0, 2));\n+        array = new int[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.indexOf(array, 0, 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 1, 2));\n+        assertEquals(2, ArrayUtils.indexOf(array, 2, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, 3, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, 3, -1));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 99, 0));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 0, 6));\n+    }\n+\n+    public void testLastIndexOfInt() {\n+        int[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 0));\n+        array = new int[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, 0));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, 1));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, 2));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, 3));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 99));\n+    }\n+\n+    public void testLastIndexOfIntWithStartIndex() {\n+        int[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 0, 2));\n+        array = new int[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, 0, 2));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, 1, 2));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, 2, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, -1));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 99));\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, 0, 88));\n+    }\n+\n+    public void testContainsInt() {\n+        int[] array = null;\n+        assertEquals(false, ArrayUtils.contains(array, 1));\n+        array = new int[] { 0, 1, 2, 3, 0 };\n+        assertEquals(true, ArrayUtils.contains(array, 0));\n+        assertEquals(true, ArrayUtils.contains(array, 1));\n+        assertEquals(true, ArrayUtils.contains(array, 2));\n+        assertEquals(true, ArrayUtils.contains(array, 3));\n+        assertEquals(false, ArrayUtils.contains(array, 99));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIndexOfShort() {\n+        short[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, (short) 0));\n+        array = new short[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.indexOf(array, (short) 0));\n+        assertEquals(1, ArrayUtils.indexOf(array, (short) 1));\n+        assertEquals(2, ArrayUtils.indexOf(array, (short) 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (short) 3));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (short) 99));\n+    }\n+\n+    public void testIndexOfShortWithStartIndex() {\n+        short[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, (short) 0, 2));\n+        array = new short[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.indexOf(array, (short) 0, 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (short) 1, 2));\n+        assertEquals(2, ArrayUtils.indexOf(array, (short) 2, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (short) 3, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (short) 3, -1));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (short) 99, 0));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (short) 0, 6));\n+    }\n+\n+    public void testLastIndexOfShort() {\n+        short[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0));\n+        array = new short[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, (short) 3));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99));\n+    }\n+\n+    public void testLastIndexOfShortWithStartIndex() {\n+        short[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0, 2));\n+        array = new short[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, (short) 0, 2));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1, 2));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, -1));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99));\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0, 88));\n+    }\n+\n+    public void testContainsShort() {\n+        short[] array = null;\n+        assertEquals(false, ArrayUtils.contains(array, (short) 1));\n+        array = new short[] { 0, 1, 2, 3, 0 };\n+        assertEquals(true, ArrayUtils.contains(array, (short) 0));\n+        assertEquals(true, ArrayUtils.contains(array, (short) 1));\n+        assertEquals(true, ArrayUtils.contains(array, (short) 2));\n+        assertEquals(true, ArrayUtils.contains(array, (short) 3));\n+        assertEquals(false, ArrayUtils.contains(array, (short) 99));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIndexOfChar() {\n+        char[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, 'a'));\n+        array = new char[] { 'a', 'b', 'c', 'd', 'a' };\n+        assertEquals(0, ArrayUtils.indexOf(array, 'a'));\n+        assertEquals(1, ArrayUtils.indexOf(array, 'b'));\n+        assertEquals(2, ArrayUtils.indexOf(array, 'c'));\n+        assertEquals(3, ArrayUtils.indexOf(array, 'd'));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 'e'));\n+    }\n+\n+    public void testIndexOfCharWithStartIndex() {\n+        char[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, 'a', 2));\n+        array = new char[] { 'a', 'b', 'c', 'd', 'a' };\n+        assertEquals(4, ArrayUtils.indexOf(array, 'a', 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 'b', 2));\n+        assertEquals(2, ArrayUtils.indexOf(array, 'c', 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, 'd', 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, 'd', -1));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 'e', 0));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 'a', 6));\n+    }\n+\n+    public void testLastIndexOfChar() {\n+        char[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 'a'));\n+        array = new char[] { 'a', 'b', 'c', 'd', 'a' };\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, 'a'));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, 'b'));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, 'c'));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, 'd'));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 'e'));\n+    }\n+\n+    public void testLastIndexOfCharWithStartIndex() {\n+        char[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 'a', 2));\n+        array = new char[] { 'a', 'b', 'c', 'd', 'a' };\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, 'a', 2));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, 'b', 2));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, 'c', 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 'd', 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 'd', -1));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 'e'));\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, 'a', 88));\n+    }\n+\n+    public void testContainsChar() {\n+        char[] array = null;\n+        assertEquals(false, ArrayUtils.contains(array, 'b'));\n+        array = new char[] { 'a', 'b', 'c', 'd', 'a' };\n+        assertEquals(true, ArrayUtils.contains(array, 'a'));\n+        assertEquals(true, ArrayUtils.contains(array, 'b'));\n+        assertEquals(true, ArrayUtils.contains(array, 'c'));\n+        assertEquals(true, ArrayUtils.contains(array, 'd'));\n+        assertEquals(false, ArrayUtils.contains(array, 'e'));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIndexOfByte() {\n+        byte[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, (byte) 0));\n+        array = new byte[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.indexOf(array, (byte) 0));\n+        assertEquals(1, ArrayUtils.indexOf(array, (byte) 1));\n+        assertEquals(2, ArrayUtils.indexOf(array, (byte) 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (byte) 3));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (byte) 99));\n+    }\n+\n+    public void testIndexOfByteWithStartIndex() {\n+        byte[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, (byte) 0, 2));\n+        array = new byte[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.indexOf(array, (byte) 0, 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (byte) 1, 2));\n+        assertEquals(2, ArrayUtils.indexOf(array, (byte) 2, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (byte) 3, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (byte) 3, -1));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (byte) 99, 0));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (byte) 0, 6));\n+    }\n+\n+    public void testLastIndexOfByte() {\n+        byte[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 0));\n+        array = new byte[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, (byte) 0));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, (byte) 1));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, (byte) 2));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, (byte) 3));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 99));\n+    }\n+\n+    public void testLastIndexOfByteWithStartIndex() {\n+        byte[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 0, 2));\n+        array = new byte[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, (byte) 0, 2));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, (byte) 1, 2));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, (byte) 2, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 3, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 3, -1));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 99));\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, (byte) 0, 88));\n+    }\n+\n+    public void testContainsByte() {\n+        byte[] array = null;\n+        assertEquals(false, ArrayUtils.contains(array, (byte) 1));\n+        array = new byte[] { 0, 1, 2, 3, 0 };\n+        assertEquals(true, ArrayUtils.contains(array, (byte) 0));\n+        assertEquals(true, ArrayUtils.contains(array, (byte) 1));\n+        assertEquals(true, ArrayUtils.contains(array, (byte) 2));\n+        assertEquals(true, ArrayUtils.contains(array, (byte) 3));\n+        assertEquals(false, ArrayUtils.contains(array, (byte) 99));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"cast\")\n+    public void testIndexOfDouble() {\n+        double[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 0));\n+        array = new double[0];\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 0));\n+        array = new double[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.indexOf(array, (double) 0));\n+        assertEquals(1, ArrayUtils.indexOf(array, (double) 1));\n+        assertEquals(2, ArrayUtils.indexOf(array, (double) 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (double) 3));\n+        assertEquals(3, ArrayUtils.indexOf(array, (double) 3, -1));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 99));\n+    }\n+\n+    @SuppressWarnings(\"cast\")\n+    public void testIndexOfDoubleTolerance() {\n+        double[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, (double) 0));\n+        array = new double[0];\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, (double) 0));\n+        array = new double[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.indexOf(array, (double) 0, (double) 0.3));\n+        assertEquals(2, ArrayUtils.indexOf(array, (double) 2.2, (double) 0.35));\n+        assertEquals(3, ArrayUtils.indexOf(array, (double) 4.15, (double) 2.0));\n+        assertEquals(1, ArrayUtils.indexOf(array, (double) 1.00001324, (double) 0.0001));\n+    }\n+\n+    @SuppressWarnings(\"cast\")\n+    public void testIndexOfDoubleWithStartIndex() {\n+        double[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 2));\n+        array = new double[0];\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 2));\n+        array = new double[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.indexOf(array, (double) 0, 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 1, 2));\n+        assertEquals(2, ArrayUtils.indexOf(array, (double) 2, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (double) 3, 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 99, 0));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 6));\n+    }\n+    \n+    @SuppressWarnings(\"cast\")\n+    public void testIndexOfDoubleWithStartIndexTolerance() {\n+        double[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 2, (double) 0));\n+        array = new double[0];\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 2, (double) 0));\n+        array = new double[] { 0, 1, 2, 3, 0 };\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 99, (double) 0.3));\n+        assertEquals(0, ArrayUtils.indexOf(array, (double) 0, 0, (double) 0.3));\n+        assertEquals(4, ArrayUtils.indexOf(array, (double) 0, 3, (double) 0.3));\n+        assertEquals(2, ArrayUtils.indexOf(array, (double) 2.2, 0, (double) 0.35));\n+        assertEquals(3, ArrayUtils.indexOf(array, (double) 4.15, 0, (double) 2.0));\n+        assertEquals(1, ArrayUtils.indexOf(array, (double) 1.00001324, 0, (double) 0.0001));\n+        assertEquals(3, ArrayUtils.indexOf(array, (double) 4.15, -1, (double) 2.0));\n+        assertEquals(1, ArrayUtils.indexOf(array, (double) 1.00001324, -300, (double) 0.0001));\n+    }\n+\n+    @SuppressWarnings(\"cast\")\n+    public void testLastIndexOfDouble() {\n+        double[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0));\n+        array = new double[0];\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0));\n+        array = new double[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, (double) 0));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, (double) 1));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, (double) 2));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, (double) 3));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 99));\n+    }\n+\n+    @SuppressWarnings(\"cast\")\n+    public void testLastIndexOfDoubleTolerance() {\n+        double[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, (double) 0));\n+        array = new double[0];\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, (double) 0));\n+        array = new double[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, (double) 0, (double) 0.3));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, (double) 2.2, (double) 0.35));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, (double) 4.15, (double) 2.0));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, (double) 1.00001324, (double) 0.0001));\n+    }\n+\n+    @SuppressWarnings(\"cast\")\n+    public void testLastIndexOfDoubleWithStartIndex() {\n+        double[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, 2));\n+        array = new double[0];\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, 2));\n+        array = new double[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, (double) 0, 2));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, (double) 1, 2));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, (double) 2, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 3, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 3, -1));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 99));\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, (double) 0, 88));\n+    }\n+\n+    @SuppressWarnings(\"cast\")\n+    public void testLastIndexOfDoubleWithStartIndexTolerance() {\n+        double[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, 2, (double) 0));\n+        array = new double[0];\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, 2, (double) 0));\n+        array = new double[] { (double) 3 };\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 1, 0, (double) 0));\n+        array = new double[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, (double) 0, 99, (double) 0.3));\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, (double) 0, 3, (double) 0.3));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, (double) 2.2, 3, (double) 0.35));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, (double) 4.15, array.length, (double) 2.0));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, (double) 1.00001324, array.length, (double) 0.0001));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 4.15, -200, (double) 2.0));\n+    }\n+\n+    @SuppressWarnings(\"cast\")\n+    public void testContainsDouble() {\n+        double[] array = null;\n+        assertEquals(false, ArrayUtils.contains(array, (double) 1));\n+        array = new double[] { 0, 1, 2, 3, 0 };\n+        assertEquals(true, ArrayUtils.contains(array, (double) 0));\n+        assertEquals(true, ArrayUtils.contains(array, (double) 1));\n+        assertEquals(true, ArrayUtils.contains(array, (double) 2));\n+        assertEquals(true, ArrayUtils.contains(array, (double) 3));\n+        assertEquals(false, ArrayUtils.contains(array, (double) 99));\n+    }\n+\n+    @SuppressWarnings(\"cast\")\n+    public void testContainsDoubleTolerance() {\n+        double[] array = null;\n+        assertEquals(false, ArrayUtils.contains(array, (double) 1, (double) 0));\n+        array = new double[] { 0, 1, 2, 3, 0 };\n+        assertEquals(false, ArrayUtils.contains(array, (double) 4.0, (double) 0.33));\n+        assertEquals(false, ArrayUtils.contains(array, (double) 2.5, (double) 0.49));\n+        assertEquals(true, ArrayUtils.contains(array, (double) 2.5, (double) 0.50));\n+        assertEquals(true, ArrayUtils.contains(array, (double) 2.5, (double) 0.51));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"cast\")\n+    public void testIndexOfFloat() {\n+        float[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, (float) 0));\n+        array = new float[0];\n+        assertEquals(-1, ArrayUtils.indexOf(array, (float) 0));\n+        array = new float[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.indexOf(array, (float) 0));\n+        assertEquals(1, ArrayUtils.indexOf(array, (float) 1));\n+        assertEquals(2, ArrayUtils.indexOf(array, (float) 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (float) 3));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (float) 99));\n+    }\n+\n+    @SuppressWarnings(\"cast\")\n+    public void testIndexOfFloatWithStartIndex() {\n+        float[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, (float) 0, 2));\n+        array = new float[0];\n+        assertEquals(-1, ArrayUtils.indexOf(array, (float) 0, 2));\n+        array = new float[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.indexOf(array, (float) 0, 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (float) 1, 2));\n+        assertEquals(2, ArrayUtils.indexOf(array, (float) 2, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (float) 3, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (float) 3, -1));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (float) 99, 0));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (float) 0, 6));\n+    }\n+\n+    @SuppressWarnings(\"cast\")\n+    public void testLastIndexOfFloat() {\n+        float[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 0));\n+        array = new float[0];\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 0));\n+        array = new float[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, (float) 0));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, (float) 1));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, (float) 2));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, (float) 3));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 99));\n+    }\n+\n+    @SuppressWarnings(\"cast\")\n+    public void testLastIndexOfFloatWithStartIndex() {\n+        float[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 0, 2));\n+        array = new float[0];\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 0, 2));\n+        array = new float[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, (float) 0, 2));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, (float) 1, 2));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, (float) 2, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 3, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 3, -1));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 99));\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, (float) 0, 88));\n+    }\n+\n+    @SuppressWarnings(\"cast\")\n+    public void testContainsFloat() {\n+        float[] array = null;\n+        assertEquals(false, ArrayUtils.contains(array, (float) 1));\n+        array = new float[] { 0, 1, 2, 3, 0 };\n+        assertEquals(true, ArrayUtils.contains(array, (float) 0));\n+        assertEquals(true, ArrayUtils.contains(array, (float) 1));\n+        assertEquals(true, ArrayUtils.contains(array, (float) 2));\n+        assertEquals(true, ArrayUtils.contains(array, (float) 3));\n+        assertEquals(false, ArrayUtils.contains(array, (float) 99));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIndexOfBoolean() {\n+        boolean[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, true));\n+        array = new boolean[0];\n+        assertEquals(-1, ArrayUtils.indexOf(array, true));\n+        array = new boolean[] { true, false, true };\n+        assertEquals(0, ArrayUtils.indexOf(array, true));\n+        assertEquals(1, ArrayUtils.indexOf(array, false));\n+        array = new boolean[] { true, true };\n+        assertEquals(-1, ArrayUtils.indexOf(array, false));\n+    }\n+\n+    public void testIndexOfBooleanWithStartIndex() {\n+        boolean[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, true, 2));\n+        array = new boolean[0];\n+        assertEquals(-1, ArrayUtils.indexOf(array, true, 2));\n+        array = new boolean[] { true, false, true };\n+        assertEquals(2, ArrayUtils.indexOf(array, true, 1));\n+        assertEquals(-1, ArrayUtils.indexOf(array, false, 2));\n+        assertEquals(1, ArrayUtils.indexOf(array, false, 0));\n+        assertEquals(1, ArrayUtils.indexOf(array, false, -1));\n+        array = new boolean[] { true, true };\n+        assertEquals(-1, ArrayUtils.indexOf(array, false, 0));\n+        assertEquals(-1, ArrayUtils.indexOf(array, false, -1));\n+    }\n+\n+    public void testLastIndexOfBoolean() {\n+        boolean[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, true));\n+        array = new boolean[0];\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, true));\n+        array = new boolean[] { true, false, true };\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, true));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, false));\n+        array = new boolean[] { true, true };\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, false));\n+    }\n+\n+    public void testLastIndexOfBooleanWithStartIndex() {\n+        boolean[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2));\n+        array = new boolean[0];\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2));\n+        array = new boolean[] { true, false, true };\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, true, 2));\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, true, 1));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, false, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, true, -1));\n+        array = new boolean[] { true, true };\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, false, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, true, -1));\n+    }\n+\n+    public void testContainsBoolean() {\n+        boolean[] array = null;\n+        assertEquals(false, ArrayUtils.contains(array, true));\n+        array = new boolean[] { true, false, true };\n+        assertEquals(true, ArrayUtils.contains(array, true));\n+        assertEquals(true, ArrayUtils.contains(array, false));\n+        array = new boolean[] { true, true };\n+        assertEquals(true, ArrayUtils.contains(array, true));\n+        assertEquals(false, ArrayUtils.contains(array, false));\n+    }\n+    \n+    // testToPrimitive/Object for boolean\n+    //  -----------------------------------------------------------------------\n+    public void testToPrimitive_boolean() {\n+        final Boolean[] b = null;\n+        assertEquals(null, ArrayUtils.toPrimitive(b));\n+        assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.toPrimitive(new Boolean[0]));\n+        assertTrue(Arrays.equals(\n+            new boolean[] {true, false, true},\n+            ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, Boolean.FALSE, Boolean.TRUE}))\n+        );\n+\n+        try {\n+            ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, null});\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testToPrimitive_boolean_boolean() {\n+        assertEquals(null, ArrayUtils.toPrimitive(null, false));\n+        assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.toPrimitive(new Boolean[0], false));\n+        assertTrue(Arrays.equals(\n+            new boolean[] {true, false, true},\n+            ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, Boolean.FALSE, Boolean.TRUE}, false))\n+        );\n+        assertTrue(Arrays.equals(\n+            new boolean[] {true, false, false},\n+            ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, null, Boolean.FALSE}, false))\n+        );\n+        assertTrue(Arrays.equals(\n+            new boolean[] {true, true, false},\n+            ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, null, Boolean.FALSE}, true))\n+        );\n+    }\n+\n+    public void testToObject_boolean() {\n+        final boolean[] b = null;\n+        assertEquals(null, ArrayUtils.toObject(b));\n+        assertSame(ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY, ArrayUtils.toObject(new boolean[0]));\n+        assertTrue(Arrays.equals(\n+            new Boolean[] {Boolean.TRUE, Boolean.FALSE, Boolean.TRUE},\n+            ArrayUtils.toObject(new boolean[] {true, false, true}))\n+        );\n+    }\n+\n+    // testToPrimitive/Object for byte\n+    //  -----------------------------------------------------------------------\n+    public void testToPrimitive_char() {\n+        final Character[] b = null;\n+        assertEquals(null, ArrayUtils.toPrimitive(b));\n+        \n+        assertSame(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.toPrimitive(new Character[0]));\n+        \n+        assertTrue(Arrays.equals(\n+            new char[] {Character.MIN_VALUE, Character.MAX_VALUE, '0'},\n+            ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE), \n+                new Character(Character.MAX_VALUE), new Character('0')}))\n+        );\n+\n+        try {\n+            ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE), null});\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testToPrimitive_char_char() {\n+        final Character[] b = null;\n+        assertEquals(null, ArrayUtils.toPrimitive(b, Character.MIN_VALUE));\n+        \n+        assertSame(ArrayUtils.EMPTY_CHAR_ARRAY, \n+            ArrayUtils.toPrimitive(new Character[0], (char)0));\n+        \n+        assertTrue(Arrays.equals(\n+            new char[] {Character.MIN_VALUE, Character.MAX_VALUE, '0'},\n+            ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE), \n+                new Character(Character.MAX_VALUE), new Character('0')}, \n+                Character.MIN_VALUE))\n+        );\n+        \n+        assertTrue(Arrays.equals(\n+            new char[] {Character.MIN_VALUE, Character.MAX_VALUE, '0'},\n+            ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE), null, \n+                new Character('0')}, Character.MAX_VALUE))\n+        );\n+    }\n+\n+    public void testToObject_char() {\n+        final char[] b = null;\n+        assertEquals(null, ArrayUtils.toObject(b));\n+        \n+        assertSame(ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY, \n+            ArrayUtils.toObject(new char[0]));\n+        \n+        assertTrue(Arrays.equals(\n+            new Character[] {new Character(Character.MIN_VALUE), \n+                new Character(Character.MAX_VALUE), new Character('0')},\n+                ArrayUtils.toObject(new char[] {Character.MIN_VALUE, Character.MAX_VALUE, \n+                '0'} ))\n+        );\n+    }\n+    \n+    // testToPrimitive/Object for byte\n+    //  -----------------------------------------------------------------------\n+    public void testToPrimitive_byte() {\n+        final Byte[] b = null;\n+        assertEquals(null, ArrayUtils.toPrimitive(b));\n+        \n+        assertSame(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.toPrimitive(new Byte[0]));\n+        \n+        assertTrue(Arrays.equals(\n+            new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE, (byte)9999999},\n+            ArrayUtils.toPrimitive(new Byte[] {Byte.valueOf(Byte.MIN_VALUE), \n+                Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte)9999999)}))\n+        );\n+\n+        try {\n+            ArrayUtils.toPrimitive(new Byte[] {Byte.valueOf(Byte.MIN_VALUE), null});\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testToPrimitive_byte_byte() {\n+        final Byte[] b = null;\n+        assertEquals(null, ArrayUtils.toPrimitive(b, Byte.MIN_VALUE));\n+        \n+        assertSame(ArrayUtils.EMPTY_BYTE_ARRAY, \n+            ArrayUtils.toPrimitive(new Byte[0], (byte)1));\n+        \n+        assertTrue(Arrays.equals(\n+            new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE, (byte)9999999},\n+            ArrayUtils.toPrimitive(new Byte[] {Byte.valueOf(Byte.MIN_VALUE), \n+                Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte)9999999)}, \n+                Byte.MIN_VALUE))\n+        );\n+        \n+        assertTrue(Arrays.equals(\n+            new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE, (byte)9999999},\n+            ArrayUtils.toPrimitive(new Byte[] {Byte.valueOf(Byte.MIN_VALUE), null, \n+                Byte.valueOf((byte)9999999)}, Byte.MAX_VALUE))\n+        );\n+    }\n+\n+    public void testToObject_byte() {\n+        final byte[] b = null;\n+        assertEquals(null, ArrayUtils.toObject(b));\n+        \n+        assertSame(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, \n+            ArrayUtils.toObject(new byte[0]));\n+        \n+        assertTrue(Arrays.equals(\n+            new Byte[] {Byte.valueOf(Byte.MIN_VALUE), \n+                Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte)9999999)},\n+                ArrayUtils.toObject(new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE, \n+                (byte)9999999}))\n+        );\n+    }\n+\n+    // testToPrimitive/Object for short\n+    //  -----------------------------------------------------------------------\n+    public void testToPrimitive_short() {\n+        final Short[] b = null;\n+        assertEquals(null, ArrayUtils.toPrimitive(b));\n+        \n+        assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.toPrimitive(new Short[0]));\n+        \n+        assertTrue(Arrays.equals(\n+            new short[] {Short.MIN_VALUE, Short.MAX_VALUE, (short)9999999},\n+            ArrayUtils.toPrimitive(new Short[] {new Short(Short.MIN_VALUE), \n+                new Short(Short.MAX_VALUE), new Short((short)9999999)}))\n+        );\n+\n+        try {\n+            ArrayUtils.toPrimitive(new Short[] {new Short(Short.MIN_VALUE), null});\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testToPrimitive_short_short() {\n+        final Short[] s = null;\n+        assertEquals(null, ArrayUtils.toPrimitive(s, Short.MIN_VALUE));\n+        \n+        assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.toPrimitive(new Short[0], \n+        Short.MIN_VALUE));\n+        \n+        assertTrue(Arrays.equals(\n+            new short[] {Short.MIN_VALUE, Short.MAX_VALUE, (short)9999999},\n+            ArrayUtils.toPrimitive(new Short[] {new Short(Short.MIN_VALUE), \n+                new Short(Short.MAX_VALUE), new Short((short)9999999)}, Short.MIN_VALUE))\n+        );\n+        \n+        assertTrue(Arrays.equals(\n+            new short[] {Short.MIN_VALUE, Short.MAX_VALUE, (short)9999999},\n+            ArrayUtils.toPrimitive(new Short[] {new Short(Short.MIN_VALUE), null, \n+                new Short((short)9999999)}, Short.MAX_VALUE))\n+        );\n+    }\n+\n+    public void testToObject_short() {\n+        final short[] b = null;\n+        assertEquals(null, ArrayUtils.toObject(b));\n+        \n+        assertSame(ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY, \n+        ArrayUtils.toObject(new short[0]));\n+        \n+        assertTrue(Arrays.equals(\n+            new Short[] {new Short(Short.MIN_VALUE), new Short(Short.MAX_VALUE), \n+                new Short((short)9999999)},\n+            ArrayUtils.toObject(new short[] {Short.MIN_VALUE, Short.MAX_VALUE, \n+                (short)9999999}))\n+        );\n+    }\n+\n+    //  testToPrimitive/Object for int\n+    //  -----------------------------------------------------------------------\n+     public void testToPrimitive_int() {\n+         final Integer[] b = null;\n+         assertEquals(null, ArrayUtils.toPrimitive(b));\n+         assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.toPrimitive(new Integer[0]));\n+         assertTrue(Arrays.equals(\n+             new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Integer[] {new Integer(Integer.MIN_VALUE), \n+                 new Integer(Integer.MAX_VALUE), new Integer(9999999)}))\n+         );\n+\n+         try {\n+             ArrayUtils.toPrimitive(new Integer[] {new Integer(Integer.MIN_VALUE), null});\n+             fail();\n+         } catch (NullPointerException ex) {}\n+     }\n+\n+     public void testToPrimitive_int_int() {\n+         final Long[] l = null;\n+         assertEquals(null, ArrayUtils.toPrimitive(l, Integer.MIN_VALUE));\n+         assertSame(ArrayUtils.EMPTY_INT_ARRAY, \n+         ArrayUtils.toPrimitive(new Integer[0], 1));\n+         assertTrue(Arrays.equals(\n+             new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Integer[] {new Integer(Integer.MIN_VALUE), \n+                 new Integer(Integer.MAX_VALUE), new Integer(9999999)},1)));\n+         assertTrue(Arrays.equals(\n+             new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Integer[] {new Integer(Integer.MIN_VALUE), \n+                 null, new Integer(9999999)}, Integer.MAX_VALUE))\n+         );\n+     }\n+     \n+    public void testToPrimitive_intNull() {\n+        Integer[] iArray = null;\n+        assertEquals(null, ArrayUtils.toPrimitive(iArray, Integer.MIN_VALUE));\n+    }\n+\n+    public void testToObject_int() {\n+        final int[] b = null;\n+        assertEquals(null, ArrayUtils.toObject(b));\n+    \n+        assertSame(\n+            ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY,\n+            ArrayUtils.toObject(new int[0]));\n+    \n+        assertTrue(\n+            Arrays.equals(\n+                new Integer[] {\n+                    new Integer(Integer.MIN_VALUE),\n+                    new Integer(Integer.MAX_VALUE),\n+                    new Integer(9999999)},\n+            ArrayUtils.toObject(\n+                new int[] { Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999 })));\n+    }\n+\n+    //  testToPrimitive/Object for long\n+    //  -----------------------------------------------------------------------\n+     public void testToPrimitive_long() {\n+         final Long[] b = null;\n+         assertEquals(null, ArrayUtils.toPrimitive(b));\n+         \n+         assertSame(ArrayUtils.EMPTY_LONG_ARRAY, \n+            ArrayUtils.toPrimitive(new Long[0]));\n+         \n+         assertTrue(Arrays.equals(\n+             new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Long[] {new Long(Long.MIN_VALUE), \n+                 new Long(Long.MAX_VALUE), new Long(9999999)}))\n+         );\n+\n+         try {\n+             ArrayUtils.toPrimitive(new Long[] {new Long(Long.MIN_VALUE), null});\n+             fail();\n+         } catch (NullPointerException ex) {}\n+     }\n+\n+     public void testToPrimitive_long_long() {\n+         final Long[] l = null;\n+         assertEquals(null, ArrayUtils.toPrimitive(l, Long.MIN_VALUE));\n+         \n+         assertSame(ArrayUtils.EMPTY_LONG_ARRAY, \n+         ArrayUtils.toPrimitive(new Long[0], 1));\n+         \n+         assertTrue(Arrays.equals(\n+             new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Long[] {new Long(Long.MIN_VALUE), \n+                 new Long(Long.MAX_VALUE), new Long(9999999)},1)));\n+         \n+         assertTrue(Arrays.equals(\n+             new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Long[] {new Long(Long.MIN_VALUE), \n+                 null, new Long(9999999)}, Long.MAX_VALUE))\n+         );\n+     }\n+     \n+    public void testToObject_long() {\n+        final long[] b = null;\n+        assertEquals(null, ArrayUtils.toObject(b));\n+    \n+        assertSame(\n+            ArrayUtils.EMPTY_LONG_OBJECT_ARRAY,\n+            ArrayUtils.toObject(new long[0]));\n+    \n+        assertTrue(\n+            Arrays.equals(\n+                new Long[] {\n+                    new Long(Long.MIN_VALUE),\n+                    new Long(Long.MAX_VALUE),\n+                    new Long(9999999)},\n+            ArrayUtils.toObject(\n+                new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 })));\n+    }\n+\n+    //  testToPrimitive/Object for float\n+    //  -----------------------------------------------------------------------\n+     public void testToPrimitive_float() {\n+         final Float[] b = null;\n+         assertEquals(null, ArrayUtils.toPrimitive(b));\n+         \n+         assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY, \n+            ArrayUtils.toPrimitive(new Float[0]));\n+         \n+         assertTrue(Arrays.equals(\n+             new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Float[] {new Float(Float.MIN_VALUE), \n+                 new Float(Float.MAX_VALUE), new Float(9999999)}))\n+         );\n+\n+         try {\n+             ArrayUtils.toPrimitive(new Float[] {new Float(Float.MIN_VALUE), null});\n+             fail();\n+         } catch (NullPointerException ex) {}\n+     }\n+\n+     public void testToPrimitive_float_float() {\n+         final Float[] l = null;\n+         assertEquals(null, ArrayUtils.toPrimitive(l, Float.MIN_VALUE));\n+         \n+         assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY, \n+         ArrayUtils.toPrimitive(new Float[0], 1));\n+         \n+         assertTrue(Arrays.equals(\n+             new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Float[] {new Float(Float.MIN_VALUE), \n+                 new Float(Float.MAX_VALUE), new Float(9999999)},1)));\n+         \n+         assertTrue(Arrays.equals(\n+             new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Float[] {new Float(Float.MIN_VALUE), \n+                 null, new Float(9999999)}, Float.MAX_VALUE))\n+         );\n+     }\n+     \n+    public void testToObject_float() {\n+        final float[] b = null;\n+        assertEquals(null, ArrayUtils.toObject(b));\n+    \n+        assertSame(\n+            ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY,\n+            ArrayUtils.toObject(new float[0]));\n+    \n+        assertTrue(\n+            Arrays.equals(\n+                new Float[] {\n+                    new Float(Float.MIN_VALUE),\n+                    new Float(Float.MAX_VALUE),\n+                    new Float(9999999)},\n+            ArrayUtils.toObject(\n+                new float[] { Float.MIN_VALUE, Float.MAX_VALUE, 9999999 })));\n+    }\n+\n+    //  testToPrimitive/Object for double\n+    //  -----------------------------------------------------------------------\n+     public void testToPrimitive_double() {\n+         final Double[] b = null;\n+         assertEquals(null, ArrayUtils.toPrimitive(b));\n+         \n+         assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, \n+            ArrayUtils.toPrimitive(new Double[0]));\n+         \n+         assertTrue(Arrays.equals(\n+             new double[] {Double.MIN_VALUE, Double.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Double[] {new Double(Double.MIN_VALUE), \n+                 new Double(Double.MAX_VALUE), new Double(9999999)}))\n+         );\n+\n+         try {\n+             ArrayUtils.toPrimitive(new Float[] {new Float(Float.MIN_VALUE), null});\n+             fail();\n+         } catch (NullPointerException ex) {}\n+     }\n+\n+     public void testToPrimitive_double_double() {\n+         final Double[] l = null;\n+         assertEquals(null, ArrayUtils.toPrimitive(l, Double.MIN_VALUE));\n+         \n+         assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, \n+         ArrayUtils.toPrimitive(new Double[0], 1));\n+         \n+         assertTrue(Arrays.equals(\n+             new double[] {Double.MIN_VALUE, Double.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Double[] {new Double(Double.MIN_VALUE), \n+                 new Double(Double.MAX_VALUE), new Double(9999999)},1)));\n+         \n+         assertTrue(Arrays.equals(\n+             new double[] {Double.MIN_VALUE, Double.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Double[] {new Double(Double.MIN_VALUE), \n+                 null, new Double(9999999)}, Double.MAX_VALUE))\n+         );\n+     }\n+     \n+    public void testToObject_double() {\n+        final double[] b = null;\n+        assertEquals(null, ArrayUtils.toObject(b));\n+    \n+        assertSame(\n+            ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY,\n+            ArrayUtils.toObject(new double[0]));\n+    \n+        assertTrue(\n+            Arrays.equals(\n+                new Double[] {\n+                    new Double(Double.MIN_VALUE),\n+                    new Double(Double.MAX_VALUE),\n+                    new Double(9999999)},\n+            ArrayUtils.toObject(\n+                new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 })));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test for {@link ArrayUtils#isEmpty(java.lang.Object[])}.\n+     */\n+    public void testIsEmptyObject() {\n+        Object[] emptyArray = new Object[] {};\n+        Object[] notEmptyArray = new Object[] { new String(\"Value\") };\n+        assertEquals(true, ArrayUtils.isEmpty((Object[])null));\n+        assertEquals(true, ArrayUtils.isEmpty(emptyArray));\n+        assertEquals(false, ArrayUtils.isEmpty(notEmptyArray));\n+    }\n+\n+    /**\n+     * Tests for {@link ArrayUtils#isEmpty(long[])},\n+     * {@link ArrayUtils#isEmpty(int[])},\n+     * {@link ArrayUtils#isEmpty(short[])},\n+     * {@link ArrayUtils#isEmpty(char[])},\n+     * {@link ArrayUtils#isEmpty(byte[])},\n+     * {@link ArrayUtils#isEmpty(double[])},\n+     * {@link ArrayUtils#isEmpty(float[])} and\n+     * {@link ArrayUtils#isEmpty(boolean[])}.\n+     */\n+    public void testIsEmptyPrimitives() {\n+        long[] emptyLongArray = new long[] {};\n+        long[] notEmptyLongArray = new long[] { 1L };\n+        assertEquals(true, ArrayUtils.isEmpty((long[])null));\n+        assertEquals(true, ArrayUtils.isEmpty(emptyLongArray));\n+        assertEquals(false, ArrayUtils.isEmpty(notEmptyLongArray));\n+\n+        int[] emptyIntArray = new int[] {};\n+        int[] notEmptyIntArray = new int[] { 1 };\n+        assertEquals(true, ArrayUtils.isEmpty((int[])null));\n+        assertEquals(true, ArrayUtils.isEmpty(emptyIntArray));\n+        assertEquals(false, ArrayUtils.isEmpty(notEmptyIntArray));\n+\n+        short[] emptyShortArray = new short[] {};\n+        short[] notEmptyShortArray = new short[] { 1 };\n+        assertEquals(true, ArrayUtils.isEmpty((short[])null));\n+        assertEquals(true, ArrayUtils.isEmpty(emptyShortArray));\n+        assertEquals(false, ArrayUtils.isEmpty(notEmptyShortArray));\n+\n+        char[] emptyCharArray = new char[] {};\n+        char[] notEmptyCharArray = new char[] { 1 };\n+        assertEquals(true, ArrayUtils.isEmpty((char[])null));\n+        assertEquals(true, ArrayUtils.isEmpty(emptyCharArray));\n+        assertEquals(false, ArrayUtils.isEmpty(notEmptyCharArray));\n+\n+        byte[] emptyByteArray = new byte[] {};\n+        byte[] notEmptyByteArray = new byte[] { 1 };\n+        assertEquals(true, ArrayUtils.isEmpty((byte[])null));\n+        assertEquals(true, ArrayUtils.isEmpty(emptyByteArray));\n+        assertEquals(false, ArrayUtils.isEmpty(notEmptyByteArray));\n+\n+        double[] emptyDoubleArray = new double[] {};\n+        double[] notEmptyDoubleArray = new double[] { 1.0 };\n+        assertEquals(true, ArrayUtils.isEmpty((double[])null));\n+        assertEquals(true, ArrayUtils.isEmpty(emptyDoubleArray));\n+        assertEquals(false, ArrayUtils.isEmpty(notEmptyDoubleArray));\n+\n+        float[] emptyFloatArray = new float[] {};\n+        float[] notEmptyFloatArray = new float[] { 1.0F };\n+        assertEquals(true, ArrayUtils.isEmpty((float[])null));\n+        assertEquals(true, ArrayUtils.isEmpty(emptyFloatArray));\n+        assertEquals(false, ArrayUtils.isEmpty(notEmptyFloatArray));\n+\n+        boolean[] emptyBooleanArray = new boolean[] {};\n+        boolean[] notEmptyBooleanArray = new boolean[] { true };\n+        assertEquals(true, ArrayUtils.isEmpty((boolean[])null));\n+        assertEquals(true, ArrayUtils.isEmpty(emptyBooleanArray));\n+        assertEquals(false, ArrayUtils.isEmpty(notEmptyBooleanArray));\n+    }\n+    \n+    // ------------------------------------------------------------------------\n+    public void testGetLength() {\n+        assertEquals(0, ArrayUtils.getLength(null));\n+        \n+        Object[] emptyObjectArray = new Object[0];\n+        Object[] notEmptyObjectArray = new Object[] {\"aValue\"};\n+        assertEquals(0, ArrayUtils.getLength((Object[]) null));\n+        assertEquals(0, ArrayUtils.getLength(emptyObjectArray));\n+        assertEquals(1, ArrayUtils.getLength(notEmptyObjectArray));\n+ \n+        int[] emptyIntArray = new int[] {};\n+        int[] notEmptyIntArray = new int[] { 1 };\n+        assertEquals(0, ArrayUtils.getLength((int[]) null));\n+        assertEquals(0, ArrayUtils.getLength(emptyIntArray));\n+        assertEquals(1, ArrayUtils.getLength(notEmptyIntArray));\n+\n+        short[] emptyShortArray = new short[] {};\n+        short[] notEmptyShortArray = new short[] { 1 };\n+        assertEquals(0, ArrayUtils.getLength((short[]) null));\n+        assertEquals(0, ArrayUtils.getLength(emptyShortArray));\n+        assertEquals(1, ArrayUtils.getLength(notEmptyShortArray));\n+\n+        char[] emptyCharArray = new char[] {};\n+        char[] notEmptyCharArray = new char[] { 1 };\n+        assertEquals(0, ArrayUtils.getLength((char[]) null));\n+        assertEquals(0, ArrayUtils.getLength(emptyCharArray));\n+        assertEquals(1, ArrayUtils.getLength(notEmptyCharArray));\n+\n+        byte[] emptyByteArray = new byte[] {};\n+        byte[] notEmptyByteArray = new byte[] { 1 };\n+        assertEquals(0, ArrayUtils.getLength((byte[]) null));\n+        assertEquals(0, ArrayUtils.getLength(emptyByteArray));\n+        assertEquals(1, ArrayUtils.getLength(notEmptyByteArray));\n+\n+        double[] emptyDoubleArray = new double[] {};\n+        double[] notEmptyDoubleArray = new double[] { 1.0 };\n+        assertEquals(0, ArrayUtils.getLength((double[]) null));\n+        assertEquals(0, ArrayUtils.getLength(emptyDoubleArray));\n+        assertEquals(1, ArrayUtils.getLength(notEmptyDoubleArray));\n+\n+        float[] emptyFloatArray = new float[] {};\n+        float[] notEmptyFloatArray = new float[] { 1.0F };\n+        assertEquals(0, ArrayUtils.getLength((float[]) null));\n+        assertEquals(0, ArrayUtils.getLength(emptyFloatArray));\n+        assertEquals(1, ArrayUtils.getLength(notEmptyFloatArray));\n+\n+        boolean[] emptyBooleanArray = new boolean[] {};\n+        boolean[] notEmptyBooleanArray = new boolean[] { true };\n+        assertEquals(0, ArrayUtils.getLength((boolean[]) null));\n+        assertEquals(0, ArrayUtils.getLength(emptyBooleanArray));\n+        assertEquals(1, ArrayUtils.getLength(notEmptyBooleanArray));\n+        \n+        try {\n+            ArrayUtils.getLength(\"notAnArray\");\n+            fail(\"IllegalArgumentException should have been thrown\");\n+        } catch (IllegalArgumentException e) {}\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/BitFieldTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Class to test BitField functionality\n+ *\n+ * @author Scott Sanders\n+ * @author Marc Johnson\n+ * @author Glen Stampoultzis\n+ * @version $Id$\n+ */\n+public class BitFieldTest extends TestCase {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(BitFieldTest.class);\n+        suite.setName(\"BitField Tests\");\n+        return suite;\n+    }\n+\n+    private static final BitField bf_multi  = new BitField(0x3F80);\n+    private static final BitField bf_single = new BitField(0x4000);\n+    private static final BitField bf_zero = new BitField(0);\n+\n+    /**\n+     * Constructor BitFieldTest\n+     *\n+     * @param name\n+     */\n+    public BitFieldTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * test the getValue() method\n+     */\n+    public void testGetValue() {\n+        assertEquals(bf_multi.getValue(-1), 127);\n+        assertEquals(bf_multi.getValue(0), 0);\n+        assertEquals(bf_single.getValue(-1), 1);\n+        assertEquals(bf_single.getValue(0), 0);\n+        assertEquals(bf_zero.getValue(-1), 0);\n+        assertEquals(bf_zero.getValue(0), 0);\n+    }\n+\n+    /**\n+     * test the getShortValue() method\n+     */\n+    public void testGetShortValue() {\n+        assertEquals(bf_multi.getShortValue((short) - 1), (short) 127);\n+        assertEquals(bf_multi.getShortValue((short) 0), (short) 0);\n+        assertEquals(bf_single.getShortValue((short) - 1), (short) 1);\n+        assertEquals(bf_single.getShortValue((short) 0), (short) 0);\n+        assertEquals(bf_zero.getShortValue((short) -1), (short) 0);\n+        assertEquals(bf_zero.getShortValue((short) 0), (short) 0);\n+    }\n+\n+    /**\n+     * test the getRawValue() method\n+     */\n+    public void testGetRawValue() {\n+        assertEquals(bf_multi.getRawValue(-1), 0x3F80);\n+        assertEquals(bf_multi.getRawValue(0), 0);\n+        assertEquals(bf_single.getRawValue(-1), 0x4000);\n+        assertEquals(bf_single.getRawValue(0), 0);\n+        assertEquals(bf_zero.getRawValue(-1), 0);\n+        assertEquals(bf_zero.getRawValue(0), 0);\n+    }\n+\n+    /**\n+     * test the getShortRawValue() method\n+     */\n+    public void testGetShortRawValue() {\n+        assertEquals(bf_multi.getShortRawValue((short) - 1), (short) 0x3F80);\n+        assertEquals(bf_multi.getShortRawValue((short) 0), (short) 0);\n+        assertEquals(bf_single.getShortRawValue((short) - 1), (short) 0x4000);\n+        assertEquals(bf_single.getShortRawValue((short) 0), (short) 0);\n+        assertEquals(bf_zero.getShortRawValue((short) -1), (short) 0);\n+        assertEquals(bf_zero.getShortRawValue((short) 0), (short) 0);\n+    }\n+\n+    /**\n+     * test the isSet() method\n+     */\n+    public void testIsSet() {\n+        assertTrue(!bf_multi.isSet(0));\n+        assertTrue(!bf_zero.isSet(0));\n+        for (int j = 0x80; j <= 0x3F80; j += 0x80) {\n+            assertTrue(bf_multi.isSet(j));\n+        }\n+        for (int j = 0x80; j <= 0x3F80; j += 0x80) {\n+            assertTrue(!bf_zero.isSet(j));\n+        }\n+        assertTrue(!bf_single.isSet(0));\n+        assertTrue(bf_single.isSet(0x4000));\n+    }\n+\n+    /**\n+     * test the isAllSet() method\n+     */\n+    public void testIsAllSet() {\n+        for (int j = 0; j < 0x3F80; j += 0x80) {\n+            assertTrue(!bf_multi.isAllSet(j));\n+            assertTrue(bf_zero.isAllSet(j));\n+        }\n+        assertTrue(bf_multi.isAllSet(0x3F80));\n+        assertTrue(!bf_single.isAllSet(0));\n+        assertTrue(bf_single.isAllSet(0x4000));\n+    }\n+\n+    /**\n+     * test the setValue() method\n+     */\n+    public void testSetValue() {\n+        for (int j = 0; j < 128; j++) {\n+            assertEquals(bf_multi.getValue(bf_multi.setValue(0, j)), j);\n+            assertEquals(bf_multi.setValue(0, j), j << 7);\n+        }\n+        for (int j = 0; j < 128; j++) {\n+          assertEquals(bf_zero.getValue(bf_zero.setValue(0, j)), 0);\n+          assertEquals(bf_zero.setValue(0, j), 0);\n+      }\n+\n+        // verify that excess bits are stripped off\n+        assertEquals(bf_multi.setValue(0x3f80, 128), 0);\n+        for (int j = 0; j < 2; j++) {\n+            assertEquals(bf_single.getValue(bf_single.setValue(0, j)), j);\n+            assertEquals(bf_single.setValue(0, j), j << 14);\n+        }\n+\n+        // verify that excess bits are stripped off\n+        assertEquals(bf_single.setValue(0x4000, 2), 0);\n+    }\n+\n+    /**\n+     * test the setShortValue() method\n+     */\n+    public void testSetShortValue() {\n+        for (int j = 0; j < 128; j++) {\n+            assertEquals(bf_multi.getShortValue(bf_multi.setShortValue((short) 0, (short) j)), (short) j);\n+            assertEquals(bf_multi.setShortValue((short) 0, (short) j), (short) (j << 7));\n+        }\n+        for (int j = 0; j < 128; j++) {\n+            assertEquals(bf_zero.getShortValue(bf_zero.setShortValue((short) 0, (short) j)), (short) 0);\n+            assertEquals(bf_zero.setShortValue((short) 0, (short) j), (short) (0));\n+        }\n+\n+        // verify that excess bits are stripped off\n+        assertEquals(bf_multi.setShortValue((short) 0x3f80, (short) 128), (short) 0);\n+        for (int j = 0; j < 2; j++) {\n+            assertEquals(bf_single.getShortValue(bf_single.setShortValue((short) 0, (short) j)), (short) j);\n+            assertEquals(bf_single.setShortValue((short) 0, (short) j), (short) (j << 14));\n+        }\n+\n+        // verify that excess bits are stripped off\n+        assertEquals(bf_single.setShortValue((short) 0x4000, (short) 2), (short) 0);\n+    }\n+\n+    public void testByte() {\n+        assertEquals(0, new BitField(0).setByteBoolean((byte) 0, true));\n+        assertEquals(1, new BitField(1).setByteBoolean((byte) 0, true));\n+        assertEquals(2, new BitField(2).setByteBoolean((byte) 0, true));\n+        assertEquals(4, new BitField(4).setByteBoolean((byte) 0, true));\n+        assertEquals(8, new BitField(8).setByteBoolean((byte) 0, true));\n+        assertEquals(16, new BitField(16).setByteBoolean((byte) 0, true));\n+        assertEquals(32, new BitField(32).setByteBoolean((byte) 0, true));\n+        assertEquals(64, new BitField(64).setByteBoolean((byte) 0, true));\n+        assertEquals(-128, new BitField(128).setByteBoolean((byte) 0, true));\n+        assertEquals(1, new BitField(0).setByteBoolean((byte) 1, false));\n+        assertEquals(0, new BitField(1).setByteBoolean((byte) 1, false));\n+        assertEquals(0, new BitField(2).setByteBoolean((byte) 2, false));\n+        assertEquals(0, new BitField(4).setByteBoolean((byte) 4, false));\n+        assertEquals(0, new BitField(8).setByteBoolean((byte) 8, false));\n+        assertEquals(0, new BitField(16).setByteBoolean((byte) 16, false));\n+        assertEquals(0, new BitField(32).setByteBoolean((byte) 32, false));\n+        assertEquals(0, new BitField(64).setByteBoolean((byte) 64, false));\n+        assertEquals(0, new BitField(128).setByteBoolean((byte) 128, false));\n+        assertEquals(-2, new BitField(1).setByteBoolean((byte) 255, false));\n+        byte clearedBit = new BitField(0x40).setByteBoolean((byte) - 63, false);\n+\n+        assertEquals(false, new BitField(0x40).isSet(clearedBit));\n+    }\n+\n+    /**\n+     * test the clear() method\n+     */\n+    public void testClear() {\n+        assertEquals(bf_multi.clear(-1), 0xFFFFC07F);\n+        assertEquals(bf_single.clear(-1), 0xFFFFBFFF);\n+        assertEquals(bf_zero.clear(-1), 0xFFFFFFFF);\n+    }\n+\n+    /**\n+     * test the clearShort() method\n+     */\n+    public void testClearShort() {\n+        assertEquals(bf_multi.clearShort((short) - 1), (short) 0xC07F);\n+        assertEquals(bf_single.clearShort((short) - 1), (short) 0xBFFF);\n+        assertEquals(bf_zero.clearShort((short) -1), (short) 0xFFFF);\n+    }\n+\n+    /**\n+     * test the set() method\n+     */\n+    public void testSet() {\n+        assertEquals(bf_multi.set(0), 0x3F80);\n+        assertEquals(bf_single.set(0), 0x4000);\n+        assertEquals(bf_zero.set(0), 0);\n+    }\n+\n+    /**\n+     * test the setShort() method\n+     */\n+    public void testSetShort() {\n+        assertEquals(bf_multi.setShort((short) 0), (short) 0x3F80);\n+        assertEquals(bf_single.setShort((short) 0), (short) 0x4000);\n+        assertEquals(bf_zero.setShort((short) 0), (short) 0);\n+    }\n+\n+    /**\n+     * test the setBoolean() method\n+     */\n+    public void testSetBoolean() {\n+        assertEquals(bf_multi.set(0), bf_multi.setBoolean(0, true));\n+        assertEquals(bf_single.set(0), bf_single.setBoolean(0, true));\n+        assertEquals(bf_zero.set(0), bf_zero.setBoolean(0, true));\n+        assertEquals(bf_multi.clear(-1), bf_multi.setBoolean(-1, false));\n+        assertEquals(bf_single.clear(-1), bf_single.setBoolean(-1, false));\n+        assertEquals(bf_zero.clear(-1), bf_zero.setBoolean(-1, false));\n+    }\n+\n+    /**\n+     * test the setShortBoolean() method\n+     */\n+    public void testSetShortBoolean() {\n+        assertEquals(bf_multi.setShort((short) 0), bf_multi.setShortBoolean((short) 0, true));\n+        assertEquals(bf_single.setShort((short) 0), bf_single.setShortBoolean((short) 0, true));\n+        assertEquals(bf_zero.setShort((short) 0), bf_zero.setShortBoolean((short) 0, true));\n+        assertEquals(bf_multi.clearShort((short) - 1), bf_multi.setShortBoolean((short) - 1, false));\n+        assertEquals(bf_single.clearShort((short) - 1), bf_single.setShortBoolean((short) - 1, false));\n+        assertEquals(bf_zero.clearShort((short) -1), bf_zero.setShortBoolean((short) -1, false));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/BooleanUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.BooleanUtils}.\n+ *\n+ * @author Apache Software Foundation\n+ * @author Matthew Hawthorne\n+ * @version $Id$\n+ */\n+public class BooleanUtilsTest extends TestCase {\n+\n+    public BooleanUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(BooleanUtilsTest.class);\n+        suite.setName(\"BooleanUtils Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new BooleanUtils());\n+        Constructor<?>[] cons = BooleanUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(BooleanUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(BooleanUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void test_negate_Boolean() {\n+        assertSame(null, BooleanUtils.negate(null));\n+        assertSame(Boolean.TRUE, BooleanUtils.negate(Boolean.FALSE));\n+        assertSame(Boolean.FALSE, BooleanUtils.negate(Boolean.TRUE));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_isTrue_Boolean() {\n+        assertEquals(true, BooleanUtils.isTrue(Boolean.TRUE));\n+        assertEquals(false, BooleanUtils.isTrue(Boolean.FALSE));\n+        assertEquals(false, BooleanUtils.isTrue((Boolean) null));\n+    }\n+\n+    public void test_isNotTrue_Boolean() {\n+        assertEquals(false, BooleanUtils.isNotTrue(Boolean.TRUE));\n+        assertEquals(true, BooleanUtils.isNotTrue(Boolean.FALSE));\n+        assertEquals(true, BooleanUtils.isNotTrue((Boolean) null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_isFalse_Boolean() {\n+        assertEquals(false, BooleanUtils.isFalse(Boolean.TRUE));\n+        assertEquals(true, BooleanUtils.isFalse(Boolean.FALSE));\n+        assertEquals(false, BooleanUtils.isFalse((Boolean) null));\n+    }\n+\n+    public void test_isNotFalse_Boolean() {\n+        assertEquals(true, BooleanUtils.isNotFalse(Boolean.TRUE));\n+        assertEquals(false, BooleanUtils.isNotFalse(Boolean.FALSE));\n+        assertEquals(true, BooleanUtils.isNotFalse((Boolean) null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_toBoolean_Boolean() {\n+        assertEquals(true, BooleanUtils.toBoolean(Boolean.TRUE));\n+        assertEquals(false, BooleanUtils.toBoolean(Boolean.FALSE));\n+        assertEquals(false, BooleanUtils.toBoolean((Boolean) null));\n+    }\n+\n+    public void test_toBooleanDefaultIfNull_Boolean_boolean() {\n+        assertEquals(true, BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, true));\n+        assertEquals(true, BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, false));\n+        assertEquals(false, BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, true));\n+        assertEquals(false, BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, false));\n+        assertEquals(true, BooleanUtils.toBooleanDefaultIfNull((Boolean) null, true));\n+        assertEquals(false, BooleanUtils.toBooleanDefaultIfNull((Boolean) null, false));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void test_toBoolean_int() {\n+        assertEquals(true, BooleanUtils.toBoolean(1));\n+        assertEquals(true, BooleanUtils.toBoolean(-1));\n+        assertEquals(false, BooleanUtils.toBoolean(0));\n+    }\n+    \n+    public void test_toBooleanObject_int() {\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(1));\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(-1));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(0));\n+    }\n+    \n+    public void test_toBooleanObject_Integer() {\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(new Integer(1)));\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(new Integer(-1)));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(new Integer(0)));\n+        assertEquals(null, BooleanUtils.toBooleanObject((Integer) null));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void test_toBoolean_int_int_int() {\n+        assertEquals(true, BooleanUtils.toBoolean(6, 6, 7));\n+        assertEquals(false, BooleanUtils.toBoolean(7, 6, 7));\n+        try {\n+            BooleanUtils.toBoolean(8, 6, 7);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void test_toBoolean_Integer_Integer_Integer() {\n+        Integer six = new Integer(6);\n+        Integer seven = new Integer(7);\n+\n+        assertEquals(true, BooleanUtils.toBoolean((Integer) null, null, seven));\n+        assertEquals(false, BooleanUtils.toBoolean((Integer) null, six, null));\n+        try {\n+            BooleanUtils.toBoolean(null, six, seven);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        assertEquals(true, BooleanUtils.toBoolean(new Integer(6), six, seven));\n+        assertEquals(false, BooleanUtils.toBoolean(new Integer(7), six, seven));\n+        try {\n+            BooleanUtils.toBoolean(new Integer(8), six, seven);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void test_toBooleanObject_int_int_int() {\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(6, 6, 7, 8));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(7, 6, 7, 8));\n+        assertEquals(null, BooleanUtils.toBooleanObject(8, 6, 7, 8));\n+        try {\n+            BooleanUtils.toBooleanObject(9, 6, 7, 8);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void test_toBooleanObject_Integer_Integer_Integer_Integer() {\n+        Integer six = new Integer(6);\n+        Integer seven = new Integer(7);\n+        Integer eight = new Integer(8);\n+\n+        assertSame(Boolean.TRUE, BooleanUtils.toBooleanObject((Integer) null, null, seven, eight));\n+        assertSame(Boolean.FALSE, BooleanUtils.toBooleanObject((Integer) null, six, null, eight));\n+        assertSame(null, BooleanUtils.toBooleanObject((Integer) null, six, seven, null));\n+        try {\n+            BooleanUtils.toBooleanObject(null, six, seven, eight);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(new Integer(6), six, seven, eight));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(new Integer(7), six, seven, eight));\n+        assertEquals(null, BooleanUtils.toBooleanObject(new Integer(8), six, seven, eight));\n+        try {\n+            BooleanUtils.toBooleanObject(new Integer(9), six, seven, eight);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void test_toInteger_boolean() {\n+        assertEquals(1, BooleanUtils.toInteger(true));\n+        assertEquals(0, BooleanUtils.toInteger(false));\n+    }\n+    \n+    public void test_toIntegerObject_boolean() {\n+        assertEquals(new Integer(1), BooleanUtils.toIntegerObject(true));\n+        assertEquals(new Integer(0), BooleanUtils.toIntegerObject(false));\n+    }\n+    \n+    public void test_toIntegerObject_Boolean() {\n+        assertEquals(new Integer(1), BooleanUtils.toIntegerObject(Boolean.TRUE));\n+        assertEquals(new Integer(0), BooleanUtils.toIntegerObject(Boolean.FALSE));\n+        assertEquals(null, BooleanUtils.toIntegerObject((Boolean) null));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void test_toInteger_boolean_int_int() {\n+        assertEquals(6, BooleanUtils.toInteger(true, 6, 7));\n+        assertEquals(7, BooleanUtils.toInteger(false, 6, 7));\n+    }\n+    \n+    public void test_toInteger_Boolean_int_int_int() {\n+        assertEquals(6, BooleanUtils.toInteger(Boolean.TRUE, 6, 7, 8));\n+        assertEquals(7, BooleanUtils.toInteger(Boolean.FALSE, 6, 7, 8));\n+        assertEquals(8, BooleanUtils.toInteger(null, 6, 7, 8));\n+    }\n+    \n+    public void test_toIntegerObject_boolean_Integer_Integer() {\n+        Integer six = new Integer(6);\n+        Integer seven = new Integer(7);\n+        assertEquals(six, BooleanUtils.toIntegerObject(true, six, seven));\n+        assertEquals(seven, BooleanUtils.toIntegerObject(false, six, seven));\n+    }\n+    \n+    public void test_toIntegerObject_Boolean_Integer_Integer_Integer() {\n+        Integer six = new Integer(6);\n+        Integer seven = new Integer(7);\n+        Integer eight = new Integer(8);\n+        assertEquals(six, BooleanUtils.toIntegerObject(Boolean.TRUE, six, seven, eight));\n+        assertEquals(seven, BooleanUtils.toIntegerObject(Boolean.FALSE, six, seven, eight));\n+        assertEquals(eight, BooleanUtils.toIntegerObject((Boolean) null, six, seven, eight));\n+        assertEquals(null, BooleanUtils.toIntegerObject((Boolean) null, six, seven, null));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void test_toBooleanObject_String() {\n+        assertEquals(null, BooleanUtils.toBooleanObject((String) null));\n+        assertEquals(null, BooleanUtils.toBooleanObject(\"\"));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(\"false\"));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(\"no\"));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(\"off\"));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(\"FALSE\"));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(\"NO\"));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(\"OFF\"));\n+        assertEquals(null, BooleanUtils.toBooleanObject(\"oof\"));\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(\"true\"));\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(\"yes\"));\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(\"on\"));\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(\"TRUE\"));\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(\"ON\"));\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(\"YES\"));\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(\"TruE\"));\n+    }\n+    \n+    public void test_toBooleanObject_String_String_String_String() {\n+        assertSame(Boolean.TRUE, BooleanUtils.toBooleanObject((String) null, null, \"N\", \"U\"));\n+        assertSame(Boolean.FALSE, BooleanUtils.toBooleanObject((String) null, \"Y\", null, \"U\"));\n+        assertSame(null, BooleanUtils.toBooleanObject((String) null, \"Y\", \"N\", null));\n+        try {\n+            BooleanUtils.toBooleanObject((String) null, \"Y\", \"N\", \"U\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(\"Y\", \"Y\", \"N\", \"U\"));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(\"N\", \"Y\", \"N\", \"U\"));\n+        assertEquals(null, BooleanUtils.toBooleanObject(\"U\", \"Y\", \"N\", \"U\"));\n+        try {\n+            BooleanUtils.toBooleanObject(null, \"Y\", \"N\", \"U\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            BooleanUtils.toBooleanObject(\"X\", \"Y\", \"N\", \"U\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_toBoolean_String() {\n+        assertEquals(false, BooleanUtils.toBoolean((String) null));\n+        assertEquals(false, BooleanUtils.toBoolean(\"\"));\n+        assertEquals(false, BooleanUtils.toBoolean(\"off\"));\n+        assertEquals(false, BooleanUtils.toBoolean(\"oof\"));\n+        assertEquals(false, BooleanUtils.toBoolean(\"yep\"));\n+        assertEquals(false, BooleanUtils.toBoolean(\"trux\"));\n+        assertEquals(false, BooleanUtils.toBoolean(\"false\"));\n+        assertEquals(false, BooleanUtils.toBoolean(\"a\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"true\")); // interned handled differently\n+        assertEquals(true, BooleanUtils.toBoolean(new StringBuffer(\"tr\").append(\"ue\").toString()));\n+        assertEquals(true, BooleanUtils.toBoolean(\"truE\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"trUe\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"trUE\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"tRue\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"tRuE\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"tRUe\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"tRUE\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"TRUE\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"TRUe\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"TRuE\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"TRue\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"TrUE\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"TrUe\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"TruE\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"True\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"on\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"oN\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"On\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"ON\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"yes\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"yeS\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"yEs\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"yES\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"Yes\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"YeS\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"YEs\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"YES\"));\n+        assertEquals(false, BooleanUtils.toBoolean(\"yes?\"));\n+        assertEquals(false, BooleanUtils.toBoolean(\"tru\"));\n+    }\n+\n+    public void test_toBoolean_String_String_String() {\n+        assertEquals(true, BooleanUtils.toBoolean((String) null, null, \"N\"));\n+        assertEquals(false, BooleanUtils.toBoolean((String) null, \"Y\", null));\n+        try {\n+            BooleanUtils.toBooleanObject((String) null, \"Y\", \"N\", \"U\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        assertEquals(true, BooleanUtils.toBoolean(\"Y\", \"Y\", \"N\"));\n+        assertEquals(false, BooleanUtils.toBoolean(\"N\", \"Y\", \"N\"));\n+        try {\n+            BooleanUtils.toBoolean(null, \"Y\", \"N\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            BooleanUtils.toBoolean(\"X\", \"Y\", \"N\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_toStringTrueFalse_Boolean() {\n+        assertEquals(null, BooleanUtils.toStringTrueFalse((Boolean) null));\n+        assertEquals(\"true\", BooleanUtils.toStringTrueFalse(Boolean.TRUE));\n+        assertEquals(\"false\", BooleanUtils.toStringTrueFalse(Boolean.FALSE));\n+    }\n+    \n+    public void test_toStringOnOff_Boolean() {\n+        assertEquals(null, BooleanUtils.toStringOnOff((Boolean) null));\n+        assertEquals(\"on\", BooleanUtils.toStringOnOff(Boolean.TRUE));\n+        assertEquals(\"off\", BooleanUtils.toStringOnOff(Boolean.FALSE));\n+    }\n+    \n+    public void test_toStringYesNo_Boolean() {\n+        assertEquals(null, BooleanUtils.toStringYesNo((Boolean) null));\n+        assertEquals(\"yes\", BooleanUtils.toStringYesNo(Boolean.TRUE));\n+        assertEquals(\"no\", BooleanUtils.toStringYesNo(Boolean.FALSE));\n+    }\n+    \n+    public void test_toString_Boolean_String_String_String() {\n+        assertEquals(\"U\", BooleanUtils.toString((Boolean) null, \"Y\", \"N\", \"U\"));\n+        assertEquals(\"Y\", BooleanUtils.toString(Boolean.TRUE, \"Y\", \"N\", \"U\"));\n+        assertEquals(\"N\", BooleanUtils.toString(Boolean.FALSE, \"Y\", \"N\", \"U\"));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void test_toStringTrueFalse_boolean() {\n+        assertEquals(\"true\", BooleanUtils.toStringTrueFalse(true));\n+        assertEquals(\"false\", BooleanUtils.toStringTrueFalse(false));\n+    }\n+    \n+    public void test_toStringOnOff_boolean() {\n+        assertEquals(\"on\", BooleanUtils.toStringOnOff(true));\n+        assertEquals(\"off\", BooleanUtils.toStringOnOff(false));\n+    }\n+    \n+    public void test_toStringYesNo_boolean() {\n+        assertEquals(\"yes\", BooleanUtils.toStringYesNo(true));\n+        assertEquals(\"no\", BooleanUtils.toStringYesNo(false));\n+    }\n+    \n+    public void test_toString_boolean_String_String_String() {\n+        assertEquals(\"Y\", BooleanUtils.toString(true, \"Y\", \"N\"));\n+        assertEquals(\"N\", BooleanUtils.toString(false, \"Y\", \"N\"));\n+    }\n+    \n+    //  testXor\n+    //  -----------------------------------------------------------------------\n+    public void testXor_primitive_nullInput() {\n+        final boolean[] b = null;\n+        try {\n+            BooleanUtils.xor(b);\n+            fail(\"Exception was not thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testXor_primitive_emptyInput() {\n+        try {\n+            BooleanUtils.xor(new boolean[] {});\n+            fail(\"Exception was not thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testXor_primitive_validInput_2items() {\n+        assertTrue(\n+            \"True result for (true, true)\",\n+            ! BooleanUtils.xor(new boolean[] { true, true }));\n+\n+        assertTrue(\n+            \"True result for (false, false)\",\n+            ! BooleanUtils.xor(new boolean[] { false, false }));\n+\n+        assertTrue(\n+            \"False result for (true, false)\",\n+            BooleanUtils.xor(new boolean[] { true, false }));\n+\n+        assertTrue(\n+            \"False result for (false, true)\",\n+            BooleanUtils.xor(new boolean[] { false, true }));\n+    }\n+\n+    public void testXor_primitive_validInput_3items() {\n+        assertTrue(\n+            \"False result for (false, false, true)\",\n+            BooleanUtils.xor(new boolean[] { false, false, true }));\n+\n+        assertTrue(\n+            \"False result for (false, true, false)\",\n+            BooleanUtils.xor(new boolean[] { false, true, false }));\n+\n+        assertTrue(\n+            \"False result for (true, false, false)\",\n+            BooleanUtils.xor(new boolean[] { true, false, false }));\n+\n+        assertTrue(\n+            \"True result for (true, true, true)\",\n+            ! BooleanUtils.xor(new boolean[] { true, true, true }));\n+\n+        assertTrue(\n+            \"True result for (false, false)\",\n+            ! BooleanUtils.xor(new boolean[] { false, false, false }));\n+\n+        assertTrue(\n+            \"True result for (true, true, false)\",\n+            ! BooleanUtils.xor(new boolean[] { true, true, false }));\n+\n+        assertTrue(\n+            \"True result for (true, false, true)\",\n+            ! BooleanUtils.xor(new boolean[] { true, false, true }));\n+\n+        assertTrue(\n+            \"False result for (false, true, true)\",\n+            ! BooleanUtils.xor(new boolean[] { false, true, true }));\n+    }\n+\n+    public void testXor_object_nullInput() {\n+        final Boolean[] b = null;\n+        try {\n+            BooleanUtils.xor(b);\n+            fail(\"Exception was not thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testXor_object_emptyInput() {\n+        try {\n+            BooleanUtils.xor(new Boolean[] {});\n+            fail(\"Exception was not thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void testXor_object_nullElementInput() {\n+        try {\n+            BooleanUtils.xor(new Boolean[] {null});\n+            fail(\"Exception was not thrown for null element input.\");\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testXor_object_validInput_2items() {\n+        assertTrue(\n+            \"True result for (true, true)\",\n+            ! BooleanUtils\n+                .xor(new Boolean[] { Boolean.TRUE, Boolean.TRUE })\n+                .booleanValue());\n+\n+        assertTrue(\n+            \"True result for (false, false)\",\n+            ! BooleanUtils\n+                .xor(new Boolean[] { Boolean.FALSE, Boolean.FALSE })\n+                .booleanValue());\n+\n+        assertTrue(\n+            \"False result for (true, false)\",\n+            BooleanUtils\n+                .xor(new Boolean[] { Boolean.TRUE, Boolean.FALSE })\n+                .booleanValue());\n+\n+        assertTrue(\n+            \"False result for (false, true)\",\n+            BooleanUtils\n+                .xor(new Boolean[] { Boolean.FALSE, Boolean.TRUE })\n+                .booleanValue());\n+    }\n+\n+    public void testXor_object_validInput_3items() {\n+        assertTrue(\n+            \"False result for (false, false, true)\",\n+            BooleanUtils\n+                .xor(\n+                    new Boolean[] {\n+                        Boolean.FALSE,\n+                        Boolean.FALSE,\n+                        Boolean.TRUE })\n+                .booleanValue());\n+\n+        assertTrue(\n+            \"False result for (false, true, false)\",\n+            BooleanUtils\n+                .xor(\n+                    new Boolean[] {\n+                        Boolean.FALSE,\n+                        Boolean.TRUE,\n+                        Boolean.FALSE })\n+                .booleanValue());\n+\n+        assertTrue(\n+            \"False result for (true, false, false)\",\n+            BooleanUtils\n+                .xor(\n+                    new Boolean[] {\n+                        Boolean.TRUE,\n+                        Boolean.FALSE,\n+                        Boolean.FALSE })\n+                .booleanValue());\n+\n+        assertTrue(\n+            \"True result for (true, true, true)\",\n+            ! BooleanUtils\n+                .xor(new Boolean[] { Boolean.TRUE, Boolean.TRUE, Boolean.TRUE })\n+                .booleanValue());\n+\n+        assertTrue(\n+            \"True result for (false, false)\",\n+            ! BooleanUtils.xor(\n+                    new Boolean[] {\n+                        Boolean.FALSE,\n+                        Boolean.FALSE,\n+                        Boolean.FALSE })\n+                .booleanValue());\n+\n+        assertTrue(\n+            \"True result for (true, true, false)\",\n+            ! BooleanUtils.xor(\n+                    new Boolean[] {\n+                        Boolean.TRUE,\n+                        Boolean.TRUE,\n+                        Boolean.FALSE })\n+                .booleanValue());\n+\n+        assertTrue(\n+            \"True result for (true, false, true)\",\n+            ! BooleanUtils.xor(\n+                    new Boolean[] {\n+                        Boolean.TRUE,\n+                        Boolean.FALSE,\n+                        Boolean.TRUE })\n+                .booleanValue());\n+\n+        assertTrue(\n+            \"False result for (false, true, true)\",\n+            ! BooleanUtils.xor(\n+                    new Boolean[] {\n+                        Boolean.FALSE,\n+                        Boolean.TRUE,\n+                        Boolean.TRUE })\n+                .booleanValue());\n+                \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/CharEncodingTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Tests CharEncoding.\n+ * \n+ * @see CharEncoding\n+ * @author Gary D. Gregory\n+ * @version $Id$\n+ */\n+public class CharEncodingTest extends TestCase {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(CharEncodingTest.class);\n+        suite.setName(\"CharEncoding Tests\");\n+        return suite;\n+    }\n+\n+    private void assertSupportedEncoding(String name) {\n+        assertTrue(\"Encoding should be supported: \" + name, CharEncoding.isSupported(name));\n+    }\n+\n+    /**\n+     * The class can be instantiated.\n+     */\n+    public void testConstructor() {\n+        new CharEncoding();\n+    }\n+\n+    public void testMustBeSupportedJava1_3_1() {\n+        if (SystemUtils.isJavaVersionAtLeast(1.3f)) {\n+            this.assertSupportedEncoding(CharEncoding.ISO_8859_1);\n+            this.assertSupportedEncoding(CharEncoding.US_ASCII);\n+            this.assertSupportedEncoding(CharEncoding.UTF_16);\n+            this.assertSupportedEncoding(CharEncoding.UTF_16BE);\n+            this.assertSupportedEncoding(CharEncoding.UTF_16LE);\n+            this.assertSupportedEncoding(CharEncoding.UTF_8);\n+        } else {\n+            this.warn(\"Java 1.3 tests not run since the current version is \" + SystemUtils.JAVA_VERSION);\n+        }\n+    }\n+\n+    public void testNotSupported() {\n+        assertFalse(CharEncoding.isSupported(null));\n+        assertFalse(CharEncoding.isSupported(\"\"));\n+        assertFalse(CharEncoding.isSupported(\" \"));\n+        assertFalse(CharEncoding.isSupported(\"\\t\\r\\n\"));\n+        assertFalse(CharEncoding.isSupported(\"DOESNOTEXIST\"));\n+        assertFalse(CharEncoding.isSupported(\"this is not a valid encoding name\"));\n+    }\n+\n+    public void testWorksOnJava1_1_8() {\n+        //\n+        // In this test, I simply deleted the encodings from the 1.3.1 list.\n+        // The Javadoc do not specify which encodings are required.\n+        //\n+        if (SystemUtils.isJavaVersionAtLeast(1.1f)) {\n+            this.assertSupportedEncoding(CharEncoding.ISO_8859_1);\n+            this.assertSupportedEncoding(CharEncoding.US_ASCII);\n+            this.assertSupportedEncoding(CharEncoding.UTF_8);\n+        } else {\n+            this.warn(\"Java 1.1 tests not run since the current version is \" + SystemUtils.JAVA_VERSION);\n+        }\n+    }\n+\n+    public void testWorksOnJava1_2_2() {\n+        //\n+        // In this test, I simply deleted the encodings from the 1.3.1 list.\n+        // The Javadoc do not specify which encodings are required.\n+        //\n+        if (SystemUtils.isJavaVersionAtLeast(1.2f)) {\n+            this.assertSupportedEncoding(CharEncoding.ISO_8859_1);\n+            this.assertSupportedEncoding(CharEncoding.US_ASCII);\n+            this.assertSupportedEncoding(CharEncoding.UTF_8);\n+        } else {\n+            this.warn(\"Java 1.2 tests not run since the current version is \" + SystemUtils.JAVA_VERSION);\n+        }\n+    }\n+\n+    void warn(String msg) {\n+        System.err.println(msg);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/CharRangeTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Modifier;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.CharRange}.\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class CharRangeTest extends TestCase {\n+    \n+    public CharRangeTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(CharRangeTest.class);\n+        suite.setName(\"CharRange Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testClass() {\n+        assertEquals(true, Modifier.isPublic(CharRange.class.getModifiers()));\n+        assertEquals(true, Modifier.isFinal(CharRange.class.getModifiers()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructorAccessors_is() {\n+        CharRange rangea = CharRange.is('a');\n+        assertEquals('a', rangea.getStart());\n+        assertEquals('a', rangea.getEnd());\n+        assertEquals(false, rangea.isNegated());\n+        assertEquals(\"a\", rangea.toString());\n+    }\n+    \n+    public void testConstructorAccessors_isNot() {\n+        CharRange rangea = CharRange.isNot('a');\n+        assertEquals('a', rangea.getStart());\n+        assertEquals('a', rangea.getEnd());\n+        assertEquals(true, rangea.isNegated());\n+        assertEquals(\"^a\", rangea.toString());\n+    }\n+    \n+    public void testConstructorAccessors_isIn_Same() {\n+        CharRange rangea = CharRange.isIn('a', 'a');\n+        assertEquals('a', rangea.getStart());\n+        assertEquals('a', rangea.getEnd());\n+        assertEquals(false, rangea.isNegated());\n+        assertEquals(\"a\", rangea.toString());\n+    }\n+    \n+    public void testConstructorAccessors_isIn_Normal() {\n+        CharRange rangea = CharRange.isIn('a', 'e');\n+        assertEquals('a', rangea.getStart());\n+        assertEquals('e', rangea.getEnd());\n+        assertEquals(false, rangea.isNegated());\n+        assertEquals(\"a-e\", rangea.toString());\n+    }\n+    \n+    public void testConstructorAccessors_isIn_Reversed() {\n+        CharRange rangea = CharRange.isIn('e', 'a');\n+        assertEquals('a', rangea.getStart());\n+        assertEquals('e', rangea.getEnd());\n+        assertEquals(false, rangea.isNegated());\n+        assertEquals(\"a-e\", rangea.toString());\n+    }\n+    \n+    public void testConstructorAccessors_isNotIn_Same() {\n+        CharRange rangea = CharRange.isNotIn('a', 'a');\n+        assertEquals('a', rangea.getStart());\n+        assertEquals('a', rangea.getEnd());\n+        assertEquals(true, rangea.isNegated());\n+        assertEquals(\"^a\", rangea.toString());\n+    }\n+    \n+    public void testConstructorAccessors_isNotIn_Normal() {\n+        CharRange rangea = CharRange.isNotIn('a', 'e');\n+        assertEquals('a', rangea.getStart());\n+        assertEquals('e', rangea.getEnd());\n+        assertEquals(true, rangea.isNegated());\n+        assertEquals(\"^a-e\", rangea.toString());\n+    }\n+    \n+    public void testConstructorAccessors_isNotIn_Reversed() {\n+        CharRange rangea = CharRange.isNotIn('e', 'a');\n+        assertEquals('a', rangea.getStart());\n+        assertEquals('e', rangea.getEnd());\n+        assertEquals(true, rangea.isNegated());\n+        assertEquals(\"^a-e\", rangea.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    public void testEquals_Object() {\n+        CharRange rangea = CharRange.is('a');\n+        CharRange rangeae = CharRange.isIn('a', 'e');\n+        CharRange rangenotbf = CharRange.isIn('b', 'f');\n+        \n+        assertEquals(false, rangea.equals(null));\n+        \n+        assertEquals(true, rangea.equals(rangea));\n+        assertEquals(true, rangea.equals(CharRange.is('a')));\n+        assertEquals(true, rangeae.equals(rangeae));\n+        assertEquals(true, rangeae.equals(CharRange.isIn('a', 'e')));\n+        assertEquals(true, rangenotbf.equals(rangenotbf));\n+        assertEquals(true, rangenotbf.equals(CharRange.isIn('b', 'f')));\n+        \n+        assertEquals(false, rangea.equals(rangeae));\n+        assertEquals(false, rangea.equals(rangenotbf));\n+        assertEquals(false, rangeae.equals(rangea));\n+        assertEquals(false, rangeae.equals(rangenotbf));\n+        assertEquals(false, rangenotbf.equals(rangea));\n+        assertEquals(false, rangenotbf.equals(rangeae));\n+    }\n+            \n+    public void testHashCode() {\n+        CharRange rangea = CharRange.is('a');\n+        CharRange rangeae = CharRange.isIn('a', 'e');\n+        CharRange rangenotbf = CharRange.isIn('b', 'f');\n+        \n+        assertEquals(true, rangea.hashCode() == rangea.hashCode());\n+        assertEquals(true, rangea.hashCode() == CharRange.is('a').hashCode());\n+        assertEquals(true, rangeae.hashCode() == rangeae.hashCode());\n+        assertEquals(true, rangeae.hashCode() == CharRange.isIn('a', 'e').hashCode());\n+        assertEquals(true, rangenotbf.hashCode() == rangenotbf.hashCode());\n+        assertEquals(true, rangenotbf.hashCode() == CharRange.isIn('b', 'f').hashCode());\n+        \n+        assertEquals(false, rangea.hashCode() == rangeae.hashCode());\n+        assertEquals(false, rangea.hashCode() == rangenotbf.hashCode());\n+        assertEquals(false, rangeae.hashCode() == rangea.hashCode());\n+        assertEquals(false, rangeae.hashCode() == rangenotbf.hashCode());\n+        assertEquals(false, rangenotbf.hashCode() == rangea.hashCode());\n+        assertEquals(false, rangenotbf.hashCode() == rangeae.hashCode());\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    public void testContains_Char() {\n+        CharRange range = CharRange.is('c');\n+        assertEquals(false, range.contains('b'));\n+        assertEquals(true, range.contains('c'));\n+        assertEquals(false, range.contains('d'));\n+        assertEquals(false, range.contains('e'));\n+        \n+        range = CharRange.isIn('c', 'd');\n+        assertEquals(false, range.contains('b'));\n+        assertEquals(true, range.contains('c'));\n+        assertEquals(true, range.contains('d'));\n+        assertEquals(false, range.contains('e'));\n+        \n+        range = CharRange.isIn('d', 'c');\n+        assertEquals(false, range.contains('b'));\n+        assertEquals(true, range.contains('c'));\n+        assertEquals(true, range.contains('d'));\n+        assertEquals(false, range.contains('e'));\n+        \n+        range = CharRange.isNotIn('c', 'd');\n+        assertEquals(true, range.contains('b'));\n+        assertEquals(false, range.contains('c'));\n+        assertEquals(false, range.contains('d'));\n+        assertEquals(true, range.contains('e'));\n+        assertEquals(true, range.contains((char) 0));\n+        assertEquals(true, range.contains(Character.MAX_VALUE));\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    public void testContains_Charrange() {\n+        CharRange a = CharRange.is('a');\n+        CharRange b = CharRange.is('b');\n+        CharRange c = CharRange.is('c');\n+        CharRange c2 = CharRange.is('c');\n+        CharRange d = CharRange.is('d');\n+        CharRange e = CharRange.is('e');\n+        CharRange cd = CharRange.isIn('c', 'd');\n+        CharRange bd = CharRange.isIn('b', 'd');\n+        CharRange bc = CharRange.isIn('b', 'c');\n+        CharRange ab = CharRange.isIn('a', 'b');\n+        CharRange de = CharRange.isIn('d', 'e');\n+        CharRange ef = CharRange.isIn('e', 'f');\n+        CharRange ae = CharRange.isIn('a', 'e');\n+        \n+        // normal/normal\n+        assertEquals(false, c.contains(b));\n+        assertEquals(true, c.contains(c));\n+        assertEquals(true, c.contains(c2));\n+        assertEquals(false, c.contains(d));\n+        \n+        assertEquals(false, c.contains(cd));\n+        assertEquals(false, c.contains(bd));\n+        assertEquals(false, c.contains(bc));\n+        assertEquals(false, c.contains(ab));\n+        assertEquals(false, c.contains(de));\n+        \n+        assertEquals(true, cd.contains(c));\n+        assertEquals(true, bd.contains(c));\n+        assertEquals(true, bc.contains(c));\n+        assertEquals(false, ab.contains(c));\n+        assertEquals(false, de.contains(c));\n+\n+        assertEquals(true, ae.contains(b));\n+        assertEquals(true, ae.contains(ab));\n+        assertEquals(true, ae.contains(bc));\n+        assertEquals(true, ae.contains(cd));\n+        assertEquals(true, ae.contains(de));\n+        \n+        CharRange notb = CharRange.isNot('b');\n+        CharRange notc = CharRange.isNot('c');\n+        CharRange notd = CharRange.isNot('d');\n+        CharRange notab = CharRange.isNotIn('a', 'b');\n+        CharRange notbc = CharRange.isNotIn('b', 'c');\n+        CharRange notbd = CharRange.isNotIn('b', 'd');\n+        CharRange notcd = CharRange.isNotIn('c', 'd');\n+        CharRange notde = CharRange.isNotIn('d', 'e');\n+        CharRange notae = CharRange.isNotIn('a', 'e');\n+        CharRange all = CharRange.isIn((char) 0, Character.MAX_VALUE);\n+        CharRange allbutfirst = CharRange.isIn((char) 1, Character.MAX_VALUE);\n+        \n+        // normal/negated\n+        assertEquals(false, c.contains(notc));\n+        assertEquals(false, c.contains(notbd));\n+        assertEquals(true, all.contains(notc));\n+        assertEquals(true, all.contains(notbd));\n+        assertEquals(false, allbutfirst.contains(notc));\n+        assertEquals(false, allbutfirst.contains(notbd));\n+        \n+        // negated/normal\n+        assertEquals(true, notc.contains(a));\n+        assertEquals(true, notc.contains(b));\n+        assertEquals(false, notc.contains(c));\n+        assertEquals(true, notc.contains(d));\n+        assertEquals(true, notc.contains(e));\n+        \n+        assertEquals(true, notc.contains(ab));\n+        assertEquals(false, notc.contains(bc));\n+        assertEquals(false, notc.contains(bd));\n+        assertEquals(false, notc.contains(cd));\n+        assertEquals(true, notc.contains(de));\n+        assertEquals(false, notc.contains(ae));\n+        assertEquals(false, notc.contains(all));\n+        assertEquals(false, notc.contains(allbutfirst));\n+        \n+        assertEquals(true, notbd.contains(a));\n+        assertEquals(false, notbd.contains(b));\n+        assertEquals(false, notbd.contains(c));\n+        assertEquals(false, notbd.contains(d));\n+        assertEquals(true, notbd.contains(e));\n+        \n+        assertEquals(true, notcd.contains(ab));\n+        assertEquals(false, notcd.contains(bc));\n+        assertEquals(false, notcd.contains(bd));\n+        assertEquals(false, notcd.contains(cd));\n+        assertEquals(false, notcd.contains(de));\n+        assertEquals(false, notcd.contains(ae));\n+        assertEquals(true, notcd.contains(ef));\n+        assertEquals(false, notcd.contains(all));\n+        assertEquals(false, notcd.contains(allbutfirst));\n+        \n+        // negated/negated\n+        assertEquals(false, notc.contains(notb));\n+        assertEquals(true, notc.contains(notc));\n+        assertEquals(false, notc.contains(notd));\n+        \n+        assertEquals(false, notc.contains(notab));\n+        assertEquals(true, notc.contains(notbc));\n+        assertEquals(true, notc.contains(notbd));\n+        assertEquals(true, notc.contains(notcd));\n+        assertEquals(false, notc.contains(notde));\n+        \n+        assertEquals(false, notbd.contains(notb));\n+        assertEquals(false, notbd.contains(notc));\n+        assertEquals(false, notbd.contains(notd));\n+        \n+        assertEquals(false, notbd.contains(notab));\n+        assertEquals(false, notbd.contains(notbc));\n+        assertEquals(true, notbd.contains(notbd));\n+        assertEquals(false, notbd.contains(notcd));\n+        assertEquals(false, notbd.contains(notde));\n+        assertEquals(true, notbd.contains(notae));\n+    }\n+    \n+    public void testContainsNullArg() {\n+        CharRange range = CharRange.is('a');\n+        try {\n+            @SuppressWarnings(\"unused\")\n+            boolean contains = range.contains(null);\n+        } catch(IllegalArgumentException e) {\n+            assertEquals(\"The Range must not be null\", e.getMessage());\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    public void testSerialization() {\n+        CharRange range = CharRange.is('a');\n+        assertEquals(range, SerializationUtils.clone(range)); \n+        range = CharRange.isIn('a', 'e');\n+        assertEquals(range, SerializationUtils.clone(range)); \n+        range = CharRange.isNotIn('a', 'e');\n+        assertEquals(range, SerializationUtils.clone(range)); \n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/CharSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Modifier;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.CharSet}.\n+ *\n+ * @author Apache Software Foundation\n+ * @author Phil Steitz\n+ * @version $Id$\n+ */\n+public class CharSetTest extends TestCase {\n+    \n+    public CharSetTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(CharSetTest.class);\n+        suite.setName(\"CharSet Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testClass() {\n+        assertEquals(true, Modifier.isPublic(CharSet.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(CharSet.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testGetInstance() {\n+        assertSame(CharSet.EMPTY, CharSet.getInstance( (String) null));\n+        assertSame(CharSet.EMPTY, CharSet.getInstance(\"\"));\n+        assertSame(CharSet.ASCII_ALPHA, CharSet.getInstance(\"a-zA-Z\"));\n+        assertSame(CharSet.ASCII_ALPHA, CharSet.getInstance(\"A-Za-z\"));\n+        assertSame(CharSet.ASCII_ALPHA_LOWER, CharSet.getInstance(\"a-z\"));\n+        assertSame(CharSet.ASCII_ALPHA_UPPER, CharSet.getInstance(\"A-Z\"));\n+        assertSame(CharSet.ASCII_NUMERIC, CharSet.getInstance(\"0-9\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetInstance_Stringarray() {\n+        assertEquals(null, CharSet.getInstance((String[]) null));\n+        assertEquals(\"[]\", CharSet.getInstance(new String[0]).toString());\n+        assertEquals(\"[]\", CharSet.getInstance(new String[] {null}).toString());\n+        assertEquals(\"[a-e]\", CharSet.getInstance(new String[] {\"a-e\"}).toString());\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testConstructor_String_simple() {\n+        CharSet set;\n+        CharRange[] array;\n+        \n+        set = CharSet.getInstance((String) null);\n+        array = set.getCharRanges();\n+        assertEquals(\"[]\", set.toString());\n+        assertEquals(0, array.length);\n+        \n+        set = CharSet.getInstance(\"\");\n+        array = set.getCharRanges();\n+        assertEquals(\"[]\", set.toString());\n+        assertEquals(0, array.length);\n+        \n+        set = CharSet.getInstance(\"a\");\n+        array = set.getCharRanges();\n+        assertEquals(\"[a]\", set.toString());\n+        assertEquals(1, array.length);\n+        assertEquals(\"a\", array[0].toString());\n+        \n+        set = CharSet.getInstance(\"^a\");\n+        array = set.getCharRanges();\n+        assertEquals(\"[^a]\", set.toString());\n+        assertEquals(1, array.length);\n+        assertEquals(\"^a\", array[0].toString());\n+        \n+        set = CharSet.getInstance(\"a-e\");\n+        array = set.getCharRanges();\n+        assertEquals(\"[a-e]\", set.toString());\n+        assertEquals(1, array.length);\n+        assertEquals(\"a-e\", array[0].toString());\n+        \n+        set = CharSet.getInstance(\"^a-e\");\n+        array = set.getCharRanges();\n+        assertEquals(\"[^a-e]\", set.toString());\n+        assertEquals(1, array.length);\n+        assertEquals(\"^a-e\", array[0].toString());\n+    }\n+    \n+    public void testConstructor_String_combo() {\n+        CharSet set;\n+        CharRange[] array;\n+        \n+        set = CharSet.getInstance(\"abc\");\n+        array = set.getCharRanges();\n+        assertEquals(3, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('a')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('b')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('c')));\n+        \n+        set = CharSet.getInstance(\"a-ce-f\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isIn('a', 'c')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isIn('e', 'f')));\n+        \n+        set = CharSet.getInstance(\"ae-f\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('a')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isIn('e', 'f')));\n+        \n+        set = CharSet.getInstance(\"e-fa\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('a')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isIn('e', 'f')));\n+        \n+        set = CharSet.getInstance(\"ae-fm-pz\");\n+        array = set.getCharRanges();\n+        assertEquals(4, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('a')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isIn('e', 'f')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isIn('m', 'p')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('z')));\n+    }\n+    \n+    public void testConstructor_String_comboNegated() {\n+        CharSet set;\n+        CharRange[] array;\n+        \n+        set = CharSet.getInstance(\"^abc\");\n+        array = set.getCharRanges();\n+        assertEquals(3, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isNot('a')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('b')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('c')));\n+        \n+        set = CharSet.getInstance(\"b^ac\");\n+        array = set.getCharRanges();\n+        assertEquals(3, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('b')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isNot('a')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('c')));\n+        \n+        set = CharSet.getInstance(\"db^ac\");\n+        array = set.getCharRanges();\n+        assertEquals(4, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('d')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('b')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isNot('a')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('c')));\n+        \n+        set = CharSet.getInstance(\"^b^a\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isNot('b')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isNot('a')));\n+        \n+        set = CharSet.getInstance(\"b^a-c^z\");\n+        array = set.getCharRanges();\n+        assertEquals(3, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isNotIn('a', 'c')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isNot('z')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('b')));\n+    }\n+\n+    public void testConstructor_String_oddDash() {\n+        CharSet set;\n+        CharRange[] array;\n+        \n+        set = CharSet.getInstance(\"-\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('-')));\n+        \n+        set = CharSet.getInstance(\"--\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('-')));\n+        \n+        set = CharSet.getInstance(\"---\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('-')));\n+        \n+        set = CharSet.getInstance(\"----\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('-')));\n+        \n+        set = CharSet.getInstance(\"-a\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('-')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('a')));\n+        \n+        set = CharSet.getInstance(\"a-\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('a')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('-')));\n+        \n+        set = CharSet.getInstance(\"a--\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isIn('a', '-')));\n+        \n+        set = CharSet.getInstance(\"--a\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isIn('-', 'a')));\n+    }\n+    \n+    public void testConstructor_String_oddNegate() {\n+        CharSet set;\n+        CharRange[] array;\n+        set = CharSet.getInstance(\"^\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('^'))); // \"^\"\n+        \n+        set = CharSet.getInstance(\"^^\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isNot('^'))); // \"^^\"\n+        \n+        set = CharSet.getInstance(\"^^^\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isNot('^'))); // \"^^\"\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('^'))); // \"^\"\n+        \n+        set = CharSet.getInstance(\"^^^^\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isNot('^'))); // \"^^\" x2\n+        \n+        set = CharSet.getInstance(\"a^\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('a'))); // \"a\"\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('^'))); // \"^\"\n+        \n+        set = CharSet.getInstance(\"^a-\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isNot('a'))); // \"^a\"\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('-'))); // \"-\"\n+        \n+        set = CharSet.getInstance(\"^^-c\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isNotIn('^', 'c'))); // \"^^-c\"\n+        \n+        set = CharSet.getInstance(\"^c-^\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isNotIn('c', '^'))); // \"^c-^\"\n+        \n+        set = CharSet.getInstance(\"^c-^d\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isNotIn('c', '^'))); // \"^c-^\"\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('d'))); // \"d\"\n+        \n+        set = CharSet.getInstance(\"^^-\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isNot('^'))); // \"^^\"\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('-'))); // \"-\"\n+    }\n+    \n+    public void testConstructor_String_oddCombinations() {\n+        CharSet set;\n+        CharRange[] array = null;\n+        \n+        set = CharSet.getInstance(\"a-^c\");\n+        array = set.getCharRanges();\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isIn('a', '^'))); // \"a-^\"\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('c'))); // \"c\"\n+        assertEquals(false, set.contains('b'));\n+        assertEquals(true, set.contains('^'));  \n+        assertEquals(true, set.contains('_')); // between ^ and a\n+        assertEquals(true, set.contains('c'));  \n+        \n+        set = CharSet.getInstance(\"^a-^c\");\n+        array = set.getCharRanges();\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isNotIn('a', '^'))); // \"^a-^\"\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.is('c'))); // \"c\"\n+        assertEquals(true, set.contains('b'));\n+        assertEquals(false, set.contains('^'));  \n+        assertEquals(false, set.contains('_')); // between ^ and a\n+        \n+        set = CharSet.getInstance(\"a- ^-- \"); //contains everything\n+        array = set.getCharRanges();\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isIn('a', ' '))); // \"a- \"\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isNotIn('-', ' '))); // \"^-- \"\n+        assertEquals(true, set.contains('#'));\n+        assertEquals(true, set.contains('^'));\n+        assertEquals(true, set.contains('a'));\n+        assertEquals(true, set.contains('*'));\n+        assertEquals(true, set.contains('A'));\n+        \n+        set = CharSet.getInstance(\"^-b\");\n+        array = set.getCharRanges();\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isIn('^','b'))); // \"^-b\"\n+        assertEquals(true, set.contains('b'));\n+        assertEquals(true, set.contains('_')); // between ^ and a\n+        assertEquals(false, set.contains('A'));\n+        assertEquals(true, set.contains('^')); \n+        \n+        set = CharSet.getInstance(\"b-^\");\n+        array = set.getCharRanges();\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isIn('^','b'))); // \"b-^\"\n+        assertEquals(true, set.contains('b'));\n+        assertEquals(true, set.contains('^'));\n+        assertEquals(true, set.contains('a')); // between ^ and b\n+        assertEquals(false, set.contains('c')); \n+    }\n+        \n+    //-----------------------------------------------------------------------    \n+    public void testEquals_Object() {\n+        CharSet abc = CharSet.getInstance(\"abc\");\n+        CharSet abc2 = CharSet.getInstance(\"abc\");\n+        CharSet atoc = CharSet.getInstance(\"a-c\");\n+        CharSet atoc2 = CharSet.getInstance(\"a-c\");\n+        CharSet notatoc = CharSet.getInstance(\"^a-c\");\n+        CharSet notatoc2 = CharSet.getInstance(\"^a-c\");\n+        \n+        assertEquals(false, abc.equals(null));\n+        \n+        assertEquals(true, abc.equals(abc));\n+        assertEquals(true, abc.equals(abc2));\n+        assertEquals(false, abc.equals(atoc));\n+        assertEquals(false, abc.equals(notatoc));\n+        \n+        assertEquals(false, atoc.equals(abc));\n+        assertEquals(true, atoc.equals(atoc));\n+        assertEquals(true, atoc.equals(atoc2));\n+        assertEquals(false, atoc.equals(notatoc));\n+        \n+        assertEquals(false, notatoc.equals(abc));\n+        assertEquals(false, notatoc.equals(atoc));\n+        assertEquals(true, notatoc.equals(notatoc));\n+        assertEquals(true, notatoc.equals(notatoc2));\n+    }\n+            \n+    public void testHashCode() {\n+        CharSet abc = CharSet.getInstance(\"abc\");\n+        CharSet abc2 = CharSet.getInstance(\"abc\");\n+        CharSet atoc = CharSet.getInstance(\"a-c\");\n+        CharSet atoc2 = CharSet.getInstance(\"a-c\");\n+        CharSet notatoc = CharSet.getInstance(\"^a-c\");\n+        CharSet notatoc2 = CharSet.getInstance(\"^a-c\");\n+        \n+        assertEquals(abc.hashCode(), abc.hashCode());\n+        assertEquals(abc.hashCode(), abc2.hashCode());\n+        assertEquals(atoc.hashCode(), atoc.hashCode());\n+        assertEquals(atoc.hashCode(), atoc2.hashCode());\n+        assertEquals(notatoc.hashCode(), notatoc.hashCode());\n+        assertEquals(notatoc.hashCode(), notatoc2.hashCode());\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    public void testContains_Char() {\n+        CharSet btod = CharSet.getInstance(\"b-d\");\n+        CharSet dtob = CharSet.getInstance(\"d-b\");\n+        CharSet bcd = CharSet.getInstance(\"bcd\");\n+        CharSet bd = CharSet.getInstance(\"bd\");\n+        CharSet notbtod = CharSet.getInstance(\"^b-d\");\n+        \n+        assertEquals(false, btod.contains('a'));\n+        assertEquals(true, btod.contains('b'));\n+        assertEquals(true, btod.contains('c'));\n+        assertEquals(true, btod.contains('d'));\n+        assertEquals(false, btod.contains('e'));\n+        \n+        assertEquals(false, bcd.contains('a'));\n+        assertEquals(true, bcd.contains('b'));\n+        assertEquals(true, bcd.contains('c'));\n+        assertEquals(true, bcd.contains('d'));\n+        assertEquals(false, bcd.contains('e'));\n+        \n+        assertEquals(false, bd.contains('a'));\n+        assertEquals(true, bd.contains('b'));\n+        assertEquals(false, bd.contains('c'));\n+        assertEquals(true, bd.contains('d'));\n+        assertEquals(false, bd.contains('e'));\n+        \n+        assertEquals(true, notbtod.contains('a'));\n+        assertEquals(false, notbtod.contains('b'));\n+        assertEquals(false, notbtod.contains('c'));\n+        assertEquals(false, notbtod.contains('d'));\n+        assertEquals(true, notbtod.contains('e'));\n+        \n+        assertEquals(false, dtob.contains('a'));\n+        assertEquals(true, dtob.contains('b'));\n+        assertEquals(true, dtob.contains('c'));\n+        assertEquals(true, dtob.contains('d'));\n+        assertEquals(false, dtob.contains('e'));\n+      \n+        CharRange[] array = dtob.getCharRanges();\n+        assertEquals(\"[b-d]\", dtob.toString());\n+        assertEquals(1, array.length);\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    public void testSerialization() {\n+        CharSet set = CharSet.getInstance(\"a\");\n+        assertEquals(set, SerializationUtils.clone(set)); \n+        set = CharSet.getInstance(\"a-e\");\n+        assertEquals(set, SerializationUtils.clone(set)); \n+        set = CharSet.getInstance(\"be-f^a-z\");\n+        assertEquals(set, SerializationUtils.clone(set)); \n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    public void testStatics() {\n+        CharRange[] array;\n+        \n+        array = CharSet.EMPTY.getCharRanges();\n+        assertEquals(0, array.length);\n+        \n+        array = CharSet.ASCII_ALPHA.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isIn('a', 'z')));\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isIn('A', 'Z')));\n+        \n+        array = CharSet.ASCII_ALPHA_LOWER.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isIn('a', 'z')));\n+        \n+        array = CharSet.ASCII_ALPHA_UPPER.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isIn('A', 'Z')));\n+        \n+        array = CharSet.ASCII_NUMERIC.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, CharRange.isIn('0', '9')));\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/CharSetUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.CharSetUtils}.\n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @author Gary D. Gregory\n+ * @version $Id$\n+ */\n+public class CharSetUtilsTest extends TestCase {\n+    \n+    public CharSetUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(CharSetUtilsTest.class);\n+        suite.setName(\"CharSetUtils Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new CharSetUtils());\n+        Constructor<?>[] cons = CharSetUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(CharSetUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(CharSetUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testSqueeze_StringString() {\n+        assertEquals(null, CharSetUtils.squeeze(null, (String) null));\n+        assertEquals(null, CharSetUtils.squeeze(null, \"\"));\n+        \n+        assertEquals(\"\", CharSetUtils.squeeze(\"\", (String) null));\n+        assertEquals(\"\", CharSetUtils.squeeze(\"\", \"\"));\n+        assertEquals(\"\", CharSetUtils.squeeze(\"\", \"a-e\"));\n+        \n+        assertEquals(\"hello\", CharSetUtils.squeeze(\"hello\", (String) null));\n+        assertEquals(\"hello\", CharSetUtils.squeeze(\"hello\", \"\"));\n+        assertEquals(\"hello\", CharSetUtils.squeeze(\"hello\", \"a-e\"));\n+        assertEquals(\"helo\", CharSetUtils.squeeze(\"hello\", \"l-p\"));\n+        assertEquals(\"heloo\", CharSetUtils.squeeze(\"helloo\", \"l\"));\n+        assertEquals(\"hello\", CharSetUtils.squeeze(\"helloo\", \"^l\"));\n+    }\n+    \n+    public void testSqueeze_StringStringarray() {\n+        assertEquals(null, CharSetUtils.squeeze(null, (String[]) null));\n+        assertEquals(null, CharSetUtils.squeeze(null, new String[0]));\n+        assertEquals(null, CharSetUtils.squeeze(null, new String[] {null}));\n+        assertEquals(null, CharSetUtils.squeeze(null, new String[] {\"el\"}));\n+        \n+        assertEquals(\"\", CharSetUtils.squeeze(\"\", (String[]) null));\n+        assertEquals(\"\", CharSetUtils.squeeze(\"\", new String[0]));\n+        assertEquals(\"\", CharSetUtils.squeeze(\"\", new String[] {null}));\n+        assertEquals(\"\", CharSetUtils.squeeze(\"\", new String[] {\"a-e\"}));\n+        \n+        assertEquals(\"hello\", CharSetUtils.squeeze(\"hello\", (String[]) null));\n+        assertEquals(\"hello\", CharSetUtils.squeeze(\"hello\", new String[0]));\n+        assertEquals(\"hello\", CharSetUtils.squeeze(\"hello\", new String[] {null}));\n+        assertEquals(\"hello\", CharSetUtils.squeeze(\"hello\", new String[] {\"a-e\"}));\n+        \n+        assertEquals(\"helo\", CharSetUtils.squeeze(\"hello\", new String[] { \"el\" }));\n+        assertEquals(\"hello\", CharSetUtils.squeeze(\"hello\", new String[] { \"e\" }));\n+        assertEquals(\"fofof\", CharSetUtils.squeeze(\"fooffooff\", new String[] { \"of\" }));\n+        assertEquals(\"fof\", CharSetUtils.squeeze(\"fooooff\", new String[] { \"fo\" }));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCount_StringString() {\n+        assertEquals(0, CharSetUtils.count(null, (String) null));\n+        assertEquals(0, CharSetUtils.count(null, \"\"));\n+        \n+        assertEquals(0, CharSetUtils.count(\"\", (String) null));\n+        assertEquals(0, CharSetUtils.count(\"\", \"\"));\n+        assertEquals(0, CharSetUtils.count(\"\", \"a-e\"));\n+        \n+        assertEquals(0, CharSetUtils.count(\"hello\", (String) null));\n+        assertEquals(0, CharSetUtils.count(\"hello\", \"\"));\n+        assertEquals(1, CharSetUtils.count(\"hello\", \"a-e\"));\n+        assertEquals(3, CharSetUtils.count(\"hello\", \"l-p\"));\n+    }\n+    \n+    public void testCount_StringStringarray() {\n+        assertEquals(0, CharSetUtils.count(null, (String[]) null));\n+        assertEquals(0, CharSetUtils.count(null, new String[0]));\n+        assertEquals(0, CharSetUtils.count(null, new String[] {null}));\n+        assertEquals(0, CharSetUtils.count(null, new String[] {\"a-e\"}));\n+        \n+        assertEquals(0, CharSetUtils.count(\"\", (String[]) null));\n+        assertEquals(0, CharSetUtils.count(\"\", new String[0]));\n+        assertEquals(0, CharSetUtils.count(\"\", new String[] {null}));\n+        assertEquals(0, CharSetUtils.count(\"\", new String[] {\"a-e\"}));\n+        \n+        assertEquals(0, CharSetUtils.count(\"hello\", (String[]) null));\n+        assertEquals(0, CharSetUtils.count(\"hello\", new String[0]));\n+        assertEquals(0, CharSetUtils.count(\"hello\", new String[] {null}));\n+        assertEquals(1, CharSetUtils.count(\"hello\", new String[] {\"a-e\"}));\n+        \n+        assertEquals(3, CharSetUtils.count(\"hello\", new String[] { \"el\" }));\n+        assertEquals(0, CharSetUtils.count(\"hello\", new String[] { \"x\" }));\n+        assertEquals(2, CharSetUtils.count(\"hello\", new String[] { \"e-i\" }));\n+        assertEquals(5, CharSetUtils.count(\"hello\", new String[] { \"a-z\" }));\n+        assertEquals(0, CharSetUtils.count(\"hello\", new String[] { \"\" }));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testKeep_StringString() {\n+        assertEquals(null, CharSetUtils.keep(null, (String) null));\n+        assertEquals(null, CharSetUtils.keep(null, \"\"));\n+        \n+        assertEquals(\"\", CharSetUtils.keep(\"\", (String) null));\n+        assertEquals(\"\", CharSetUtils.keep(\"\", \"\"));\n+        assertEquals(\"\", CharSetUtils.keep(\"\", \"a-e\"));\n+        \n+        assertEquals(\"\", CharSetUtils.keep(\"hello\", (String) null));\n+        assertEquals(\"\", CharSetUtils.keep(\"hello\", \"\"));\n+        assertEquals(\"\", CharSetUtils.keep(\"hello\", \"xyz\"));\n+        assertEquals(\"hello\", CharSetUtils.keep(\"hello\", \"a-z\"));\n+        assertEquals(\"hello\", CharSetUtils.keep(\"hello\", \"oleh\"));\n+        assertEquals(\"ell\", CharSetUtils.keep(\"hello\", \"el\"));\n+    }\n+    \n+    public void testKeep_StringStringarray() {\n+        assertEquals(null, CharSetUtils.keep(null, (String[]) null));\n+        assertEquals(null, CharSetUtils.keep(null, new String[0]));\n+        assertEquals(null, CharSetUtils.keep(null, new String[] {null}));\n+        assertEquals(null, CharSetUtils.keep(null, new String[] {\"a-e\"}));\n+        \n+        assertEquals(\"\", CharSetUtils.keep(\"\", (String[]) null));\n+        assertEquals(\"\", CharSetUtils.keep(\"\", new String[0]));\n+        assertEquals(\"\", CharSetUtils.keep(\"\", new String[] {null}));\n+        assertEquals(\"\", CharSetUtils.keep(\"\", new String[] {\"a-e\"}));\n+        \n+        assertEquals(\"\", CharSetUtils.keep(\"hello\", (String[]) null));\n+        assertEquals(\"\", CharSetUtils.keep(\"hello\", new String[0]));\n+        assertEquals(\"\", CharSetUtils.keep(\"hello\", new String[] {null}));\n+        assertEquals(\"e\", CharSetUtils.keep(\"hello\", new String[] {\"a-e\"}));\n+        \n+        assertEquals(\"e\", CharSetUtils.keep(\"hello\", new String[] { \"a-e\" }));\n+        assertEquals(\"ell\", CharSetUtils.keep(\"hello\", new String[] { \"el\" }));\n+        assertEquals(\"hello\", CharSetUtils.keep(\"hello\", new String[] { \"elho\" }));\n+        assertEquals(\"hello\", CharSetUtils.keep(\"hello\", new String[] { \"a-z\" }));\n+        assertEquals(\"----\", CharSetUtils.keep(\"----\", new String[] { \"-\" }));\n+        assertEquals(\"ll\", CharSetUtils.keep(\"hello\", new String[] { \"l\" }));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDelete_StringString() {\n+        assertEquals(null, CharSetUtils.delete(null, (String) null));\n+        assertEquals(null, CharSetUtils.delete(null, \"\"));\n+        \n+        assertEquals(\"\", CharSetUtils.delete(\"\", (String) null));\n+        assertEquals(\"\", CharSetUtils.delete(\"\", \"\"));\n+        assertEquals(\"\", CharSetUtils.delete(\"\", \"a-e\"));\n+        \n+        assertEquals(\"hello\", CharSetUtils.delete(\"hello\", (String) null));\n+        assertEquals(\"hello\", CharSetUtils.delete(\"hello\", \"\"));\n+        assertEquals(\"hllo\", CharSetUtils.delete(\"hello\", \"a-e\"));\n+        assertEquals(\"he\", CharSetUtils.delete(\"hello\", \"l-p\"));\n+        assertEquals(\"hello\", CharSetUtils.delete(\"hello\", \"z\"));\n+    }\n+    \n+    public void testDelete_StringStringarray() {\n+        assertEquals(null, CharSetUtils.delete(null, (String[]) null));\n+        assertEquals(null, CharSetUtils.delete(null, new String[0]));\n+        assertEquals(null, CharSetUtils.delete(null, new String[] {null}));\n+        assertEquals(null, CharSetUtils.delete(null, new String[] {\"el\"}));\n+        \n+        assertEquals(\"\", CharSetUtils.delete(\"\", (String[]) null));\n+        assertEquals(\"\", CharSetUtils.delete(\"\", new String[0]));\n+        assertEquals(\"\", CharSetUtils.delete(\"\", new String[] {null}));\n+        assertEquals(\"\", CharSetUtils.delete(\"\", new String[] {\"a-e\"}));\n+        \n+        assertEquals(\"hello\", CharSetUtils.delete(\"hello\", (String[]) null));\n+        assertEquals(\"hello\", CharSetUtils.delete(\"hello\", new String[0]));\n+        assertEquals(\"hello\", CharSetUtils.delete(\"hello\", new String[] {null}));\n+        assertEquals(\"hello\", CharSetUtils.delete(\"hello\", new String[] {\"xyz\"}));\n+\n+        assertEquals(\"ho\", CharSetUtils.delete(\"hello\", new String[] { \"el\" }));\n+        assertEquals(\"\", CharSetUtils.delete(\"hello\", new String[] { \"elho\" }));\n+        assertEquals(\"hello\", CharSetUtils.delete(\"hello\", new String[] { \"\" }));\n+        assertEquals(\"hello\", CharSetUtils.delete(\"hello\", \"\"));\n+        assertEquals(\"\", CharSetUtils.delete(\"hello\", new String[] { \"a-z\" }));\n+        assertEquals(\"\", CharSetUtils.delete(\"----\", new String[] { \"-\" }));\n+        assertEquals(\"heo\", CharSetUtils.delete(\"hello\", new String[] { \"l\" }));\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/CharUtilsPerfRun.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang;\n+\n+import java.text.NumberFormat;\n+import java.util.Calendar;\n+\n+/**\n+ * Tests the difference in performance between CharUtils and CharSet.\n+ * \n+ * Sample runs:\n+\n+Now: Thu Mar 18 14:29:48 PST 2004\n+Sun Microsystems Inc. Java(TM) 2 Runtime Environment, Standard Edition 1.3.1_10-b03\n+Sun Microsystems Inc. Java HotSpot(TM) Client VM 1.3.1_10-b03\n+Windows XP 5.1 x86 pentium i486 i386\n+Do nohting: 0 milliseconds.\n+run_CharUtils_isAsciiNumeric: 4,545 milliseconds.\n+run_inlined_CharUtils_isAsciiNumeric: 3,417 milliseconds.\n+run_inlined_CharUtils_isAsciiNumeric: 85,679 milliseconds.\n+\n+\n+Now: Thu Mar 18 14:24:51 PST 2004\n+Sun Microsystems Inc. Java(TM) 2 Runtime Environment, Standard Edition 1.4.2_04-b05\n+Sun Microsystems Inc. Java HotSpot(TM) Client VM 1.4.2_04-b05\n+Windows XP 5.1 x86 pentium i486 i386\n+Do nohting: 0 milliseconds.\n+run_CharUtils_isAsciiNumeric: 2,578 milliseconds.\n+run_inlined_CharUtils_isAsciiNumeric: 2,477 milliseconds.\n+run_inlined_CharUtils_isAsciiNumeric: 114,429 milliseconds.\n+\n+Now: Thu Mar 18 14:27:55 PST 2004\n+Sun Microsystems Inc. Java(TM) 2 Runtime Environment, Standard Edition 1.4.2_04-b05\n+Sun Microsystems Inc. Java HotSpot(TM) Server VM 1.4.2_04-b05\n+Windows XP 5.1 x86 pentium i486 i386\n+Do nohting: 0 milliseconds.\n+run_CharUtils_isAsciiNumeric: 630 milliseconds.\n+run_inlined_CharUtils_isAsciiNumeric: 709 milliseconds.\n+run_inlined_CharUtils_isAsciiNumeric: 84,420 milliseconds.\n+\n+\n+ * @version $Id$\n+ */\n+public class CharUtilsPerfRun {\n+    final static String VERSION = \"$Id$\";\n+\n+    final static int WARM_UP = 100;\n+\n+    final static int COUNT = 5000;\n+\n+    final static char[] CHAR_SAMPLES;\n+    static {\n+        CHAR_SAMPLES = new char[Character.MAX_VALUE];\n+        for (char i = Character.MIN_VALUE; i < Character.MAX_VALUE; i++) {\n+            CHAR_SAMPLES[i] = i;\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new CharUtilsPerfRun().run();\n+    }\n+\n+    private void printSysInfo() {\n+        System.out.println(VERSION);\n+        System.out.println(\"Now: \" + Calendar.getInstance().getTime());\n+        System.out.println(System.getProperty(\"java.vendor\")\n+                + \" \"\n+                + System.getProperty(\"java.runtime.name\")\n+                + \" \"\n+                + System.getProperty(\"java.runtime.version\"));\n+        System.out.println(System.getProperty(\"java.vm.vendor\")\n+                + \" \"\n+                + System.getProperty(\"java.vm.name\")\n+                + \" \"\n+                + System.getProperty(\"java.vm.version\"));\n+        System.out.println(System.getProperty(\"os.name\")\n+            + \" \"\n+            + System.getProperty(\"os.version\")\n+            + \" \"\n+            + System.getProperty(\"os.arch\")\n+            + \" \"\n+            + System.getProperty(\"sun.cpu.isalist\"));\n+    }\n+\n+    private void run() {\n+        this.printSysInfo();\n+        long start;\n+        start = System.currentTimeMillis();\n+        this.printlnTotal(\"Do nohting\", start);\n+        //System.out.println(\"Warming up...\");\n+        run_CharUtils_isAsciiNumeric(WARM_UP);\n+        //System.out.println(\"Measuring...\");\n+        start = System.currentTimeMillis();\n+        run_CharUtils_isAsciiNumeric(COUNT);\n+        this.printlnTotal(\"run_CharUtils_isAsciiNumeric\", start);\n+        //System.out.println(\"Warming up...\");\n+        run_inlined_CharUtils_isAsciiNumeric(WARM_UP);\n+        //System.out.println(\"Measuring...\");\n+        start = System.currentTimeMillis();\n+        run_inlined_CharUtils_isAsciiNumeric(COUNT);\n+        this.printlnTotal(\"run_inlined_CharUtils_isAsciiNumeric\", start);\n+        //System.out.println(\"Warming up...\");\n+        run_CharSet(WARM_UP);\n+        //System.out.println(\"Measuring...\");\n+        start = System.currentTimeMillis();\n+        run_CharSet(COUNT);\n+        this.printlnTotal(\"run_CharSet\", start);\n+    }\n+\n+    private int run_CharSet(int loopCount) {\n+        int t = 0;\n+        for (int i = 0; i < loopCount; i++) {\n+            for (int j = 0; j < CHAR_SAMPLES.length; j++) {\n+                char ch = CHAR_SAMPLES[j];\n+                boolean b = CharSet.ASCII_NUMERIC.contains(ch);\n+                t += b ? 1 : 0;\n+            }\n+        }\n+        return t;\n+    }\n+\n+    private int run_CharUtils_isAsciiNumeric(int loopCount) {\n+        int t = 0;\n+        for (int i = 0; i < loopCount; i++) {\n+            for (int j = 0; j < CHAR_SAMPLES.length; j++) {\n+                char ch = CHAR_SAMPLES[j];\n+                boolean b = CharUtils.isAsciiNumeric(ch);\n+                t += b ? 1 : 0;\n+            }\n+        }\n+        return t;\n+    }\n+\n+    private int run_inlined_CharUtils_isAsciiNumeric(int loopCount) {\n+        int t = 0;\n+        for (int i = 0; i < loopCount; i++) {\n+            for (int j = 0; j < CHAR_SAMPLES.length; j++) {\n+                char ch = CHAR_SAMPLES[j];\n+                boolean b = (ch >= '0' && ch <= '9');\n+                t += b ? 1 : 0;\n+            }\n+        }\n+        return t;\n+    }\n+\n+    private void printlnTotal(String prefix, long start) {\n+        long total = System.currentTimeMillis() - start;\n+        System.out.println(prefix + \": \" + NumberFormat.getInstance().format(total) + \" milliseconds.\");\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/CharUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.CharUtils}.\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class CharUtilsTest extends TestCase {\n+\n+    private static final Character CHARACTER_A = new Character('A');\n+    private static final Character CHARACTER_B = new Character('B');\n+    private static final char CHAR_COPY = '\\u00a9';\n+    \n+    public CharUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(CharUtilsTest.class);\n+        suite.setName(\"CharUtils Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new CharUtils());\n+        Constructor<?>[] cons = CharUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(BooleanUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(BooleanUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testToCharacterObject_char() {\n+        assertEquals(new Character('a'), CharUtils.toCharacterObject('a'));\n+        assertSame(CharUtils.toCharacterObject('a'), CharUtils.toCharacterObject('a'));\n+       \n+        for (int i = 0; i < 128; i++) {\n+            Character ch = CharUtils.toCharacterObject((char) i);\n+            Character ch2 = CharUtils.toCharacterObject((char) i);\n+            assertSame(ch, ch2);\n+            assertEquals(i, ch.charValue());\n+        }\n+        for (int i = 128; i < 196; i++) {\n+            Character ch = CharUtils.toCharacterObject((char) i);\n+            Character ch2 = CharUtils.toCharacterObject((char) i);\n+            assertEquals(ch, ch2);\n+            assertTrue(ch != ch2);\n+            assertEquals(i, ch.charValue());\n+            assertEquals(i, ch2.charValue());\n+        }\n+    }\n+    \n+    public void testToCharacterObject_String() {\n+        assertEquals(null, CharUtils.toCharacterObject(null));\n+        assertEquals(null, CharUtils.toCharacterObject(\"\"));\n+        assertEquals(new Character('a'), CharUtils.toCharacterObject(\"a\"));\n+        assertEquals(new Character('a'), CharUtils.toCharacterObject(\"abc\"));\n+        assertSame(CharUtils.toCharacterObject(\"a\"), CharUtils.toCharacterObject(\"a\"));\n+        assertSame(CharUtils.toCharacterObject(\"a\"), CharUtils.toCharacterObject('a'));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testToChar_Character() {\n+        assertEquals('A', CharUtils.toChar(CHARACTER_A));\n+        assertEquals('B', CharUtils.toChar(CHARACTER_B));\n+        try {\n+            CharUtils.toChar((Character) null);\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void testToChar_Character_char() {\n+        assertEquals('A', CharUtils.toChar(CHARACTER_A, 'X'));\n+        assertEquals('B', CharUtils.toChar(CHARACTER_B, 'X'));\n+        assertEquals('X', CharUtils.toChar((Character) null, 'X'));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testToChar_String() {\n+        assertEquals('A', CharUtils.toChar(\"A\"));\n+        assertEquals('B', CharUtils.toChar(\"BA\"));\n+        try {\n+            CharUtils.toChar((String) null);\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            CharUtils.toChar(\"\");\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void testToChar_String_char() {\n+        assertEquals('A', CharUtils.toChar(\"A\", 'X'));\n+        assertEquals('B', CharUtils.toChar(\"BA\", 'X'));\n+        assertEquals('X', CharUtils.toChar(\"\", 'X'));\n+        assertEquals('X', CharUtils.toChar((String) null, 'X'));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testToIntValue_char() {\n+        assertEquals(0, CharUtils.toIntValue('0'));\n+        assertEquals(1, CharUtils.toIntValue('1'));\n+        assertEquals(2, CharUtils.toIntValue('2'));\n+        assertEquals(3, CharUtils.toIntValue('3'));\n+        assertEquals(4, CharUtils.toIntValue('4'));\n+        assertEquals(5, CharUtils.toIntValue('5'));\n+        assertEquals(6, CharUtils.toIntValue('6'));\n+        assertEquals(7, CharUtils.toIntValue('7'));\n+        assertEquals(8, CharUtils.toIntValue('8'));\n+        assertEquals(9, CharUtils.toIntValue('9'));\n+        try {\n+            CharUtils.toIntValue('a');\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void testToIntValue_char_int() {\n+        assertEquals(0, CharUtils.toIntValue('0', -1));\n+        assertEquals(3, CharUtils.toIntValue('3', -1));\n+        assertEquals(-1, CharUtils.toIntValue('a', -1));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testToIntValue_Character() {\n+        assertEquals(0, CharUtils.toIntValue(new Character('0')));\n+        assertEquals(3, CharUtils.toIntValue(new Character('3')));\n+        try {\n+            CharUtils.toIntValue(null);\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            CharUtils.toIntValue(CHARACTER_A);\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void testToIntValue_Character_int() {\n+        assertEquals(0, CharUtils.toIntValue(new Character('0'), -1));\n+        assertEquals(3, CharUtils.toIntValue(new Character('3'), -1));\n+        assertEquals(-1, CharUtils.toIntValue(new Character('A'), -1));\n+        assertEquals(-1, CharUtils.toIntValue(null, -1));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testToString_char() {\n+        assertEquals(\"a\", CharUtils.toString('a'));\n+        assertSame(CharUtils.toString('a'), CharUtils.toString('a'));\n+       \n+        for (int i = 0; i < 128; i++) {\n+            String str = CharUtils.toString((char) i);\n+            String str2 = CharUtils.toString((char) i);\n+            assertSame(str, str2);\n+            assertEquals(1, str.length());\n+            assertEquals(i, str.charAt(0));\n+        }\n+        for (int i = 128; i < 196; i++) {\n+            String str = CharUtils.toString((char) i);\n+            String str2 = CharUtils.toString((char) i);\n+            assertEquals(str, str2);\n+            assertTrue(str != str2);\n+            assertEquals(1, str.length());\n+            assertEquals(i, str.charAt(0));\n+            assertEquals(1, str2.length());\n+            assertEquals(i, str2.charAt(0));\n+        }\n+    }\n+    \n+    public void testToString_Character() {\n+        assertEquals(null, CharUtils.toString(null));\n+        assertEquals(\"A\", CharUtils.toString(CHARACTER_A));\n+        assertSame(CharUtils.toString(CHARACTER_A), CharUtils.toString(CHARACTER_A));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testToUnicodeEscaped_char() {\n+        assertEquals(\"\\\\u0041\", CharUtils.unicodeEscaped('A'));\n+       \n+        for (int i = 0; i < 196; i++) {\n+            String str = CharUtils.unicodeEscaped((char) i);\n+            assertEquals(6, str.length());\n+            int val = Integer.parseInt(str.substring(2), 16);\n+            assertEquals(i, val);\n+        }\n+        assertEquals(\"\\\\u0999\", CharUtils.unicodeEscaped((char) 0x999));\n+        assertEquals(\"\\\\u1001\", CharUtils.unicodeEscaped((char) 0x1001));\n+    }\n+    \n+    public void testToUnicodeEscaped_Character() {\n+        assertEquals(null, CharUtils.unicodeEscaped(null));\n+        assertEquals(\"\\\\u0041\", CharUtils.unicodeEscaped(CHARACTER_A));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAscii_char() {\n+        assertEquals(true, CharUtils.isAscii('a'));\n+        assertEquals(true, CharUtils.isAscii('A'));\n+        assertEquals(true, CharUtils.isAscii('3'));\n+        assertEquals(true, CharUtils.isAscii('-'));\n+        assertEquals(true, CharUtils.isAscii('\\n'));\n+        assertEquals(false, CharUtils.isAscii(CHAR_COPY));\n+       \n+        for (int i = 0; i < 128; i++) {\n+            if (i < 128) {\n+                assertEquals(true, CharUtils.isAscii((char) i));\n+            } else {\n+                assertEquals(false, CharUtils.isAscii((char) i));\n+            }\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAsciiPrintable_char() {\n+        assertEquals(true, CharUtils.isAsciiPrintable('a'));\n+        assertEquals(true, CharUtils.isAsciiPrintable('A'));\n+        assertEquals(true, CharUtils.isAsciiPrintable('3'));\n+        assertEquals(true, CharUtils.isAsciiPrintable('-'));\n+        assertEquals(false, CharUtils.isAsciiPrintable('\\n'));\n+        assertEquals(false, CharUtils.isAscii(CHAR_COPY));\n+       \n+        for (int i = 0; i < 196; i++) {\n+            if (i >= 32 && i <= 126) {\n+                assertEquals(true, CharUtils.isAsciiPrintable((char) i));\n+            } else {\n+                assertEquals(false, CharUtils.isAsciiPrintable((char) i));\n+            }\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAsciiControl_char() {\n+        assertEquals(false, CharUtils.isAsciiControl('a'));\n+        assertEquals(false, CharUtils.isAsciiControl('A'));\n+        assertEquals(false, CharUtils.isAsciiControl('3'));\n+        assertEquals(false, CharUtils.isAsciiControl('-'));\n+        assertEquals(true, CharUtils.isAsciiControl('\\n'));\n+        assertEquals(false, CharUtils.isAsciiControl(CHAR_COPY));\n+       \n+        for (int i = 0; i < 196; i++) {\n+            if (i < 32 || i == 127) {\n+                assertEquals(true, CharUtils.isAsciiControl((char) i));\n+            } else {\n+                assertEquals(false, CharUtils.isAsciiControl((char) i));\n+            }\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAsciiAlpha_char() {\n+        assertEquals(true, CharUtils.isAsciiAlpha('a'));\n+        assertEquals(true, CharUtils.isAsciiAlpha('A'));\n+        assertEquals(false, CharUtils.isAsciiAlpha('3'));\n+        assertEquals(false, CharUtils.isAsciiAlpha('-'));\n+        assertEquals(false, CharUtils.isAsciiAlpha('\\n'));\n+        assertEquals(false, CharUtils.isAsciiAlpha(CHAR_COPY));\n+       \n+        for (int i = 0; i < 196; i++) {\n+            if ((i >= 'A' && i <= 'Z') || (i >= 'a' && i <= 'z')) {\n+                assertEquals(true, CharUtils.isAsciiAlpha((char) i));\n+            } else {\n+                assertEquals(false, CharUtils.isAsciiAlpha((char) i));\n+            }\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAsciiAlphaUpper_char() {\n+        assertEquals(false, CharUtils.isAsciiAlphaUpper('a'));\n+        assertEquals(true, CharUtils.isAsciiAlphaUpper('A'));\n+        assertEquals(false, CharUtils.isAsciiAlphaUpper('3'));\n+        assertEquals(false, CharUtils.isAsciiAlphaUpper('-'));\n+        assertEquals(false, CharUtils.isAsciiAlphaUpper('\\n'));\n+        assertEquals(false, CharUtils.isAsciiAlphaUpper(CHAR_COPY));\n+       \n+        for (int i = 0; i < 196; i++) {\n+            if (i >= 'A' && i <= 'Z') {\n+                assertEquals(true, CharUtils.isAsciiAlphaUpper((char) i));\n+            } else {\n+                assertEquals(false, CharUtils.isAsciiAlphaUpper((char) i));\n+            }\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAsciiAlphaLower_char() {\n+        assertEquals(true, CharUtils.isAsciiAlphaLower('a'));\n+        assertEquals(false, CharUtils.isAsciiAlphaLower('A'));\n+        assertEquals(false, CharUtils.isAsciiAlphaLower('3'));\n+        assertEquals(false, CharUtils.isAsciiAlphaLower('-'));\n+        assertEquals(false, CharUtils.isAsciiAlphaLower('\\n'));\n+        assertEquals(false, CharUtils.isAsciiAlphaLower(CHAR_COPY));\n+       \n+        for (int i = 0; i < 196; i++) {\n+            if (i >= 'a' && i <= 'z') {\n+                assertEquals(true, CharUtils.isAsciiAlphaLower((char) i));\n+            } else {\n+                assertEquals(false, CharUtils.isAsciiAlphaLower((char) i));\n+            }\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAsciiNumeric_char() {\n+        assertEquals(false, CharUtils.isAsciiNumeric('a'));\n+        assertEquals(false, CharUtils.isAsciiNumeric('A'));\n+        assertEquals(true, CharUtils.isAsciiNumeric('3'));\n+        assertEquals(false, CharUtils.isAsciiNumeric('-'));\n+        assertEquals(false, CharUtils.isAsciiNumeric('\\n'));\n+        assertEquals(false, CharUtils.isAsciiNumeric(CHAR_COPY));\n+       \n+        for (int i = 0; i < 196; i++) {\n+            if (i >= '0' && i <= '9') {\n+                assertEquals(true, CharUtils.isAsciiNumeric((char) i));\n+            } else {\n+                assertEquals(false, CharUtils.isAsciiNumeric((char) i));\n+            }\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAsciiAlphanumeric_char() {\n+        assertEquals(true, CharUtils.isAsciiAlphanumeric('a'));\n+        assertEquals(true, CharUtils.isAsciiAlphanumeric('A'));\n+        assertEquals(true, CharUtils.isAsciiAlphanumeric('3'));\n+        assertEquals(false, CharUtils.isAsciiAlphanumeric('-'));\n+        assertEquals(false, CharUtils.isAsciiAlphanumeric('\\n'));\n+        assertEquals(false, CharUtils.isAsciiAlphanumeric(CHAR_COPY));\n+       \n+        for (int i = 0; i < 196; i++) {\n+            if ((i >= 'A' && i <= 'Z') || (i >= 'a' && i <= 'z') || (i >= '0' && i <= '9')) {\n+                assertEquals(true, CharUtils.isAsciiAlphanumeric((char) i));\n+            } else {\n+                assertEquals(false, CharUtils.isAsciiAlphanumeric((char) i));\n+            }\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/ClassUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.ClassUtils}.\n+ *\n+ * @author Apache Software Foundation\n+ * @author Gary D. Gregory\n+ * @author Tomasz Blachowicz\n+ * @version $Id$\n+ */\n+public class ClassUtilsTest extends TestCase {\n+\n+    public ClassUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ClassUtilsTest.class);\n+        suite.setName(\"ClassUtils Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    private static class Inner {\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new ClassUtils());\n+        Constructor<?>[] cons = ClassUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(ClassUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(ClassUtils.class.getModifiers()));\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    public void test_getShortClassName_Object() {\n+        assertEquals(\"ClassUtils\", ClassUtils.getShortClassName(new ClassUtils(), \"<null>\"));\n+        assertEquals(\"ClassUtilsTest.Inner\", ClassUtils.getShortClassName(new Inner(), \"<null>\"));\n+        assertEquals(\"String\", ClassUtils.getShortClassName(\"hello\", \"<null>\"));\n+        assertEquals(\"<null>\", ClassUtils.getShortClassName(null, \"<null>\"));\n+    }\n+    \n+    public void test_getShortClassName_Class() {\n+        assertEquals(\"ClassUtils\", ClassUtils.getShortClassName(ClassUtils.class));\n+        assertEquals(\"Map.Entry\", ClassUtils.getShortClassName(Map.Entry.class));\n+        assertEquals(\"\", ClassUtils.getShortClassName((Class<?>) null));\n+\n+        // LANG-535\n+        assertEquals(\"String[]\", ClassUtils.getShortClassName(String[].class));\n+        assertEquals(\"Map.Entry[]\", ClassUtils.getShortClassName(Map.Entry[].class));\n+\n+        // Primitives\n+        assertEquals(\"boolean\", ClassUtils.getShortClassName(boolean.class));\n+        assertEquals(\"byte\", ClassUtils.getShortClassName(byte.class));\n+        assertEquals(\"char\", ClassUtils.getShortClassName(char.class));\n+        assertEquals(\"short\", ClassUtils.getShortClassName(short.class));\n+        assertEquals(\"int\", ClassUtils.getShortClassName(int.class));\n+        assertEquals(\"long\", ClassUtils.getShortClassName(long.class));\n+        assertEquals(\"float\", ClassUtils.getShortClassName(float.class));\n+        assertEquals(\"double\", ClassUtils.getShortClassName(double.class));\n+\n+        // Primitive Arrays\n+        assertEquals(\"boolean[]\", ClassUtils.getShortClassName(boolean[].class));\n+        assertEquals(\"byte[]\", ClassUtils.getShortClassName(byte[].class));\n+        assertEquals(\"char[]\", ClassUtils.getShortClassName(char[].class));\n+        assertEquals(\"short[]\", ClassUtils.getShortClassName(short[].class));\n+        assertEquals(\"int[]\", ClassUtils.getShortClassName(int[].class));\n+        assertEquals(\"long[]\", ClassUtils.getShortClassName(long[].class));\n+        assertEquals(\"float[]\", ClassUtils.getShortClassName(float[].class));\n+        assertEquals(\"double[]\", ClassUtils.getShortClassName(double[].class));\n+\n+        // Arrays of arrays of ...\n+        assertEquals(\"String[][]\", ClassUtils.getShortClassName(String[][].class));\n+        assertEquals(\"String[][][]\", ClassUtils.getShortClassName(String[][][].class));\n+        assertEquals(\"String[][][][]\", ClassUtils.getShortClassName(String[][][][].class));\n+    }\n+    \n+    public void test_getShortClassName_String() {\n+        assertEquals(\"ClassUtils\", ClassUtils.getShortClassName(ClassUtils.class.getName()));\n+        assertEquals(\"Map.Entry\", ClassUtils.getShortClassName(Map.Entry.class.getName()));\n+        assertEquals(\"\", ClassUtils.getShortClassName((String) null));\n+        assertEquals(\"\", ClassUtils.getShortClassName(\"\"));\n+    }\n+\n+    // -------------------------------------------------------------------------\n+    public void test_getPackageName_Object() {\n+        assertEquals(\"org.apache.commons.lang\", ClassUtils.getPackageName(new ClassUtils(), \"<null>\"));\n+        assertEquals(\"org.apache.commons.lang\", ClassUtils.getPackageName(new Inner(), \"<null>\"));\n+        assertEquals(\"<null>\", ClassUtils.getPackageName(null, \"<null>\"));\n+    }\n+    \n+    public void test_getPackageName_Class() {\n+        assertEquals(\"java.lang\", ClassUtils.getPackageName(String.class));\n+        assertEquals(\"java.util\", ClassUtils.getPackageName(Map.Entry.class));\n+        assertEquals(\"\", ClassUtils.getPackageName((Class<?>)null));\n+\n+        // LANG-535\n+        assertEquals(\"java.lang\", ClassUtils.getPackageName(String[].class));\n+\n+        // Primitive Arrays\n+        assertEquals(\"\", ClassUtils.getPackageName(boolean[].class));\n+        assertEquals(\"\", ClassUtils.getPackageName(byte[].class));\n+        assertEquals(\"\", ClassUtils.getPackageName(char[].class));\n+        assertEquals(\"\", ClassUtils.getPackageName(short[].class));\n+        assertEquals(\"\", ClassUtils.getPackageName(int[].class));\n+        assertEquals(\"\", ClassUtils.getPackageName(long[].class));\n+        assertEquals(\"\", ClassUtils.getPackageName(float[].class));\n+        assertEquals(\"\", ClassUtils.getPackageName(double[].class));\n+\n+        // Arrays of arrays of ...\n+        assertEquals(\"java.lang\", ClassUtils.getPackageName(String[][].class));\n+        assertEquals(\"java.lang\", ClassUtils.getPackageName(String[][][].class));\n+        assertEquals(\"java.lang\", ClassUtils.getPackageName(String[][][][].class));\n+    }\n+    \n+    public void test_getPackageName_String() {\n+        assertEquals(\"org.apache.commons.lang\", ClassUtils.getPackageName(ClassUtils.class.getName()));\n+        assertEquals(\"java.util\", ClassUtils.getPackageName(Map.Entry.class.getName()));\n+        assertEquals(\"\", ClassUtils.getPackageName((String)null));\n+        assertEquals(\"\", ClassUtils.getPackageName(\"\"));\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    public void test_getAllSuperclasses_Class() {\n+        List<?> list = ClassUtils.getAllSuperclasses(CY.class);\n+        assertEquals(2, list.size());\n+        assertEquals(CX.class, list.get(0));\n+        assertEquals(Object.class, list.get(1));\n+        \n+        assertEquals(null, ClassUtils.getAllSuperclasses(null));\n+    }\n+    \n+    public void test_getAllInterfaces_Class() {\n+        List<?> list = ClassUtils.getAllInterfaces(CY.class);\n+        assertEquals(6, list.size());\n+        assertEquals(IB.class, list.get(0));\n+        assertEquals(IC.class, list.get(1));\n+        assertEquals(ID.class, list.get(2));\n+        assertEquals(IE.class, list.get(3));\n+        assertEquals(IF.class, list.get(4));\n+        assertEquals(IA.class, list.get(5));\n+        \n+        assertEquals(null, ClassUtils.getAllInterfaces(null));\n+    }\n+    \n+    private static interface IA {\n+    }\n+    private static interface IB {\n+    }\n+    private static interface IC extends ID, IE {\n+    }\n+    private static interface ID {\n+    }\n+    private static interface IE extends IF {\n+    }\n+    private static interface IF {\n+    }\n+    private static class CX implements IB, IA, IE {\n+    }\n+    private static class CY extends CX implements IB, IC {\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    public void test_convertClassNamesToClasses_List() {\n+        List list = new ArrayList();\n+        List result = ClassUtils.convertClassNamesToClasses(list);\n+        assertEquals(0, result.size());\n+        \n+        list.add(\"java.lang.String\");\n+        list.add(\"java.lang.xxx\");\n+        list.add(\"java.lang.Object\");\n+        result = ClassUtils.convertClassNamesToClasses(list);\n+        assertEquals(3, result.size());\n+        assertEquals(String.class, result.get(0));\n+        assertEquals(null, result.get(1));\n+        assertEquals(Object.class, result.get(2));\n+\n+        list.add(new Object());\n+        try {\n+            ClassUtils.convertClassNamesToClasses(list);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        assertEquals(null, ClassUtils.convertClassNamesToClasses(null));\n+    }\n+    \n+    public void test_convertClassesToClassNames_List() {\n+        List list = new ArrayList();\n+        List result = ClassUtils.convertClassesToClassNames(list);\n+        assertEquals(0, result.size());\n+        \n+        list.add(String.class);\n+        list.add(null);\n+        list.add(Object.class);\n+        result = ClassUtils.convertClassesToClassNames(list);\n+        assertEquals(3, result.size());\n+        assertEquals(\"java.lang.String\", result.get(0));\n+        assertEquals(null, result.get(1));\n+        assertEquals(\"java.lang.Object\", result.get(2));\n+\n+        list.add(new Object());\n+        try {\n+            ClassUtils.convertClassesToClassNames(list);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        assertEquals(null, ClassUtils.convertClassesToClassNames(null));\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    public void test_isInnerClass_Class() {\n+        assertEquals(true, ClassUtils.isInnerClass(Inner.class));\n+        assertEquals(true, ClassUtils.isInnerClass(Map.Entry.class));\n+        assertEquals(true, ClassUtils.isInnerClass(new Cloneable() {\n+        }.getClass()));\n+        assertEquals(false, ClassUtils.isInnerClass(this.getClass()));\n+        assertEquals(false, ClassUtils.isInnerClass(String.class));\n+        assertEquals(false, ClassUtils.isInnerClass(null));\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    public void test_isAssignable_ClassArray_ClassArray() throws Exception {\n+        Class<?>[] array2 = new Class[] {Object.class, Object.class};\n+        Class<?>[] array1 = new Class[] {Object.class};\n+        Class<?>[] array1s = new Class[] {String.class};\n+        Class<?>[] array0 = new Class[] {};\n+\n+        assertFalse(ClassUtils.isAssignable(array1, array2));\n+        assertFalse(ClassUtils.isAssignable(null, array2));\n+        assertTrue(ClassUtils.isAssignable(null, array0));\n+        assertTrue(ClassUtils.isAssignable(array0, array0));\n+        assertTrue(ClassUtils.isAssignable(array0, null));\n+        assertTrue(ClassUtils.isAssignable((Class[]) null, (Class[]) null));\n+        \n+        assertFalse(ClassUtils.isAssignable(array1, array1s));\n+        assertTrue(ClassUtils.isAssignable(array1s, array1s));\n+        assertTrue(ClassUtils.isAssignable(array1s, array1));\n+    }\n+    \n+    public void test_isAssignable() throws Exception {\n+        assertFalse(ClassUtils.isAssignable((Class<?>) null, null));\n+        assertFalse(ClassUtils.isAssignable(String.class, null));\n+        \n+        assertTrue(ClassUtils.isAssignable(null, Object.class));\n+        assertTrue(ClassUtils.isAssignable(null, Integer.class));\n+        assertFalse(ClassUtils.isAssignable(null, Integer.TYPE));\n+        assertTrue(ClassUtils.isAssignable(String.class, Object.class));\n+        assertTrue(ClassUtils.isAssignable(String.class, String.class));\n+        assertFalse(ClassUtils.isAssignable(Object.class, String.class));\n+        assertFalse(ClassUtils.isAssignable(Integer.TYPE, Integer.class));\n+        assertFalse(ClassUtils.isAssignable(Integer.class, Integer.TYPE));\n+        assertTrue(ClassUtils.isAssignable(Integer.TYPE, Integer.TYPE));\n+        assertTrue(ClassUtils.isAssignable(Integer.class, Integer.class));\n+        assertFalse(ClassUtils.isAssignable(Boolean.TYPE, Boolean.class));\n+        assertFalse(ClassUtils.isAssignable(Boolean.class, Boolean.TYPE));\n+        assertTrue(ClassUtils.isAssignable(Boolean.TYPE, Boolean.TYPE));\n+        assertTrue(ClassUtils.isAssignable(Boolean.class, Boolean.class));\n+    }\n+    \n+    public void test_isAssignable_Autoboxing() throws Exception {\n+        assertFalse(ClassUtils.isAssignable((Class<?>) null, null, true));\n+        assertFalse(ClassUtils.isAssignable(String.class, null, true));\n+\n+        assertTrue(ClassUtils.isAssignable(null, Object.class, true));\n+        assertTrue(ClassUtils.isAssignable(null, Integer.class, true));\n+        assertFalse(ClassUtils.isAssignable(null, Integer.TYPE, true));\n+        assertTrue(ClassUtils.isAssignable(String.class, Object.class, true));\n+        assertTrue(ClassUtils.isAssignable(String.class, String.class, true));\n+        assertFalse(ClassUtils.isAssignable(Object.class, String.class, true));\n+        assertTrue(ClassUtils.isAssignable(Integer.TYPE, Integer.class, true));\n+        assertTrue(ClassUtils.isAssignable(Integer.class, Integer.TYPE, true));\n+        assertTrue(ClassUtils.isAssignable(Integer.TYPE, Integer.TYPE, true));\n+        assertTrue(ClassUtils.isAssignable(Integer.class, Integer.class, true));\n+        assertTrue(ClassUtils.isAssignable(Boolean.TYPE, Boolean.class, true));\n+        assertTrue(ClassUtils.isAssignable(Boolean.class, Boolean.TYPE, true));\n+        assertTrue(ClassUtils.isAssignable(Boolean.TYPE, Boolean.TYPE, true));\n+        assertTrue(ClassUtils.isAssignable(Boolean.class, Boolean.class, true));\n+    }\n+\n+    public void test_isAssignable_Widening() throws Exception {\n+        // test byte conversions\n+        assertFalse(\"byte -> char\", ClassUtils.isAssignable(Byte.TYPE, Character.TYPE));\n+        assertTrue(\"byte -> byte\", ClassUtils.isAssignable(Byte.TYPE, Byte.TYPE));\n+        assertTrue(\"byte -> short\", ClassUtils.isAssignable(Byte.TYPE, Short.TYPE));\n+        assertTrue(\"byte -> int\", ClassUtils.isAssignable(Byte.TYPE, Integer.TYPE));\n+        assertTrue(\"byte -> long\", ClassUtils.isAssignable(Byte.TYPE, Long.TYPE));\n+        assertTrue(\"byte -> float\", ClassUtils.isAssignable(Byte.TYPE, Float.TYPE));\n+        assertTrue(\"byte -> double\", ClassUtils.isAssignable(Byte.TYPE, Double.TYPE));\n+        assertFalse(\"byte -> boolean\", ClassUtils.isAssignable(Byte.TYPE, Boolean.TYPE));\n+        \n+        // test short conversions\n+        assertFalse(\"short -> char\", ClassUtils.isAssignable(Short.TYPE, Character.TYPE));\n+        assertFalse(\"short -> byte\", ClassUtils.isAssignable(Short.TYPE, Byte.TYPE));\n+        assertTrue(\"short -> short\", ClassUtils.isAssignable(Short.TYPE, Short.TYPE));\n+        assertTrue(\"short -> int\", ClassUtils.isAssignable(Short.TYPE, Integer.TYPE));\n+        assertTrue(\"short -> long\", ClassUtils.isAssignable(Short.TYPE, Long.TYPE));\n+        assertTrue(\"short -> float\", ClassUtils.isAssignable(Short.TYPE, Float.TYPE));\n+        assertTrue(\"short -> double\", ClassUtils.isAssignable(Short.TYPE, Double.TYPE));\n+        assertFalse(\"short -> boolean\", ClassUtils.isAssignable(Short.TYPE, Boolean.TYPE));\n+        \n+        // test char conversions\n+        assertTrue(\"char -> char\", ClassUtils.isAssignable(Character.TYPE, Character.TYPE));\n+        assertFalse(\"char -> byte\", ClassUtils.isAssignable(Character.TYPE, Byte.TYPE));\n+        assertFalse(\"char -> short\", ClassUtils.isAssignable(Character.TYPE, Short.TYPE));\n+        assertTrue(\"char -> int\", ClassUtils.isAssignable(Character.TYPE, Integer.TYPE));\n+        assertTrue(\"char -> long\", ClassUtils.isAssignable(Character.TYPE, Long.TYPE));\n+        assertTrue(\"char -> float\", ClassUtils.isAssignable(Character.TYPE, Float.TYPE));\n+        assertTrue(\"char -> double\", ClassUtils.isAssignable(Character.TYPE, Double.TYPE));\n+        assertFalse(\"char -> boolean\", ClassUtils.isAssignable(Character.TYPE, Boolean.TYPE));\n+        \n+        // test int conversions\n+        assertFalse(\"int -> char\", ClassUtils.isAssignable(Integer.TYPE, Character.TYPE));\n+        assertFalse(\"int -> byte\", ClassUtils.isAssignable(Integer.TYPE, Byte.TYPE));\n+        assertFalse(\"int -> short\", ClassUtils.isAssignable(Integer.TYPE, Short.TYPE));\n+        assertTrue(\"int -> int\", ClassUtils.isAssignable(Integer.TYPE, Integer.TYPE));\n+        assertTrue(\"int -> long\", ClassUtils.isAssignable(Integer.TYPE, Long.TYPE));\n+        assertTrue(\"int -> float\", ClassUtils.isAssignable(Integer.TYPE, Float.TYPE));\n+        assertTrue(\"int -> double\", ClassUtils.isAssignable(Integer.TYPE, Double.TYPE));\n+        assertFalse(\"int -> boolean\", ClassUtils.isAssignable(Integer.TYPE, Boolean.TYPE));\n+ \n+        // test long conversions\n+        assertFalse(\"long -> char\", ClassUtils.isAssignable(Long.TYPE, Character.TYPE));\n+        assertFalse(\"long -> byte\", ClassUtils.isAssignable(Long.TYPE, Byte.TYPE));\n+        assertFalse(\"long -> short\", ClassUtils.isAssignable(Long.TYPE, Short.TYPE));\n+        assertFalse(\"long -> int\", ClassUtils.isAssignable(Long.TYPE, Integer.TYPE));\n+        assertTrue(\"long -> long\", ClassUtils.isAssignable(Long.TYPE, Long.TYPE));\n+        assertTrue(\"long -> float\", ClassUtils.isAssignable(Long.TYPE, Float.TYPE));\n+        assertTrue(\"long -> double\", ClassUtils.isAssignable(Long.TYPE, Double.TYPE));\n+        assertFalse(\"long -> boolean\", ClassUtils.isAssignable(Long.TYPE, Boolean.TYPE));\n+ \n+        // test float conversions\n+        assertFalse(\"float -> char\", ClassUtils.isAssignable(Float.TYPE, Character.TYPE));\n+        assertFalse(\"float -> byte\", ClassUtils.isAssignable(Float.TYPE, Byte.TYPE));\n+        assertFalse(\"float -> short\", ClassUtils.isAssignable(Float.TYPE, Short.TYPE));\n+        assertFalse(\"float -> int\", ClassUtils.isAssignable(Float.TYPE, Integer.TYPE));\n+        assertFalse(\"float -> long\", ClassUtils.isAssignable(Float.TYPE, Long.TYPE));\n+        assertTrue(\"float -> float\", ClassUtils.isAssignable(Float.TYPE, Float.TYPE));\n+        assertTrue(\"float -> double\", ClassUtils.isAssignable(Float.TYPE, Double.TYPE));\n+        assertFalse(\"float -> boolean\", ClassUtils.isAssignable(Float.TYPE, Boolean.TYPE));\n+        \n+        // test double conversions\n+        assertFalse(\"double -> char\", ClassUtils.isAssignable(Double.TYPE, Character.TYPE));\n+        assertFalse(\"double -> byte\", ClassUtils.isAssignable(Double.TYPE, Byte.TYPE));\n+        assertFalse(\"double -> short\", ClassUtils.isAssignable(Double.TYPE, Short.TYPE));\n+        assertFalse(\"double -> int\", ClassUtils.isAssignable(Double.TYPE, Integer.TYPE));\n+        assertFalse(\"double -> long\", ClassUtils.isAssignable(Double.TYPE, Long.TYPE));\n+        assertFalse(\"double -> float\", ClassUtils.isAssignable(Double.TYPE, Float.TYPE));\n+        assertTrue(\"double -> double\", ClassUtils.isAssignable(Double.TYPE, Double.TYPE));\n+        assertFalse(\"double -> boolean\", ClassUtils.isAssignable(Double.TYPE, Boolean.TYPE));\n+        \n+        // test boolean conversions\n+        assertFalse(\"boolean -> char\", ClassUtils.isAssignable(Boolean.TYPE, Character.TYPE));\n+        assertFalse(\"boolean -> byte\", ClassUtils.isAssignable(Boolean.TYPE, Byte.TYPE));\n+        assertFalse(\"boolean -> short\", ClassUtils.isAssignable(Boolean.TYPE, Short.TYPE));\n+        assertFalse(\"boolean -> int\", ClassUtils.isAssignable(Boolean.TYPE, Integer.TYPE));\n+        assertFalse(\"boolean -> long\", ClassUtils.isAssignable(Boolean.TYPE, Long.TYPE));\n+        assertFalse(\"boolean -> float\", ClassUtils.isAssignable(Boolean.TYPE, Float.TYPE));\n+        assertFalse(\"boolean -> double\", ClassUtils.isAssignable(Boolean.TYPE, Double.TYPE));\n+        assertTrue(\"boolean -> boolean\", ClassUtils.isAssignable(Boolean.TYPE, Boolean.TYPE));\n+    }\n+    \n+    public void test_isAssignable_Unboxing_Widening() throws Exception {\n+        // test byte conversions\n+        assertFalse(\"byte -> char\", ClassUtils.isAssignable(Byte.class, Character.TYPE, true));\n+        assertTrue(\"byte -> byte\", ClassUtils.isAssignable(Byte.class, Byte.TYPE, true));\n+        assertTrue(\"byte -> short\", ClassUtils.isAssignable(Byte.class, Short.TYPE, true));\n+        assertTrue(\"byte -> int\", ClassUtils.isAssignable(Byte.class, Integer.TYPE, true));\n+        assertTrue(\"byte -> long\", ClassUtils.isAssignable(Byte.class, Long.TYPE, true));\n+        assertTrue(\"byte -> float\", ClassUtils.isAssignable(Byte.class, Float.TYPE, true));\n+        assertTrue(\"byte -> double\", ClassUtils.isAssignable(Byte.class, Double.TYPE, true));\n+        assertFalse(\"byte -> boolean\", ClassUtils.isAssignable(Byte.class, Boolean.TYPE, true));\n+        \n+        // test short conversions\n+        assertFalse(\"short -> char\", ClassUtils.isAssignable(Short.class, Character.TYPE, true));\n+        assertFalse(\"short -> byte\", ClassUtils.isAssignable(Short.class, Byte.TYPE, true));\n+        assertTrue(\"short -> short\", ClassUtils.isAssignable(Short.class, Short.TYPE, true));\n+        assertTrue(\"short -> int\", ClassUtils.isAssignable(Short.class, Integer.TYPE, true));\n+        assertTrue(\"short -> long\", ClassUtils.isAssignable(Short.class, Long.TYPE, true));\n+        assertTrue(\"short -> float\", ClassUtils.isAssignable(Short.class, Float.TYPE, true));\n+        assertTrue(\"short -> double\", ClassUtils.isAssignable(Short.class, Double.TYPE, true));\n+        assertFalse(\"short -> boolean\", ClassUtils.isAssignable(Short.class, Boolean.TYPE, true));\n+        \n+        // test char conversions\n+        assertTrue(\"char -> char\", ClassUtils.isAssignable(Character.class, Character.TYPE, true));\n+        assertFalse(\"char -> byte\", ClassUtils.isAssignable(Character.class, Byte.TYPE, true));\n+        assertFalse(\"char -> short\", ClassUtils.isAssignable(Character.class, Short.TYPE, true));\n+        assertTrue(\"char -> int\", ClassUtils.isAssignable(Character.class, Integer.TYPE, true));\n+        assertTrue(\"char -> long\", ClassUtils.isAssignable(Character.class, Long.TYPE, true));\n+        assertTrue(\"char -> float\", ClassUtils.isAssignable(Character.class, Float.TYPE, true));\n+        assertTrue(\"char -> double\", ClassUtils.isAssignable(Character.class, Double.TYPE, true));\n+        assertFalse(\"char -> boolean\", ClassUtils.isAssignable(Character.class, Boolean.TYPE, true));\n+        \n+        // test int conversions\n+        assertFalse(\"int -> char\", ClassUtils.isAssignable(Integer.class, Character.TYPE, true));\n+        assertFalse(\"int -> byte\", ClassUtils.isAssignable(Integer.class, Byte.TYPE, true));\n+        assertFalse(\"int -> short\", ClassUtils.isAssignable(Integer.class, Short.TYPE, true));\n+        assertTrue(\"int -> int\", ClassUtils.isAssignable(Integer.class, Integer.TYPE, true));\n+        assertTrue(\"int -> long\", ClassUtils.isAssignable(Integer.class, Long.TYPE, true));\n+        assertTrue(\"int -> float\", ClassUtils.isAssignable(Integer.class, Float.TYPE, true));\n+        assertTrue(\"int -> double\", ClassUtils.isAssignable(Integer.class, Double.TYPE, true));\n+        assertFalse(\"int -> boolean\", ClassUtils.isAssignable(Integer.class, Boolean.TYPE, true));\n+        \n+        // test long conversions\n+        assertFalse(\"long -> char\", ClassUtils.isAssignable(Long.class, Character.TYPE, true));\n+        assertFalse(\"long -> byte\", ClassUtils.isAssignable(Long.class, Byte.TYPE, true));\n+        assertFalse(\"long -> short\", ClassUtils.isAssignable(Long.class, Short.TYPE, true));\n+        assertFalse(\"long -> int\", ClassUtils.isAssignable(Long.class, Integer.TYPE, true));\n+        assertTrue(\"long -> long\", ClassUtils.isAssignable(Long.class, Long.TYPE, true));\n+        assertTrue(\"long -> float\", ClassUtils.isAssignable(Long.class, Float.TYPE, true));\n+        assertTrue(\"long -> double\", ClassUtils.isAssignable(Long.class, Double.TYPE, true));\n+        assertFalse(\"long -> boolean\", ClassUtils.isAssignable(Long.class, Boolean.TYPE, true));\n+        \n+        // test float conversions\n+        assertFalse(\"float -> char\", ClassUtils.isAssignable(Float.class, Character.TYPE, true));\n+        assertFalse(\"float -> byte\", ClassUtils.isAssignable(Float.class, Byte.TYPE, true));\n+        assertFalse(\"float -> short\", ClassUtils.isAssignable(Float.class, Short.TYPE, true));\n+        assertFalse(\"float -> int\", ClassUtils.isAssignable(Float.class, Integer.TYPE, true));\n+        assertFalse(\"float -> long\", ClassUtils.isAssignable(Float.class, Long.TYPE, true));\n+        assertTrue(\"float -> float\", ClassUtils.isAssignable(Float.class, Float.TYPE, true));\n+        assertTrue(\"float -> double\", ClassUtils.isAssignable(Float.class, Double.TYPE, true));\n+        assertFalse(\"float -> boolean\", ClassUtils.isAssignable(Float.class, Boolean.TYPE, true));\n+        \n+        // test double conversions\n+        assertFalse(\"double -> char\", ClassUtils.isAssignable(Double.class, Character.TYPE, true));\n+        assertFalse(\"double -> byte\", ClassUtils.isAssignable(Double.class, Byte.TYPE, true));\n+        assertFalse(\"double -> short\", ClassUtils.isAssignable(Double.class, Short.TYPE, true));\n+        assertFalse(\"double -> int\", ClassUtils.isAssignable(Double.class, Integer.TYPE, true));\n+        assertFalse(\"double -> long\", ClassUtils.isAssignable(Double.class, Long.TYPE, true));\n+        assertFalse(\"double -> float\", ClassUtils.isAssignable(Double.class, Float.TYPE, true));\n+        assertTrue(\"double -> double\", ClassUtils.isAssignable(Double.class, Double.TYPE, true));\n+        assertFalse(\"double -> boolean\", ClassUtils.isAssignable(Double.class, Boolean.TYPE, true));\n+        \n+        // test boolean conversions\n+        assertFalse(\"boolean -> char\", ClassUtils.isAssignable(Boolean.class, Character.TYPE, true));\n+        assertFalse(\"boolean -> byte\", ClassUtils.isAssignable(Boolean.class, Byte.TYPE, true));\n+        assertFalse(\"boolean -> short\", ClassUtils.isAssignable(Boolean.class, Short.TYPE, true));\n+        assertFalse(\"boolean -> int\", ClassUtils.isAssignable(Boolean.class, Integer.TYPE, true));\n+        assertFalse(\"boolean -> long\", ClassUtils.isAssignable(Boolean.class, Long.TYPE, true));\n+        assertFalse(\"boolean -> float\", ClassUtils.isAssignable(Boolean.class, Float.TYPE, true));\n+        assertFalse(\"boolean -> double\", ClassUtils.isAssignable(Boolean.class, Double.TYPE, true));\n+        assertTrue(\"boolean -> boolean\", ClassUtils.isAssignable(Boolean.class, Boolean.TYPE, true));\n+    }\n+    \n+    public void testPrimitiveToWrapper() {\n+       \n+        // test primitive classes\n+        assertEquals(\"boolean -> Boolean.class\", \n+            Boolean.class, ClassUtils.primitiveToWrapper(Boolean.TYPE));   \n+        assertEquals(\"byte -> Byte.class\",\n+            Byte.class, ClassUtils.primitiveToWrapper(Byte.TYPE));\n+        assertEquals(\"char -> Character.class\",\n+            Character.class, ClassUtils.primitiveToWrapper(Character.TYPE));\n+        assertEquals(\"short -> Short.class\",\n+            Short.class, ClassUtils.primitiveToWrapper(Short.TYPE));\n+        assertEquals(\"int -> Integer.class\",\n+            Integer.class, ClassUtils.primitiveToWrapper(Integer.TYPE));\n+        assertEquals(\"long -> Long.class\",\n+            Long.class, ClassUtils.primitiveToWrapper(Long.TYPE));\n+        assertEquals(\"double -> Double.class\",\n+            Double.class, ClassUtils.primitiveToWrapper(Double.TYPE));\n+        assertEquals(\"float -> Float.class\",\n+            Float.class, ClassUtils.primitiveToWrapper(Float.TYPE));\n+        \n+        // test a few other classes\n+        assertEquals(\"String.class -> String.class\",\n+            String.class, ClassUtils.primitiveToWrapper(String.class));\n+        assertEquals(\"ClassUtils.class -> ClassUtils.class\",\n+            org.apache.commons.lang.ClassUtils.class, \n+            ClassUtils.primitiveToWrapper(org.apache.commons.lang.ClassUtils.class));\n+        assertEquals(\"Void.TYPE -> Void.TYPE\",\n+            Void.TYPE, ClassUtils.primitiveToWrapper(Void.TYPE));\n+            \n+        // test null     \n+        assertNull(\"null -> null\",\n+            ClassUtils.primitiveToWrapper(null));\n+    }\n+\n+    public void testPrimitivesToWrappers() {\n+        // test null\n+        assertNull(\"null -> null\",\n+            ClassUtils.primitivesToWrappers(null));\n+        // test empty array\n+        assertEquals(\"empty -> empty\",\n+                ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.primitivesToWrappers(ArrayUtils.EMPTY_CLASS_ARRAY));\n+\n+        // test an array of various classes\n+        final Class<?>[] primitives = new Class[] {\n+                Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE, \n+                Integer.TYPE, Long.TYPE, Double.TYPE, Float.TYPE,\n+                String.class, ClassUtils.class\n+        };\n+        Class<?>[] wrappers= ClassUtils.primitivesToWrappers(primitives);\n+        \n+        for (int i=0; i < primitives.length; i++) {\n+            // test each returned wrapper\n+            Class<?> primitive = primitives[i];\n+            Class<?> expectedWrapper = ClassUtils.primitiveToWrapper(primitive);\n+            \n+            assertEquals(primitive + \" -> \" + expectedWrapper, expectedWrapper, wrappers[i]);\n+        }\n+\n+        // test an array of no primitive classes\n+        final Class<?>[] noPrimitives = new Class[] {\n+                String.class, ClassUtils.class, Void.TYPE\n+        };\n+        // This used to return the exact same array, but no longer does.\n+        assertNotSame(\"unmodified\", noPrimitives, ClassUtils.primitivesToWrappers(noPrimitives));\n+    }\n+\n+    public void testWrapperToPrimitive() {\n+        // an array with classes to convert\n+        final Class<?>[] primitives = {\n+                Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE,\n+                Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE\n+        };\n+        for (int i = 0; i < primitives.length; i++) {\n+            Class<?> wrapperCls = ClassUtils.primitiveToWrapper(primitives[i]);\n+            assertFalse(\"Still primitive\", wrapperCls.isPrimitive());\n+            assertEquals(wrapperCls + \" -> \" + primitives[i], primitives[i],\n+                    ClassUtils.wrapperToPrimitive(wrapperCls));\n+        }\n+    }\n+\n+    public void testWrapperToPrimitiveNoWrapper() {\n+        assertNull(\"Wrong result for non wrapper class\", ClassUtils.wrapperToPrimitive(String.class));\n+    }\n+\n+    public void testWrapperToPrimitiveNull() {\n+        assertNull(\"Wrong result for null class\", ClassUtils.wrapperToPrimitive(null));\n+    }\n+\n+    public void testWrappersToPrimitives() {\n+        // an array with classes to test\n+        final Class<?>[] classes = {\n+                Boolean.class, Byte.class, Character.class, Short.class,\n+                Integer.class, Long.class, Float.class, Double.class,\n+                String.class, ClassUtils.class, null\n+        };\n+\n+        Class<?>[] primitives = ClassUtils.wrappersToPrimitives(classes);\n+        // now test the result\n+        assertEquals(\"Wrong length of result array\", classes.length, primitives.length);\n+        for (int i = 0; i < classes.length; i++) {\n+            Class<?> expectedPrimitive = ClassUtils.wrapperToPrimitive(classes[i]);\n+            assertEquals(classes[i] + \" -> \" + expectedPrimitive, expectedPrimitive,\n+                    primitives[i]);\n+        }\n+    }\n+\n+    public void testWrappersToPrimitivesNull() {\n+        assertNull(\"Wrong result for null input\", ClassUtils.wrappersToPrimitives(null));\n+    }\n+\n+    public void testWrappersToPrimitivesEmpty() {\n+        Class<?>[] empty = new Class[0];\n+        assertEquals(\"Wrong result for empty input\", empty, ClassUtils.wrappersToPrimitives(empty));\n+    }\n+\n+    public void testGetClassClassNotFound() throws Exception {\n+        assertGetClassThrowsClassNotFound( \"bool\" );\n+        assertGetClassThrowsClassNotFound( \"bool[]\" );\n+        assertGetClassThrowsClassNotFound( \"integer[]\" );\n+    }\n+\n+    public void testGetClassInvalidArguments() throws Exception {\n+        assertGetClassThrowsNullPointerException( null );\n+        assertGetClassThrowsClassNotFound( \"[][][]\" );\n+        assertGetClassThrowsClassNotFound( \"[[]\" );\n+        assertGetClassThrowsClassNotFound( \"[\" );\n+        assertGetClassThrowsClassNotFound( \"java.lang.String][\" );\n+        assertGetClassThrowsClassNotFound( \".hello.world\" );\n+        assertGetClassThrowsClassNotFound( \"hello..world\" );\n+    }\n+\n+    public void testWithInterleavingWhitespace() throws ClassNotFoundException {\n+        assertEquals( int[].class, ClassUtils.getClass( \" int [ ] \" ) );\n+        assertEquals( long[].class, ClassUtils.getClass( \"\\rlong\\t[\\n]\\r\" ) );\n+        assertEquals( short[].class, ClassUtils.getClass( \"\\tshort                \\t\\t[]\" ) );\n+        assertEquals( byte[].class, ClassUtils.getClass( \"byte[\\t\\t\\n\\r]   \" ) );\n+    }\n+\n+    public void testGetClassByNormalNameArrays() throws ClassNotFoundException {\n+        assertEquals( int[].class, ClassUtils.getClass( \"int[]\" ) );\n+        assertEquals( long[].class, ClassUtils.getClass( \"long[]\" ) );\n+        assertEquals( short[].class, ClassUtils.getClass( \"short[]\" ) );\n+        assertEquals( byte[].class, ClassUtils.getClass( \"byte[]\" ) );\n+        assertEquals( char[].class, ClassUtils.getClass( \"char[]\" ) );\n+        assertEquals( float[].class, ClassUtils.getClass( \"float[]\" ) );\n+        assertEquals( double[].class, ClassUtils.getClass( \"double[]\" ) );\n+        assertEquals( boolean[].class, ClassUtils.getClass( \"boolean[]\" ) );\n+        assertEquals( String[].class, ClassUtils.getClass( \"java.lang.String[]\" ) );\n+    }\n+\n+    public void testGetClassByNormalNameArrays2D() throws ClassNotFoundException {\n+        assertEquals( int[][].class, ClassUtils.getClass( \"int[][]\" ) );\n+        assertEquals( long[][].class, ClassUtils.getClass( \"long[][]\" ) );\n+        assertEquals( short[][].class, ClassUtils.getClass( \"short[][]\" ) );\n+        assertEquals( byte[][].class, ClassUtils.getClass( \"byte[][]\" ) );\n+        assertEquals( char[][].class, ClassUtils.getClass( \"char[][]\" ) );\n+        assertEquals( float[][].class, ClassUtils.getClass( \"float[][]\" ) );\n+        assertEquals( double[][].class, ClassUtils.getClass( \"double[][]\" ) );\n+        assertEquals( boolean[][].class, ClassUtils.getClass( \"boolean[][]\" ) );\n+        assertEquals( String[][].class, ClassUtils.getClass( \"java.lang.String[][]\" ) );\n+    }\n+\n+    public void testGetClassWithArrayClasses2D() throws Exception {\n+        assertGetClassReturnsClass( String[][].class );\n+        assertGetClassReturnsClass( int[][].class );\n+        assertGetClassReturnsClass( long[][].class );\n+        assertGetClassReturnsClass( short[][].class );\n+        assertGetClassReturnsClass( byte[][].class );\n+        assertGetClassReturnsClass( char[][].class );\n+        assertGetClassReturnsClass( float[][].class );\n+        assertGetClassReturnsClass( double[][].class );\n+        assertGetClassReturnsClass( boolean[][].class );\n+    }\n+\n+    public void testGetClassWithArrayClasses() throws Exception {\n+        assertGetClassReturnsClass( String[].class );\n+        assertGetClassReturnsClass( int[].class );\n+        assertGetClassReturnsClass( long[].class );\n+        assertGetClassReturnsClass( short[].class );\n+        assertGetClassReturnsClass( byte[].class );\n+        assertGetClassReturnsClass( char[].class );\n+        assertGetClassReturnsClass( float[].class );\n+        assertGetClassReturnsClass( double[].class );\n+        assertGetClassReturnsClass( boolean[].class );\n+    }\n+\n+    public void testGetClassRawPrimitives() throws ClassNotFoundException {\n+        assertEquals( int.class, ClassUtils.getClass( \"int\" ) );\n+        assertEquals( long.class, ClassUtils.getClass( \"long\" ) );\n+        assertEquals( short.class, ClassUtils.getClass( \"short\" ) );\n+        assertEquals( byte.class, ClassUtils.getClass( \"byte\" ) );\n+        assertEquals( char.class, ClassUtils.getClass( \"char\" ) );\n+        assertEquals( float.class, ClassUtils.getClass( \"float\" ) );\n+        assertEquals( double.class, ClassUtils.getClass( \"double\" ) );\n+        assertEquals( boolean.class, ClassUtils.getClass( \"boolean\" ) );\n+    }\n+\n+    private void assertGetClassReturnsClass( Class<?> c ) throws Exception {\n+        assertEquals( c, ClassUtils.getClass( c.getName() ) );\n+    }\n+\n+    private void assertGetClassThrowsException( String className, Class<?> exceptionType ) throws Exception {\n+        try {\n+            ClassUtils.getClass( className );\n+            fail( \"ClassUtils.getClass() should fail with an exception of type \" + exceptionType.getName() + \" when given class name \\\"\" + className + \"\\\".\" );\n+        }\n+        catch( Exception e ) {\n+            assertTrue( exceptionType.isAssignableFrom( e.getClass() ) );\n+        }\n+    }\n+\n+    private void assertGetClassThrowsNullPointerException( String className ) throws Exception {\n+        assertGetClassThrowsException( className, NullPointerException.class );\n+    }\n+\n+    private void assertGetClassThrowsClassNotFound( String className ) throws Exception {\n+        assertGetClassThrowsException( className, ClassNotFoundException.class );\n+    }\n+\n+    // Show the Java bug: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4071957\n+    // We may have to delete this if a JDK fixes the bug.\n+    public void testShowJavaBug() throws Exception {\n+        // Tests with Collections$UnmodifiableSet\n+        Set<?> set = Collections.unmodifiableSet(new HashSet<Object>());\n+        Method isEmptyMethod = set.getClass().getMethod(\"isEmpty\",  new Class[0]);\n+        try {\n+            isEmptyMethod.invoke(set, new Object[0]);\n+            fail(\"Failed to throw IllegalAccessException as expected\");\n+        } catch(IllegalAccessException iae) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetPublicMethod() throws Exception {\n+        // Tests with Collections$UnmodifiableSet\n+        Set<?> set = Collections.unmodifiableSet(new HashSet<Object>());\n+        Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), \"isEmpty\",  new Class[0]);\n+            assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers()));\n+ \n+        try {\n+            isEmptyMethod.invoke(set, new Object[0]);\n+        } catch(java.lang.IllegalAccessException iae) {\n+            fail(\"Should not have thrown IllegalAccessException\");\n+        }\n+               \n+        // Tests with a public Class\n+        Method toStringMethod = ClassUtils.getPublicMethod(Object.class, \"toString\",  new Class[0]);\n+            assertEquals(Object.class.getMethod(\"toString\", new Class[0]), toStringMethod);\n+    }\n+ \n+    public void testToClass_object() {\n+        assertEquals(null, ClassUtils.toClass(null));\n+\n+        assertSame(\n+            ArrayUtils.EMPTY_CLASS_ARRAY,\n+            ClassUtils.toClass(new Class[0]));\n+\n+        Object[] array = new Object[3];\n+        array[0] = new String(\"Test\");\n+        array[1] = new Integer(1);\n+        array[2] = new Double(99);\n+\n+        Class<?>[] results = ClassUtils.toClass(array);\n+        assertEquals(\"String\", ClassUtils.getShortClassName(results[0]));\n+        assertEquals(\"Integer\", ClassUtils.getShortClassName(results[1]));\n+        assertEquals(\"Double\", ClassUtils.getShortClassName(results[2]));\n+    }\n+\n+    public void test_getShortCanonicalName_Object() {\n+        assertEquals(\"<null>\", ClassUtils.getShortCanonicalName(null, \"<null>\"));\n+        assertEquals(\"ClassUtils\", ClassUtils.getShortCanonicalName(new ClassUtils(), \"<null>\"));\n+        assertEquals(\"ClassUtils[]\", ClassUtils.getShortCanonicalName(new ClassUtils[0], \"<null>\"));\n+        assertEquals(\"ClassUtils[][]\", ClassUtils.getShortCanonicalName(new ClassUtils[0][0], \"<null>\"));\n+        assertEquals(\"int[]\", ClassUtils.getShortCanonicalName(new int[0], \"<null>\"));\n+        assertEquals(\"int[][]\", ClassUtils.getShortCanonicalName(new int[0][0], \"<null>\"));\n+    }\n+\n+    public void test_getShortCanonicalName_Class() {\n+        assertEquals(\"ClassUtils\", ClassUtils.getShortCanonicalName(ClassUtils.class));\n+        assertEquals(\"ClassUtils[]\", ClassUtils.getShortCanonicalName(ClassUtils[].class));\n+        assertEquals(\"ClassUtils[][]\", ClassUtils.getShortCanonicalName(ClassUtils[][].class));\n+        assertEquals(\"int[]\", ClassUtils.getShortCanonicalName(int[].class));\n+        assertEquals(\"int[][]\", ClassUtils.getShortCanonicalName(int[][].class));\n+    }\n+\n+    public void test_getShortCanonicalName_String() {\n+        assertEquals(\"ClassUtils\", ClassUtils.getShortCanonicalName(\"org.apache.commons.lang.ClassUtils\"));\n+        assertEquals(\"ClassUtils[]\", ClassUtils.getShortCanonicalName(\"[Lorg.apache.commons.lang.ClassUtils;\"));\n+        assertEquals(\"ClassUtils[][]\", ClassUtils.getShortCanonicalName(\"[[Lorg.apache.commons.lang.ClassUtils;\"));\n+        assertEquals(\"ClassUtils[]\", ClassUtils.getShortCanonicalName(\"org.apache.commons.lang.ClassUtils[]\"));\n+        assertEquals(\"ClassUtils[][]\", ClassUtils.getShortCanonicalName(\"org.apache.commons.lang.ClassUtils[][]\"));\n+        assertEquals(\"int[]\", ClassUtils.getShortCanonicalName(\"[I\"));\n+        assertEquals(\"int[][]\", ClassUtils.getShortCanonicalName(\"[[I\"));\n+        assertEquals(\"int[]\", ClassUtils.getShortCanonicalName(\"int[]\"));\n+        assertEquals(\"int[][]\", ClassUtils.getShortCanonicalName(\"int[][]\"));\n+    }\n+\n+    public void test_getPackageCanonicalName_Object() {\n+        assertEquals(\"<null>\", ClassUtils.getPackageCanonicalName(null, \"<null>\"));\n+        assertEquals(\"org.apache.commons.lang\", ClassUtils.getPackageCanonicalName(new ClassUtils(), \"<null>\"));\n+        assertEquals(\"org.apache.commons.lang\", ClassUtils.getPackageCanonicalName(new ClassUtils[0], \"<null>\"));\n+        assertEquals(\"org.apache.commons.lang\", ClassUtils.getPackageCanonicalName(new ClassUtils[0][0], \"<null>\"));\n+        assertEquals(\"\", ClassUtils.getPackageCanonicalName(new int[0], \"<null>\"));\n+        assertEquals(\"\", ClassUtils.getPackageCanonicalName(new int[0][0], \"<null>\"));\n+    }\n+\n+    public void test_getPackageCanonicalName_Class() {\n+        assertEquals(\"org.apache.commons.lang\", ClassUtils.getPackageCanonicalName(ClassUtils.class));\n+        assertEquals(\"org.apache.commons.lang\", ClassUtils.getPackageCanonicalName(ClassUtils[].class));\n+        assertEquals(\"org.apache.commons.lang\", ClassUtils.getPackageCanonicalName(ClassUtils[][].class));\n+        assertEquals(\"\", ClassUtils.getPackageCanonicalName(int[].class));\n+        assertEquals(\"\", ClassUtils.getPackageCanonicalName(int[][].class));\n+    }\n+\n+    public void test_getPackageCanonicalName_String() {\n+        assertEquals(\"org.apache.commons.lang\", \n+            ClassUtils.getPackageCanonicalName(\"org.apache.commons.lang.ClassUtils\"));\n+        assertEquals(\"org.apache.commons.lang\", \n+            ClassUtils.getPackageCanonicalName(\"[Lorg.apache.commons.lang.ClassUtils;\"));\n+        assertEquals(\"org.apache.commons.lang\", \n+            ClassUtils.getPackageCanonicalName(\"[[Lorg.apache.commons.lang.ClassUtils;\"));\n+        assertEquals(\"org.apache.commons.lang\", \n+            ClassUtils.getPackageCanonicalName(\"org.apache.commons.lang.ClassUtils[]\"));\n+        assertEquals(\"org.apache.commons.lang\", \n+            ClassUtils.getPackageCanonicalName(\"org.apache.commons.lang.ClassUtils[][]\"));\n+        assertEquals(\"\", ClassUtils.getPackageCanonicalName(\"[I\"));\n+        assertEquals(\"\", ClassUtils.getPackageCanonicalName(\"[[I\"));\n+        assertEquals(\"\", ClassUtils.getPackageCanonicalName(\"int[]\"));\n+        assertEquals(\"\", ClassUtils.getPackageCanonicalName(\"int[][]\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/EnumUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class EnumUtilsTest extends TestCase {\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(EnumUtilsTest.class);\n+        suite.setName(\"EnumUtils Tests\");\n+        return suite;\n+    }\n+\n+    public void testConstructable() {\n+        // enforce public constructor\n+        new EnumUtils();\n+    }\n+\n+    public void test_getEnumMap() {\n+        Map<String, Traffic> test = EnumUtils.getEnumMap(Traffic.class);\n+        assertEquals( \"getEnumMap not created correctly\", \"{RED=RED, AMBER=AMBER, GREEN=GREEN}\", test.toString());\n+        assertEquals(3, test.size());\n+        assertEquals(true, test.containsKey(\"RED\"));\n+        assertEquals(Traffic.RED, test.get(\"RED\"));\n+        assertEquals(true, test.containsKey(\"AMBER\"));\n+        assertEquals(Traffic.AMBER, test.get(\"AMBER\"));\n+        assertEquals(true, test.containsKey(\"GREEN\"));\n+        assertEquals(Traffic.GREEN, test.get(\"GREEN\"));\n+        assertEquals(false, test.containsKey(\"PURPLE\"));\n+    }\n+\n+    public void test_getEnumList() {\n+        List<Traffic> test = EnumUtils.getEnumList(Traffic.class);\n+        assertEquals(3, test.size());\n+        assertEquals(Traffic.RED, test.get(0));\n+        assertEquals(Traffic.AMBER, test.get(1));\n+        assertEquals(Traffic.GREEN, test.get(2));\n+    }\n+\n+    public void test_isEnum() {\n+        assertEquals(true, EnumUtils.isValidEnum(Traffic.class, \"RED\"));\n+        assertEquals(true, EnumUtils.isValidEnum(Traffic.class, \"AMBER\"));\n+        assertEquals(true, EnumUtils.isValidEnum(Traffic.class, \"GREEN\"));\n+        assertEquals(false, EnumUtils.isValidEnum(Traffic.class, \"PURPLE\"));\n+    }\n+\n+    public void test_getEnum() {\n+        assertEquals(Traffic.RED, EnumUtils.getEnum(Traffic.class, \"RED\"));\n+        assertEquals(Traffic.AMBER, EnumUtils.getEnum(Traffic.class, \"AMBER\"));\n+        assertEquals(Traffic.GREEN, EnumUtils.getEnum(Traffic.class, \"GREEN\"));\n+        assertEquals(null, EnumUtils.getEnum(Traffic.class, \"PURPLE\"));\n+    }\n+\n+}\n+\n+enum Traffic {\n+    RED, AMBER, GREEN\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/LocaleUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests for {@link LocaleUtils}.\n+ *\n+ * @author Apache Software Foundation\n+ * @author Chris Hyzer\n+ * @version $Id$\n+ */\n+public class LocaleUtilsTest extends TestCase {\n+\n+    private static final Locale LOCALE_EN = new Locale(\"en\", \"\");\n+    private static final Locale LOCALE_EN_US = new Locale(\"en\", \"US\");\n+    private static final Locale LOCALE_EN_US_ZZZZ = new Locale(\"en\", \"US\", \"ZZZZ\");\n+    private static final Locale LOCALE_FR = new Locale(\"fr\", \"\");\n+    private static final Locale LOCALE_FR_CA = new Locale(\"fr\", \"CA\");\n+    private static final Locale LOCALE_QQ = new Locale(\"qq\", \"\");\n+    private static final Locale LOCALE_QQ_ZZ = new Locale(\"qq\", \"ZZ\");\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param name\n+     */\n+    public LocaleUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Main.\n+     * @param args\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Run the test cases as a suite.\n+     * @return the Test\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(LocaleUtilsTest.class);\n+        suite.setName(\"LocaleUtils Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+\n+        // Testing #LANG-304. Must be called before availableLocaleSet is called.\n+        LocaleUtils.isAvailableLocale(Locale.getDefault());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test that constructors are public, and work, etc.\n+     */\n+    public void testConstructor() {\n+        assertNotNull(new LocaleUtils());\n+        Constructor<?>[] cons = LocaleUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(LocaleUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(LocaleUtils.class.getModifiers()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Pass in a valid language, test toLocale.\n+     *\n+     * @param language  the language string\n+     */\n+    private void assertValidToLocale(String language) {\n+        Locale locale = LocaleUtils.toLocale(language);\n+        assertNotNull(\"valid locale\", locale);\n+        assertEquals(language, locale.getLanguage());\n+        //country and variant are empty\n+        assertTrue(locale.getCountry() == null || locale.getCountry().length() == 0);\n+        assertTrue(locale.getVariant() == null || locale.getVariant().length() == 0);\n+    }\n+\n+    /**\n+     * Pass in a valid language, test toLocale.\n+     *\n+     * @param localeString to pass to toLocale()\n+     * @param language of the resulting Locale\n+     * @param country of the resulting Locale\n+     */\n+    private void assertValidToLocale(String localeString, String language, String country) {\n+        Locale locale = LocaleUtils.toLocale(localeString);\n+        assertNotNull(\"valid locale\", locale);\n+        assertEquals(language, locale.getLanguage());\n+        assertEquals(country, locale.getCountry());\n+        //variant is empty\n+        assertTrue(locale.getVariant() == null || locale.getVariant().length() == 0);\n+    }\n+\n+    /**\n+     * Pass in a valid language, test toLocale.\n+     *\n+     * @param localeString to pass to toLocale()\n+     * @param language of the resulting Locale\n+     * @param country of the resulting Locale\n+     * @param variant of the resulting Locale\n+     */\n+    private void assertValidToLocale(\n+            String localeString, String language, \n+            String country, String variant) {\n+        Locale locale = LocaleUtils.toLocale(localeString);\n+        assertNotNull(\"valid locale\", locale);\n+        assertEquals(language, locale.getLanguage());\n+        assertEquals(country, locale.getCountry());\n+        assertEquals(variant, locale.getVariant());\n+        \n+    }\n+\n+    /**\n+     * Test toLocale() method.\n+     */\n+    public void testToLocale_1Part() {\n+        assertEquals(null, LocaleUtils.toLocale((String) null));\n+        \n+        assertValidToLocale(\"us\");\n+        assertValidToLocale(\"fr\");\n+        assertValidToLocale(\"de\");\n+        assertValidToLocale(\"zh\");\n+        // Valid format but lang doesnt exist, should make instance anyway\n+        assertValidToLocale(\"qq\");\n+        \n+        try {\n+            LocaleUtils.toLocale(\"Us\");\n+            fail(\"Should fail if not lowercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"US\");\n+            fail(\"Should fail if not lowercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"uS\");\n+            fail(\"Should fail if not lowercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"u#\");\n+            fail(\"Should fail if not lowercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        \n+        try {\n+            LocaleUtils.toLocale(\"u\");\n+            fail(\"Must be 2 chars if less than 5\");\n+        } catch (IllegalArgumentException iae) {}\n+       \n+        try {\n+            LocaleUtils.toLocale(\"uuu\");\n+            fail(\"Must be 2 chars if less than 5\");\n+        } catch (IllegalArgumentException iae) {}\n+\n+        try {\n+            LocaleUtils.toLocale(\"uu_U\");\n+            fail(\"Must be 2 chars if less than 5\");\n+        } catch (IllegalArgumentException iae) {}\n+    }        \n+\n+    /**\n+     * Test toLocale() method.\n+     */\n+    public void testToLocale_2Part() {\n+        assertValidToLocale(\"us_EN\", \"us\", \"EN\");\n+        //valid though doesnt exist\n+        assertValidToLocale(\"us_ZH\", \"us\", \"ZH\");\n+        \n+        try {\n+            LocaleUtils.toLocale(\"us-EN\");\n+            fail(\"Should fail as not underscore\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"us_En\");\n+            fail(\"Should fail second part not uppercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"us_en\");\n+            fail(\"Should fail second part not uppercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"us_eN\");\n+            fail(\"Should fail second part not uppercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"uS_EN\");\n+            fail(\"Should fail first part not lowercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"us_E3\");\n+            fail(\"Should fail second part not uppercase\");\n+        } catch (IllegalArgumentException iae) {}\n+    }        \n+\n+    /**\n+     * Test toLocale() method.\n+     */\n+    public void testToLocale_3Part() {\n+        assertValidToLocale(\"us_EN_A\", \"us\", \"EN\", \"A\");\n+        // this isn't pretty, but was caused by a jdk bug it seems\n+        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4210525\n+        if (SystemUtils.isJavaVersionAtLeast(1.4f)) {\n+            assertValidToLocale(\"us_EN_a\", \"us\", \"EN\", \"a\");\n+            assertValidToLocale(\"us_EN_SFsafdFDsdfF\", \"us\", \"EN\", \"SFsafdFDsdfF\");\n+        } else {\n+            assertValidToLocale(\"us_EN_a\", \"us\", \"EN\", \"A\");\n+            assertValidToLocale(\"us_EN_SFsafdFDsdfF\", \"us\", \"EN\", \"SFSAFDFDSDFF\");\n+        }\n+        \n+        try {\n+            LocaleUtils.toLocale(\"us_EN-a\");\n+            fail(\"Should fail as not underscore\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"uu_UU_\");\n+            fail(\"Must be 3, 5 or 7+ in length\");\n+        } catch (IllegalArgumentException iae) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Helper method for local lookups.\n+     *\n+     * @param locale  the input locale\n+     * @param defaultLocale  the input default locale\n+     * @param expected  expected results\n+     */\n+    private void assertLocaleLookupList(Locale locale, Locale defaultLocale, Locale[] expected) {\n+        List<Locale> localeList = defaultLocale == null ?\n+                LocaleUtils.localeLookupList(locale) :\n+                LocaleUtils.localeLookupList(locale, defaultLocale);\n+        \n+        assertEquals(expected.length, localeList.size());\n+        assertEquals(Arrays.asList(expected), localeList);\n+        assertUnmodifiableCollection(localeList);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test localeLookupList() method.\n+     */\n+    public void testLocaleLookupList_Locale() {\n+        assertLocaleLookupList(null, null, new Locale[0]);\n+        assertLocaleLookupList(LOCALE_QQ, null, new Locale[]{LOCALE_QQ});\n+        assertLocaleLookupList(LOCALE_EN, null, new Locale[]{LOCALE_EN});\n+        assertLocaleLookupList(LOCALE_EN, null, new Locale[]{LOCALE_EN});\n+        assertLocaleLookupList(LOCALE_EN_US, null,\n+            new Locale[] {\n+                LOCALE_EN_US,\n+                LOCALE_EN});\n+        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, null,\n+            new Locale[] {\n+                LOCALE_EN_US_ZZZZ,\n+                LOCALE_EN_US,\n+                LOCALE_EN});\n+    }        \n+\n+    /**\n+     * Test localeLookupList() method.\n+     */\n+    public void testLocaleLookupList_LocaleLocale() {\n+        assertLocaleLookupList(LOCALE_QQ, LOCALE_QQ, \n+                new Locale[]{LOCALE_QQ});\n+        assertLocaleLookupList(LOCALE_EN, LOCALE_EN, \n+                new Locale[]{LOCALE_EN});\n+        \n+        assertLocaleLookupList(LOCALE_EN_US, LOCALE_EN_US, \n+            new Locale[]{\n+                LOCALE_EN_US,\n+                LOCALE_EN});\n+        assertLocaleLookupList(LOCALE_EN_US, LOCALE_QQ,\n+            new Locale[] {\n+                LOCALE_EN_US,\n+                LOCALE_EN,\n+                LOCALE_QQ});\n+        assertLocaleLookupList(LOCALE_EN_US, LOCALE_QQ_ZZ,\n+            new Locale[] {\n+                LOCALE_EN_US,\n+                LOCALE_EN,\n+                LOCALE_QQ_ZZ});\n+        \n+        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, null,\n+            new Locale[] {\n+                LOCALE_EN_US_ZZZZ,\n+                LOCALE_EN_US,\n+                LOCALE_EN});\n+        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_EN_US_ZZZZ,\n+            new Locale[] {\n+                LOCALE_EN_US_ZZZZ,\n+                LOCALE_EN_US,\n+                LOCALE_EN});\n+        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_QQ,\n+            new Locale[] {\n+                LOCALE_EN_US_ZZZZ,\n+                LOCALE_EN_US,\n+                LOCALE_EN,\n+                LOCALE_QQ});\n+        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_QQ_ZZ,\n+            new Locale[] {\n+                LOCALE_EN_US_ZZZZ,\n+                LOCALE_EN_US,\n+                LOCALE_EN,\n+                LOCALE_QQ_ZZ});\n+        assertLocaleLookupList(LOCALE_FR_CA, LOCALE_EN,\n+            new Locale[] {\n+                LOCALE_FR_CA,\n+                LOCALE_FR,\n+                LOCALE_EN});\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test availableLocaleList() method.\n+     */\n+    public void testAvailableLocaleList() {\n+        List<Locale> list = LocaleUtils.availableLocaleList();\n+        List<Locale> list2 = LocaleUtils.availableLocaleList();\n+        assertNotNull(list);\n+        assertSame(list, list2);\n+        assertUnmodifiableCollection(list);\n+        \n+        Locale[] jdkLocaleArray = Locale.getAvailableLocales();\n+        List<Locale> jdkLocaleList = Arrays.asList(jdkLocaleArray);\n+        assertEquals(jdkLocaleList, list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test availableLocaleSet() method.\n+     */\n+    public void testAvailableLocaleSet() {\n+        Set<Locale> set = LocaleUtils.availableLocaleSet();\n+        Set<Locale> set2 = LocaleUtils.availableLocaleSet();\n+        assertNotNull(set);\n+        assertSame(set, set2);\n+        assertUnmodifiableCollection(set);\n+        \n+        Locale[] jdkLocaleArray = Locale.getAvailableLocales();\n+        List<Locale> jdkLocaleList = Arrays.asList(jdkLocaleArray);\n+        Set<Locale> jdkLocaleSet = new HashSet<Locale>(jdkLocaleList);\n+        assertEquals(jdkLocaleSet, set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test availableLocaleSet() method.\n+     */\n+    public void testIsAvailableLocale() {\n+        Set<Locale> set = LocaleUtils.availableLocaleSet();\n+        assertEquals(set.contains(LOCALE_EN), LocaleUtils.isAvailableLocale(LOCALE_EN));\n+        assertEquals(set.contains(LOCALE_EN_US), LocaleUtils.isAvailableLocale(LOCALE_EN_US));\n+        assertEquals(set.contains(LOCALE_EN_US_ZZZZ), LocaleUtils.isAvailableLocale(LOCALE_EN_US_ZZZZ));\n+        assertEquals(set.contains(LOCALE_FR), LocaleUtils.isAvailableLocale(LOCALE_FR));\n+        assertEquals(set.contains(LOCALE_FR_CA), LocaleUtils.isAvailableLocale(LOCALE_FR_CA));\n+        assertEquals(set.contains(LOCALE_QQ), LocaleUtils.isAvailableLocale(LOCALE_QQ));\n+        assertEquals(set.contains(LOCALE_QQ_ZZ), LocaleUtils.isAvailableLocale(LOCALE_QQ_ZZ));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Make sure the language by country is correct. It checks that \n+     * the LocaleUtils.languagesByCountry(country) call contains the \n+     * array of languages passed in. It may contain more due to JVM \n+     * variations.\n+     *\n+     * @param country\n+     * @param languages array of languages that should be returned\n+     */\n+    private void assertLanguageByCountry(String country, String[] languages) {\n+        List<Locale> list = LocaleUtils.languagesByCountry(country);\n+        List<Locale> list2 = LocaleUtils.languagesByCountry(country);\n+        assertNotNull(list);\n+        assertSame(list, list2);\n+        //search through langauges\n+        for (int i = 0; i < languages.length; i++) {\n+            Iterator<Locale> iterator = list.iterator();\n+            boolean found = false;\n+            // see if it was returned by the set\n+            while (iterator.hasNext()) {\n+                Locale locale = iterator.next();\n+                // should have an en empty variant\n+                assertTrue(locale.getVariant() == null\n+                        || locale.getVariant().length() == 0);\n+                assertEquals(country, locale.getCountry());\n+                if (languages[i].equals(locale.getLanguage())) {\n+                    found = true;\n+                    break;\n+                }\n+            }\n+            if (!found) {\n+                fail(\"Cound not find language: \" + languages[i]\n+                        + \" for country: \" + country);\n+            }\n+        }\n+        assertUnmodifiableCollection(list);\n+    }\n+\n+    /**\n+     * Test languagesByCountry() method.\n+     */\n+    public void testLanguagesByCountry() {\n+        assertLanguageByCountry(null, new String[0]);\n+        assertLanguageByCountry(\"GB\", new String[]{\"en\"});\n+        assertLanguageByCountry(\"ZZ\", new String[0]);\n+        assertLanguageByCountry(\"CH\", new String[]{\"fr\", \"de\", \"it\"});\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Make sure the country by language is correct. It checks that \n+     * the LocaleUtils.countryByLanguage(language) call contains the \n+     * array of countries passed in. It may contain more due to JVM \n+     * variations.\n+     *\n+     *\n+     * @param language\n+     * @param countries array of countries that should be returned\n+     */\n+    private void assertCountriesByLanguage(String language, String[] countries) {\n+        List<Locale> list = LocaleUtils.countriesByLanguage(language);\n+        List<Locale> list2 = LocaleUtils.countriesByLanguage(language);\n+        assertNotNull(list);\n+        assertSame(list, list2);\n+        //search through langauges\n+        for (int i = 0; i < countries.length; i++) {\n+            Iterator<Locale> iterator = list.iterator();\n+            boolean found = false;\n+            // see if it was returned by the set\n+            while (iterator.hasNext()) {\n+                Locale locale = iterator.next();\n+                // should have an en empty variant\n+                assertTrue(locale.getVariant() == null\n+                        || locale.getVariant().length() == 0);\n+                assertEquals(language, locale.getLanguage());\n+                if (countries[i].equals(locale.getCountry())) {\n+                    found = true;\n+                    break;\n+                }\n+            }\n+            if (!found) {\n+                fail(\"Cound not find language: \" + countries[i]\n+                        + \" for country: \" + language);\n+            }\n+        }\n+        assertUnmodifiableCollection(list);\n+    }\n+\n+    /**\n+     * Test countriesByLanguage() method.\n+     */\n+    public void testCountriesByLanguage() {\n+        assertCountriesByLanguage(null, new String[0]);\n+        assertCountriesByLanguage(\"de\", new String[]{\"DE\", \"CH\", \"AT\", \"LU\"});\n+        assertCountriesByLanguage(\"zz\", new String[0]);\n+        assertCountriesByLanguage(\"it\", new String[]{\"IT\", \"CH\"});\n+    }\n+\n+    /**\n+     * @param coll  the collection to check\n+     */\n+    private static void assertUnmodifiableCollection(Collection<?> coll) {\n+        try {\n+            coll.add(null);\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+    }\n+\n+    /**\n+     * Tests #LANG-328 - only language+variant\n+     */\n+    public void testLang328() {\n+        assertValidToLocale(\"fr__POSIX\", \"fr\", \"\", \"POSIX\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/ObjectUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.ObjectUtils}.\n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:jmcnally@collab.net\">John McNally</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id$\n+ */\n+public class ObjectUtilsTest extends TestCase {\n+    private static final String FOO = \"foo\";\n+    private static final String BAR = \"bar\";\n+\n+    public ObjectUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ObjectUtilsTest.class);\n+        suite.setName(\"ObjectUtils Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new ObjectUtils());\n+        Constructor<?>[] cons = ObjectUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(ObjectUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(ObjectUtils.class.getModifiers()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsNull() {\n+        Object o = FOO;\n+        Object dflt = BAR;\n+        assertSame(\"dflt was not returned when o was null\", dflt, ObjectUtils.defaultIfNull(null, dflt));\n+        assertSame(\"dflt was returned when o was not null\", o, ObjectUtils.defaultIfNull(o, dflt));\n+    }\n+\n+    public void testFirstNonNull() {\n+        assertEquals(null, ObjectUtils.firstNonNull(null, null));\n+        assertEquals(\"\", ObjectUtils.firstNonNull(null, \"\"));\n+        String firstNonNullGenerics = ObjectUtils.firstNonNull(null, null, \"123\", \"456\");\n+        assertEquals(\"123\", firstNonNullGenerics);\n+        assertEquals(\"123\", ObjectUtils.firstNonNull(\"123\", null, \"456\", null));\n+        assertEquals(null, ObjectUtils.firstNonNull());\n+        assertSame(Boolean.TRUE, ObjectUtils.firstNonNull(Boolean.TRUE));\n+        assertNull(ObjectUtils.firstNonNull());\n+        assertNull(ObjectUtils.firstNonNull(null, null));\n+//        assertSame(\"123\", ObjectUtils.firstNonNull(null, ObjectUtils.NULL, \"123\", \"456\"));\n+//        assertSame(\"456\", ObjectUtils.firstNonNull(ObjectUtils.NULL, \"456\", \"123\", null));\n+//        assertNull(ObjectUtils.firstNonNull(null, null, ObjectUtils.NULL));\n+        assertNull(ObjectUtils.firstNonNull((Object) null));\n+        assertNull(ObjectUtils.firstNonNull((Object[]) null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEquals() {\n+        assertTrue(\"ObjectUtils.equals(null, null) returned false\", ObjectUtils.equals(null, null));\n+        assertTrue(\"ObjectUtils.equals(\\\"foo\\\", null) returned true\", !ObjectUtils.equals(FOO, null));\n+        assertTrue(\"ObjectUtils.equals(null, \\\"bar\\\") returned true\", !ObjectUtils.equals(null, BAR));\n+        assertTrue(\"ObjectUtils.equals(\\\"foo\\\", \\\"bar\\\") returned true\", !ObjectUtils.equals(FOO, BAR));\n+        assertTrue(\"ObjectUtils.equals(\\\"foo\\\", \\\"foo\\\") returned false\", ObjectUtils.equals(FOO, FOO));\n+    }\n+\n+    public void testHashCode() {\n+        assertEquals(0, ObjectUtils.hashCode(null));\n+        assertEquals(\"a\".hashCode(), ObjectUtils.hashCode(\"a\"));\n+    }\n+\n+//    /**\n+//     * Show that java.util.Date and java.sql.Timestamp are apples and oranges.\n+//     * Prompted by an email discussion. \n+//     * \n+//     * The behavior is different b/w Sun Java 1.3.1_10 and 1.4.2_03.\n+//     */\n+//    public void testDateEqualsJava() {\n+//        long now = 1076957313284L; // Feb 16, 2004 10:49... PST\n+//        java.util.Date date = new java.util.Date(now);\n+//        java.sql.Timestamp realTimestamp = new java.sql.Timestamp(now);\n+//        java.util.Date timestamp = realTimestamp;\n+//        // sanity check 1:\n+//        assertEquals(284000000, realTimestamp.getNanos());\n+//        assertEquals(1076957313284L, date.getTime());\n+//        //\n+//        // On Sun 1.3.1_10:\n+//        //junit.framework.AssertionFailedError: expected:<1076957313284> but was:<1076957313000>\n+//        //\n+//        //assertEquals(1076957313284L, timestamp.getTime());\n+//        //\n+//        //junit.framework.AssertionFailedError: expected:<1076957313284> but was:<1076957313000>\n+//        //\n+//        //assertEquals(1076957313284L, realTimestamp.getTime());\n+//        // sanity check 2:        \n+//        assertEquals(date.getDay(), realTimestamp.getDay());\n+//        assertEquals(date.getHours(), realTimestamp.getHours());\n+//        assertEquals(date.getMinutes(), realTimestamp.getMinutes());\n+//        assertEquals(date.getMonth(), realTimestamp.getMonth());\n+//        assertEquals(date.getSeconds(), realTimestamp.getSeconds());\n+//        assertEquals(date.getTimezoneOffset(), realTimestamp.getTimezoneOffset());\n+//        assertEquals(date.getYear(), realTimestamp.getYear());\n+//        //\n+//        // Time values are == and equals() on Sun 1.4.2_03 but NOT on Sun 1.3.1_10:\n+//        //\n+//        //assertFalse(\"Sanity check failed: date.getTime() == timestamp.getTime()\", date.getTime() == timestamp.getTime());\n+//        //assertFalse(\"Sanity check failed: timestamp.equals(date)\", timestamp.equals(date));\n+//        //assertFalse(\"Sanity check failed: date.equals(timestamp)\", date.equals(timestamp));\n+//        // real test:\n+//        //assertFalse(\"java.util.Date and java.sql.Timestamp should be equal\", ObjectUtils.equals(date, timestamp));\n+//    }\n+    \n+    public void testIdentityToString() {\n+        assertEquals(null, ObjectUtils.identityToString(null));\n+        assertEquals(\n+            \"java.lang.String@\" + Integer.toHexString(System.identityHashCode(FOO)),\n+            ObjectUtils.identityToString(FOO));\n+        Integer i = new Integer(90);\n+        String expected = \"java.lang.Integer@\" + Integer.toHexString(System.identityHashCode(i));\n+        assertEquals(expected, ObjectUtils.identityToString(i));\n+        StringBuffer buffer = new StringBuffer();\n+        ObjectUtils.identityToString(buffer, i);\n+        assertEquals(expected, buffer.toString());\n+\n+        try {\n+            ObjectUtils.identityToString(null, \"tmp\");\n+            fail(\"NullPointerException expected\");\n+        } catch(NullPointerException npe) {\n+        }\n+        try {\n+            ObjectUtils.identityToString(new StringBuffer(), null);\n+            fail(\"NullPointerException expected\");\n+        } catch(NullPointerException npe) {\n+        }\n+    }\n+\n+    public void testToString_Object() {\n+        assertEquals(\"\", ObjectUtils.toString((Object) null) );\n+        assertEquals(Boolean.TRUE.toString(), ObjectUtils.toString(Boolean.TRUE) );\n+    }\n+            \n+    public void testToString_ObjectString() {\n+        assertEquals(BAR, ObjectUtils.toString((Object) null, BAR) );\n+        assertEquals(Boolean.TRUE.toString(), ObjectUtils.toString(Boolean.TRUE, BAR) );\n+    }\n+\n+    public void testNull() {\n+        assertNotNull(ObjectUtils.NULL);\n+        assertTrue(ObjectUtils.NULL instanceof ObjectUtils.Null);\n+        assertSame(ObjectUtils.NULL, SerializationUtils.clone(ObjectUtils.NULL));\n+    }\n+    \n+    \n+    \n+    public void testMax() {\n+        Calendar calendar = Calendar.getInstance();\n+        Date nonNullComparable1 = calendar.getTime();\n+        Date nonNullComparable2 = calendar.getTime();\n+        \n+        calendar.set( Calendar.YEAR, calendar.get( Calendar.YEAR ) -1 );\n+        Date minComparable = calendar.getTime();\n+        \n+        assertNotSame( nonNullComparable1, nonNullComparable2 );\n+        \n+        assertSame( nonNullComparable1, ObjectUtils.max( null, nonNullComparable1 ) );\n+        assertSame( nonNullComparable1, ObjectUtils.max( nonNullComparable1, null ) );\n+        assertSame( nonNullComparable1, ObjectUtils.max( nonNullComparable1, nonNullComparable2 ) );\n+        assertSame( nonNullComparable2, ObjectUtils.max( nonNullComparable2, nonNullComparable1 ) );\n+        assertSame( nonNullComparable1, ObjectUtils.max( nonNullComparable1, minComparable ) );\n+        assertSame( nonNullComparable1, ObjectUtils.max( minComparable, nonNullComparable1 ) );\n+\n+        assertNull( ObjectUtils.max((String)null, (String)null) );\n+    }\n+    \n+    public void testMin() {\n+        Calendar calendar = Calendar.getInstance();\n+        Date nonNullComparable1 = calendar.getTime();\n+        Date nonNullComparable2 = calendar.getTime();\n+        \n+        calendar.set( Calendar.YEAR, calendar.get( Calendar.YEAR ) -1 );\n+        Date minComparable = calendar.getTime();\n+        \n+        assertNotSame( nonNullComparable1, nonNullComparable2 );\n+        \n+        assertSame( nonNullComparable1, ObjectUtils.min( null, nonNullComparable1 ) );\n+        assertSame( nonNullComparable1, ObjectUtils.min( nonNullComparable1, null ) );\n+        assertSame( nonNullComparable1, ObjectUtils.min( nonNullComparable1, nonNullComparable2 ) );\n+        assertSame( nonNullComparable2, ObjectUtils.min( nonNullComparable2, nonNullComparable1 ) );\n+        assertSame( minComparable, ObjectUtils.min( nonNullComparable1, minComparable ) );\n+        assertSame( minComparable, ObjectUtils.min( minComparable, nonNullComparable1 ) );\n+\n+        assertNull( ObjectUtils.min((String)null, (String)null) );\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/RandomStringUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.RandomStringUtils}.\n+ *\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @author Phil Steitz\n+ * @version $Id$\n+ */\n+public class RandomStringUtilsTest extends junit.framework.TestCase {\n+    /**\n+     * Construct a new instance of RandomStringUtilsTest with the specified name\n+     */\n+    public RandomStringUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(RandomStringUtilsTest.class);\n+        suite.setName(\"RandomStringUtils Tests\");\n+        return suite;\n+    }\n+    \n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    @Override\n+    public void setUp() {\n+    }\n+    \n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    @Override\n+    public void tearDown() {\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new RandomStringUtils());\n+        Constructor<?>[] cons = RandomStringUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(RandomStringUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(RandomStringUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test the implementation\n+     */\n+    public void testRandomStringUtils() {\n+        String r1 = RandomStringUtils.random(50);\n+        assertEquals(\"random(50) length\", 50, r1.length());\n+        String r2 = RandomStringUtils.random(50);\n+        assertEquals(\"random(50) length\", 50, r2.length());\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+        \n+        r1 = RandomStringUtils.randomAscii(50);\n+        assertEquals(\"randomAscii(50) length\", 50, r1.length());\n+        for(int i = 0; i < r1.length(); i++) {\n+            assertTrue(\"char between 32 and 127\", r1.charAt(i) >= 32 && r1.charAt(i) <= 127);\n+        }        \n+        r2 = RandomStringUtils.randomAscii(50);\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+\n+        r1 = RandomStringUtils.randomAlphabetic(50);\n+        assertEquals(\"randomAlphabetic(50)\", 50, r1.length());\n+        for(int i = 0; i < r1.length(); i++) {\n+            assertEquals(\"r1 contains alphabetic\", true, Character.isLetter(r1.charAt(i)) && !Character.isDigit(r1.charAt(i)));\n+        }\n+        r2 = RandomStringUtils.randomAlphabetic(50);\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+        \n+        r1 = RandomStringUtils.randomAlphanumeric(50);\n+        assertEquals(\"randomAlphanumeric(50)\", 50, r1.length());\n+        for(int i = 0; i < r1.length(); i++) {\n+            assertEquals(\"r1 contains alphanumeric\", true, Character.isLetterOrDigit(r1.charAt(i)));\n+        }\n+        r2 = RandomStringUtils.randomAlphabetic(50);\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+        \n+        r1 = RandomStringUtils.randomNumeric(50);\n+        assertEquals(\"randomNumeric(50)\", 50, r1.length());\n+        for(int i = 0; i < r1.length(); i++) {\n+            assertEquals(\"r1 contains numeric\", true, Character.isDigit(r1.charAt(i)) && !Character.isLetter(r1.charAt(i)));\n+        }\n+        r2 = RandomStringUtils.randomNumeric(50);\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+        \n+        String set = \"abcdefg\";\n+        r1 = RandomStringUtils.random(50, set);\n+        assertEquals(\"random(50, \\\"abcdefg\\\")\", 50, r1.length());\n+        for(int i = 0; i < r1.length(); i++) {\n+            assertTrue(\"random char in set\", set.indexOf(r1.charAt(i)) > -1);\n+        }\n+        r2 = RandomStringUtils.random(50, set);\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+        \n+        r1 = RandomStringUtils.random(50, (String) null);\n+        assertEquals(\"random(50) length\", 50, r1.length());\n+        r2 = RandomStringUtils.random(50, (String) null);\n+        assertEquals(\"random(50) length\", 50, r2.length());\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+        \n+        set = \"stuvwxyz\";\n+        r1 = RandomStringUtils.random(50, set.toCharArray());\n+        assertEquals(\"random(50, \\\"stuvwxyz\\\")\", 50, r1.length());\n+        for(int i = 0; i < r1.length(); i++) {\n+            assertTrue(\"random char in set\", set.indexOf(r1.charAt(i)) > -1);\n+        }\n+        r2 = RandomStringUtils.random(50, set);\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+        \n+        r1 = RandomStringUtils.random(50, (char[]) null);\n+        assertEquals(\"random(50) length\", 50, r1.length());\n+        r2 = RandomStringUtils.random(50, (char[]) null);\n+        assertEquals(\"random(50) length\", 50, r2.length());\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+\n+        long seed = System.currentTimeMillis();\n+        r1 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed));\n+        r2 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed));\n+        assertEquals(\"r1.equals(r2)\", r1, r2);\n+\n+        r1 = RandomStringUtils.random(0);\n+        assertEquals(\"random(0).equals(\\\"\\\")\", \"\", r1);\n+\n+    }\n+    public void testExceptions() {\n+        try {\n+            RandomStringUtils.random(-1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            RandomStringUtils.random(-1, true, true);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            RandomStringUtils.random(-1, new char[0]);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            RandomStringUtils.random(-1, \"\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            RandomStringUtils.random(-1, 'a', 'z', false, false);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            RandomStringUtils.random(-1, 'a', 'z', false, false, new char[0]);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            RandomStringUtils.random(-1, 'a', 'z', false, false, new char[0], new Random());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    /**\n+     * Make sure boundary alphanumeric characters are generated by randomAlphaNumeric\n+     * This test will fail randomly with probability = 6 * (61/62)**1000 ~ 5.2E-7\n+     */  \n+    public void testRandomAlphaNumeric() {\n+        char[] testChars = {'a', 'z', 'A', 'Z', '0', '9'};\n+        boolean[] found = {false, false, false, false, false, false};\n+        for (int i = 0; i < 100; i++) {\n+            String randString = RandomStringUtils.randomAlphanumeric(10);\n+            for (int j = 0; j < testChars.length; j++) {\n+                if (randString.indexOf(testChars[j]) > 0) {\n+                    found[j] = true;\n+                }\n+            }\n+        }\n+        for (int i = 0; i < testChars.length; i++) {\n+            if (!found[i]) {\n+                fail(\"alphanumeric character not generated in 1000 attempts: \" \n+                   + testChars[i] +\" -- repeated failures indicate a problem \");\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Make sure '0' and '9' are generated by randomNumeric\n+     * This test will fail randomly with probability = 2 * (9/10)**1000 ~ 3.5E-46\n+     */  \n+    public void testRandomNumeric() {\n+        char[] testChars = {'0','9'};\n+        boolean[] found = {false, false};\n+        for (int i = 0; i < 100; i++) {\n+            String randString = RandomStringUtils.randomNumeric(10);\n+            for (int j = 0; j < testChars.length; j++) {\n+                if (randString.indexOf(testChars[j]) > 0) {\n+                    found[j] = true;\n+                }\n+            }\n+        }\n+        for (int i = 0; i < testChars.length; i++) {\n+            if (!found[i]) {\n+                fail(\"digit not generated in 1000 attempts: \" \n+                   + testChars[i] +\" -- repeated failures indicate a problem \");\n+            }\n+        }  \n+    }\n+    \n+    /**\n+     * Make sure boundary alpha characters are generated by randomAlphabetic\n+     * This test will fail randomly with probability = 4 * (51/52)**1000 ~ 1.58E-8\n+     */  \n+    public void testRandomAlphabetic() {\n+        char[] testChars = {'a', 'z', 'A', 'Z'};\n+        boolean[] found = {false, false, false, false};\n+        for (int i = 0; i < 100; i++) {\n+            String randString = RandomStringUtils.randomAlphabetic(10);\n+            for (int j = 0; j < testChars.length; j++) {\n+                if (randString.indexOf(testChars[j]) > 0) {\n+                    found[j] = true;\n+                }\n+            }\n+        }\n+        for (int i = 0; i < testChars.length; i++) {\n+            if (!found[i]) {\n+                fail(\"alphanumeric character not generated in 1000 attempts: \" \n+                   + testChars[i] +\" -- repeated failures indicate a problem \");\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Make sure 32 and 127 are generated by randomNumeric\n+     * This test will fail randomly with probability = 2*(95/96)**1000 ~ 5.7E-5\n+     */  \n+    public void testRandomAscii() {\n+        char[] testChars = {(char) 32, (char) 126};\n+        boolean[] found = {false, false};\n+        for (int i = 0; i < 100; i++) {\n+            String randString = RandomStringUtils.randomAscii(10);\n+            for (int j = 0; j < testChars.length; j++) {\n+                if (randString.indexOf(testChars[j]) > 0) {\n+                    found[j] = true;\n+                }\n+            }\n+        }\n+        for (int i = 0; i < testChars.length; i++) {\n+            if (!found[i]) {\n+                fail(\"ascii character not generated in 1000 attempts: \" \n+                + (int) testChars[i] + \n+                 \" -- repeated failures indicate a problem\");\n+            }\n+        }  \n+    }\n+    \n+    /** \n+     * Test homogeneity of random strings generated --\n+     * i.e., test that characters show up with expected frequencies\n+     * in generated strings.  Will fail randomly about 1 in 1000 times.\n+     * Repeated failures indicate a problem.\n+     */\n+    public void testRandomStringUtilsHomog() {\n+        String set = \"abc\";\n+        char[] chars = set.toCharArray();\n+        String gen = \"\";\n+        int[] counts = {0,0,0};\n+        int[] expected = {200,200,200};\n+        for (int i = 0; i< 100; i++) {\n+           gen = RandomStringUtils.random(6,chars);\n+           for (int j = 0; j < 6; j++) {\n+               switch (gen.charAt(j)) {\n+                   case 'a': {counts[0]++; break;}\n+                   case 'b': {counts[1]++; break;}\n+                   case 'c': {counts[2]++; break;}\n+                   default: {fail(\"generated character not in set\");}\n+               }\n+           }\n+        } \n+        // Perform chi-square test with df = 3-1 = 2, testing at .001 level\n+        assertTrue(\"test homogeneity -- will fail about 1 in 1000 times\",\n+            chiSquare(expected,counts) < 13.82);  \n+    }\n+    \n+    /**\n+     * Computes Chi-Square statistic given observed and expected counts\n+     * @param observed array of observed frequency counts\n+     * @param expected array of expected frequency counts\n+     */\n+    private double chiSquare(int[] expected, int[] observed) {\n+        double sumSq = 0.0d;\n+        double dev = 0.0d;\n+        for (int i = 0; i < observed.length; i++) {\n+            dev = (observed[i] - expected[i]);\n+            sumSq += dev * dev / expected[i];\n+        }\n+        return sumSq;\n+    }           \n+\n+    /**\n+     * Checks if the string got by {@link RandomStringUtils#random(int)}\n+     * can be converted to UTF-8 and back without loss.\n+     *\n+     * @see <a href=\"http://issues.apache.org/jira/browse/LANG-100\">LANG-100</a>\n+     *\n+     * @throws Exception\n+     */\n+    public void testLang100() throws Exception {\n+        int size = 5000;\n+        String encoding = \"UTF-8\";\n+        String orig = RandomStringUtils.random(size);\n+        byte[] bytes = orig.getBytes(encoding);\n+        String copy = new String(bytes, encoding);\n+\n+        // for a verbose compare:\n+        for (int i=0; i < orig.length() && i < copy.length(); i++) {\n+            char o = orig.charAt(i);\n+            char c = copy.charAt(i);\n+            assertEquals(\"differs at \" + i + \"(\" + Integer.toHexString((new Character(o)).hashCode()) + \",\" +\n+            Integer.toHexString((new Character(c)).hashCode()) + \")\", o, c);\n+        }\n+        // compare length also\n+        assertEquals(orig.length(), copy.length());\n+        // just to be complete\n+        assertEquals(orig, copy);\n+    }\n+\n+    public static void main(String args[]) {\n+        TestRunner.run(suite());\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/RangeTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang;\n+\n+import java.util.Comparator;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * <p>\n+ * Tests the methods in the {@link org.apache.commons.lang.Range} class.\n+ * </p>\n+ * \n+ * @version $Id: RangeTest.java 754804 2009-03-16 02:06:18Z sebb $\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class RangeTest extends TestCase {\n+\n+    private Range<Byte> byteRange;\n+    private Range<Byte> byteRange2;\n+    private Range<Byte> byteRange3;\n+\n+    private Range<Integer> intRange;\n+    private Range<Long> longRange;\n+    private Range<Float> floatRange;\n+    private Range<Double> doubleRange;\n+\n+    @SuppressWarnings(\"cast\") // intRange\n+    @Override\n+    public void setUp() {\n+        byteRange   = Range.between((byte) 0, (byte) 5);\n+        byteRange2  = Range.between((byte) 0, (byte) 5);\n+        byteRange3  = Range.between((byte) 0, (byte) 10);\n+\n+        intRange    = Range.between((int) 10, (int) 20);\n+        longRange   = Range.between((long) 10, (long) 20);\n+        floatRange  = Range.between((float) 10, (float) 20);\n+        doubleRange = Range.between((double) 10, (double) 20);\n+    }\n+\n+    // --------------------------------------------------------------------------\n+\n+    public void testComparableConstructors() {\n+        Comparable c = \n+            new Comparable() { \n+                public int compareTo(Object other) {\n+                    return 1;\n+                }\n+            };\n+        Range.is(c);\n+        Range.between(c, c);\n+    }\n+\n+    public void testIsWithCompare(){\n+        Comparator<Integer> c = new Comparator<Integer>(){\n+            public int compare(Integer o1, Integer o2) {\n+                return 0; // all integers are equal\n+            }\n+        };\n+        Range<Integer> ri = Range.is(10);\n+        assertFalse(\"should not contain null\",ri.contains(null));\n+        assertTrue(\"should contain 10\",ri.contains(10));\n+        assertFalse(\"should not contain 11\",ri.contains(11));\n+        ri = Range.is(10,c);\n+        assertFalse(\"should not contain null\",ri.contains(null));\n+        assertTrue(\"should contain 10\",ri.contains(10));\n+        assertTrue(\"should contain 11\",ri.contains(11));\n+    }\n+\n+    public void testBetweenWithCompare(){\n+        // TODO add tests with a better comparator\n+        Comparator<Integer> c = new Comparator<Integer>(){\n+            public int compare(Integer o1, Integer o2) {\n+                return 0; // all integers are equal\n+            }\n+        };\n+        Range<Integer> rb = Range.between(-10,20);\n+        assertFalse(\"should not contain null\",rb.contains(null));\n+        assertTrue(\"should contain 10\",rb.contains(10));\n+        assertTrue(\"should contain -10\",rb.contains(-10));\n+        assertFalse(\"should not contain 21\",rb.contains(21));\n+        assertFalse(\"should not contain -11\",rb.contains(-11));\n+        rb = Range.between(-10,20,c);\n+        assertFalse(\"should not contain null\",rb.contains(null));\n+        assertTrue(\"should contain 10\",rb.contains(10));\n+        assertTrue(\"should contain -10\",rb.contains(-10));\n+        assertTrue(\"should contain 21\",rb.contains(21));\n+        assertTrue(\"should contain -11\",rb.contains(-11));\n+    }\n+\n+    // --------------------------------------------------------------------------\n+\n+    public void testRangeOfChars() {\n+        Range<Character> chars = Range.between('a', 'z');\n+        assertTrue(chars.contains('b'));\n+        assertFalse(chars.contains('B'));\n+    }\n+\n+    // --------------------------------------------------------------------------\n+\n+    public void testEqualsObject() {\n+        assertEquals(byteRange, byteRange);\n+        assertEquals(byteRange, byteRange2);\n+        assertEquals(byteRange2, byteRange2);\n+        assertTrue(byteRange.equals(byteRange));\n+        assertTrue(byteRange2.equals(byteRange2));\n+        assertTrue(byteRange3.equals(byteRange3));\n+        assertFalse(byteRange2.equals(byteRange3));\n+        assertFalse(byteRange2.equals(null));\n+        assertFalse(byteRange2.equals(\"Ni!\"));\n+    }\n+\n+    public void testHashCode() {\n+        assertEquals(byteRange.hashCode(), byteRange2.hashCode());\n+        assertFalse(byteRange.hashCode() == byteRange3.hashCode());\n+\n+        assertEquals(intRange.hashCode(), intRange.hashCode());\n+        assertTrue(intRange.hashCode() != 0);\n+    }\n+\n+    public void testToString() {\n+        assertNotNull(byteRange.toString());\n+\n+        String str = intRange.toString();\n+        assertEquals(\"Range[10,20]\", str);\n+//        assertSame(str, intRange.toString());  // no longer passes - does it matter?\n+        assertEquals(\"Range[-20,-10]\", Range.between(-20, -10).toString());\n+    }\n+\n+    // --------------------------------------------------------------------------\n+\n+    public void testGetMinimum() {\n+        assertEquals(10, (int) intRange.getMinimum());\n+        assertEquals(10L, (long) longRange.getMinimum());\n+        assertEquals(10f, floatRange.getMinimum(), 0.00001f);\n+        assertEquals(10d, doubleRange.getMinimum(), 0.00001d);\n+    }\n+    \n+    public void testGetMaximum() {\n+        assertEquals(20, (int) intRange.getMaximum());\n+        assertEquals(20L, (long) longRange.getMaximum());\n+        assertEquals(20f, floatRange.getMaximum(), 0.00001f);\n+        assertEquals(20d, doubleRange.getMaximum(), 0.00001d);\n+    }\n+\n+    public void testContains() {\n+        assertFalse(intRange.contains(null));\n+        \n+        assertFalse(intRange.contains(5));\n+        assertTrue(intRange.contains(10));\n+        assertTrue(intRange.contains(15));\n+        assertTrue(intRange.contains(20));\n+        assertFalse(intRange.contains(25));\n+    }\n+\n+    public void testElementBefore() {\n+        assertFalse(intRange.elementBefore(null));\n+        \n+        assertTrue(intRange.elementBefore(5));\n+        assertFalse(intRange.elementBefore(10));\n+        assertFalse(intRange.elementBefore(15));\n+        assertFalse(intRange.elementBefore(20));\n+        assertFalse(intRange.elementBefore(25));\n+    }\n+\n+    public void testElementAfter() {\n+        assertFalse(intRange.elementAfter(null));\n+        \n+        assertFalse(intRange.elementAfter(5));\n+        assertFalse(intRange.elementAfter(10));\n+        assertFalse(intRange.elementAfter(15));\n+        assertFalse(intRange.elementAfter(20));\n+        assertTrue(intRange.elementAfter(25));\n+    }\n+\n+    public void testElementCompareTo() {\n+        try {\n+            intRange.elementCompareTo(null);\n+            fail(\"NullPointerException should have been thrown\");\n+        } catch(NullPointerException npe) {\n+            // expected\n+        }\n+        \n+        assertEquals(-1, intRange.elementCompareTo(5));\n+        assertEquals(0, intRange.elementCompareTo(10));\n+        assertEquals(0, intRange.elementCompareTo(15));\n+        assertEquals(0, intRange.elementCompareTo(20));\n+        assertEquals(1, intRange.elementCompareTo(25));\n+    }\n+\n+    // --------------------------------------------------------------------------\n+\n+    public void testContainsRange() {\n+\n+        // null handling\n+        assertFalse(intRange.containsRange(null));\n+\n+        // easy inside range\n+        assertTrue(intRange.containsRange(Range.between(12, 18)));\n+\n+        // outside range on each side\n+        assertFalse(intRange.containsRange(Range.between(32, 45)));\n+        assertFalse(intRange.containsRange(Range.between(2, 8)));\n+\n+        // equals range\n+        assertTrue(intRange.containsRange(Range.between(10, 20)));\n+\n+        // overlaps\n+        assertFalse(intRange.containsRange(Range.between(9, 14)));\n+        assertFalse(intRange.containsRange(Range.between(16, 21)));\n+\n+        // touches lower boundary\n+        assertTrue(intRange.containsRange(Range.between(10, 19)));\n+        assertFalse(intRange.containsRange(Range.between(10, 21)));\n+\n+        // touches upper boundary\n+        assertTrue(intRange.containsRange(Range.between(11, 20)));\n+        assertFalse(intRange.containsRange(Range.between(9, 20)));\n+        \n+        // negative\n+        assertFalse(intRange.containsRange(Range.between(-11, -18)));\n+\n+    }\n+\n+    public void testOverlapsRange() {\n+\n+        // null handling\n+        assertFalse(intRange.overlapsRange(null));\n+\n+        // easy inside range\n+        assertTrue(intRange.overlapsRange(Range.between(12, 18)));\n+\n+        // outside range on each side\n+        assertFalse(intRange.overlapsRange(Range.between(32, 45)));\n+        assertFalse(intRange.overlapsRange(Range.between(2, 8)));\n+\n+        // equals range\n+        assertTrue(intRange.overlapsRange(Range.between(10, 20)));\n+\n+        // overlaps\n+        assertTrue(intRange.overlapsRange(Range.between(9, 14)));\n+        assertTrue(intRange.overlapsRange(Range.between(16, 21)));\n+\n+        // touches lower boundary\n+        assertTrue(intRange.overlapsRange(Range.between(10, 19)));\n+        assertTrue(intRange.overlapsRange(Range.between(10, 21)));\n+\n+        // touches upper boundary\n+        assertTrue(intRange.overlapsRange(Range.between(11, 20)));\n+        assertTrue(intRange.overlapsRange(Range.between(9, 20)));\n+        \n+        // negative\n+        assertFalse(intRange.overlapsRange(Range.between(-11, -18)));\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/SerializationUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.HashMap;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.SerializationUtils}.\n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @version $Id$\n+ */\n+public class SerializationUtilsTest extends TestCase {\n+\n+  static final String CLASS_NOT_FOUND_MESSAGE = \"ClassNotFoundSerialization.readObject fake exception\";\n+    protected static final String SERIALIZE_IO_EXCEPTION_MESSAGE = \"Anonymous OutputStream I/O exception\";\n+  \n+    private String iString;\n+    private Integer iInteger;\n+    private HashMap<Object, Object> iMap;\n+\n+    public SerializationUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SerializationUtilsTest.class);\n+        suite.setName(\"SerializationUtils Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+\n+        iString = \"foo\";\n+        iInteger = new Integer(7);\n+        iMap = new HashMap<Object, Object>();\n+        iMap.put(\"FOO\", iString);\n+        iMap.put(\"BAR\", iInteger);\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new SerializationUtils());\n+        Constructor<?>[] cons = SerializationUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(SerializationUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(SerializationUtils.class.getModifiers()));\n+    }\n+    \n+    public void testException() {\n+        SerializationException serEx;\n+        Exception ex = new Exception();\n+        \n+        serEx = new SerializationException();\n+        assertSame(null, serEx.getMessage());\n+        assertSame(null, serEx.getCause());\n+        \n+        serEx = new SerializationException(\"Message\");\n+        assertSame(\"Message\", serEx.getMessage());\n+        assertSame(null, serEx.getCause());\n+        \n+        serEx = new SerializationException(ex);\n+        assertEquals(\"java.lang.Exception\", serEx.getMessage());\n+        assertSame(ex, serEx.getCause());\n+        \n+        serEx = new SerializationException(\"Message\", ex);\n+        assertSame(\"Message\", serEx.getMessage());\n+        assertSame(ex, serEx.getCause());\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testSerializeStream() throws Exception {\n+        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();\n+        SerializationUtils.serialize(iMap, streamTest);\n+\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(iMap);\n+        oos.flush();\n+        oos.close();\n+\n+        byte[] testBytes = streamTest.toByteArray();\n+        byte[] realBytes = streamReal.toByteArray();\n+        assertEquals(testBytes.length, realBytes.length);\n+        for (int i = 0; i < realBytes.length; i++) {\n+            assertEquals(realBytes[i], testBytes[i]);\n+        }\n+    }\n+\n+    public void testSerializeStreamUnserializable() throws Exception {\n+        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();\n+        try {\n+            iMap.put(new Object(), new Object());\n+            SerializationUtils.serialize(iMap, streamTest);\n+        } catch (SerializationException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testSerializeStreamNullObj() throws Exception {\n+        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();\n+        SerializationUtils.serialize(null, streamTest);\n+\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(null);\n+        oos.flush();\n+        oos.close();\n+\n+        byte[] testBytes = streamTest.toByteArray();\n+        byte[] realBytes = streamReal.toByteArray();\n+        assertEquals(testBytes.length, realBytes.length);\n+        for (int i = 0; i < realBytes.length; i++) {\n+            assertEquals(realBytes[i], testBytes[i]);\n+        }\n+    }\n+\n+    public void testSerializeStreamObjNull() throws Exception {\n+        try {\n+            SerializationUtils.serialize(iMap, null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testSerializeStreamNullNull() throws Exception {\n+        try {\n+            SerializationUtils.serialize(null, null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    public void testSerializeIOException() throws Exception {\n+        // forces an IOException when the ObjectOutputStream is created, to test not closing the stream\n+        // in the finally block\n+        OutputStream streamTest = new OutputStream() {\n+            @Override\n+            public void write(int arg0) throws IOException {\n+                throw new IOException(SERIALIZE_IO_EXCEPTION_MESSAGE);\n+            }\n+        };\n+        try {\n+            SerializationUtils.serialize(iMap, streamTest);\n+        }\n+        catch(SerializationException e) {\n+            assertEquals(\"java.io.IOException: \" + SERIALIZE_IO_EXCEPTION_MESSAGE, e.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testDeserializeStream() throws Exception {\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(iMap);\n+        oos.flush();\n+        oos.close();\n+\n+        ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());\n+        Object test = SerializationUtils.deserialize(inTest);\n+        assertNotNull(test);\n+        assertTrue(test instanceof HashMap<?, ?>);\n+        assertTrue(test != iMap);\n+        HashMap<?, ?> testMap = (HashMap<?, ?>) test;\n+        assertEquals(iString, testMap.get(\"FOO\"));\n+        assertTrue(iString != testMap.get(\"FOO\"));\n+        assertEquals(iInteger, testMap.get(\"BAR\"));\n+        assertTrue(iInteger != testMap.get(\"BAR\"));\n+        assertEquals(iMap, testMap);\n+    }\n+\n+    public void testDeserializeStreamOfNull() throws Exception {\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(null);\n+        oos.flush();\n+        oos.close();\n+\n+        ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());\n+        Object test = SerializationUtils.deserialize(inTest);\n+        assertNull(test);\n+    }\n+\n+    public void testDeserializeStreamNull() throws Exception {\n+        try {\n+            SerializationUtils.deserialize((InputStream) null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testDeserializeStreamBadStream() throws Exception {\n+        try {\n+            SerializationUtils.deserialize(new ByteArrayInputStream(new byte[0]));\n+        } catch (SerializationException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testDeserializeStreamClassNotFound() throws Exception {\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(new ClassNotFoundSerialization());\n+        oos.flush();\n+        oos.close();\n+\n+        ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());\n+        try {\n+            @SuppressWarnings(\"unused\")\n+            Object test = SerializationUtils.deserialize(inTest);\n+        } catch(SerializationException se) {\n+            assertEquals(\"java.lang.ClassNotFoundException: \" + CLASS_NOT_FOUND_MESSAGE, se.getMessage());\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+\n+    public void testSerializeBytes() throws Exception {\n+        byte[] testBytes = SerializationUtils.serialize(iMap);\n+\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(iMap);\n+        oos.flush();\n+        oos.close();\n+\n+        byte[] realBytes = streamReal.toByteArray();\n+        assertEquals(testBytes.length, realBytes.length);\n+        for (int i = 0; i < realBytes.length; i++) {\n+            assertEquals(realBytes[i], testBytes[i]);\n+        }\n+    }\n+\n+    public void testSerializeBytesUnserializable() throws Exception {\n+        try {\n+            iMap.put(new Object(), new Object());\n+            SerializationUtils.serialize(iMap);\n+        } catch (SerializationException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testSerializeBytesNull() throws Exception {\n+        byte[] testBytes = SerializationUtils.serialize(null);\n+\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(null);\n+        oos.flush();\n+        oos.close();\n+\n+        byte[] realBytes = streamReal.toByteArray();\n+        assertEquals(testBytes.length, realBytes.length);\n+        for (int i = 0; i < realBytes.length; i++) {\n+            assertEquals(realBytes[i], testBytes[i]);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testDeserializeBytes() throws Exception {\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(iMap);\n+        oos.flush();\n+        oos.close();\n+\n+        Object test = SerializationUtils.deserialize(streamReal.toByteArray());\n+        assertNotNull(test);\n+        assertTrue(test instanceof HashMap<?, ?>);\n+        assertTrue(test != iMap);\n+        HashMap<?, ?> testMap = (HashMap<?, ?>) test;\n+        assertEquals(iString, testMap.get(\"FOO\"));\n+        assertTrue(iString != testMap.get(\"FOO\"));\n+        assertEquals(iInteger, testMap.get(\"BAR\"));\n+        assertTrue(iInteger != testMap.get(\"BAR\"));\n+        assertEquals(iMap, testMap);\n+    }\n+\n+    public void testDeserializeBytesOfNull() throws Exception {\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(null);\n+        oos.flush();\n+        oos.close();\n+\n+        Object test = SerializationUtils.deserialize(streamReal.toByteArray());\n+        assertNull(test);\n+    }\n+\n+    public void testDeserializeBytesNull() throws Exception {\n+        try {\n+            SerializationUtils.deserialize((byte[]) null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testDeserializeBytesBadStream() throws Exception {\n+        try {\n+            SerializationUtils.deserialize(new byte[0]);\n+        } catch (SerializationException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testClone() throws Exception {\n+        Object test = SerializationUtils.clone(iMap);\n+        assertNotNull(test);\n+        assertTrue(test instanceof HashMap<?,?>);\n+        assertTrue(test != iMap);\n+        HashMap<?, ?> testMap = (HashMap<?, ?>) test;\n+        assertEquals(iString, testMap.get(\"FOO\"));\n+        assertTrue(iString != testMap.get(\"FOO\"));\n+        assertEquals(iInteger, testMap.get(\"BAR\"));\n+        assertTrue(iInteger != testMap.get(\"BAR\"));\n+        assertEquals(iMap, testMap);\n+    }\n+\n+    public void testCloneNull() throws Exception {\n+        Object test = SerializationUtils.clone(null);\n+        assertNull(test);\n+    }\n+\n+    public void testCloneUnserializable() throws Exception {\n+        try {\n+            iMap.put(new Object(), new Object());\n+            SerializationUtils.clone(iMap);\n+        } catch (SerializationException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+}\n+\n+class ClassNotFoundSerialization implements Serializable\n+{\n+\n+    private void readObject(ObjectInputStream in) throws ClassNotFoundException    {\n+        throw new ClassNotFoundException(SerializationUtilsTest.CLASS_NOT_FOUND_MESSAGE);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/StringEscapeUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests for {@link StringEscapeUtils}.\n+ *\n+ * @author <a href=\"mailto:alex@purpletech.com\">Alexander Day Chaffee</a>\n+ * @version $Id$\n+ */\n+public class StringEscapeUtilsTest extends TestCase {\n+    private final static String FOO = \"foo\";\n+\n+    public StringEscapeUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StringEscapeUtilsTest.class);\n+        suite.setName(\"StringEscapeUtilsTest Tests\");\n+        return suite;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new StringEscapeUtils());\n+        Constructor<?>[] cons = StringEscapeUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(StringEscapeUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(StringEscapeUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testEscapeJava() throws IOException {\n+        assertEquals(null, StringEscapeUtils.escapeJava(null));\n+        try {\n+            StringEscapeUtils.ESCAPE_JAVA.translate(null, null);\n+            fail();\n+        } catch (IOException ex) {\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+        try {\n+            StringEscapeUtils.ESCAPE_JAVA.translate(\"\", null);\n+            fail();\n+        } catch (IOException ex) {\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+        \n+        assertEscapeJava(\"empty string\", \"\", \"\");\n+        assertEscapeJava(FOO, FOO);\n+        assertEscapeJava(\"tab\", \"\\\\t\", \"\\t\");\n+        assertEscapeJava(\"backslash\", \"\\\\\\\\\", \"\\\\\");\n+        assertEscapeJava(\"single quote should not be escaped\", \"'\", \"'\");\n+        assertEscapeJava(\"\\\\\\\\\\\\b\\\\t\\\\r\", \"\\\\\\b\\t\\r\");\n+        assertEscapeJava(\"\\\\u1234\", \"\\u1234\");\n+        assertEscapeJava(\"\\\\u0234\", \"\\u0234\");\n+        assertEscapeJava(\"\\\\u00EF\", \"\\u00ef\");\n+        assertEscapeJava(\"\\\\u0001\", \"\\u0001\");\n+        assertEscapeJava(\"Should use capitalized unicode hex\", \"\\\\uABCD\", \"\\uabcd\");\n+\n+        assertEscapeJava(\"He didn't say, \\\\\\\"stop!\\\\\\\"\",\n+                \"He didn't say, \\\"stop!\\\"\");\n+        assertEscapeJava(\"non-breaking space\", \"This space is non-breaking:\" + \"\\\\u00A0\",\n+                \"This space is non-breaking:\\u00a0\");\n+        assertEscapeJava(\"\\\\uABCD\\\\u1234\\\\u012C\",\n+                \"\\uABCD\\u1234\\u012C\");\n+    }\n+\n+    /**\n+     * https://issues.apache.org/jira/browse/LANG-421\n+     */\n+    public void testEscapeJavaWithSlash() {\n+        final String input = \"String with a slash (/) in it\";\n+\n+        final String expected = input;\n+        final String actual = StringEscapeUtils.escapeJava(input);\n+\n+        /**\n+         * In 2.4 StringEscapeUtils.escapeJava(String) escapes '/' characters, which are not a valid character to escape\n+         * in a Java string.\n+         */\n+        assertEquals(expected, actual);\n+    }\n+    \n+    private void assertEscapeJava(String escaped, String original) throws IOException {\n+        assertEscapeJava(null, escaped, original);\n+    }\n+\n+    private void assertEscapeJava(String message, String expected, String original) throws IOException {\n+        String converted = StringEscapeUtils.escapeJava(original);\n+        message = \"escapeJava(String) failed\" + (message == null ? \"\" : (\": \" + message));\n+        assertEquals(message, expected, converted);\n+\n+        StringWriter writer = new StringWriter();\n+        StringEscapeUtils.ESCAPE_JAVA.translate(original, writer);\n+        assertEquals(expected, writer.toString());\n+    }\n+\n+    public void testUnescapeJava() throws IOException {\n+        assertEquals(null, StringEscapeUtils.unescapeJava(null));\n+        try {\n+            StringEscapeUtils.UNESCAPE_JAVA.translate(null, null);\n+            fail();\n+        } catch (IOException ex) {\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+        try {\n+            StringEscapeUtils.UNESCAPE_JAVA.translate(\"\", null);\n+            fail();\n+        } catch (IOException ex) {\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+        try {\n+            StringEscapeUtils.unescapeJava(\"\\\\u02-3\");\n+            fail();\n+        } catch (RuntimeException ex) {\n+        }\n+        \n+        assertUnescapeJava(\"\", \"\");\n+        assertUnescapeJava(\"test\", \"test\");\n+        assertUnescapeJava(\"\\ntest\\b\", \"\\\\ntest\\\\b\");\n+        assertUnescapeJava(\"\\u123425foo\\ntest\\b\", \"\\\\u123425foo\\\\ntest\\\\b\");\n+        assertUnescapeJava(\"'\\foo\\teste\\r\", \"\\\\'\\\\foo\\\\teste\\\\r\");\n+        assertUnescapeJava(\"\", \"\\\\\");\n+        //foo\n+        assertUnescapeJava(\"lowercase unicode\", \"\\uABCDx\", \"\\\\uabcdx\");\n+        assertUnescapeJava(\"uppercase unicode\", \"\\uABCDx\", \"\\\\uABCDx\");\n+        assertUnescapeJava(\"unicode as final character\", \"\\uABCD\", \"\\\\uabcd\");\n+    }\n+\n+    private void assertUnescapeJava(String unescaped, String original) throws IOException {\n+        assertUnescapeJava(null, unescaped, original);\n+    }\n+\n+    private void assertUnescapeJava(String message, String unescaped, String original) throws IOException {\n+        String expected = unescaped;\n+        String actual = StringEscapeUtils.unescapeJava(original);\n+\n+        assertEquals(\"unescape(String) failed\" +\n+                (message == null ? \"\" : (\": \" + message)) +\n+                \": expected '\" + StringEscapeUtils.escapeJava(expected) +\n+                // we escape this so we can see it in the error message\n+                \"' actual '\" + StringEscapeUtils.escapeJava(actual) + \"'\",\n+                expected, actual);\n+\n+        StringWriter writer = new StringWriter();\n+        StringEscapeUtils.UNESCAPE_JAVA.translate(original, writer);\n+        assertEquals(unescaped, writer.toString());\n+\n+    }\n+\n+    public void testEscapeEcmaScript() {\n+        assertEquals(null, StringEscapeUtils.escapeEcmaScript(null));\n+        try {\n+            StringEscapeUtils.ESCAPE_ECMASCRIPT.translate(null, null);\n+            fail();\n+        } catch (IOException ex) {\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+        try {\n+            StringEscapeUtils.ESCAPE_ECMASCRIPT.translate(\"\", null);\n+            fail();\n+        } catch (IOException ex) {\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+        \n+        assertEquals(\"He didn\\\\'t say, \\\\\\\"stop!\\\\\\\"\", StringEscapeUtils.escapeEcmaScript(\"He didn't say, \\\"stop!\\\"\"));\n+        assertEquals(\"document.getElementById(\\\\\\\"test\\\\\\\").value = \\\\'<script>alert(\\\\'aaa\\\\');<\\\\/script>\\\\';\", \n+                StringEscapeUtils.escapeEcmaScript(\"document.getElementById(\\\"test\\\").value = '<script>alert('aaa');</script>';\"));\n+    }\n+\n+\n+    // HTML and XML\n+    //--------------------------------------------------------------\n+\n+    String[][] htmlEscapes = {\n+        {\"no escaping\", \"plain text\", \"plain text\"},\n+        {\"no escaping\", \"plain text\", \"plain text\"},\n+        {\"empty string\", \"\", \"\"},\n+        {\"null\", null, null},\n+        {\"ampersand\", \"bread &amp; butter\", \"bread & butter\"},\n+        {\"quotes\", \"&quot;bread&quot; &amp; butter\", \"\\\"bread\\\" & butter\"},\n+        {\"final character only\", \"greater than &gt;\", \"greater than >\"},\n+        {\"first character only\", \"&lt; less than\", \"< less than\"},\n+        {\"apostrophe\", \"Huntington's chorea\", \"Huntington's chorea\"},\n+        {\"languages\", \"English,Fran&ccedil;ais,\\u65E5\\u672C\\u8A9E (nihongo)\", \"English,Fran\\u00E7ais,\\u65E5\\u672C\\u8A9E (nihongo)\"},\n+        {\"8-bit ascii shouldn't number-escape\", \"\\u0080\\u009F\", \"\\u0080\\u009F\"},\n+    };\n+\n+    public void testEscapeHtml() {\n+        for (int i = 0; i < htmlEscapes.length; ++i) {\n+            String message = htmlEscapes[i][0];\n+            String expected = htmlEscapes[i][1];\n+            String original = htmlEscapes[i][2];\n+            assertEquals(message, expected, StringEscapeUtils.escapeHtml4(original));\n+            StringWriter sw = new StringWriter();\n+            try {\n+                StringEscapeUtils.ESCAPE_HTML4.translate(original, sw);\n+            } catch (IOException e) {\n+            }\n+            String actual = original == null ? null : sw.toString();\n+            assertEquals(message, expected, actual);\n+        }\n+    }\n+\n+    public void testUnescapeHtml4() {\n+        for (int i = 0; i < htmlEscapes.length; ++i) {\n+            String message = htmlEscapes[i][0];\n+            String expected = htmlEscapes[i][2];\n+            String original = htmlEscapes[i][1];\n+            assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original));\n+            \n+            StringWriter sw = new StringWriter();\n+            try {\n+                StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw);\n+            } catch (IOException e) {\n+            }\n+            String actual = original == null ? null : sw.toString();\n+            assertEquals(message, expected, actual);\n+        }\n+        // \\u00E7 is a cedilla (c with wiggle under)\n+        // note that the test string must be 7-bit-clean (unicode escaped) or else it will compile incorrectly\n+        // on some locales        \n+        assertEquals(\"funny chars pass through OK\", \"Fran\\u00E7ais\", StringEscapeUtils.unescapeHtml4(\"Fran\\u00E7ais\"));\n+        \n+        assertEquals(\"Hello&;World\", StringEscapeUtils.unescapeHtml4(\"Hello&;World\"));\n+        assertEquals(\"Hello&#;World\", StringEscapeUtils.unescapeHtml4(\"Hello&#;World\"));\n+        assertEquals(\"Hello&# ;World\", StringEscapeUtils.unescapeHtml4(\"Hello&# ;World\"));\n+        assertEquals(\"Hello&##;World\", StringEscapeUtils.unescapeHtml4(\"Hello&##;World\"));\n+    }\n+\n+    public void testUnescapeHexCharsHtml() {\n+        // Simple easy to grok test \n+        assertEquals(\"hex number unescape\", \"\\u0080\\u009F\", StringEscapeUtils.unescapeHtml4(\"&#x80;&#x9F;\"));\n+        assertEquals(\"hex number unescape\", \"\\u0080\\u009F\", StringEscapeUtils.unescapeHtml4(\"&#X80;&#X9F;\"));\n+        // Test all Character values:\n+        for (char i = Character.MIN_VALUE; i < Character.MAX_VALUE; i++) {\n+            Character c1 = new Character(i);\n+            Character c2 = new Character((char)(i+1));\n+            String expected = c1.toString() + c2.toString();\n+            String escapedC1 = \"&#x\" + Integer.toHexString((c1.charValue())) + \";\";\n+            String escapedC2 = \"&#x\" + Integer.toHexString((c2.charValue())) + \";\";\n+            assertEquals(\"hex number unescape index \" + (int)i, expected, StringEscapeUtils.unescapeHtml4(escapedC1 + escapedC2));\n+        }\n+    }\n+\n+    public void testUnescapeUnknownEntity() throws Exception\n+    {\n+        assertEquals(\"&zzzz;\", StringEscapeUtils.unescapeHtml4(\"&zzzz;\"));\n+    }\n+\n+    public void testEscapeHtmlVersions() throws Exception\n+    {\n+        assertEquals(\"&Beta;\", StringEscapeUtils.escapeHtml4(\"\\u0392\"));\n+        assertEquals(\"\\u0392\", StringEscapeUtils.unescapeHtml4(\"&Beta;\"));\n+\n+        // TODO: refine API for escaping/unescaping specific HTML versions\n+\n+    }\n+\n+    public void testEscapeXml() throws Exception {\n+        assertEquals(\"&lt;abc&gt;\", StringEscapeUtils.escapeXml(\"<abc>\"));\n+        assertEquals(\"<abc>\", StringEscapeUtils.unescapeXml(\"&lt;abc&gt;\"));\n+\n+        assertEquals(\"XML should not escape >0x7f values\",\n+                \"\\u00A1\", StringEscapeUtils.escapeXml(\"\\u00A1\"));\n+        assertEquals(\"XML should be able to unescape >0x7f values\",\n+                \"\\u00A0\", StringEscapeUtils.unescapeXml(\"&#160;\"));\n+\n+        assertEquals(\"ain't\", StringEscapeUtils.unescapeXml(\"ain&apos;t\"));\n+        assertEquals(\"ain&apos;t\", StringEscapeUtils.escapeXml(\"ain't\"));\n+        assertEquals(\"\", StringEscapeUtils.escapeXml(\"\"));\n+        assertEquals(null, StringEscapeUtils.escapeXml(null));\n+        assertEquals(null, StringEscapeUtils.unescapeXml(null));\n+\n+        StringWriter sw = new StringWriter();\n+        try {\n+            StringEscapeUtils.ESCAPE_XML.translate(\"<abc>\", sw);\n+        } catch (IOException e) {\n+        }\n+        assertEquals(\"XML was escaped incorrectly\", \"&lt;abc&gt;\", sw.toString() );\n+\n+        sw = new StringWriter();\n+        try {\n+            StringEscapeUtils.UNESCAPE_XML.translate(\"&lt;abc&gt;\", sw);\n+        } catch (IOException e) {\n+        }\n+        assertEquals(\"XML was unescaped incorrectly\", \"<abc>\", sw.toString() );\n+    }\n+\n+    // Tests issue #38569\n+    // http://issues.apache.org/bugzilla/show_bug.cgi?id=38569\n+    public void testStandaloneAmphersand() {\n+        assertEquals(\"<P&O>\", StringEscapeUtils.unescapeHtml4(\"&lt;P&O&gt;\"));\n+        assertEquals(\"test & <\", StringEscapeUtils.unescapeHtml4(\"test & &lt;\"));\n+        assertEquals(\"<P&O>\", StringEscapeUtils.unescapeXml(\"&lt;P&O&gt;\"));\n+        assertEquals(\"test & <\", StringEscapeUtils.unescapeXml(\"test & &lt;\"));\n+    }\n+\n+    public void testLang313() {\n+        assertEquals(\"& &\", StringEscapeUtils.unescapeHtml4(\"& &amp;\"));\n+    }\n+\n+    public void testEscapeCsvString() throws Exception\n+    {\n+        assertEquals(\"foo.bar\",          StringEscapeUtils.escapeCsv(\"foo.bar\"));\n+        assertEquals(\"\\\"foo,bar\\\"\",      StringEscapeUtils.escapeCsv(\"foo,bar\"));\n+        assertEquals(\"\\\"foo\\nbar\\\"\",     StringEscapeUtils.escapeCsv(\"foo\\nbar\"));\n+        assertEquals(\"\\\"foo\\rbar\\\"\",     StringEscapeUtils.escapeCsv(\"foo\\rbar\"));\n+        assertEquals(\"\\\"foo\\\"\\\"bar\\\"\",   StringEscapeUtils.escapeCsv(\"foo\\\"bar\"));\n+        assertEquals(\"\",   StringEscapeUtils.escapeCsv(\"\"));\n+        assertEquals(null, StringEscapeUtils.escapeCsv(null));\n+    }\n+\n+    public void testEscapeCsvWriter() throws Exception\n+    {\n+        checkCsvEscapeWriter(\"foo.bar\",        \"foo.bar\");\n+        checkCsvEscapeWriter(\"\\\"foo,bar\\\"\",    \"foo,bar\");\n+        checkCsvEscapeWriter(\"\\\"foo\\nbar\\\"\",   \"foo\\nbar\");\n+        checkCsvEscapeWriter(\"\\\"foo\\rbar\\\"\",   \"foo\\rbar\");\n+        checkCsvEscapeWriter(\"\\\"foo\\\"\\\"bar\\\"\", \"foo\\\"bar\");\n+        checkCsvEscapeWriter(\"\", null);\n+        checkCsvEscapeWriter(\"\", \"\");\n+    }\n+\n+    private void checkCsvEscapeWriter(String expected, String value) {\n+        try {\n+            StringWriter writer = new StringWriter();\n+            StringEscapeUtils.ESCAPE_CSV.translate(value, writer);\n+            assertEquals(expected, writer.toString());\n+        } catch (IOException e) {\n+            fail(\"Threw: \" + e);\n+        }\n+    }\n+\n+    public void testUnescapeCsvString() throws Exception\n+    {\n+        assertEquals(\"foo.bar\",          StringEscapeUtils.unescapeCsv(\"foo.bar\"));\n+        assertEquals(\"foo,bar\",      StringEscapeUtils.unescapeCsv(\"\\\"foo,bar\\\"\"));\n+        assertEquals(\"foo\\nbar\",     StringEscapeUtils.unescapeCsv(\"\\\"foo\\nbar\\\"\"));\n+        assertEquals(\"foo\\rbar\",     StringEscapeUtils.unescapeCsv(\"\\\"foo\\rbar\\\"\"));\n+        assertEquals(\"foo\\\"bar\",   StringEscapeUtils.unescapeCsv(\"\\\"foo\\\"\\\"bar\\\"\"));\n+        assertEquals(\"\",   StringEscapeUtils.unescapeCsv(\"\"));\n+        assertEquals(null, StringEscapeUtils.unescapeCsv(null));\n+\n+        assertEquals(\"\\\"foo.bar\\\"\",          StringEscapeUtils.unescapeCsv(\"\\\"foo.bar\\\"\"));\n+    }\n+\n+    public void testUnescapeCsvWriter() throws Exception\n+    {\n+        checkCsvUnescapeWriter(\"foo.bar\",        \"foo.bar\");\n+        checkCsvUnescapeWriter(\"foo,bar\",    \"\\\"foo,bar\\\"\");\n+        checkCsvUnescapeWriter(\"foo\\nbar\",   \"\\\"foo\\nbar\\\"\");\n+        checkCsvUnescapeWriter(\"foo\\rbar\",   \"\\\"foo\\rbar\\\"\");\n+        checkCsvUnescapeWriter(\"foo\\\"bar\", \"\\\"foo\\\"\\\"bar\\\"\");\n+        checkCsvUnescapeWriter(\"\", null);\n+        checkCsvUnescapeWriter(\"\", \"\");\n+\n+        checkCsvUnescapeWriter(\"\\\"foo.bar\\\"\",        \"\\\"foo.bar\\\"\");\n+    }\n+\n+    private void checkCsvUnescapeWriter(String expected, String value) {\n+        try {\n+            StringWriter writer = new StringWriter();\n+            StringEscapeUtils.UNESCAPE_CSV.translate(value, writer);\n+            assertEquals(expected, writer.toString());\n+        } catch (IOException e) {\n+            fail(\"Threw: \" + e);\n+        }\n+    }\n+\n+    // https://issues.apache.org/jira/browse/LANG-480\n+    public void testEscapeHtmlHighUnicode() throws java.io.UnsupportedEncodingException {\n+        // this is the utf8 representation of the character:\n+        // COUNTING ROD UNIT DIGIT THREE\n+        // in unicode\n+        // codepoint: U+1D362\n+        byte[] data = new byte[] { (byte)0xF0, (byte)0x9D, (byte)0x8D, (byte)0xA2 };\n+\n+        String original = new String(data, \"UTF8\");\n+\n+        String escaped = StringEscapeUtils.escapeHtml4( original );\n+        assertEquals( \"High unicode should not have been escaped\", original, escaped);\n+\n+        String unescaped = StringEscapeUtils.unescapeHtml4( escaped );\n+        assertEquals( \"High unicode should have been unchanged\", original, unescaped);\n+\n+// TODO: I think this should hold, needs further investigation\n+//        String unescapedFromEntity = StringEscapeUtils.unescapeHtml4( \"&#119650;\" );\n+//        assertEquals( \"High unicode should have been unescaped\", original, unescapedFromEntity);\n+    }\n+\n+    // https://issues.apache.org/jira/browse/LANG-339\n+    public void testEscapeHiragana() {\n+        // Some random Japanese unicode characters\n+        String original = \"\\u304B\\u304C\\u3068\";\n+        String escaped = StringEscapeUtils.escapeHtml4(original);\n+        assertEquals( \"Hiragana character unicode behaviour should not be being escaped by escapeHtml4\",\n+        original, escaped);\n+\n+        String unescaped = StringEscapeUtils.unescapeHtml4( escaped );\n+\n+        assertEquals( \"Hiragana character unicode behaviour has changed - expected no unescaping\", escaped, unescaped);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.util.Locale;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.StringUtils} - Substring methods\n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @author Phil Steitz\n+ * @version $Id$\n+ */\n+public class StringUtilsEqualsIndexOfTest extends TestCase {\n+    private static final String FOO = \"foo\";\n+    private static final String BAR = \"bar\";\n+    private static final String FOOBAR = \"foobar\";\n+    private static final String[] FOOBAR_SUB_ARRAY = new String[] {\"ob\", \"ba\"};\n+\n+    public StringUtilsEqualsIndexOfTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StringUtilsEqualsIndexOfTest.class);\n+        suite.setName(\"StringUtilsEqualsIndexOf Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testEquals() {\n+        assertEquals(true, StringUtils.equals(null, null));\n+        assertEquals(true, StringUtils.equals(FOO, FOO));\n+        assertEquals(true, StringUtils.equals(FOO, new String(new char[] { 'f', 'o', 'o' })));\n+        assertEquals(false, StringUtils.equals(FOO, new String(new char[] { 'f', 'O', 'O' })));\n+        assertEquals(false, StringUtils.equals(FOO, BAR));\n+        assertEquals(false, StringUtils.equals(FOO, null));\n+        assertEquals(false, StringUtils.equals(null, FOO));\n+    }\n+\n+    public void testEqualsIgnoreCase() {\n+        assertEquals(true, StringUtils.equalsIgnoreCase(null, null));\n+        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, FOO));\n+        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'o', 'o' })));\n+        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'O', 'O' })));\n+        assertEquals(false, StringUtils.equalsIgnoreCase(FOO, BAR));\n+        assertEquals(false, StringUtils.equalsIgnoreCase(FOO, null));\n+        assertEquals(false, StringUtils.equalsIgnoreCase(null, FOO));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIndexOf_char() {\n+        assertEquals(-1, StringUtils.indexOf(null, ' '));\n+        assertEquals(-1, StringUtils.indexOf(\"\", ' '));\n+        assertEquals(0, StringUtils.indexOf(\"aabaabaa\", 'a'));\n+        assertEquals(2, StringUtils.indexOf(\"aabaabaa\", 'b'));\n+    }\n+\n+    public void testIndexOf_charInt() {\n+        assertEquals(-1, StringUtils.indexOf(null, ' ', 0));\n+        assertEquals(-1, StringUtils.indexOf(null, ' ', -1));\n+        assertEquals(-1, StringUtils.indexOf(\"\", ' ', 0));\n+        assertEquals(-1, StringUtils.indexOf(\"\", ' ', -1));\n+        assertEquals(0, StringUtils.indexOf(\"aabaabaa\", 'a', 0));\n+        assertEquals(2, StringUtils.indexOf(\"aabaabaa\", 'b', 0));\n+        assertEquals(5, StringUtils.indexOf(\"aabaabaa\", 'b', 3));\n+        assertEquals(-1, StringUtils.indexOf(\"aabaabaa\", 'b', 9));\n+        assertEquals(2, StringUtils.indexOf(\"aabaabaa\", 'b', -1));\n+    }\n+\n+    public void testIndexOf_String() {\n+        assertEquals(-1, StringUtils.indexOf(null, null));\n+        assertEquals(-1, StringUtils.indexOf(\"\", null));\n+        assertEquals(0, StringUtils.indexOf(\"\", \"\"));\n+        assertEquals(0, StringUtils.indexOf(\"aabaabaa\", \"a\"));\n+        assertEquals(2, StringUtils.indexOf(\"aabaabaa\", \"b\"));\n+        assertEquals(1, StringUtils.indexOf(\"aabaabaa\", \"ab\"));\n+        assertEquals(0, StringUtils.indexOf(\"aabaabaa\", \"\"));\n+    }\n+\n+    public void testOrdinalIndexOf() {\n+        assertEquals(-1, StringUtils.ordinalIndexOf(null, null, Integer.MIN_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", null, Integer.MIN_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", \"\", Integer.MIN_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", Integer.MIN_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", Integer.MIN_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", Integer.MIN_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", Integer.MIN_VALUE));\n+        \n+        assertEquals(-1, StringUtils.ordinalIndexOf(null, null, -1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", null, -1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", \"\", -1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", -1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", -1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", -1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", -1));\n+\n+        assertEquals(-1, StringUtils.ordinalIndexOf(null, null, 0));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", null, 0));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", \"\", 0));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 0));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 0));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 0));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 0));\n+\n+        assertEquals(-1, StringUtils.ordinalIndexOf(null, null, 1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", null, 1));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"\", \"\", 1));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 1));\n+        assertEquals(2, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 1));\n+        assertEquals(1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 1));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 1));\n+\n+        assertEquals(-1, StringUtils.ordinalIndexOf(null, null, 2));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", null, 2));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"\", \"\", 2));\n+        assertEquals(1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 2));\n+        assertEquals(5, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 2));\n+        assertEquals(4, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 2));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 2));\n+        \n+        assertEquals(-1, StringUtils.ordinalIndexOf(null, null, Integer.MAX_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", null, Integer.MAX_VALUE));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"\", \"\", Integer.MAX_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", Integer.MAX_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", Integer.MAX_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", Integer.MAX_VALUE));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", Integer.MAX_VALUE));\n+        \n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 0));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 1));\n+        assertEquals(1, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 2));\n+        assertEquals(2, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 3));\n+        assertEquals(3, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 4));\n+        assertEquals(4, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 5));\n+        assertEquals(5, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 6));\n+        assertEquals(6, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 7));\n+        assertEquals(7, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 8));\n+        assertEquals(8, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 9));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 10));\n+    }\n+\n+    public void testIndexOf_StringInt() {\n+        assertEquals(-1, StringUtils.indexOf(null, null, 0));\n+        assertEquals(-1, StringUtils.indexOf(null, null, -1));\n+        assertEquals(-1, StringUtils.indexOf(null, \"\", 0));\n+        assertEquals(-1, StringUtils.indexOf(null, \"\", -1));\n+        assertEquals(-1, StringUtils.indexOf(\"\", null, 0));\n+        assertEquals(-1, StringUtils.indexOf(\"\", null, -1));\n+        assertEquals(0, StringUtils.indexOf(\"\", \"\", 0));\n+        assertEquals(0, StringUtils.indexOf(\"\", \"\", -1));\n+        assertEquals(0, StringUtils.indexOf(\"\", \"\", 9));\n+        assertEquals(0, StringUtils.indexOf(\"abc\", \"\", 0));\n+        assertEquals(0, StringUtils.indexOf(\"abc\", \"\", -1));\n+        assertEquals(3, StringUtils.indexOf(\"abc\", \"\", 9));\n+        assertEquals(3, StringUtils.indexOf(\"abc\", \"\", 3));\n+        assertEquals(0, StringUtils.indexOf(\"aabaabaa\", \"a\", 0));\n+        assertEquals(2, StringUtils.indexOf(\"aabaabaa\", \"b\", 0));\n+        assertEquals(1, StringUtils.indexOf(\"aabaabaa\", \"ab\", 0));\n+        assertEquals(5, StringUtils.indexOf(\"aabaabaa\", \"b\", 3));\n+        assertEquals(-1, StringUtils.indexOf(\"aabaabaa\", \"b\", 9));\n+        assertEquals(2, StringUtils.indexOf(\"aabaabaa\", \"b\", -1));\n+        assertEquals(2,StringUtils.indexOf(\"aabaabaa\", \"\", 2)); \n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testLastIndexOf_char() {\n+        assertEquals(-1, StringUtils.lastIndexOf(null, ' '));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"\", ' '));\n+        assertEquals(7, StringUtils.lastIndexOf(\"aabaabaa\", 'a'));\n+        assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", 'b'));\n+    }\n+\n+    public void testLastIndexOf_charInt() {\n+        assertEquals(-1, StringUtils.lastIndexOf(null, ' ', 0));\n+        assertEquals(-1, StringUtils.lastIndexOf(null, ' ', -1));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"\", ' ', 0));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"\", ' ', -1));\n+        assertEquals(7, StringUtils.lastIndexOf(\"aabaabaa\", 'a', 8));\n+        assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", 'b', 8));\n+        assertEquals(2, StringUtils.lastIndexOf(\"aabaabaa\", 'b', 3));\n+        assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", 'b', 9));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"aabaabaa\", 'b', -1));\n+        assertEquals(0, StringUtils.lastIndexOf(\"aabaabaa\", 'a', 0));\n+    }\n+\n+    public void testLastIndexOf_String() {\n+        assertEquals(-1, StringUtils.lastIndexOf(null, null));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"\", null));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"\", \"a\"));\n+        assertEquals(0, StringUtils.lastIndexOf(\"\", \"\"));\n+        assertEquals(8, StringUtils.lastIndexOf(\"aabaabaa\", \"\"));\n+        assertEquals(7, StringUtils.lastIndexOf(\"aabaabaa\", \"a\"));\n+        assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", \"b\"));\n+        assertEquals(4, StringUtils.lastIndexOf(\"aabaabaa\", \"ab\"));\n+    }\n+\n+    public void testLastIndexOf_StringInt() {\n+        assertEquals(-1, StringUtils.lastIndexOf(null, null, 0));\n+        assertEquals(-1, StringUtils.lastIndexOf(null, null, -1));\n+        assertEquals(-1, StringUtils.lastIndexOf(null, \"\", 0));\n+        assertEquals(-1, StringUtils.lastIndexOf(null, \"\", -1));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"\", null, 0));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"\", null, -1));\n+        assertEquals(0, StringUtils.lastIndexOf(\"\", \"\", 0));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"\", \"\", -1));\n+        assertEquals(0, StringUtils.lastIndexOf(\"\", \"\", 9));\n+        assertEquals(0, StringUtils.lastIndexOf(\"abc\", \"\", 0));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"abc\", \"\", -1));\n+        assertEquals(3, StringUtils.lastIndexOf(\"abc\", \"\", 9));\n+        assertEquals(7, StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 8));\n+        assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 8));\n+        assertEquals(4, StringUtils.lastIndexOf(\"aabaabaa\", \"ab\", 8));\n+        assertEquals(2, StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 3));\n+        assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 9));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"aabaabaa\", \"b\", -1));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 0));\n+        assertEquals(0, StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 0));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testContainsChar() {\n+        assertEquals(false, StringUtils.contains(null, ' '));\n+        assertEquals(false, StringUtils.contains(\"\", ' '));\n+        assertEquals(false, StringUtils.contains(\"\",null));\n+        assertEquals(false, StringUtils.contains(null,null));\n+        assertEquals(true, StringUtils.contains(\"abc\", 'a'));\n+        assertEquals(true, StringUtils.contains(\"abc\", 'b'));\n+        assertEquals(true, StringUtils.contains(\"abc\", 'c'));\n+        assertEquals(false, StringUtils.contains(\"abc\", 'z'));\n+    }\n+\n+    public void testContainsString() {\n+        assertEquals(false, StringUtils.contains(null, null));\n+        assertEquals(false, StringUtils.contains(null, \"\"));\n+        assertEquals(false, StringUtils.contains(null, \"a\"));\n+        assertEquals(false, StringUtils.contains(\"\", null));\n+        assertEquals(true, StringUtils.contains(\"\", \"\"));\n+        assertEquals(false, StringUtils.contains(\"\", \"a\"));\n+        assertEquals(true, StringUtils.contains(\"abc\", \"a\"));\n+        assertEquals(true, StringUtils.contains(\"abc\", \"b\"));\n+        assertEquals(true, StringUtils.contains(\"abc\", \"c\"));\n+        assertEquals(true, StringUtils.contains(\"abc\", \"abc\"));\n+        assertEquals(false, StringUtils.contains(\"abc\", \"z\"));\n+    }\n+\n+    public void testContainsIgnoreCase_StringString() {\n+        assertFalse(StringUtils.containsIgnoreCase(null, null));\n+        \n+        // Null tests\n+        assertFalse(StringUtils.containsIgnoreCase(null, \"\"));\n+        assertFalse(StringUtils.containsIgnoreCase(null, \"a\"));\n+        assertFalse(StringUtils.containsIgnoreCase(null, \"abc\"));\n+        \n+        assertFalse(StringUtils.containsIgnoreCase(\"\", null));\n+        assertFalse(StringUtils.containsIgnoreCase(\"a\", null));\n+        assertFalse(StringUtils.containsIgnoreCase(\"abc\", null));\n+        \n+        // Match len = 0\n+        assertTrue(StringUtils.containsIgnoreCase(\"\", \"\"));\n+        assertTrue(StringUtils.containsIgnoreCase(\"a\", \"\"));\n+        assertTrue(StringUtils.containsIgnoreCase(\"abc\", \"\"));\n+\n+        // Match len = 1\n+        assertFalse(StringUtils.containsIgnoreCase(\"\", \"a\"));\n+        assertTrue(StringUtils.containsIgnoreCase(\"a\", \"a\"));\n+        assertTrue(StringUtils.containsIgnoreCase(\"abc\", \"a\"));\n+        assertFalse(StringUtils.containsIgnoreCase(\"\", \"A\"));\n+        assertTrue(StringUtils.containsIgnoreCase(\"a\", \"A\"));\n+        assertTrue(StringUtils.containsIgnoreCase(\"abc\", \"A\"));\n+        \n+        // Match len > 1\n+        assertFalse(StringUtils.containsIgnoreCase(\"\", \"abc\"));\n+        assertFalse(StringUtils.containsIgnoreCase(\"a\", \"abc\"));\n+        assertTrue(StringUtils.containsIgnoreCase(\"xabcz\", \"abc\"));\n+        assertFalse(StringUtils.containsIgnoreCase(\"\", \"ABC\"));\n+        assertFalse(StringUtils.containsIgnoreCase(\"a\", \"ABC\"));\n+        assertTrue(StringUtils.containsIgnoreCase(\"xabcz\", \"ABC\"));\n+    }\n+\n+    public void testContainsIgnoreCase_LocaleIndependence() {\n+        Locale orig = Locale.getDefault();\n+\n+        Locale[] locales = { Locale.ENGLISH, new Locale(\"tr\"), Locale.getDefault() };\n+\n+        String[][] tdata = { \n+            { \"i\", \"I\" },\n+            { \"I\", \"i\" },\n+            { \"\\u03C2\", \"\\u03C3\" },\n+            { \"\\u03A3\", \"\\u03C2\" },\n+            { \"\\u03A3\", \"\\u03C3\" },\n+        };\n+\n+        String[][] fdata = { \n+            { \"\\u00DF\", \"SS\" },\n+        };\n+\n+        try {\n+            for (int i = 0; i < locales.length; i++) {\n+                Locale.setDefault(locales[i]);\n+                for (int j = 0; j < tdata.length; j++) {\n+                    assertTrue(Locale.getDefault() + \": \" + j + \" \" + tdata[j][0] + \" \" + tdata[j][1], StringUtils\n+                            .containsIgnoreCase(tdata[j][0], tdata[j][1]));\n+                }\n+                for (int j = 0; j < fdata.length; j++) {\n+                    assertFalse(Locale.getDefault() + \": \" + j + \" \" + fdata[j][0] + \" \" + fdata[j][1], StringUtils\n+                            .containsIgnoreCase(fdata[j][0], fdata[j][1]));\n+                }\n+            }\n+        } finally {\n+            Locale.setDefault(orig);\n+        }\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testIndexOfAny_StringStringarray() {\n+        assertEquals(-1, StringUtils.indexOfAny(null, (String[]) null));\n+        assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY));\n+        assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (String[]) null));\n+        assertEquals(2, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY));\n+        assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0]));\n+        assertEquals(-1, StringUtils.indexOfAny(null, new String[0]));\n+        assertEquals(-1, StringUtils.indexOfAny(\"\", new String[0]));\n+        assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] {\"llll\"}));\n+        assertEquals(0, StringUtils.indexOfAny(FOOBAR, new String[] {\"\"}));\n+        assertEquals(0, StringUtils.indexOfAny(\"\", new String[] {\"\"}));\n+        assertEquals(-1, StringUtils.indexOfAny(\"\", new String[] {\"a\"}));\n+        assertEquals(-1, StringUtils.indexOfAny(\"\", new String[] {null}));\n+        assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] {null}));\n+        assertEquals(-1, StringUtils.indexOfAny(null, new String[] {null}));\n+    }\n+\n+    public void testLastIndexOfAny_StringStringarray() {\n+        assertEquals(-1, StringUtils.lastIndexOfAny(null, null));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(null, FOOBAR_SUB_ARRAY));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, null));\n+        assertEquals(3, StringUtils.lastIndexOfAny(FOOBAR, FOOBAR_SUB_ARRAY));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, new String[0]));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(null, new String[0]));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(\"\", new String[0]));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, new String[] {\"llll\"}));\n+        assertEquals(6, StringUtils.lastIndexOfAny(FOOBAR, new String[] {\"\"}));\n+        assertEquals(0, StringUtils.lastIndexOfAny(\"\", new String[] {\"\"}));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(\"\", new String[] {\"a\"}));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(\"\", new String[] {null}));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, new String[] {null}));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(null, new String[] {null}));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIndexOfAny_StringChararray() {\n+        assertEquals(-1, StringUtils.indexOfAny(null, (char[]) null));\n+        assertEquals(-1, StringUtils.indexOfAny(null, new char[0]));\n+        assertEquals(-1, StringUtils.indexOfAny(null, new char[] {'a','b'}));\n+        \n+        assertEquals(-1, StringUtils.indexOfAny(\"\", (char[]) null));\n+        assertEquals(-1, StringUtils.indexOfAny(\"\", new char[0]));\n+        assertEquals(-1, StringUtils.indexOfAny(\"\", new char[] {'a','b'}));\n+        \n+        assertEquals(-1, StringUtils.indexOfAny(\"zzabyycdxx\", (char[]) null)); \n+        assertEquals(-1, StringUtils.indexOfAny(\"zzabyycdxx\", new char[0])); \n+        assertEquals(0, StringUtils.indexOfAny(\"zzabyycdxx\", new char[] {'z','a'})); \n+        assertEquals(3, StringUtils.indexOfAny(\"zzabyycdxx\", new char[] {'b','y'}));\n+        assertEquals(-1, StringUtils.indexOfAny(\"ab\", new char[] {'z'}));\n+    }\n+\n+    public void testIndexOfAny_StringString() {\n+        assertEquals(-1, StringUtils.indexOfAny(null, (String) null));\n+        assertEquals(-1, StringUtils.indexOfAny(null, \"\"));\n+        assertEquals(-1, StringUtils.indexOfAny(null, \"ab\"));\n+        \n+        assertEquals(-1, StringUtils.indexOfAny(\"\", (String) null));\n+        assertEquals(-1, StringUtils.indexOfAny(\"\", \"\"));\n+        assertEquals(-1, StringUtils.indexOfAny(\"\", \"ab\"));\n+        \n+        assertEquals(-1, StringUtils.indexOfAny(\"zzabyycdxx\", (String) null)); \n+        assertEquals(-1, StringUtils.indexOfAny(\"zzabyycdxx\", \"\")); \n+        assertEquals(0, StringUtils.indexOfAny(\"zzabyycdxx\", \"za\")); \n+        assertEquals(3, StringUtils.indexOfAny(\"zzabyycdxx\", \"by\"));\n+        assertEquals(-1, StringUtils.indexOfAny(\"ab\", \"z\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testContainsAny_StringChararray() {\n+        assertFalse(StringUtils.containsAny(null, (char[]) null));\n+        assertFalse(StringUtils.containsAny(null, new char[0]));\n+        assertFalse(StringUtils.containsAny(null, new char[] {'a','b'}));\n+        \n+        assertFalse(StringUtils.containsAny(\"\", (char[]) null));\n+        assertFalse(StringUtils.containsAny(\"\", new char[0]));\n+        assertFalse(StringUtils.containsAny(\"\", new char[] {'a','b'}));\n+        \n+        assertFalse(StringUtils.containsAny(\"zzabyycdxx\", (char[]) null)); \n+        assertFalse(StringUtils.containsAny(\"zzabyycdxx\", new char[0])); \n+        assertTrue(StringUtils.containsAny(\"zzabyycdxx\", new char[] {'z','a'})); \n+        assertTrue(StringUtils.containsAny(\"zzabyycdxx\", new char[] {'b','y'}));\n+        assertFalse(StringUtils.containsAny(\"ab\", new char[] {'z'}));\n+    }\n+\n+    public void testContainsAny_StringString() {\n+        assertFalse(StringUtils.containsAny(null, (String) null));\n+        assertFalse(StringUtils.containsAny(null, \"\"));\n+        assertFalse(StringUtils.containsAny(null, \"ab\"));\n+        \n+        assertFalse(StringUtils.containsAny(\"\", (String) null));\n+        assertFalse(StringUtils.containsAny(\"\", \"\"));\n+        assertFalse(StringUtils.containsAny(\"\", \"ab\"));\n+        \n+        assertFalse(StringUtils.containsAny(\"zzabyycdxx\", (String) null)); \n+        assertFalse(StringUtils.containsAny(\"zzabyycdxx\", \"\")); \n+        assertTrue(StringUtils.containsAny(\"zzabyycdxx\", \"za\")); \n+        assertTrue(StringUtils.containsAny(\"zzabyycdxx\", \"by\"));\n+        assertFalse(StringUtils.containsAny(\"ab\", \"z\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIndexOfAnyBut_StringChararray() {\n+        assertEquals(-1, StringUtils.indexOfAnyBut(null, (char[]) null));\n+        assertEquals(-1, StringUtils.indexOfAnyBut(null, new char[0]));\n+        assertEquals(-1, StringUtils.indexOfAnyBut(null, new char[] {'a','b'}));\n+        \n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"\", (char[]) null));\n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"\", new char[0]));\n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"\", new char[] {'a','b'}));\n+        \n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"zzabyycdxx\", (char[]) null));\n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"zzabyycdxx\", new char[0]));\n+        assertEquals(3, StringUtils.indexOfAnyBut(\"zzabyycdxx\", new char[] {'z','a'})); \n+        assertEquals(0, StringUtils.indexOfAnyBut(\"zzabyycdxx\", new char[] {'b','y'})); \n+        assertEquals(0, StringUtils.indexOfAnyBut(\"ab\", new char[] {'z'}));\n+    }\n+\n+    public void testIndexOfAnyBut_StringString() {\n+        assertEquals(-1, StringUtils.indexOfAnyBut(null, (String) null));\n+        assertEquals(-1, StringUtils.indexOfAnyBut(null, \"\"));\n+        assertEquals(-1, StringUtils.indexOfAnyBut(null, \"ab\"));\n+        \n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"\", (String) null));\n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"\", \"\"));\n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"\", \"ab\"));\n+        \n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"zzabyycdxx\", (String) null)); \n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"\")); \n+        assertEquals(3, StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"za\")); \n+        assertEquals(0, StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"by\"));\n+        assertEquals(0, StringUtils.indexOfAnyBut(\"ab\", \"z\"));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testContainsOnly_String() {\n+        String str1 = \"a\";\n+        String str2 = \"b\";\n+        String str3 = \"ab\";\n+        String chars1= \"b\";\n+        String chars2= \"a\";\n+        String chars3= \"ab\";\n+        assertEquals(false, StringUtils.containsOnly(null, (String) null));\n+        assertEquals(false, StringUtils.containsOnly(\"\", (String) null));\n+        assertEquals(false, StringUtils.containsOnly(null, \"\"));\n+        assertEquals(false, StringUtils.containsOnly(str1, \"\"));\n+        assertEquals(true, StringUtils.containsOnly(\"\", \"\"));\n+        assertEquals(true, StringUtils.containsOnly(\"\", chars1));\n+        assertEquals(false, StringUtils.containsOnly(str1, chars1));\n+        assertEquals(true, StringUtils.containsOnly(str1, chars2));\n+        assertEquals(true, StringUtils.containsOnly(str1, chars3));\n+        assertEquals(true, StringUtils.containsOnly(str2, chars1));\n+        assertEquals(false, StringUtils.containsOnly(str2, chars2));\n+        assertEquals(true, StringUtils.containsOnly(str2, chars3));\n+        assertEquals(false, StringUtils.containsOnly(str3, chars1));\n+        assertEquals(false, StringUtils.containsOnly(str3, chars2));\n+        assertEquals(true, StringUtils.containsOnly(str3, chars3));\n+    }\n+\n+    public void testContainsOnly_Chararray() {\n+        String str1 = \"a\";\n+        String str2 = \"b\";\n+        String str3 = \"ab\";\n+        char[] chars1= {'b'};\n+        char[] chars2= {'a'};\n+        char[] chars3= {'a', 'b'};\n+        char[] emptyChars = new char[0];\n+        assertEquals(false, StringUtils.containsOnly(null, (char[]) null));\n+        assertEquals(false, StringUtils.containsOnly(\"\", (char[]) null));\n+        assertEquals(false, StringUtils.containsOnly(null, emptyChars));\n+        assertEquals(false, StringUtils.containsOnly(str1, emptyChars));\n+        assertEquals(true, StringUtils.containsOnly(\"\", emptyChars));\n+        assertEquals(true, StringUtils.containsOnly(\"\", chars1));\n+        assertEquals(false, StringUtils.containsOnly(str1, chars1));\n+        assertEquals(true, StringUtils.containsOnly(str1, chars2));\n+        assertEquals(true, StringUtils.containsOnly(str1, chars3));\n+        assertEquals(true, StringUtils.containsOnly(str2, chars1));\n+        assertEquals(false, StringUtils.containsOnly(str2, chars2));\n+        assertEquals(true, StringUtils.containsOnly(str2, chars3));\n+        assertEquals(false, StringUtils.containsOnly(str3, chars1));\n+        assertEquals(false, StringUtils.containsOnly(str3, chars2));\n+        assertEquals(true, StringUtils.containsOnly(str3, chars3));\n+    }\n+\n+    public void testContainsNone_String() {\n+        String str1 = \"a\";\n+        String str2 = \"b\";\n+        String str3 = \"ab.\";\n+        String chars1= \"b\";\n+        String chars2= \".\";\n+        String chars3= \"cd\";\n+        assertEquals(true, StringUtils.containsNone(null, (String) null));\n+        assertEquals(true, StringUtils.containsNone(\"\", (String) null));\n+        assertEquals(true, StringUtils.containsNone(null, \"\"));\n+        assertEquals(true, StringUtils.containsNone(str1, \"\"));\n+        assertEquals(true, StringUtils.containsNone(\"\", \"\"));\n+        assertEquals(true, StringUtils.containsNone(\"\", chars1));\n+        assertEquals(true, StringUtils.containsNone(str1, chars1));\n+        assertEquals(true, StringUtils.containsNone(str1, chars2));\n+        assertEquals(true, StringUtils.containsNone(str1, chars3));\n+        assertEquals(false, StringUtils.containsNone(str2, chars1));\n+        assertEquals(true, StringUtils.containsNone(str2, chars2));\n+        assertEquals(true, StringUtils.containsNone(str2, chars3));\n+        assertEquals(false, StringUtils.containsNone(str3, chars1));\n+        assertEquals(false, StringUtils.containsNone(str3, chars2));\n+        assertEquals(true, StringUtils.containsNone(str3, chars3));\n+    }\n+\n+    public void testContainsNone_Chararray() {\n+        String str1 = \"a\";\n+        String str2 = \"b\";\n+        String str3 = \"ab.\";\n+        char[] chars1= {'b'};\n+        char[] chars2= {'.'};\n+        char[] chars3= {'c', 'd'};\n+        char[] emptyChars = new char[0];\n+        assertEquals(true, StringUtils.containsNone(null, (char[]) null));\n+        assertEquals(true, StringUtils.containsNone(\"\", (char[]) null));\n+        assertEquals(true, StringUtils.containsNone(null, emptyChars));\n+        assertEquals(true, StringUtils.containsNone(str1, emptyChars));\n+        assertEquals(true, StringUtils.containsNone(\"\", emptyChars));\n+        assertEquals(true, StringUtils.containsNone(\"\", chars1));\n+        assertEquals(true, StringUtils.containsNone(str1, chars1));\n+        assertEquals(true, StringUtils.containsNone(str1, chars2));\n+        assertEquals(true, StringUtils.containsNone(str1, chars3));\n+        assertEquals(false, StringUtils.containsNone(str2, chars1));\n+        assertEquals(true, StringUtils.containsNone(str2, chars2));\n+        assertEquals(true, StringUtils.containsNone(str2, chars3));\n+        assertEquals(false, StringUtils.containsNone(str3, chars1));\n+        assertEquals(false, StringUtils.containsNone(str3, chars2));\n+        assertEquals(true, StringUtils.containsNone(str3, chars3));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/StringUtilsIsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.StringUtils} - Substring methods\n+ *\n+ * @author Apache Software Foundation\n+ * @author Michael Davey\n+ * @version $Id$\n+ */\n+public class StringUtilsIsTest extends TestCase {\n+\n+    public StringUtilsIsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StringUtilsIsTest.class);\n+        suite.setName(\"StringUtilsIsXxx Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testIsAlpha() {\n+        assertEquals(false, StringUtils.isAlpha(null));\n+        assertEquals(true, StringUtils.isAlpha(\"\"));\n+        assertEquals(false, StringUtils.isAlpha(\" \"));\n+        assertEquals(true, StringUtils.isAlpha(\"a\"));\n+        assertEquals(true, StringUtils.isAlpha(\"A\"));\n+        assertEquals(true, StringUtils.isAlpha(\"kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl\"));\n+        assertEquals(false, StringUtils.isAlpha(\"ham kso\"));\n+        assertEquals(false, StringUtils.isAlpha(\"1\"));\n+        assertEquals(false, StringUtils.isAlpha(\"hkHKHik6iUGHKJgU7tUJgKJGI87GIkug\"));\n+        assertEquals(false, StringUtils.isAlpha(\"_\"));\n+        assertEquals(false, StringUtils.isAlpha(\"hkHKHik*khbkuh\"));\n+    }\n+\n+    public void testIsAlphanumeric() {\n+        assertEquals(false, StringUtils.isAlphanumeric(null));\n+        assertEquals(true, StringUtils.isAlphanumeric(\"\"));\n+        assertEquals(false, StringUtils.isAlphanumeric(\" \"));\n+        assertEquals(true, StringUtils.isAlphanumeric(\"a\"));\n+        assertEquals(true, StringUtils.isAlphanumeric(\"A\"));\n+        assertEquals(true, StringUtils.isAlphanumeric(\"kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl\"));\n+        assertEquals(false, StringUtils.isAlphanumeric(\"ham kso\"));\n+        assertEquals(true, StringUtils.isAlphanumeric(\"1\"));\n+        assertEquals(true, StringUtils.isAlphanumeric(\"hkHKHik6iUGHKJgU7tUJgKJGI87GIkug\"));\n+        assertEquals(false, StringUtils.isAlphanumeric(\"_\"));\n+        assertEquals(false, StringUtils.isAlphanumeric(\"hkHKHik*khbkuh\"));\n+    }\n+\n+    public void testIsWhitespace() {\n+        assertEquals(false, StringUtils.isWhitespace(null));\n+        assertEquals(true, StringUtils.isWhitespace(\"\"));\n+        assertEquals(true, StringUtils.isWhitespace(\" \"));\n+        assertEquals(true, StringUtils.isWhitespace(\"\\t \\n \\t\"));\n+        assertEquals(false, StringUtils.isWhitespace(\"\\t aa\\n \\t\"));\n+        assertEquals(true, StringUtils.isWhitespace(\" \"));\n+        assertEquals(false, StringUtils.isWhitespace(\" a \"));\n+        assertEquals(false, StringUtils.isWhitespace(\"a  \"));\n+        assertEquals(false, StringUtils.isWhitespace(\"  a\"));\n+        assertEquals(false, StringUtils.isWhitespace(\"aba\"));\n+        assertEquals(true, StringUtils.isWhitespace(StringUtilsTest.WHITESPACE));\n+        assertEquals(false, StringUtils.isWhitespace(StringUtilsTest.NON_WHITESPACE));\n+    }\n+\n+    public void testIsAlphaspace() {\n+        assertEquals(false, StringUtils.isAlphaSpace(null));\n+        assertEquals(true, StringUtils.isAlphaSpace(\"\"));\n+        assertEquals(true, StringUtils.isAlphaSpace(\" \"));\n+        assertEquals(true, StringUtils.isAlphaSpace(\"a\"));\n+        assertEquals(true, StringUtils.isAlphaSpace(\"A\"));\n+        assertEquals(true, StringUtils.isAlphaSpace(\"kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl\"));\n+        assertEquals(true, StringUtils.isAlphaSpace(\"ham kso\"));\n+        assertEquals(false, StringUtils.isAlphaSpace(\"1\"));\n+        assertEquals(false, StringUtils.isAlphaSpace(\"hkHKHik6iUGHKJgU7tUJgKJGI87GIkug\"));\n+        assertEquals(false, StringUtils.isAlphaSpace(\"_\"));\n+        assertEquals(false, StringUtils.isAlphaSpace(\"hkHKHik*khbkuh\"));\n+    }\n+\n+    public void testIsAlphanumericSpace() {\n+        assertEquals(false, StringUtils.isAlphanumericSpace(null));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"\"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\" \"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"a\"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"A\"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl\"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"ham kso\"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"1\"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"hkHKHik6iUGHKJgU7tUJgKJGI87GIkug\"));\n+        assertEquals(false, StringUtils.isAlphanumericSpace(\"_\"));\n+        assertEquals(false, StringUtils.isAlphanumericSpace(\"hkHKHik*khbkuh\"));\n+    }\n+\n+    public void testIsAsciiPrintable_String() {\n+        assertEquals(false, StringUtils.isAsciiPrintable(null));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\" \"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"a\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"A\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"1\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"Ceki\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"!ab2c~\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"1000\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"10 00\"));\n+        assertEquals(false, StringUtils.isAsciiPrintable(\"10\\t00\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"10.00\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"10,00\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"!ab-c~\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"hkHK=Hik6i?UGH_KJgU7.tUJgKJ*GI87GI,kug\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"\\u0020\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"\\u0021\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"\\u007e\"));\n+        assertEquals(false, StringUtils.isAsciiPrintable(\"\\u007f\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"G?lc?\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"=?iso-8859-1?Q?G=FClc=FC?=\"));\n+        assertEquals(false, StringUtils.isAsciiPrintable(\"G\\u00fclc\\u00fc\"));\n+    }\n+  \n+    public void testIsNumeric() {\n+        assertEquals(false, StringUtils.isNumeric(null));\n+        assertEquals(true, StringUtils.isNumeric(\"\"));\n+        assertEquals(false, StringUtils.isNumeric(\" \"));\n+        assertEquals(false, StringUtils.isNumeric(\"a\"));\n+        assertEquals(false, StringUtils.isNumeric(\"A\"));\n+        assertEquals(false, StringUtils.isNumeric(\"kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl\"));\n+        assertEquals(false, StringUtils.isNumeric(\"ham kso\"));\n+        assertEquals(true, StringUtils.isNumeric(\"1\"));\n+        assertEquals(true, StringUtils.isNumeric(\"1000\"));\n+        assertEquals(false, StringUtils.isNumeric(\"2.3\"));\n+        assertEquals(false, StringUtils.isNumeric(\"10 00\"));\n+        assertEquals(false, StringUtils.isNumeric(\"hkHKHik6iUGHKJgU7tUJgKJGI87GIkug\"));\n+        assertEquals(false, StringUtils.isNumeric(\"_\"));\n+        assertEquals(false, StringUtils.isNumeric(\"hkHKHik*khbkuh\"));\n+    }\n+\n+    public void testIsNumericSpace() {\n+        assertEquals(false, StringUtils.isNumericSpace(null));\n+        assertEquals(true, StringUtils.isNumericSpace(\"\"));\n+        assertEquals(true, StringUtils.isNumericSpace(\" \"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"a\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"A\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"ham kso\"));\n+        assertEquals(true, StringUtils.isNumericSpace(\"1\"));\n+        assertEquals(true, StringUtils.isNumericSpace(\"1000\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"2.3\"));\n+        assertEquals(true, StringUtils.isNumericSpace(\"10 00\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"hkHKHik6iUGHKJgU7tUJgKJGI87GIkug\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"_\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"hkHKHik*khbkuh\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/StringUtilsStartsEndsWithTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.StringUtils} - StartsWith/EndsWith methods\n+ *\n+ * @version $Id$\n+ */\n+public class StringUtilsStartsEndsWithTest extends TestCase {\n+    private static final String foo    = \"foo\";\n+    private static final String bar    = \"bar\";\n+    private static final String foobar = \"foobar\";\n+    private static final String FOO    = \"FOO\";\n+    private static final String BAR    = \"BAR\";\n+    private static final String FOOBAR = \"FOOBAR\";\n+\n+    public StringUtilsStartsEndsWithTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StringUtilsStartsEndsWithTest.class);\n+        suite.setName(\"StringUtilsStartsEndsWith Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Test StringUtils.startsWith()\n+     */\n+    public void testStartsWith() {\n+        assertTrue(\"startsWith(null, null)\", StringUtils.startsWith(null, (String)null));\n+        assertFalse(\"startsWith(FOOBAR, null)\", StringUtils.startsWith(FOOBAR, (String)null));\n+        assertFalse(\"startsWith(null, FOO)\",    StringUtils.startsWith(null, FOO));\n+        assertTrue(\"startsWith(FOOBAR, \\\"\\\")\",  StringUtils.startsWith(FOOBAR, \"\"));\n+\n+        assertTrue(\"startsWith(foobar, foo)\",  StringUtils.startsWith(foobar, foo));\n+        assertTrue(\"startsWith(FOOBAR, FOO)\",  StringUtils.startsWith(FOOBAR, FOO));\n+        assertFalse(\"startsWith(foobar, FOO)\", StringUtils.startsWith(foobar, FOO));\n+        assertFalse(\"startsWith(FOOBAR, foo)\", StringUtils.startsWith(FOOBAR, foo));\n+\n+        assertFalse(\"startsWith(foo, foobar)\", StringUtils.startsWith(foo, foobar));\n+        assertFalse(\"startsWith(foo, foobar)\", StringUtils.startsWith(bar, foobar));\n+\n+        assertFalse(\"startsWith(foobar, bar)\", StringUtils.startsWith(foobar, bar));\n+        assertFalse(\"startsWith(FOOBAR, BAR)\", StringUtils.startsWith(FOOBAR, BAR));\n+        assertFalse(\"startsWith(foobar, BAR)\", StringUtils.startsWith(foobar, BAR));\n+        assertFalse(\"startsWith(FOOBAR, bar)\", StringUtils.startsWith(FOOBAR, bar));\n+    }\n+\n+    /**\n+     * Test StringUtils.testStartsWithIgnoreCase()\n+     */\n+    public void testStartsWithIgnoreCase() {\n+        assertTrue(\"startsWithIgnoreCase(null, null)\",    StringUtils.startsWithIgnoreCase(null, (String)null));\n+        assertFalse(\"startsWithIgnoreCase(FOOBAR, null)\", StringUtils.startsWithIgnoreCase(FOOBAR, (String)null));\n+        assertFalse(\"startsWithIgnoreCase(null, FOO)\",    StringUtils.startsWithIgnoreCase(null, FOO));\n+        assertTrue(\"startsWithIgnoreCase(FOOBAR, \\\"\\\")\",  StringUtils.startsWithIgnoreCase(FOOBAR, \"\"));\n+\n+        assertTrue(\"startsWithIgnoreCase(foobar, foo)\", StringUtils.startsWithIgnoreCase(foobar, foo));\n+        assertTrue(\"startsWithIgnoreCase(FOOBAR, FOO)\", StringUtils.startsWithIgnoreCase(FOOBAR, FOO));\n+        assertTrue(\"startsWithIgnoreCase(foobar, FOO)\", StringUtils.startsWithIgnoreCase(foobar, FOO));\n+        assertTrue(\"startsWithIgnoreCase(FOOBAR, foo)\", StringUtils.startsWithIgnoreCase(FOOBAR, foo));\n+\n+        assertFalse(\"startsWithIgnoreCase(foo, foobar)\", StringUtils.startsWithIgnoreCase(foo, foobar));\n+        assertFalse(\"startsWithIgnoreCase(foo, foobar)\", StringUtils.startsWithIgnoreCase(bar, foobar));\n+\n+        assertFalse(\"startsWithIgnoreCase(foobar, bar)\", StringUtils.startsWithIgnoreCase(foobar, bar));\n+        assertFalse(\"startsWithIgnoreCase(FOOBAR, BAR)\", StringUtils.startsWithIgnoreCase(FOOBAR, BAR));\n+        assertFalse(\"startsWithIgnoreCase(foobar, BAR)\", StringUtils.startsWithIgnoreCase(foobar, BAR));\n+        assertFalse(\"startsWithIgnoreCase(FOOBAR, bar)\", StringUtils.startsWithIgnoreCase(FOOBAR, bar));\n+    }\n+\n+\n+    /**\n+     * Test StringUtils.endsWith()\n+     */\n+    public void testEndsWith() {\n+        assertTrue(\"endsWith(null, null)\",    StringUtils.endsWith(null, (String)null));\n+        assertFalse(\"endsWith(FOOBAR, null)\", StringUtils.endsWith(FOOBAR, (String)null));\n+        assertFalse(\"endsWith(null, FOO)\",    StringUtils.endsWith(null, FOO));\n+        assertTrue(\"endsWith(FOOBAR, \\\"\\\")\",  StringUtils.endsWith(FOOBAR, \"\"));\n+\n+        assertFalse(\"endsWith(foobar, foo)\", StringUtils.endsWith(foobar, foo));\n+        assertFalse(\"endsWith(FOOBAR, FOO)\", StringUtils.endsWith(FOOBAR, FOO));\n+        assertFalse(\"endsWith(foobar, FOO)\", StringUtils.endsWith(foobar, FOO));\n+        assertFalse(\"endsWith(FOOBAR, foo)\", StringUtils.endsWith(FOOBAR, foo));\n+\n+        assertFalse(\"endsWith(foo, foobar)\", StringUtils.endsWith(foo, foobar));\n+        assertFalse(\"endsWith(foo, foobar)\", StringUtils.endsWith(bar, foobar));\n+\n+        assertTrue(\"endsWith(foobar, bar)\",  StringUtils.endsWith(foobar, bar));\n+        assertTrue(\"endsWith(FOOBAR, BAR)\",  StringUtils.endsWith(FOOBAR, BAR));\n+        assertFalse(\"endsWith(foobar, BAR)\", StringUtils.endsWith(foobar, BAR));\n+        assertFalse(\"endsWith(FOOBAR, bar)\", StringUtils.endsWith(FOOBAR, bar));\n+    }\n+\n+    /**\n+     * Test StringUtils.endsWithIgnoreCase()\n+     */\n+    public void testEndsWithIgnoreCase() {\n+        assertTrue(\"endsWithIgnoreCase(null, null)\",    StringUtils.endsWithIgnoreCase(null, (String)null));\n+        assertFalse(\"endsWithIgnoreCase(FOOBAR, null)\", StringUtils.endsWithIgnoreCase(FOOBAR, (String)null));\n+        assertFalse(\"endsWithIgnoreCase(null, FOO)\",    StringUtils.endsWithIgnoreCase(null, FOO));\n+        assertTrue(\"endsWithIgnoreCase(FOOBAR, \\\"\\\")\",  StringUtils.endsWithIgnoreCase(FOOBAR, \"\"));\n+\n+        assertFalse(\"endsWithIgnoreCase(foobar, foo)\", StringUtils.endsWithIgnoreCase(foobar, foo));\n+        assertFalse(\"endsWithIgnoreCase(FOOBAR, FOO)\", StringUtils.endsWithIgnoreCase(FOOBAR, FOO));\n+        assertFalse(\"endsWithIgnoreCase(foobar, FOO)\", StringUtils.endsWithIgnoreCase(foobar, FOO));\n+        assertFalse(\"endsWithIgnoreCase(FOOBAR, foo)\", StringUtils.endsWithIgnoreCase(FOOBAR, foo));\n+\n+        assertFalse(\"endsWithIgnoreCase(foo, foobar)\", StringUtils.endsWithIgnoreCase(foo, foobar));\n+        assertFalse(\"endsWithIgnoreCase(foo, foobar)\", StringUtils.endsWithIgnoreCase(bar, foobar));\n+\n+        assertTrue(\"endsWithIgnoreCase(foobar, bar)\", StringUtils.endsWithIgnoreCase(foobar, bar));\n+        assertTrue(\"endsWithIgnoreCase(FOOBAR, BAR)\", StringUtils.endsWithIgnoreCase(FOOBAR, BAR));\n+        assertTrue(\"endsWithIgnoreCase(foobar, BAR)\", StringUtils.endsWithIgnoreCase(foobar, BAR));\n+        assertTrue(\"endsWithIgnoreCase(FOOBAR, bar)\", StringUtils.endsWithIgnoreCase(FOOBAR, bar));\n+\n+        // javadoc\n+        assertTrue(StringUtils.endsWithIgnoreCase(\"abcdef\", \"def\"));\n+        assertTrue(StringUtils.endsWithIgnoreCase(\"ABCDEF\", \"def\"));\n+        assertFalse(StringUtils.endsWithIgnoreCase(\"ABCDEF\", \"cde\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/StringUtilsSubstringTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.StringUtils} - Substring methods\n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @author Phil Steitz\n+ * @version $Id$\n+ */\n+public class StringUtilsSubstringTest extends TestCase {\n+    private static final String FOO = \"foo\";\n+    private static final String BAR = \"bar\";\n+    private static final String BAZ = \"baz\";\n+    private static final String FOOBAR = \"foobar\";\n+    private static final String SENTENCE = \"foo bar baz\";\n+\n+    public StringUtilsSubstringTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StringUtilsSubstringTest.class);\n+        suite.setName(\"StringUtilsSubstring Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+\n+    public void testSubstring_StringInt() {\n+        assertEquals(null, StringUtils.substring(null, 0));\n+        assertEquals(\"\", StringUtils.substring(\"\", 0));\n+        assertEquals(\"\", StringUtils.substring(\"\", 2));\n+        \n+        assertEquals(\"\", StringUtils.substring(SENTENCE, 80));\n+        assertEquals(BAZ, StringUtils.substring(SENTENCE, 8));\n+        assertEquals(BAZ, StringUtils.substring(SENTENCE, -3));\n+        assertEquals(SENTENCE, StringUtils.substring(SENTENCE, 0));\n+        assertEquals(\"abc\", StringUtils.substring(\"abc\", -4));\n+        assertEquals(\"abc\", StringUtils.substring(\"abc\", -3));\n+        assertEquals(\"bc\", StringUtils.substring(\"abc\", -2));\n+        assertEquals(\"c\", StringUtils.substring(\"abc\", -1));\n+        assertEquals(\"abc\", StringUtils.substring(\"abc\", 0));\n+        assertEquals(\"bc\", StringUtils.substring(\"abc\", 1));\n+        assertEquals(\"c\", StringUtils.substring(\"abc\", 2));\n+        assertEquals(\"\", StringUtils.substring(\"abc\", 3));\n+        assertEquals(\"\", StringUtils.substring(\"abc\", 4));\n+    }\n+    \n+    public void testSubstring_StringIntInt() {\n+        assertEquals(null, StringUtils.substring(null, 0, 0));\n+        assertEquals(null, StringUtils.substring(null, 1, 2));\n+        assertEquals(\"\", StringUtils.substring(\"\", 0, 0));\n+        assertEquals(\"\", StringUtils.substring(\"\", 1, 2));\n+        assertEquals(\"\", StringUtils.substring(\"\", -2, -1));\n+        \n+        assertEquals(\"\", StringUtils.substring(SENTENCE, 8, 6));\n+        assertEquals(FOO, StringUtils.substring(SENTENCE, 0, 3));\n+        assertEquals(\"o\", StringUtils.substring(SENTENCE, -9, 3));\n+        assertEquals(FOO, StringUtils.substring(SENTENCE, 0, -8));\n+        assertEquals(\"o\", StringUtils.substring(SENTENCE, -9, -8));\n+        assertEquals(SENTENCE, StringUtils.substring(SENTENCE, 0, 80));\n+        assertEquals(\"\", StringUtils.substring(SENTENCE, 2, 2));\n+        assertEquals(\"b\",StringUtils.substring(\"abc\", -2, -1));\n+    }\n+           \n+    public void testLeft_String() {\n+        assertSame(null, StringUtils.left(null, -1));\n+        assertSame(null, StringUtils.left(null, 0));\n+        assertSame(null, StringUtils.left(null, 2));\n+        \n+        assertEquals(\"\", StringUtils.left(\"\", -1));\n+        assertEquals(\"\", StringUtils.left(\"\", 0));\n+        assertEquals(\"\", StringUtils.left(\"\", 2));\n+        \n+        assertEquals(\"\", StringUtils.left(FOOBAR, -1));\n+        assertEquals(\"\", StringUtils.left(FOOBAR, 0));\n+        assertEquals(FOO, StringUtils.left(FOOBAR, 3));\n+        assertSame(FOOBAR, StringUtils.left(FOOBAR, 80));\n+    }\n+    \n+    public void testRight_String() {\n+        assertSame(null, StringUtils.right(null, -1));\n+        assertSame(null, StringUtils.right(null, 0));\n+        assertSame(null, StringUtils.right(null, 2));\n+        \n+        assertEquals(\"\", StringUtils.right(\"\", -1));\n+        assertEquals(\"\", StringUtils.right(\"\", 0));\n+        assertEquals(\"\", StringUtils.right(\"\", 2));\n+        \n+        assertEquals(\"\", StringUtils.right(FOOBAR, -1));\n+        assertEquals(\"\", StringUtils.right(FOOBAR, 0));\n+        assertEquals(BAR, StringUtils.right(FOOBAR, 3));\n+        assertSame(FOOBAR, StringUtils.right(FOOBAR, 80));\n+    }\n+    \n+    public void testMid_String() {\n+        assertSame(null, StringUtils.mid(null, -1, 0));\n+        assertSame(null, StringUtils.mid(null, 0, -1));\n+        assertSame(null, StringUtils.mid(null, 3, 0));\n+        assertSame(null, StringUtils.mid(null, 3, 2));\n+        \n+        assertEquals(\"\", StringUtils.mid(\"\", 0, -1));\n+        assertEquals(\"\", StringUtils.mid(\"\", 0, 0));\n+        assertEquals(\"\", StringUtils.mid(\"\", 0, 2));\n+        \n+        assertEquals(\"\", StringUtils.mid(FOOBAR, 3, -1));\n+        assertEquals(\"\", StringUtils.mid(FOOBAR, 3, 0));\n+        assertEquals(\"b\", StringUtils.mid(FOOBAR, 3, 1));\n+        assertEquals(FOO, StringUtils.mid(FOOBAR, 0, 3));\n+        assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 3));\n+        assertEquals(FOOBAR, StringUtils.mid(FOOBAR, 0, 80));\n+        assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 80));\n+        assertEquals(\"\", StringUtils.mid(FOOBAR, 9, 3));\n+        assertEquals(FOO, StringUtils.mid(FOOBAR, -1, 3));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testSubstringBefore_StringString() {\n+        assertEquals(\"foo\", StringUtils.substringBefore(\"fooXXbarXXbaz\", \"XX\"));\n+\n+        assertEquals(null, StringUtils.substringBefore(null, null));\n+        assertEquals(null, StringUtils.substringBefore(null, \"\"));\n+        assertEquals(null, StringUtils.substringBefore(null, \"XX\"));\n+        assertEquals(\"\", StringUtils.substringBefore(\"\", null));\n+        assertEquals(\"\", StringUtils.substringBefore(\"\", \"\"));\n+        assertEquals(\"\", StringUtils.substringBefore(\"\", \"XX\"));\n+        \n+        assertEquals(\"foo\", StringUtils.substringBefore(\"foo\", null));\n+        assertEquals(\"foo\", StringUtils.substringBefore(\"foo\", \"b\"));\n+        assertEquals(\"f\", StringUtils.substringBefore(\"foot\", \"o\"));\n+        assertEquals(\"\", StringUtils.substringBefore(\"abc\", \"a\"));\n+        assertEquals(\"a\", StringUtils.substringBefore(\"abcba\", \"b\"));\n+        assertEquals(\"ab\", StringUtils.substringBefore(\"abc\", \"c\"));\n+        assertEquals(\"\", StringUtils.substringBefore(\"abc\", \"\"));\n+    }\n+    \n+    public void testSubstringAfter_StringString() {\n+        assertEquals(\"barXXbaz\", StringUtils.substringAfter(\"fooXXbarXXbaz\", \"XX\"));\n+        \n+        assertEquals(null, StringUtils.substringAfter(null, null));\n+        assertEquals(null, StringUtils.substringAfter(null, \"\"));\n+        assertEquals(null, StringUtils.substringAfter(null, \"XX\"));\n+        assertEquals(\"\", StringUtils.substringAfter(\"\", null));\n+        assertEquals(\"\", StringUtils.substringAfter(\"\", \"\"));\n+        assertEquals(\"\", StringUtils.substringAfter(\"\", \"XX\"));\n+        \n+        assertEquals(\"\", StringUtils.substringAfter(\"foo\", null));\n+        assertEquals(\"ot\", StringUtils.substringAfter(\"foot\", \"o\"));\n+        assertEquals(\"bc\", StringUtils.substringAfter(\"abc\", \"a\"));\n+        assertEquals(\"cba\", StringUtils.substringAfter(\"abcba\", \"b\"));\n+        assertEquals(\"\", StringUtils.substringAfter(\"abc\", \"c\"));\n+        assertEquals(\"abc\", StringUtils.substringAfter(\"abc\", \"\"));\n+        assertEquals(\"\", StringUtils.substringAfter(\"abc\", \"d\"));\n+    }\n+\n+    public void testSubstringBeforeLast_StringString() {\n+        assertEquals(\"fooXXbar\", StringUtils.substringBeforeLast(\"fooXXbarXXbaz\", \"XX\"));\n+\n+        assertEquals(null, StringUtils.substringBeforeLast(null, null));\n+        assertEquals(null, StringUtils.substringBeforeLast(null, \"\"));\n+        assertEquals(null, StringUtils.substringBeforeLast(null, \"XX\"));\n+        assertEquals(\"\", StringUtils.substringBeforeLast(\"\", null));\n+        assertEquals(\"\", StringUtils.substringBeforeLast(\"\", \"\"));\n+        assertEquals(\"\", StringUtils.substringBeforeLast(\"\", \"XX\"));\n+\n+        assertEquals(\"foo\", StringUtils.substringBeforeLast(\"foo\", null));\n+        assertEquals(\"foo\", StringUtils.substringBeforeLast(\"foo\", \"b\"));\n+        assertEquals(\"fo\", StringUtils.substringBeforeLast(\"foo\", \"o\"));\n+        assertEquals(\"abc\\r\\n\", StringUtils.substringBeforeLast(\"abc\\r\\n\", \"d\"));\n+        assertEquals(\"abc\", StringUtils.substringBeforeLast(\"abcdabc\", \"d\"));\n+        assertEquals(\"abcdabc\", StringUtils.substringBeforeLast(\"abcdabcd\", \"d\"));\n+        assertEquals(\"a\", StringUtils.substringBeforeLast(\"abc\", \"b\"));\n+        assertEquals(\"abc \", StringUtils.substringBeforeLast(\"abc \\n\", \"\\n\"));\n+        assertEquals(\"a\", StringUtils.substringBeforeLast(\"a\", null));\n+        assertEquals(\"a\", StringUtils.substringBeforeLast(\"a\", \"\"));\n+        assertEquals(\"\", StringUtils.substringBeforeLast(\"a\", \"a\"));\n+    }\n+    \n+    public void testSubstringAfterLast_StringString() {\n+        assertEquals(\"baz\", StringUtils.substringAfterLast(\"fooXXbarXXbaz\", \"XX\"));\n+\n+        assertEquals(null, StringUtils.substringAfterLast(null, null));\n+        assertEquals(null, StringUtils.substringAfterLast(null, \"\"));\n+        assertEquals(null, StringUtils.substringAfterLast(null, \"XX\"));\n+        assertEquals(\"\", StringUtils.substringAfterLast(\"\", null));\n+        assertEquals(\"\", StringUtils.substringAfterLast(\"\", \"\"));\n+        assertEquals(\"\", StringUtils.substringAfterLast(\"\", \"a\"));\n+\n+        assertEquals(\"\", StringUtils.substringAfterLast(\"foo\", null));\n+        assertEquals(\"\", StringUtils.substringAfterLast(\"foo\", \"b\"));\n+        assertEquals(\"t\", StringUtils.substringAfterLast(\"foot\", \"o\"));\n+        assertEquals(\"bc\", StringUtils.substringAfterLast(\"abc\", \"a\"));\n+        assertEquals(\"a\", StringUtils.substringAfterLast(\"abcba\", \"b\"));\n+        assertEquals(\"\", StringUtils.substringAfterLast(\"abc\", \"c\"));\n+        assertEquals(\"\", StringUtils.substringAfterLast(\"\", \"d\"));\n+        assertEquals(\"\", StringUtils.substringAfterLast(\"abc\", \"\"));\n+    }        \n+        \n+    //-----------------------------------------------------------------------\n+    public void testSubstringBetween_StringString() {\n+        assertEquals(null, StringUtils.substringBetween(null, \"tag\"));\n+        assertEquals(\"\", StringUtils.substringBetween(\"\", \"\"));\n+        assertEquals(null, StringUtils.substringBetween(\"\", \"abc\"));\n+        assertEquals(\"\", StringUtils.substringBetween(\"    \", \" \"));\n+        assertEquals(null, StringUtils.substringBetween(\"abc\", null));\n+        assertEquals(\"\", StringUtils.substringBetween(\"abc\", \"\"));\n+        assertEquals(null, StringUtils.substringBetween(\"abc\", \"a\"));\n+        assertEquals(\"bc\", StringUtils.substringBetween(\"abca\", \"a\"));\n+        assertEquals(\"bc\", StringUtils.substringBetween(\"abcabca\", \"a\"));\n+        assertEquals(\"bar\", StringUtils.substringBetween(\"\\nbar\\n\", \"\\n\"));\n+    }\n+            \n+    public void testSubstringBetween_StringStringString() {\n+        assertEquals(null, StringUtils.substringBetween(null, \"\", \"\"));\n+        assertEquals(null, StringUtils.substringBetween(\"\", null, \"\"));\n+        assertEquals(null, StringUtils.substringBetween(\"\", \"\", null));\n+        assertEquals(\"\", StringUtils.substringBetween(\"\", \"\", \"\"));\n+        assertEquals(\"\", StringUtils.substringBetween(\"foo\", \"\", \"\"));\n+        assertEquals(null, StringUtils.substringBetween(\"foo\", \"\", \"]\"));\n+        assertEquals(null, StringUtils.substringBetween(\"foo\", \"[\", \"]\"));\n+        assertEquals(\"\", StringUtils.substringBetween(\"    \", \" \", \"  \"));\n+        assertEquals(\"bar\", StringUtils.substringBetween(\"<foo>bar</foo>\", \"<foo>\", \"</foo>\") );\n+    }\n+\n+   /**\n+     * Tests the substringsBetween method that returns an String Array of substrings.\n+     */\n+    public void testSubstringsBetween_StringStringString() {\n+\n+        String[] results = StringUtils.substringsBetween(\"[one], [two], [three]\", \"[\", \"]\");\n+        assertEquals(3, results.length);\n+        assertEquals(\"one\", results[0]);\n+        assertEquals(\"two\", results[1]);\n+        assertEquals(\"three\", results[2]);\n+\n+        results = StringUtils.substringsBetween(\"[one], [two], three\", \"[\", \"]\");\n+        assertEquals(2, results.length);\n+        assertEquals(\"one\", results[0]);\n+        assertEquals(\"two\", results[1]);\n+\n+        results = StringUtils.substringsBetween(\"[one], [two], three]\", \"[\", \"]\");\n+        assertEquals(2, results.length);\n+        assertEquals(\"one\", results[0]);\n+        assertEquals(\"two\", results[1]);\n+\n+        results = StringUtils.substringsBetween(\"[one], two], three]\", \"[\", \"]\");\n+        assertEquals(1, results.length);\n+        assertEquals(\"one\", results[0]);\n+\n+        results = StringUtils.substringsBetween(\"one], two], [three]\", \"[\", \"]\");\n+        assertEquals(1, results.length);\n+        assertEquals(\"three\", results[0]);\n+\n+        // 'ab hello ba' will match, but 'ab non ba' won't\n+        // this is because the 'a' is shared between the two and can't be matched twice\n+        results = StringUtils.substringsBetween(\"aabhellobabnonba\", \"ab\", \"ba\");\n+        assertEquals(1, results.length);\n+        assertEquals(\"hello\", results[0]);\n+\n+        results = StringUtils.substringsBetween(\"one, two, three\", \"[\", \"]\");\n+        assertNull(results);\n+\n+        results = StringUtils.substringsBetween(\"[one, two, three\", \"[\", \"]\");\n+        assertNull(results);\n+\n+        results = StringUtils.substringsBetween(\"one, two, three]\", \"[\", \"]\");\n+        assertNull(results);\n+\n+        results = StringUtils.substringsBetween(\"[one], [two], [three]\", \"[\", null);\n+        assertNull(results);\n+\n+        results = StringUtils.substringsBetween(\"[one], [two], [three]\", null, \"]\");\n+        assertNull(results);\n+\n+        results = StringUtils.substringsBetween(\"[one], [two], [three]\", \"\", \"\");\n+        assertNull(results);\n+\n+        results = StringUtils.substringsBetween(null, \"[\", \"]\");\n+        assertNull(results);\n+\n+        results = StringUtils.substringsBetween(\"\", \"[\", \"]\");\n+        assertEquals(0, results.length);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCountMatches_String() {\n+        assertEquals(0, StringUtils.countMatches(null, null));\n+        assertEquals(0, StringUtils.countMatches(\"blah\", null));\n+        assertEquals(0, StringUtils.countMatches(null, \"DD\"));\n+\n+        assertEquals(0, StringUtils.countMatches(\"x\", \"\"));\n+        assertEquals(0, StringUtils.countMatches(\"\", \"\"));\n+\n+        assertEquals(3, \n+             StringUtils.countMatches(\"one long someone sentence of one\", \"one\"));\n+        assertEquals(0, \n+             StringUtils.countMatches(\"one long someone sentence of one\", \"two\"));\n+        assertEquals(4, \n+             StringUtils.countMatches(\"oooooooooooo\", \"ooo\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/StringUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Locale;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.StringUtils}.\n+ *\n+ * @author Apache Software Foundation\n+ * @author Daniel L. Rall\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @author <a href=\"mailto:fredrik@westermarck.com>Fredrik Westermarck</a>\n+ * @author Holger Krauth\n+ * @author <a href=\"hps@intermeta.de\">Henning P. Schmiedehausen</a>\n+ * @author Phil Steitz\n+ * @author Gary D. Gregory\n+ * @author Scott Johnson\n+ * @author Al Chou\n+ * @version $Id$\n+ */\n+public class StringUtilsTest extends TestCase {\n+    \n+    static final String WHITESPACE;\n+    static final String NON_WHITESPACE;\n+    static final String TRIMMABLE;\n+    static final String NON_TRIMMABLE;\n+    static {\n+        String ws = \"\";\n+        String nws = \"\";\n+        String tr = \"\";\n+        String ntr = \"\";\n+        for (int i = 0; i < Character.MAX_VALUE; i++) {\n+            if (Character.isWhitespace((char) i)) {\n+                ws += String.valueOf((char) i);\n+                if (i > 32) {\n+                    ntr += String.valueOf((char) i);\n+                }\n+            } else if (i < 40) {\n+                nws += String.valueOf((char) i);\n+            }\n+        }\n+        for (int i = 0; i <= 32; i++) {\n+            tr += String.valueOf((char) i);\n+        }\n+        WHITESPACE = ws;\n+        NON_WHITESPACE = nws;\n+        TRIMMABLE = tr;\n+        NON_TRIMMABLE = ntr;\n+    }\n+\n+    private static final String[] ARRAY_LIST = { \"foo\", \"bar\", \"baz\" };\n+    private static final String[] EMPTY_ARRAY_LIST = {};\n+    private static final String[] NULL_ARRAY_LIST = {null};\n+    private static final String[] MIXED_ARRAY_LIST = {null, \"\", \"foo\"};\n+    private static final Object[] MIXED_TYPE_LIST = {new String(\"foo\"), new Long(2)};\n+\n+    private static final String SEPARATOR = \",\";\n+    private static final char   SEPARATOR_CHAR = ';';\n+\n+    private static final String TEXT_LIST = \"foo,bar,baz\";\n+    private static final String TEXT_LIST_CHAR = \"foo;bar;baz\";\n+    private static final String TEXT_LIST_NOSEP = \"foobarbaz\";\n+\n+    private static final String FOO_UNCAP = \"foo\";\n+    private static final String FOO_CAP = \"Foo\";\n+\n+    private static final String SENTENCE_UNCAP = \"foo bar baz\";\n+    private static final String SENTENCE_CAP = \"Foo Bar Baz\";\n+\n+    public StringUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StringUtilsTest.class);\n+        suite.setName(\"StringUtilsTest Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new StringUtils());\n+        Constructor<?>[] cons = StringUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(StringUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(StringUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testCaseFunctions() {\n+        assertEquals(null, StringUtils.upperCase(null));\n+        assertEquals(null, StringUtils.upperCase(null, Locale.ENGLISH));\n+        assertEquals(null, StringUtils.lowerCase(null));\n+        assertEquals(null, StringUtils.lowerCase(null, Locale.ENGLISH));\n+        assertEquals(null, StringUtils.capitalize(null));\n+        assertEquals(null, StringUtils.uncapitalize(null));\n+\n+        assertEquals(\"capitalize(empty-string) failed\",\n+                     \"\", StringUtils.capitalize(\"\") );\n+        assertEquals(\"capitalize(single-char-string) failed\",\n+                     \"X\", StringUtils.capitalize(\"x\") );\n+        assertEquals(\"uncapitalize(String) failed\",\n+                     FOO_UNCAP, StringUtils.uncapitalize(FOO_CAP) );\n+        assertEquals(\"uncapitalize(empty-string) failed\",\n+                     \"\", StringUtils.uncapitalize(\"\") );\n+        assertEquals(\"uncapitalize(single-char-string) failed\",\n+                     \"x\", StringUtils.uncapitalize(\"X\") );\n+                     \n+        // reflection type of tests: Sentences.\n+        assertEquals(\"uncapitalize(capitalize(String)) failed\",\n+                     SENTENCE_UNCAP, StringUtils.uncapitalize(StringUtils.capitalize(SENTENCE_UNCAP)) );\n+        assertEquals(\"capitalize(uncapitalize(String)) failed\",\n+                     SENTENCE_CAP, StringUtils.capitalize(StringUtils.uncapitalize(SENTENCE_CAP)) );\n+\n+        // reflection type of tests: One word.\n+        assertEquals(\"uncapitalize(capitalize(String)) failed\",\n+                     FOO_UNCAP, StringUtils.uncapitalize(StringUtils.capitalize(FOO_UNCAP)) );\n+        assertEquals(\"capitalize(uncapitalize(String)) failed\",\n+                     FOO_CAP, StringUtils.capitalize(StringUtils.uncapitalize(FOO_CAP)) );\n+\n+        assertEquals(\"upperCase(String) failed\",\n+                     \"FOO TEST THING\", StringUtils.upperCase(\"fOo test THING\") );\n+        assertEquals(\"upperCase(empty-string) failed\",\n+                     \"\", StringUtils.upperCase(\"\") );\n+        assertEquals(\"lowerCase(String) failed\",\n+                     \"foo test thing\", StringUtils.lowerCase(\"fOo test THING\") );\n+        assertEquals(\"lowerCase(empty-string) failed\",\n+                     \"\", StringUtils.lowerCase(\"\") );\n+\n+        assertEquals(\"upperCase(String, Locale) failed\",\n+                     \"FOO TEST THING\", StringUtils.upperCase(\"fOo test THING\", Locale.ENGLISH) );\n+        assertEquals(\"upperCase(empty-string, Locale) failed\",\n+                     \"\", StringUtils.upperCase(\"\", Locale.ENGLISH) );\n+        assertEquals(\"lowerCase(String, Locale) failed\",\n+                     \"foo test thing\", StringUtils.lowerCase(\"fOo test THING\", Locale.ENGLISH) );\n+        assertEquals(\"lowerCase(empty-string, Locale) failed\",\n+                     \"\", StringUtils.lowerCase(\"\", Locale.ENGLISH) );\n+    }\n+\n+    public void testSwapCase_String() {\n+        assertEquals(null, StringUtils.swapCase(null));\n+        assertEquals(\"\", StringUtils.swapCase(\"\"));\n+        assertEquals(\"  \", StringUtils.swapCase(\"  \"));\n+        \n+        assertEquals(\"i\", WordUtils.swapCase(\"I\") );\n+        assertEquals(\"I\", WordUtils.swapCase(\"i\") );\n+        assertEquals(\"I AM HERE 123\", StringUtils.swapCase(\"i am here 123\") );\n+        assertEquals(\"i aM hERE 123\", StringUtils.swapCase(\"I Am Here 123\") );\n+        assertEquals(\"I AM here 123\", StringUtils.swapCase(\"i am HERE 123\") );\n+        assertEquals(\"i am here 123\", StringUtils.swapCase(\"I AM HERE 123\") );\n+        \n+        String test = \"This String contains a TitleCase character: \\u01C8\";\n+        String expect = \"tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \\u01C9\";\n+        assertEquals(expect, WordUtils.swapCase(test));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testJoin_Objectarray() {\n+        assertEquals(null, StringUtils.join(null));\n+        assertEquals(\"\", StringUtils.join(EMPTY_ARRAY_LIST));\n+        assertEquals(\"\", StringUtils.join(NULL_ARRAY_LIST));\n+        assertEquals(\"abc\", StringUtils.join(new String[] {\"a\", \"b\", \"c\"}));\n+        assertEquals(\"a\", StringUtils.join(new String[] {null, \"a\", \"\"}));\n+        assertEquals(\"foo\", StringUtils.join(MIXED_ARRAY_LIST));\n+        assertEquals(\"foo2\", StringUtils.join(MIXED_TYPE_LIST));\n+    }\n+        \n+    public void testJoin_ArrayChar() {\n+        assertEquals(null, StringUtils.join((Object[]) null, ','));\n+        assertEquals(TEXT_LIST_CHAR, StringUtils.join(ARRAY_LIST, SEPARATOR_CHAR));\n+        assertEquals(\"\", StringUtils.join(EMPTY_ARRAY_LIST, SEPARATOR_CHAR));\n+        assertEquals(\";;foo\", StringUtils.join(MIXED_ARRAY_LIST, SEPARATOR_CHAR));\n+        assertEquals(\"foo;2\", StringUtils.join(MIXED_TYPE_LIST, SEPARATOR_CHAR));\n+\n+        assertEquals(\"/\", StringUtils.join(MIXED_ARRAY_LIST, '/', 0, MIXED_ARRAY_LIST.length-1));\n+        assertEquals(\"foo\", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 1));\n+        assertEquals(\"foo/2\", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 2));\n+        assertEquals(\"2\", StringUtils.join(MIXED_TYPE_LIST, '/', 1, 2));\n+        assertEquals(\"\", StringUtils.join(MIXED_TYPE_LIST, '/', 2, 1));\n+    }\n+    \n+    public void testJoin_ArrayString() {\n+        assertEquals(null, StringUtils.join((Object[]) null, null));\n+        assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, null));\n+        assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, \"\"));\n+        \n+        assertEquals(\"\", StringUtils.join(NULL_ARRAY_LIST, null));\n+        \n+        assertEquals(\"\", StringUtils.join(EMPTY_ARRAY_LIST, null));\n+        assertEquals(\"\", StringUtils.join(EMPTY_ARRAY_LIST, \"\"));\n+        assertEquals(\"\", StringUtils.join(EMPTY_ARRAY_LIST, SEPARATOR));\n+\n+        assertEquals(TEXT_LIST, StringUtils.join(ARRAY_LIST, SEPARATOR));\n+        assertEquals(\",,foo\", StringUtils.join(MIXED_ARRAY_LIST, SEPARATOR));\n+        assertEquals(\"foo,2\", StringUtils.join(MIXED_TYPE_LIST, SEPARATOR));\n+\n+        assertEquals(\"/\", StringUtils.join(MIXED_ARRAY_LIST, \"/\", 0, MIXED_ARRAY_LIST.length-1));\n+        assertEquals(\"\", StringUtils.join(MIXED_ARRAY_LIST, \"\", 0, MIXED_ARRAY_LIST.length-1));\n+        assertEquals(\"foo\", StringUtils.join(MIXED_TYPE_LIST, \"/\", 0, 1));\n+        assertEquals(\"foo/2\", StringUtils.join(MIXED_TYPE_LIST, \"/\", 0, 2));\n+        assertEquals(\"2\", StringUtils.join(MIXED_TYPE_LIST, \"/\", 1, 2));\n+        assertEquals(\"\", StringUtils.join(MIXED_TYPE_LIST, \"/\", 2, 1));\n+    }\n+    \n+    public void testJoin_IteratorChar() {\n+        assertEquals(null, StringUtils.join((Iterator<?>) null, ','));\n+        assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(), SEPARATOR_CHAR));\n+        assertEquals(\"\", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST).iterator(), SEPARATOR_CHAR));\n+        assertEquals(\"\", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(), SEPARATOR_CHAR));\n+        assertEquals(\"foo\", StringUtils.join(Collections.singleton(\"foo\").iterator(), 'x'));\n+    }\n+    \n+    public void testJoin_IteratorString() {\n+        assertEquals(null, StringUtils.join((Iterator<?>) null, null));\n+        assertEquals(TEXT_LIST_NOSEP, StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(), null));\n+        assertEquals(TEXT_LIST_NOSEP, StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(), \"\"));\n+        assertEquals(\"foo\", StringUtils.join(Collections.singleton(\"foo\").iterator(), \"x\"));\n+        assertEquals(\"foo\", StringUtils.join(Collections.singleton(\"foo\").iterator(), null));\n+\n+        assertEquals(\"\", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST).iterator(), null));\n+        \n+        assertEquals(\"\", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(), null));\n+        assertEquals(\"\", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(), \"\"));\n+        assertEquals(\"\", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(), SEPARATOR));\n+        \n+        assertEquals(TEXT_LIST, StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(), SEPARATOR));\n+    }\n+\n+    public void testJoin_IterableChar() {\n+        assertEquals(null, StringUtils.join((Iterable<?>) null, ','));\n+        assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR));\n+        assertEquals(\"\", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR));\n+        assertEquals(\"\", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR));\n+        assertEquals(\"foo\", StringUtils.join(Collections.singleton(\"foo\"), 'x'));\n+    }\n+\n+    public void testJoin_IterableString() {\n+        assertEquals(null, StringUtils.join((Iterable<?>) null, null));\n+        assertEquals(TEXT_LIST_NOSEP, StringUtils.join(Arrays.asList(ARRAY_LIST), null));\n+        assertEquals(TEXT_LIST_NOSEP, StringUtils.join(Arrays.asList(ARRAY_LIST), \"\"));\n+        assertEquals(\"foo\", StringUtils.join(Collections.singleton(\"foo\"), \"x\"));\n+        assertEquals(\"foo\", StringUtils.join(Collections.singleton(\"foo\"), null));\n+\n+        assertEquals(\"\", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), null));\n+\n+        assertEquals(\"\", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), null));\n+        assertEquals(\"\", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), \"\"));\n+        assertEquals(\"\", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR));\n+\n+        assertEquals(TEXT_LIST, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR));\n+    }\n+\n+    public void testSplit_String() {\n+        assertEquals(null, StringUtils.split(null));\n+        assertEquals(0, StringUtils.split(\"\").length);\n+        \n+        String str = \"a b  .c\";\n+        String[] res = StringUtils.split(str);\n+        assertEquals(3, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"b\", res[1]);\n+        assertEquals(\".c\", res[2]);\n+        \n+        str = \" a \";\n+        res = StringUtils.split(str);\n+        assertEquals(1, res.length);\n+        assertEquals(\"a\", res[0]);\n+        \n+        str = \"a\" + WHITESPACE + \"b\" + NON_WHITESPACE + \"c\";\n+        res = StringUtils.split(str);\n+        assertEquals(2, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"b\" + NON_WHITESPACE + \"c\", res[1]);                       \n+    }\n+    \n+    public void testSplit_StringChar() {\n+        assertEquals(null, StringUtils.split(null, '.'));\n+        assertEquals(0, StringUtils.split(\"\", '.').length);\n+\n+        String str = \"a.b.. c\";\n+        String[] res = StringUtils.split(str, '.');\n+        assertEquals(3, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"b\", res[1]);\n+        assertEquals(\" c\", res[2]);\n+            \n+        str = \".a.\";\n+        res = StringUtils.split(str, '.');\n+        assertEquals(1, res.length);\n+        assertEquals(\"a\", res[0]);\n+        \n+        str = \"a b c\";\n+        res = StringUtils.split(str,' ');\n+        assertEquals(3, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"b\", res[1]);\n+        assertEquals(\"c\", res[2]);\n+    }\n+    \n+    public void testSplit_StringString_StringStringInt() {\n+        assertEquals(null, StringUtils.split(null, \".\"));\n+        assertEquals(null, StringUtils.split(null, \".\", 3));\n+        \n+        assertEquals(0, StringUtils.split(\"\", \".\").length);\n+        assertEquals(0, StringUtils.split(\"\", \".\", 3).length);\n+        \n+        innerTestSplit('.', \".\", ' ');\n+        innerTestSplit('.', \".\", ',');\n+        innerTestSplit('.', \".,\", 'x');\n+        for (int i = 0; i < WHITESPACE.length(); i++) {\n+            for (int j = 0; j < NON_WHITESPACE.length(); j++) {\n+                innerTestSplit(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j));\n+                innerTestSplit(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j));\n+            }\n+        }\n+        \n+        String[] results = null;\n+        String[] expectedResults = {\"ab\", \"de fg\"};\n+        results = StringUtils.split(\"ab   de fg\", null, 2);\n+        assertEquals(expectedResults.length, results.length);\n+        for (int i = 0; i < expectedResults.length; i++) {\n+            assertEquals(expectedResults[i], results[i]);\n+        }\n+        \n+        String[] expectedResults2 = {\"ab\", \"cd:ef\"};\n+        results = StringUtils.split(\"ab:cd:ef\",\":\", 2);\n+        assertEquals(expectedResults2.length, results.length);\n+        for (int i = 0; i < expectedResults2.length; i++) {\n+            assertEquals(expectedResults2[i], results[i]);\n+        }\n+    }\n+    \n+    private void innerTestSplit(char separator, String sepStr, char noMatch) {\n+        String msg = \"Failed on separator hex(\" + Integer.toHexString(separator) +\n+            \"), noMatch hex(\" + Integer.toHexString(noMatch) + \"), sepStr(\" + sepStr + \")\";\n+        \n+        final String str = \"a\" + separator + \"b\" + separator + separator + noMatch + \"c\";\n+        String[] res;\n+        // (str, sepStr)\n+        res = StringUtils.split(str, sepStr);\n+        assertEquals(msg, 3, res.length);\n+        assertEquals(msg, \"a\", res[0]);\n+        assertEquals(msg, \"b\", res[1]);\n+        assertEquals(msg, noMatch + \"c\", res[2]);\n+        \n+        final String str2 = separator + \"a\" + separator;\n+        res = StringUtils.split(str2, sepStr);\n+        assertEquals(msg, 1, res.length);\n+        assertEquals(msg, \"a\", res[0]);\n+\n+        res = StringUtils.split(str, sepStr, -1);\n+        assertEquals(msg, 3, res.length);\n+        assertEquals(msg, \"a\", res[0]);\n+        assertEquals(msg, \"b\", res[1]);\n+        assertEquals(msg, noMatch + \"c\", res[2]);\n+        \n+        res = StringUtils.split(str, sepStr, 0);\n+        assertEquals(msg, 3, res.length);\n+        assertEquals(msg, \"a\", res[0]);\n+        assertEquals(msg, \"b\", res[1]);\n+        assertEquals(msg, noMatch + \"c\", res[2]);\n+        \n+        res = StringUtils.split(str, sepStr, 1);\n+        assertEquals(msg, 1, res.length);\n+        assertEquals(msg, str, res[0]);\n+        \n+        res = StringUtils.split(str, sepStr, 2);\n+        assertEquals(msg, 2, res.length);\n+        assertEquals(msg, \"a\", res[0]);\n+        assertEquals(msg, str.substring(2), res[1]);\n+    }\n+\n+    public void testSplitByWholeString_StringStringBoolean() {\n+        assertEquals( null, StringUtils.splitByWholeSeparator( null, \".\" ) ) ;\n+\n+        assertEquals( 0, StringUtils.splitByWholeSeparator( \"\", \".\" ).length ) ;\n+\n+        String stringToSplitOnNulls = \"ab   de fg\" ;\n+        String[] splitOnNullExpectedResults = { \"ab\", \"de\", \"fg\" } ;\n+\n+        String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ;\n+        assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ;\n+        for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) {\n+            assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ;\n+        }\n+\n+        String stringToSplitOnCharactersAndString = \"abstemiouslyaeiouyabstemiously\" ;\n+\n+        String[] splitOnStringExpectedResults = { \"abstemiously\", \"abstemiously\" } ;\n+        String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, \"aeiouy\" ) ;\n+        assertEquals( splitOnStringExpectedResults.length, splitOnStringResults.length ) ;\n+        for ( int i = 0 ; i < splitOnStringExpectedResults.length ; i+= 1 ) {\n+            assertEquals( splitOnStringExpectedResults[i], splitOnStringResults[i] ) ;\n+        }\n+\n+        String[] splitWithMultipleSeparatorExpectedResults = {\"ab\", \"cd\", \"ef\"};\n+        String[] splitWithMultipleSeparator = StringUtils.splitByWholeSeparator(\"ab:cd::ef\", \":\");\n+        assertEquals( splitWithMultipleSeparatorExpectedResults.length, splitWithMultipleSeparator.length );\n+        for( int i = 0; i < splitWithMultipleSeparatorExpectedResults.length ; i++ ) {\n+            assertEquals( splitWithMultipleSeparatorExpectedResults[i], splitWithMultipleSeparator[i] ) ;\n+        }\n+    }\n+\n+    public void testSplitByWholeString_StringStringBooleanInt() {\n+        assertEquals( null, StringUtils.splitByWholeSeparator( null, \".\", 3 ) ) ;\n+\n+        assertEquals( 0, StringUtils.splitByWholeSeparator( \"\", \".\", 3 ).length ) ;\n+\n+        String stringToSplitOnNulls = \"ab   de fg\" ;\n+        String[] splitOnNullExpectedResults = { \"ab\", \"de fg\" } ;\n+        //String[] splitOnNullExpectedResults = { \"ab\", \"de\" } ;\n+\n+        String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null, 2 ) ;\n+        assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ;\n+        for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) {\n+            assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ;\n+        }\n+\n+        String stringToSplitOnCharactersAndString = \"abstemiouslyaeiouyabstemiouslyaeiouyabstemiously\" ;\n+\n+        String[] splitOnStringExpectedResults = { \"abstemiously\", \"abstemiouslyaeiouyabstemiously\" } ;\n+        //String[] splitOnStringExpectedResults = { \"abstemiously\", \"abstemiously\" } ;\n+        String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, \"aeiouy\", 2 ) ;\n+        assertEquals( splitOnStringExpectedResults.length, splitOnStringResults.length ) ;\n+        for ( int i = 0 ; i < splitOnStringExpectedResults.length ; i++ ) {\n+            assertEquals( splitOnStringExpectedResults[i], splitOnStringResults[i] ) ;\n+        }\n+    }\n+\n+    public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() {\n+        assertEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, \".\", -1 ) ) ;\n+\n+        assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( \"\", \".\", -1 ).length ) ;\n+\n+        // test whitespace\n+        String input = \"ab   de fg\" ;\n+        String[] expected = new String[] { \"ab\", \"\", \"\", \"de\", \"fg\" } ;\n+\n+        String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ;\n+        assertEquals( expected.length, actual.length ) ;\n+        for ( int i = 0 ; i < actual.length ; i+= 1 ) {\n+            assertEquals( expected[i], actual[i] );\n+        }\n+\n+        // test delimiter singlechar\n+        input = \"1::2:::3::::4\";\n+        expected = new String[] { \"1\", \"\", \"2\", \"\", \"\", \"3\", \"\", \"\", \"\", \"4\" };\n+\n+        actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, \":\", -1 ) ;\n+        assertEquals( expected.length, actual.length ) ;\n+        for ( int i = 0 ; i < actual.length ; i+= 1 ) {\n+            assertEquals( expected[i], actual[i] );\n+        }\n+\n+        // test delimiter multichar\n+        input = \"1::2:::3::::4\";\n+        expected = new String[] { \"1\", \"2\", \":3\", \"\", \"4\" };\n+\n+        actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, \"::\", -1 ) ;\n+        assertEquals( expected.length, actual.length ) ;\n+        for ( int i = 0 ; i < actual.length ; i+= 1 ) {\n+            assertEquals( expected[i], actual[i] );\n+        }\n+\n+        // test delimiter char with max\n+        input = \"1::2::3:4\";\n+        expected = new String[] { \"1\", \"\", \"2\", \":3:4\" };\n+\n+        actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, \":\", 4 ) ;\n+        assertEquals( expected.length, actual.length ) ;\n+        for ( int i = 0 ; i < actual.length ; i+= 1 ) {\n+            assertEquals( expected[i], actual[i] );\n+        }\n+    }\n+    \n+    public void testSplitPreserveAllTokens_String() {\n+        assertEquals(null, StringUtils.splitPreserveAllTokens(null));\n+        assertEquals(0, StringUtils.splitPreserveAllTokens(\"\").length);\n+        \n+        String str = \"abc def\";\n+        String[] res = StringUtils.splitPreserveAllTokens(str);\n+        assertEquals(2, res.length);\n+        assertEquals(\"abc\", res[0]);\n+        assertEquals(\"def\", res[1]);\n+        \n+        str = \"abc  def\";\n+        res = StringUtils.splitPreserveAllTokens(str);\n+        assertEquals(3, res.length);\n+        assertEquals(\"abc\", res[0]);\n+        assertEquals(\"\", res[1]);\n+        assertEquals(\"def\", res[2]);\n+        \n+        str = \" abc \";\n+        res = StringUtils.splitPreserveAllTokens(str);\n+        assertEquals(3, res.length);\n+        assertEquals(\"\", res[0]);\n+        assertEquals(\"abc\", res[1]);\n+        assertEquals(\"\", res[2]);\n+        \n+        str = \"a b .c\";\n+        res = StringUtils.splitPreserveAllTokens(str);\n+        assertEquals(3, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"b\", res[1]);\n+        assertEquals(\".c\", res[2]);\n+        \n+        str = \" a b .c\";\n+        res = StringUtils.splitPreserveAllTokens(str);\n+        assertEquals(4, res.length);\n+        assertEquals(\"\", res[0]);\n+        assertEquals(\"a\", res[1]);\n+        assertEquals(\"b\", res[2]);\n+        assertEquals(\".c\", res[3]);\n+        \n+        str = \"a  b  .c\";\n+        res = StringUtils.splitPreserveAllTokens(str);\n+        assertEquals(5, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"\", res[1]);\n+        assertEquals(\"b\", res[2]);\n+        assertEquals(\"\", res[3]);\n+        assertEquals(\".c\", res[4]);\n+        \n+        str = \" a  \";\n+        res = StringUtils.splitPreserveAllTokens(str);\n+        assertEquals(4, res.length);\n+        assertEquals(\"\", res[0]);\n+        assertEquals(\"a\", res[1]);\n+        assertEquals(\"\", res[2]);\n+        assertEquals(\"\", res[3]);\n+\n+        str = \" a  b\";\n+        res = StringUtils.splitPreserveAllTokens(str);\n+        assertEquals(4, res.length);\n+        assertEquals(\"\", res[0]);\n+        assertEquals(\"a\", res[1]);\n+        assertEquals(\"\", res[2]);\n+        assertEquals(\"b\", res[3]);\n+\n+        str = \"a\" + WHITESPACE + \"b\" + NON_WHITESPACE + \"c\";\n+        res = StringUtils.splitPreserveAllTokens(str);\n+        assertEquals(WHITESPACE.length() + 1, res.length);\n+        assertEquals(\"a\", res[0]);\n+        for(int i = 1; i < WHITESPACE.length()-1; i++)\n+        {\n+          assertEquals(\"\", res[i]);\n+        }\n+        assertEquals(\"b\" + NON_WHITESPACE + \"c\", res[WHITESPACE.length()]);                       \n+    }\n+    \n+    public void testSplitPreserveAllTokens_StringChar() {\n+        assertEquals(null, StringUtils.splitPreserveAllTokens(null, '.'));\n+        assertEquals(0, StringUtils.splitPreserveAllTokens(\"\", '.').length);\n+\n+        String str = \"a.b. c\";\n+        String[] res = StringUtils.splitPreserveAllTokens(str, '.');\n+        assertEquals(3, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"b\", res[1]);\n+        assertEquals(\" c\", res[2]);\n+            \n+        str = \"a.b.. c\";\n+        res = StringUtils.splitPreserveAllTokens(str, '.');\n+        assertEquals(4, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"b\", res[1]);\n+        assertEquals(\"\", res[2]);\n+        assertEquals(\" c\", res[3]);\n+\n+        str = \".a.\";\n+        res = StringUtils.splitPreserveAllTokens(str, '.');\n+        assertEquals(3, res.length);\n+        assertEquals(\"\", res[0]);\n+        assertEquals(\"a\", res[1]);\n+        assertEquals(\"\", res[2]);\n+       \n+        str = \".a..\";\n+        res = StringUtils.splitPreserveAllTokens(str, '.');\n+        assertEquals(4, res.length);\n+        assertEquals(\"\", res[0]);\n+        assertEquals(\"a\", res[1]);\n+        assertEquals(\"\", res[2]);\n+        assertEquals(\"\", res[3]);\n+        \n+        str = \"..a.\";\n+        res = StringUtils.splitPreserveAllTokens(str, '.');\n+        assertEquals(4, res.length);\n+        assertEquals(\"\", res[0]);\n+        assertEquals(\"\", res[1]);\n+        assertEquals(\"a\", res[2]);\n+        assertEquals(\"\", res[3]);\n+        \n+        str = \"..a\";\n+        res = StringUtils.splitPreserveAllTokens(str, '.');\n+        assertEquals(3, res.length);\n+        assertEquals(\"\", res[0]);\n+        assertEquals(\"\", res[1]);\n+        assertEquals(\"a\", res[2]);\n+        \n+        str = \"a b c\";\n+        res = StringUtils.splitPreserveAllTokens(str,' ');\n+        assertEquals(3, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"b\", res[1]);\n+        assertEquals(\"c\", res[2]);\n+\n+        str = \"a  b  c\";\n+        res = StringUtils.splitPreserveAllTokens(str,' ');\n+        assertEquals(5, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"\", res[1]);\n+        assertEquals(\"b\", res[2]);\n+        assertEquals(\"\", res[3]);\n+        assertEquals(\"c\", res[4]);\n+        \n+        str = \" a b c\";\n+        res = StringUtils.splitPreserveAllTokens(str,' ');\n+        assertEquals(4, res.length);\n+        assertEquals(\"\", res[0]);\n+        assertEquals(\"a\", res[1]);\n+        assertEquals(\"b\", res[2]);\n+        assertEquals(\"c\", res[3]);\n+\n+        str = \"  a b c\";\n+        res = StringUtils.splitPreserveAllTokens(str,' ');\n+        assertEquals(5, res.length);\n+        assertEquals(\"\", res[0]);\n+        assertEquals(\"\", res[1]);\n+        assertEquals(\"a\", res[2]);\n+        assertEquals(\"b\", res[3]);\n+        assertEquals(\"c\", res[4]);\n+\n+        str = \"a b c \";\n+        res = StringUtils.splitPreserveAllTokens(str,' ');\n+        assertEquals(4, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"b\", res[1]);\n+        assertEquals(\"c\", res[2]);\n+        assertEquals(\"\", res[3]);\n+\n+        str = \"a b c  \";\n+        res = StringUtils.splitPreserveAllTokens(str,' ');\n+        assertEquals(5, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"b\", res[1]);\n+        assertEquals(\"c\", res[2]);\n+        assertEquals(\"\", res[3]);\n+        assertEquals(\"\", res[3]);\n+\n+        // Match example in javadoc\n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"a\", \"\", \"b\", \"c\"};\n+          results = StringUtils.splitPreserveAllTokens(\"a..b.c\",'.');\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+    }\n+    \n+    public void testSplitPreserveAllTokens_StringString_StringStringInt() {\n+        assertEquals(null, StringUtils.splitPreserveAllTokens(null, \".\"));\n+        assertEquals(null, StringUtils.splitPreserveAllTokens(null, \".\", 3));\n+        \n+        assertEquals(0, StringUtils.splitPreserveAllTokens(\"\", \".\").length);\n+        assertEquals(0, StringUtils.splitPreserveAllTokens(\"\", \".\", 3).length);\n+        \n+        innerTestSplitPreserveAllTokens('.', \".\", ' ');\n+        innerTestSplitPreserveAllTokens('.', \".\", ',');\n+        innerTestSplitPreserveAllTokens('.', \".,\", 'x');\n+        for (int i = 0; i < WHITESPACE.length(); i++) {\n+            for (int j = 0; j < NON_WHITESPACE.length(); j++) {\n+                innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j));\n+                innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j));\n+            }\n+        }\n+\n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"ab\", \"de fg\"};\n+          results = StringUtils.splitPreserveAllTokens(\"ab de fg\", null, 2);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+\n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"ab\", \"  de fg\"};\n+          results = StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 2);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+        \n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"ab\", \"::de:fg\"};\n+          results = StringUtils.splitPreserveAllTokens(\"ab:::de:fg\", \":\", 2);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+        \n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"ab\", \"\", \" de fg\"};\n+          results = StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 3);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+        \n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"ab\", \"\", \"\", \"de fg\"};\n+          results = StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 4);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+\n+        {\n+          String[] expectedResults = {\"ab\", \"cd:ef\"};\n+          String[] results = null;\n+          results = StringUtils.splitPreserveAllTokens(\"ab:cd:ef\",\":\", 2);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+\n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"ab\", \":cd:ef\"};\n+          results = StringUtils.splitPreserveAllTokens(\"ab::cd:ef\",\":\", 2);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+\n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"ab\", \"\", \":cd:ef\"};\n+          results = StringUtils.splitPreserveAllTokens(\"ab:::cd:ef\",\":\", 3);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+\n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"ab\", \"\", \"\", \"cd:ef\"};\n+          results = StringUtils.splitPreserveAllTokens(\"ab:::cd:ef\",\":\", 4);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+\n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"\", \"ab\", \"\", \"\", \"cd:ef\"};\n+          results = StringUtils.splitPreserveAllTokens(\":ab:::cd:ef\",\":\", 5);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+        \n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"\", \"\", \"ab\", \"\", \"\", \"cd:ef\"};\n+          results = StringUtils.splitPreserveAllTokens(\"::ab:::cd:ef\",\":\", 6);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+        \n+    }\n+    \n+    private void innerTestSplitPreserveAllTokens(char separator, String sepStr, char noMatch) {\n+        String msg = \"Failed on separator hex(\" + Integer.toHexString(separator) +\n+            \"), noMatch hex(\" + Integer.toHexString(noMatch) + \"), sepStr(\" + sepStr + \")\";\n+        \n+        final String str = \"a\" + separator + \"b\" + separator + separator + noMatch + \"c\";\n+        String[] res;\n+        // (str, sepStr)\n+        res = StringUtils.splitPreserveAllTokens(str, sepStr);\n+        assertEquals(msg, 4, res.length);\n+        assertEquals(msg, \"a\", res[0]);\n+        assertEquals(msg, \"b\", res[1]);\n+        assertEquals(msg, \"\", res[2]);\n+        assertEquals(msg, noMatch + \"c\", res[3]);\n+        \n+        final String str2 = separator + \"a\" + separator;\n+        res = StringUtils.splitPreserveAllTokens(str2, sepStr);\n+        assertEquals(msg, 3, res.length);\n+        assertEquals(msg, \"\", res[0]);\n+        assertEquals(msg, \"a\", res[1]);\n+        assertEquals(msg, \"\", res[2]);\n+\n+        res = StringUtils.splitPreserveAllTokens(str, sepStr, -1);\n+        assertEquals(msg, 4, res.length);\n+        assertEquals(msg, \"a\", res[0]);\n+        assertEquals(msg, \"b\", res[1]);\n+        assertEquals(msg, \"\", res[2]);\n+        assertEquals(msg, noMatch + \"c\", res[3]);\n+        \n+        res = StringUtils.splitPreserveAllTokens(str, sepStr, 0);\n+        assertEquals(msg, 4, res.length);\n+        assertEquals(msg, \"a\", res[0]);\n+        assertEquals(msg, \"b\", res[1]);\n+        assertEquals(msg, \"\", res[2]);\n+        assertEquals(msg, noMatch + \"c\", res[3]);\n+        \n+        res = StringUtils.splitPreserveAllTokens(str, sepStr, 1);\n+        assertEquals(msg, 1, res.length);\n+        assertEquals(msg, str, res[0]);\n+        \n+        res = StringUtils.splitPreserveAllTokens(str, sepStr, 2);\n+        assertEquals(msg, 2, res.length);\n+        assertEquals(msg, \"a\", res[0]);\n+        assertEquals(msg, str.substring(2), res[1]);\n+    }\n+\n+    public void testSplitByCharacterType() {\n+        assertNull(StringUtils.splitByCharacterType(null));\n+        assertEquals(0, StringUtils.splitByCharacterType(\"\").length);\n+        \n+        assertTrue(ArrayUtils.isEquals(new String[] { \"ab\", \" \", \"de\", \" \",\n+        \"fg\" }, StringUtils.splitByCharacterType(\"ab de fg\")));\n+        \n+        assertTrue(ArrayUtils.isEquals(new String[] { \"ab\", \"   \", \"de\", \" \",\n+        \"fg\" }, StringUtils.splitByCharacterType(\"ab   de fg\")));\n+        \n+        assertTrue(ArrayUtils.isEquals(new String[] { \"ab\", \":\", \"cd\", \":\",\n+        \"ef\" }, StringUtils.splitByCharacterType(\"ab:cd:ef\")));\n+        \n+        assertTrue(ArrayUtils.isEquals(new String[] { \"number\", \"5\" },\n+                StringUtils.splitByCharacterType(\"number5\")));\n+        \n+        assertTrue(ArrayUtils.isEquals(new String[] { \"foo\", \"B\", \"ar\" },\n+                StringUtils.splitByCharacterType(\"fooBar\")));\n+        \n+        assertTrue(ArrayUtils.isEquals(new String[] { \"foo\", \"200\", \"B\", \"ar\" },\n+                StringUtils.splitByCharacterType(\"foo200Bar\")));\n+        \n+        assertTrue(ArrayUtils.isEquals(new String[] { \"ASFR\", \"ules\" },\n+                StringUtils.splitByCharacterType(\"ASFRules\")));\n+    }\n+    \n+    public void testSplitByCharacterTypeCamelCase() {\n+        assertNull(StringUtils.splitByCharacterTypeCamelCase(null));\n+        assertEquals(0, StringUtils.splitByCharacterTypeCamelCase(\"\").length);\n+\n+        assertTrue(ArrayUtils.isEquals(new String[] { \"ab\", \" \", \"de\", \" \",\n+                \"fg\" }, StringUtils.splitByCharacterTypeCamelCase(\"ab de fg\")));\n+\n+        assertTrue(ArrayUtils.isEquals(new String[] { \"ab\", \"   \", \"de\", \" \",\n+                \"fg\" }, StringUtils.splitByCharacterTypeCamelCase(\"ab   de fg\")));\n+\n+        assertTrue(ArrayUtils.isEquals(new String[] { \"ab\", \":\", \"cd\", \":\",\n+                \"ef\" }, StringUtils.splitByCharacterTypeCamelCase(\"ab:cd:ef\")));\n+        \n+        assertTrue(ArrayUtils.isEquals(new String[] { \"number\", \"5\" },\n+                StringUtils.splitByCharacterTypeCamelCase(\"number5\")));\n+\n+        assertTrue(ArrayUtils.isEquals(new String[] { \"foo\", \"Bar\" },\n+                StringUtils.splitByCharacterTypeCamelCase(\"fooBar\")));\n+\n+        assertTrue(ArrayUtils.isEquals(new String[] { \"foo\", \"200\", \"Bar\" },\n+                StringUtils.splitByCharacterTypeCamelCase(\"foo200Bar\")));\n+\n+        assertTrue(ArrayUtils.isEquals(new String[] { \"ASF\", \"Rules\" },\n+                StringUtils.splitByCharacterTypeCamelCase(\"ASFRules\")));\n+    }\n+\n+    public void testDeleteWhitespace_String() {\n+        assertEquals(null, StringUtils.deleteWhitespace(null));\n+        assertEquals(\"\", StringUtils.deleteWhitespace(\"\"));\n+        assertEquals(\"\", StringUtils.deleteWhitespace(\"  \\u000C  \\t\\t\\u001F\\n\\n \\u000B  \"));\n+        assertEquals(\"\", StringUtils.deleteWhitespace(StringUtilsTest.WHITESPACE));\n+        assertEquals(StringUtilsTest.NON_WHITESPACE, StringUtils.deleteWhitespace(StringUtilsTest.NON_WHITESPACE));\n+        // Note: u-2007 and u-000A both cause problems in the source code\n+        // it should ignore 2007 but delete 000A\n+        assertEquals(\"\\u00A0\\u202F\", StringUtils.deleteWhitespace(\"  \\u00A0  \\t\\t\\n\\n \\u202F  \"));\n+        assertEquals(\"\\u00A0\\u202F\", StringUtils.deleteWhitespace(\"\\u00A0\\u202F\"));\n+        assertEquals(\"test\", StringUtils.deleteWhitespace(\"\\u000Bt  \\t\\n\\u0009e\\rs\\n\\n   \\tt\"));\n+    }\n+\n+    public void testReplace_StringStringString() {\n+        assertEquals(null, StringUtils.replace(null, null, null));\n+        assertEquals(null, StringUtils.replace(null, null, \"any\"));\n+        assertEquals(null, StringUtils.replace(null, \"any\", null));\n+        assertEquals(null, StringUtils.replace(null, \"any\", \"any\"));\n+\n+        assertEquals(\"\", StringUtils.replace(\"\", null, null));\n+        assertEquals(\"\", StringUtils.replace(\"\", null, \"any\"));\n+        assertEquals(\"\", StringUtils.replace(\"\", \"any\", null));\n+        assertEquals(\"\", StringUtils.replace(\"\", \"any\", \"any\"));\n+\n+        assertEquals(\"FOO\", StringUtils.replace(\"FOO\", \"\", \"any\"));\n+        assertEquals(\"FOO\", StringUtils.replace(\"FOO\", null, \"any\"));\n+        assertEquals(\"FOO\", StringUtils.replace(\"FOO\", \"F\", null));\n+        assertEquals(\"FOO\", StringUtils.replace(\"FOO\", null, null));\n+\n+        assertEquals(\"\", StringUtils.replace(\"foofoofoo\", \"foo\", \"\"));\n+        assertEquals(\"barbarbar\", StringUtils.replace(\"foofoofoo\", \"foo\", \"bar\"));\n+        assertEquals(\"farfarfar\", StringUtils.replace(\"foofoofoo\", \"oo\", \"ar\"));\n+       }\n+    \n+    public void testReplace_StringStringStringInt() {\n+        assertEquals(null, StringUtils.replace(null, null, null, 2));\n+        assertEquals(null, StringUtils.replace(null, null, \"any\", 2));\n+        assertEquals(null, StringUtils.replace(null, \"any\", null, 2));\n+        assertEquals(null, StringUtils.replace(null, \"any\", \"any\", 2));\n+\n+        assertEquals(\"\", StringUtils.replace(\"\", null, null, 2));\n+        assertEquals(\"\", StringUtils.replace(\"\", null, \"any\", 2));\n+        assertEquals(\"\", StringUtils.replace(\"\", \"any\", null, 2));\n+        assertEquals(\"\", StringUtils.replace(\"\", \"any\", \"any\", 2));\n+        \n+        String str = new String(new char[] {'o', 'o', 'f', 'o', 'o'});\n+        assertSame(str, StringUtils.replace(str, \"x\", \"\", -1));\n+        \n+        assertEquals(\"f\", StringUtils.replace(\"oofoo\", \"o\", \"\", -1));\n+        assertEquals(\"oofoo\", StringUtils.replace(\"oofoo\", \"o\", \"\", 0));\n+        assertEquals(\"ofoo\", StringUtils.replace(\"oofoo\", \"o\", \"\", 1));\n+        assertEquals(\"foo\", StringUtils.replace(\"oofoo\", \"o\", \"\", 2));\n+        assertEquals(\"fo\", StringUtils.replace(\"oofoo\", \"o\", \"\", 3));\n+        assertEquals(\"f\", StringUtils.replace(\"oofoo\", \"o\", \"\", 4));\n+        \n+        assertEquals(\"f\", StringUtils.replace(\"oofoo\", \"o\", \"\", -5));\n+        assertEquals(\"f\", StringUtils.replace(\"oofoo\", \"o\", \"\", 1000));\n+    }\n+    \n+    public void testReplaceOnce_StringStringString() {\n+        assertEquals(null, StringUtils.replaceOnce(null, null, null));\n+        assertEquals(null, StringUtils.replaceOnce(null, null, \"any\"));\n+        assertEquals(null, StringUtils.replaceOnce(null, \"any\", null));\n+        assertEquals(null, StringUtils.replaceOnce(null, \"any\", \"any\"));\n+\n+        assertEquals(\"\", StringUtils.replaceOnce(\"\", null, null));\n+        assertEquals(\"\", StringUtils.replaceOnce(\"\", null, \"any\"));\n+        assertEquals(\"\", StringUtils.replaceOnce(\"\", \"any\", null));\n+        assertEquals(\"\", StringUtils.replaceOnce(\"\", \"any\", \"any\"));\n+\n+        assertEquals(\"FOO\", StringUtils.replaceOnce(\"FOO\", \"\", \"any\"));\n+        assertEquals(\"FOO\", StringUtils.replaceOnce(\"FOO\", null, \"any\"));\n+        assertEquals(\"FOO\", StringUtils.replaceOnce(\"FOO\", \"F\", null));\n+        assertEquals(\"FOO\", StringUtils.replaceOnce(\"FOO\", null, null));\n+\n+        assertEquals(\"foofoo\", StringUtils.replaceOnce(\"foofoofoo\", \"foo\", \"\"));\n+    }\n+\n+    /**\n+     * Test method for 'org.apache.commons.lang.StringUtils.replaceEach(String, String[], String[])'\n+     */\n+    public void testReplace_StringStringArrayStringArray() {\n+\n+        \n+        //JAVADOC TESTS START\n+        assertNull(StringUtils.replaceEach(null, new String[]{\"a\"}, new String[]{\"b\"}));\n+        assertEquals(StringUtils.replaceEach(\"\", new String[]{\"a\"}, new String[]{\"b\"}),\"\");\n+        assertEquals(StringUtils.replaceEach(\"aba\", null, null),\"aba\");\n+        assertEquals(StringUtils.replaceEach(\"aba\", new String[0], null),\"aba\");\n+        assertEquals(StringUtils.replaceEach(\"aba\", null, new String[0]),\"aba\");\n+        assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null),\"aba\");\n+\n+        assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}),\"b\");\n+        assertEquals(StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}),\"aba\");\n+        assertEquals(StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}),\"wcte\");\n+        assertEquals(StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}),\"dcte\");\n+        //JAVADOC TESTS END\n+\n+        assertEquals(\"bcc\", StringUtils.replaceEach(\"abc\", new String[]{\"a\", \"b\"}, new String[]{\"b\", \"c\"}));\n+        assertEquals(\"q651.506bera\", StringUtils.replaceEach(\"d216.102oren\",\n+            new String[]{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \n+                \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \n+                \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \n+                \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"},\n+            new String[]{\"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"a\", \n+                \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"N\", \"O\", \"P\", \"Q\", \n+                \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \n+                \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"5\", \"6\", \"7\", \"8\", \"9\", \"1\", \"2\", \"3\", \"4\"}));\n+    }\n+\n+    /**\n+     * Test method for 'org.apache.commons.lang.StringUtils.replaceEachRepeatedly(String, String[], String[])'\n+     */\n+    public void testReplace_StringStringArrayStringArrayBoolean() {\n+        //JAVADOC TESTS START\n+        assertNull(StringUtils.replaceEachRepeatedly(null, new String[]{\"a\"}, new String[]{\"b\"}));\n+        assertEquals(StringUtils.replaceEachRepeatedly(\"\", new String[]{\"a\"}, new String[]{\"b\"}),\"\");\n+        assertEquals(StringUtils.replaceEachRepeatedly(\"aba\", null, null),\"aba\");\n+        assertEquals(StringUtils.replaceEachRepeatedly(\"aba\", new String[0], null),\"aba\");\n+        assertEquals(StringUtils.replaceEachRepeatedly(\"aba\", null, new String[0]),\"aba\");\n+        assertEquals(StringUtils.replaceEachRepeatedly(\"aba\", new String[0], null),\"aba\");\n+\n+        assertEquals(StringUtils.replaceEachRepeatedly(\"aba\", new String[]{\"a\"}, new String[]{\"\"}),\"b\");\n+        assertEquals(StringUtils.replaceEachRepeatedly(\"aba\", new String[]{null}, new String[]{\"a\"}),\"aba\");\n+        assertEquals(StringUtils.replaceEachRepeatedly(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}),\"wcte\");\n+        assertEquals(StringUtils.replaceEachRepeatedly(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}),\"tcte\");\n+\n+        try {\n+            StringUtils.replaceEachRepeatedly(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"});\n+            fail(\"Should be a circular reference\");\n+        } catch (IllegalStateException e) {}\n+\n+        //JAVADOC TESTS END\n+\n+    }\n+    \n+    public void testReplaceChars_StringCharChar() {\n+        assertEquals(null, StringUtils.replaceChars(null, 'b', 'z'));\n+        assertEquals(\"\", StringUtils.replaceChars(\"\", 'b', 'z'));\n+        assertEquals(\"azcza\", StringUtils.replaceChars(\"abcba\", 'b', 'z'));\n+        assertEquals(\"abcba\", StringUtils.replaceChars(\"abcba\", 'x', 'z'));\n+    }\n+    \n+    public void testReplaceChars_StringStringString() {\n+        assertEquals(null, StringUtils.replaceChars(null, null, null));\n+        assertEquals(null, StringUtils.replaceChars(null, \"\", null));\n+        assertEquals(null, StringUtils.replaceChars(null, \"a\", null));\n+        assertEquals(null, StringUtils.replaceChars(null, null, \"\"));\n+        assertEquals(null, StringUtils.replaceChars(null, null, \"x\"));\n+        \n+        assertEquals(\"\", StringUtils.replaceChars(\"\", null, null));\n+        assertEquals(\"\", StringUtils.replaceChars(\"\", \"\", null));\n+        assertEquals(\"\", StringUtils.replaceChars(\"\", \"a\", null));\n+        assertEquals(\"\", StringUtils.replaceChars(\"\", null, \"\"));\n+        assertEquals(\"\", StringUtils.replaceChars(\"\", null, \"x\"));\n+\n+        assertEquals(\"abc\", StringUtils.replaceChars(\"abc\", null, null));\n+        assertEquals(\"abc\", StringUtils.replaceChars(\"abc\", null, \"\"));\n+        assertEquals(\"abc\", StringUtils.replaceChars(\"abc\", null, \"x\"));\n+        \n+        assertEquals(\"abc\", StringUtils.replaceChars(\"abc\", \"\", null));\n+        assertEquals(\"abc\", StringUtils.replaceChars(\"abc\", \"\", \"\"));\n+        assertEquals(\"abc\", StringUtils.replaceChars(\"abc\", \"\", \"x\"));\n+        \n+        assertEquals(\"ac\", StringUtils.replaceChars(\"abc\", \"b\", null));\n+        assertEquals(\"ac\", StringUtils.replaceChars(\"abc\", \"b\", \"\"));\n+        assertEquals(\"axc\", StringUtils.replaceChars(\"abc\", \"b\", \"x\"));\n+        \n+        assertEquals(\"ayzya\", StringUtils.replaceChars(\"abcba\", \"bc\", \"yz\"));\n+        assertEquals(\"ayya\", StringUtils.replaceChars(\"abcba\", \"bc\", \"y\"));\n+        assertEquals(\"ayzya\", StringUtils.replaceChars(\"abcba\", \"bc\", \"yzx\"));\n+        \n+        assertEquals(\"abcba\", StringUtils.replaceChars(\"abcba\", \"z\", \"w\"));\n+        assertSame(\"abcba\", StringUtils.replaceChars(\"abcba\", \"z\", \"w\"));\n+        \n+        // Javadoc examples:\n+        assertEquals(\"jelly\", StringUtils.replaceChars(\"hello\", \"ho\", \"jy\"));\n+        assertEquals(\"ayzya\", StringUtils.replaceChars(\"abcba\", \"bc\", \"yz\"));\n+        assertEquals(\"ayya\", StringUtils.replaceChars(\"abcba\", \"bc\", \"y\"));\n+        assertEquals(\"ayzya\", StringUtils.replaceChars(\"abcba\", \"bc\", \"yzx\"));\n+        \n+        // From http://issues.apache.org/bugzilla/show_bug.cgi?id=25454\n+        assertEquals(\"bcc\", StringUtils.replaceChars(\"abc\", \"ab\", \"bc\"));\n+        assertEquals(\"q651.506bera\", StringUtils.replaceChars(\"d216.102oren\",\n+            \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789\",\n+            \"nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM567891234\"));\n+    }\n+    \n+    public void testOverlay_StringStringIntInt() {\n+        assertEquals(null, StringUtils.overlay(null, null, 2, 4));\n+        assertEquals(null, StringUtils.overlay(null, null, -2, -4));\n+        \n+        assertEquals(\"\", StringUtils.overlay(\"\", null, 0, 0));\n+        assertEquals(\"\", StringUtils.overlay(\"\", \"\", 0, 0));\n+        assertEquals(\"zzzz\", StringUtils.overlay(\"\", \"zzzz\", 0, 0));\n+        assertEquals(\"zzzz\", StringUtils.overlay(\"\", \"zzzz\", 2, 4));\n+        assertEquals(\"zzzz\", StringUtils.overlay(\"\", \"zzzz\", -2, -4));\n+        \n+        assertEquals(\"abef\", StringUtils.overlay(\"abcdef\", null, 2, 4));\n+        assertEquals(\"abef\", StringUtils.overlay(\"abcdef\", null, 4, 2));\n+        assertEquals(\"abef\", StringUtils.overlay(\"abcdef\", \"\", 2, 4));\n+        assertEquals(\"abef\", StringUtils.overlay(\"abcdef\", \"\", 4, 2));\n+        assertEquals(\"abzzzzef\", StringUtils.overlay(\"abcdef\", \"zzzz\", 2, 4));\n+        assertEquals(\"abzzzzef\", StringUtils.overlay(\"abcdef\", \"zzzz\", 4, 2));\n+        \n+        assertEquals(\"zzzzef\", StringUtils.overlay(\"abcdef\", \"zzzz\", -1, 4));\n+        assertEquals(\"zzzzef\", StringUtils.overlay(\"abcdef\", \"zzzz\", 4, -1));\n+        assertEquals(\"zzzzabcdef\", StringUtils.overlay(\"abcdef\", \"zzzz\", -2, -1));\n+        assertEquals(\"zzzzabcdef\", StringUtils.overlay(\"abcdef\", \"zzzz\", -1, -2));\n+        assertEquals(\"abcdzzzz\", StringUtils.overlay(\"abcdef\", \"zzzz\", 4, 10));\n+        assertEquals(\"abcdzzzz\", StringUtils.overlay(\"abcdef\", \"zzzz\", 10, 4));\n+        assertEquals(\"abcdefzzzz\", StringUtils.overlay(\"abcdef\", \"zzzz\", 8, 10));\n+        assertEquals(\"abcdefzzzz\", StringUtils.overlay(\"abcdef\", \"zzzz\", 10, 8));\n+    }\n+\n+    public void testRepeat_StringInt() {\n+        assertEquals(null, StringUtils.repeat(null, 2));\n+        assertEquals(\"\", StringUtils.repeat(\"ab\", 0));\n+        assertEquals(\"\", StringUtils.repeat(\"\", 3));\n+        assertEquals(\"aaa\", StringUtils.repeat(\"a\", 3));\n+        assertEquals(\"ababab\", StringUtils.repeat(\"ab\", 3));\n+        assertEquals(\"abcabcabc\", StringUtils.repeat(\"abc\", 3));\n+        String str = StringUtils.repeat(\"a\", 10000);  // bigger than pad limit\n+        assertEquals(10000, str.length());\n+        assertEquals(true, StringUtils.containsOnly(str, new char[] {'a'}));\n+    }\n+\n+    public void testRepeat_StringStringInt() {\n+        assertEquals(null, StringUtils.repeat(null, null, 2));\n+        assertEquals(null, StringUtils.repeat(null, \"x\", 2));\n+        assertEquals(\"\", StringUtils.repeat(\"\", null, 2));\n+\n+        assertEquals(\"\", StringUtils.repeat(\"ab\", \"\", 0));\n+        assertEquals(\"\", StringUtils.repeat(\"\", \"\", 2));\n+\n+        assertEquals(\"xx\", StringUtils.repeat(\"\", \"x\", 3));\n+\n+        assertEquals(\"?, ?, ?\", StringUtils.repeat(\"?\", \", \", 3));\n+    }\n+\n+    public void testChop() {\n+\n+        String[][] chopCases = {\n+            { FOO_UNCAP + \"\\r\\n\", FOO_UNCAP } ,\n+            { FOO_UNCAP + \"\\n\" , FOO_UNCAP } ,\n+            { FOO_UNCAP + \"\\r\", FOO_UNCAP },\n+            { FOO_UNCAP + \" \\r\", FOO_UNCAP + \" \" },\n+            { \"foo\", \"fo\"},\n+            { \"foo\\nfoo\", \"foo\\nfo\" },\n+            { \"\\n\", \"\" },\n+            { \"\\r\", \"\" },\n+            { \"\\r\\n\", \"\" },\n+            { null, null },\n+            { \"\", \"\" },\n+            { \"a\", \"\" },\n+        };\n+        for (int i = 0; i < chopCases.length; i++) {\n+            String original = chopCases[i][0];\n+            String expectedResult = chopCases[i][1];\n+            assertEquals(\"chop(String) failed\",\n+                    expectedResult, StringUtils.chop(original));\n+        }\n+    }\n+\n+    public void testChomp() {\n+\n+        String[][] chompCases = {\n+            { FOO_UNCAP + \"\\r\\n\", FOO_UNCAP },\n+            { FOO_UNCAP + \"\\n\" , FOO_UNCAP },\n+            { FOO_UNCAP + \"\\r\", FOO_UNCAP },\n+            { FOO_UNCAP + \" \\r\", FOO_UNCAP + \" \" },\n+            { FOO_UNCAP, FOO_UNCAP },\n+            { FOO_UNCAP + \"\\n\\n\", FOO_UNCAP + \"\\n\"},\n+            { FOO_UNCAP + \"\\r\\n\\r\\n\", FOO_UNCAP + \"\\r\\n\" },\n+            { \"foo\\nfoo\", \"foo\\nfoo\" },\n+            { \"foo\\n\\rfoo\", \"foo\\n\\rfoo\" },\n+            { \"\\n\", \"\" },\n+            { \"\\r\", \"\" },\n+            { \"a\", \"a\" },\n+            { \"\\r\\n\", \"\" },\n+            { \"\", \"\" },\n+            { null, null },\n+            { FOO_UNCAP + \"\\n\\r\", FOO_UNCAP + \"\\n\"}\n+        };\n+        for (int i = 0; i < chompCases.length; i++) {\n+            String original = chompCases[i][0];\n+            String expectedResult = chompCases[i][1];\n+            assertEquals(\"chomp(String) failed\",\n+                    expectedResult, StringUtils.chomp(original));\n+        }\n+\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"foo\", StringUtils.chomp(\"foobar\", \"bar\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"foobar\", StringUtils.chomp(\"foobar\", \"baz\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"foo\", StringUtils.chomp(\"foo\", \"foooo\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"foobar\", StringUtils.chomp(\"foobar\", \"\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"foobar\", StringUtils.chomp(\"foobar\", null));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"\", StringUtils.chomp(\"\", \"foo\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"\", StringUtils.chomp(\"\", null));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"\", StringUtils.chomp(\"\", \"\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                null, StringUtils.chomp(null, \"foo\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                null, StringUtils.chomp(null, null));\n+        assertEquals(\"chomp(String, String) failed\",\n+                null, StringUtils.chomp(null, \"\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"\", StringUtils.chomp(\"foo\", \"foo\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \" \", StringUtils.chomp(\" foo\", \"foo\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"foo \", StringUtils.chomp(\"foo \", \"foo\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testRightPad_StringInt() {\n+        assertEquals(null, StringUtils.rightPad(null, 5));\n+        assertEquals(\"     \", StringUtils.rightPad(\"\", 5));\n+        assertEquals(\"abc  \", StringUtils.rightPad(\"abc\", 5));\n+        assertEquals(\"abc\", StringUtils.rightPad(\"abc\", 2));\n+        assertEquals(\"abc\", StringUtils.rightPad(\"abc\", -1));\n+    }\n+\n+    public void testRightPad_StringIntChar() {\n+        assertEquals(null, StringUtils.rightPad(null, 5, ' '));\n+        assertEquals(\"     \", StringUtils.rightPad(\"\", 5, ' '));\n+        assertEquals(\"abc  \", StringUtils.rightPad(\"abc\", 5, ' '));\n+        assertEquals(\"abc\", StringUtils.rightPad(\"abc\", 2, ' '));\n+        assertEquals(\"abc\", StringUtils.rightPad(\"abc\", -1, ' '));\n+        assertEquals(\"abcxx\", StringUtils.rightPad(\"abc\", 5, 'x'));\n+        String str = StringUtils.rightPad(\"aaa\", 10000, 'a');  // bigger than pad length\n+        assertEquals(10000, str.length());\n+        assertEquals(true, StringUtils.containsOnly(str, new char[] {'a'}));\n+    }\n+\n+    public void testRightPad_StringIntString() {\n+        assertEquals(null, StringUtils.rightPad(null, 5, \"-+\"));\n+        assertEquals(\"     \", StringUtils.rightPad(\"\", 5, \" \"));\n+        assertEquals(null, StringUtils.rightPad(null, 8, null));\n+        assertEquals(\"abc-+-+\", StringUtils.rightPad(\"abc\", 7, \"-+\"));\n+        assertEquals(\"abc-+~\", StringUtils.rightPad(\"abc\", 6, \"-+~\"));\n+        assertEquals(\"abc-+\", StringUtils.rightPad(\"abc\", 5, \"-+~\"));\n+        assertEquals(\"abc\", StringUtils.rightPad(\"abc\", 2, \" \"));\n+        assertEquals(\"abc\", StringUtils.rightPad(\"abc\", -1, \" \"));\n+        assertEquals(\"abc  \", StringUtils.rightPad(\"abc\", 5, null));\n+        assertEquals(\"abc  \", StringUtils.rightPad(\"abc\", 5, \"\"));\n+    }\n+        \n+    //-----------------------------------------------------------------------\n+    public void testLeftPad_StringInt() {\n+        assertEquals(null, StringUtils.leftPad(null, 5));\n+        assertEquals(\"     \", StringUtils.leftPad(\"\", 5));\n+        assertEquals(\"  abc\", StringUtils.leftPad(\"abc\", 5));\n+        assertEquals(\"abc\", StringUtils.leftPad(\"abc\", 2));\n+    }\n+        \n+    public void testLeftPad_StringIntChar() {\n+        assertEquals(null, StringUtils.leftPad(null, 5, ' '));\n+        assertEquals(\"     \", StringUtils.leftPad(\"\", 5, ' '));\n+        assertEquals(\"  abc\", StringUtils.leftPad(\"abc\", 5, ' '));\n+        assertEquals(\"xxabc\", StringUtils.leftPad(\"abc\", 5, 'x'));\n+        assertEquals(\"\\uffff\\uffffabc\", StringUtils.leftPad(\"abc\", 5, '\\uffff'));\n+        assertEquals(\"abc\", StringUtils.leftPad(\"abc\", 2, ' '));\n+        String str = StringUtils.leftPad(\"aaa\", 10000, 'a');  // bigger than pad length\n+        assertEquals(10000, str.length());\n+        assertEquals(true, StringUtils.containsOnly(str, new char[] {'a'}));\n+    }\n+        \n+    public void testLeftPad_StringIntString() {\n+        assertEquals(null, StringUtils.leftPad(null, 5, \"-+\"));\n+        assertEquals(null, StringUtils.leftPad(null, 5, null));\n+        assertEquals(\"     \", StringUtils.leftPad(\"\", 5, \" \"));\n+        assertEquals(\"-+-+abc\", StringUtils.leftPad(\"abc\", 7, \"-+\"));\n+        assertEquals(\"-+~abc\", StringUtils.leftPad(\"abc\", 6, \"-+~\"));\n+        assertEquals(\"-+abc\", StringUtils.leftPad(\"abc\", 5, \"-+~\"));\n+        assertEquals(\"abc\", StringUtils.leftPad(\"abc\", 2, \" \"));\n+        assertEquals(\"abc\", StringUtils.leftPad(\"abc\", -1, \" \"));\n+        assertEquals(\"  abc\", StringUtils.leftPad(\"abc\", 5, null));\n+        assertEquals(\"  abc\", StringUtils.leftPad(\"abc\", 5, \"\"));\n+    }\n+\n+    public void testLength() {\n+        assertEquals(0, StringUtils.length(null));\n+        assertEquals(0, StringUtils.length(\"\"));\n+        assertEquals(0, StringUtils.length(StringUtils.EMPTY));\n+        assertEquals(1, StringUtils.length(\"A\"));\n+        assertEquals(1, StringUtils.length(\" \"));\n+        assertEquals(8, StringUtils.length(\"ABCDEFGH\"));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testCenter_StringInt() {\n+        assertEquals(null, StringUtils.center(null, -1));\n+        assertEquals(null, StringUtils.center(null, 4));\n+        assertEquals(\"    \", StringUtils.center(\"\", 4));\n+        assertEquals(\"ab\", StringUtils.center(\"ab\", 0));\n+        assertEquals(\"ab\", StringUtils.center(\"ab\", -1));\n+        assertEquals(\"ab\", StringUtils.center(\"ab\", 1));\n+        assertEquals(\"    \", StringUtils.center(\"\", 4));\n+        assertEquals(\" ab \", StringUtils.center(\"ab\", 4));\n+        assertEquals(\"abcd\", StringUtils.center(\"abcd\", 2));\n+        assertEquals(\" a  \", StringUtils.center(\"a\", 4));\n+        assertEquals(\"  a  \", StringUtils.center(\"a\", 5));\n+    }\n+    \n+    public void testCenter_StringIntChar() {\n+        assertEquals(null, StringUtils.center(null, -1, ' '));\n+        assertEquals(null, StringUtils.center(null, 4, ' '));\n+        assertEquals(\"    \", StringUtils.center(\"\", 4, ' '));\n+        assertEquals(\"ab\", StringUtils.center(\"ab\", 0, ' '));\n+        assertEquals(\"ab\", StringUtils.center(\"ab\", -1, ' '));\n+        assertEquals(\"ab\", StringUtils.center(\"ab\", 1, ' '));\n+        assertEquals(\"    \", StringUtils.center(\"\", 4, ' '));\n+        assertEquals(\" ab \", StringUtils.center(\"ab\", 4, ' '));\n+        assertEquals(\"abcd\", StringUtils.center(\"abcd\", 2, ' '));\n+        assertEquals(\" a  \", StringUtils.center(\"a\", 4, ' '));\n+        assertEquals(\"  a  \", StringUtils.center(\"a\", 5, ' '));\n+        assertEquals(\"xxaxx\", StringUtils.center(\"a\", 5, 'x'));\n+    }\n+    \n+    public void testCenter_StringIntString() {\n+        assertEquals(null, StringUtils.center(null, 4, null));\n+        assertEquals(null, StringUtils.center(null, -1, \" \"));\n+        assertEquals(null, StringUtils.center(null, 4, \" \"));\n+        assertEquals(\"    \", StringUtils.center(\"\", 4, \" \"));\n+        assertEquals(\"ab\", StringUtils.center(\"ab\", 0, \" \"));\n+        assertEquals(\"ab\", StringUtils.center(\"ab\", -1, \" \"));\n+        assertEquals(\"ab\", StringUtils.center(\"ab\", 1, \" \"));\n+        assertEquals(\"    \", StringUtils.center(\"\", 4, \" \"));\n+        assertEquals(\" ab \", StringUtils.center(\"ab\", 4, \" \"));\n+        assertEquals(\"abcd\", StringUtils.center(\"abcd\", 2, \" \"));\n+        assertEquals(\" a  \", StringUtils.center(\"a\", 4, \" \"));\n+        assertEquals(\"yayz\", StringUtils.center(\"a\", 4, \"yz\"));\n+        assertEquals(\"yzyayzy\", StringUtils.center(\"a\", 7, \"yz\"));\n+        assertEquals(\"  abc  \", StringUtils.center(\"abc\", 7, null));\n+        assertEquals(\"  abc  \", StringUtils.center(\"abc\", 7, \"\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReverse_String() {\n+        assertEquals(null, StringUtils.reverse(null) );\n+        assertEquals(\"\", StringUtils.reverse(\"\") );\n+        assertEquals(\"sdrawkcab\", StringUtils.reverse(\"backwards\") );\n+    }\n+        \n+    public void testReverseDelimited_StringChar() {\n+        assertEquals(null, StringUtils.reverseDelimited(null, '.') );\n+        assertEquals(\"\", StringUtils.reverseDelimited(\"\", '.') );\n+        assertEquals(\"c.b.a\", StringUtils.reverseDelimited(\"a.b.c\", '.') );\n+        assertEquals(\"a b c\", StringUtils.reverseDelimited(\"a b c\", '.') );\n+        assertEquals(\"\", StringUtils.reverseDelimited(\"\", '.') );\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDefault_String() {\n+        assertEquals(\"\", StringUtils.defaultString(null));\n+        assertEquals(\"\", StringUtils.defaultString(\"\"));\n+        assertEquals(\"abc\", StringUtils.defaultString(\"abc\"));\n+    }\n+\n+    public void testDefault_StringString() {\n+        assertEquals(\"NULL\", StringUtils.defaultString(null, \"NULL\"));\n+        assertEquals(\"\", StringUtils.defaultString(\"\", \"NULL\"));\n+        assertEquals(\"abc\", StringUtils.defaultString(\"abc\", \"NULL\"));\n+    }\n+\n+    public void testDefaultIfEmpty_StringString() {\n+        assertEquals(\"NULL\", StringUtils.defaultIfEmpty(null, \"NULL\"));\n+        assertEquals(\"NULL\", StringUtils.defaultIfEmpty(\"\", \"NULL\"));\n+        assertEquals(\"abc\", StringUtils.defaultIfEmpty(\"abc\", \"NULL\"));\n+        assertNull(StringUtils.defaultIfEmpty(\"\", null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAbbreviate_StringInt() {\n+        assertEquals(null, StringUtils.abbreviate(null, 10));\n+        assertEquals(\"\", StringUtils.abbreviate(\"\", 10));\n+        assertEquals(\"short\", StringUtils.abbreviate(\"short\", 10));\n+        assertEquals(\"Now is ...\", StringUtils.abbreviate(\"Now is the time for all good men to come to the aid of their party.\", 10));\n+\n+        String raspberry = \"raspberry peach\";\n+        assertEquals(\"raspberry p...\", StringUtils.abbreviate(raspberry, 14));\n+        assertEquals(\"raspberry peach\", StringUtils.abbreviate(\"raspberry peach\", 15));\n+        assertEquals(\"raspberry peach\", StringUtils.abbreviate(\"raspberry peach\", 16));\n+        assertEquals(\"abc...\", StringUtils.abbreviate(\"abcdefg\", 6));\n+        assertEquals(\"abcdefg\", StringUtils.abbreviate(\"abcdefg\", 7));\n+        assertEquals(\"abcdefg\", StringUtils.abbreviate(\"abcdefg\", 8));\n+        assertEquals(\"a...\", StringUtils.abbreviate(\"abcdefg\", 4));\n+        assertEquals(\"\", StringUtils.abbreviate(\"\", 4));\n+        \n+        try {\n+            @SuppressWarnings(\"unused\")\n+            String res = StringUtils.abbreviate(\"abc\", 3);\n+            fail(\"StringUtils.abbreviate expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+                // empty\n+        }              \n+    }\n+    \n+    public void testAbbreviate_StringIntInt() {\n+        assertEquals(null, StringUtils.abbreviate(null, 10, 12));\n+        assertEquals(\"\", StringUtils.abbreviate(\"\", 0, 10));\n+        assertEquals(\"\", StringUtils.abbreviate(\"\", 2, 10));\n+        \n+        try {\n+            @SuppressWarnings(\"unused\")\n+            String res = StringUtils.abbreviate(\"abcdefghij\", 0, 3);\n+            fail(\"StringUtils.abbreviate expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+                // empty\n+        }      \n+        try {\n+            @SuppressWarnings(\"unused\")\n+            String res = StringUtils.abbreviate(\"abcdefghij\", 5, 6);\n+            fail(\"StringUtils.abbreviate expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+                // empty\n+        }      \n+        \n+\n+        String raspberry = \"raspberry peach\";\n+        assertEquals(\"raspberry peach\", StringUtils.abbreviate(raspberry, 11, 15));\n+\n+        assertEquals(null, StringUtils.abbreviate(null, 7, 14));\n+        assertAbbreviateWithOffset(\"abcdefg...\", -1, 10);\n+        assertAbbreviateWithOffset(\"abcdefg...\", 0, 10);\n+        assertAbbreviateWithOffset(\"abcdefg...\", 1, 10);\n+        assertAbbreviateWithOffset(\"abcdefg...\", 2, 10);\n+        assertAbbreviateWithOffset(\"abcdefg...\", 3, 10);\n+        assertAbbreviateWithOffset(\"abcdefg...\", 4, 10);\n+        assertAbbreviateWithOffset(\"...fghi...\", 5, 10);\n+        assertAbbreviateWithOffset(\"...ghij...\", 6, 10);\n+        assertAbbreviateWithOffset(\"...hijk...\", 7, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", 8, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", 9, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", 10, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", 10, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", 11, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", 12, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", 13, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", 14, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", 15, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", 16, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", Integer.MAX_VALUE, 10);\n+    }\n+\n+    private void assertAbbreviateWithOffset(String expected, int offset, int maxWidth) {\n+        String abcdefghijklmno = \"abcdefghijklmno\";\n+        String message = \"abbreviate(String,int,int) failed\";\n+        String actual = StringUtils.abbreviate(abcdefghijklmno, offset, maxWidth);\n+        if (offset >= 0 && offset < abcdefghijklmno.length()) {\n+            assertTrue(message + \" -- should contain offset character\",\n+                    actual.indexOf((char)('a'+offset)) != -1);\n+        }\n+        assertTrue(message + \" -- should not be greater than maxWidth\",\n+                actual.length() <= maxWidth);\n+        assertEquals(message, expected, actual);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDifference_StringString() {\n+        assertEquals(null, StringUtils.difference(null, null));\n+        assertEquals(\"\", StringUtils.difference(\"\", \"\"));\n+        assertEquals(\"abc\", StringUtils.difference(\"\", \"abc\"));\n+        assertEquals(\"\", StringUtils.difference(\"abc\", \"\"));\n+        assertEquals(\"i am a robot\", StringUtils.difference(null, \"i am a robot\"));\n+        assertEquals(\"i am a machine\", StringUtils.difference(\"i am a machine\", null));\n+        assertEquals(\"robot\", StringUtils.difference(\"i am a machine\", \"i am a robot\"));\n+        assertEquals(\"\", StringUtils.difference(\"abc\", \"abc\"));\n+        assertEquals(\"you are a robot\", StringUtils.difference(\"i am a robot\", \"you are a robot\"));\n+    }\n+\n+    public void testDifferenceAt_StringString() {\n+        assertEquals(-1, StringUtils.indexOfDifference(null, null));\n+        assertEquals(0, StringUtils.indexOfDifference(null, \"i am a robot\"));\n+        assertEquals(-1, StringUtils.indexOfDifference(\"\", \"\"));\n+        assertEquals(0, StringUtils.indexOfDifference(\"\", \"abc\"));\n+        assertEquals(0, StringUtils.indexOfDifference(\"abc\", \"\"));\n+        assertEquals(0, StringUtils.indexOfDifference(\"i am a machine\", null));\n+        assertEquals(7, StringUtils.indexOfDifference(\"i am a machine\", \"i am a robot\"));\n+        assertEquals(-1, StringUtils.indexOfDifference(\"foo\", \"foo\"));\n+        assertEquals(0, StringUtils.indexOfDifference(\"i am a robot\", \"you are a robot\"));\n+        //System.out.println(\"indexOfDiff: \" + StringUtils.indexOfDifference(\"i am a robot\", \"not machine\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetLevenshteinDistance_StringString() {\n+        assertEquals(0, StringUtils.getLevenshteinDistance(\"\", \"\") );\n+        assertEquals(1, StringUtils.getLevenshteinDistance(\"\", \"a\") );\n+        assertEquals(7, StringUtils.getLevenshteinDistance(\"aaapppp\", \"\") );\n+        assertEquals(1, StringUtils.getLevenshteinDistance(\"frog\", \"fog\") );\n+        assertEquals(3, StringUtils.getLevenshteinDistance(\"fly\", \"ant\") );\n+        assertEquals(7, StringUtils.getLevenshteinDistance(\"elephant\", \"hippo\") );\n+        assertEquals(7, StringUtils.getLevenshteinDistance(\"hippo\", \"elephant\") );\n+        assertEquals(8, StringUtils.getLevenshteinDistance(\"hippo\", \"zzzzzzzz\") );\n+        assertEquals(8, StringUtils.getLevenshteinDistance(\"zzzzzzzz\", \"hippo\") );\n+        assertEquals(1, StringUtils.getLevenshteinDistance(\"hello\", \"hallo\") );\n+        try {\n+            @SuppressWarnings(\"unused\")\n+            int d = StringUtils.getLevenshteinDistance(\"a\", null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // empty\n+        }\n+        try {\n+            @SuppressWarnings(\"unused\")\n+            int d = StringUtils.getLevenshteinDistance(null, \"a\");\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // empty\n+        }\n+    }\n+\n+    /**\n+     * A sanity check for {@link StringUtils#EMPTY}.\n+     */\n+    public void testEMPTY() {\n+        assertNotNull(StringUtils.EMPTY);\n+        assertEquals(\"\", StringUtils.EMPTY);\n+        assertEquals(0, StringUtils.EMPTY.length());\n+    }\n+\n+    /**\n+     * Test for {@link StringUtils#isAllLowerCase(String)}.\n+     */\n+    public void testIsAllLowerCase() {\n+        assertFalse(StringUtils.isAllLowerCase(null));\n+        assertFalse(StringUtils.isAllLowerCase(StringUtils.EMPTY));\n+        assertTrue(StringUtils.isAllLowerCase(\"abc\"));\n+        assertFalse(StringUtils.isAllLowerCase(\"abc \"));\n+        assertFalse(StringUtils.isAllLowerCase(\"abC\"));\n+    }\n+\n+    /**\n+     * Test for {@link StringUtils#isAllUpperCase(String)}.\n+     */\n+    public void testIsAllUpperCase() {\n+        assertFalse(StringUtils.isAllUpperCase(null));\n+        assertFalse(StringUtils.isAllUpperCase(StringUtils.EMPTY));\n+        assertTrue(StringUtils.isAllUpperCase(\"ABC\"));\n+        assertFalse(StringUtils.isAllUpperCase(\"ABC \"));\n+        assertFalse(StringUtils.isAllUpperCase(\"aBC\"));\n+    }\n+\n+    public void testRemoveStart() {\n+        // StringUtils.removeStart(\"\", *)        = \"\"\n+        assertNull(StringUtils.removeStart(null, null));\n+        assertNull(StringUtils.removeStart(null, \"\"));\n+        assertNull(StringUtils.removeStart(null, \"a\"));\n+        \n+        // StringUtils.removeStart(*, null)      = *\n+        assertEquals(StringUtils.removeStart(\"\", null), \"\");\n+        assertEquals(StringUtils.removeStart(\"\", \"\"), \"\");\n+        assertEquals(StringUtils.removeStart(\"\", \"a\"), \"\");\n+        \n+        // All others:\n+        assertEquals(StringUtils.removeStart(\"www.domain.com\", \"www.\"), \"domain.com\");\n+        assertEquals(StringUtils.removeStart(\"domain.com\", \"www.\"), \"domain.com\");\n+        assertEquals(StringUtils.removeStart(\"domain.com\", \"\"), \"domain.com\");        \n+        assertEquals(StringUtils.removeStart(\"domain.com\", null), \"domain.com\");        \n+    }\n+    \n+    public void testRemoveStartIgnoreCase() {\n+        // StringUtils.removeStart(\"\", *)        = \"\"\n+        assertNull(\"removeStartIgnoreCase(null, null)\", StringUtils.removeStartIgnoreCase(null, null));\n+        assertNull(\"removeStartIgnoreCase(null, \\\"\\\")\", StringUtils.removeStartIgnoreCase(null, \"\"));\n+        assertNull(\"removeStartIgnoreCase(null, \\\"a\\\")\", StringUtils.removeStartIgnoreCase(null, \"a\"));\n+        \n+        // StringUtils.removeStart(*, null)      = *\n+        assertEquals(\"removeStartIgnoreCase(\\\"\\\", null)\", StringUtils.removeStartIgnoreCase(\"\", null), \"\");\n+        assertEquals(\"removeStartIgnoreCase(\\\"\\\", \\\"\\\")\", StringUtils.removeStartIgnoreCase(\"\", \"\"), \"\");\n+        assertEquals(\"removeStartIgnoreCase(\\\"\\\", \\\"a\\\")\", StringUtils.removeStartIgnoreCase(\"\", \"a\"), \"\");\n+        \n+        // All others:\n+        assertEquals(\"removeStartIgnoreCase(\\\"www.domain.com\\\", \\\"www.\\\")\", StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"www.\"), \"domain.com\");\n+        assertEquals(\"removeStartIgnoreCase(\\\"domain.com\\\", \\\"www.\\\")\", StringUtils.removeStartIgnoreCase(\"domain.com\", \"www.\"), \"domain.com\");\n+        assertEquals(\"removeStartIgnoreCase(\\\"domain.com\\\", \\\"\\\")\", StringUtils.removeStartIgnoreCase(\"domain.com\", \"\"), \"domain.com\");        \n+        assertEquals(\"removeStartIgnoreCase(\\\"domain.com\\\", null)\", StringUtils.removeStartIgnoreCase(\"domain.com\", null), \"domain.com\");        \n+        \n+        // Case insensitive:\n+        assertEquals(\"removeStartIgnoreCase(\\\"www.domain.com\\\", \\\"WWW.\\\")\", StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"WWW.\"), \"domain.com\");\n+    }\n+\n+    public void testRemoveEnd() {\n+        // StringUtils.removeEnd(\"\", *)        = \"\"\n+        assertNull(StringUtils.removeEnd(null, null));\n+        assertNull(StringUtils.removeEnd(null, \"\"));\n+        assertNull(StringUtils.removeEnd(null, \"a\"));\n+        \n+        // StringUtils.removeEnd(*, null)      = *\n+        assertEquals(StringUtils.removeEnd(\"\", null), \"\");\n+        assertEquals(StringUtils.removeEnd(\"\", \"\"), \"\");\n+        assertEquals(StringUtils.removeEnd(\"\", \"a\"), \"\");\n+        \n+        // All others:\n+        assertEquals(StringUtils.removeEnd(\"www.domain.com.\", \".com\"), \"www.domain.com.\");\n+        assertEquals(StringUtils.removeEnd(\"www.domain.com\", \".com\"), \"www.domain\");\n+        assertEquals(StringUtils.removeEnd(\"www.domain\", \".com\"), \"www.domain\");\n+        assertEquals(StringUtils.removeEnd(\"domain.com\", \"\"), \"domain.com\");   \n+        assertEquals(StringUtils.removeEnd(\"domain.com\", null), \"domain.com\");   \n+    }\n+\n+    public void testRemoveEndIgnoreCase() {\n+        // StringUtils.removeEndIgnoreCase(\"\", *)        = \"\"\n+        assertNull(\"removeEndIgnoreCase(null, null)\", StringUtils.removeEndIgnoreCase(null, null));\n+        assertNull(\"removeEndIgnoreCase(null, \\\"\\\")\", StringUtils.removeEndIgnoreCase(null, \"\"));\n+        assertNull(\"removeEndIgnoreCase(null, \\\"a\\\")\", StringUtils.removeEndIgnoreCase(null, \"a\"));\n+        \n+        // StringUtils.removeEnd(*, null)      = *\n+        assertEquals(\"removeEndIgnoreCase(\\\"\\\", null)\", StringUtils.removeEndIgnoreCase(\"\", null), \"\");\n+        assertEquals(\"removeEndIgnoreCase(\\\"\\\", \\\"\\\")\", StringUtils.removeEndIgnoreCase(\"\", \"\"), \"\");\n+        assertEquals(\"removeEndIgnoreCase(\\\"\\\", \\\"a\\\")\", StringUtils.removeEndIgnoreCase(\"\", \"a\"), \"\");\n+        \n+        // All others:\n+        assertEquals(\"removeEndIgnoreCase(\\\"www.domain.com.\\\", \\\".com\\\")\", StringUtils.removeEndIgnoreCase(\"www.domain.com.\", \".com\"), \"www.domain.com.\");\n+        assertEquals(\"removeEndIgnoreCase(\\\"www.domain.com\\\", \\\".com\\\")\", StringUtils.removeEndIgnoreCase(\"www.domain.com\", \".com\"), \"www.domain\");\n+        assertEquals(\"removeEndIgnoreCase(\\\"www.domain\\\", \\\".com\\\")\", StringUtils.removeEndIgnoreCase(\"www.domain\", \".com\"), \"www.domain\");\n+        assertEquals(\"removeEndIgnoreCase(\\\"domain.com\\\", \\\"\\\")\", StringUtils.removeEndIgnoreCase(\"domain.com\", \"\"), \"domain.com\");   \n+        assertEquals(\"removeEndIgnoreCase(\\\"domain.com\\\", null)\", StringUtils.removeEndIgnoreCase(\"domain.com\", null), \"domain.com\");   \n+\n+        // Case insensitive:\n+        assertEquals(\"removeEndIgnoreCase(\\\"www.domain.com\\\", \\\".com\\\")\", StringUtils.removeEndIgnoreCase(\"www.domain.com\", \".COM\"), \"www.domain\");\n+    }\n+\n+    public void testRemove_String() {\n+        // StringUtils.remove(null, *)        = null\n+        assertEquals(null, StringUtils.remove(null, null));\n+        assertEquals(null, StringUtils.remove(null, \"\"));\n+        assertEquals(null, StringUtils.remove(null, \"a\"));\n+        \n+        // StringUtils.remove(\"\", *)          = \"\"\n+        assertEquals(\"\", StringUtils.remove(\"\", null));\n+        assertEquals(\"\", StringUtils.remove(\"\", \"\"));\n+        assertEquals(\"\", StringUtils.remove(\"\", \"a\"));\n+        \n+        // StringUtils.remove(*, null)        = *\n+        assertEquals(null, StringUtils.remove(null, null));\n+        assertEquals(\"\", StringUtils.remove(\"\", null));\n+        assertEquals(\"a\", StringUtils.remove(\"a\", null));\n+        \n+        // StringUtils.remove(*, \"\")          = *\n+        assertEquals(null, StringUtils.remove(null, \"\"));\n+        assertEquals(\"\", StringUtils.remove(\"\", \"\"));\n+        assertEquals(\"a\", StringUtils.remove(\"a\", \"\"));\n+        \n+        // StringUtils.remove(\"queued\", \"ue\") = \"qd\"\n+        assertEquals(\"qd\", StringUtils.remove(\"queued\", \"ue\"));\n+        \n+        // StringUtils.remove(\"queued\", \"zz\") = \"queued\"\n+        assertEquals(\"queued\", StringUtils.remove(\"queued\", \"zz\"));\n+    }\n+\n+    public void testRemove_char() {\n+        // StringUtils.remove(null, *)       = null\n+        assertEquals(null, StringUtils.remove(null, 'a'));\n+        assertEquals(null, StringUtils.remove(null, 'a'));\n+        assertEquals(null, StringUtils.remove(null, 'a'));\n+        \n+        // StringUtils.remove(\"\", *)          = \"\"\n+        assertEquals(\"\", StringUtils.remove(\"\", 'a'));\n+        assertEquals(\"\", StringUtils.remove(\"\", 'a'));\n+        assertEquals(\"\", StringUtils.remove(\"\", 'a'));\n+        \n+        // StringUtils.remove(\"queued\", 'u') = \"qeed\"\n+        assertEquals(\"qeed\", StringUtils.remove(\"queued\", 'u'));\n+        \n+        // StringUtils.remove(\"queued\", 'z') = \"queued\"\n+        assertEquals(\"queued\", StringUtils.remove(\"queued\", 'z'));\n+    }\n+\n+    \n+    public void testDifferenceAt_StringArray(){        \n+        assertEquals(-1, StringUtils.indexOfDifference(null));\n+        assertEquals(-1, StringUtils.indexOfDifference(new String[] {}));\n+        assertEquals(-1, StringUtils.indexOfDifference(new String[] {\"abc\"}));\n+        assertEquals(-1, StringUtils.indexOfDifference(new String[] {null, null}));\n+        assertEquals(-1, StringUtils.indexOfDifference(new String[] {\"\", \"\"}));\n+        assertEquals(0, StringUtils.indexOfDifference(new String[] {\"\", null}));\n+        assertEquals(0, StringUtils.indexOfDifference(new String[] {\"abc\", null, null}));\n+        assertEquals(0, StringUtils.indexOfDifference(new String[] {null, null, \"abc\"}));\n+        assertEquals(0, StringUtils.indexOfDifference(new String[] {\"\", \"abc\"}));\n+        assertEquals(0, StringUtils.indexOfDifference(new String[] {\"abc\", \"\"}));\n+        assertEquals(-1, StringUtils.indexOfDifference(new String[] {\"abc\", \"abc\"}));\n+        assertEquals(1, StringUtils.indexOfDifference(new String[] {\"abc\", \"a\"}));\n+        assertEquals(2, StringUtils.indexOfDifference(new String[] {\"ab\", \"abxyz\"}));\n+        assertEquals(2, StringUtils.indexOfDifference(new String[] {\"abcde\", \"abxyz\"}));\n+        assertEquals(0, StringUtils.indexOfDifference(new String[] {\"abcde\", \"xyz\"}));\n+        assertEquals(0, StringUtils.indexOfDifference(new String[] {\"xyz\", \"abcde\"}));\n+        assertEquals(7, StringUtils.indexOfDifference(new String[] {\"i am a machine\", \"i am a robot\"}));\n+    }\n+    \n+    public void testGetCommonPrefix_StringArray(){        \n+        assertEquals(\"\", StringUtils.getCommonPrefix(null));\n+        assertEquals(\"\", StringUtils.getCommonPrefix(new String[] {}));\n+        assertEquals(\"abc\", StringUtils.getCommonPrefix(new String[] {\"abc\"}));\n+        assertEquals(\"\", StringUtils.getCommonPrefix(new String[] {null, null}));\n+        assertEquals(\"\", StringUtils.getCommonPrefix(new String[] {\"\", \"\"}));\n+        assertEquals(\"\", StringUtils.getCommonPrefix(new String[] {\"\", null}));\n+        assertEquals(\"\", StringUtils.getCommonPrefix(new String[] {\"abc\", null, null}));\n+        assertEquals(\"\", StringUtils.getCommonPrefix(new String[] {null, null, \"abc\"}));\n+        assertEquals(\"\", StringUtils.getCommonPrefix(new String[] {\"\", \"abc\"}));\n+        assertEquals(\"\", StringUtils.getCommonPrefix(new String[] {\"abc\", \"\"}));\n+        assertEquals(\"abc\", StringUtils.getCommonPrefix(new String[] {\"abc\", \"abc\"}));\n+        assertEquals(\"a\", StringUtils.getCommonPrefix(new String[] {\"abc\", \"a\"}));\n+        assertEquals(\"ab\", StringUtils.getCommonPrefix(new String[] {\"ab\", \"abxyz\"}));\n+        assertEquals(\"ab\", StringUtils.getCommonPrefix(new String[] {\"abcde\", \"abxyz\"}));\n+        assertEquals(\"\", StringUtils.getCommonPrefix(new String[] {\"abcde\", \"xyz\"}));\n+        assertEquals(\"\", StringUtils.getCommonPrefix(new String[] {\"xyz\", \"abcde\"}));\n+        assertEquals(\"i am a \", StringUtils.getCommonPrefix(new String[] {\"i am a machine\", \"i am a robot\"}));\n+    }\n+        \n+    public void testStartsWithAny() {\n+        assertFalse(StringUtils.startsWithAny(null, null));\n+        assertFalse(StringUtils.startsWithAny(null, new String[] {\"abc\"}));\n+        assertFalse(StringUtils.startsWithAny(\"abcxyz\", null));\n+        assertFalse(StringUtils.startsWithAny(\"abcxyz\", new String[] {}));\n+        assertTrue(StringUtils.startsWithAny(\"abcxyz\", new String[] {\"abc\"}));\n+        assertTrue(StringUtils.startsWithAny(\"abcxyz\", new String[] {null, \"xyz\", \"abc\"}));\n+        assertFalse(StringUtils.startsWithAny(\"abcxyz\", new String[] {null, \"xyz\", \"abcd\"}));\n+    }\n+ \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/StringUtilsTrimEmptyTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.StringUtils} - Trim/Empty methods\n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @version $Id$\n+ */\n+public class StringUtilsTrimEmptyTest extends TestCase {\n+    private static final String FOO = \"foo\";\n+\n+    public StringUtilsTrimEmptyTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StringUtilsTrimEmptyTest.class);\n+        suite.setName(\"StringUtilsTrimEmpty Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsEmpty() {\n+        assertEquals(true, StringUtils.isEmpty(null));\n+        assertEquals(true, StringUtils.isEmpty(\"\"));\n+        assertEquals(false, StringUtils.isEmpty(\" \"));\n+        assertEquals(false, StringUtils.isEmpty(\"foo\"));\n+        assertEquals(false, StringUtils.isEmpty(\"  foo  \"));\n+    }\n+\n+    public void testIsNotEmpty() {\n+        assertEquals(false, StringUtils.isNotEmpty(null));\n+        assertEquals(false, StringUtils.isNotEmpty(\"\"));\n+        assertEquals(true, StringUtils.isNotEmpty(\" \"));\n+        assertEquals(true, StringUtils.isNotEmpty(\"foo\"));\n+        assertEquals(true, StringUtils.isNotEmpty(\"  foo  \"));\n+    }\n+\n+    public void testIsBlank() {\n+        assertEquals(true, StringUtils.isBlank(null));\n+        assertEquals(true, StringUtils.isBlank(\"\"));\n+        assertEquals(true, StringUtils.isBlank(StringUtilsTest.WHITESPACE));\n+        assertEquals(false, StringUtils.isBlank(\"foo\"));\n+        assertEquals(false, StringUtils.isBlank(\"  foo  \"));\n+    }\n+\n+    public void testIsNotBlank() {\n+        assertEquals(false, StringUtils.isNotBlank(null));\n+        assertEquals(false, StringUtils.isNotBlank(\"\"));\n+        assertEquals(false, StringUtils.isNotBlank(StringUtilsTest.WHITESPACE));\n+        assertEquals(true, StringUtils.isNotBlank(\"foo\"));\n+        assertEquals(true, StringUtils.isNotBlank(\"  foo  \"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTrim() {\n+        assertEquals(FOO, StringUtils.trim(FOO + \"  \"));\n+        assertEquals(FOO, StringUtils.trim(\" \" + FOO + \"  \"));\n+        assertEquals(FOO, StringUtils.trim(\" \" + FOO));\n+        assertEquals(FOO, StringUtils.trim(FOO + \"\"));\n+        assertEquals(\"\", StringUtils.trim(\" \\t\\r\\n\\b \"));\n+        assertEquals(\"\", StringUtils.trim(StringUtilsTest.TRIMMABLE));\n+        assertEquals(StringUtilsTest.NON_TRIMMABLE, StringUtils.trim(StringUtilsTest.NON_TRIMMABLE));\n+        assertEquals(\"\", StringUtils.trim(\"\"));\n+        assertEquals(null, StringUtils.trim(null));\n+    }\n+\n+    public void testTrimToNull() {\n+        assertEquals(FOO, StringUtils.trimToNull(FOO + \"  \"));\n+        assertEquals(FOO, StringUtils.trimToNull(\" \" + FOO + \"  \"));\n+        assertEquals(FOO, StringUtils.trimToNull(\" \" + FOO));\n+        assertEquals(FOO, StringUtils.trimToNull(FOO + \"\"));\n+        assertEquals(null, StringUtils.trimToNull(\" \\t\\r\\n\\b \"));\n+        assertEquals(null, StringUtils.trimToNull(StringUtilsTest.TRIMMABLE));\n+        assertEquals(StringUtilsTest.NON_TRIMMABLE, StringUtils.trimToNull(StringUtilsTest.NON_TRIMMABLE));\n+        assertEquals(null, StringUtils.trimToNull(\"\"));\n+        assertEquals(null, StringUtils.trimToNull(null));\n+    }\n+\n+    public void testTrimToEmpty() {\n+        assertEquals(FOO, StringUtils.trimToEmpty(FOO + \"  \"));\n+        assertEquals(FOO, StringUtils.trimToEmpty(\" \" + FOO + \"  \"));\n+        assertEquals(FOO, StringUtils.trimToEmpty(\" \" + FOO));\n+        assertEquals(FOO, StringUtils.trimToEmpty(FOO + \"\"));\n+        assertEquals(\"\", StringUtils.trimToEmpty(\" \\t\\r\\n\\b \"));\n+        assertEquals(\"\", StringUtils.trimToEmpty(StringUtilsTest.TRIMMABLE));\n+        assertEquals(StringUtilsTest.NON_TRIMMABLE, StringUtils.trimToEmpty(StringUtilsTest.NON_TRIMMABLE));\n+        assertEquals(\"\", StringUtils.trimToEmpty(\"\"));\n+        assertEquals(\"\", StringUtils.trimToEmpty(null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testStrip_String() {\n+        assertEquals(null, StringUtils.strip(null));\n+        assertEquals(\"\", StringUtils.strip(\"\"));\n+        assertEquals(\"\", StringUtils.strip(\"        \"));\n+        assertEquals(\"abc\", StringUtils.strip(\"  abc  \"));\n+        assertEquals(StringUtilsTest.NON_WHITESPACE, \n+            StringUtils.strip(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE));\n+    }\n+    \n+    public void testStripToNull_String() {\n+        assertEquals(null, StringUtils.stripToNull(null));\n+        assertEquals(null, StringUtils.stripToNull(\"\"));\n+        assertEquals(null, StringUtils.stripToNull(\"        \"));\n+        assertEquals(null, StringUtils.stripToNull(StringUtilsTest.WHITESPACE));\n+        assertEquals(\"ab c\", StringUtils.stripToNull(\"  ab c  \"));\n+        assertEquals(StringUtilsTest.NON_WHITESPACE, \n+            StringUtils.stripToNull(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE));\n+    }\n+    \n+    public void testStripToEmpty_String() {\n+        assertEquals(\"\", StringUtils.stripToEmpty(null));\n+        assertEquals(\"\", StringUtils.stripToEmpty(\"\"));\n+        assertEquals(\"\", StringUtils.stripToEmpty(\"        \"));\n+        assertEquals(\"\", StringUtils.stripToEmpty(StringUtilsTest.WHITESPACE));\n+        assertEquals(\"ab c\", StringUtils.stripToEmpty(\"  ab c  \"));\n+        assertEquals(StringUtilsTest.NON_WHITESPACE, \n+            StringUtils.stripToEmpty(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE));\n+    }\n+    \n+    public void testStrip_StringString() {\n+        // null strip\n+        assertEquals(null, StringUtils.strip(null, null));\n+        assertEquals(\"\", StringUtils.strip(\"\", null));\n+        assertEquals(\"\", StringUtils.strip(\"        \", null));\n+        assertEquals(\"abc\", StringUtils.strip(\"  abc  \", null));\n+        assertEquals(StringUtilsTest.NON_WHITESPACE, \n+            StringUtils.strip(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE, null));\n+\n+        // \"\" strip\n+        assertEquals(null, StringUtils.strip(null, \"\"));\n+        assertEquals(\"\", StringUtils.strip(\"\", \"\"));\n+        assertEquals(\"        \", StringUtils.strip(\"        \", \"\"));\n+        assertEquals(\"  abc  \", StringUtils.strip(\"  abc  \", \"\"));\n+        assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE, \"\"));\n+        \n+        // \" \" strip\n+        assertEquals(null, StringUtils.strip(null, \" \"));\n+        assertEquals(\"\", StringUtils.strip(\"\", \" \"));\n+        assertEquals(\"\", StringUtils.strip(\"        \", \" \"));\n+        assertEquals(\"abc\", StringUtils.strip(\"  abc  \", \" \"));\n+        \n+        // \"ab\" strip\n+        assertEquals(null, StringUtils.strip(null, \"ab\"));\n+        assertEquals(\"\", StringUtils.strip(\"\", \"ab\"));\n+        assertEquals(\"        \", StringUtils.strip(\"        \", \"ab\"));\n+        assertEquals(\"  abc  \", StringUtils.strip(\"  abc  \", \"ab\"));\n+        assertEquals(\"c\", StringUtils.strip(\"abcabab\", \"ab\"));\n+        assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE, \"\"));\n+    }\n+    \n+    public void testStripStart_StringString() {\n+        // null stripStart\n+        assertEquals(null, StringUtils.stripStart(null, null));\n+        assertEquals(\"\", StringUtils.stripStart(\"\", null));\n+        assertEquals(\"\", StringUtils.stripStart(\"        \", null));\n+        assertEquals(\"abc  \", StringUtils.stripStart(\"  abc  \", null));\n+        assertEquals(StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE, \n+            StringUtils.stripStart(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE, null));\n+\n+        // \"\" stripStart\n+        assertEquals(null, StringUtils.stripStart(null, \"\"));\n+        assertEquals(\"\", StringUtils.stripStart(\"\", \"\"));\n+        assertEquals(\"        \", StringUtils.stripStart(\"        \", \"\"));\n+        assertEquals(\"  abc  \", StringUtils.stripStart(\"  abc  \", \"\"));\n+        assertEquals(StringUtilsTest.WHITESPACE, StringUtils.stripStart(StringUtilsTest.WHITESPACE, \"\"));\n+        \n+        // \" \" stripStart\n+        assertEquals(null, StringUtils.stripStart(null, \" \"));\n+        assertEquals(\"\", StringUtils.stripStart(\"\", \" \"));\n+        assertEquals(\"\", StringUtils.stripStart(\"        \", \" \"));\n+        assertEquals(\"abc  \", StringUtils.stripStart(\"  abc  \", \" \"));\n+        \n+        // \"ab\" stripStart\n+        assertEquals(null, StringUtils.stripStart(null, \"ab\"));\n+        assertEquals(\"\", StringUtils.stripStart(\"\", \"ab\"));\n+        assertEquals(\"        \", StringUtils.stripStart(\"        \", \"ab\"));\n+        assertEquals(\"  abc  \", StringUtils.stripStart(\"  abc  \", \"ab\"));\n+        assertEquals(\"cabab\", StringUtils.stripStart(\"abcabab\", \"ab\"));\n+        assertEquals(StringUtilsTest.WHITESPACE, StringUtils.stripStart(StringUtilsTest.WHITESPACE, \"\"));\n+    }\n+    \n+    public void testStripEnd_StringString() {\n+        // null stripEnd\n+        assertEquals(null, StringUtils.stripEnd(null, null));\n+        assertEquals(\"\", StringUtils.stripEnd(\"\", null));\n+        assertEquals(\"\", StringUtils.stripEnd(\"        \", null));\n+        assertEquals(\"  abc\", StringUtils.stripEnd(\"  abc  \", null));\n+        assertEquals(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE, \n+            StringUtils.stripEnd(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE, null));\n+\n+        // \"\" stripEnd\n+        assertEquals(null, StringUtils.stripEnd(null, \"\"));\n+        assertEquals(\"\", StringUtils.stripEnd(\"\", \"\"));\n+        assertEquals(\"        \", StringUtils.stripEnd(\"        \", \"\"));\n+        assertEquals(\"  abc  \", StringUtils.stripEnd(\"  abc  \", \"\"));\n+        assertEquals(StringUtilsTest.WHITESPACE, StringUtils.stripEnd(StringUtilsTest.WHITESPACE, \"\"));\n+        \n+        // \" \" stripEnd\n+        assertEquals(null, StringUtils.stripEnd(null, \" \"));\n+        assertEquals(\"\", StringUtils.stripEnd(\"\", \" \"));\n+        assertEquals(\"\", StringUtils.stripEnd(\"        \", \" \"));\n+        assertEquals(\"  abc\", StringUtils.stripEnd(\"  abc  \", \" \"));\n+        \n+        // \"ab\" stripEnd\n+        assertEquals(null, StringUtils.stripEnd(null, \"ab\"));\n+        assertEquals(\"\", StringUtils.stripEnd(\"\", \"ab\"));\n+        assertEquals(\"        \", StringUtils.stripEnd(\"        \", \"ab\"));\n+        assertEquals(\"  abc  \", StringUtils.stripEnd(\"  abc  \", \"ab\"));\n+        assertEquals(\"abc\", StringUtils.stripEnd(\"abcabab\", \"ab\"));\n+        assertEquals(StringUtilsTest.WHITESPACE, StringUtils.stripEnd(StringUtilsTest.WHITESPACE, \"\"));\n+    }\n+\n+    public void testStripAll() {\n+        // test stripAll method, merely an array version of the above strip\n+        String[] empty = new String[0];\n+        String[] fooSpace = new String[] { \"  \"+FOO+\"  \", \"  \"+FOO, FOO+\"  \" };\n+        String[] fooDots = new String[] { \"..\"+FOO+\"..\", \"..\"+FOO, FOO+\"..\" };\n+        String[] foo = new String[] { FOO, FOO, FOO };\n+\n+        assertEquals(null, StringUtils.stripAll(null));\n+        assertArrayEquals(empty, StringUtils.stripAll(empty));\n+        assertArrayEquals(foo, StringUtils.stripAll(fooSpace));\n+        \n+        assertEquals(null, StringUtils.stripAll(null, null));\n+        assertArrayEquals(foo, StringUtils.stripAll(fooSpace, null));\n+        assertArrayEquals(foo, StringUtils.stripAll(fooDots, \".\"));\n+    }\n+\n+    private void assertArrayEquals(Object[] o1, Object[] o2) {\n+        if(o1 == null) {\n+            assertEquals(o1,o2);\n+            return;\n+        }\n+        assertEquals(\"Length not equal. \", o1.length, o2.length);\n+        int sz = o1.length;\n+        for(int i=0; i<sz; i++) {\n+            if(o1[i] instanceof Object[]) {\n+                // do an assert equals on type....\n+                assertArrayEquals( (Object[]) o1[i], (Object[]) o2[i] );\n+            } else {\n+                assertEquals(o1[i], o2[i]);\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/SystemUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.lang;\n+\n+import java.io.File;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.Locale;\n+\n+import junit.framework.Assert;\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.SystemUtils}.\n+ * \n+ * Only limited testing can be performed.\n+ * \n+ * @author Apache Software Foundation\n+ * @author Tetsuya Kaneuchi\n+ * @author Gary D. Gregory\n+ * @version $Id$\n+ */\n+public class SystemUtilsTest extends TestCase {\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SystemUtilsTest.class);\n+        suite.setName(\"SystemUtils Tests\");\n+        return suite;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // COPIED FROM SystemUtils\n+    //-----------------------------------------------------------------------\n+    private String JAVA_VERSION;\n+\n+    private String JAVA_VERSION_TRIMMED;\n+\n+    private String OS_NAME;\n+\n+    private String OS_VERSION;\n+\n+    public SystemUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * <p>Gets the Java version number as a <code>float</code>.</p>\n+     *\n+     * <p>Example return values:</p>\n+     * <ul>\n+     *  <li><code>1.2f</code> for JDK 1.2\n+     *  <li><code>1.31f</code> for JDK 1.3.1\n+     * </ul>\n+     * \n+     * <p>Patch releases are not reported.\n+     * Zero is returned if {@link #JAVA_VERSION_TRIMMED} is <code>null</code>.</p>\n+     * \n+     * @return the version, for example 1.31f for JDK 1.3.1\n+     */\n+    private float getJavaVersionAsFloat() {\n+        if (JAVA_VERSION_TRIMMED == null) {\n+            return 0f;\n+        }\n+        String str = JAVA_VERSION_TRIMMED.substring(0, 3);\n+        if (JAVA_VERSION_TRIMMED.length() >= 5) {\n+            str = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n+        }\n+        try {\n+            return Float.parseFloat(str);\n+        } catch (Exception ex) {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets the Java version number as an <code>int</code>.</p>\n+     *\n+     * <p>Example return values:</p>\n+     * <ul>\n+     *  <li><code>120</code> for JDK 1.2\n+     *  <li><code>131</code> for JDK 1.3.1\n+     * </ul>\n+     * \n+     * <p>Patch releases are not reported.\n+     * Zero is returned if {@link #JAVA_VERSION_TRIMMED} is <code>null</code>.</p>\n+     * \n+     * @return the version, for example 131 for JDK 1.3.1\n+     */\n+    private int getJavaVersionAsInt() {\n+        if (JAVA_VERSION == null) {\n+            return 0;\n+        }\n+        String str = JAVA_VERSION_TRIMMED.substring(0, 1);\n+        str = str + JAVA_VERSION_TRIMMED.substring(2, 3);\n+        if (JAVA_VERSION_TRIMMED.length() >= 5) {\n+            str = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n+        } else {\n+            str = str + \"0\";\n+        }\n+        try {\n+            return Integer.parseInt(str);\n+        } catch (Exception ex) {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Trims the text of the java version to start with numbers.\n+     * \n+     * @return the trimmed java version\n+     */\n+    private String getJavaVersionTrimmed() {\n+        if (JAVA_VERSION != null) {\n+            for (int i = 0; i < JAVA_VERSION.length(); i++) {\n+                char ch = JAVA_VERSION.charAt(i);\n+                if (ch >= '0' && ch <= '9') {\n+                    return JAVA_VERSION.substring(i);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Decides if the java version matches.\n+     * \n+     * @param versionPrefix\n+     *                  the prefix for the java version\n+     * @return true if matches, or false if not or can't determine\n+     */\n+    private boolean getJavaVersionMatches(String versionPrefix) {\n+        if (JAVA_VERSION_TRIMMED == null) {\n+            return false;\n+        }\n+        return JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n+    }\n+\n+    /**\n+     * Decides if the operating system matches.\n+     * \n+     * @param osNamePrefix\n+     *                  the prefix for the os name\n+     * @return true if matches, or false if not or can't determine\n+     */\n+    private boolean getOSMatches(String osNamePrefix) {\n+        if (OS_NAME == null) {\n+            return false;\n+        }\n+        return OS_NAME.startsWith(osNamePrefix);\n+    }\n+\n+    /**\n+     * Decides if the operating system matches.\n+     * \n+     * @param osNamePrefix\n+     *                  the prefix for the os name\n+     * @param osVersionPrefix\n+     *                  the prefix for the version\n+     * @return true if matches, or false if not or can't determine\n+     */\n+    private boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\n+        if (OS_NAME == null || OS_VERSION == null) {\n+            return false;\n+        }\n+        return OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new SystemUtils());\n+        Constructor<?>[] cons = SystemUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(SystemUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(SystemUtils.class.getModifiers()));\n+    }\n+\n+    /**\n+     * Assums no security manager exists.\n+     */\n+    public void testGetJavaHome() {\n+        File dir = SystemUtils.getJavaHome();\n+        Assert.assertNotNull(dir);\n+        Assert.assertTrue(dir.exists());\n+    }\n+\n+    /**\n+     * Assums no security manager exists.\n+     */\n+    public void testGetJavaIoTmpDir() {\n+        File dir = SystemUtils.getJavaIoTmpDir();\n+        Assert.assertNotNull(dir);\n+        Assert.assertTrue(dir.exists());\n+    }\n+\n+    /**\n+     * Assums no security manager exists.\n+     */\n+    public void testGetUserDir() {\n+        File dir = SystemUtils.getUserDir();\n+        Assert.assertNotNull(dir);\n+        Assert.assertTrue(dir.exists());\n+    }\n+\n+    /**\n+     * Assums no security manager exists.\n+     */\n+    public void testGetUserHome() {\n+        File dir = SystemUtils.getUserHome();\n+        Assert.assertNotNull(dir);\n+        Assert.assertTrue(dir.exists());\n+    }\n+\n+    public void testIS_JAVA() {\n+        String javaVersion = System.getProperty(\"java.version\");\n+        if (javaVersion == null) {\n+            assertEquals(false, SystemUtils.IS_JAVA_1_1);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_2);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_3);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_4);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_5);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_6);\n+        } else if (javaVersion.startsWith(\"1.1\")) {\n+            assertEquals(true, SystemUtils.IS_JAVA_1_1);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_2);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_3);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_4);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_5);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_6);\n+        } else if (javaVersion.startsWith(\"1.2\")) {\n+            assertEquals(false, SystemUtils.IS_JAVA_1_1);\n+            assertEquals(true, SystemUtils.IS_JAVA_1_2);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_3);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_4);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_5);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_6);\n+        } else if (javaVersion.startsWith(\"1.3\")) {\n+            assertEquals(false, SystemUtils.IS_JAVA_1_1);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_2);\n+            assertEquals(true, SystemUtils.IS_JAVA_1_3);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_4);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_5);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_6);\n+        } else if (javaVersion.startsWith(\"1.4\")) {\n+            assertEquals(false, SystemUtils.IS_JAVA_1_1);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_2);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_3);\n+            assertEquals(true, SystemUtils.IS_JAVA_1_4);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_5);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_6);\n+        } else if (javaVersion.startsWith(\"1.5\")) {\n+            assertEquals(false, SystemUtils.IS_JAVA_1_1);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_2);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_3);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_4);\n+            assertEquals(true, SystemUtils.IS_JAVA_1_5);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_6);\n+        } else if (javaVersion.startsWith(\"1.6\")) {\n+            assertEquals(false, SystemUtils.IS_JAVA_1_1);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_2);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_3);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_4);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_5);\n+            assertEquals(true, SystemUtils.IS_JAVA_1_6);\n+        } else {\n+            System.out.println(\"Can't test IS_JAVA value\");\n+        }\n+    }\n+\n+    public void testIS_OS() {\n+        String osName = System.getProperty(\"os.name\");\n+        if (osName == null) {\n+            assertEquals(false, SystemUtils.IS_OS_WINDOWS);\n+            assertEquals(false, SystemUtils.IS_OS_UNIX);\n+            assertEquals(false, SystemUtils.IS_OS_SOLARIS);\n+            assertEquals(false, SystemUtils.IS_OS_LINUX);\n+            assertEquals(false, SystemUtils.IS_OS_MAC_OSX);\n+        } else if (osName.startsWith(\"Windows\")) {\n+            assertEquals(false, SystemUtils.IS_OS_UNIX);\n+            assertEquals(true, SystemUtils.IS_OS_WINDOWS);\n+        } else if (osName.startsWith(\"Solaris\")) {\n+            assertEquals(true, SystemUtils.IS_OS_SOLARIS);\n+            assertEquals(true, SystemUtils.IS_OS_UNIX);\n+            assertEquals(false, SystemUtils.IS_OS_WINDOWS);\n+        } else if (osName.toLowerCase(Locale.ENGLISH).startsWith(\"linux\")) {\n+            assertEquals(true, SystemUtils.IS_OS_LINUX);\n+            assertEquals(true, SystemUtils.IS_OS_UNIX);\n+            assertEquals(false, SystemUtils.IS_OS_WINDOWS);\n+        } else if (osName.startsWith(\"Mac OS X\")) {\n+            assertEquals(true, SystemUtils.IS_OS_MAC_OSX);\n+            assertEquals(true, SystemUtils.IS_OS_UNIX);\n+            assertEquals(false, SystemUtils.IS_OS_WINDOWS);\n+        } else if (osName.startsWith(\"OS/2\")) {\n+            assertEquals(true, SystemUtils.IS_OS_OS2);\n+            assertEquals(false, SystemUtils.IS_OS_UNIX);\n+            assertEquals(false, SystemUtils.IS_OS_WINDOWS);\n+        } else if (osName.startsWith(\"SunOS\")) {\n+            assertEquals(true, SystemUtils.IS_OS_SUN_OS);\n+            assertEquals(true, SystemUtils.IS_OS_UNIX);\n+            assertEquals(false, SystemUtils.IS_OS_WINDOWS);\n+        } else {\n+            System.out.println(\"Can't test IS_OS value\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testJavaVersionAsFloat() {\n+        JAVA_VERSION = null;\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(0f, getJavaVersionAsFloat(), 0.000001f);\n+        JAVA_VERSION = \"1.1\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(1.1f, getJavaVersionAsFloat(), 0.000001f);\n+        JAVA_VERSION = \"1.2\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(1.2f, getJavaVersionAsFloat(), 0.000001f);\n+        JAVA_VERSION = \"1.3.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(1.3f, getJavaVersionAsFloat(), 0.000001f);\n+        JAVA_VERSION = \"1.3.1\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(1.31f, getJavaVersionAsFloat(), 0.000001f);\n+        JAVA_VERSION = \"1.4.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(1.4f, getJavaVersionAsFloat(), 0.000001f);\n+        JAVA_VERSION = \"1.4.1\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(1.41f, getJavaVersionAsFloat(), 0.000001f);\n+        JAVA_VERSION = \"1.5.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(1.5f, getJavaVersionAsFloat(), 0.000001f);\n+        JAVA_VERSION = \"1.6.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(1.6f, getJavaVersionAsFloat(), 0.000001f);\n+        JAVA_VERSION = \"JavaVM-1.3.1\";  //HP-UX\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(1.31f, getJavaVersionAsFloat(), 0.000001f);\n+        JAVA_VERSION = \"XXX-1.3.x\";  //error\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(0.0f, getJavaVersionAsFloat(), 0.000001f);\n+    }\n+\n+    public void testJavaVersionAsInt() {\n+        JAVA_VERSION = null;\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(0, getJavaVersionAsInt());\n+        JAVA_VERSION = \"1.1\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(110, getJavaVersionAsInt());\n+        JAVA_VERSION = \"1.2\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(120, getJavaVersionAsInt());\n+        JAVA_VERSION = \"1.3.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(130, getJavaVersionAsInt());\n+        JAVA_VERSION = \"1.3.1\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(131, getJavaVersionAsInt());\n+        JAVA_VERSION = \"1.4.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(140, getJavaVersionAsInt());\n+        JAVA_VERSION = \"1.4.1\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(141, getJavaVersionAsInt());\n+        JAVA_VERSION = \"1.5.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(150, getJavaVersionAsInt());\n+        JAVA_VERSION = \"1.6.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(160, getJavaVersionAsInt());\n+        JAVA_VERSION = \"JavaVM-1.3.1\";  //HP-UX\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(131, getJavaVersionAsInt());\n+        JAVA_VERSION = \"XXX-1.3.x\";  //error\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(0, getJavaVersionAsInt());\n+    }\n+\n+    public void testJavaVersionAtLeastFloat() {\n+        float version = SystemUtils.JAVA_VERSION_FLOAT;\n+        assertEquals(true, SystemUtils.isJavaVersionAtLeast(version));\n+        version -= 0.1f;\n+        assertEquals(true, SystemUtils.isJavaVersionAtLeast(version));\n+        version += 0.2f;\n+        assertEquals(false, SystemUtils.isJavaVersionAtLeast(version));\n+    }\n+\n+    public void testJavaVersionAtLeastInt() {\n+        int version = SystemUtils.JAVA_VERSION_INT;\n+        assertEquals(true, SystemUtils.isJavaVersionAtLeast(version));\n+        version -= 10;\n+        assertEquals(true, SystemUtils.isJavaVersionAtLeast(version));\n+        version += 20;\n+        assertEquals(false, SystemUtils.isJavaVersionAtLeast(version));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testJavaVersionMatches() {\n+        JAVA_VERSION = null;\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(false, getJavaVersionMatches(\"1.1\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.2\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.3\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.4\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.5\"));\n+        JAVA_VERSION = \"1.1\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(true, getJavaVersionMatches(\"1.1\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.2\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.3\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.4\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.5\"));\n+        JAVA_VERSION = \"1.2\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(false, getJavaVersionMatches(\"1.1\"));\n+        assertEquals(true, getJavaVersionMatches(\"1.2\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.3\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.4\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.5\"));\n+        JAVA_VERSION = \"1.3.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(false, getJavaVersionMatches(\"1.1\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.2\"));\n+        assertEquals(true, getJavaVersionMatches(\"1.3\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.4\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.5\"));\n+        JAVA_VERSION = \"1.3.1\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(false, getJavaVersionMatches(\"1.1\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.2\"));\n+        assertEquals(true, getJavaVersionMatches(\"1.3\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.4\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.5\"));\n+        JAVA_VERSION = \"1.4.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(false, getJavaVersionMatches(\"1.1\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.2\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.3\"));\n+        assertEquals(true, getJavaVersionMatches(\"1.4\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.5\"));\n+        JAVA_VERSION = \"1.4.1\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(false, getJavaVersionMatches(\"1.1\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.2\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.3\"));\n+        assertEquals(true, getJavaVersionMatches(\"1.4\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.5\"));\n+        JAVA_VERSION = \"1.5.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(false, getJavaVersionMatches(\"1.1\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.2\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.3\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.4\"));\n+        assertEquals(true, getJavaVersionMatches(\"1.5\"));\n+        JAVA_VERSION = \"1.6.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(false, getJavaVersionMatches(\"1.1\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.2\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.3\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.4\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.5\"));\n+    }\n+\n+    public void testOSMatches() {\n+        OS_NAME = null;\n+        assertEquals(false, getOSMatches(\"Windows\"));\n+        OS_NAME = \"Windows 95\";\n+        assertEquals(true, getOSMatches(\"Windows\"));\n+        OS_NAME = \"Windows NT\";\n+        assertEquals(true, getOSMatches(\"Windows\"));\n+        OS_NAME = \"OS/2\";\n+        assertEquals(false, getOSMatches(\"Windows\"));\n+    }\n+\n+    public void testOSMatches2() {\n+        OS_NAME = null;\n+        OS_VERSION = null;\n+        assertEquals(false, getOSMatches(\"Windows 9\", \"4.1\"));\n+        OS_NAME = \"Windows 95\";\n+        OS_VERSION = \"4.0\";\n+        assertEquals(false, getOSMatches(\"Windows 9\", \"4.1\"));\n+        OS_NAME = \"Windows 95\";\n+        OS_VERSION = \"4.1\";\n+        assertEquals(true, getOSMatches(\"Windows 9\", \"4.1\"));\n+        OS_NAME = \"Windows 98\";\n+        OS_VERSION = \"4.1\";\n+        assertEquals(true, getOSMatches(\"Windows 9\", \"4.1\"));\n+        OS_NAME = \"Windows NT\";\n+        OS_VERSION = \"4.0\";\n+        assertEquals(false, getOSMatches(\"Windows 9\", \"4.1\"));\n+        OS_NAME = \"OS/2\";\n+        OS_VERSION = \"4.0\";\n+        assertEquals(false, getOSMatches(\"Windows 9\", \"4.1\"));\n+    }\n+\n+    public void testJavaAwtHeadless() {\n+        boolean atLeastJava14 = SystemUtils.isJavaVersionAtLeast(140);\n+        String expectedStringValue = System.getProperty(\"java.awt.headless\");\n+        String expectedStringValueWithDefault = System.getProperty(\"java.awt.headless\", \"false\");\n+        assertNotNull(expectedStringValueWithDefault);\n+        if (atLeastJava14) {\n+            boolean expectedValue = Boolean.valueOf(expectedStringValue).booleanValue();\n+            if (expectedStringValue != null) {\n+                assertEquals(expectedStringValue, SystemUtils.JAVA_AWT_HEADLESS);\n+            }\n+            assertEquals(expectedValue, SystemUtils.isJavaAwtHeadless());\n+        } else {\n+            assertNull(expectedStringValue);\n+            assertNull(SystemUtils.JAVA_AWT_HEADLESS);\n+            assertEquals(expectedStringValueWithDefault, \"\" + SystemUtils.isJavaAwtHeadless());\n+        }\n+        assertEquals(expectedStringValueWithDefault, \"\" + SystemUtils.isJavaAwtHeadless());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/ValidateTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+/**\n+ * Unit tests {@link org.apache.commons.lang.Validate}.\n+ *\n+ * @author Apache Software Foundation\n+ * @author Norm Deane\n+ * @version $Id$\n+ */\n+public class ValidateTest extends TestCase {\n+\n+    public ValidateTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ValidateTest.class);\n+        suite.setName(\"Validate Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsTrue1() {\n+        Validate.isTrue(true);\n+        try {\n+            Validate.isTrue(false);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated expression is false\", ex.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsTrue2() {\n+        Validate.isTrue(true, \"MSG\");\n+        try {\n+            Validate.isTrue(false, \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsTrue3() {\n+        Validate.isTrue(true, \"MSG\", new Integer(6));\n+        try {\n+            Validate.isTrue(false, \"MSG\", new Integer(6));\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsTrue4() {\n+        Validate.isTrue(true, \"MSG\", 7);\n+        try {\n+            Validate.isTrue(false, \"MSG\", 7);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsTrue5() {\n+        Validate.isTrue(true, \"MSG\", 7.4d);\n+        try {\n+            Validate.isTrue(false, \"MSG\", 7.4d);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testNotNull1() {\n+        Validate.notNull(new Object());\n+        try {\n+            Validate.notNull(null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            assertEquals(\"The validated object is null\", ex.getMessage());\n+        }\n+        \n+        String str = \"Hi\";\n+        String testStr = Validate.notNull(str);\n+        assertSame(str, testStr);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotNull2() {\n+        Validate.notNull(new Object(), \"MSG\");\n+        try {\n+            Validate.notNull(null, \"MSG\");\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        \n+        String str = \"Hi\";\n+        String testStr = Validate.notNull(str, \"Message\");\n+        assertSame(str, testStr);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testNotEmptyArray1() {\n+        Validate.notEmpty(new Object[] {null});\n+        try {\n+            Validate.notEmpty((Object[]) null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            assertEquals(\"The validated array is empty\", ex.getMessage());\n+        }\n+        try {\n+            Validate.notEmpty(new Object[0]);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated array is empty\", ex.getMessage());\n+        }\n+        \n+        String[] array = new String[] {\"hi\"};\n+        String[] test = Validate.notEmpty(array);\n+        assertSame(array, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotEmptyArray2() {\n+        Validate.notEmpty(new Object[] {null}, \"MSG\");\n+        try {\n+            Validate.notEmpty((Object[]) null, \"MSG\");\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        try {\n+            Validate.notEmpty(new Object[0], \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        \n+        String[] array = new String[] {\"hi\"};\n+        String[] test = Validate.notEmpty(array, \"Message\");\n+        assertSame(array, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testNotEmptyCollection1() {\n+        Collection<Integer> coll = new ArrayList<Integer>();\n+        try {\n+            Validate.notEmpty((Collection<?>) null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            assertEquals(\"The validated collection is empty\", ex.getMessage());\n+        }\n+        try {\n+            Validate.notEmpty(coll);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated collection is empty\", ex.getMessage());\n+        }\n+        coll.add(new Integer(8));\n+        Validate.notEmpty(coll);\n+        \n+        Collection<Integer> test = Validate.notEmpty(coll);\n+        assertSame(coll, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotEmptyCollection2() {\n+        Collection<Integer> coll = new ArrayList<Integer>();\n+        try {\n+            Validate.notEmpty((Collection<?>) null, \"MSG\");\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        try {\n+            Validate.notEmpty(coll, \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        coll.add(new Integer(8));\n+        Validate.notEmpty(coll, \"MSG\");\n+        \n+        Collection<Integer> test = Validate.notEmpty(coll, \"Message\");\n+        assertSame(coll, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testNotEmptyMap1() {\n+        Map<String, Integer> map = new HashMap<String, Integer>();\n+        try {\n+            Validate.notEmpty((Map<?, ?>) null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            assertEquals(\"The validated map is empty\", ex.getMessage());\n+        }\n+        try {\n+            Validate.notEmpty(map);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated map is empty\", ex.getMessage());\n+        }\n+        map.put(\"ll\", new Integer(8));\n+        Validate.notEmpty(map);\n+        \n+        Map<String, Integer> test = Validate.notEmpty(map);\n+        assertSame(map, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotEmptyMap2() {\n+        Map<String, Integer> map = new HashMap<String, Integer>();\n+        try {\n+            Validate.notEmpty((Map<?, ?>) null, \"MSG\");\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        try {\n+            Validate.notEmpty(map, \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        map.put(\"ll\", new Integer(8));\n+        Validate.notEmpty(map, \"MSG\");\n+        \n+        Map<String, Integer> test = Validate.notEmpty(map, \"Message\");\n+        assertSame(map, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testNotEmptyString1() {\n+        Validate.notEmpty(\"hjl\");\n+        try {\n+            Validate.notEmpty((String) null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            assertEquals(\"The validated character sequence is empty\", ex.getMessage());\n+        }\n+        try {\n+            Validate.notEmpty(\"\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated character sequence is empty\", ex.getMessage());\n+        }\n+        \n+        String str = \"Hi\";\n+        String testStr = Validate.notEmpty(str);\n+        assertSame(str, testStr);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotEmptyString2() {\n+        Validate.notEmpty(\"a\", \"MSG\");\n+        try {\n+            Validate.notEmpty((String) null, \"MSG\");\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        try {\n+            Validate.notEmpty(\"\", \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        \n+        String str = \"Hi\";\n+        String testStr = Validate.notEmpty(str, \"Message\");\n+        assertSame(str, testStr);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testNotBlankNullStringShouldThrow() {\n+        //given\n+        String string = null;\n+\n+        try {\n+            //when\n+            Validate.notBlank(string);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException e) {\n+            //then\n+            assertEquals(\"The validated character sequence is blank\", e.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotBlankMsgNullStringShouldThrow() {\n+        //given\n+        String string = null;\n+\n+        try {\n+            //when\n+            Validate.notBlank(string, \"Message\");\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException e) {\n+            //then\n+            assertEquals(\"Message\", e.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotBlankEmptyStringShouldThrow() {\n+        //given\n+        String string = \"\";\n+\n+        try {\n+            //when\n+            Validate.notBlank(string);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            //then\n+            assertEquals(\"The validated character sequence is blank\", e.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotBlankBlankStringWithWhitespacesShouldThrow() {\n+        //given\n+        String string = \"   \";\n+\n+        try {\n+            //when\n+            Validate.notBlank(string);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            //then\n+            assertEquals(\"The validated character sequence is blank\", e.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotBlankBlankStringWithNewlinesShouldThrow() {\n+        //given\n+        String string = \" \\n \\t \\r \\n \";\n+\n+        try {\n+            //when\n+            Validate.notBlank(string);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            //then\n+            assertEquals(\"The validated character sequence is blank\", e.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotBlankMsgBlankStringShouldThrow() {\n+        //given\n+        String string = \" \\n \\t \\r \\n \";\n+\n+        try {\n+            //when\n+            Validate.notBlank(string, \"Message\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            //then\n+            assertEquals(\"Message\", e.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotBlankMsgBlankStringWithWhitespacesShouldThrow() {\n+        //given\n+        String string = \"   \";\n+\n+        try {\n+            //when\n+            Validate.notBlank(string, \"Message\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            //then\n+            assertEquals(\"Message\", e.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotBlankMsgEmptyStringShouldThrow() {\n+        //given\n+        String string = \"\";\n+\n+        try {\n+            //when\n+            Validate.notBlank(string, \"Message\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            //then\n+            assertEquals(\"Message\", e.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotBlankNotBlankStringShouldNotThrow() {\n+        //given\n+        String string = \"abc\";\n+\n+        //when\n+        Validate.notBlank(string);\n+\n+        //then should not throw\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotBlankNotBlankStringWithWhitespacesShouldNotThrow() {\n+        //given\n+        String string = \"  abc   \";\n+\n+        //when\n+        Validate.notBlank(string);\n+\n+        //then should not throw\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotBlankNotBlankStringWithNewlinesShouldNotThrow() {\n+        //given\n+        String string = \" \\n \\t abc \\r \\n \";\n+\n+        //when\n+        Validate.notBlank(string);\n+\n+        //then should not throw\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotBlankMsgNotBlankStringShouldNotThrow() {\n+        //given\n+        String string = \"abc\";\n+\n+        //when\n+        Validate.notBlank(string, \"Message\");\n+\n+        //then should not throw\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotBlankMsgNotBlankStringWithWhitespacesShouldNotThrow() {\n+        //given\n+        String string = \"  abc   \";\n+\n+        //when\n+        Validate.notBlank(string, \"Message\");\n+\n+        //then should not throw\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotBlankMsgNotBlankStringWithNewlinesShouldNotThrow() {\n+        //given\n+        String string = \" \\n \\t abc \\r \\n \";\n+\n+        //when\n+        Validate.notBlank(string, \"Message\");\n+\n+        //then should not throw\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotBlankReturnValues1() {\n+        String str = \"Hi\";\n+        String test = Validate.notBlank(str);\n+        assertSame(str, test);\n+    }\n+\n+    public void testNotBlankReturnValues2() {\n+        String str = \"Hi\";\n+        String test = Validate.notBlank(str, \"Message\");\n+        assertSame(str, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testNoNullElementsArray1() {\n+        String[] array = new String[] {\"a\", \"b\"};\n+        Validate.noNullElements(array);\n+        try {\n+            Validate.noNullElements((Object[]) null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            assertEquals(\"The validated object is null\", ex.getMessage());\n+        }\n+        array[1] = null;\n+        try {\n+            Validate.noNullElements(array);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated array contains null element at index: 1\", ex.getMessage());\n+        }\n+        \n+        array = new String[] {\"a\", \"b\"};\n+        String[] test = Validate.noNullElements(array);\n+        assertSame(array, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNoNullElementsArray2() {\n+        String[] array = new String[] {\"a\", \"b\"};\n+        Validate.noNullElements(array, \"MSG\");\n+        try {\n+            Validate.noNullElements((Object[]) null, \"MSG\");\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            assertEquals(\"The validated object is null\", ex.getMessage());\n+        }\n+        array[1] = null;\n+        try {\n+            Validate.noNullElements(array, \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        \n+        array = new String[] {\"a\", \"b\"};\n+        String[] test = Validate.noNullElements(array, \"Message\");\n+        assertSame(array, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testNoNullElementsCollection1() {\n+        List<String> coll = new ArrayList<String>();\n+        coll.add(\"a\");\n+        coll.add(\"b\");\n+        Validate.noNullElements(coll);\n+        try {\n+            Validate.noNullElements((Collection<?>) null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            assertEquals(\"The validated object is null\", ex.getMessage());\n+        }\n+        coll.set(1, null);\n+        try {\n+            Validate.noNullElements(coll);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated collection contains null element at index: 1\", ex.getMessage());\n+        }\n+        \n+        coll.set(1, \"b\");\n+        List<String> test = Validate.noNullElements(coll);\n+        assertSame(coll, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNoNullElementsCollection2() {\n+        List<String> coll = new ArrayList<String>();\n+        coll.add(\"a\");\n+        coll.add(\"b\");\n+        Validate.noNullElements(coll, \"MSG\");\n+        try {\n+            Validate.noNullElements((Collection<?>) null, \"MSG\");\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            assertEquals(\"The validated object is null\", ex.getMessage());\n+        }\n+        coll.set(1, null);\n+        try {\n+            Validate.noNullElements(coll, \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        \n+        coll.set(1, \"b\");\n+        List<String> test = Validate.noNullElements(coll, \"Message\");\n+        assertSame(coll, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new Validate());\n+        Constructor<?>[] cons = Validate.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(Validate.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(Validate.class.getModifiers()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testValidIndex_withMessage_array() {\n+        Object[] array = new Object[2];\n+        Validate.validIndex(array, 0, \"Broken: \");\n+        Validate.validIndex(array, 1, \"Broken: \");\n+        try {\n+            Validate.validIndex(array, -1, \"Broken: \");\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            assertEquals(\"Broken: \", ex.getMessage());\n+        }\n+        try {\n+            Validate.validIndex(array, 2, \"Broken: \");\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            assertEquals(\"Broken: \", ex.getMessage());\n+        }\n+        \n+        String[] strArray = new String[] {\"Hi\"};\n+        String[] test = Validate.noNullElements(strArray, \"Message\");\n+        assertSame(strArray, test);\n+    }\n+\n+    public void testValidIndex_array() {\n+        Object[] array = new Object[2];\n+        Validate.validIndex(array, 0);\n+        Validate.validIndex(array, 1);\n+        try {\n+            Validate.validIndex(array, -1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            assertEquals(\"The validated array index is invalid: -1\", ex.getMessage());\n+        }\n+        try {\n+            Validate.validIndex(array, 2);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            assertEquals(\"The validated array index is invalid: 2\", ex.getMessage());\n+        }\n+        \n+        String[] strArray = new String[] {\"Hi\"};\n+        String[] test = Validate.noNullElements(strArray);\n+        assertSame(strArray, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testValidIndex_withMessage_collection() {\n+        Collection<String> coll = new ArrayList<String>();\n+        coll.add(null);\n+        coll.add(null);\n+        Validate.validIndex(coll, 0, \"Broken: \");\n+        Validate.validIndex(coll, 1, \"Broken: \");\n+        try {\n+            Validate.validIndex(coll, -1, \"Broken: \");\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            assertEquals(\"Broken: \", ex.getMessage());\n+        }\n+        try {\n+            Validate.validIndex(coll, 2, \"Broken: \");\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            assertEquals(\"Broken: \", ex.getMessage());\n+        }\n+        \n+        List<String> strColl = Arrays.asList(new String[] {\"Hi\"});\n+        List<String> test = Validate.validIndex(strColl, 0, \"Message\");\n+        assertSame(strColl, test);\n+    }\n+\n+    public void testValidIndex_collection() {\n+        Collection<String> coll = new ArrayList<String>();\n+        coll.add(null);\n+        coll.add(null);\n+        Validate.validIndex(coll, 0);\n+        Validate.validIndex(coll, 1);\n+        try {\n+            Validate.validIndex(coll, -1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            assertEquals(\"The validated collection index is invalid: -1\", ex.getMessage());\n+        }\n+        try {\n+            Validate.validIndex(coll, 2);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            assertEquals(\"The validated collection index is invalid: 2\", ex.getMessage());\n+        }\n+        \n+        List<String> strColl = Arrays.asList(new String[] {\"Hi\"});\n+        List<String> test = Validate.validIndex(strColl, 0);\n+        assertSame(strColl, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testValidIndex_withMessage_charSequence() {\n+        CharSequence str = \"Hi\";\n+        Validate.validIndex(str, 0, \"Broken: \");\n+        Validate.validIndex(str, 1, \"Broken: \");\n+        try {\n+            Validate.validIndex(str, -1, \"Broken: \");\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            assertEquals(\"Broken: \", ex.getMessage());\n+        }\n+        try {\n+            Validate.validIndex(str, 2, \"Broken: \");\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            assertEquals(\"Broken: \", ex.getMessage());\n+        }\n+        \n+        String input = \"Hi\";\n+        String test = Validate.validIndex(input, 0, \"Message\");\n+        assertSame(input, test);\n+    }\n+\n+    public void testValidIndex_charSequence() {\n+        CharSequence str = \"Hi\";\n+        Validate.validIndex(str, 0);\n+        Validate.validIndex(str, 1);\n+        try {\n+            Validate.validIndex(str, -1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            assertEquals(\"The validated character sequence index is invalid: -1\", ex.getMessage());\n+        }\n+        try {\n+            Validate.validIndex(str, 2);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            assertEquals(\"The validated character sequence index is invalid: 2\", ex.getMessage());\n+        }\n+        \n+        String input = \"Hi\";\n+        String test = Validate.validIndex(input, 0);\n+        assertSame(input, test);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/WordUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Unit tests for WordUtils class.\n+ * \n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @version $Id$\n+ */\n+public class WordUtilsTest extends TestCase {\n+\n+    public WordUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(WordUtilsTest.class);\n+        suite.setName(\"WordUtilsTests\");\n+        return suite;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new WordUtils());\n+        Constructor<?>[] cons = WordUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(WordUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(WordUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testWrap_StringInt() {\n+        assertEquals(null, WordUtils.wrap(null, 20));\n+        assertEquals(null, WordUtils.wrap(null, -1));\n+        \n+        assertEquals(\"\", WordUtils.wrap(\"\", 20));\n+        assertEquals(\"\", WordUtils.wrap(\"\", -1));\n+        \n+        // normal\n+        String systemNewLine = System.getProperty(\"line.separator\");\n+        String input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n+        String expected = \"Here is one line of\" + systemNewLine + \"text that is going\" \n+            + systemNewLine + \"to be wrapped after\" + systemNewLine + \"20 columns.\";\n+        assertEquals(expected, WordUtils.wrap(input, 20));\n+        \n+        // long word at end\n+        input = \"Click here to jump to the jakarta website - http://jakarta.apache.org\";\n+        expected = \"Click here to jump\" + systemNewLine + \"to the jakarta\" + systemNewLine \n+            + \"website -\" + systemNewLine + \"http://jakarta.apache.org\";\n+        assertEquals(expected, WordUtils.wrap(input, 20));\n+        \n+        // long word in middle\n+        input = \"Click here, http://jakarta.apache.org, to jump to the jakarta website\";\n+        expected = \"Click here,\" + systemNewLine + \"http://jakarta.apache.org,\" + systemNewLine \n+            + \"to jump to the\" + systemNewLine + \"jakarta website\";\n+        assertEquals(expected, WordUtils.wrap(input, 20));\n+    }\n+    \n+    public void testWrap_StringIntStringBoolean() {\n+        assertEquals(null, WordUtils.wrap(null, 20, \"\\n\", false));\n+        assertEquals(null, WordUtils.wrap(null, 20, \"\\n\", true));\n+        assertEquals(null, WordUtils.wrap(null, 20, null, true));\n+        assertEquals(null, WordUtils.wrap(null, 20, null, false));\n+        assertEquals(null, WordUtils.wrap(null, -1, null, true));\n+        assertEquals(null, WordUtils.wrap(null, -1, null, false));\n+        \n+        assertEquals(\"\", WordUtils.wrap(\"\", 20, \"\\n\", false));\n+        assertEquals(\"\", WordUtils.wrap(\"\", 20, \"\\n\", true));\n+        assertEquals(\"\", WordUtils.wrap(\"\", 20, null, false));\n+        assertEquals(\"\", WordUtils.wrap(\"\", 20, null, true));\n+        assertEquals(\"\", WordUtils.wrap(\"\", -1, null, false));\n+        assertEquals(\"\", WordUtils.wrap(\"\", -1, null, true));\n+        \n+        // normal\n+        String input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n+        String expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", false));\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", true));\n+\n+        // unusual newline char\n+        input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n+        expected = \"Here is one line of<br />text that is going<br />to be wrapped after<br />20 columns.\";\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"<br />\", false));\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"<br />\", true));\n+\n+        // short line length\n+        input = \"Here is one line\";\n+        expected = \"Here\\nis one\\nline\";\n+        assertEquals(expected, WordUtils.wrap(input, 6, \"\\n\", false));\n+        expected = \"Here\\nis\\none\\nline\";\n+        assertEquals(expected, WordUtils.wrap(input, 2, \"\\n\", false));\n+        assertEquals(expected, WordUtils.wrap(input, -1, \"\\n\", false));\n+\n+        // system newline char\n+        String systemNewLine = System.getProperty(\"line.separator\");\n+        input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n+        expected = \"Here is one line of\" + systemNewLine + \"text that is going\" + systemNewLine \n+            + \"to be wrapped after\" + systemNewLine + \"20 columns.\";\n+        assertEquals(expected, WordUtils.wrap(input, 20, null, false));\n+        assertEquals(expected, WordUtils.wrap(input, 20, null, true));\n+\n+        // with extra spaces\n+        input = \" Here:  is  one  line  of  text  that  is  going  to  be  wrapped  after  20  columns.\";\n+        expected = \"Here:  is  one  line\\nof  text  that  is \\ngoing  to  be \\nwrapped  after  20 \\ncolumns.\";\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", false));\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", true));\n+        \n+        // with tab\n+        input = \"Here is\\tone line of text that is going to be wrapped after 20 columns.\";\n+        expected = \"Here is\\tone line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", false));\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", true));\n+        \n+        // with tab at wrapColumn\n+        input = \"Here is one line of\\ttext that is going to be wrapped after 20 columns.\";\n+        expected = \"Here is one line\\nof\\ttext that is\\ngoing to be wrapped\\nafter 20 columns.\";\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", false));\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", true));\n+        \n+        // difference because of long word\n+        input = \"Click here to jump to the jakarta website - http://jakarta.apache.org\";\n+        expected = \"Click here to jump\\nto the jakarta\\nwebsite -\\nhttp://jakarta.apache.org\";\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", false));\n+        expected = \"Click here to jump\\nto the jakarta\\nwebsite -\\nhttp://jakarta.apach\\ne.org\";\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", true));\n+        \n+        // difference because of long word in middle\n+        input = \"Click here, http://jakarta.apache.org, to jump to the jakarta website\";\n+        expected = \"Click here,\\nhttp://jakarta.apache.org,\\nto jump to the\\njakarta website\";\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", false));\n+        expected = \"Click here,\\nhttp://jakarta.apach\\ne.org, to jump to\\nthe jakarta website\";\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", true));\n+//        System.err.println(expected);\n+//        System.err.println(WordUtils.wrap(input, 20, \"\\n\", false));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testCapitalize_String() {\n+        assertEquals(null, WordUtils.capitalize(null));\n+        assertEquals(\"\", WordUtils.capitalize(\"\"));\n+        assertEquals(\"  \", WordUtils.capitalize(\"  \"));\n+        \n+        assertEquals(\"I\", WordUtils.capitalize(\"I\") );\n+        assertEquals(\"I\", WordUtils.capitalize(\"i\") );\n+        assertEquals(\"I Am Here 123\", WordUtils.capitalize(\"i am here 123\") );\n+        assertEquals(\"I Am Here 123\", WordUtils.capitalize(\"I Am Here 123\") );\n+        assertEquals(\"I Am HERE 123\", WordUtils.capitalize(\"i am HERE 123\") );\n+        assertEquals(\"I AM HERE 123\", WordUtils.capitalize(\"I AM HERE 123\") );\n+    }\n+    \n+    public void testCapitalizeWithDelimiters_String() {\n+        assertEquals(null, WordUtils.capitalize(null, null));\n+        assertEquals(\"\", WordUtils.capitalize(\"\", new char[0]));\n+        assertEquals(\"  \", WordUtils.capitalize(\"  \", new char[0]));\n+        \n+        char[] chars = new char[] { '-', '+', ' ', '@' };\n+        assertEquals(\"I\", WordUtils.capitalize(\"I\", chars) );\n+        assertEquals(\"I\", WordUtils.capitalize(\"i\", chars) );\n+        assertEquals(\"I-Am Here+123\", WordUtils.capitalize(\"i-am here+123\", chars) );\n+        assertEquals(\"I Am+Here-123\", WordUtils.capitalize(\"I Am+Here-123\", chars) );\n+        assertEquals(\"I+Am-HERE 123\", WordUtils.capitalize(\"i+am-HERE 123\", chars) );\n+        assertEquals(\"I-AM HERE+123\", WordUtils.capitalize(\"I-AM HERE+123\", chars) );\n+        chars = new char[] {'.'};\n+        assertEquals(\"I aM.Fine\", WordUtils.capitalize(\"i aM.fine\", chars) );\n+        assertEquals(\"I Am.fine\", WordUtils.capitalize(\"i am.fine\", null) );\n+    }\n+\n+    public void testCapitalizeFully_String() {\n+        assertEquals(null, WordUtils.capitalizeFully(null));\n+        assertEquals(\"\", WordUtils.capitalizeFully(\"\"));\n+        assertEquals(\"  \", WordUtils.capitalizeFully(\"  \"));\n+        \n+        assertEquals(\"I\", WordUtils.capitalizeFully(\"I\") );\n+        assertEquals(\"I\", WordUtils.capitalizeFully(\"i\") );\n+        assertEquals(\"I Am Here 123\", WordUtils.capitalizeFully(\"i am here 123\") );\n+        assertEquals(\"I Am Here 123\", WordUtils.capitalizeFully(\"I Am Here 123\") );\n+        assertEquals(\"I Am Here 123\", WordUtils.capitalizeFully(\"i am HERE 123\") );\n+        assertEquals(\"I Am Here 123\", WordUtils.capitalizeFully(\"I AM HERE 123\") );\n+    }\n+    \n+    public void testCapitalizeFullyWithDelimiters_String() {\n+        assertEquals(null, WordUtils.capitalizeFully(null, null));\n+        assertEquals(\"\", WordUtils.capitalizeFully(\"\", new char[0]));\n+        assertEquals(\"  \", WordUtils.capitalizeFully(\"  \", new char[0]));\n+        \n+        char[] chars = new char[] { '-', '+', ' ', '@' };\n+        assertEquals(\"I\", WordUtils.capitalizeFully(\"I\", chars) );\n+        assertEquals(\"I\", WordUtils.capitalizeFully(\"i\", chars) );\n+        assertEquals(\"I-Am Here+123\", WordUtils.capitalizeFully(\"i-am here+123\", chars) );\n+        assertEquals(\"I Am+Here-123\", WordUtils.capitalizeFully(\"I Am+Here-123\", chars) );\n+        assertEquals(\"I+Am-Here 123\", WordUtils.capitalizeFully(\"i+am-HERE 123\", chars) );\n+        assertEquals(\"I-Am Here+123\", WordUtils.capitalizeFully(\"I-AM HERE+123\", chars) );\n+        chars = new char[] {'.'};\n+        assertEquals(\"I am.Fine\", WordUtils.capitalizeFully(\"i aM.fine\", chars) );\n+        assertEquals(\"I Am.fine\", WordUtils.capitalizeFully(\"i am.fine\", null) );\n+    }\n+\n+    public void testUncapitalize_String() {\n+        assertEquals(null, WordUtils.uncapitalize(null));\n+        assertEquals(\"\", WordUtils.uncapitalize(\"\"));\n+        assertEquals(\"  \", WordUtils.uncapitalize(\"  \"));\n+        \n+        assertEquals(\"i\", WordUtils.uncapitalize(\"I\") );\n+        assertEquals(\"i\", WordUtils.uncapitalize(\"i\") );\n+        assertEquals(\"i am here 123\", WordUtils.uncapitalize(\"i am here 123\") );\n+        assertEquals(\"i am here 123\", WordUtils.uncapitalize(\"I Am Here 123\") );\n+        assertEquals(\"i am hERE 123\", WordUtils.uncapitalize(\"i am HERE 123\") );\n+        assertEquals(\"i aM hERE 123\", WordUtils.uncapitalize(\"I AM HERE 123\") );\n+    }\n+    \n+    public void testUncapitalizeWithDelimiters_String() {\n+        assertEquals(null, WordUtils.uncapitalize(null, null));\n+        assertEquals(\"\", WordUtils.uncapitalize(\"\", new char[0]));\n+        assertEquals(\"  \", WordUtils.uncapitalize(\"  \", new char[0]));\n+        \n+        char[] chars = new char[] { '-', '+', ' ', '@' };\n+        assertEquals(\"i\", WordUtils.uncapitalize(\"I\", chars) );\n+        assertEquals(\"i\", WordUtils.uncapitalize(\"i\", chars) );\n+        assertEquals(\"i am-here+123\", WordUtils.uncapitalize(\"i am-here+123\", chars) );\n+        assertEquals(\"i+am here-123\", WordUtils.uncapitalize(\"I+Am Here-123\", chars) );\n+        assertEquals(\"i-am+hERE 123\", WordUtils.uncapitalize(\"i-am+HERE 123\", chars) );\n+        assertEquals(\"i aM-hERE+123\", WordUtils.uncapitalize(\"I AM-HERE+123\", chars) );\n+        chars = new char[] {'.'};\n+        assertEquals(\"i AM.fINE\", WordUtils.uncapitalize(\"I AM.FINE\", chars) );\n+        assertEquals(\"i aM.FINE\", WordUtils.uncapitalize(\"I AM.FINE\", null) );\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testInitials_String() {\n+        assertEquals(null, WordUtils.initials(null));\n+        assertEquals(\"\", WordUtils.initials(\"\"));\n+        assertEquals(\"\", WordUtils.initials(\"  \"));\n+\n+        assertEquals(\"I\", WordUtils.initials(\"I\"));\n+        assertEquals(\"i\", WordUtils.initials(\"i\"));\n+        assertEquals(\"BJL\", WordUtils.initials(\"Ben John Lee\"));\n+        assertEquals(\"BJ\", WordUtils.initials(\"Ben J.Lee\"));\n+        assertEquals(\"BJ.L\", WordUtils.initials(\" Ben   John  . Lee\"));\n+        assertEquals(\"iah1\", WordUtils.initials(\"i am here 123\"));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testInitials_String_charArray() {\n+        char[] array = null;\n+        assertEquals(null, WordUtils.initials(null, array));\n+        assertEquals(\"\", WordUtils.initials(\"\", array));\n+        assertEquals(\"\", WordUtils.initials(\"  \", array));\n+        assertEquals(\"I\", WordUtils.initials(\"I\", array));\n+        assertEquals(\"i\", WordUtils.initials(\"i\", array));\n+        assertEquals(\"S\", WordUtils.initials(\"SJC\", array));\n+        assertEquals(\"BJL\", WordUtils.initials(\"Ben John Lee\", array));\n+        assertEquals(\"BJ\", WordUtils.initials(\"Ben J.Lee\", array));\n+        assertEquals(\"BJ.L\", WordUtils.initials(\" Ben   John  . Lee\", array));\n+        assertEquals(\"KO\", WordUtils.initials(\"Kay O'Murphy\", array));\n+        assertEquals(\"iah1\", WordUtils.initials(\"i am here 123\", array));\n+        \n+        array = new char[0];\n+        assertEquals(null, WordUtils.initials(null, array));\n+        assertEquals(\"\", WordUtils.initials(\"\", array));\n+        assertEquals(\"\", WordUtils.initials(\"  \", array));\n+        assertEquals(\"\", WordUtils.initials(\"I\", array));\n+        assertEquals(\"\", WordUtils.initials(\"i\", array));\n+        assertEquals(\"\", WordUtils.initials(\"SJC\", array));\n+        assertEquals(\"\", WordUtils.initials(\"Ben John Lee\", array));\n+        assertEquals(\"\", WordUtils.initials(\"Ben J.Lee\", array));\n+        assertEquals(\"\", WordUtils.initials(\" Ben   John  . Lee\", array));\n+        assertEquals(\"\", WordUtils.initials(\"Kay O'Murphy\", array));\n+        assertEquals(\"\", WordUtils.initials(\"i am here 123\", array));\n+        \n+        array = \" \".toCharArray();\n+        assertEquals(null, WordUtils.initials(null, array));\n+        assertEquals(\"\", WordUtils.initials(\"\", array));\n+        assertEquals(\"\", WordUtils.initials(\"  \", array));\n+        assertEquals(\"I\", WordUtils.initials(\"I\", array));\n+        assertEquals(\"i\", WordUtils.initials(\"i\", array));\n+        assertEquals(\"S\", WordUtils.initials(\"SJC\", array));\n+        assertEquals(\"BJL\", WordUtils.initials(\"Ben John Lee\", array));\n+        assertEquals(\"BJ\", WordUtils.initials(\"Ben J.Lee\", array));\n+        assertEquals(\"BJ.L\", WordUtils.initials(\" Ben   John  . Lee\", array));\n+        assertEquals(\"KO\", WordUtils.initials(\"Kay O'Murphy\", array));\n+        assertEquals(\"iah1\", WordUtils.initials(\"i am here 123\", array));\n+        \n+        array = \" .\".toCharArray();\n+        assertEquals(null, WordUtils.initials(null, array));\n+        assertEquals(\"\", WordUtils.initials(\"\", array));\n+        assertEquals(\"\", WordUtils.initials(\"  \", array));\n+        assertEquals(\"I\", WordUtils.initials(\"I\", array));\n+        assertEquals(\"i\", WordUtils.initials(\"i\", array));\n+        assertEquals(\"S\", WordUtils.initials(\"SJC\", array));\n+        assertEquals(\"BJL\", WordUtils.initials(\"Ben John Lee\", array));\n+        assertEquals(\"BJL\", WordUtils.initials(\"Ben J.Lee\", array));\n+        assertEquals(\"BJL\", WordUtils.initials(\" Ben   John  . Lee\", array));\n+        assertEquals(\"KO\", WordUtils.initials(\"Kay O'Murphy\", array));\n+        assertEquals(\"iah1\", WordUtils.initials(\"i am here 123\", array));\n+        \n+        array = \" .'\".toCharArray();\n+        assertEquals(null, WordUtils.initials(null, array));\n+        assertEquals(\"\", WordUtils.initials(\"\", array));\n+        assertEquals(\"\", WordUtils.initials(\"  \", array));\n+        assertEquals(\"I\", WordUtils.initials(\"I\", array));\n+        assertEquals(\"i\", WordUtils.initials(\"i\", array));\n+        assertEquals(\"S\", WordUtils.initials(\"SJC\", array));\n+        assertEquals(\"BJL\", WordUtils.initials(\"Ben John Lee\", array));\n+        assertEquals(\"BJL\", WordUtils.initials(\"Ben J.Lee\", array));\n+        assertEquals(\"BJL\", WordUtils.initials(\" Ben   John  . Lee\", array));\n+        assertEquals(\"KOM\", WordUtils.initials(\"Kay O'Murphy\", array));\n+        assertEquals(\"iah1\", WordUtils.initials(\"i am here 123\", array));\n+        \n+        array = \"SIJo1\".toCharArray();\n+        assertEquals(null, WordUtils.initials(null, array));\n+        assertEquals(\"\", WordUtils.initials(\"\", array));\n+        assertEquals(\" \", WordUtils.initials(\"  \", array));\n+        assertEquals(\"\", WordUtils.initials(\"I\", array));\n+        assertEquals(\"i\", WordUtils.initials(\"i\", array));\n+        assertEquals(\"C\", WordUtils.initials(\"SJC\", array));\n+        assertEquals(\"Bh\", WordUtils.initials(\"Ben John Lee\", array));\n+        assertEquals(\"B.\", WordUtils.initials(\"Ben J.Lee\", array));\n+        assertEquals(\" h\", WordUtils.initials(\" Ben   John  . Lee\", array));\n+        assertEquals(\"K\", WordUtils.initials(\"Kay O'Murphy\", array));\n+        assertEquals(\"i2\", WordUtils.initials(\"i am here 123\", array));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testSwapCase_String() {\n+        assertEquals(null, WordUtils.swapCase(null));\n+        assertEquals(\"\", WordUtils.swapCase(\"\"));\n+        assertEquals(\"  \", WordUtils.swapCase(\"  \"));\n+        \n+        assertEquals(\"i\", WordUtils.swapCase(\"I\") );\n+        assertEquals(\"I\", WordUtils.swapCase(\"i\") );\n+        assertEquals(\"I AM HERE 123\", WordUtils.swapCase(\"i am here 123\") );\n+        assertEquals(\"i aM hERE 123\", WordUtils.swapCase(\"I Am Here 123\") );\n+        assertEquals(\"I AM here 123\", WordUtils.swapCase(\"i am HERE 123\") );\n+        assertEquals(\"i am here 123\", WordUtils.swapCase(\"I AM HERE 123\") );\n+\n+        String test = \"This String contains a TitleCase character: \\u01C8\";\n+        String expect = \"tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \\u01C9\";\n+        assertEquals(expect, WordUtils.swapCase(test));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testAbbreviate() {\n+        // check null and empty are returned respectively\n+        assertNull(WordUtils.abbreviate(null, 1,-1,\"\"));\n+        assertEquals(StringUtils.EMPTY, WordUtils.abbreviate(\"\", 1,-1,\"\"));\n+\n+        // test upper limit\n+        assertEquals(\"01234\", WordUtils.abbreviate(\"0123456789\", 0,5,\"\"));\n+        assertEquals(\"01234\", WordUtils.abbreviate(\"0123456789\", 5, 2,\"\"));\n+        assertEquals(\"012\", WordUtils.abbreviate(\"012 3456789\", 2, 5,\"\"));\n+        assertEquals(\"012 3\", WordUtils.abbreviate(\"012 3456789\", 5, 2,\"\"));\n+        assertEquals(\"0123456789\", WordUtils.abbreviate(\"0123456789\", 0,-1,\"\"));\n+\n+        // test upper limit + append string\n+        assertEquals(\"01234-\", WordUtils.abbreviate(\"0123456789\", 0,5,\"-\"));\n+        assertEquals(\"01234-\", WordUtils.abbreviate(\"0123456789\", 5, 2,\"-\"));\n+        assertEquals(\"012\", WordUtils.abbreviate(\"012 3456789\", 2, 5, null));\n+        assertEquals(\"012 3\", WordUtils.abbreviate(\"012 3456789\", 5, 2,\"\"));\n+        assertEquals(\"0123456789\", WordUtils.abbreviate(\"0123456789\", 0,-1,\"\"));\n+\n+        // test lower value\n+        assertEquals(\"012\", WordUtils.abbreviate(\"012 3456789\", 0,5, null));\n+        assertEquals(\"01234\", WordUtils.abbreviate(\"01234 56789\", 5, 10, null));\n+        assertEquals(\"01 23 45 67\", WordUtils.abbreviate(\"01 23 45 67 89\", 9, -1, null));\n+        assertEquals(\"01 23 45 6\", WordUtils.abbreviate(\"01 23 45 67 89\", 9, 10, null));\n+        assertEquals(\"0123456789\", WordUtils.abbreviate(\"0123456789\", 15, 20, null));\n+\n+        // test lower value + append\n+        assertEquals(\"012\", WordUtils.abbreviate(\"012 3456789\", 0,5, null));\n+        assertEquals(\"01234-\", WordUtils.abbreviate(\"01234 56789\", 5, 10, \"-\"));\n+        assertEquals(\"01 23 45 67abc\", WordUtils.abbreviate(\"01 23 45 67 89\", 9, -1, \"abc\"));\n+        assertEquals(\"01 23 45 6\", WordUtils.abbreviate(\"01 23 45 67 89\", 9, 10, \"\"));\n+\n+        // others\n+        assertEquals(\"\", WordUtils.abbreviate(\"0123456790\", 0,0,\"\"));\n+        assertEquals(\"\", WordUtils.abbreviate(\" 0123456790\", 0,-1,\"\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/builder/CompareToBuilderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.math.BigInteger;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.builder.CompareToBuilder}.\n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:sdowney@panix.com\">Steve Downey</a>\n+ * @version $Id$\n+ */\n+public class CompareToBuilderTest extends TestCase {\n+\n+  public CompareToBuilderTest(String name) {\n+    super(name);\n+  }\n+     public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(CompareToBuilderTest.class);\n+        suite.setName(\"CompareToBuilder Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    static class TestObject implements Comparable<TestObject> {\n+        private int a;\n+        public TestObject(int a) {\n+            this.a = a;\n+        }\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) {\n+                return true;\n+            }\n+            if (!(o instanceof TestObject)) {\n+                return false;\n+            }\n+            TestObject rhs = (TestObject) o;\n+            return (a == rhs.a);\n+        }\n+\n+        public void setA(int a) {\n+            this.a = a;\n+        }\n+\n+        public int getA() {\n+            return a;\n+        }\n+        public int compareTo(TestObject rhs) {\n+            return (a < rhs.a) ? -1 : (a > rhs.a) ? +1 : 0;\n+        }\n+    }\n+\n+    static class TestSubObject extends TestObject {\n+        private int b;\n+        public TestSubObject() {\n+            super(0);\n+        }\n+        public TestSubObject(int a, int b) {\n+            super(a);\n+            this.b = b;\n+        }\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) {\n+                return true;\n+            }\n+            if (!(o instanceof TestSubObject)) {\n+                return false;\n+            }\n+            TestSubObject rhs = (TestSubObject) o;\n+            return super.equals(o) && (b == rhs.b);\n+        }\n+    }\n+\n+    static class TestTransientSubObject extends TestObject {\n+        @SuppressWarnings(\"unused\")\n+        private transient int t;\n+        public TestTransientSubObject(int a, int t) {\n+            super(a);\n+            this.t = t;\n+        }\n+    }\n+    \n+    public void testReflectionCompare() {\n+        TestObject o1 = new TestObject(4);\n+        TestObject o2 = new TestObject(4);\n+        assertTrue(CompareToBuilder.reflectionCompare(o1, o1) == 0);\n+        assertTrue(CompareToBuilder.reflectionCompare(o1, o2) == 0);\n+        o2.setA(5);\n+        assertTrue(CompareToBuilder.reflectionCompare(o1, o2) < 0);\n+        assertTrue(CompareToBuilder.reflectionCompare(o2, o1) > 0);\n+    }\n+\n+    public void testReflectionCompareEx1() {\n+        TestObject o1 = new TestObject(4);\n+        try {\n+            CompareToBuilder.reflectionCompare(o1, null);\n+        } catch (NullPointerException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testReflectionCompareEx2() {\n+        TestObject o1 = new TestObject(4);\n+        Object o2 = new Object();\n+        try {\n+            CompareToBuilder.reflectionCompare(o1, o2);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    public void testReflectionHierarchyCompare() {\n+        testReflectionHierarchyCompare(false, null);\n+    }\n+    \n+    public void testReflectionHierarchyCompareExcludeFields() {\n+        String[] excludeFields = new String[] { \"b\" };\n+        testReflectionHierarchyCompare(true, excludeFields);\n+        \n+        TestSubObject x;\n+        TestSubObject y;\n+        TestSubObject z;\n+        \n+        x = new TestSubObject(1, 1);\n+        y = new TestSubObject(2, 1);\n+        z = new TestSubObject(3, 1);\n+        assertXYZCompareOrder(x, y, z, true, excludeFields);\n+\n+        x = new TestSubObject(1, 3);\n+        y = new TestSubObject(2, 2);\n+        z = new TestSubObject(3, 1);\n+        assertXYZCompareOrder(x, y, z, true, excludeFields);\n+    }\n+    \n+    public void testReflectionHierarchyCompareTransients() {\n+        testReflectionHierarchyCompare(true, null);\n+\n+        TestTransientSubObject x;\n+        TestTransientSubObject y;\n+        TestTransientSubObject z;\n+\n+        x = new TestTransientSubObject(1, 1);\n+        y = new TestTransientSubObject(2, 2);\n+        z = new TestTransientSubObject(3, 3);\n+        assertXYZCompareOrder(x, y, z, true, null);\n+        \n+        x = new TestTransientSubObject(1, 1);\n+        y = new TestTransientSubObject(1, 2);\n+        z = new TestTransientSubObject(1, 3);\n+        assertXYZCompareOrder(x, y, z, true, null);  \n+    }\n+    \n+    private void assertXYZCompareOrder(Object x, Object y, Object z, boolean testTransients, String[] excludeFields) {\n+        assertTrue(0 == CompareToBuilder.reflectionCompare(x, x, testTransients, null, excludeFields));\n+        assertTrue(0 == CompareToBuilder.reflectionCompare(y, y, testTransients, null, excludeFields));\n+        assertTrue(0 == CompareToBuilder.reflectionCompare(z, z, testTransients, null, excludeFields));\n+        \n+        assertTrue(0 > CompareToBuilder.reflectionCompare(x, y, testTransients, null, excludeFields));\n+        assertTrue(0 > CompareToBuilder.reflectionCompare(x, z, testTransients, null, excludeFields));\n+        assertTrue(0 > CompareToBuilder.reflectionCompare(y, z, testTransients, null, excludeFields));\n+        \n+        assertTrue(0 < CompareToBuilder.reflectionCompare(y, x, testTransients, null, excludeFields));\n+        assertTrue(0 < CompareToBuilder.reflectionCompare(z, x, testTransients, null, excludeFields));\n+        assertTrue(0 < CompareToBuilder.reflectionCompare(z, y, testTransients, null, excludeFields));\n+    }\n+    \n+    public void testReflectionHierarchyCompare(boolean testTransients, String[] excludeFields) {\n+        TestObject to1 = new TestObject(1);\n+        TestObject to2 = new TestObject(2);\n+        TestObject to3 = new TestObject(3);\n+        TestSubObject tso1 = new TestSubObject(1, 1);\n+        TestSubObject tso2 = new TestSubObject(2, 2);\n+        TestSubObject tso3 = new TestSubObject(3, 3);\n+        \n+        assertReflectionCompareContract(to1, to1, to1, false, excludeFields);\n+        assertReflectionCompareContract(to1, to2, to3, false, excludeFields);\n+        assertReflectionCompareContract(tso1, tso1, tso1, false, excludeFields);\n+        assertReflectionCompareContract(tso1, tso2, tso3, false, excludeFields);\n+        assertReflectionCompareContract(\"1\", \"2\", \"3\", false, excludeFields);\n+        \n+        assertTrue(0 != CompareToBuilder.reflectionCompare(tso1, new TestSubObject(1, 0), testTransients));\n+        assertTrue(0 != CompareToBuilder.reflectionCompare(tso1, new TestSubObject(0, 1), testTransients));\n+\n+        // root class\n+        assertXYZCompareOrder(to1, to2, to3, true, null);\n+        // subclass  \n+        assertXYZCompareOrder(tso1, tso2, tso3, true, null);  \n+    }\n+\n+    /**\n+     * See \"Effective Java\" under \"Consider Implementing Comparable\".\n+     *  \n+     * @param x an object to compare \n+     * @param y an object to compare\n+     * @param z an object to compare\n+     * @param testTransients Whether to include transients in the comparison\n+     * @param excludeFields fields to exclude\n+     */\n+    public void assertReflectionCompareContract(Object x, Object y, Object z, boolean testTransients, String[] excludeFields) {\n+\n+        // signum\n+        assertTrue(reflectionCompareSignum(x, y, testTransients, excludeFields) == -reflectionCompareSignum(y, x, testTransients, excludeFields));\n+        \n+        // transitive\n+        if (CompareToBuilder.reflectionCompare(x, y, testTransients, null, excludeFields) > 0 \n+                && CompareToBuilder.reflectionCompare(y, z, testTransients, null, excludeFields) > 0){\n+            assertTrue(CompareToBuilder.reflectionCompare(x, z, testTransients, null, excludeFields) > 0);\n+        }\n+        \n+        // un-named\n+        if (CompareToBuilder.reflectionCompare(x, y, testTransients, null, excludeFields) == 0) {\n+            assertTrue(reflectionCompareSignum(x, z, testTransients, excludeFields) == -reflectionCompareSignum(y, z, testTransients, excludeFields));\n+        }\n+        \n+        // strongly recommended but not strictly required\n+        assertTrue((CompareToBuilder.reflectionCompare(x, y, testTransients) ==0 ) == EqualsBuilder.reflectionEquals(x, y, testTransients));\n+    }\n+    \n+    /**\n+     * Returns the signum of the result of comparing x and y with\n+     * <code>CompareToBuilder.reflectionCompare</code>\n+     * \n+     * @param lhs The \"left-hand-side\" of the comparison.\n+     * @param rhs The \"right-hand-side\" of the comparison.\n+     * @param testTransients Whether to include transients in the comparison\n+     * @param excludeFields fields to exclude\n+     * @return int The signum\n+     */\n+    private int reflectionCompareSignum(Object lhs, Object rhs, boolean testTransients, String[] excludeFields) {\n+        return BigInteger.valueOf(CompareToBuilder.reflectionCompare(lhs, rhs, testTransients)).signum();\n+    }\n+    \n+    public void testAppendSuper() {\n+        TestObject o1 = new TestObject(4);\n+        TestObject o2 = new TestObject(5);\n+        assertTrue(new CompareToBuilder().appendSuper(0).append(o1, o1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().appendSuper(0).append(o1, o2).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().appendSuper(0).append(o2, o1).toComparison() > 0);\n+        \n+        assertTrue(new CompareToBuilder().appendSuper(-1).append(o1, o1).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().appendSuper(-1).append(o1, o2).toComparison() < 0);\n+        \n+        assertTrue(new CompareToBuilder().appendSuper(1).append(o1, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().appendSuper(1).append(o1, o2).toComparison() > 0);\n+    }\n+    \n+    public void testObject() {\n+        TestObject o1 = new TestObject(4);\n+        TestObject o2 = new TestObject(4);\n+        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() == 0);\n+        o2.setA(5);\n+        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n+        \n+        assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((Object) null, (Object) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, o1).toComparison() < 0);\n+    }\n+\n+    public void testObjectEx2() {\n+        TestObject o1 = new TestObject(4);\n+        Object o2 = new Object();\n+        try {\n+            new CompareToBuilder().append(o1, o2);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    public void testObjectComparator() {\n+        String o1 = \"Fred\";\n+        String o2 = \"Fred\";\n+        assertTrue(new CompareToBuilder().append(o1, o1, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);\n+        o2 = \"FRED\";\n+        assertTrue(new CompareToBuilder().append(o1, o2, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);\n+        o2 = \"FREDA\";\n+        assertTrue(new CompareToBuilder().append(o1, o2, String.CASE_INSENSITIVE_ORDER).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1, String.CASE_INSENSITIVE_ORDER).toComparison() > 0);\n+        \n+        assertTrue(new CompareToBuilder().append(o1, null, String.CASE_INSENSITIVE_ORDER).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((Object) null, (Object) null, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, o1, String.CASE_INSENSITIVE_ORDER).toComparison() < 0);\n+    }\n+    \n+    public void testObjectComparatorNull() {\n+        String o1 = \"Fred\";\n+        String o2 = \"Fred\";\n+        assertTrue(new CompareToBuilder().append(o1, o1, null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2, null).toComparison() == 0);\n+        o2 = \"Zebra\";\n+        assertTrue(new CompareToBuilder().append(o1, o2, null).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1, null).toComparison() > 0);\n+        \n+        assertTrue(new CompareToBuilder().append(o1, null, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((Object) null, (Object) null, null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, o1, null).toComparison() < 0);\n+    }\n+\n+    public void testLong() {\n+        long o1 = 1L;\n+        long o2 = 2L;\n+        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Long.MAX_VALUE).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Long.MAX_VALUE, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Long.MIN_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Long.MIN_VALUE, o1).toComparison() < 0);\n+    }\n+\n+    public void testInt() {\n+        int o1 = 1;\n+        int o2 = 2;\n+        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Integer.MAX_VALUE).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Integer.MAX_VALUE, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Integer.MIN_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Integer.MIN_VALUE, o1).toComparison() < 0);\n+    }\n+\n+    public void testShort() {\n+        short o1 = 1;\n+        short o2 = 2;\n+        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Short.MAX_VALUE).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Short.MAX_VALUE, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Short.MIN_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Short.MIN_VALUE, o1).toComparison() < 0);\n+    }\n+\n+    public void testChar() {\n+        char o1 = 1;\n+        char o2 = 2;\n+        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Character.MAX_VALUE).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Character.MAX_VALUE, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Character.MIN_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Character.MIN_VALUE, o1).toComparison() < 0);\n+    }\n+\n+    public void testByte() {\n+        byte o1 = 1;\n+        byte o2 = 2;\n+        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Byte.MAX_VALUE).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Byte.MAX_VALUE, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Byte.MIN_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Byte.MIN_VALUE, o1).toComparison() < 0);\n+    }\n+\n+    public void testDouble() {\n+        double o1 = 1;\n+        double o2 = 2;\n+        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Double.MAX_VALUE).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Double.MAX_VALUE, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Double.MIN_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Double.MIN_VALUE, o1).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Double.NaN, Double.NaN).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(Double.NaN, Double.MAX_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Double.POSITIVE_INFINITY, Double.MAX_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Double.NEGATIVE_INFINITY, Double.MIN_VALUE).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o1, Double.NaN).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Double.NaN, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(-0.0, 0.0).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(0.0, -0.0).toComparison() > 0);\n+    }\n+\n+    public void testFloat() {\n+        float o1 = 1;\n+        float o2 = 2;\n+        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Float.MAX_VALUE).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Float.MAX_VALUE, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Float.MIN_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Float.MIN_VALUE, o1).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Float.NaN, Float.NaN).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(Float.NaN, Float.MAX_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Float.POSITIVE_INFINITY, Float.MAX_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Float.NEGATIVE_INFINITY, Float.MIN_VALUE).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o1, Float.NaN).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Float.NaN, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(-0.0, 0.0).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(0.0, -0.0).toComparison() > 0);\n+    }\n+\n+    public void testBoolean() {\n+        boolean o1 = true;\n+        boolean o2 = false;\n+        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o2, o2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() < 0);\n+    }\n+\n+    public void testObjectArray() {\n+        TestObject[] obj1 = new TestObject[2];\n+        obj1[0] = new TestObject(4);\n+        obj1[1] = new TestObject(5);\n+        TestObject[] obj2 = new TestObject[2];\n+        obj2[0] = new TestObject(4);\n+        obj2[1] = new TestObject(5);\n+        TestObject[] obj3 = new TestObject[3];\n+        obj3[0] = new TestObject(4);\n+        obj3[1] = new TestObject(5);\n+        obj3[2] = new TestObject(6);\n+        \n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+        \n+        obj1[1] = new TestObject(7);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n+    }\n+\n+    public void testLongArray() {\n+        long[] obj1 = new long[2];\n+        obj1[0] = 5L;\n+        obj1[1] = 6L;\n+        long[] obj2 = new long[2];\n+        obj2[0] = 5L;\n+        obj2[1] = 6L;\n+        long[] obj3 = new long[3];\n+        obj3[0] = 5L;\n+        obj3[1] = 6L;\n+        obj3[2] = 7L;\n+        \n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        obj1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n+    }\n+\n+    public void testIntArray() {\n+        int[] obj1 = new int[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        int[] obj2 = new int[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        int[] obj3 = new int[3];\n+        obj3[0] = 5;\n+        obj3[1] = 6;\n+        obj3[2] = 7;\n+\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        obj1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((int[]) null, (int[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n+    }\n+\n+    public void testShortArray() {\n+        short[] obj1 = new short[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        short[] obj2 = new short[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        short[] obj3 = new short[3];\n+        obj3[0] = 5;\n+        obj3[1] = 6;\n+        obj3[2] = 7;\n+\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        obj1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((short[]) null, (short[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n+    }\n+\n+    public void testCharArray() {\n+        char[] obj1 = new char[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        char[] obj2 = new char[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        char[] obj3 = new char[3];\n+        obj3[0] = 5;\n+        obj3[1] = 6;\n+        obj3[2] = 7;\n+\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        obj1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n+    }\n+\n+    public void testByteArray() {\n+        byte[] obj1 = new byte[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        byte[] obj2 = new byte[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        byte[] obj3 = new byte[3];\n+        obj3[0] = 5;\n+        obj3[1] = 6;\n+        obj3[2] = 7;\n+\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        obj1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((byte[]) null, (byte[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n+    }\n+\n+    public void testDoubleArray() {\n+        double[] obj1 = new double[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        double[] obj2 = new double[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        double[] obj3 = new double[3];\n+        obj3[0] = 5;\n+        obj3[1] = 6;\n+        obj3[2] = 7;\n+\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        obj1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((double[]) null, (double[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n+    }\n+\n+    public void testFloatArray() {\n+        float[] obj1 = new float[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        float[] obj2 = new float[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        float[] obj3 = new float[3];\n+        obj3[0] = 5;\n+        obj3[1] = 6;\n+        obj3[2] = 7;\n+\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        obj1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((float[]) null, (float[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n+    }\n+\n+    public void testBooleanArray() {\n+        boolean[] obj1 = new boolean[2];\n+        obj1[0] = true;\n+        obj1[1] = false;\n+        boolean[] obj2 = new boolean[2];\n+        obj2[0] = true;\n+        obj2[1] = false;\n+        boolean[] obj3 = new boolean[3];\n+        obj3[0] = true;\n+        obj3[1] = false;\n+        obj3[2] = true;\n+\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        obj1[1] = true;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((boolean[]) null, (boolean[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n+    }\n+\n+    public void testMultiLongArray() {\n+        long[][] array1 = new long[2][2];\n+        long[][] array2 = new long[2][2];\n+        long[][] array3 = new long[2][3];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+                array3[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        array3[1][2] = 100;\n+        array3[1][2] = 100;\n+        \n+        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);\n+        array1[1][1] = 200;\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);\n+    }\n+\n+    public void testMultiIntArray() {\n+        int[][] array1 = new int[2][2];\n+        int[][] array2 = new int[2][2];\n+        int[][] array3 = new int[2][3];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+                array3[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        array3[1][2] = 100;\n+        array3[1][2] = 100;\n+        \n+        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);\n+        array1[1][1] = 200;\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);\n+    }\n+\n+    public void testMultiShortArray() {\n+        short[][] array1 = new short[2][2];\n+        short[][] array2 = new short[2][2];\n+        short[][] array3 = new short[2][3];\n+        for (short i = 0; i < array1.length; ++i) {\n+            for (short j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (short)((i + 1) * (j + 1));\n+                array2[i][j] = (short)((i + 1) * (j + 1));\n+                array3[i][j] = (short)((i + 1) * (j + 1));\n+            }\n+        }\n+        array3[1][2] = 100;\n+        array3[1][2] = 100;\n+        \n+        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);\n+        array1[1][1] = 200;\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);\n+    }\n+\n+    public void testMultiCharArray() {\n+        char[][] array1 = new char[2][2];\n+        char[][] array2 = new char[2][2];\n+        char[][] array3 = new char[2][3];\n+        for (short i = 0; i < array1.length; ++i) {\n+            for (short j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (char)((i + 1) * (j + 1));\n+                array2[i][j] = (char)((i + 1) * (j + 1));\n+                array3[i][j] = (char)((i + 1) * (j + 1));\n+            }\n+        }\n+        array3[1][2] = 100;\n+        array3[1][2] = 100;\n+        \n+        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);\n+        array1[1][1] = 200;\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);\n+    }\n+\n+    public void testMultiByteArray() {\n+        byte[][] array1 = new byte[2][2];\n+        byte[][] array2 = new byte[2][2];\n+        byte[][] array3 = new byte[2][3];\n+        for (byte i = 0; i < array1.length; ++i) {\n+            for (byte j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (byte)((i + 1) * (j + 1));\n+                array2[i][j] = (byte)((i + 1) * (j + 1));\n+                array3[i][j] = (byte)((i + 1) * (j + 1));\n+            }\n+        }\n+        array3[1][2] = 100;\n+        array3[1][2] = 100;\n+        \n+        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);\n+        array1[1][1] = 127;\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);\n+    }\n+    \n+    public void testMultiFloatArray() {\n+        float[][] array1 = new float[2][2];\n+        float[][] array2 = new float[2][2];\n+        float[][] array3 = new float[2][3];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = ((i + 1) * (j + 1));\n+                array2[i][j] = ((i + 1) * (j + 1));\n+                array3[i][j] = ((i + 1) * (j + 1));\n+            }\n+        }\n+        array3[1][2] = 100;\n+        array3[1][2] = 100;\n+        \n+        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);\n+        array1[1][1] = 127;\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);\n+    }\n+\n+    public void testMultiDoubleArray() {\n+        double[][] array1 = new double[2][2];\n+        double[][] array2 = new double[2][2];\n+        double[][] array3 = new double[2][3];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = ((i + 1) * (j + 1));\n+                array2[i][j] = ((i + 1) * (j + 1));\n+                array3[i][j] = ((i + 1) * (j + 1));\n+            }\n+        }\n+        array3[1][2] = 100;\n+        array3[1][2] = 100;\n+        \n+        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);\n+        array1[1][1] = 127;\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);\n+    }\n+\n+    public void testMultiBooleanArray() {\n+        boolean[][] array1 = new boolean[2][2];\n+        boolean[][] array2 = new boolean[2][2];\n+        boolean[][] array3 = new boolean[2][3];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = ((i == 1) ^ (j == 1));\n+                array2[i][j] = ((i == 1) ^ (j == 1));\n+                array3[i][j] = ((i == 1) ^ (j == 1));\n+            }\n+        }\n+        array3[1][2] = false;\n+        array3[1][2] = false;\n+        \n+        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);\n+        array1[1][1] = true;\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);\n+    }\n+\n+    public void testRaggedArray() {\n+        long array1[][] = new long[2][];\n+        long array2[][] = new long[2][];\n+        long array3[][] = new long[3][];\n+        for (int i = 0; i < array1.length; ++i) {\n+            array1[i] = new long[2];\n+            array2[i] = new long[2];\n+            array3[i] = new long[3];\n+            for (int j = 0; j < array1[i].length; ++j) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+                array3[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        array3[1][2] = 100;\n+        array3[1][2] = 100;\n+        \n+        \n+        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);\n+        array1[1][1] = 200;\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);\n+    }\n+\n+    public void testMixedArray() {\n+        Object array1[] = new Object[2];\n+        Object array2[] = new Object[2];\n+        Object array3[] = new Object[2];\n+        for (int i = 0; i < array1.length; ++i) {\n+            array1[i] = new long[2];\n+            array2[i] = new long[2];\n+            array3[i] = new long[3];\n+            for (int j = 0; j < 2; ++j) {\n+                ((long[]) array1[i])[j] = (i + 1) * (j + 1);\n+                ((long[]) array2[i])[j] = (i + 1) * (j + 1);\n+                ((long[]) array3[i])[j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        ((long[]) array3[0])[2] = 1;\n+        ((long[]) array3[1])[2] = 1;\n+        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);\n+        ((long[]) array1[1])[1] = 200;\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);\n+    }\n+\n+    public void testObjectArrayHiddenByObject() {\n+        TestObject[] array1 = new TestObject[2];\n+        array1[0] = new TestObject(4);\n+        array1[1] = new TestObject(5);\n+        TestObject[] array2 = new TestObject[2];\n+        array2[0] = new TestObject(4);\n+        array2[1] = new TestObject(5);\n+        TestObject[] array3 = new TestObject[3];\n+        array3[0] = new TestObject(4);\n+        array3[1] = new TestObject(5);\n+        array3[2] = new TestObject(6);\n+        \n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        Object obj3 = array3;\n+        \n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        array1[1] = new TestObject(7);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+    }\n+\n+    public void testLongArrayHiddenByObject() {\n+        long[] array1 = new long[2];\n+        array1[0] = 5L;\n+        array1[1] = 6L;\n+        long[] array2 = new long[2];\n+        array2[0] = 5L;\n+        array2[1] = 6L;\n+        long[] array3 = new long[3];\n+        array3[0] = 5L;\n+        array3[1] = 6L;\n+        array3[2] = 7L;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        Object obj3 = array3;\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        array1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+    }\n+\n+    public void testIntArrayHiddenByObject() {\n+        int[] array1 = new int[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        int[] array2 = new int[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        int[] array3 = new int[3];\n+        array3[0] = 5;\n+        array3[1] = 6;\n+        array3[2] = 7;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        Object obj3 = array3;\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        array1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+    }\n+\n+    public void testShortArrayHiddenByObject() {\n+        short[] array1 = new short[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        short[] array2 = new short[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        short[] array3 = new short[3];\n+        array3[0] = 5;\n+        array3[1] = 6;\n+        array3[2] = 7;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        Object obj3 = array3;\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        array1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+    }\n+\n+    public void testCharArrayHiddenByObject() {\n+        char[] array1 = new char[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        char[] array2 = new char[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        char[] array3 = new char[3];\n+        array3[0] = 5;\n+        array3[1] = 6;\n+        array3[2] = 7;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        Object obj3 = array3;\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        array1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+    }\n+\n+    public void testByteArrayHiddenByObject() {\n+        byte[] array1 = new byte[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        byte[] array2 = new byte[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        byte[] array3 = new byte[3];\n+        array3[0] = 5;\n+        array3[1] = 6;\n+        array3[2] = 7;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        Object obj3 = array3;\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        array1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+    }\n+\n+    public void testDoubleArrayHiddenByObject() {\n+        double[] array1 = new double[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        double[] array2 = new double[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        double[] array3 = new double[3];\n+        array3[0] = 5;\n+        array3[1] = 6;\n+        array3[2] = 7;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        Object obj3 = array3;\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        array1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+    }\n+\n+    public void testFloatArrayHiddenByObject() {\n+        float[] array1 = new float[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        float[] array2 = new float[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        float[] array3 = new float[3];\n+        array3[0] = 5;\n+        array3[1] = 6;\n+        array3[2] = 7;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        Object obj3 = array3;\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        array1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+    }\n+\n+    public void testBooleanArrayHiddenByObject() {\n+        boolean[] array1 = new boolean[2];\n+        array1[0] = true;\n+        array1[1] = false;\n+        boolean[] array2 = new boolean[2];\n+        array2[0] = true;\n+        array2[1] = false;\n+        boolean[] array3 = new boolean[3];\n+        array3[0] = true;\n+        array3[1] = false;\n+        array3[2] = true;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        Object obj3 = array3;\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        array1[1] = true;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+    }\n+  \n+ }\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/builder/DefaultToStringStyleTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import org.apache.commons.lang.builder.ToStringStyleTest.Person;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.builder.DefaultToStringStyleTest}.\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class DefaultToStringStyleTest extends TestCase {\n+\n+    private final Integer base = new Integer(5);\n+    private final String baseStr = base.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(base));\n+    \n+    public DefaultToStringStyleTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(DefaultToStringStyleTest.class);\n+        suite.setName(\"DefaultToStringStyle Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);\n+    }\n+\n+    //----------------------------------------------------------------\n+    \n+    public void testBlank() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).toString());\n+    }\n+\n+    public void testAppendSuper() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").toString());\n+        \n+        assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[<null>,a=hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendSuper(null).append(\"a\", \"hello\").toString());\n+    }\n+    \n+    public void testObject() {\n+        Integer i3 = new Integer(3);\n+        Integer i4 = new Integer(4);\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) null).toString());\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(i3).toString());\n+        assertEquals(baseStr + \"[a=<null>]\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", i3).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", i3).append(\"b\", i4).toString());\n+        assertEquals(baseStr + \"[a=<Integer>]\", new ToStringBuilder(base).append(\"a\", i3, false).toString());\n+        assertEquals(baseStr + \"[a=<size=0>]\", new ToStringBuilder(base).append(\"a\", new ArrayList<Object>(), false).toString());\n+        assertEquals(baseStr + \"[a=[]]\", new ToStringBuilder(base).append(\"a\", new ArrayList<Object>(), true).toString());\n+        assertEquals(baseStr + \"[a=<size=0>]\", new ToStringBuilder(base).append(\"a\", new HashMap<Object, Object>(), false).toString());\n+        assertEquals(baseStr + \"[a={}]\", new ToStringBuilder(base).append(\"a\", new HashMap<Object, Object>(), true).toString());\n+        assertEquals(baseStr + \"[a=<size=0>]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], false).toString());\n+        assertEquals(baseStr + \"[a={}]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], true).toString());\n+    }\n+\n+    public void testPerson() {\n+        Person p = new Person();\n+        p.name = \"John Doe\";\n+        p.age = 33;\n+        p.smoker = false;\n+        String pBaseStr = p.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(p));\n+        assertEquals(pBaseStr + \"[name=John Doe,age=33,smoker=false]\", new ToStringBuilder(p).append(\"name\", p.name).append(\"age\", p.age).append(\"smoker\", p.smoker).toString());\n+    }\n+\n+    public void testLong() {\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(3L).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", 3L).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", 3L).append(\"b\", 4L).toString());\n+    }\n+\n+    public void testObjectArray() {\n+        Object[] array = new Object[] {null, base, new int[] {3, 6}};\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArray() {\n+        long[] array = new long[] {1, 2, -3, 4};\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArrayArray() {\n+        long[][] array = new long[][] {{1, 2}, null, {5}};\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/builder/EqualsBuilderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.util.Arrays;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.builder.EqualsBuilder}.\n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:sdowney@panix.com\">Steve Downey</a>\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author Maarten Coene\n+ * @version $Id$\n+ */\n+public class EqualsBuilderTest extends TestCase {\n+\n+    public EqualsBuilderTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(EqualsBuilderTest.class);\n+        suite.setName(\"EqualsBuilder Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    static class TestObject {\n+        private int a;\n+        public TestObject() {\n+        }\n+        public TestObject(int a) {\n+            this.a = a;\n+        }\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == null) { return false; }\n+            if (o == this) { return true; }\n+            if (o.getClass() != getClass()) {\n+                return false;\n+            }\n+\n+            TestObject rhs = (TestObject) o;\n+            return (a == rhs.a);\n+        }\n+\n+        public void setA(int a) {\n+            this.a = a;\n+        }\n+\n+        public int getA() {\n+            return a;\n+        }\n+    }\n+\n+    static class TestSubObject extends TestObject {\n+        private int b;\n+        public TestSubObject() {\n+            super(0);\n+        }\n+        public TestSubObject(int a, int b) {\n+            super(a);\n+            this.b = b;\n+        }\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == null) { return false; }\n+            if (o == this) { return true; }\n+            if (o.getClass() != getClass()) {\n+                return false;\n+            }\n+\n+            TestSubObject rhs = (TestSubObject) o;\n+            return super.equals(o) && (b == rhs.b);\n+        }\n+\n+        public void setB(int b) {\n+            this.b = b;\n+        }\n+\n+        public int getB() {\n+            return b;\n+        }\n+    }\n+    \n+    static class TestEmptySubObject extends TestObject {\n+        public TestEmptySubObject(int a) {\n+            super(a);\n+        }\n+    }\n+\n+    static class TestTSubObject extends TestObject {\n+        @SuppressWarnings(\"unused\")\n+        private transient int t;\n+        public TestTSubObject(int a, int t) {\n+            super(a);\n+            this.t = t;\n+        }\n+    }\n+\n+    static class TestTTSubObject extends TestTSubObject {\n+        @SuppressWarnings(\"unused\")\n+        private transient int tt;\n+        public TestTTSubObject(int a, int t, int tt) {\n+            super(a, t);\n+            this.tt = tt;\n+        }\n+    }\n+\n+    static class TestTTLeafObject extends TestTTSubObject {\n+        @SuppressWarnings(\"unused\")\n+        private int leafValue;\n+        public TestTTLeafObject(int a, int t, int tt, int leafValue) {\n+            super(a, t, tt);\n+            this.leafValue = leafValue;\n+        }\n+    }\n+\n+    static class TestTSubObject2 extends TestObject {\n+        private transient int t;\n+        public TestTSubObject2(int a, int t) {\n+            super(a);\n+        }\n+        public int getT() {\n+            return t;\n+        }\n+        public void setT(int t) {\n+            this.t = t;\n+        }\n+    }\n+\n+    public void testReflectionEquals() {\n+        TestObject o1 = new TestObject(4);\n+        TestObject o2 = new TestObject(5);\n+        assertTrue(EqualsBuilder.reflectionEquals(o1, o1));\n+        assertTrue(!EqualsBuilder.reflectionEquals(o1, o2));\n+        o2.setA(4);\n+        assertTrue(EqualsBuilder.reflectionEquals(o1, o2));\n+\n+        assertTrue(!EqualsBuilder.reflectionEquals(o1, this));\n+\n+        assertTrue(!EqualsBuilder.reflectionEquals(o1, null));\n+        assertTrue(!EqualsBuilder.reflectionEquals(null, o2));\n+        assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null));\n+    }\n+    \n+    public void testReflectionHierarchyEquals() {\n+        testReflectionHierarchyEquals(false);\n+        testReflectionHierarchyEquals(true);\n+        // Transients\n+        assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true));\n+        assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), false));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 0, 0, 4), new TestTTLeafObject(1, 2, 3, 4), true));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 0), true));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(0, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true));\n+    }\n+\n+    public void testReflectionHierarchyEquals(boolean testTransients) {\n+        TestObject to1 = new TestObject(4);\n+        TestObject to1Bis = new TestObject(4);\n+        TestObject to1Ter = new TestObject(4);\n+        TestObject to2 = new TestObject(5);\n+        TestEmptySubObject teso = new TestEmptySubObject(4);\n+        TestTSubObject ttso = new TestTSubObject(4, 1);\n+        TestTTSubObject tttso = new TestTTSubObject(4, 1, 2);\n+        TestTTLeafObject ttlo = new TestTTLeafObject(4, 1, 2, 3);\n+        TestSubObject tso1 = new TestSubObject(1, 4);\n+        TestSubObject tso1bis = new TestSubObject(1, 4);\n+        TestSubObject tso1ter = new TestSubObject(1, 4);\n+        TestSubObject tso2 = new TestSubObject(2, 5);\n+\n+        testReflectionEqualsEquivalenceRelationship(to1, to1Bis, to1Ter, to2, new TestObject(), testTransients);\n+        testReflectionEqualsEquivalenceRelationship(tso1, tso1bis, tso1ter, tso2, new TestSubObject(), testTransients);\n+\n+        // More sanity checks:\n+\n+        // same values\n+        assertTrue(EqualsBuilder.reflectionEquals(ttlo, ttlo, testTransients));\n+        assertTrue(EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(1, 10), testTransients));\n+        // same super values, diff sub values\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(1, 11), testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 11), new TestSubObject(1, 10), testTransients));\n+        // diff super values, same sub values\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(0, 10), new TestSubObject(1, 10), testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(0, 10), testTransients));\n+\n+        // mix super and sub types: equals\n+        assertTrue(EqualsBuilder.reflectionEquals(to1, teso, testTransients));\n+        assertTrue(EqualsBuilder.reflectionEquals(teso, to1, testTransients));\n+\n+        assertTrue(EqualsBuilder.reflectionEquals(to1, ttso, false)); // Force testTransients = false for this assert\n+        assertTrue(EqualsBuilder.reflectionEquals(ttso, to1, false)); // Force testTransients = false for this assert\n+\n+        assertTrue(EqualsBuilder.reflectionEquals(to1, tttso, false)); // Force testTransients = false for this assert\n+        assertTrue(EqualsBuilder.reflectionEquals(tttso, to1, false)); // Force testTransients = false for this assert\n+\n+        assertTrue(EqualsBuilder.reflectionEquals(ttso, tttso, false)); // Force testTransients = false for this assert\n+        assertTrue(EqualsBuilder.reflectionEquals(tttso, ttso, false)); // Force testTransients = false for this assert\n+\n+        // mix super and sub types: NOT equals\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(0), new TestEmptySubObject(1), testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestEmptySubObject(1), new TestObject(0), testTransients));\n+\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(0), new TestTSubObject(1, 1), testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestTSubObject(1, 1), new TestObject(0), testTransients));\n+\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(1), new TestSubObject(0, 10), testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(0, 10), new TestObject(1), testTransients));\n+\n+        assertTrue(!EqualsBuilder.reflectionEquals(to1, ttlo));\n+        assertTrue(!EqualsBuilder.reflectionEquals(tso1, this));\n+    }\n+\n+    /**\n+     * Equivalence relationship tests inspired by \"Effective Java\":\n+     * <ul>\n+     * <li>reflection</li>\n+     * <li>symmetry</li>\n+     * <li>transitive</li>\n+     * <li>consistency</li>\n+     * <li>non-null reference</li>\n+     * </ul>\n+     * @param to a TestObject\n+     * @param toBis a TestObject, equal to to and toTer\n+     * @param toTer Left hand side, equal to to and toBis\n+     * @param to2 a different TestObject\n+     * @param oToChange a TestObject that will be changed\n+     */\n+    public void testReflectionEqualsEquivalenceRelationship(\n+        TestObject to,\n+        TestObject toBis,\n+        TestObject toTer,\n+        TestObject to2,\n+        TestObject oToChange,\n+        boolean testTransients) {\n+\n+        // reflection test\n+        assertTrue(EqualsBuilder.reflectionEquals(to, to, testTransients));\n+        assertTrue(EqualsBuilder.reflectionEquals(to2, to2, testTransients));\n+\n+        // symmetry test\n+        assertTrue(EqualsBuilder.reflectionEquals(to, toBis, testTransients) && EqualsBuilder.reflectionEquals(toBis, to, testTransients));\n+\n+        // transitive test\n+        assertTrue(\n+            EqualsBuilder.reflectionEquals(to, toBis, testTransients)\n+                && EqualsBuilder.reflectionEquals(toBis, toTer, testTransients)\n+                && EqualsBuilder.reflectionEquals(to, toTer, testTransients));\n+\n+        // consistency test\n+        oToChange.setA(to.getA());\n+        if (oToChange instanceof TestSubObject) {\n+            ((TestSubObject) oToChange).setB(((TestSubObject) to).getB());\n+        }\n+        assertTrue(EqualsBuilder.reflectionEquals(oToChange, to, testTransients));\n+        assertTrue(EqualsBuilder.reflectionEquals(oToChange, to, testTransients));\n+        oToChange.setA(to.getA() + 1);\n+        if (oToChange instanceof TestSubObject) {\n+            ((TestSubObject) oToChange).setB(((TestSubObject) to).getB() + 1);\n+        }\n+        assertTrue(!EqualsBuilder.reflectionEquals(oToChange, to, testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(oToChange, to, testTransients));\n+\n+        // non-null reference test\n+        assertTrue(!EqualsBuilder.reflectionEquals(to, null, testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(to2, null, testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(null, to, testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(null, to2, testTransients));\n+        assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null, testTransients));\n+    }\n+\n+    public void testSuper() {\n+        TestObject o1 = new TestObject(4);\n+        TestObject o2 = new TestObject(5);\n+        assertEquals(true, new EqualsBuilder().appendSuper(true).append(o1, o1).isEquals());\n+        assertEquals(false, new EqualsBuilder().appendSuper(false).append(o1, o1).isEquals());\n+        assertEquals(false, new EqualsBuilder().appendSuper(true).append(o1, o2).isEquals());\n+        assertEquals(false, new EqualsBuilder().appendSuper(false).append(o1, o2).isEquals());\n+    }\n+\n+    public void testObject() {\n+        TestObject o1 = new TestObject(4);\n+        TestObject o2 = new TestObject(5);\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+        o2.setA(4);\n+        assertTrue(new EqualsBuilder().append(o1, o2).isEquals());\n+\n+        assertTrue(!new EqualsBuilder().append(o1, this).isEquals());\n+        \n+        assertTrue(!new EqualsBuilder().append(o1, null).isEquals());\n+        assertTrue(!new EqualsBuilder().append(null, o2).isEquals());\n+        assertTrue(new EqualsBuilder().append((Object) null, (Object) null).isEquals());\n+    }\n+\n+    public void testLong() {\n+        long o1 = 1L;\n+        long o2 = 2L;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+    }\n+\n+    public void testInt() {\n+        int o1 = 1;\n+        int o2 = 2;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+    }\n+\n+    public void testShort() {\n+        short o1 = 1;\n+        short o2 = 2;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+    }\n+\n+    public void testChar() {\n+        char o1 = 1;\n+        char o2 = 2;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+    }\n+\n+    public void testByte() {\n+        byte o1 = 1;\n+        byte o2 = 2;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+    }\n+\n+    public void testDouble() {\n+        double o1 = 1;\n+        double o2 = 2;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, Double.NaN).isEquals());\n+        assertTrue(new EqualsBuilder().append(Double.NaN, Double.NaN).isEquals());\n+        assertTrue(new EqualsBuilder().append(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY).isEquals());\n+    }\n+\n+    public void testFloat() {\n+        float o1 = 1;\n+        float o2 = 2;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, Float.NaN).isEquals());\n+        assertTrue(new EqualsBuilder().append(Float.NaN, Float.NaN).isEquals());\n+        assertTrue(new EqualsBuilder().append(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY).isEquals());\n+    }\n+\n+    public void testAccessors() {\n+        EqualsBuilder equalsBuilder = new EqualsBuilder();\n+        assertTrue(equalsBuilder.isEquals());\n+        equalsBuilder.setEquals(true);\n+        assertTrue(equalsBuilder.isEquals());\n+        equalsBuilder.setEquals(false);\n+        assertFalse(equalsBuilder.isEquals());\n+    }\n+    \n+    public void testBoolean() {\n+        boolean o1 = true;\n+        boolean o2 = false;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+    }\n+\n+    public void testObjectArray() {\n+        TestObject[] obj1 = new TestObject[3];\n+        obj1[0] = new TestObject(4);\n+        obj1[1] = new TestObject(5);\n+        obj1[2] = null;\n+        TestObject[] obj2 = new TestObject[3];\n+        obj2[0] = new TestObject(4);\n+        obj2[1] = new TestObject(5);\n+        obj2[2] = null;\n+        \n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj2, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1].setA(6);\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1].setA(5);\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[2] = obj1[1];\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[2] = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+                       \n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testLongArray() {\n+        long[] obj1 = new long[2];\n+        obj1[0] = 5L;\n+        obj1[1] = 6L;\n+        long[] obj2 = new long[2];\n+        obj2[0] = 5L;\n+        obj2[1] = 6L;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testIntArray() {\n+        int[] obj1 = new int[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        int[] obj2 = new int[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testShortArray() {\n+        short[] obj1 = new short[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        short[] obj2 = new short[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testCharArray() {\n+        char[] obj1 = new char[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        char[] obj2 = new char[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testByteArray() {\n+        byte[] obj1 = new byte[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        byte[] obj2 = new byte[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testDoubleArray() {\n+        double[] obj1 = new double[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        double[] obj2 = new double[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testFloatArray() {\n+        float[] obj1 = new float[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        float[] obj2 = new float[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testBooleanArray() {\n+        boolean[] obj1 = new boolean[2];\n+        obj1[0] = true;\n+        obj1[1] = false;\n+        boolean[] obj2 = new boolean[2];\n+        obj2[0] = true;\n+        obj2[1] = false;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = true;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testMultiLongArray() {\n+        long[][] array1 = new long[2][2];\n+        long[][] array2 = new long[2][2];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    public void testMultiIntArray() {\n+        int[][] array1 = new int[2][2];\n+        int[][] array2 = new int[2][2];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    public void testMultiShortArray() {\n+        short[][] array1 = new short[2][2];\n+        short[][] array2 = new short[2][2];\n+        for (short i = 0; i < array1.length; ++i) {\n+            for (short j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = i;\n+                array2[i][j] = i;\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    public void testMultiCharArray() {\n+        char[][] array1 = new char[2][2];\n+        char[][] array2 = new char[2][2];\n+        for (char i = 0; i < array1.length; ++i) {\n+            for (char j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = i;\n+                array2[i][j] = i;\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    public void testMultiByteArray() {\n+        byte[][] array1 = new byte[2][2];\n+        byte[][] array2 = new byte[2][2];\n+        for (byte i = 0; i < array1.length; ++i) {\n+            for (byte j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = i;\n+                array2[i][j] = i;\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+    public void testMultiFloatArray() {\n+        float[][] array1 = new float[2][2];\n+        float[][] array2 = new float[2][2];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    public void testMultiDoubleArray() {\n+        double[][] array1 = new double[2][2];\n+        double[][] array2 = new double[2][2];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    public void testMultiBooleanArray() {\n+        boolean[][] array1 = new boolean[2][2];\n+        boolean[][] array2 = new boolean[2][2];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (i == 1) || (j == 1);\n+                array2[i][j] = (i == 1) || (j == 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = false;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+        \n+        // compare 1 dim to 2.\n+        boolean[] array3 = new boolean[]{true, true};\n+        assertFalse(new EqualsBuilder().append(array1, array3).isEquals());\n+        assertFalse(new EqualsBuilder().append(array3, array1).isEquals());\n+        assertFalse(new EqualsBuilder().append(array2, array3).isEquals());\n+        assertFalse(new EqualsBuilder().append(array3, array2).isEquals());\n+    }\n+\n+    public void testRaggedArray() {\n+        long array1[][] = new long[2][];\n+        long array2[][] = new long[2][];\n+        for (int i = 0; i < array1.length; ++i) {\n+            array1[i] = new long[2];\n+            array2[i] = new long[2];\n+            for (int j = 0; j < array1[i].length; ++j) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    public void testMixedArray() {\n+        Object array1[] = new Object[2];\n+        Object array2[] = new Object[2];\n+        for (int i = 0; i < array1.length; ++i) {\n+            array1[i] = new long[2];\n+            array2[i] = new long[2];\n+            for (int j = 0; j < 2; ++j) {\n+                ((long[]) array1[i])[j] = (i + 1) * (j + 1);\n+                ((long[]) array2[i])[j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        ((long[]) array1[1])[1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    public void testObjectArrayHiddenByObject() {\n+        TestObject[] array1 = new TestObject[2];\n+        array1[0] = new TestObject(4);\n+        array1[1] = new TestObject(5);\n+        TestObject[] array2 = new TestObject[2];\n+        array2[0] = new TestObject(4);\n+        array2[1] = new TestObject(5);\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1].setA(6);\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testLongArrayHiddenByObject() {\n+        long[] array1 = new long[2];\n+        array1[0] = 5L;\n+        array1[1] = 6L;\n+        long[] array2 = new long[2];\n+        array2[0] = 5L;\n+        array2[1] = 6L;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testIntArrayHiddenByObject() {\n+        int[] array1 = new int[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        int[] array2 = new int[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testShortArrayHiddenByObject() {\n+        short[] array1 = new short[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        short[] array2 = new short[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testCharArrayHiddenByObject() {\n+        char[] array1 = new char[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        char[] array2 = new char[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testByteArrayHiddenByObject() {\n+        byte[] array1 = new byte[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        byte[] array2 = new byte[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testDoubleArrayHiddenByObject() {\n+        double[] array1 = new double[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        double[] array2 = new double[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testFloatArrayHiddenByObject() {\n+        float[] array1 = new float[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        float[] array2 = new float[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testBooleanArrayHiddenByObject() {\n+        boolean[] array1 = new boolean[2];\n+        array1[0] = true;\n+        array1[1] = false;\n+        boolean[] array2 = new boolean[2];\n+        array2[0] = true;\n+        array2[1] = false;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = true;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+    \n+    public static class TestACanEqualB {\n+        private int a;\n+\n+        public TestACanEqualB(int a) {\n+            this.a = a;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this)\n+                return true;\n+            if (o instanceof TestACanEqualB)\n+                return this.a == ((TestACanEqualB) o).getA();\n+            if (o instanceof TestBCanEqualA)\n+                return this.a == ((TestBCanEqualA) o).getB();\n+            return false;\n+        }\n+\n+        public int getA() {\n+            return this.a;\n+        }\n+    }\n+\n+    public static class TestBCanEqualA {\n+        private int b;\n+\n+        public TestBCanEqualA(int b) {\n+            this.b = b;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this)\n+                return true;\n+            if (o instanceof TestACanEqualB)\n+                return this.b == ((TestACanEqualB) o).getA();\n+            if (o instanceof TestBCanEqualA)\n+                return this.b == ((TestBCanEqualA) o).getB();\n+            return false;\n+        }\n+\n+        public int getB() {\n+            return this.b;\n+        }\n+    }\n+    \n+    /**\n+     * Tests two instances of classes that can be equal and that are not \"related\". The two classes are not subclasses\n+     * of each other and do not share a parent aside from Object.\n+     * See http://issues.apache.org/bugzilla/show_bug.cgi?id=33069\n+     */\n+    public void testUnrelatedClasses() {\n+        Object[] x = new Object[]{new TestACanEqualB(1)};\n+        Object[] y = new Object[]{new TestBCanEqualA(1)};\n+\n+        // sanity checks:\n+        assertTrue(Arrays.equals(x, x));\n+        assertTrue(Arrays.equals(y, y));\n+        assertTrue(Arrays.equals(x, y));\n+        assertTrue(Arrays.equals(y, x));\n+        // real tests:\n+        assertTrue(x[0].equals(x[0]));\n+        assertTrue(y[0].equals(y[0]));\n+        assertTrue(x[0].equals(y[0]));\n+        assertTrue(y[0].equals(x[0]));\n+        assertTrue(new EqualsBuilder().append(x, x).isEquals());\n+        assertTrue(new EqualsBuilder().append(y, y).isEquals());\n+        assertTrue(new EqualsBuilder().append(x, y).isEquals());\n+        assertTrue(new EqualsBuilder().append(y, x).isEquals());\n+    }\n+    \n+    /**\n+     * Test from http://issues.apache.org/bugzilla/show_bug.cgi?id=33067\n+     */\n+    public void testNpeForNullElement() {\n+        Object[] x1 = new Object[] { new Integer(1), null, new Integer(3) };\n+        Object[] x2 = new Object[] { new Integer(1), new Integer(2), new Integer(3) };\n+\n+        // causes an NPE in 2.0 according to:\n+        // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067\n+        new EqualsBuilder().append(x1, x2);\n+    }\n+\n+    public void testReflectionEqualsExcludeFields() throws Exception {\n+        TestObjectWithMultipleFields x1 = new TestObjectWithMultipleFields(1, 2, 3);\n+        TestObjectWithMultipleFields x2 = new TestObjectWithMultipleFields(1, 3, 4);\n+\n+        // not equal when including all fields\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2));\n+\n+        // doesn't barf on null, empty array, or non-existent field, but still tests as not equal\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, (String[]) null));\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {}));\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"xxx\"}));\n+\n+        // not equal if only one of the differing fields excluded\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"two\"}));\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"three\"}));\n+\n+        // equal if both differing fields excluded\n+        assertTrue(EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"two\", \"three\"}));\n+\n+        // still equal as long as both differing fields are among excluded\n+        assertTrue(EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"one\", \"two\", \"three\"}));\n+        assertTrue(EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"one\", \"two\", \"three\", \"xxx\"}));\n+    }\n+\n+    static class TestObjectWithMultipleFields {\n+        @SuppressWarnings(\"unused\")\n+        private TestObject one;\n+        @SuppressWarnings(\"unused\")\n+        private TestObject two;\n+        @SuppressWarnings(\"unused\")\n+        private TestObject three;\n+\n+        public TestObjectWithMultipleFields(int one, int two, int three) {\n+            this.one = new TestObject(one);\n+            this.two = new TestObject(two);\n+            this.three = new TestObject(three);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/builder/HashCodeBuilderAndEqualsBuilderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Tests {@link org.apache.commons.lang.builder.HashCodeBuilder} and\n+ * {@link org.apache.commons.lang.builder.EqualsBuilderTest} to insure that equal\n+ * objects must have equal hash codes.\n+ * \n+ * @author Gary Gregory\n+ * @version $Id$\n+ */\n+public class HashCodeBuilderAndEqualsBuilderTest extends TestCase {\n+\n+    /**\n+     * Constructor for HashCodeBuilderAndEqualsBuilderTest.\n+     * @param name\n+     */\n+    public HashCodeBuilderAndEqualsBuilderTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(HashCodeBuilderAndEqualsBuilderTest.class);\n+        suite.setName(\"HashCodeBuilderAndEqualsBuilder Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testInteger(boolean testTransients) {\n+        Integer i1 = new Integer(12345);\n+        Integer i2 = new Integer(12345);\n+        assertEqualsAndHashCodeContract(i1, i2, testTransients);\n+    }\n+\n+    public void testInteger() {\n+        testInteger(false);\n+    }\n+\n+    public void testIntegerWithTransients() {\n+        testInteger(true);\n+    }\n+\n+    public void testFixture() {\n+        testFixture(false);\n+    }\n+\n+    public void testFixtureWithTransients() {\n+        testFixture(true);\n+    }\n+\n+    public void testFixture(boolean testTransients) {\n+        assertEqualsAndHashCodeContract(new TestFixture(2, 'c', \"Test\", (short) 2), new TestFixture(2, 'c', \"Test\", (short) 2), testTransients);\n+        assertEqualsAndHashCodeContract(\n+            new AllTransientFixture(2, 'c', \"Test\", (short) 2),\n+            new AllTransientFixture(2, 'c', \"Test\", (short) 2),\n+            testTransients);\n+        assertEqualsAndHashCodeContract(\n+            new SubTestFixture(2, 'c', \"Test\", (short) 2, \"Same\"),\n+            new SubTestFixture(2, 'c', \"Test\", (short) 2, \"Same\"),\n+            testTransients);\n+        assertEqualsAndHashCodeContract(\n+            new SubAllTransientFixture(2, 'c', \"Test\", (short) 2, \"Same\"),\n+            new SubAllTransientFixture(2, 'c', \"Test\", (short) 2, \"Same\"),\n+            testTransients);\n+    }\n+\n+    /**\n+     * Asserts that if <code>lhs</code> equals <code>rhs</code> \n+     * then their hash codes MUST be identical.\n+     * \n+     * @param lhs The Left-Hand-Side of the equals test\n+     * @param rhs The Right-Hand-Side of the equals test\n+     * @param testTransients wether to test transient fields\n+     */\n+    public void assertEqualsAndHashCodeContract(Object lhs, Object rhs, boolean testTransients) {\n+        if (EqualsBuilder.reflectionEquals(lhs, rhs, testTransients)) {\n+            // test a couple of times for consistency.\n+            assertEquals(HashCodeBuilder.reflectionHashCode(lhs, testTransients), HashCodeBuilder.reflectionHashCode(rhs, testTransients));\n+            assertEquals(HashCodeBuilder.reflectionHashCode(lhs, testTransients), HashCodeBuilder.reflectionHashCode(rhs, testTransients));\n+            assertEquals(HashCodeBuilder.reflectionHashCode(lhs, testTransients), HashCodeBuilder.reflectionHashCode(rhs, testTransients));\n+        }\n+    }\n+\n+    static class TestFixture {\n+        int i;\n+        char c;\n+        String string;\n+        short s;\n+\n+        TestFixture(int i, char c, String string, short s) {\n+            this.i = i;\n+            this.c = c;\n+            this.string = string;\n+            this.s = s;\n+        }\n+    }\n+\n+    static class SubTestFixture extends TestFixture {\n+        transient String tString;\n+\n+        SubTestFixture(int i, char c, String string, short s, String tString) {\n+            super(i, c, string, s);\n+            this.tString = tString;\n+        }\n+    }\n+\n+    static class AllTransientFixture {\n+        transient int i;\n+        transient char c;\n+        transient String string;\n+        transient short s;\n+\n+        AllTransientFixture(int i, char c, String string, short s) {\n+            this.i = i;\n+            this.c = c;\n+            this.string = string;\n+            this.s = s;\n+        }\n+    }\n+\n+    static class SubAllTransientFixture extends AllTransientFixture {\n+        transient String tString;\n+\n+        SubAllTransientFixture(int i, char c, String string, short s, String tString) {\n+            super(i, c, string, s);\n+            this.tString = tString;\n+        }\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/builder/HashCodeBuilderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.builder;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.builder.HashCodeBuilder}.\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class HashCodeBuilderTest extends TestCase {\n+\n+    /**\n+     * A reflection test fixture.\n+     */\n+    static class ReflectionTestCycleA {\n+        ReflectionTestCycleB b;\n+\n+        @Override\n+        public int hashCode() {\n+            return HashCodeBuilder.reflectionHashCode(this);\n+        }\n+    }\n+\n+    /**\n+     * A reflection test fixture.\n+     */\n+    static class ReflectionTestCycleB {\n+        ReflectionTestCycleA a;\n+\n+        @Override\n+        public int hashCode() {\n+            return HashCodeBuilder.reflectionHashCode(this);\n+        }\n+    }\n+\n+    public HashCodeBuilderTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(HashCodeBuilderTest.class);\n+        suite.setName(\"HashCodeBuilder Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    // -----------------------------------------------------------------------\n+\n+    public void testConstructorEx1() {\n+        try {\n+            new HashCodeBuilder(0, 0);\n+\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testConstructorEx2() {\n+        try {\n+            new HashCodeBuilder(2, 2);\n+\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    static class TestObject {\n+        private int a;\n+\n+        public TestObject(int a) {\n+            this.a = a;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) {\n+                return true;\n+            }\n+            if (!(o instanceof TestObject)) {\n+                return false;\n+            }\n+            TestObject rhs = (TestObject) o;\n+            return (a == rhs.a);\n+        }\n+\n+        public void setA(int a) {\n+            this.a = a;\n+        }\n+\n+        public int getA() {\n+            return a;\n+        }\n+    }\n+\n+    static class TestSubObject extends TestObject {\n+        private int b;\n+\n+        @SuppressWarnings(\"unused\")\n+        transient private int t;\n+\n+        public TestSubObject() {\n+            super(0);\n+        }\n+\n+        public TestSubObject(int a, int b, int t) {\n+            super(a);\n+            this.b = b;\n+            this.t = t;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) {\n+                return true;\n+            }\n+            if (!(o instanceof TestSubObject)) {\n+                return false;\n+            }\n+            TestSubObject rhs = (TestSubObject) o;\n+            return super.equals(o) && (b == rhs.b);\n+        }\n+    }\n+\n+    public void testReflectionHashCode() {\n+        assertEquals(17 * 37, HashCodeBuilder.reflectionHashCode(new TestObject(0)));\n+        assertEquals(17 * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestObject(123456)));\n+    }\n+\n+    public void testReflectionHierarchyHashCode() {\n+        assertEquals(17 * 37 * 37, HashCodeBuilder.reflectionHashCode(new TestSubObject(0, 0, 0)));\n+        assertEquals(17 * 37 * 37 * 37, HashCodeBuilder.reflectionHashCode(new TestSubObject(0, 0, 0), true));\n+        assertEquals((17 * 37 + 7890) * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestSubObject(123456, 7890,\n+                0)));\n+        assertEquals(((17 * 37 + 7890) * 37 + 0) * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestSubObject(\n+                123456, 7890, 0), true));\n+    }\n+\n+    public void testReflectionHierarchyHashCodeEx1() {\n+        try {\n+            HashCodeBuilder.reflectionHashCode(0, 0, new TestSubObject(0, 0, 0), true);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testReflectionHierarchyHashCodeEx2() {\n+        try {\n+            HashCodeBuilder.reflectionHashCode(2, 2, new TestSubObject(0, 0, 0), true);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testReflectionHashCodeEx1() {\n+        try {\n+            HashCodeBuilder.reflectionHashCode(0, 0, new TestObject(0), true);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testReflectionHashCodeEx2() {\n+        try {\n+            HashCodeBuilder.reflectionHashCode(2, 2, new TestObject(0), true);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testReflectionHashCodeEx3() {\n+        try {\n+            HashCodeBuilder.reflectionHashCode(13, 19, null, true);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testSuper() {\n+        Object obj = new Object();\n+        assertEquals(17 * 37 + (19 * 41 + obj.hashCode()), new HashCodeBuilder(17, 37).appendSuper(\n+                new HashCodeBuilder(19, 41).append(obj).toHashCode()).toHashCode());\n+    }\n+\n+    public void testObject() {\n+        Object obj = null;\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj = new Object();\n+        assertEquals(17 * 37 + obj.hashCode(), new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    @SuppressWarnings(\"cast\") // cast is not really needed, keep for consistency\n+    public void testLong() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long) 0L).toHashCode());\n+        assertEquals(17 * 37 + (int) (123456789L ^ (123456789L >> 32)), new HashCodeBuilder(17, 37).append(\n+                (long) 123456789L).toHashCode());\n+    }\n+\n+    @SuppressWarnings(\"cast\") // cast is not really needed, keep for consistency\n+    public void testInt() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int) 0).toHashCode());\n+        assertEquals(17 * 37 + 123456, new HashCodeBuilder(17, 37).append((int) 123456).toHashCode());\n+    }\n+\n+    public void testShort() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((short) 0).toHashCode());\n+        assertEquals(17 * 37 + 12345, new HashCodeBuilder(17, 37).append((short) 12345).toHashCode());\n+    }\n+\n+    public void testChar() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((char) 0).toHashCode());\n+        assertEquals(17 * 37 + 1234, new HashCodeBuilder(17, 37).append((char) 1234).toHashCode());\n+    }\n+\n+    public void testByte() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((byte) 0).toHashCode());\n+        assertEquals(17 * 37 + 123, new HashCodeBuilder(17, 37).append((byte) 123).toHashCode());\n+    }\n+\n+    @SuppressWarnings(\"cast\") // cast is not really needed, keep for consistency\n+    public void testDouble() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double) 0d).toHashCode());\n+        double d = 1234567.89;\n+        long l = Double.doubleToLongBits(d);\n+        assertEquals(17 * 37 + (int) (l ^ (l >> 32)), new HashCodeBuilder(17, 37).append(d).toHashCode());\n+    }\n+\n+    @SuppressWarnings(\"cast\") // cast is not really needed, keep for consistency\n+    public void testFloat() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((float) 0f).toHashCode());\n+        float f = 1234.89f;\n+        int i = Float.floatToIntBits(f);\n+        assertEquals(17 * 37 + i, new HashCodeBuilder(17, 37).append(f).toHashCode());\n+    }\n+\n+    public void testBoolean() {\n+        assertEquals(17 * 37 + 0, new HashCodeBuilder(17, 37).append(true).toHashCode());\n+        assertEquals(17 * 37 + 1, new HashCodeBuilder(17, 37).append(false).toHashCode());\n+    }\n+\n+    public void testObjectArray() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((Object[]) null).toHashCode());\n+        Object[] obj = new Object[2];\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = new Object();\n+        assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[1] = new Object();\n+        assertEquals((17 * 37 + obj[0].hashCode()) * 37 + obj[1].hashCode(), new HashCodeBuilder(17, 37).append(obj)\n+                .toHashCode());\n+    }\n+\n+    public void testObjectArrayAsObject() {\n+        Object[] obj = new Object[2];\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[0] = new Object();\n+        assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[1] = new Object();\n+        assertEquals((17 * 37 + obj[0].hashCode()) * 37 + obj[1].hashCode(), new HashCodeBuilder(17, 37).append(\n+                (Object) obj).toHashCode());\n+    }\n+\n+    public void testLongArray() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long[]) null).toHashCode());\n+        long[] obj = new long[2];\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = 5L;\n+        int h1 = (int) (5L ^ (5L >> 32));\n+        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[1] = 6L;\n+        int h2 = (int) (6L ^ (6L >> 32));\n+        assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    public void testLongArrayAsObject() {\n+        long[] obj = new long[2];\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[0] = 5L;\n+        int h1 = (int) (5L ^ (5L >> 32));\n+        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[1] = 6L;\n+        int h2 = (int) (6L ^ (6L >> 32));\n+        assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+    }\n+\n+    public void testIntArray() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int[]) null).toHashCode());\n+        int[] obj = new int[2];\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = 5;\n+        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[1] = 6;\n+        assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    public void testIntArrayAsObject() {\n+        int[] obj = new int[2];\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[0] = 5;\n+        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[1] = 6;\n+        assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+    }\n+\n+    public void testShortArray() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((short[]) null).toHashCode());\n+        short[] obj = new short[2];\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = (short) 5;\n+        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[1] = (short) 6;\n+        assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    public void testShortArrayAsObject() {\n+        short[] obj = new short[2];\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[0] = (short) 5;\n+        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[1] = (short) 6;\n+        assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+    }\n+\n+    public void testCharArray() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((char[]) null).toHashCode());\n+        char[] obj = new char[2];\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = (char) 5;\n+        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[1] = (char) 6;\n+        assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    public void testCharArrayAsObject() {\n+        char[] obj = new char[2];\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[0] = (char) 5;\n+        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[1] = (char) 6;\n+        assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+    }\n+\n+    public void testByteArray() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((byte[]) null).toHashCode());\n+        byte[] obj = new byte[2];\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = (byte) 5;\n+        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[1] = (byte) 6;\n+        assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    public void testByteArrayAsObject() {\n+        byte[] obj = new byte[2];\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[0] = (byte) 5;\n+        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[1] = (byte) 6;\n+        assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+    }\n+\n+    public void testDoubleArray() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double[]) null).toHashCode());\n+        double[] obj = new double[2];\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = 5.4d;\n+        long l1 = Double.doubleToLongBits(5.4d);\n+        int h1 = (int) (l1 ^ (l1 >> 32));\n+        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[1] = 6.3d;\n+        long l2 = Double.doubleToLongBits(6.3d);\n+        int h2 = (int) (l2 ^ (l2 >> 32));\n+        assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    public void testDoubleArrayAsObject() {\n+        double[] obj = new double[2];\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[0] = 5.4d;\n+        long l1 = Double.doubleToLongBits(5.4d);\n+        int h1 = (int) (l1 ^ (l1 >> 32));\n+        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[1] = 6.3d;\n+        long l2 = Double.doubleToLongBits(6.3d);\n+        int h2 = (int) (l2 ^ (l2 >> 32));\n+        assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+    }\n+\n+    public void testFloatArray() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((float[]) null).toHashCode());\n+        float[] obj = new float[2];\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = 5.4f;\n+        int h1 = Float.floatToIntBits(5.4f);\n+        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[1] = 6.3f;\n+        int h2 = Float.floatToIntBits(6.3f);\n+        assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    public void testFloatArrayAsObject() {\n+        float[] obj = new float[2];\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[0] = 5.4f;\n+        int h1 = Float.floatToIntBits(5.4f);\n+        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[1] = 6.3f;\n+        int h2 = Float.floatToIntBits(6.3f);\n+        assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+    }\n+\n+    public void testBooleanArray() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((boolean[]) null).toHashCode());\n+        boolean[] obj = new boolean[2];\n+        assertEquals((17 * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = true;\n+        assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[1] = false;\n+        assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    public void testBooleanArrayAsObject() {\n+        boolean[] obj = new boolean[2];\n+        assertEquals((17 * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[0] = true;\n+        assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[1] = false;\n+        assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+    }\n+\n+    public void testBooleanMultiArray() {\n+        boolean[][] obj = new boolean[2][];\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = new boolean[0];\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = new boolean[1];\n+        assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = new boolean[2];\n+        assertEquals(((17 * 37 + 1) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0][0] = true;\n+        assertEquals(((17 * 37 + 0) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[1] = new boolean[1];\n+        assertEquals((((17 * 37 + 0) * 37 + 1) * 37 + 1), new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    public void testReflectionHashCodeExcludeFields() throws Exception {\n+        TestObjectWithMultipleFields x = new TestObjectWithMultipleFields(1, 2, 3);\n+\n+        assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x));\n+\n+        assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, (String[]) null));\n+        assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, new String[]{}));\n+        assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, new String[]{\"xxx\"}));\n+\n+        assertEquals(((17 * 37 + 1) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, new String[]{\"two\"}));\n+        assertEquals(((17 * 37 + 1) * 37 + 2), HashCodeBuilder.reflectionHashCode(x, new String[]{\"three\"}));\n+\n+        assertEquals((17 * 37 + 1), HashCodeBuilder.reflectionHashCode(x, new String[]{\"two\", \"three\"}));\n+\n+        assertEquals(17, HashCodeBuilder.reflectionHashCode(x, new String[]{\"one\", \"two\", \"three\"}));\n+        assertEquals(17, HashCodeBuilder.reflectionHashCode(x, new String[]{\"one\", \"two\", \"three\", \"xxx\"}));\n+    }\n+\n+    static class TestObjectWithMultipleFields {\n+        @SuppressWarnings(\"unused\")\n+        private int one = 0;\n+\n+        @SuppressWarnings(\"unused\")\n+        private int two = 0;\n+\n+        @SuppressWarnings(\"unused\")\n+        private int three = 0;\n+\n+        public TestObjectWithMultipleFields(int one, int two, int three) {\n+            this.one = one;\n+            this.two = two;\n+            this.three = three;\n+        }\n+    }\n+\n+    /**\n+     * Test Objects pointing to each other.\n+     */\n+    public void testReflectionObjectCycle() {\n+        ReflectionTestCycleA a = new ReflectionTestCycleA();\n+        ReflectionTestCycleB b = new ReflectionTestCycleB();\n+        a.b = b;\n+        b.a = a;\n+        \n+        // Used to caused:\n+        // java.lang.StackOverflowError\n+        // at java.lang.ClassLoader.getCallerClassLoader(Native Method)\n+        // at java.lang.Class.getDeclaredFields(Class.java:992)\n+        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:373)\n+        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\n+        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\n+        // at\n+        // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleB.hashCode(HashCodeBuilderTest.java:53)\n+        // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n+        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:383)\n+        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\n+        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\n+        // at\n+        // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleA.hashCode(HashCodeBuilderTest.java:42)\n+        // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n+\n+        a.hashCode();\n+        b.hashCode();\n+    }\n+\n+    /**\n+     * Ensures LANG-520 remains true\n+     */\n+    public void testToHashCodeEqualsHashCode() {\n+        HashCodeBuilder hcb = new HashCodeBuilder(17, 37).append(new Object()).append('a');\n+        assertEquals(\"hashCode() is no longer returning the same value as toHashCode() - see LANG-520\", \n+                     hcb.toHashCode(), hcb.hashCode());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/builder/MultiLineToStringStyleTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.lang.SystemUtils;\n+import org.apache.commons.lang.builder.ToStringStyleTest.Person;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.builder.MultiLineToStringStyleTest}.\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MultiLineToStringStyleTest extends TestCase {\n+\n+    private final Integer base = new Integer(5);\n+    private final String baseStr = base.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(base));\n+    \n+    public MultiLineToStringStyleTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(MultiLineToStringStyleTest.class);\n+        suite.setName(\"MultiLineToStringStyle Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.MULTI_LINE_STYLE);\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);\n+    }\n+\n+    //----------------------------------------------------------------\n+    \n+    public void testBlank() {\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).toString());\n+    }\n+\n+    public void testAppendSuper() {\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[\" + SystemUtils.LINE_SEPARATOR + \"]\").toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\").toString());\n+        \n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=hello\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[\" + SystemUtils.LINE_SEPARATOR + \"]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"  a=hello\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=hello\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).appendSuper(null).append(\"a\", \"hello\").toString());\n+    }\n+    \n+    public void testObject() {\n+        Integer i3 = new Integer(3);\n+        Integer i4 = new Integer(4);\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append((Object) null).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  3\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(i3).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=<null>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=3\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", i3).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=3\" + SystemUtils.LINE_SEPARATOR + \"  b=4\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", i3).append(\"b\", i4).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=<Integer>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", i3, false).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=<size=0>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", new ArrayList<Object>(), false).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=[]\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", new ArrayList<Object>(), true).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=<size=0>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", new HashMap<Object, Object>(), false).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a={}\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", new HashMap<Object, Object>(), true).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=<size=0>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], false).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a={}\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], true).toString());\n+    }\n+\n+    public void testPerson() {\n+        Person p = new Person();\n+        p.name = \"Jane Doe\";\n+        p.age = 25;\n+        p.smoker = true;\n+        String pBaseStr = p.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(p));\n+        assertEquals(pBaseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  name=Jane Doe\" + SystemUtils.LINE_SEPARATOR + \"  age=25\" + SystemUtils.LINE_SEPARATOR + \"  smoker=true\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(p).append(\"name\", p.name).append(\"age\", p.age).append(\"smoker\", p.smoker).toString());\n+    }\n+\n+    public void testLong() {\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  3\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(3L).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=3\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", 3L).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=3\" + SystemUtils.LINE_SEPARATOR + \"  b=4\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", 3L).append(\"b\", 4L).toString());\n+    }\n+\n+    public void testObjectArray() {\n+        Object[] array = new Object[] {null, base, new int[] {3, 6}};\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  {<null>,5,{3,6}}\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  {<null>,5,{3,6}}\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArray() {\n+        long[] array = new long[] {1, 2, -3, 4};\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  {1,2,-3,4}\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  {1,2,-3,4}\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArrayArray() {\n+        long[][] array = new long[][] {{1, 2}, null, {5}};\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  {{1,2},<null>,{5}}\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  {{1,2},<null>,{5}}\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/builder/NoFieldNamesToStringStyleTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import org.apache.commons.lang.builder.ToStringStyleTest.Person;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.builder.NoFieldNamesToStringStyleTest}.\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class NoFieldNamesToStringStyleTest extends TestCase {\n+\n+    private final Integer base = new Integer(5);\n+    private final String baseStr = base.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(base));\n+    \n+    public NoFieldNamesToStringStyleTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(NoFieldNamesToStringStyleTest.class);\n+        suite.setName(\"NoFieldNamesToStringStyle Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.NO_FIELD_NAMES_STYLE);\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);\n+    }\n+\n+    //----------------------------------------------------------------\n+    \n+    public void testBlank() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).toString());\n+    }\n+\n+    public void testAppendSuper() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").toString());\n+        \n+        assertEquals(baseStr + \"[hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[<null>,hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[hello]\", new ToStringBuilder(base).appendSuper(null).append(\"a\", \"hello\").toString());\n+    }\n+    \n+    public void testObject() {\n+        Integer i3 = new Integer(3);\n+        Integer i4 = new Integer(4);\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) null).toString());\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(i3).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(\"a\", i3).toString());\n+        assertEquals(baseStr + \"[3,4]\", new ToStringBuilder(base).append(\"a\", i3).append(\"b\", i4).toString());\n+        assertEquals(baseStr + \"[<Integer>]\", new ToStringBuilder(base).append(\"a\", i3, false).toString());\n+        assertEquals(baseStr + \"[<size=0>]\", new ToStringBuilder(base).append(\"a\", new ArrayList<Object>(), false).toString());\n+        assertEquals(baseStr + \"[[]]\", new ToStringBuilder(base).append(\"a\", new ArrayList<Object>(), true).toString());\n+        assertEquals(baseStr + \"[<size=0>]\", new ToStringBuilder(base).append(\"a\", new HashMap<Object, Object>(), false).toString());\n+        assertEquals(baseStr + \"[{}]\", new ToStringBuilder(base).append(\"a\", new HashMap<Object, Object>(), true).toString());\n+        assertEquals(baseStr + \"[<size=0>]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], false).toString());\n+        assertEquals(baseStr + \"[{}]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], true).toString());\n+    }\n+\n+    public void testPerson() {\n+        Person p = new Person();\n+        p.name = \"Ron Paul\";\n+        p.age = 72;\n+        p.smoker = false;\n+        String pBaseStr = p.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(p));\n+        assertEquals(pBaseStr + \"[Ron Paul,72,false]\", new ToStringBuilder(p).append(\"name\", p.name).append(\"age\", p.age).append(\"smoker\", p.smoker).toString());\n+    }\n+\n+    public void testLong() {\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(3L).toString());\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(\"a\", 3L).toString());\n+        assertEquals(baseStr + \"[3,4]\", new ToStringBuilder(base).append(\"a\", 3L).append(\"b\", 4L).toString());\n+    }\n+\n+    public void testObjectArray() {\n+        Object[] array = new Object[] {null, base, new int[] {3, 6}};\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArray() {\n+        long[] array = new long[] {1, 2, -3, 4};\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArrayArray() {\n+        long[][] array = new long[][] {{1, 2}, null, {5}};\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/builder/ReflectionToStringBuilderExcludeTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.builder;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import junit.framework.Assert;\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+\n+/**\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">ggregory</a>\n+ * @version $Id$\n+ */\n+public class ReflectionToStringBuilderExcludeTest extends TestCase {\n+\n+    class TestFixture {\n+        @SuppressWarnings(\"unused\")\n+        private String secretField = SECRET_VALUE;\n+\n+        @SuppressWarnings(\"unused\")\n+        private String showField = NOT_SECRET_VALUE;\n+    }\n+\n+    private static final String NOT_SECRET_FIELD = \"showField\";\n+\n+    private static final String NOT_SECRET_VALUE = \"Hello World!\";\n+\n+    private static final String SECRET_FIELD = \"secretField\";\n+\n+    private static final String SECRET_VALUE = \"secret value\";\n+\n+    public void test_toStringExclude() {\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), SECRET_FIELD);\n+        this.validateSecretFieldAbsent(toString);\n+    }\n+\n+    public void test_toStringExcludeArray() {\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[]{SECRET_FIELD});\n+        this.validateSecretFieldAbsent(toString);\n+    }\n+\n+    public void test_toStringExcludeArrayWithNull() {\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[]{null});\n+        this.validateSecretFieldPresent(toString);\n+    }\n+\n+    public void test_toStringExcludeArrayWithNulls() {\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[]{null, null});\n+        this.validateSecretFieldPresent(toString);\n+    }\n+\n+    public void test_toStringExcludeCollection() {\n+        List<String> excludeList = new ArrayList<String>();\n+        excludeList.add(SECRET_FIELD);\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList);\n+        this.validateSecretFieldAbsent(toString);\n+    }\n+\n+    public void test_toStringExcludeCollectionWithNull() {\n+        List<String> excludeList = new ArrayList<String>();\n+        excludeList.add(null);\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList);\n+        this.validateSecretFieldPresent(toString);\n+    }\n+\n+    public void test_toStringExcludeCollectionWithNulls() {\n+        List<String> excludeList = new ArrayList<String>();\n+        excludeList.add(null);\n+        excludeList.add(null);\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList);\n+        this.validateSecretFieldPresent(toString);\n+    }\n+\n+    public void test_toStringExcludeEmptyArray() {\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), ArrayUtils.EMPTY_STRING_ARRAY);\n+        this.validateSecretFieldPresent(toString);\n+    }\n+\n+    public void test_toStringExcludeEmptyCollection() {\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new ArrayList<String>());\n+        this.validateSecretFieldPresent(toString);\n+    }\n+\n+    public void test_toStringExcludeNullArray() {\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), (String[]) null);\n+        this.validateSecretFieldPresent(toString);\n+    }\n+\n+    public void test_toStringExcludeNullCollection() {\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), (Collection<String>) null);\n+        this.validateSecretFieldPresent(toString);\n+    }\n+\n+    private void validateNonSecretField(String toString) {\n+        Assert.assertTrue(toString.indexOf(NOT_SECRET_FIELD) > ArrayUtils.INDEX_NOT_FOUND);\n+        Assert.assertTrue(toString.indexOf(NOT_SECRET_VALUE) > ArrayUtils.INDEX_NOT_FOUND);\n+    }\n+\n+    private void validateSecretFieldAbsent(String toString) {\n+        Assert.assertEquals(ArrayUtils.INDEX_NOT_FOUND, toString.indexOf(SECRET_VALUE));\n+        this.validateNonSecretField(toString);\n+    }\n+\n+    private void validateSecretFieldPresent(String toString) {\n+        Assert.assertTrue(toString.indexOf(SECRET_VALUE) > 0);\n+        this.validateNonSecretField(toString);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/builder/ShortPrefixToStringStyleTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import org.apache.commons.lang.builder.ToStringStyleTest.Person;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.builder.ToStringStyle#SHORT_PREFIX_STYLE}.\n+ * \n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id$\n+ */\n+public class ShortPrefixToStringStyleTest extends TestCase {\n+\n+    private final Integer base = new Integer(5);\n+    private final String baseStr = \"Integer\";\n+    \n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.SHORT_PREFIX_STYLE);\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);\n+    }\n+\n+    //----------------------------------------------------------------\n+    \n+    public void testBlank() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).toString());\n+    }\n+\n+    public void testAppendSuper() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").toString());\n+        \n+        assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[<null>,a=hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendSuper(null).append(\"a\", \"hello\").toString());\n+    }\n+    \n+    public void testObject() {\n+        Integer i3 = new Integer(3);\n+        Integer i4 = new Integer(4);\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) null).toString());\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(i3).toString());\n+        assertEquals(baseStr + \"[a=<null>]\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", i3).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", i3).append(\"b\", i4).toString());\n+        assertEquals(baseStr + \"[a=<Integer>]\", new ToStringBuilder(base).append(\"a\", i3, false).toString());\n+        assertEquals(baseStr + \"[a=<size=0>]\", new ToStringBuilder(base).append(\"a\", new ArrayList<Object>(), false).toString());\n+        assertEquals(baseStr + \"[a=[]]\", new ToStringBuilder(base).append(\"a\", new ArrayList<Object>(), true).toString());\n+        assertEquals(baseStr + \"[a=<size=0>]\", new ToStringBuilder(base).append(\"a\", new HashMap<Object, Object>(), false).toString());\n+        assertEquals(baseStr + \"[a={}]\", new ToStringBuilder(base).append(\"a\", new HashMap<Object, Object>(), true).toString());\n+        assertEquals(baseStr + \"[a=<size=0>]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], false).toString());\n+        assertEquals(baseStr + \"[a={}]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], true).toString());\n+    }\n+\n+    public void testPerson() {\n+        Person p = new Person();\n+        p.name = \"John Q. Public\";\n+        p.age = 45;\n+        p.smoker = true;\n+        String pBaseStr = \"ToStringStyleTest.Person\";\n+        assertEquals(pBaseStr + \"[name=John Q. Public,age=45,smoker=true]\", new ToStringBuilder(p).append(\"name\", p.name).append(\"age\", p.age).append(\"smoker\", p.smoker).toString());\n+    }\n+\n+    public void testLong() {\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(3L).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", 3L).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", 3L).append(\"b\", 4L).toString());\n+    }\n+\n+    public void testObjectArray() {\n+        Object[] array = new Object[] {null, base, new int[] {3, 6}};\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArray() {\n+        long[] array = new long[] {1, 2, -3, 4};\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArrayArray() {\n+        long[][] array = new long[][] {{1, 2}, null, {5}};\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/builder/SimpleToStringStyleTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import org.apache.commons.lang.builder.ToStringStyleTest.Person;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.builder.SimpleToStringStyleTest}.\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class SimpleToStringStyleTest extends TestCase {\n+\n+    private final Integer base = new Integer(5);\n+    \n+    public SimpleToStringStyleTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SimpleToStringStyleTest.class);\n+        suite.setName(\"SimpleToStringStyle Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.SIMPLE_STYLE);\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);\n+    }\n+\n+    //----------------------------------------------------------------\n+    \n+    public void testBlank() {\n+        assertEquals(\"\", new ToStringBuilder(base).toString());\n+    }\n+\n+    public void testAppendSuper() {\n+        assertEquals(\"\", new ToStringBuilder(base).appendSuper(\"\").toString());\n+        assertEquals(\"<null>\", new ToStringBuilder(base).appendSuper(\"<null>\").toString());\n+        \n+        assertEquals(\"hello\", new ToStringBuilder(base).appendSuper(\"\").append(\"a\", \"hello\").toString());\n+        assertEquals(\"<null>,hello\", new ToStringBuilder(base).appendSuper(\"<null>\").append(\"a\", \"hello\").toString());\n+        assertEquals(\"hello\", new ToStringBuilder(base).appendSuper(null).append(\"a\", \"hello\").toString());\n+    }\n+    \n+    public void testObject() {\n+        Integer i3 = new Integer(3);\n+        Integer i4 = new Integer(4);\n+        assertEquals(\"<null>\", new ToStringBuilder(base).append((Object) null).toString());\n+        assertEquals(\"3\", new ToStringBuilder(base).append(i3).toString());\n+        assertEquals(\"<null>\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n+        assertEquals(\"3\", new ToStringBuilder(base).append(\"a\", i3).toString());\n+        assertEquals(\"3,4\", new ToStringBuilder(base).append(\"a\", i3).append(\"b\", i4).toString());\n+        assertEquals(\"<Integer>\", new ToStringBuilder(base).append(\"a\", i3, false).toString());\n+        assertEquals(\"<size=0>\", new ToStringBuilder(base).append(\"a\", new ArrayList<Object>(), false).toString());\n+        assertEquals(\"[]\", new ToStringBuilder(base).append(\"a\", new ArrayList<Object>(), true).toString());\n+        assertEquals(\"<size=0>\", new ToStringBuilder(base).append(\"a\", new HashMap<Object, Object>(), false).toString());\n+        assertEquals(\"{}\", new ToStringBuilder(base).append(\"a\", new HashMap<Object, Object>(), true).toString());\n+        assertEquals(\"<size=0>\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], false).toString());\n+        assertEquals(\"{}\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], true).toString());\n+    }\n+\n+    public void testPerson() {\n+        Person p = new Person();\n+        p.name = \"Jane Q. Public\";\n+        p.age = 47;\n+        p.smoker = false;\n+        assertEquals(\"Jane Q. Public,47,false\", new ToStringBuilder(p).append(\"name\", p.name).append(\"age\", p.age).append(\"smoker\", p.smoker).toString());\n+    }\n+\n+    public void testLong() {\n+        assertEquals(\"3\", new ToStringBuilder(base).append(3L).toString());\n+        assertEquals(\"3\", new ToStringBuilder(base).append(\"a\", 3L).toString());\n+        assertEquals(\"3,4\", new ToStringBuilder(base).append(\"a\", 3L).append(\"b\", 4L).toString());\n+    }\n+\n+    public void testObjectArray() {\n+        Object[] array = new Object[] {null, base, new int[] {3, 6}};\n+        assertEquals(\"{<null>,5,{3,6}}\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(\"{<null>,5,{3,6}}\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(\"<null>\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(\"<null>\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArray() {\n+        long[] array = new long[] {1, 2, -3, 4};\n+        assertEquals(\"{1,2,-3,4}\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(\"{1,2,-3,4}\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(\"<null>\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(\"<null>\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArrayArray() {\n+        long[][] array = new long[][] {{1, 2}, null, {5}};\n+        assertEquals(\"{{1,2},<null>,{5}}\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(\"{{1,2},<null>,{5}}\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(\"<null>\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(\"<null>\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/builder/StandardToStringStyleTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import org.apache.commons.lang.builder.ToStringStyleTest.Person;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.builder.ToStringStyle}.\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class StandardToStringStyleTest extends TestCase {\n+\n+    private final Integer base = new Integer(5);\n+    private final String baseStr = \"Integer\";\n+    \n+    private static final StandardToStringStyle STYLE = new StandardToStringStyle();\n+    \n+    static {\n+        STYLE.setUseShortClassName(true);\n+        STYLE.setUseIdentityHashCode(false);\n+        STYLE.setArrayStart(\"[\");\n+        STYLE.setArraySeparator(\", \");\n+        STYLE.setArrayEnd(\"]\");\n+        STYLE.setNullText(\"%NULL%\");\n+        STYLE.setSizeStartText(\"%SIZE=\");\n+        STYLE.setSizeEndText(\"%\");\n+        STYLE.setSummaryObjectStartText(\"%\");\n+        STYLE.setSummaryObjectEndText(\"%\");\n+    }\n+    \n+    public StandardToStringStyleTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StandardToStringStyleTest.class);\n+        suite.setName(\"StandardToStringStyle Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        ToStringBuilder.setDefaultStyle(STYLE);\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);\n+    }\n+\n+    //----------------------------------------------------------------\n+    \n+    public void testBlank() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).toString());\n+    }\n+\n+    public void testAppendSuper() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").toString());\n+        assertEquals(baseStr + \"[%NULL%]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[%NULL%]\").toString());\n+        \n+        assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[%NULL%,a=hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[%NULL%]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendSuper(null).append(\"a\", \"hello\").toString());\n+    }\n+    \n+    public void testObject() {\n+        Integer i3 = new Integer(3);\n+        Integer i4 = new Integer(4);\n+        assertEquals(baseStr + \"[%NULL%]\", new ToStringBuilder(base).append((Object) null).toString());\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(i3).toString());\n+        assertEquals(baseStr + \"[a=%NULL%]\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", i3).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", i3).append(\"b\", i4).toString());\n+        assertEquals(baseStr + \"[a=%Integer%]\", new ToStringBuilder(base).append(\"a\", i3, false).toString());\n+        assertEquals(baseStr + \"[a=%SIZE=0%]\", new ToStringBuilder(base).append(\"a\", new ArrayList<Object>(), false).toString());\n+        assertEquals(baseStr + \"[a=[]]\", new ToStringBuilder(base).append(\"a\", new ArrayList<Object>(), true).toString());\n+        assertEquals(baseStr + \"[a=%SIZE=0%]\", new ToStringBuilder(base).append(\"a\", new HashMap<Object, Object>(), false).toString());\n+        assertEquals(baseStr + \"[a={}]\", new ToStringBuilder(base).append(\"a\", new HashMap<Object, Object>(), true).toString());\n+        assertEquals(baseStr + \"[a=%SIZE=0%]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], false).toString());\n+        assertEquals(baseStr + \"[a=[]]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], true).toString());\n+    }\n+\n+    public void testPerson() {\n+        Person p = new Person();\n+        p.name = \"Suzy Queue\";\n+        p.age = 19;\n+        p.smoker = false;\n+        String pBaseStr = \"ToStringStyleTest.Person\";\n+        assertEquals(pBaseStr + \"[name=Suzy Queue,age=19,smoker=false]\", new ToStringBuilder(p).append(\"name\", p.name).append(\"age\", p.age).append(\"smoker\", p.smoker).toString());\n+    }\n+\n+    public void testLong() {\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(3L).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", 3L).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", 3L).append(\"b\", 4L).toString());\n+    }\n+\n+    public void testObjectArray() {\n+        Object[] array = new Object[] {null, base, new int[] {3, 6}};\n+        assertEquals(baseStr + \"[[%NULL%, 5, [3, 6]]]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[[%NULL%, 5, [3, 6]]]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[%NULL%]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[%NULL%]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArray() {\n+        long[] array = new long[] {1, 2, -3, 4};\n+        assertEquals(baseStr + \"[[1, 2, -3, 4]]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[[1, 2, -3, 4]]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[%NULL%]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[%NULL%]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArrayArray() {\n+        long[][] array = new long[][] {{1, 2}, null, {5}};\n+        assertEquals(baseStr + \"[[[1, 2], %NULL%, [5]]]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[[[1, 2], %NULL%, [5]]]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[%NULL%]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[%NULL%]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/builder/ToStringBuilderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests for {@link org.apache.commons.lang.builder.ToStringBuilder}.\n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author <a href=\"mailto:alex@apache.org\">Alex Chaffee</a>\n+ * @version $Id$\n+ */\n+public class ToStringBuilderTest extends TestCase {\n+\n+    private final Integer base = new Integer(5);\n+    private final String baseStr = base.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(base));\n+    \n+    public ToStringBuilderTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ToStringBuilderTest.class);\n+        suite.setName(\"ToStringBuilder Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testConstructorEx1() {\n+        assertEquals(\"<null>\", new ToStringBuilder(null).toString());\n+    }\n+\n+    public void testConstructorEx2() {\n+        assertEquals(\"<null>\", new ToStringBuilder(null, null).toString());\n+        new ToStringBuilder(this.base, null).toString();\n+    }\n+\n+    public void testConstructorEx3() {\n+        assertEquals(\"<null>\", new ToStringBuilder(null, null, null).toString());\n+        new ToStringBuilder(this.base, null, null);\n+        new ToStringBuilder(this.base, ToStringStyle.DEFAULT_STYLE, null);\n+    }\n+\n+    public void testGetSetDefault() {\n+        try {\n+            ToStringBuilder.setDefaultStyle(ToStringStyle.NO_FIELD_NAMES_STYLE);\n+            assertSame(ToStringStyle.NO_FIELD_NAMES_STYLE, ToStringBuilder.getDefaultStyle());\n+        } finally {\n+            // reset for other tests\n+            ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);\n+        }\n+    }\n+\n+    public void testSetDefaultEx() {\n+        try {\n+            ToStringBuilder.setDefaultStyle(null);\n+            \n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testBlank() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).toString());\n+    }\n+    \n+    /**\n+     * Test wrapper for int primitive.\n+     */\n+    public void testReflectionInteger() {\n+        assertEquals(baseStr + \"[value=5]\", ToStringBuilder.reflectionToString(base));\n+    }\n+\n+    /**\n+     * Test wrapper for char primitive.\n+     */\n+    public void testReflectionCharacter() {\n+        Character c = new Character('A');\n+        assertEquals(this.toBaseString(c) + \"[value=A]\", ToStringBuilder.reflectionToString(c));\n+    }\n+\n+    /**\n+     * Test wrapper for char boolean.\n+     */\n+    public void testReflectionBoolean() {\n+        Boolean b;\n+        b = Boolean.TRUE;\n+        assertEquals(this.toBaseString(b) + \"[value=true]\", ToStringBuilder.reflectionToString(b));\n+        b = Boolean.FALSE;\n+        assertEquals(this.toBaseString(b) + \"[value=false]\", ToStringBuilder.reflectionToString(b));\n+    }\n+\n+    /**\n+     * Create the same toString() as Object.toString().\n+     * @param o the object to create the string for.\n+     * @return a String in the Object.toString format.\n+     */\n+    private String toBaseString(Object o) {\n+        return o.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(o));\n+    }\n+    \n+    // Reflection Array tests\n+    \n+    //\n+    // Note on the following line of code repeated in the reflection array tests.\n+    //\n+    // assertReflectionArray(\"<null>\", array);\n+    //\n+    // The expected value is not baseStr + \"[<null>]\" since array==null and is typed as Object.\n+    // The null array does not carry array type information.\n+    // If we added a primitive array type constructor and pile of associated methods, \n+    // then type declaring type information could be carried forward. IMHO, null is null.\n+    //\n+    // Gary Gregory - 2003-03-12 - ggregory@seagullsw.com  \n+    //\n+    \n+    public void assertReflectionArray(String expected, Object actual) {\n+        if (actual == null) {\n+            // Until ToStringBuilder supports null objects.\n+            return;\n+        }\n+        assertEquals(expected, ToStringBuilder.reflectionToString(actual));\n+        assertEquals(expected, ToStringBuilder.reflectionToString(actual, null));\n+        assertEquals(expected, ToStringBuilder.reflectionToString(actual, null, true));\n+        assertEquals(expected, ToStringBuilder.reflectionToString(actual, null, false));\n+    }\n+\n+    public void testReflectionObjectArray() {\n+        Object[] array = new Object[] { null, base, new int[] { 3, 6 } };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+    public void testReflectionLongArray() {\n+        long[] array = new long[] { 1, 2, -3, 4 };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+    public void testReflectionIntArray() {\n+        int[] array = new int[] { 1, 2, -3, 4 };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+    public void testReflectionShortArray() {\n+        short[] array = new short[] { 1, 2, -3, 4 };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+    public void testReflectionyteArray() {\n+        byte[] array = new byte[] { 1, 2, -3, 4 };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+    public void testReflectionCharArray() {\n+        char[] array = new char[] { 'A', '2', '_', 'D' };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{A,2,_,D}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+    public void testReflectionDoubleArray() {\n+        double[] array = new double[] { 1.0, 2.9876, -3.00001, 4.3 };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+    public void testReflectionFloatArray() {\n+        float[] array = new float[] { 1.0f, 2.9876f, -3.00001f, 4.3f };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+    public void testReflectionBooleanArray() {\n+        boolean[] array = new boolean[] { true, false, false };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{true,false,false}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+    \n+    // Reflection Array Array tests\n+\n+    public void testReflectionFloatArrayArray() {\n+        float[][] array = new float[][] { { 1.0f, 2.29686f }, null, { Float.NaN } };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+\n+    public void testReflectionLongArrayArray() {\n+        long[][] array = new long[][] { { 1, 2 }, null, { 5 } };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+    public void testReflectionIntArrayArray() {\n+        int[][] array = new int[][] { { 1, 2 }, null, { 5 } };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+    public void testReflectionhortArrayArray() {\n+        short[][] array = new short[][] { { 1, 2 }, null, { 5 } };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+    public void testReflectionByteArrayArray() {\n+        byte[][] array = new byte[][] { { 1, 2 }, null, { 5 } };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+    public void testReflectionCharArrayArray() {\n+        char[][] array = new char[][] { { 'A', 'B' }, null, { 'p' } };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{{A,B},<null>,{p}}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+    public void testReflectionDoubleArrayArray() {\n+        double[][] array = new double[][] { { 1.0, 2.29686 }, null, { Double.NaN } };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+    public void testReflectionBooleanArrayArray() {\n+        boolean[][] array = new boolean[][] { { true, false }, null, { false } };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", ToStringBuilder.reflectionToString(array));\n+        assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+    \n+    // Reflection hierarchy tests\n+\n+    public void testReflectionHierarchyArrayList() {\n+        List<Object> base = new ArrayList<Object>();\n+        String baseStr = this.toBaseString(base);\n+        assertEquals(baseStr + \"[elementData={<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>},size=0,modCount=0]\", ToStringBuilder.reflectionToString(base, null, true));\n+        assertEquals(baseStr + \"[size=0]\", ToStringBuilder.reflectionToString(base, null, false));\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+    public void testReflectionHierarchy() {\n+        ReflectionTestFixtureA baseA = new ReflectionTestFixtureA();\n+        String baseStr = this.toBaseString(baseA);\n+        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA));\n+        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null));\n+        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false));\n+        assertEquals(baseStr + \"[a=a,transientA=t]\", ToStringBuilder.reflectionToString(baseA, null, true));\n+        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, null));\n+        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, Object.class));\n+        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, ReflectionTestFixtureA.class));\n+        \n+        ReflectionTestFixtureB baseB = new ReflectionTestFixtureB();\n+        baseStr = this.toBaseString(baseB);\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB));\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB));\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null));\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false));\n+        assertEquals(baseStr + \"[b=b,transientB=t,a=a,transientA=t]\", ToStringBuilder.reflectionToString(baseB, null, true));\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, null));\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, Object.class));\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureA.class));\n+        assertEquals(baseStr + \"[b=b]\", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureB.class));\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+    static class ReflectionTestFixtureA {\n+        @SuppressWarnings(\"unused\")\n+        private char a='a';\n+        @SuppressWarnings(\"unused\")\n+        private transient char transientA='t';\n+    }\n+\n+    static class ReflectionTestFixtureB extends ReflectionTestFixtureA {\n+        @SuppressWarnings(\"unused\")\n+        private char b='b';\n+        @SuppressWarnings(\"unused\")\n+        private transient char transientB='t';\n+    }\n+\n+    public void testInnerClassReflection() {\n+        Outer outer = new Outer();\n+        assertEquals(toBaseString(outer) + \"[inner=\" + toBaseString(outer.inner) + \"[]]\", outer.toString());\n+    }\n+    \n+    static class Outer {\n+        Inner inner = new Inner();\n+        class Inner {\n+            @Override\n+            public String toString() {\n+                return ToStringBuilder.reflectionToString(this);\n+            }\n+        }\n+        @Override\n+        public String toString() {\n+            return ToStringBuilder.reflectionToString(this);\n+        }\n+    }\n+    \n+    // Reflection cycle tests\n+\n+    /**\n+     * Test an array element pointing to its container.\n+     */\n+    public void testReflectionArrayCycle() throws Exception {\n+        Object[] objects = new Object[1];\n+        objects[0] = objects;\n+        assertEquals(\n+            this.toBaseString(objects) + \"[{\" + this.toBaseString(objects) + \"}]\",\n+            ToStringBuilder.reflectionToString(objects));\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+    /**\n+     * Test an array element pointing to its container.\n+     */\n+    public void testReflectionArrayCycleLevel2() throws Exception {\n+        Object[] objects = new Object[1];\n+        Object[] objectsLevel2 = new Object[1];\n+        objects[0] = objectsLevel2;\n+        objectsLevel2[0] = objects;\n+        assertEquals(\n+            this.toBaseString(objects) + \"[{{\" + this.toBaseString(objects) + \"}}]\",\n+            ToStringBuilder.reflectionToString(objects));\n+        assertEquals(\n+            this.toBaseString(objectsLevel2) + \"[{{\" + this.toBaseString(objectsLevel2) + \"}}]\",\n+            ToStringBuilder.reflectionToString(objectsLevel2));\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+    public void testReflectionArrayArrayCycle() throws Exception {\n+        Object[][] objects = new Object[2][2];\n+        objects[0][0] = objects;\n+        objects[0][1] = objects;\n+        objects[1][0] = objects;\n+        objects[1][1] = objects;\n+        String basicToString = this.toBaseString(objects);\n+        assertEquals(\n+            basicToString\n+                + \"[{{\"\n+                + basicToString\n+                + \",\"\n+                + basicToString\n+                + \"},{\"\n+                + basicToString\n+                + \",\"\n+                + basicToString\n+                + \"}}]\",\n+            ToStringBuilder.reflectionToString(objects));\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+    /**\n+     * A reflection test fixture.\n+     */\n+    static class ReflectionTestCycleA {\n+        ReflectionTestCycleB b;\n+\n+        @Override\n+        public String toString() {\n+            return ToStringBuilder.reflectionToString(this);\n+        }\n+    }\n+\n+    /**\n+     * A reflection test fixture.\n+     */\n+    static class ReflectionTestCycleB {\n+        ReflectionTestCycleA a;\n+\n+        @Override\n+        public String toString() {\n+            return ToStringBuilder.reflectionToString(this);\n+        }\n+    }\n+\n+    /**\n+     * A reflection test fixture.\n+     */\n+    static class SimpleReflectionTestFixture {\n+        Object o;\n+\n+        public SimpleReflectionTestFixture() {\n+        }\n+\n+        public SimpleReflectionTestFixture(Object o) {\n+            this.o = o;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return ToStringBuilder.reflectionToString(this);\n+        }\n+    }\n+\n+    private static class SelfInstanceVarReflectionTestFixture {\n+        @SuppressWarnings(\"unused\")\n+        private SelfInstanceVarReflectionTestFixture typeIsSelf;\n+\n+        public SelfInstanceVarReflectionTestFixture() {\n+            this.typeIsSelf = this;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return ToStringBuilder.reflectionToString(this);\n+        }\n+      }\n+    \n+    private static class SelfInstanceTwoVarsReflectionTestFixture {\n+        @SuppressWarnings(\"unused\")\n+        private SelfInstanceTwoVarsReflectionTestFixture typeIsSelf;\n+        private String otherType = \"The Other Type\";\n+\n+        public SelfInstanceTwoVarsReflectionTestFixture() {\n+            this.typeIsSelf = this;\n+        }\n+        \n+        public String getOtherType(){\n+            return this.otherType;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return ToStringBuilder.reflectionToString(this);\n+        }\n+      }\n+    \n+    \n+    /**\n+     * Test an Object pointing to itself, the simplest test.\n+     * \n+     * @throws Exception\n+     */\n+    public void testSimpleReflectionObjectCycle() throws Exception {\n+        SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture();\n+        simple.o = simple;\n+        assertTrue(ToStringStyle.getRegistry().isEmpty());\n+        assertEquals(this.toBaseString(simple) + \"[o=\" + this.toBaseString(simple) + \"]\", simple.toString());\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+\n+    /**\n+     * Test a class that defines an ivar pointing to itself.\n+     * \n+     * @throws Exception\n+     */\n+    public void testSelfInstanceVarReflectionObjectCycle() throws Exception {\n+        SelfInstanceVarReflectionTestFixture test = new SelfInstanceVarReflectionTestFixture();\n+        assertTrue(ToStringStyle.getRegistry().isEmpty());\n+        assertEquals(this.toBaseString(test) + \"[typeIsSelf=\" + this.toBaseString(test) + \"]\", test.toString());\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+    \n+    /**\n+     * Test a class that defines an ivar pointing to itself.  This test was \n+     * created to show that handling cyclical object resulted in a missing endFieldSeparator call.\n+     * \n+     * @throws Exception\n+     */\n+    public void testSelfInstanceTwoVarsReflectionObjectCycle() throws Exception {\n+        SelfInstanceTwoVarsReflectionTestFixture test = new SelfInstanceTwoVarsReflectionTestFixture();\n+        assertTrue(ToStringStyle.getRegistry().isEmpty());\n+        assertEquals(this.toBaseString(test) + \"[typeIsSelf=\" + this.toBaseString(test) + \",otherType=\" + test.getOtherType().toString() + \"]\", test.toString());\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+    \n+\n+    /**\n+     * Test Objects pointing to each other.\n+     * \n+     * @throws Exception\n+     */\n+    public void testReflectionObjectCycle() throws Exception {\n+        ReflectionTestCycleA a = new ReflectionTestCycleA();\n+        ReflectionTestCycleB b = new ReflectionTestCycleB();\n+        a.b = b;\n+        b.a = a;\n+        assertEquals(\n+            this.toBaseString(a) + \"[b=\" + this.toBaseString(b) + \"[a=\" + this.toBaseString(a) + \"]]\",\n+            a.toString());\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+    \n+    /**\n+     * Test a nasty combination of arrays and Objects pointing to each other.\n+     * objects[0] -> SimpleReflectionTestFixture[ o -> objects ]\n+     * \n+     * @throws Exception\n+     */\n+    public void testReflectionArrayAndObjectCycle() throws Exception {\n+        Object[] objects = new Object[1];\n+        SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture(objects);\n+        objects[0] = simple;\n+        assertEquals(\n+            this.toBaseString(objects)\n+                + \"[{\"\n+                + this.toBaseString(simple)\n+                + \"[o=\"\n+                + this.toBaseString(objects)\n+                + \"]\"\n+                + \"}]\",\n+            ToStringBuilder.reflectionToString(objects));\n+        assertEquals(\n+            this.toBaseString(simple)\n+                + \"[o={\"\n+                + this.toBaseString(simple)\n+                + \"}]\",\n+            ToStringBuilder.reflectionToString(simple));\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+        \n+    void validateEmptyToStringStyleRegistry() {\n+       if (!ToStringStyle.getRegistry().isEmpty()) {\n+           System.out.println(ToStringStyle.getRegistry());\n+       }\n+       \n+        assertTrue(ToStringStyle.getRegistry().isEmpty());        \n+    }\n+    //  End: Reflection cycle tests\n+\n+    public void testAppendSuper() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").toString());\n+        \n+        assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[<null>,a=hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendSuper(null).append(\"a\", \"hello\").toString());\n+    }\n+    \n+    public void testAppendToString() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).appendToString(\"Integer@8888[]\").toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).appendToString(\"Integer@8888[<null>]\").toString());\n+        \n+        assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendToString(\"Integer@8888[]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[<null>,a=hello]\", new ToStringBuilder(base).appendToString(\"Integer@8888[<null>]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendToString(null).append(\"a\", \"hello\").toString());\n+    }\n+    \n+    public void testObject() {\n+        Integer i3 = new Integer(3);\n+        Integer i4 = new Integer(4);\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) null).toString());\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(i3).toString());\n+        assertEquals(baseStr + \"[a=<null>]\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", i3).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", i3).append(\"b\", i4).toString());\n+        assertEquals(baseStr + \"[a=<Integer>]\", new ToStringBuilder(base).append(\"a\", i3, false).toString());\n+        assertEquals(baseStr + \"[a=<size=0>]\", new ToStringBuilder(base).append(\"a\", new ArrayList<Object>(), false).toString());\n+        assertEquals(baseStr + \"[a=[]]\", new ToStringBuilder(base).append(\"a\", new ArrayList<Object>(), true).toString());\n+        assertEquals(baseStr + \"[a=<size=0>]\", new ToStringBuilder(base).append(\"a\", new HashMap<Object, Object>(), false).toString());\n+        assertEquals(baseStr + \"[a={}]\", new ToStringBuilder(base).append(\"a\", new HashMap<Object, Object>(), true).toString());\n+        assertEquals(baseStr + \"[a=<size=0>]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], false).toString());\n+        assertEquals(baseStr + \"[a={}]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], true).toString());\n+    }\n+\n+    public void testLong() {\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(3L).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", 3L).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", 3L).append(\"b\", 4L).toString());\n+    }\n+\n+    @SuppressWarnings(\"cast\") // cast is not really needed, keep for consistency\n+    public void testInt() {\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append((int) 3).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", (int) 3).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", (int) 3).append(\"b\", (int) 4).toString());\n+    }\n+\n+    public void testShort() {\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append((short) 3).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", (short) 3).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", (short) 3).append(\"b\", (short) 4).toString());\n+    }\n+\n+    public void testChar() {\n+        assertEquals(baseStr + \"[A]\", new ToStringBuilder(base).append((char) 65).toString());\n+        assertEquals(baseStr + \"[a=A]\", new ToStringBuilder(base).append(\"a\", (char) 65).toString());\n+        assertEquals(baseStr + \"[a=A,b=B]\", new ToStringBuilder(base).append(\"a\", (char) 65).append(\"b\", (char) 66).toString());\n+    }\n+\n+    public void testByte() {\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append((byte) 3).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", (byte) 3).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", (byte) 3).append(\"b\", (byte) 4).toString());\n+    }\n+\n+    @SuppressWarnings(\"cast\")\n+    public void testDouble() {\n+        assertEquals(baseStr + \"[3.2]\", new ToStringBuilder(base).append((double) 3.2).toString());\n+        assertEquals(baseStr + \"[a=3.2]\", new ToStringBuilder(base).append(\"a\", (double) 3.2).toString());\n+        assertEquals(baseStr + \"[a=3.2,b=4.3]\", new ToStringBuilder(base).append(\"a\", (double) 3.2).append(\"b\", (double) 4.3).toString());\n+    }\n+\n+    public void testFloat() {\n+        assertEquals(baseStr + \"[3.2]\", new ToStringBuilder(base).append((float) 3.2).toString());\n+        assertEquals(baseStr + \"[a=3.2]\", new ToStringBuilder(base).append(\"a\", (float) 3.2).toString());\n+        assertEquals(baseStr + \"[a=3.2,b=4.3]\", new ToStringBuilder(base).append(\"a\", (float) 3.2).append(\"b\", (float) 4.3).toString());\n+    }\n+\n+    public void testBoolean() {\n+        assertEquals(baseStr + \"[true]\", new ToStringBuilder(base).append(true).toString());\n+        assertEquals(baseStr + \"[a=true]\", new ToStringBuilder(base).append(\"a\", true).toString());\n+        assertEquals(baseStr + \"[a=true,b=false]\", new ToStringBuilder(base).append(\"a\", true).append(\"b\", false).toString());\n+    }\n+\n+\n+    public void testObjectArray() {\n+        Object[] array = new Object[] {null, base, new int[] {3, 6}};\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArray() {\n+        long[] array = new long[] {1, 2, -3, 4};\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testIntArray() {\n+        int[] array = new int[] {1, 2, -3, 4};\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testShortArray() {\n+        short[] array = new short[] {1, 2, -3, 4};\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+    \n+    public void testByteArray() {\n+        byte[] array = new byte[] {1, 2, -3, 4};\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testCharArray() {\n+        char[] array = new char[] {'A', '2', '_', 'D'};\n+        assertEquals(baseStr + \"[{A,2,_,D}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{A,2,_,D}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testDoubleArray() {\n+        double[] array = new double[] {1.0, 2.9876, -3.00001, 4.3};\n+        assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testFloatArray() {\n+        float[] array = new float[] {1.0f, 2.9876f, -3.00001f, 4.3f};\n+        assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+    \n+    public void testBooleanArray() {\n+        boolean[] array = new boolean[] {true, false, false};\n+        assertEquals(baseStr + \"[{true,false,false}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{true,false,false}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArrayArray() {\n+        long[][] array = new long[][] {{1, 2}, null, {5}};\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testIntArrayArray() {\n+        int[][] array = new int[][] {{1, 2}, null, {5}};\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testShortArrayArray() {\n+        short[][] array = new short[][] {{1, 2}, null, {5}};\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testByteArrayArray() {\n+        byte[][] array = new byte[][] {{1, 2}, null, {5}};\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testCharArrayArray() {\n+        char[][] array = new char[][] {{'A', 'B'}, null, {'p'}};\n+        assertEquals(baseStr + \"[{{A,B},<null>,{p}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{A,B},<null>,{p}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testDoubleArrayArray() {\n+        double[][] array = new double[][] {{1.0, 2.29686}, null, {Double.NaN}};\n+        assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testFloatArrayArray() {\n+        float[][] array = new float[][] {{1.0f, 2.29686f}, null, {Float.NaN}};\n+        assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testBooleanArrayArray() {\n+        boolean[][] array = new boolean[][] {{true, false}, null, {false}};\n+        assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testObjectCycle() {\n+        ObjectCycle a = new ObjectCycle();\n+        ObjectCycle b = new ObjectCycle();\n+        a.obj = b;\n+        b.obj = a;\n+       \n+        String expected = toBaseString(a) + \"[\" + toBaseString(b) + \"[\" + toBaseString(a) + \"]]\";\n+        assertEquals(expected, a.toString());\n+        validateEmptyToStringStyleRegistry();\n+    }\n+    \n+    static class ObjectCycle {\n+        Object obj;\n+       \n+        @Override\n+        public String toString() {\n+            return new ToStringBuilder(this).append(obj).toString();\n+        }\n+    }\n+    \n+    public void testSimpleReflectionStatics() {\n+        SimpleReflectionStaticFieldsFixture instance1 = new SimpleReflectionStaticFieldsFixture();\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345]\",\n+            ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345]\",\n+            ReflectionToStringBuilder.toString(instance1, null, true, true, SimpleReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345]\",\n+            this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345]\",\n+            this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class));\n+    }\n+\n+    /**\n+     * Tests ReflectionToStringBuilder.toString() for statics.\n+     */\n+    public void testReflectionStatics() {\n+        ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture();\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]\",\n+            ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345,staticTransientString=staticTransientString,staticTransientInt=54321,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]\",\n+            ReflectionToStringBuilder.toString(instance1, null, true, true, ReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]\",\n+            this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]\",\n+            this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class));\n+    }\n+\n+    /**\n+     * Tests ReflectionToStringBuilder.toString() for statics.\n+     */\n+    public void testInheritedReflectionStatics() {\n+        InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture();\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString2=staticString2,staticInt2=67890]\",\n+            ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]\",\n+            ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]\",\n+            this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]\",\n+            this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class));\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to build a suitable\n+     * <code>toString</code> value which includes static fields.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run\n+     * under a security manager, if the permissions are not set up correctly.\n+     * It is also not as efficient as testing explicitly. </p>\n+     *\n+     * <p>Transient fields are not output.</p>\n+     *\n+     * <p>Superclass fields will be appended up to and including the specified superclass. \n+     * A null superclass is treated as <code>java.lang.Object</code>.</p>\n+     *\n+     * <p>If the style is <code>null</code>, the default\n+     * <code>ToStringStyle</code> is used.</p>\n+     * \n+     * @param object  the Object to be output\n+     * @param style  the style of the <code>toString</code> to create,\n+     *  may be <code>null</code>\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n+     *  may be <code>null</code>\n+     * @return the String result\n+     * @throws IllegalArgumentException if the Object is <code>null</code>\n+     */\n+    public Object toStringWithStatics(Object object, ToStringStyle style, Class reflectUpToClass) {\n+        return ReflectionToStringBuilder.toString(object, style, false, true, reflectUpToClass);\n+    }\n+\n+    /**\n+     * Tests ReflectionToStringBuilder setUpToClass().\n+     */\n+    public void test_setUpToClass_valid() {\n+        Integer val = new Integer(5);\n+        ReflectionToStringBuilder test = new ReflectionToStringBuilder(val);\n+        test.setUpToClass(Number.class);\n+    }\n+    \n+    /**\n+     * Tests ReflectionToStringBuilder setUpToClass().\n+     */\n+    public void test_setUpToClass_invalid() {\n+        Integer val = new Integer(5);\n+        ReflectionToStringBuilder test = new ReflectionToStringBuilder(val);\n+        try {\n+            test.setUpToClass(String.class);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    /**\n+     * Tests ReflectionToStringBuilder.toString() for statics.\n+     */\n+    class ReflectionStaticFieldsFixture {\n+        static final String staticString = \"staticString\";\n+        static final int staticInt = 12345;\n+        static final transient String staticTransientString = \"staticTransientString\";\n+        static final transient int staticTransientInt = 54321;\n+        String instanceString = \"instanceString\";\n+        int instanceInt = 67890;\n+        transient String transientString = \"transientString\";\n+        transient int transientInt = 98765;\n+    }\n+\n+    /**\n+     * Test fixture for ReflectionToStringBuilder.toString() for statics.\n+     */\n+    class SimpleReflectionStaticFieldsFixture {\n+        static final String staticString = \"staticString\";\n+        static final int staticInt = 12345;\n+    }\n+\n+    /**\n+     * Test fixture for ReflectionToStringBuilder.toString() for statics.\n+     */\n+    class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture {\n+        static final String staticString2 = \"staticString2\";\n+        static final int staticInt2 = 67890;\n+    }\n+\n+    public void testReflectionNull() {\n+        assertEquals(\"<null>\", ReflectionToStringBuilder.toString(null));\n+    }\n+\n+    /**\n+     * Points out failure to print anything from appendToString methods using MULTI_LINE_STYLE.\n+     * See issue LANG-372.\n+     */\n+    class MultiLineTestObject {\n+        Integer i = new Integer(31337);\n+        @Override\n+        public String toString() {\n+            return new ToStringBuilder(this).append(\"testInt\", i).toString();\n+        }\n+    }\n+\n+    public void testAppendToStringUsingMultiLineStyle() {\n+        MultiLineTestObject obj = new MultiLineTestObject();\n+        ToStringBuilder testBuilder = new ToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE)\n+                                          .appendToString(obj.toString());\n+        assertEquals(testBuilder.toString().indexOf(\"testInt=31337\"), -1);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/builder/ToStringStyleTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Test case for ToStringStyle.\n+ * \n+ * @author Masato Tezuka\n+ * @version $Id$\n+ */\n+public class ToStringStyleTest extends TestCase {\n+\n+    public ToStringStyleTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ToStringStyleTest.class);\n+        suite.setName(\"ToStringStyle Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    private static class ToStringStyleImpl extends ToStringStyle {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSetArrayStart() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setArrayStart(null);\n+        assertEquals(\"\", style.getArrayStart());\n+    }\n+\n+    public void testSetArrayEnd() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setArrayEnd(null);\n+        assertEquals(\"\", style.getArrayEnd());\n+    }\n+\n+    public void testSetArraySeparator() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setArraySeparator(null);\n+        assertEquals(\"\", style.getArraySeparator());\n+    }\n+\n+    public void testSetContentStart() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setContentStart(null);\n+        assertEquals(\"\", style.getContentStart());\n+    }\n+\n+    public void testSetContentEnd() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setContentEnd(null);\n+        assertEquals(\"\", style.getContentEnd());\n+    }\n+\n+    public void testSetFieldNameValueSeparator() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setFieldNameValueSeparator(null);\n+        assertEquals(\"\", style.getFieldNameValueSeparator());\n+    }\n+\n+    public void testSetFieldSeparator() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setFieldSeparator(null);\n+        assertEquals(\"\", style.getFieldSeparator());\n+    }\n+\n+    public void testSetNullText() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setNullText(null);\n+        assertEquals(\"\", style.getNullText());\n+    }\n+\n+    public void testSetSizeStartText() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setSizeStartText(null);\n+        assertEquals(\"\", style.getSizeStartText());\n+    }\n+\n+    public void testSetSizeEndText() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setSizeEndText(null);\n+        assertEquals(\"\", style.getSizeEndText());\n+    }\n+\n+    public void testSetSummaryObjectStartText() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setSummaryObjectStartText(null);\n+        assertEquals(\"\", style.getSummaryObjectStartText());\n+    }\n+\n+    public void testSetSummaryObjectEndText() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setSummaryObjectEndText(null);\n+        assertEquals(\"\", style.getSummaryObjectEndText());\n+    }\n+\n+    /**\n+     * An object used to test {@link ToStringStyle}.\n+     * \n+     * @author Scott Bassin\n+     */\n+    static class Person {\n+        /**\n+         * Test String field.\n+         */\n+        String name;\n+\n+        /**\n+         * Test integer field.\n+         */\n+        int age;\n+\n+        /**\n+         * Test boolean field.\n+         */\n+        boolean smoker;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.concurrent;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import junit.framework.TestCase;\n+\n+public class BackgroundInitializerTest extends TestCase {\n+    /**\n+     * Helper method for checking whether the initialize() method was correctly\n+     * called. start() must already have been invoked.\n+     *\n+     * @param init the initializer to test\n+     */\n+    private void checkInitialize(BackgroundInitializerTestImpl init) {\n+        try {\n+            Integer result = init.get();\n+            assertEquals(\"Wrong result\", 1, result.intValue());\n+            assertEquals(\"Wrong number of invocations\", 1, init.initializeCalls);\n+            assertNotNull(\"No future\", init.getFuture());\n+        } catch (ConcurrentException cex) {\n+            fail(\"Unexpected exception: \" + cex);\n+        }\n+    }\n+\n+    /**\n+     * Tests whether initialize() is invoked.\n+     */\n+    public void testInitialize() {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        init.start();\n+        checkInitialize(init);\n+    }\n+\n+    /**\n+     * Tries to obtain the executor before start(). It should not have been\n+     * initialized yet.\n+     */\n+    public void testGetActiveExecutorBeforeStart() {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        assertNull(\"Got an executor\", init.getActiveExecutor());\n+    }\n+\n+    /**\n+     * Tests whether an external executor is correctly detected.\n+     */\n+    public void testGetActiveExecutorExternal() {\n+        ExecutorService exec = Executors.newSingleThreadExecutor();\n+        try {\n+            BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n+                    exec);\n+            init.start();\n+            assertSame(\"Wrong executor\", exec, init.getActiveExecutor());\n+            checkInitialize(init);\n+        } finally {\n+            exec.shutdown();\n+        }\n+    }\n+\n+    /**\n+     * Tests getActiveExecutor() for a temporary executor.\n+     */\n+    public void testGetActiveExecutorTemp() {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        init.start();\n+        assertNotNull(\"No active executor\", init.getActiveExecutor());\n+        checkInitialize(init);\n+    }\n+\n+    /**\n+     * Tests the execution of the background task if a temporary executor has to\n+     * be created.\n+     */\n+    public void testInitializeTempExecutor() {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        assertTrue(\"Wrong result of start()\", init.start());\n+        checkInitialize(init);\n+        assertTrue(\"Executor not shutdown\", init.getActiveExecutor()\n+                .isShutdown());\n+    }\n+\n+    /**\n+     * Tests whether an external executor can be set using the\n+     * setExternalExecutor() method.\n+     */\n+    public void testSetExternalExecutor() throws Exception {\n+        ExecutorService exec = Executors.newCachedThreadPool();\n+        try {\n+            BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+            init.setExternalExecutor(exec);\n+            assertEquals(\"Wrong executor service\", exec, init\n+                    .getExternalExecutor());\n+            assertTrue(\"Wrong result of start()\", init.start());\n+            assertSame(\"Wrong active executor\", exec, init.getActiveExecutor());\n+            checkInitialize(init);\n+            assertFalse(\"Executor was shutdown\", exec.isShutdown());\n+        } finally {\n+            exec.shutdown();\n+        }\n+    }\n+\n+    /**\n+     * Tests that setting an executor after start() causes an exception.\n+     */\n+    public void testSetExternalExecutorAfterStart() throws ConcurrentException {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        init.start();\n+        try {\n+            init.setExternalExecutor(Executors.newSingleThreadExecutor());\n+            fail(\"Could set executor after start()!\");\n+        } catch (IllegalStateException istex) {\n+            init.get();\n+        }\n+    }\n+\n+    /**\n+     * Tests invoking start() multiple times. Only the first invocation should\n+     * have an effect.\n+     */\n+    public void testStartMultipleTimes() {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        assertTrue(\"Wrong result for start()\", init.start());\n+        for (int i = 0; i < 10; i++) {\n+            assertFalse(\"Could start again\", init.start());\n+        }\n+        checkInitialize(init);\n+    }\n+\n+    /**\n+     * Tests calling get() before start(). This should cause an exception.\n+     */\n+    public void testGetBeforeStart() throws ConcurrentException {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        try {\n+            init.get();\n+            fail(\"Could call get() before start()!\");\n+        } catch (IllegalStateException istex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tests the get() method if background processing causes a runtime\n+     * exception.\n+     */\n+    public void testGetRuntimeException() throws Exception {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        RuntimeException rex = new RuntimeException();\n+        init.ex = rex;\n+        init.start();\n+        try {\n+            init.get();\n+            fail(\"Exception not thrown!\");\n+        } catch (Exception ex) {\n+            assertEquals(\"Runtime exception not thrown\", rex, ex);\n+        }\n+    }\n+\n+    /**\n+     * Tests the get() method if background processing causes a checked\n+     * exception.\n+     */\n+    public void testGetCheckedException() throws Exception {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        Exception ex = new Exception();\n+        init.ex = ex;\n+        init.start();\n+        try {\n+            init.get();\n+            fail(\"Exception not thrown!\");\n+        } catch (ConcurrentException cex) {\n+            assertEquals(\"Exception not thrown\", ex, cex.getCause());\n+        }\n+    }\n+\n+    /**\n+     * Tests the get() method if waiting for the initialization is interrupted.\n+     */\n+    public void testGetInterruptedException() throws Exception {\n+        ExecutorService exec = Executors.newSingleThreadExecutor();\n+        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n+                exec);\n+        final CountDownLatch latch1 = new CountDownLatch(1);\n+        init.shouldSleep = true;\n+        init.start();\n+        final AtomicReference<InterruptedException> iex = new AtomicReference<InterruptedException>();\n+        Thread getThread = new Thread() {\n+            @Override\n+            public void run() {\n+                try {\n+                    init.get();\n+                } catch (ConcurrentException cex) {\n+                    if (cex.getCause() instanceof InterruptedException) {\n+                        iex.set((InterruptedException) cex.getCause());\n+                    }\n+                } finally {\n+                    assertTrue(\"Thread not interrupted\", isInterrupted());\n+                    latch1.countDown();\n+                }\n+            }\n+        };\n+        getThread.start();\n+        getThread.interrupt();\n+        latch1.await();\n+        exec.shutdownNow();\n+        exec.awaitTermination(Long.MAX_VALUE, TimeUnit.MILLISECONDS);\n+        assertNotNull(\"No interrupted exception\", iex.get());\n+    }\n+\n+    /**\n+     * Tests isStarted() before start() was called.\n+     */\n+    public void testIsStartedFalse() {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        assertFalse(\"Already started\", init.isStarted());\n+    }\n+\n+    /**\n+     * Tests isStarted() after start().\n+     */\n+    public void testIsStartedTrue() {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        init.start();\n+        assertTrue(\"Not started\", init.isStarted());\n+    }\n+\n+    /**\n+     * Tests isStarted() after the background task has finished.\n+     */\n+    public void testIsStartedAfterGet() {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        init.start();\n+        checkInitialize(init);\n+        assertTrue(\"Not started\", init.isStarted());\n+    }\n+\n+    /**\n+     * A concrete implementation of BackgroundInitializer. It also overloads\n+     * some methods that simplify testing.\n+     */\n+    private static class BackgroundInitializerTestImpl extends\n+            BackgroundInitializer<Integer> {\n+        /** An exception to be thrown by initialize(). */\n+        Exception ex;\n+\n+        /** A flag whether the background task should sleep a while. */\n+        boolean shouldSleep;\n+\n+        /** The number of invocations of initialize(). */\n+        volatile int initializeCalls;\n+\n+        public BackgroundInitializerTestImpl() {\n+            super();\n+        }\n+\n+        public BackgroundInitializerTestImpl(ExecutorService exec) {\n+            super(exec);\n+        }\n+\n+        /**\n+         * Records this invocation. Optionally throws an exception or sleeps a\n+         * while.\n+         */\n+        @Override\n+        protected Integer initialize() throws Exception {\n+            if (ex != null) {\n+                throw ex;\n+            }\n+            if (shouldSleep) {\n+                Thread.sleep(60000L);\n+            }\n+            return ++initializeCalls;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/concurrent/CallableBackgroundInitializerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.concurrent;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test class for {@code CallableBackgroundInitializer}\n+ *\n+ * @version $Id$\n+ */\n+public class CallableBackgroundInitializerTest extends TestCase {\n+    /** Constant for the result of the call() invocation. */\n+    private static final Integer RESULT = 42;\n+\n+    /**\n+     * Tries to create an instance without a Callable. This should cause an\n+     * exception.\n+     */\n+    public void testInitNullCallable() {\n+        try {\n+            new CallableBackgroundInitializer<Object>(null);\n+            fail(\"Could create instance without a Callable!\");\n+        } catch (IllegalArgumentException iex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tests whether the executor service is correctly passed to the super\n+     * class.\n+     */\n+    public void testInitExecutor() {\n+        ExecutorService exec = Executors.newSingleThreadExecutor();\n+        CallableBackgroundInitializer<Integer> init = new CallableBackgroundInitializer<Integer>(\n+                new TestCallable(), exec);\n+        assertEquals(\"Executor not set\", exec, init.getExternalExecutor());\n+    }\n+\n+    /**\n+     * Tries to pass a null Callable to the constructor that takes an executor.\n+     * This should cause an exception.\n+     */\n+    public void testInitExecutorNullCallable() {\n+        ExecutorService exec = Executors.newSingleThreadExecutor();\n+        try {\n+            new CallableBackgroundInitializer<Integer>(null, exec);\n+            fail(\"Could create instance without a Callable!\");\n+        } catch (IllegalArgumentException iex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tests the implementation of initialize().\n+     */\n+    public void testInitialize() throws Exception {\n+        TestCallable call = new TestCallable();\n+        CallableBackgroundInitializer<Integer> init = new CallableBackgroundInitializer<Integer>(\n+                call);\n+        assertEquals(\"Wrong result\", RESULT, init.initialize());\n+        assertEquals(\"Wrong number of invocations\", 1, call.callCount);\n+    }\n+\n+    /**\n+     * A test Callable implementation for checking the initializer's\n+     * implementation of the initialize() method.\n+     */\n+    private static class TestCallable implements Callable<Integer> {\n+        /** A counter for the number of call() invocations. */\n+        int callCount;\n+\n+        /**\n+         * Records this invocation and returns the test result.\n+         */\n+        public Integer call() throws Exception {\n+            callCount++;\n+            return RESULT;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/concurrent/ConcurrentUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.concurrent;\n+\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test class for {@link ConcurrentUtils}.\n+ *\n+ * @version $Id$\n+ */\n+public class ConcurrentUtilsTest extends TestCase {\n+    /**\n+     * Tests creating a ConcurrentException with a runtime exception as cause.\n+     */\n+    public void testConcurrentExceptionCauseUnchecked() {\n+        try {\n+            new ConcurrentException(new RuntimeException());\n+            fail(\"Could create ConcurrentException with unchecked cause!\");\n+        } catch (IllegalArgumentException iex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tests creating a ConcurrentException with an error as cause.\n+     */\n+    public void testConcurrentExceptionCauseError() {\n+        try {\n+            new ConcurrentException(\"An error\", new Error());\n+            fail(\"Could create ConcurrentException with an error cause!\");\n+        } catch (IllegalArgumentException iex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tests creating a ConcurrentException with null as cause.\n+     */\n+    public void testConcurrentExceptionCauseNull() {\n+        try {\n+            new ConcurrentException(null);\n+            fail(\"Could create ConcurrentException with null cause!\");\n+        } catch (IllegalArgumentException iex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tests extractCause() for a null exception.\n+     */\n+    public void testExtractCauseNull() {\n+        assertNull(\"Non null result\", ConcurrentUtils.extractCause(null));\n+    }\n+\n+    /**\n+     * Tests extractCause() if the cause of the passed in exception is null.\n+     */\n+    public void testExtractCauseNullCause() {\n+        assertNull(\"Non null result\", ConcurrentUtils\n+                .extractCause(new ExecutionException(\"Test\", null)));\n+    }\n+\n+    /**\n+     * Tests extractCause() if the cause is an error.\n+     */\n+    public void testExtractCauseError() {\n+        Error err = new AssertionError(\"Test\");\n+        try {\n+            ConcurrentUtils.extractCause(new ExecutionException(err));\n+            fail(\"Error not thrown!\");\n+        } catch (Error e) {\n+            assertEquals(\"Wrong error\", err, e);\n+        }\n+    }\n+\n+    /**\n+     * Tests extractCause() if the cause is an unchecked exception.\n+     */\n+    public void testExtractCauseUnchecked() {\n+        RuntimeException rex = new RuntimeException(\"Test\");\n+        try {\n+            ConcurrentUtils.extractCause(new ExecutionException(rex));\n+            fail(\"Runtime exception not thrown!\");\n+        } catch (RuntimeException r) {\n+            assertEquals(\"Wrong exception\", rex, r);\n+        }\n+    }\n+\n+    /**\n+     * Tests extractCause() if the cause is a checked exception.\n+     */\n+    public void testExtractCauseChecked() {\n+        Exception ex = new Exception(\"Test\");\n+        ConcurrentException cex = ConcurrentUtils\n+                .extractCause(new ExecutionException(ex));\n+        assertSame(\"Wrong cause\", ex, cex.getCause());\n+    }\n+\n+    /**\n+     * Tests handleCause() if the cause is an error.\n+     */\n+    public void testHandleCauseError() throws ConcurrentException {\n+        Error err = new AssertionError(\"Test\");\n+        try {\n+            ConcurrentUtils.handleCause(new ExecutionException(err));\n+            fail(\"Error not thrown!\");\n+        } catch (Error e) {\n+            assertEquals(\"Wrong error\", err, e);\n+        }\n+    }\n+\n+    /**\n+     * Tests handleCause() if the cause is an unchecked exception.\n+     */\n+    public void testHandleCauseUnchecked() throws ConcurrentException {\n+        RuntimeException rex = new RuntimeException(\"Test\");\n+        try {\n+            ConcurrentUtils.handleCause(new ExecutionException(rex));\n+            fail(\"Runtime exception not thrown!\");\n+        } catch (RuntimeException r) {\n+            assertEquals(\"Wrong exception\", rex, r);\n+        }\n+    }\n+\n+    /**\n+     * Tests handleCause() if the cause is a checked exception.\n+     */\n+    public void testHandleCauseChecked() {\n+        Exception ex = new Exception(\"Test\");\n+        try {\n+            ConcurrentUtils.handleCause(new ExecutionException(ex));\n+            fail(\"ConcurrentException not thrown!\");\n+        } catch (ConcurrentException cex) {\n+            assertEquals(\"Wrong cause\", ex, cex.getCause());\n+        }\n+    }\n+\n+    /**\n+     * Tests handleCause() for a null parameter or a null cause. In this case\n+     * the method should do nothing. We can only test that no exception is\n+     * thrown.\n+     */\n+    public void testHandleCauseNull() throws ConcurrentException {\n+        ConcurrentUtils.handleCause(null);\n+        ConcurrentUtils.handleCause(new ExecutionException(\"Test\", null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests constant future.\n+     */\n+    public void testConstantFuture_Integer() throws Exception {\n+        Integer value = new Integer(5);\n+        Future<Integer> test = ConcurrentUtils.constantFuture(value);\n+        assertEquals(true, test.isDone());\n+        assertSame(value, test.get());\n+        assertSame(value, test.get(1000, TimeUnit.SECONDS));\n+        assertSame(value, test.get(1000, null));\n+        assertEquals(false, test.isCancelled());\n+        assertEquals(false, test.cancel(true));\n+        assertEquals(false, test.cancel(false));\n+    }\n+\n+    /**\n+     * Tests constant future.\n+     */\n+    public void testConstantFuture_null() throws Exception {\n+        Integer value = null;\n+        Future<Integer> test = ConcurrentUtils.constantFuture(value);\n+        assertEquals(true, test.isDone());\n+        assertSame(value, test.get());\n+        assertSame(value, test.get(1000, TimeUnit.SECONDS));\n+        assertSame(value, test.get(1000, null));\n+        assertEquals(false, test.isCancelled());\n+        assertEquals(false, test.cancel(true));\n+        assertEquals(false, test.cancel(false));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/concurrent/LazyInitializerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.concurrent;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test class for {@code LazyInitializer}.\n+ *\n+ * @version $Id$\n+ */\n+public class LazyInitializerTest extends TestCase {\n+    /** The initializer to be tested. */\n+    private LazyInitializerTestImpl initializer;\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        initializer = new LazyInitializerTestImpl();\n+    }\n+\n+    /**\n+     * Tests obtaining the managed object.\n+     */\n+    public void testGet() {\n+        assertNotNull(\"No managed object\", initializer.get());\n+    }\n+\n+    /**\n+     * Tests whether sequential get() invocations always return the same\n+     * instance.\n+     */\n+    public void testGetMultipleTimes() {\n+        Object obj = initializer.get();\n+        for (int i = 0; i < 10; i++) {\n+            assertEquals(\"Got different object at \" + i, obj, initializer.get());\n+        }\n+    }\n+\n+    /**\n+     * Tests invoking get() from multiple threads concurrently.\n+     */\n+    public void testGetConcurrent() throws InterruptedException {\n+        final int threadCount = 20;\n+        final CountDownLatch startLatch = new CountDownLatch(1);\n+        class GetThread extends Thread {\n+            Object object;\n+\n+            @Override\n+            public void run() {\n+                try {\n+                    // wait until all threads are ready for maximum parallelism\n+                    startLatch.await();\n+                    // access the initializer\n+                    object = initializer.get();\n+                } catch (InterruptedException iex) {\n+                    // ignore\n+                }\n+            }\n+        }\n+\n+        GetThread[] threads = new GetThread[threadCount];\n+        for (int i = 0; i < threadCount; i++) {\n+            threads[i] = new GetThread();\n+            threads[i].start();\n+        }\n+\n+        // fire all threads and wait until they are ready\n+        startLatch.countDown();\n+        for (Thread t : threads) {\n+            t.join();\n+        }\n+\n+        // check results\n+        Object managedObject = initializer.get();\n+        for (GetThread t : threads) {\n+            assertEquals(\"Wrong object\", managedObject, t.object);\n+        }\n+    }\n+\n+    /**\n+     * A test implementation of LazyInitializer. This class creates a plain\n+     * Object. As Object does not provide a specific equals() method, it is easy\n+     * to check whether multiple instances were created.\n+     */\n+    private static class LazyInitializerTestImpl extends\n+            LazyInitializer<Object> {\n+        @Override\n+        protected Object initialize() {\n+            return new Object();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.concurrent;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test class for {@link MultiBackgroundInitializer}.\n+ *\n+ * @version $Id$\n+ */\n+public class MultiBackgroundInitializerTest extends TestCase {\n+    /** Constant for the names of the child initializers. */\n+    private static final String CHILD_INIT = \"childInitializer\";\n+\n+    /** The initializer to be tested. */\n+    private MultiBackgroundInitializer initializer;\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        initializer = new MultiBackgroundInitializer();\n+    }\n+\n+    /**\n+     * Tests whether a child initializer has been executed. Optionally the\n+     * expected executor service can be checked, too.\n+     *\n+     * @param child the child initializer\n+     * @param expExec the expected executor service (null if the executor should\n+     * not be checked)\n+     * @throws ConcurrentException if an error occurs\n+     */\n+    private void checkChild(BackgroundInitializer<?> child,\n+            ExecutorService expExec) throws ConcurrentException {\n+        ChildBackgroundInitializer cinit = (ChildBackgroundInitializer) child;\n+        Integer result = cinit.get();\n+        assertEquals(\"Wrong result\", 1, result.intValue());\n+        assertEquals(\"Wrong number of executions\", 1, cinit.initializeCalls);\n+        if (expExec != null) {\n+            assertEquals(\"Wrong executor service\", expExec,\n+                    cinit.currentExecutor);\n+        }\n+    }\n+\n+    /**\n+     * Tests addInitializer() if a null name is passed in. This should cause an\n+     * exception.\n+     */\n+    public void testAddInitializerNullName() {\n+        try {\n+            initializer.addInitializer(null, new ChildBackgroundInitializer());\n+            fail(\"Null name not detected!\");\n+        } catch (IllegalArgumentException iex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tests addInitializer() if a null initializer is passed in. This should\n+     * cause an exception.\n+     */\n+    public void testAddInitializerNullInit() {\n+        try {\n+            initializer.addInitializer(CHILD_INIT, null);\n+            fail(\"Could add null initializer!\");\n+        } catch (IllegalArgumentException iex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tests the background processing if there are no child initializers.\n+     */\n+    public void testInitializeNoChildren() throws ConcurrentException {\n+        assertTrue(\"Wrong result of start()\", initializer.start());\n+        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n+                .get();\n+        assertTrue(\"Got child initializers\", res.initializerNames().isEmpty());\n+        assertTrue(\"Executor not shutdown\", initializer.getActiveExecutor()\n+                .isShutdown());\n+    }\n+\n+    /**\n+     * Helper method for testing the initialize() method. This method can\n+     * operate with both an external and a temporary executor service.\n+     *\n+     * @return the result object produced by the initializer\n+     */\n+    private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n+            throws ConcurrentException {\n+        final int count = 5;\n+        for (int i = 0; i < count; i++) {\n+            initializer.addInitializer(CHILD_INIT + i,\n+                    new ChildBackgroundInitializer());\n+        }\n+        initializer.start();\n+        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n+                .get();\n+        assertEquals(\"Wrong number of child initializers\", count, res\n+                .initializerNames().size());\n+        for (int i = 0; i < count; i++) {\n+            String key = CHILD_INIT + i;\n+            assertTrue(\"Name not found: \" + key, res.initializerNames()\n+                    .contains(key));\n+            assertEquals(\"Wrong result object\", Integer.valueOf(1), res\n+                    .getResultObject(key));\n+            assertFalse(\"Exception flag\", res.isException(key));\n+            assertNull(\"Got an exception\", res.getException(key));\n+            checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n+        }\n+        return res;\n+    }\n+\n+    /**\n+     * Tests background processing if a temporary executor is used.\n+     */\n+    public void testInitializeTempExec() throws ConcurrentException {\n+        checkInitialize();\n+        assertTrue(\"Executor not shutdown\", initializer.getActiveExecutor()\n+                .isShutdown());\n+    }\n+\n+    /**\n+     * Tests background processing if an external executor service is provided.\n+     */\n+    public void testInitializeExternalExec() throws ConcurrentException {\n+        ExecutorService exec = Executors.newCachedThreadPool();\n+        try {\n+            initializer = new MultiBackgroundInitializer(exec);\n+            checkInitialize();\n+            assertEquals(\"Wrong executor\", exec, initializer\n+                    .getActiveExecutor());\n+            assertFalse(\"Executor was shutdown\", exec.isShutdown());\n+        } finally {\n+            exec.shutdown();\n+        }\n+    }\n+\n+    /**\n+     * Tests the behavior of initialize() if a child initializer has a specific\n+     * executor service. Then this service should not be overridden.\n+     */\n+    public void testInitializeChildWithExecutor() throws ConcurrentException {\n+        final String initExec = \"childInitializerWithExecutor\";\n+        ExecutorService exec = Executors.newSingleThreadExecutor();\n+        try {\n+            ChildBackgroundInitializer c1 = new ChildBackgroundInitializer();\n+            ChildBackgroundInitializer c2 = new ChildBackgroundInitializer();\n+            c2.setExternalExecutor(exec);\n+            initializer.addInitializer(CHILD_INIT, c1);\n+            initializer.addInitializer(initExec, c2);\n+            initializer.start();\n+            initializer.get();\n+            checkChild(c1, initializer.getActiveExecutor());\n+            checkChild(c2, exec);\n+        } finally {\n+            exec.shutdown();\n+        }\n+    }\n+\n+    /**\n+     * Tries to add another child initializer after the start() method has been\n+     * called. This should not be allowed.\n+     */\n+    public void testAddInitializerAfterStart() throws ConcurrentException {\n+        initializer.start();\n+        try {\n+            initializer.addInitializer(CHILD_INIT,\n+                    new ChildBackgroundInitializer());\n+            fail(\"Could add initializer after start()!\");\n+        } catch (IllegalStateException istex) {\n+            initializer.get();\n+        }\n+    }\n+\n+    /**\n+     * Tries to query an unknown child initializer from the results object. This\n+     * should cause an exception.\n+     */\n+    public void testResultGetInitializerUnknown() throws ConcurrentException {\n+        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n+        try {\n+            res.getInitializer(\"unknown\");\n+            fail(\"Could obtain unknown child initializer!\");\n+        } catch (NoSuchElementException nex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tries to query the results of an unknown child initializer from the\n+     * results object. This should cause an exception.\n+     */\n+    public void testResultGetResultObjectUnknown() throws ConcurrentException {\n+        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n+        try {\n+            res.getResultObject(\"unknown\");\n+            fail(\"Could obtain results from unknown child initializer!\");\n+        } catch (NoSuchElementException nex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tries to query the exception of an unknown child initializer from the\n+     * results object. This should cause an exception.\n+     */\n+    public void testResultGetExceptionUnknown() throws ConcurrentException {\n+        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n+        try {\n+            res.getException(\"unknown\");\n+            fail(\"Could obtain exception from unknown child initializer!\");\n+        } catch (NoSuchElementException nex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tries to query the exception flag of an unknown child initializer from\n+     * the results object. This should cause an exception.\n+     */\n+    public void testResultIsExceptionUnknown() throws ConcurrentException {\n+        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n+        try {\n+            res.isException(\"unknown\");\n+            fail(\"Could obtain exception status from unknown child initializer!\");\n+        } catch (NoSuchElementException nex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tests that the set with the names of the initializers cannot be modified.\n+     */\n+    public void testResultInitializerNamesModify() throws ConcurrentException {\n+        checkInitialize();\n+        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n+                .get();\n+        Iterator<String> it = res.initializerNames().iterator();\n+        it.next();\n+        try {\n+            it.remove();\n+            fail(\"Could modify set with initializer names!\");\n+        } catch (UnsupportedOperationException uex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tests the behavior of the initializer if one of the child initializers\n+     * throws a runtime exception.\n+     */\n+    public void testInitializeRuntimeEx() {\n+        ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n+        child.ex = new RuntimeException();\n+        initializer.addInitializer(CHILD_INIT, child);\n+        initializer.start();\n+        try {\n+            initializer.get();\n+            fail(\"Runtime exception not thrown!\");\n+        } catch (Exception ex) {\n+            assertEquals(\"Wrong exception\", child.ex, ex);\n+        }\n+    }\n+\n+    /**\n+     * Tests the behavior of the initializer if one of the child initializers\n+     * throws a checked exception.\n+     */\n+    public void testInitializeEx() throws ConcurrentException {\n+        ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n+        child.ex = new Exception();\n+        initializer.addInitializer(CHILD_INIT, child);\n+        initializer.start();\n+        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n+                .get();\n+        assertTrue(\"No exception flag\", res.isException(CHILD_INIT));\n+        assertNull(\"Got a results object\", res.getResultObject(CHILD_INIT));\n+        ConcurrentException cex = res.getException(CHILD_INIT);\n+        assertEquals(\"Wrong cause\", child.ex, cex.getCause());\n+    }\n+\n+    /**\n+     * Tests whether MultiBackgroundInitializers can be combined in a nested\n+     * way.\n+     */\n+    public void testInitializeNested() throws ConcurrentException {\n+        final String nameMulti = \"multiChildInitializer\";\n+        initializer\n+                .addInitializer(CHILD_INIT, new ChildBackgroundInitializer());\n+        MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n+        final int count = 3;\n+        for (int i = 0; i < count; i++) {\n+            mi2\n+                    .addInitializer(CHILD_INIT + i,\n+                            new ChildBackgroundInitializer());\n+        }\n+        initializer.addInitializer(nameMulti, mi2);\n+        initializer.start();\n+        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n+                .get();\n+        ExecutorService exec = initializer.getActiveExecutor();\n+        checkChild(res.getInitializer(CHILD_INIT), exec);\n+        MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n+                .getResultObject(nameMulti);\n+        assertEquals(\"Wrong number of initializers\", count, res2\n+                .initializerNames().size());\n+        for (int i = 0; i < count; i++) {\n+            checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n+        }\n+        assertTrue(\"Executor not shutdown\", exec.isShutdown());\n+    }\n+\n+    /**\n+     * A concrete implementation of {@code BackgroundInitializer} used for\n+     * defining background tasks for {@code MultiBackgroundInitializer}.\n+     */\n+    private static class ChildBackgroundInitializer extends\n+            BackgroundInitializer<Integer> {\n+        /** Stores the current executor service. */\n+        volatile ExecutorService currentExecutor;\n+\n+        /** A counter for the invocations of initialize(). */\n+        volatile int initializeCalls;\n+\n+        /** An exception to be thrown by initialize(). */\n+        Exception ex;\n+\n+        /**\n+         * Records this invocation. Optionally throws an exception.\n+         */\n+        @Override\n+        protected Integer initialize() throws Exception {\n+            currentExecutor = getActiveExecutor();\n+            initializeCalls++;\n+\n+            if (ex != null) {\n+                throw ex;\n+            }\n+\n+            return initializeCalls;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/exception/ContextedExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.io.Serializable;\n+import java.util.Date;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.lang.StringUtils;\n+\n+/**\n+ * JUnit tests for ContextedException.\n+ * @author D. Ashmore\n+ *\n+ */\n+public class ContextedExceptionTest extends TestCase {\n+    \n+    private static final String TEST_MESSAGE_2 = \"This is monotonous\";\n+    private static final String TEST_MESSAGE = \"Test Message\";\n+    private ContextedException contextedException;\n+\n+    public ContextedExceptionTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testContextedException() {\n+        contextedException = new ContextedException();\n+        String message = contextedException.getMessage();\n+        String trace = ExceptionUtils.getStackTrace(contextedException);\n+        assertTrue(trace.indexOf(\"ContextedException\")>=0);\n+        assertTrue(StringUtils.isEmpty(message));\n+    }\n+\n+    public void testContextedExceptionString() {\n+        contextedException = new ContextedException(TEST_MESSAGE);\n+        assertEquals(TEST_MESSAGE, contextedException.getMessage());\n+        \n+        String trace = ExceptionUtils.getStackTrace(contextedException);\n+        assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n+    }\n+\n+    public void testContextedExceptionThrowable() {\n+        contextedException = new ContextedException(new Exception(TEST_MESSAGE));\n+        String message = contextedException.getMessage();\n+        String trace = ExceptionUtils.getStackTrace(contextedException);\n+        assertTrue(trace.indexOf(\"ContextedException\")>=0);\n+        assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n+        assertTrue(message.indexOf(TEST_MESSAGE)>=0);\n+    }\n+\n+    public void testContextedExceptionStringThrowable() {\n+        contextedException = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE));\n+        String message = contextedException.getMessage();\n+        String trace = ExceptionUtils.getStackTrace(contextedException);\n+        assertTrue(trace.indexOf(\"ContextedException\")>=0);\n+        assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n+        assertTrue(trace.indexOf(TEST_MESSAGE_2)>=0);\n+        assertTrue(message.indexOf(TEST_MESSAGE_2)>=0);\n+    }\n+    \n+    public void testContextedExceptionStringThrowableContext() {\n+        contextedException = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext());\n+        String message = contextedException.getMessage();\n+        String trace = ExceptionUtils.getStackTrace(contextedException);\n+        assertTrue(trace.indexOf(\"ContextedException\")>=0);\n+        assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n+        assertTrue(trace.indexOf(TEST_MESSAGE_2)>=0);\n+        assertTrue(message.indexOf(TEST_MESSAGE_2)>=0);\n+    }\n+\n+    public void testAddValue() {\n+        contextedException = new ContextedException(new Exception(TEST_MESSAGE))\n+        .addValue(\"test1\", null)\n+        .addValue(\"test2\", \"some value\")\n+        .addValue(\"test Date\", new Date())\n+        .addValue(\"test Nbr\", new Integer(5))\n+        .addValue(\"test Poorly written obj\", new ObjectWithFaultyToString());\n+        \n+        String message = contextedException.getMessage();\n+        assertTrue(message.indexOf(TEST_MESSAGE)>=0);\n+        assertTrue(message.indexOf(\"test1\")>=0);\n+        assertTrue(message.indexOf(\"test2\")>=0);\n+        assertTrue(message.indexOf(\"test Date\")>=0);\n+        assertTrue(message.indexOf(\"test Nbr\")>=0);\n+        assertTrue(message.indexOf(\"test Poorly written obj\")>=0);\n+        assertTrue(message.indexOf(\"some value\")>=0);\n+        assertTrue(message.indexOf(\"5\")>=0);\n+        assertTrue(message.indexOf(\"Crap\")>=0);\n+        \n+        assertTrue(contextedException.getValue(\"test1\") == null);\n+        assertTrue(contextedException.getValue(\"test2\").equals(\"some value\"));\n+        assertTrue(contextedException.getValue(\"crap\") == null);\n+        assertTrue(contextedException.getValue(\"test Poorly written obj\") instanceof ObjectWithFaultyToString);\n+        \n+        assertTrue(contextedException.getLabelSet().size() == 5);\n+        assertTrue(contextedException.getLabelSet().contains(\"test1\"));\n+        assertTrue(contextedException.getLabelSet().contains(\"test2\"));\n+        assertTrue(contextedException.getLabelSet().contains(\"test Date\"));\n+        assertTrue(contextedException.getLabelSet().contains(\"test Nbr\"));\n+        assertTrue(contextedException.getLabelSet().contains(\"test Poorly written obj\"));\n+        \n+        assertTrue(!contextedException.getLabelSet().contains(\"crap\"));\n+\n+        contextedException.addValue(\"test Poorly written obj\", \"replacement\");\n+        \n+        String contextMessage = contextedException.getFormattedExceptionMessage(null);\n+        assertTrue(contextMessage.indexOf(TEST_MESSAGE) == -1);\n+        assertTrue(contextedException.getMessage().endsWith(contextMessage));\n+    }\n+    \n+    public void testNullExceptionPassing() {\n+        contextedException = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null)\n+        .addValue(\"test1\", null)\n+        .addValue(\"test2\", \"some value\")\n+        .addValue(\"test Date\", new Date())\n+        .addValue(\"test Nbr\", new Integer(5))\n+        .addValue(\"test Poorly written obj\", new ObjectWithFaultyToString());\n+        \n+        String message = contextedException.getMessage();\n+        assertTrue(message != null);\n+    }\n+\n+    public void testGetMessage() {\n+        testAddValue();\n+    }\n+    \n+    static class ObjectWithFaultyToString implements Serializable {\n+\n+        private static final long serialVersionUID = 3495843995332310458L;\n+\n+        @Override\n+        public String toString() {\n+            throw new RuntimeException(\"Crap\");\n+        }\n+        \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/exception/ContextedRuntimeExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.util.Date;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.commons.lang.exception.ContextedExceptionTest.ObjectWithFaultyToString;\n+\n+/**\n+ * JUnit tests for ContextedRuntimeException.\n+ * @author D. Ashmore\n+ *\n+ */\n+public class ContextedRuntimeExceptionTest extends TestCase {\n+    \n+    private static final String TEST_MESSAGE_2 = \"This is monotonous\";\n+    private static final String TEST_MESSAGE = \"Test Message\";\n+    private ContextedRuntimeException contextedRuntimeException;\n+\n+    public ContextedRuntimeExceptionTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testContextedException() {\n+        contextedRuntimeException = new ContextedRuntimeException();\n+        String message = contextedRuntimeException.getMessage();\n+        String trace = ExceptionUtils.getStackTrace(contextedRuntimeException);\n+        assertTrue(trace.indexOf(\"ContextedException\")>=0);\n+        assertTrue(StringUtils.isEmpty(message));\n+    }\n+\n+    public void testContextedExceptionString() {\n+        contextedRuntimeException = new ContextedRuntimeException(TEST_MESSAGE);\n+        assertEquals(TEST_MESSAGE, contextedRuntimeException.getMessage());\n+        \n+        String trace = ExceptionUtils.getStackTrace(contextedRuntimeException);\n+        assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n+    }\n+\n+    public void testContextedExceptionThrowable() {\n+        contextedRuntimeException = new ContextedRuntimeException(new Exception(TEST_MESSAGE));\n+        String message = contextedRuntimeException.getMessage();\n+        String trace = ExceptionUtils.getStackTrace(contextedRuntimeException);\n+        assertTrue(trace.indexOf(\"ContextedException\")>=0);\n+        assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n+        assertTrue(message.indexOf(TEST_MESSAGE)>=0);\n+    }\n+\n+    public void testContextedExceptionStringThrowable() {\n+        contextedRuntimeException = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE));\n+        String message = contextedRuntimeException.getMessage();\n+        String trace = ExceptionUtils.getStackTrace(contextedRuntimeException);\n+        assertTrue(trace.indexOf(\"ContextedException\")>=0);\n+        assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n+        assertTrue(trace.indexOf(TEST_MESSAGE_2)>=0);\n+        assertTrue(message.indexOf(TEST_MESSAGE_2)>=0);\n+    }\n+    \n+    public void testContextedExceptionStringThrowableContext() {\n+        contextedRuntimeException = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext());\n+        String message = contextedRuntimeException.getMessage();\n+        String trace = ExceptionUtils.getStackTrace(contextedRuntimeException);\n+        assertTrue(trace.indexOf(\"ContextedException\")>=0);\n+        assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n+        assertTrue(trace.indexOf(TEST_MESSAGE_2)>=0);\n+        assertTrue(message.indexOf(TEST_MESSAGE_2)>=0);\n+    }\n+\n+    public void testAddValue() {\n+        contextedRuntimeException = new ContextedRuntimeException(new Exception(TEST_MESSAGE))\n+        .addValue(\"test1\", null)\n+        .addValue(\"test2\", \"some value\")\n+        .addValue(\"test Date\", new Date())\n+        .addValue(\"test Nbr\", new Integer(5))\n+        .addValue(\"test Poorly written obj\", new ObjectWithFaultyToString());\n+        \n+        String message = contextedRuntimeException.getMessage();\n+        assertTrue(message.indexOf(TEST_MESSAGE)>=0);\n+        assertTrue(message.indexOf(\"test1\")>=0);\n+        assertTrue(message.indexOf(\"test2\")>=0);\n+        assertTrue(message.indexOf(\"test Date\")>=0);\n+        assertTrue(message.indexOf(\"test Nbr\")>=0);\n+        assertTrue(message.indexOf(\"test Poorly written obj\")>=0);\n+        assertTrue(message.indexOf(\"some value\")>=0);\n+        assertTrue(message.indexOf(\"5\")>=0);\n+        assertTrue(message.indexOf(\"Crap\")>=0);\n+        \n+        assertTrue(contextedRuntimeException.getValue(\"test1\") == null);\n+        assertTrue(contextedRuntimeException.getValue(\"test2\").equals(\"some value\"));\n+        assertTrue(contextedRuntimeException.getValue(\"crap\") == null);\n+        assertTrue(contextedRuntimeException.getValue(\"test Poorly written obj\") instanceof ObjectWithFaultyToString);\n+        \n+        assertTrue(contextedRuntimeException.getLabelSet().size() == 5);\n+        assertTrue(contextedRuntimeException.getLabelSet().contains(\"test1\"));\n+        assertTrue(contextedRuntimeException.getLabelSet().contains(\"test2\"));\n+        assertTrue(contextedRuntimeException.getLabelSet().contains(\"test Date\"));\n+        assertTrue(contextedRuntimeException.getLabelSet().contains(\"test Nbr\"));\n+        assertTrue(contextedRuntimeException.getLabelSet().contains(\"test Poorly written obj\"));\n+        \n+        assertTrue(!contextedRuntimeException.getLabelSet().contains(\"crap\"));\n+\n+        contextedRuntimeException.addValue(\"test Poorly written obj\", \"replacement\");\n+        \n+        String contextMessage = contextedRuntimeException.getFormattedExceptionMessage(null);\n+        assertTrue(contextMessage.indexOf(TEST_MESSAGE) == -1);\n+        assertTrue(contextedRuntimeException.getMessage().endsWith(contextMessage));\n+    }\n+    \n+    public void testNullExceptionPassing() {\n+        contextedRuntimeException = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null)\n+        .addValue(\"test1\", null)\n+        .addValue(\"test2\", \"some value\")\n+        .addValue(\"test Date\", new Date())\n+        .addValue(\"test Nbr\", new Integer(5))\n+        .addValue(\"test Poorly written obj\", new ObjectWithFaultyToString());\n+        \n+        String message = contextedRuntimeException.getMessage();\n+        assertTrue(message != null);\n+    }\n+\n+    public void testGetMessage() {\n+        testAddValue();\n+    }\n+    \n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/exception/DefaultExceptionContextTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.util.Date;\n+\n+import org.apache.commons.lang.exception.ContextedExceptionTest.ObjectWithFaultyToString;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * JUnit tests for DefaultExceptionContext\n+ * @author D. Ashmore\n+ *\n+ */\n+public class DefaultExceptionContextTest extends TestCase {\n+    \n+    private ExceptionContext defaultExceptionContext;\n+\n+    public DefaultExceptionContextTest(String name) {\n+        super(name);\n+    }\n+    \n+    @Override\n+    public void setUp() {\n+        defaultExceptionContext = new DefaultExceptionContext()\n+        .addValue(\"test1\", null)\n+        .addValue(\"test2\", \"some value\")\n+        .addValue(\"test Date\", new Date())\n+        .addValue(\"test Nbr\", new Integer(5))\n+        .addValue(\"test Poorly written obj\", new ObjectWithFaultyToString());\n+    }\n+    \n+    public void testAddValue() {\n+                \n+        String message = defaultExceptionContext.getFormattedExceptionMessage(\"This is an error\");\n+        assertTrue(message.indexOf(\"This is an error\")>=0);\n+        assertTrue(message.indexOf(\"test1\")>=0);\n+        assertTrue(message.indexOf(\"test2\")>=0);\n+        assertTrue(message.indexOf(\"test Date\")>=0);\n+        assertTrue(message.indexOf(\"test Nbr\")>=0);\n+        assertTrue(message.indexOf(\"test Poorly written obj\")>=0);\n+        assertTrue(message.indexOf(\"some value\")>=0);\n+        assertTrue(message.indexOf(\"5\")>=0);\n+        assertTrue(message.indexOf(\"Crap\")>=0);\n+        \n+        //contextedException.printStackTrace();\n+    }\n+    \n+    public void testFormattedExceptionMessageNull() {\n+        defaultExceptionContext = new DefaultExceptionContext();\n+        defaultExceptionContext.getFormattedExceptionMessage(null);\n+    }\n+    \n+    public void testGetValue() {\n+        assertTrue(defaultExceptionContext.getValue(\"test1\") == null);\n+        assertTrue(defaultExceptionContext.getValue(\"test2\").equals(\"some value\"));\n+        assertTrue(defaultExceptionContext.getValue(\"crap\") == null);\n+        assertTrue(defaultExceptionContext.getValue(\"test Poorly written obj\") instanceof ObjectWithFaultyToString);\n+    }\n+    \n+    public void testGetLabelSet() {\n+        assertTrue(defaultExceptionContext.getLabelSet().size() == 5);\n+        assertTrue(defaultExceptionContext.getLabelSet().contains(\"test1\"));\n+        assertTrue(defaultExceptionContext.getLabelSet().contains(\"test2\"));\n+        assertTrue(defaultExceptionContext.getLabelSet().contains(\"test Date\"));\n+        assertTrue(defaultExceptionContext.getLabelSet().contains(\"test Nbr\"));\n+        assertTrue(defaultExceptionContext.getLabelSet().contains(\"test Poorly written obj\"));\n+        \n+        assertTrue(!defaultExceptionContext.getLabelSet().contains(\"crap\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/exception/ExceptionUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Modifier;\n+import java.sql.SQLException;\n+import java.util.List;\n+\n+import junit.framework.Assert;\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.lang.SystemUtils;\n+\n+/**\n+ * Tests {@link org.apache.commons.lang.exception.ExceptionUtils}.\n+ * \n+ * <h3>Notes</h3>\n+ * <p>\n+ * Make sure this exception code does not depend on Java 1.4 nested exceptions. SVN revision 38990 does not compile with\n+ * Java 1.3.1.\n+ * </p>\n+ * <ul>\n+ * <li>Compiled with Sun Java 1.3.1_15</li>\n+ * <li>Tested with Sun Java 1.3.1_15</li>\n+ * <li>Tested with Sun Java 1.4.2_12</li>\n+ * <li>Tested with Sun Java 1.5.0_08</li>\n+ * <li>All of the above on Windows XP SP2 + patches.</li>\n+ * </ul>\n+ * <p>\n+ * Gary Gregory; August 16, 2006.\n+ * </p>\n+ * \n+ * @author Apache Software Foundation\n+ * @author Daniel L. Rall\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @since 1.0\n+ */\n+public class ExceptionUtilsTest extends TestCase {\n+    \n+    private NestableException nested;\n+    private Throwable withCause;\n+    private Throwable withoutCause;\n+    private Throwable jdkNoCause;\n+    private ExceptionWithCause selfCause;\n+    private ExceptionWithCause cyclicCause;\n+\n+    public ExceptionUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(ExceptionUtilsTest.class);\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        withoutCause = createExceptionWithoutCause();\n+        nested = new NestableException(withoutCause);\n+        withCause = new ExceptionWithCause(nested);\n+        jdkNoCause = new NullPointerException();\n+        selfCause = new ExceptionWithCause(null);\n+        selfCause.setCause(selfCause);\n+        ExceptionWithCause a = new ExceptionWithCause(null);\n+        ExceptionWithCause b = new ExceptionWithCause(a);\n+        a.setCause(b);\n+        cyclicCause = new ExceptionWithCause(a);\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        withoutCause = null;\n+        nested = null;\n+        withCause = null;\n+        jdkNoCause = null;\n+        selfCause = null;\n+        cyclicCause = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private Throwable createExceptionWithoutCause() {\n+        try {\n+            throw new ExceptionWithoutCause();\n+        } catch (Throwable t) {\n+            return t;\n+        }\n+    }\n+\n+    private Throwable createExceptionWithCause() {\n+        try {\n+            try {\n+                throw new ExceptionWithCause(createExceptionWithoutCause());\n+            } catch (Throwable t) {\n+                throw new ExceptionWithCause(t);\n+            }\n+        } catch (Throwable t) {\n+            return t;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public void testConstructor() {\n+        assertNotNull(new ExceptionUtils());\n+        Constructor<?>[] cons = ExceptionUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(ExceptionUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(ExceptionUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    \n+    public void testCauseMethodNameOps() {\n+        this.testCauseMethodNameOps(null);\n+        this.testCauseMethodNameOps(\"\");\n+        this.testCauseMethodNameOps(\" \");\n+        this.testCauseMethodNameOps(\"\\t\\r\\n\\t\");\n+        this.testCauseMethodNameOps(\"testMethodName\");\n+    }\n+    \n+    void testCauseMethodNameOps(String name) {\n+        String methodName = \"testMethodName\";\n+        try {\n+            Assert.assertFalse(ExceptionUtils.isCauseMethodName(methodName));\n+            ExceptionUtils.addCauseMethodName(methodName);            \n+            ExceptionUtils.addCauseMethodName(methodName);            \n+            Assert.assertTrue(ExceptionUtils.isCauseMethodName(methodName));\n+        } finally {\n+            ExceptionUtils.removeCauseMethodName(methodName);\n+            Assert.assertFalse(\n+                    \"The method name \" + methodName + \" should not be in the array\", \n+                    ExceptionUtils.isCauseMethodName(methodName));\n+        }\n+    }\n+    \n+    public void testGetCause_Throwable() {\n+        assertSame(null, ExceptionUtils.getCause(null));\n+        assertSame(null, ExceptionUtils.getCause(withoutCause));\n+        assertSame(withoutCause, ExceptionUtils.getCause(nested));\n+        assertSame(nested, ExceptionUtils.getCause(withCause));\n+        assertSame(null, ExceptionUtils.getCause(jdkNoCause));\n+        assertSame(selfCause, ExceptionUtils.getCause(selfCause));\n+        assertSame(cyclicCause.getCause(), ExceptionUtils.getCause(cyclicCause));\n+        assertSame(((ExceptionWithCause) cyclicCause.getCause()).getCause(), ExceptionUtils.getCause(cyclicCause.getCause()));\n+        assertSame(cyclicCause.getCause(), ExceptionUtils.getCause(((ExceptionWithCause) cyclicCause.getCause()).getCause()));\n+    }\n+\n+    public void testGetCause_ThrowableArray() {\n+        assertSame(null, ExceptionUtils.getCause(null, null));\n+        assertSame(null, ExceptionUtils.getCause(null, new String[0]));\n+\n+        // not known type, so match on supplied method names\n+        assertSame(nested, ExceptionUtils.getCause(withCause, null));  // default names\n+        assertSame(null, ExceptionUtils.getCause(withCause, new String[0]));\n+        assertSame(null, ExceptionUtils.getCause(withCause, new String[] {null}));\n+        assertSame(nested, ExceptionUtils.getCause(withCause, new String[] {\"getCause\"}));\n+        \n+        // not known type, so match on supplied method names\n+        assertSame(null, ExceptionUtils.getCause(withoutCause, null));\n+        assertSame(null, ExceptionUtils.getCause(withoutCause, new String[0]));\n+        assertSame(null, ExceptionUtils.getCause(withoutCause, new String[] {null}));\n+        assertSame(null, ExceptionUtils.getCause(withoutCause, new String[] {\"getCause\"}));\n+        assertSame(null, ExceptionUtils.getCause(withoutCause, new String[] {\"getTargetException\"}));\n+    }\n+\n+    public void testGetRootCause_Throwable() {\n+        assertSame(null, ExceptionUtils.getRootCause(null));\n+        assertSame(null, ExceptionUtils.getRootCause(withoutCause));\n+        assertSame(withoutCause, ExceptionUtils.getRootCause(nested));\n+        assertSame(withoutCause, ExceptionUtils.getRootCause(withCause));\n+        assertSame(null, ExceptionUtils.getRootCause(jdkNoCause));\n+        assertSame(null, ExceptionUtils.getRootCause(selfCause));\n+        assertSame(((ExceptionWithCause) cyclicCause.getCause()).getCause(), ExceptionUtils.getRootCause(cyclicCause));\n+    }\n+\n+    public void testSetCause() {\n+        Exception cause = new ExceptionWithoutCause();\n+        assertEquals(true, ExceptionUtils.setCause(new ExceptionWithCause(null), cause));\n+        if (SystemUtils.isJavaVersionAtLeast(140)) {\n+            assertEquals(true, ExceptionUtils.setCause(new ExceptionWithoutCause(), cause));\n+        }\n+    }\n+\n+    /**\n+     * Tests overriding a cause to <code>null</code>.\n+     */\n+    public void testSetCauseToNull() {\n+        Exception ex = new ExceptionWithCause(new IOException());\n+        assertEquals(true, ExceptionUtils.setCause(ex, new IllegalStateException()));\n+        assertNotNull(ExceptionUtils.getCause(ex));\n+        assertEquals(true, ExceptionUtils.setCause(ex, null));\n+        assertNull(ExceptionUtils.getCause(ex));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsThrowableNested() {\n+        if (SystemUtils.isJavaVersionAtLeast(140)) {\n+            assertEquals(true, ExceptionUtils.isThrowableNested());\n+        } else {\n+            assertEquals(false, ExceptionUtils.isThrowableNested());\n+        }\n+    }\n+    \n+    public void testIsNestedThrowable_Throwable() {\n+        assertEquals(true, ExceptionUtils.isNestedThrowable(new SQLException()));\n+        assertEquals(true, ExceptionUtils.isNestedThrowable(new InvocationTargetException(new Exception())));\n+        assertEquals(true, ExceptionUtils.isNestedThrowable(new NestableRuntimeException()));\n+        assertEquals(true, ExceptionUtils.isNestedThrowable(withCause));\n+        assertEquals(true, ExceptionUtils.isNestedThrowable(nested));\n+        if (SystemUtils.isJavaVersionAtLeast(140)) {\n+            assertEquals(true, ExceptionUtils.isNestedThrowable(withoutCause));\n+            assertEquals(true, ExceptionUtils.isNestedThrowable(new Throwable()));\n+        } else {\n+            assertEquals(false, ExceptionUtils.isNestedThrowable(withoutCause));\n+            assertEquals(false, ExceptionUtils.isNestedThrowable(new Throwable()));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetThrowableCount_Throwable() {\n+        assertEquals(0, ExceptionUtils.getThrowableCount(null));\n+        assertEquals(1, ExceptionUtils.getThrowableCount(withoutCause));\n+        assertEquals(2, ExceptionUtils.getThrowableCount(nested));\n+        assertEquals(3, ExceptionUtils.getThrowableCount(withCause));\n+        assertEquals(1, ExceptionUtils.getThrowableCount(jdkNoCause));\n+        assertEquals(1, ExceptionUtils.getThrowableCount(selfCause));\n+        assertEquals(3, ExceptionUtils.getThrowableCount(cyclicCause));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetThrowables_Throwable_null() {\n+        assertEquals(0, ExceptionUtils.getThrowables(null).length);\n+    }\n+\n+    public void testGetThrowables_Throwable_withoutCause() {\n+        Throwable[] throwables = ExceptionUtils.getThrowables(withoutCause);\n+        assertEquals(1, throwables.length);\n+        assertSame(withoutCause, throwables[0]);\n+    }\n+\n+    public void testGetThrowables_Throwable_nested() {\n+        Throwable[] throwables = ExceptionUtils.getThrowables(nested);\n+        assertEquals(2, throwables.length);\n+        assertSame(nested, throwables[0]);\n+        assertSame(withoutCause, throwables[1]);\n+    }\n+\n+    public void testGetThrowables_Throwable_withCause() {\n+        Throwable[] throwables = ExceptionUtils.getThrowables(withCause);\n+        assertEquals(3, throwables.length);\n+        assertSame(withCause, throwables[0]);\n+        assertSame(nested, throwables[1]);\n+        assertSame(withoutCause, throwables[2]);\n+    }\n+\n+    public void testGetThrowables_Throwable_jdkNoCause() {\n+        Throwable[] throwables = ExceptionUtils.getThrowables(jdkNoCause);\n+        assertEquals(1, throwables.length);\n+        assertSame(jdkNoCause, throwables[0]);\n+    }\n+\n+    public void testGetThrowables_Throwable_selfCause() {\n+        Throwable[] throwables = ExceptionUtils.getThrowables(selfCause);\n+        assertEquals(1, throwables.length);\n+        assertSame(selfCause, throwables[0]);\n+    }\n+\n+    public void testGetThrowables_Throwable_recursiveCause() {\n+        Throwable[] throwables = ExceptionUtils.getThrowables(cyclicCause);\n+        assertEquals(3, throwables.length);\n+        assertSame(cyclicCause, throwables[0]);\n+        assertSame(cyclicCause.getCause(), throwables[1]);\n+        assertSame(((ExceptionWithCause) cyclicCause.getCause()).getCause(), throwables[2]);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetThrowableList_Throwable_null() {\n+        List<?> throwables = ExceptionUtils.getThrowableList(null);\n+        assertEquals(0, throwables.size());\n+    }\n+\n+    public void testGetThrowableList_Throwable_withoutCause() {\n+        List<?> throwables = ExceptionUtils.getThrowableList(withoutCause);\n+        assertEquals(1, throwables.size());\n+        assertSame(withoutCause, throwables.get(0));\n+    }\n+\n+    public void testGetThrowableList_Throwable_nested() {\n+        List<?> throwables = ExceptionUtils.getThrowableList(nested);\n+        assertEquals(2, throwables.size());\n+        assertSame(nested, throwables.get(0));\n+        assertSame(withoutCause, throwables.get(1));\n+    }\n+\n+    public void testGetThrowableList_Throwable_withCause() {\n+        List<?> throwables = ExceptionUtils.getThrowableList(withCause);\n+        assertEquals(3, throwables.size());\n+        assertSame(withCause, throwables.get(0));\n+        assertSame(nested, throwables.get(1));\n+        assertSame(withoutCause, throwables.get(2));\n+    }\n+\n+    public void testGetThrowableList_Throwable_jdkNoCause() {\n+        List<?> throwables = ExceptionUtils.getThrowableList(jdkNoCause);\n+        assertEquals(1, throwables.size());\n+        assertSame(jdkNoCause, throwables.get(0));\n+    }\n+\n+    public void testGetThrowableList_Throwable_selfCause() {\n+        List<?> throwables = ExceptionUtils.getThrowableList(selfCause);\n+        assertEquals(1, throwables.size());\n+        assertSame(selfCause, throwables.get(0));\n+    }\n+\n+    public void testGetThrowableList_Throwable_recursiveCause() {\n+        List<?> throwables = ExceptionUtils.getThrowableList(cyclicCause);\n+        assertEquals(3, throwables.size());\n+        assertSame(cyclicCause, throwables.get(0));\n+        assertSame(cyclicCause.getCause(), throwables.get(1));\n+        assertSame(((ExceptionWithCause) cyclicCause.getCause()).getCause(), throwables.get(2));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIndexOf_ThrowableClass() {\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(null, null));\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(null, NestableException.class));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, null));\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, ExceptionWithCause.class));\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, NestableException.class));\n+        assertEquals(0, ExceptionUtils.indexOfThrowable(withoutCause, ExceptionWithoutCause.class));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(nested, null));\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(nested, ExceptionWithCause.class));\n+        assertEquals(0, ExceptionUtils.indexOfThrowable(nested, NestableException.class));\n+        assertEquals(1, ExceptionUtils.indexOfThrowable(nested, ExceptionWithoutCause.class));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, null));\n+        assertEquals(0, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class));\n+        assertEquals(1, ExceptionUtils.indexOfThrowable(withCause, NestableException.class));\n+        assertEquals(2, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithoutCause.class));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, Exception.class));\n+    }\n+\n+    public void testIndexOf_ThrowableClassInt() {\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(null, null, 0));\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(null, NestableException.class, 0));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, null));\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, ExceptionWithCause.class, 0));\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, NestableException.class, 0));\n+        assertEquals(0, ExceptionUtils.indexOfThrowable(withoutCause, ExceptionWithoutCause.class, 0));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(nested, null, 0));\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(nested, ExceptionWithCause.class, 0));\n+        assertEquals(0, ExceptionUtils.indexOfThrowable(nested, NestableException.class, 0));\n+        assertEquals(1, ExceptionUtils.indexOfThrowable(nested, ExceptionWithoutCause.class, 0));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, null));\n+        assertEquals(0, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class, 0));\n+        assertEquals(1, ExceptionUtils.indexOfThrowable(withCause, NestableException.class, 0));\n+        assertEquals(2, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithoutCause.class, 0));\n+\n+        assertEquals(0, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class, -1));\n+        assertEquals(0, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class, 0));\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class, 1));\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class, 9));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, Exception.class, 0));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIndexOfType_ThrowableClass() {\n+        assertEquals(-1, ExceptionUtils.indexOfType(null, null));\n+        assertEquals(-1, ExceptionUtils.indexOfType(null, NestableException.class));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, null));\n+        assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, ExceptionWithCause.class));\n+        assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, NestableException.class));\n+        assertEquals(0, ExceptionUtils.indexOfType(withoutCause, ExceptionWithoutCause.class));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfType(nested, null));\n+        assertEquals(-1, ExceptionUtils.indexOfType(nested, ExceptionWithCause.class));\n+        assertEquals(0, ExceptionUtils.indexOfType(nested, NestableException.class));\n+        assertEquals(1, ExceptionUtils.indexOfType(nested, ExceptionWithoutCause.class));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfType(withCause, null));\n+        assertEquals(0, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class));\n+        assertEquals(1, ExceptionUtils.indexOfType(withCause, NestableException.class));\n+        assertEquals(2, ExceptionUtils.indexOfType(withCause, ExceptionWithoutCause.class));\n+        \n+        assertEquals(0, ExceptionUtils.indexOfType(withCause, Exception.class));\n+    }\n+\n+    public void testIndexOfType_ThrowableClassInt() {\n+        assertEquals(-1, ExceptionUtils.indexOfType(null, null, 0));\n+        assertEquals(-1, ExceptionUtils.indexOfType(null, NestableException.class, 0));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, null));\n+        assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, ExceptionWithCause.class, 0));\n+        assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, NestableException.class, 0));\n+        assertEquals(0, ExceptionUtils.indexOfType(withoutCause, ExceptionWithoutCause.class, 0));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfType(nested, null, 0));\n+        assertEquals(-1, ExceptionUtils.indexOfType(nested, ExceptionWithCause.class, 0));\n+        assertEquals(0, ExceptionUtils.indexOfType(nested, NestableException.class, 0));\n+        assertEquals(1, ExceptionUtils.indexOfType(nested, ExceptionWithoutCause.class, 0));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfType(withCause, null));\n+        assertEquals(0, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class, 0));\n+        assertEquals(1, ExceptionUtils.indexOfType(withCause, NestableException.class, 0));\n+        assertEquals(2, ExceptionUtils.indexOfType(withCause, ExceptionWithoutCause.class, 0));\n+\n+        assertEquals(0, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class, -1));\n+        assertEquals(0, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class, 0));\n+        assertEquals(-1, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class, 1));\n+        assertEquals(-1, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class, 9));\n+        \n+        assertEquals(0, ExceptionUtils.indexOfType(withCause, Exception.class, 0));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPrintRootCauseStackTrace_Throwable() throws Exception {\n+        ExceptionUtils.printRootCauseStackTrace(null);\n+        // could pipe system.err to a known stream, but not much point as\n+        // internally this method calls stram method anyway\n+    }\n+    \n+    public void testPrintRootCauseStackTrace_ThrowableStream() throws Exception {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream(1024);\n+        ExceptionUtils.printRootCauseStackTrace(null, (PrintStream) null);\n+        ExceptionUtils.printRootCauseStackTrace(null, new PrintStream(out));\n+        assertEquals(0, out.toString().length());\n+        \n+        out = new ByteArrayOutputStream(1024);\n+        try {\n+            ExceptionUtils.printRootCauseStackTrace(withCause, (PrintStream) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+        \n+        out = new ByteArrayOutputStream(1024);\n+        Throwable withCause = createExceptionWithCause();\n+        ExceptionUtils.printRootCauseStackTrace(withCause, new PrintStream(out));\n+        String stackTrace = out.toString();\n+        assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1);\n+        \n+        out = new ByteArrayOutputStream(1024);\n+        ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintStream(out));\n+        stackTrace = out.toString();\n+        assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1);\n+    }\n+\n+    public void testPrintRootCauseStackTrace_ThrowableWriter() throws Exception {\n+        StringWriter writer = new StringWriter(1024);\n+        ExceptionUtils.printRootCauseStackTrace(null, (PrintWriter) null);\n+        ExceptionUtils.printRootCauseStackTrace(null, new PrintWriter(writer));\n+        assertEquals(0, writer.getBuffer().length());\n+        \n+        writer = new StringWriter(1024);\n+        try {\n+            ExceptionUtils.printRootCauseStackTrace(withCause, (PrintWriter) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+        \n+        writer = new StringWriter(1024);\n+        Throwable withCause = createExceptionWithCause();\n+        ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(writer));\n+        String stackTrace = writer.toString();\n+        assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1);\n+        \n+        writer = new StringWriter(1024);\n+        ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintWriter(writer));\n+        stackTrace = writer.toString();\n+        assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetRootCauseStackTrace_Throwable() throws Exception {\n+        assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length);\n+        \n+        Throwable withCause = createExceptionWithCause();\n+        String[] stackTrace = ExceptionUtils.getRootCauseStackTrace(withCause);\n+        boolean match = false;\n+        for (int i = 0; i < stackTrace.length; i++) {\n+            if (stackTrace[i].startsWith(ExceptionUtils.WRAPPED_MARKER)) {\n+                match = true;\n+                break;\n+            }\n+        }\n+        assertEquals(true, match);\n+        \n+        stackTrace = ExceptionUtils.getRootCauseStackTrace(withoutCause);\n+        match = false;\n+        for (int i = 0; i < stackTrace.length; i++) {\n+            if (stackTrace[i].startsWith(ExceptionUtils.WRAPPED_MARKER)) {\n+                match = true;\n+                break;\n+            }\n+        }\n+        assertEquals(false, match);\n+    }\n+\n+    public void testRemoveCommonFrames_ListList() throws Exception {\n+        try {\n+            ExceptionUtils.removeCommonFrames(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+    }\n+\n+    public void test_getMessage_Throwable() {\n+        Throwable th = null;\n+        assertEquals(\"\", ExceptionUtils.getMessage(th));\n+        \n+        th = new IllegalArgumentException(\"Base\");\n+        assertEquals(\"IllegalArgumentException: Base\", ExceptionUtils.getMessage(th));\n+        \n+        th = new ExceptionWithCause(\"Wrapper\", th);\n+        assertEquals(\"ExceptionUtilsTest.ExceptionWithCause: Wrapper\", ExceptionUtils.getMessage(th));\n+    }\n+\n+    public void test_getRootCauseMessage_Throwable() {\n+        Throwable th = null;\n+        assertEquals(\"\", ExceptionUtils.getRootCauseMessage(th));\n+        \n+        th = new IllegalArgumentException(\"Base\");\n+        assertEquals(\"IllegalArgumentException: Base\", ExceptionUtils.getRootCauseMessage(th));\n+        \n+        th = new ExceptionWithCause(\"Wrapper\", th);\n+        assertEquals(\"IllegalArgumentException: Base\", ExceptionUtils.getRootCauseMessage(th));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Provides a method with a well known chained/nested exception\n+     * name which matches the full signature (e.g. has a return value\n+     * of <code>Throwable</code>.\n+     */\n+    private static class ExceptionWithCause extends Exception {\n+        private Throwable cause;\n+\n+        public ExceptionWithCause(String str, Throwable cause) {\n+            super(str);\n+            setCause(cause);\n+        }\n+\n+        public ExceptionWithCause(Throwable cause) {\n+            super();\n+            setCause(cause);\n+        }\n+\n+        @Override\n+        public Throwable getCause() {\n+            return cause;\n+        }\n+\n+        public void setCause(Throwable cause) {\n+            this.cause = cause;\n+        }\n+    }\n+\n+    /**\n+     * Provides a method with a well known chained/nested exception\n+     * name which does not match the full signature (e.g. lacks a\n+     * return value of <code>Throwable</code>.\n+     */\n+    private static class ExceptionWithoutCause extends Exception {\n+        @SuppressWarnings(\"unused\")\n+        public void getTargetException() {\n+        }\n+    }\n+\n+    // Temporary classes to allow the nested exception code to be removed \n+    // prior to a rewrite of this test class. \n+    private static class NestableRuntimeException extends RuntimeException { \n+        public NestableRuntimeException() { super(); }\n+        @SuppressWarnings(\"unused\")\n+        public NestableRuntimeException(Throwable t) { super(t); }\n+    }\n+    private static class NestableException extends Exception { \n+        @SuppressWarnings(\"unused\")\n+        public NestableException() { super(); }\n+        public NestableException(Throwable t) { super(t); }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/math/FractionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link Fraction} class\n+ *\n+ * @author Apache Software Foundation\n+ * @author C. Scott Ananian\n+ * @version $Id$\n+ */\n+public class FractionTest extends TestCase {\n+    \n+    private static final int SKIP = 500;  //53\n+\n+    public FractionTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(FractionTest.class);\n+        suite.setName(\"Fraction Tests\");\n+        return suite;\n+    }\n+    \n+    @Override\n+    public void setUp() {\n+    }\n+\n+    //--------------------------------------------------------------------------\n+    \n+    public void testConstants() {\n+        assertEquals(0, Fraction.ZERO.getNumerator());\n+        assertEquals(1, Fraction.ZERO.getDenominator());\n+        \n+        assertEquals(1, Fraction.ONE.getNumerator());\n+        assertEquals(1, Fraction.ONE.getDenominator());\n+        \n+        assertEquals(1, Fraction.ONE_HALF.getNumerator());\n+        assertEquals(2, Fraction.ONE_HALF.getDenominator());\n+        \n+        assertEquals(1, Fraction.ONE_THIRD.getNumerator());\n+        assertEquals(3, Fraction.ONE_THIRD.getDenominator());\n+        \n+        assertEquals(2, Fraction.TWO_THIRDS.getNumerator());\n+        assertEquals(3, Fraction.TWO_THIRDS.getDenominator());\n+        \n+        assertEquals(1, Fraction.ONE_QUARTER.getNumerator());\n+        assertEquals(4, Fraction.ONE_QUARTER.getDenominator());\n+        \n+        assertEquals(2, Fraction.TWO_QUARTERS.getNumerator());\n+        assertEquals(4, Fraction.TWO_QUARTERS.getDenominator());\n+        \n+        assertEquals(3, Fraction.THREE_QUARTERS.getNumerator());\n+        assertEquals(4, Fraction.THREE_QUARTERS.getDenominator());\n+        \n+        assertEquals(1, Fraction.ONE_FIFTH.getNumerator());\n+        assertEquals(5, Fraction.ONE_FIFTH.getDenominator());\n+        \n+        assertEquals(2, Fraction.TWO_FIFTHS.getNumerator());\n+        assertEquals(5, Fraction.TWO_FIFTHS.getDenominator());\n+        \n+        assertEquals(3, Fraction.THREE_FIFTHS.getNumerator());\n+        assertEquals(5, Fraction.THREE_FIFTHS.getDenominator());\n+        \n+        assertEquals(4, Fraction.FOUR_FIFTHS.getNumerator());\n+        assertEquals(5, Fraction.FOUR_FIFTHS.getDenominator());\n+    }\n+\n+    public void testFactory_int_int() {\n+        Fraction f = null;\n+        \n+        // zero\n+        f = Fraction.getFraction(0, 1);\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f = Fraction.getFraction(0, 2);\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        // normal\n+        f = Fraction.getFraction(1, 1);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f = Fraction.getFraction(2, 1);\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f = Fraction.getFraction(23, 345);\n+        assertEquals(23, f.getNumerator());\n+        assertEquals(345, f.getDenominator());\n+        \n+        // improper\n+        f = Fraction.getFraction(22, 7);\n+        assertEquals(22, f.getNumerator());\n+        assertEquals(7, f.getDenominator());\n+        \n+        // negatives\n+        f = Fraction.getFraction(-6, 10);\n+        assertEquals(-6, f.getNumerator());\n+        assertEquals(10, f.getDenominator());\n+        \n+        f = Fraction.getFraction(6, -10);\n+        assertEquals(-6, f.getNumerator());\n+        assertEquals(10, f.getDenominator());\n+        \n+        f = Fraction.getFraction(-6, -10);\n+        assertEquals(6, f.getNumerator());\n+        assertEquals(10, f.getDenominator());\n+        \n+        // zero denominator\n+        try {\n+            f = Fraction.getFraction(1, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(2, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(-3, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        // very large: can't represent as unsimplified fraction, although\n+        try {\n+            f = Fraction.getFraction(4, Integer.MIN_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            f = Fraction.getFraction(1, Integer.MIN_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+    }\n+\n+    public void testFactory_int_int_int() {\n+        Fraction f = null;\n+        \n+        // zero\n+        f = Fraction.getFraction(0, 0, 2);\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f = Fraction.getFraction(2, 0, 2);\n+        assertEquals(4, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f = Fraction.getFraction(0, 1, 2);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        // normal\n+        f = Fraction.getFraction(1, 1, 2);\n+        assertEquals(3, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        // negatives\n+        try {\n+            f = Fraction.getFraction(1, -6, -10);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        try {\n+            f = Fraction.getFraction(1, -6, -10);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        try {\n+            f = Fraction.getFraction(1, -6, -10);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        // negative whole\n+        f = Fraction.getFraction(-1, 6, 10);\n+        assertEquals(-16, f.getNumerator());\n+        assertEquals(10, f.getDenominator());\n+        \n+        try {\n+            f = Fraction.getFraction(-1, -6, 10);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        try {\n+            f = Fraction.getFraction(-1, 6, -10);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(-1, -6, -10);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        // zero denominator\n+        try {\n+            f = Fraction.getFraction(0, 1, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(1, 2, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(-1, -3, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(Integer.MAX_VALUE, 1, 2); \n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(-Integer.MAX_VALUE, 1, 2);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        // very large\n+        f = Fraction.getFraction(-1, 0, Integer.MAX_VALUE);\n+        assertEquals(-Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(Integer.MAX_VALUE, f.getDenominator());\n+\n+        try {\n+            // negative denominators not allowed in this constructor.\n+            f = Fraction.getFraction(0, 4, Integer.MIN_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            f = Fraction.getFraction(1, 1, Integer.MAX_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            f = Fraction.getFraction(-1, 2, Integer.MAX_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+    }\n+    public void testReducedFactory_int_int() {\n+        Fraction f = null;\n+        \n+        // zero\n+        f = Fraction.getReducedFraction(0, 1);\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        // normal\n+        f = Fraction.getReducedFraction(1, 1);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f = Fraction.getReducedFraction(2, 1);\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        // improper\n+        f = Fraction.getReducedFraction(22, 7);\n+        assertEquals(22, f.getNumerator());\n+        assertEquals(7, f.getDenominator());\n+        \n+        // negatives\n+        f = Fraction.getReducedFraction(-6, 10);\n+        assertEquals(-3, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f = Fraction.getReducedFraction(6, -10);\n+        assertEquals(-3, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f = Fraction.getReducedFraction(-6, -10);\n+        assertEquals(3, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        // zero denominator\n+        try {\n+            f = Fraction.getReducedFraction(1, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getReducedFraction(2, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getReducedFraction(-3, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        // reduced        \n+        f = Fraction.getReducedFraction(0, 2);\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f = Fraction.getReducedFraction(2, 2);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f = Fraction.getReducedFraction(2, 4);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f = Fraction.getReducedFraction(15, 10);\n+        assertEquals(3, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f = Fraction.getReducedFraction(121, 22);\n+        assertEquals(11, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        // Extreme values \n+        // OK, can reduce before negating\n+        f = Fraction.getReducedFraction(-2, Integer.MIN_VALUE);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(-(Integer.MIN_VALUE / 2), f.getDenominator());\n+        \n+        // Can't reduce, negation will throw\n+        try { \n+            f = Fraction.getReducedFraction(-7, Integer.MIN_VALUE);  \n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}      \n+    }\n+\n+    public void testFactory_double() {\n+        Fraction f = null;\n+        \n+        try {\n+            f = Fraction.getFraction(Double.NaN);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(Double.POSITIVE_INFINITY);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(Double.NEGATIVE_INFINITY);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction((double) Integer.MAX_VALUE + 1);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        // zero\n+        f = Fraction.getFraction(0.0d);\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        // one\n+        f = Fraction.getFraction(1.0d);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        // one half\n+        f = Fraction.getFraction(0.5d);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        // negative\n+        f = Fraction.getFraction(-0.875d);\n+        assertEquals(-7, f.getNumerator());\n+        assertEquals(8, f.getDenominator());\n+        \n+        // over 1\n+        f = Fraction.getFraction(1.25d);\n+        assertEquals(5, f.getNumerator());\n+        assertEquals(4, f.getDenominator());\n+        \n+        // two thirds\n+        f = Fraction.getFraction(0.66666d);\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        // small\n+        f = Fraction.getFraction(1.0d/10001d);\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        // normal\n+        Fraction f2 = null;\n+        for (int i = 1; i <= 100; i++) {  // denominator\n+            for (int j = 1; j <= i; j++) {  // numerator\n+                try {\n+                    f = Fraction.getFraction((double) j / (double) i);\n+                } catch (ArithmeticException ex) {\n+                    System.err.println(j + \" \" + i);\n+                    throw ex;\n+                }\n+                f2 = Fraction.getReducedFraction(j, i);\n+                assertEquals(f2.getNumerator(), f.getNumerator());\n+                assertEquals(f2.getDenominator(), f.getDenominator());\n+            }\n+        }\n+        // save time by skipping some tests!  (\n+        for (int i = 1001; i <= 10000; i+=SKIP) {  // denominator\n+            for (int j = 1; j <= i; j++) {  // numerator\n+                try {\n+                    f = Fraction.getFraction((double) j / (double) i);\n+                } catch (ArithmeticException ex) {\n+                    System.err.println(j + \" \" + i);\n+                    throw ex;\n+                }\n+                f2 = Fraction.getReducedFraction(j, i);\n+                assertEquals(f2.getNumerator(), f.getNumerator());\n+                assertEquals(f2.getDenominator(), f.getDenominator());\n+            }\n+        }\n+    }\n+\n+    public void testFactory_String() {\n+        try {\n+            Fraction.getFraction(null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    \n+    public void testFactory_String_double() {\n+        Fraction f = null;\n+        \n+        f = Fraction.getFraction(\"0.0\");\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"0.2\");\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"0.5\");\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"0.66666\");\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        try {\n+            f = Fraction.getFraction(\"2.3R\");\n+            fail(\"Expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(\"2147483648\"); // too big\n+            fail(\"Expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(\".\");\n+            fail(\"Expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+    }\n+\n+    public void testFactory_String_proper() {\n+        Fraction f = null;\n+        \n+        f = Fraction.getFraction(\"0 0/1\");\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"1 1/5\");\n+        assertEquals(6, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"7 1/2\");\n+        assertEquals(15, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"1 2/4\");\n+        assertEquals(6, f.getNumerator());\n+        assertEquals(4, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"-7 1/2\");\n+        assertEquals(-15, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"-1 2/4\");\n+        assertEquals(-6, f.getNumerator());\n+        assertEquals(4, f.getDenominator());\n+        \n+        try {\n+            f = Fraction.getFraction(\"2 3\");\n+            fail(\"expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(\"a 3\");\n+            fail(\"expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(\"2 b/4\");\n+            fail(\"expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(\"2 \");\n+            fail(\"expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+\n+        try {\n+            f = Fraction.getFraction(\" 3\");\n+            fail(\"expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(\" \");\n+            fail(\"expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+    }\n+\n+    public void testFactory_String_improper() {\n+        Fraction f = null;\n+        \n+        f = Fraction.getFraction(\"0/1\");\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"1/5\");\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"1/2\");\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"2/3\");\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"7/3\");\n+        assertEquals(7, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"2/4\");\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(4, f.getDenominator());\n+        \n+        try {\n+            f = Fraction.getFraction(\"2/d\");\n+            fail(\"expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(\"2e/3\");\n+            fail(\"expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(\"2/\");\n+            fail(\"expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(\"/\");\n+            fail(\"expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+    }\n+\n+    public void testGets() {\n+        Fraction f = null;\n+        \n+        f = Fraction.getFraction(3, 5, 6);\n+        assertEquals(23, f.getNumerator());\n+        assertEquals(3, f.getProperWhole());\n+        assertEquals(5, f.getProperNumerator());\n+        assertEquals(6, f.getDenominator());\n+        \n+        f = Fraction.getFraction(-3, 5, 6);\n+        assertEquals(-23, f.getNumerator());\n+        assertEquals(-3, f.getProperWhole());\n+        assertEquals(5, f.getProperNumerator());\n+        assertEquals(6, f.getDenominator());\n+\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 0, 1);\n+        assertEquals(Integer.MIN_VALUE, f.getNumerator());\n+        assertEquals(Integer.MIN_VALUE, f.getProperWhole());\n+        assertEquals(0, f.getProperNumerator());\n+        assertEquals(1, f.getDenominator());\n+    }\n+            \n+    public void testConversions() {\n+        Fraction f = null;\n+        \n+        f = Fraction.getFraction(3, 7, 8);\n+        assertEquals(3, f.intValue());\n+        assertEquals(3L, f.longValue());\n+        assertEquals(3.875f, f.floatValue(), 0.00001f);\n+        assertEquals(3.875d, f.doubleValue(), 0.00001d);\n+    }\n+    \n+    public void testReduce() {\n+        Fraction f = null;\n+        \n+        f = Fraction.getFraction(50, 75);\n+        Fraction result = f.reduce();\n+        assertEquals(2, result.getNumerator());\n+        assertEquals(3, result.getDenominator());\n+\n+        f = Fraction.getFraction(-2, -3);\n+        result = f.reduce();\n+        assertEquals(2, result.getNumerator());\n+        assertEquals(3, result.getDenominator());\n+\n+        f = Fraction.getFraction(2, -3);\n+        result = f.reduce();\n+        assertEquals(-2, result.getNumerator());\n+        assertEquals(3, result.getDenominator());\n+\n+        f = Fraction.getFraction(-2, 3);\n+        result = f.reduce();\n+        assertEquals(-2, result.getNumerator());\n+        assertEquals(3, result.getDenominator());\n+        assertSame(f, result);\n+\n+        f = Fraction.getFraction(2, 3);\n+        result = f.reduce();\n+        assertEquals(2, result.getNumerator());\n+        assertEquals(3, result.getDenominator());\n+        assertSame(f, result);\n+\n+        f = Fraction.getFraction(0, 1);\n+        result = f.reduce();\n+        assertEquals(0, result.getNumerator());\n+        assertEquals(1, result.getDenominator());\n+        assertSame(f, result);\n+\n+        f = Fraction.getFraction(0, 100);\n+        result = f.reduce();\n+        assertEquals(0, result.getNumerator());\n+        assertEquals(1, result.getDenominator());\n+        assertSame(result, Fraction.ZERO);\n+    }\n+    \n+    public void testInvert() {\n+        Fraction f = null;\n+        \n+        f = Fraction.getFraction(50, 75);\n+        f = f.invert();\n+        assertEquals(75, f.getNumerator());\n+        assertEquals(50, f.getDenominator());\n+        \n+        f = Fraction.getFraction(4, 3);\n+        f = f.invert();\n+        assertEquals(3, f.getNumerator());\n+        assertEquals(4, f.getDenominator());\n+        \n+        f = Fraction.getFraction(-15, 47);\n+        f = f.invert();\n+        assertEquals(-47, f.getNumerator());\n+        assertEquals(15, f.getDenominator());\n+        \n+        f = Fraction.getFraction(0, 3);\n+        try {\n+            f = f.invert();\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        // large values\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 1);\n+        try {\n+            f = f.invert();\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        f = Fraction.getFraction(Integer.MAX_VALUE, 1);\n+        f = f.invert();\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(Integer.MAX_VALUE, f.getDenominator());\n+    }\n+    \n+    public void testNegate() {\n+        Fraction f = null;\n+        \n+        f = Fraction.getFraction(50, 75);\n+        f = f.negate();\n+        assertEquals(-50, f.getNumerator());\n+        assertEquals(75, f.getDenominator());\n+        \n+        f = Fraction.getFraction(-50, 75);\n+        f = f.negate();\n+        assertEquals(50, f.getNumerator());\n+        assertEquals(75, f.getDenominator());\n+\n+        // large values\n+        f = Fraction.getFraction(Integer.MAX_VALUE-1, Integer.MAX_VALUE);\n+        f = f.negate();\n+        assertEquals(Integer.MIN_VALUE+2, f.getNumerator());\n+        assertEquals(Integer.MAX_VALUE, f.getDenominator());\n+\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 1);\n+        try {\n+            f = f.negate();\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+    }\n+    \n+    public void testAbs() {\n+        Fraction f = null;\n+        \n+        f = Fraction.getFraction(50, 75);\n+        f = f.abs();\n+        assertEquals(50, f.getNumerator());\n+        assertEquals(75, f.getDenominator());\n+        \n+        f = Fraction.getFraction(-50, 75);\n+        f = f.abs();\n+        assertEquals(50, f.getNumerator());\n+        assertEquals(75, f.getDenominator());\n+\n+        f = Fraction.getFraction(Integer.MAX_VALUE, 1);\n+        f = f.abs();\n+        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        f = Fraction.getFraction(Integer.MAX_VALUE, -1);\n+        f = f.abs();\n+        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 1);\n+        try {\n+            f = f.abs();\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+    }\n+    \n+    public void testPow() {\n+        Fraction f = null;\n+        \n+        f = Fraction.getFraction(3, 5);\n+        assertEquals(Fraction.ONE, f.pow(0));\n+        \n+        f = Fraction.getFraction(3, 5);\n+        assertSame(f, f.pow(1));\n+        assertEquals(f, f.pow(1));\n+\n+        f = Fraction.getFraction(3, 5);\n+        f = f.pow(2);\n+        assertEquals(9, f.getNumerator());\n+        assertEquals(25, f.getDenominator());\n+        \n+        f = Fraction.getFraction(3, 5);\n+        f = f.pow(3);\n+        assertEquals(27, f.getNumerator());\n+        assertEquals(125, f.getDenominator());\n+        \n+        f = Fraction.getFraction(3, 5);\n+        f = f.pow(-1);\n+        assertEquals(5, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        f = Fraction.getFraction(3, 5);\n+        f = f.pow(-2);\n+        assertEquals(25, f.getNumerator());\n+        assertEquals(9, f.getDenominator());\n+        \n+        // check unreduced fractions stay that way.\n+        f = Fraction.getFraction(6, 10);\n+        assertEquals(Fraction.ONE, f.pow(0));\n+        \n+        f = Fraction.getFraction(6, 10);\n+        assertEquals(f, f.pow(1));\n+        assertFalse(f.pow(1).equals(Fraction.getFraction(3,5)));\n+\n+        f = Fraction.getFraction(6, 10);\n+        f = f.pow(2);\n+        assertEquals(9, f.getNumerator());\n+        assertEquals(25, f.getDenominator());\n+        \n+        f = Fraction.getFraction(6, 10);\n+        f = f.pow(3);\n+        assertEquals(27, f.getNumerator());\n+        assertEquals(125, f.getDenominator());\n+        \n+        f = Fraction.getFraction(6, 10);\n+        f = f.pow(-1);\n+        assertEquals(10, f.getNumerator());\n+        assertEquals(6, f.getDenominator());\n+        \n+        f = Fraction.getFraction(6, 10);\n+        f = f.pow(-2);\n+        assertEquals(25, f.getNumerator());\n+        assertEquals(9, f.getDenominator());\n+        \n+        // zero to any positive power is still zero.\n+        f = Fraction.getFraction(0, 1231);\n+        f = f.pow(1);\n+        assertTrue(0==f.compareTo(Fraction.ZERO));\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1231, f.getDenominator());\n+        f = f.pow(2);\n+        assertTrue(0==f.compareTo(Fraction.ZERO));\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        // zero to negative powers should throw an exception\n+        try {\n+            f = f.pow(-1);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            f = f.pow(Integer.MIN_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        // one to any power is still one.\n+        f = Fraction.getFraction(1, 1);\n+        f = f.pow(0);\n+        assertEquals(f, Fraction.ONE);\n+        f = f.pow(1);\n+        assertEquals(f, Fraction.ONE);\n+        f = f.pow(-1);\n+        assertEquals(f, Fraction.ONE);\n+        f = f.pow(Integer.MAX_VALUE);\n+        assertEquals(f, Fraction.ONE);\n+        f = f.pow(Integer.MIN_VALUE);\n+        assertEquals(f, Fraction.ONE);\n+\n+        f = Fraction.getFraction(Integer.MAX_VALUE, 1);\n+        try {\n+            f = f.pow(2);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        // Numerator growing too negative during the pow operation.\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 1);\n+        try {\n+            f = f.pow(3);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        f = Fraction.getFraction(65536, 1);\n+        try {\n+            f = f.pow(2);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+    }\n+    \n+    public void testAdd() {\n+        Fraction f = null;\n+        Fraction f1 = null;\n+        Fraction f2 = null;\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(1, 5);\n+        f = f1.add(f2);\n+        assertEquals(4, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(2, 5);\n+        f = f1.add(f2);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(3, 5);\n+        f = f1.add(f2);\n+        assertEquals(6, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(-4, 5);\n+        f = f1.add(f2);\n+        assertEquals(-1, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(Integer.MAX_VALUE - 1, 1);\n+        f2 = Fraction.ONE;\n+        f = f1.add(f2);\n+        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(1, 2);\n+        f = f1.add(f2);\n+        assertEquals(11, f.getNumerator());\n+        assertEquals(10, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 8);\n+        f2 = Fraction.getFraction(1, 6);\n+        f = f1.add(f2);\n+        assertEquals(13, f.getNumerator());\n+        assertEquals(24, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(0, 5);\n+        f2 = Fraction.getFraction(1, 5);\n+        f = f1.add(f2);\n+        assertSame(f2, f);\n+        f = f2.add(f1);\n+        assertSame(f2, f);\n+        \n+        f1 = Fraction.getFraction(-1, 13*13*2*2);\n+        f2 = Fraction.getFraction(-2, 13*17*2);\n+        f = f1.add(f2);\n+        assertEquals(13*13*17*2*2, f.getDenominator());\n+        assertEquals(-17 - 2*13*2, f.getNumerator());\n+        \n+        try {\n+            f.add(null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        // if this fraction is added naively, it will overflow.\n+        // check that it doesn't.\n+        f1 = Fraction.getFraction(1,32768*3);\n+        f2 = Fraction.getFraction(1,59049);\n+        f = f1.add(f2);\n+        assertEquals(52451, f.getNumerator());\n+        assertEquals(1934917632, f.getDenominator());\n+\n+        f1 = Fraction.getFraction(Integer.MIN_VALUE, 3);\n+        f2 = Fraction.ONE_THIRD;\n+        f = f1.add(f2);\n+        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(Integer.MAX_VALUE - 1, 1);\n+        f2 = Fraction.ONE;\n+        f = f1.add(f2);\n+        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        try {\n+            f = f.add(Fraction.ONE); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+        \n+        // denominator should not be a multiple of 2 or 3 to trigger overflow\n+        f1 = Fraction.getFraction(Integer.MIN_VALUE, 5);\n+        f2 = Fraction.getFraction(-1,5);\n+        try {\n+            f = f1.add(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f= Fraction.getFraction(-Integer.MAX_VALUE, 1);\n+            f = f.add(f);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+            \n+        try {\n+            f= Fraction.getFraction(-Integer.MAX_VALUE, 1);\n+            f = f.add(f);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+            \n+        f1 = Fraction.getFraction(3,327680);\n+        f2 = Fraction.getFraction(2,59049);\n+        try {\n+            f = f1.add(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+    }\n+            \n+    public void testSubtract() {\n+        Fraction f = null;\n+        Fraction f1 = null;\n+        Fraction f2 = null;\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(1, 5);\n+        f = f1.subtract(f2);\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(7, 5);\n+        f2 = Fraction.getFraction(2, 5);\n+        f = f1.subtract(f2);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(3, 5);\n+        f = f1.subtract(f2);\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(-4, 5);\n+        f = f1.subtract(f2);\n+        assertEquals(7, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(0, 5);\n+        f2 = Fraction.getFraction(4, 5);\n+        f = f1.subtract(f2);\n+        assertEquals(-4, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(0, 5);\n+        f2 = Fraction.getFraction(-4, 5);\n+        f = f1.subtract(f2);\n+        assertEquals(4, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(1, 2);\n+        f = f1.subtract(f2);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(10, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(0, 5);\n+        f2 = Fraction.getFraction(1, 5);\n+        f = f2.subtract(f1);\n+        assertSame(f2, f);\n+        \n+        try {\n+            f.subtract(null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        // if this fraction is subtracted naively, it will overflow.\n+        // check that it doesn't.\n+        f1 = Fraction.getFraction(1,32768*3);\n+        f2 = Fraction.getFraction(1,59049);\n+        f = f1.subtract(f2);\n+        assertEquals(-13085, f.getNumerator());\n+        assertEquals(1934917632, f.getDenominator());\n+\n+        f1 = Fraction.getFraction(Integer.MIN_VALUE, 3);\n+        f2 = Fraction.ONE_THIRD.negate();\n+        f = f1.subtract(f2);\n+        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(Integer.MAX_VALUE, 1);\n+        f2 = Fraction.ONE;\n+        f = f1.subtract(f2);\n+        assertEquals(Integer.MAX_VALUE-1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        try {\n+            f1 = Fraction.getFraction(1, Integer.MAX_VALUE);\n+            f2 = Fraction.getFraction(1, Integer.MAX_VALUE - 1);\n+            f = f1.subtract(f2);\n+            fail(\"expecting ArithmeticException\");  //should overflow\n+        } catch (ArithmeticException ex) {}\n+            \n+        // denominator should not be a multiple of 2 or 3 to trigger overflow\n+        f1 = Fraction.getFraction(Integer.MIN_VALUE, 5);\n+        f2 = Fraction.getFraction(1,5);\n+        try {\n+            f = f1.subtract(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f= Fraction.getFraction(Integer.MIN_VALUE, 1);\n+            f = f.subtract(Fraction.ONE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+            \n+        try {\n+            f= Fraction.getFraction(Integer.MAX_VALUE, 1);\n+            f = f.subtract(Fraction.ONE.negate());\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+            \n+        f1 = Fraction.getFraction(3,327680);\n+        f2 = Fraction.getFraction(2,59049);\n+        try {\n+            f = f1.subtract(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+    }\n+            \n+    public void testMultiply() {\n+        Fraction f = null;\n+        Fraction f1 = null;\n+        Fraction f2 = null;\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(2, 5);\n+        f = f1.multiplyBy(f2);\n+        assertEquals(6, f.getNumerator());\n+        assertEquals(25, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(6, 10);\n+        f2 = Fraction.getFraction(6, 10);\n+        f = f1.multiplyBy(f2);\n+        assertEquals(9, f.getNumerator());\n+        assertEquals(25, f.getDenominator());\n+        f = f.multiplyBy(f2);\n+        assertEquals(27, f.getNumerator());\n+        assertEquals(125, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(-2, 5);\n+        f = f1.multiplyBy(f2);\n+        assertEquals(-6, f.getNumerator());\n+        assertEquals(25, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(-3, 5);\n+        f2 = Fraction.getFraction(-2, 5);\n+        f = f1.multiplyBy(f2);\n+        assertEquals(6, f.getNumerator());\n+        assertEquals(25, f.getDenominator());\n+        \n+        \n+        f1 = Fraction.getFraction(0, 5);\n+        f2 = Fraction.getFraction(2, 7);\n+        f = f1.multiplyBy(f2);\n+        assertSame(Fraction.ZERO, f);\n+        \n+        f1 = Fraction.getFraction(2, 7);\n+        f2 = Fraction.ONE;\n+        f = f1.multiplyBy(f2);\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(7, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(Integer.MAX_VALUE, 1);\n+        f2 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        f = f1.multiplyBy(f2);\n+        assertEquals(Integer.MIN_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        try {\n+            f.multiplyBy(null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        try {\n+            f1 = Fraction.getFraction(1, Integer.MAX_VALUE);\n+            f = f1.multiplyBy(f1);  // should overflow\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+            \n+        try {\n+            f1 = Fraction.getFraction(1, -Integer.MAX_VALUE);\n+            f = f1.multiplyBy(f1);  // should overflow\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+    }\n+            \n+    public void testDivide() {\n+        Fraction f = null;\n+        Fraction f1 = null;\n+        Fraction f2 = null;\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(2, 5);\n+        f = f1.divideBy(f2);\n+        assertEquals(3, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.ZERO;\n+        try {\n+            f = f1.divideBy(f2);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        f1 = Fraction.getFraction(0, 5);\n+        f2 = Fraction.getFraction(2, 7);\n+        f = f1.divideBy(f2);\n+        assertSame(Fraction.ZERO, f);\n+        \n+        f1 = Fraction.getFraction(2, 7);\n+        f2 = Fraction.ONE;\n+        f = f1.divideBy(f2);\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(7, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(1, Integer.MAX_VALUE);\n+        f = f1.divideBy(f1);  \n+        assertEquals(1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        f2 = Fraction.getFraction(1, Integer.MAX_VALUE);\n+        f = f1.divideBy(f2);\n+        assertEquals(Integer.MIN_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        try {\n+            f.divideBy(null);\n+            fail(\"IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        try {\n+            f1 = Fraction.getFraction(1, Integer.MAX_VALUE);\n+            f = f1.divideBy(f1.invert());  // should overflow\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            f1 = Fraction.getFraction(1, -Integer.MAX_VALUE);\n+            f = f1.divideBy(f1.invert());  // should overflow\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+    }\n+            \n+    public void testEquals() {\n+        Fraction f1 = null;\n+        Fraction f2 = null;\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        assertEquals(false, f1.equals(null));\n+        assertEquals(false, f1.equals(new Object()));\n+        assertEquals(false, f1.equals(new Integer(6)));\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(2, 5);\n+        assertEquals(false, f1.equals(f2));\n+        assertEquals(true, f1.equals(f1));\n+        assertEquals(true, f2.equals(f2));\n+        \n+        f2 = Fraction.getFraction(3, 5);\n+        assertEquals(true, f1.equals(f2));\n+        \n+        f2 = Fraction.getFraction(6, 10);\n+        assertEquals(false, f1.equals(f2));\n+    }\n+    \n+    public void testHashCode() {\n+        Fraction f1 = Fraction.getFraction(3, 5);\n+        Fraction f2 = Fraction.getFraction(3, 5);\n+        \n+        assertTrue(f1.hashCode() == f2.hashCode());\n+        \n+        f2 = Fraction.getFraction(2, 5);\n+        assertTrue(f1.hashCode() != f2.hashCode());\n+        \n+        f2 = Fraction.getFraction(6, 10);\n+        assertTrue(f1.hashCode() != f2.hashCode());\n+    }\n+    \n+    public void testCompareTo() {\n+        Fraction f1 = null;\n+        Fraction f2 = null;\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        assertTrue(f1.compareTo(f1) == 0);\n+        \n+        try {\n+            f1.compareTo(null);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException ex) {}\n+        \n+        f2 = Fraction.getFraction(2, 5);\n+        assertTrue(f1.compareTo(f2) > 0);\n+        assertTrue(f2.compareTo(f2) == 0);\n+        \n+        f2 = Fraction.getFraction(4, 5);\n+        assertTrue(f1.compareTo(f2) < 0);\n+        assertTrue(f2.compareTo(f2) == 0);\n+        \n+        f2 = Fraction.getFraction(3, 5);\n+        assertTrue(f1.compareTo(f2) == 0);\n+        assertTrue(f2.compareTo(f2) == 0);\n+        \n+        f2 = Fraction.getFraction(6, 10);\n+        assertTrue(f1.compareTo(f2) == 0);\n+        assertTrue(f2.compareTo(f2) == 0);\n+\n+        f2 = Fraction.getFraction(-1, 1, Integer.MAX_VALUE);\n+        assertTrue(f1.compareTo(f2) > 0);\n+        assertTrue(f2.compareTo(f2) == 0);\n+\n+    }\n+    \n+    public void testToString() {\n+        Fraction f = null;\n+\n+        f = Fraction.getFraction(3, 5);\n+        String str = f.toString();\n+        assertEquals(\"3/5\", str);\n+        assertSame(str, f.toString());\n+        \n+        f = Fraction.getFraction(7, 5);\n+        assertEquals(\"7/5\", f.toString());        \n+        \n+        f = Fraction.getFraction(4, 2);\n+        assertEquals(\"4/2\", f.toString());        \n+        \n+        f = Fraction.getFraction(0, 2);\n+        assertEquals(\"0/2\", f.toString());        \n+        \n+        f = Fraction.getFraction(2, 2);\n+        assertEquals(\"2/2\", f.toString());        \n+\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 0, 1);\n+        assertEquals(\"-2147483648/1\", f.toString());        \n+\n+        f = Fraction.getFraction(-1, 1, Integer.MAX_VALUE);\n+        assertEquals(\"-2147483648/2147483647\", f.toString());\n+    }\n+    \n+    public void testToProperString() {\n+        Fraction f = null;\n+\n+        f = Fraction.getFraction(3, 5);\n+        String str = f.toProperString();\n+        assertEquals(\"3/5\", str);\n+        assertSame(str, f.toProperString());\n+        \n+        f = Fraction.getFraction(7, 5);\n+        assertEquals(\"1 2/5\", f.toProperString());        \n+        \n+        f = Fraction.getFraction(14, 10);\n+        assertEquals(\"1 4/10\", f.toProperString());        \n+        \n+        f = Fraction.getFraction(4, 2);\n+        assertEquals(\"2\", f.toProperString());        \n+        \n+        f = Fraction.getFraction(0, 2);\n+        assertEquals(\"0\", f.toProperString());        \n+        \n+        f = Fraction.getFraction(2, 2);\n+        assertEquals(\"1\", f.toProperString());        \n+        \n+        f = Fraction.getFraction(-7, 5);\n+        assertEquals(\"-1 2/5\", f.toProperString());        \n+\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 0, 1);\n+        assertEquals(\"-2147483648\", f.toProperString());        \n+\n+        f = Fraction.getFraction(-1, 1, Integer.MAX_VALUE);\n+        assertEquals(\"-1 1/2147483647\", f.toProperString());\n+\n+        assertEquals(\"-1\", Fraction.getFraction(-1).toProperString());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/math/IEEE754rUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.math.IEEE754rUtils}.\n+ *\n+ * @version $Id$\n+ */\n+public class IEEE754rUtilsTest extends TestCase {\n+\n+    public void testLang381() {\n+        assertEquals(1.2, IEEE754rUtils.min(1.2, 2.5, Double.NaN), 0.01);\n+        assertEquals(2.5, IEEE754rUtils.max(1.2, 2.5, Double.NaN), 0.01);\n+        assertTrue(Double.isNaN(IEEE754rUtils.max(Double.NaN, Double.NaN, Double.NaN)));\n+        assertEquals(1.2f, IEEE754rUtils.min(1.2f, 2.5f, Float.NaN), 0.01);\n+        assertEquals(2.5f, IEEE754rUtils.max(1.2f, 2.5f, Float.NaN), 0.01);\n+        assertTrue(Float.isNaN(IEEE754rUtils.max(Float.NaN, Float.NaN, Float.NaN)));\n+\n+        double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN };\n+        assertEquals(42.0, IEEE754rUtils.max(a), 0.01);\n+        assertEquals(1.2, IEEE754rUtils.min(a), 0.01);\n+\n+        double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN };\n+        assertEquals(42.0, IEEE754rUtils.max(b), 0.01);\n+        assertEquals(1.2, IEEE754rUtils.min(b), 0.01);\n+\n+        float[] aF = new float[] { 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN };\n+        assertEquals(1.2f, IEEE754rUtils.min(aF), 0.01);\n+        assertEquals(42.0f, IEEE754rUtils.max(aF), 0.01);\n+\n+        float[] bF = new float[] { Float.NaN, 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN };\n+        assertEquals(1.2f, IEEE754rUtils.min(bF), 0.01);\n+        assertEquals(42.0f, IEEE754rUtils.max(bF), 0.01);\n+    }\n+\n+    public void testEnforceExceptions() {\n+        try {\n+            IEEE754rUtils.min( (float[]) null);\n+            fail(\"IllegalArgumentException expected for null input\");\n+        } catch(IllegalArgumentException iae) { /* expected */ }\n+\n+        try {\n+            IEEE754rUtils.min(new float[0]);\n+            fail(\"IllegalArgumentException expected for empty input\");\n+        } catch(IllegalArgumentException iae) { /* expected */ }\n+\n+        try {\n+            IEEE754rUtils.max( (float[]) null);\n+            fail(\"IllegalArgumentException expected for null input\");\n+        } catch(IllegalArgumentException iae) { /* expected */ }\n+\n+        try {\n+            IEEE754rUtils.max(new float[0]);\n+            fail(\"IllegalArgumentException expected for empty input\");\n+        } catch(IllegalArgumentException iae) { /* expected */ }\n+\n+        try {\n+            IEEE754rUtils.min( (double[]) null);\n+            fail(\"IllegalArgumentException expected for null input\");\n+        } catch(IllegalArgumentException iae) { /* expected */ }\n+\n+        try {\n+            IEEE754rUtils.min(new double[0]);\n+            fail(\"IllegalArgumentException expected for empty input\");\n+        } catch(IllegalArgumentException iae) { /* expected */ }\n+\n+        try {\n+            IEEE754rUtils.max( (double[]) null);\n+            fail(\"IllegalArgumentException expected for null input\");\n+        } catch(IllegalArgumentException iae) { /* expected */ }\n+\n+        try {\n+            IEEE754rUtils.max(new double[0]);\n+            fail(\"IllegalArgumentException expected for empty input\");\n+        } catch(IllegalArgumentException iae) { /* expected */ }\n+\n+    }\n+\n+    public void testConstructorExists() {\n+        new IEEE754rUtils();\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/math/NumberUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.lang.SystemUtils;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.math.NumberUtils}.\n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:rand_mcneely@yahoo.com\">Rand McNeely</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @author Eric Pugh\n+ * @author Phil Steitz\n+ * @author Matthew Hawthorne\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id$\n+ */\n+public class NumberUtilsTest extends TestCase {\n+\n+    public NumberUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(NumberUtilsTest.class);\n+        suite.setName(\"NumberUtils Tests\");\n+        return suite;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new NumberUtils());\n+        Constructor<?>[] cons = NumberUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(NumberUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(NumberUtils.class.getModifiers()));\n+    }\n+    \n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * Test for {@link NumberUtils#toInt(String)}.\n+     */\n+    public void testToIntString() {\n+        assertTrue(\"toInt(String) 1 failed\", NumberUtils.toInt(\"12345\") == 12345);\n+        assertTrue(\"toInt(String) 2 failed\", NumberUtils.toInt(\"abc\") == 0);\n+        assertTrue(\"toInt(empty) failed\", NumberUtils.toInt(\"\") == 0);\n+        assertTrue(\"toInt(null) failed\", NumberUtils.toInt(null) == 0);\n+    }\n+\n+    /**\n+     * Test for {@link NumberUtils#toInt(String, int)}.\n+     */\n+    public void testToIntStringI() {\n+        assertTrue(\"toInt(String,int) 1 failed\", NumberUtils.toInt(\"12345\", 5) == 12345);\n+        assertTrue(\"toInt(String,int) 2 failed\", NumberUtils.toInt(\"1234.5\", 5) == 5);\n+    }\n+\n+    /**\n+     * Test for {@link NumberUtils#toLong(String)}.\n+     */\n+    public void testToLongString() {\n+        assertTrue(\"toLong(String) 1 failed\", NumberUtils.toLong(\"12345\") == 12345l);\n+        assertTrue(\"toLong(String) 2 failed\", NumberUtils.toLong(\"abc\") == 0l);\n+        assertTrue(\"toLong(String) 3 failed\", NumberUtils.toLong(\"1L\") == 0l);\n+        assertTrue(\"toLong(String) 4 failed\", NumberUtils.toLong(\"1l\") == 0l);\n+        assertTrue(\"toLong(Long.MAX_VALUE) failed\", NumberUtils.toLong(Long.MAX_VALUE+\"\") == Long.MAX_VALUE);\n+        assertTrue(\"toLong(Long.MIN_VALUE) failed\", NumberUtils.toLong(Long.MIN_VALUE+\"\") == Long.MIN_VALUE);\n+        assertTrue(\"toLong(empty) failed\", NumberUtils.toLong(\"\") == 0l);\n+        assertTrue(\"toLong(null) failed\", NumberUtils.toLong(null) == 0l);\n+    }\n+\n+    /**\n+     * Test for {@link NumberUtils#toLong(String, long)}.\n+     */\n+    public void testToLongStringL() {\n+        assertTrue(\"toLong(String,long) 1 failed\", NumberUtils.toLong(\"12345\", 5l) == 12345l);\n+        assertTrue(\"toLong(String,long) 2 failed\", NumberUtils.toLong(\"1234.5\", 5l) == 5l);\n+    }\n+\n+    /**\n+     * Test for {@link NumberUtils#toFloat(String)}.\n+     */\n+    public void testToFloatString() {\n+        assertTrue(\"toFloat(String) 1 failed\", NumberUtils.toFloat(\"-1.2345\") == -1.2345f);\n+        assertTrue(\"toFloat(String) 2 failed\", NumberUtils.toFloat(\"1.2345\") == 1.2345f);\n+        assertTrue(\"toFloat(String) 3 failed\", NumberUtils.toFloat(\"abc\") == 0.0f);\n+        assertTrue(\"toFloat(Float.MAX_VALUE) failed\", NumberUtils.toFloat(Float.MAX_VALUE+\"\") ==  Float.MAX_VALUE);\n+        assertTrue(\"toFloat(Float.MIN_VALUE) failed\", NumberUtils.toFloat(Float.MIN_VALUE+\"\") == Float.MIN_VALUE);\n+        assertTrue(\"toFloat(empty) failed\", NumberUtils.toFloat(\"\") == 0.0f);\n+        assertTrue(\"toFloat(null) failed\", NumberUtils.toFloat(null) == 0.0f);\n+    }\n+\n+    /**\n+     * Test for {@link NumberUtils#toFloat(String, float)}.\n+     */\n+    public void testToFloatStringF() {\n+        assertTrue(\"toFloat(String,int) 1 failed\", NumberUtils.toFloat(\"1.2345\", 5.1f) == 1.2345f);\n+        assertTrue(\"toFloat(String,int) 2 failed\", NumberUtils.toFloat(\"a\", 5.0f) == 5.0f);\n+    }\n+\n+    /**\n+     * Test for {@link NumberUtils#toDouble(String)}.\n+     */\n+    public void testStringToDoubleString() {\n+        assertTrue(\"toDouble(String) 1 failed\", NumberUtils.toDouble(\"-1.2345\") == -1.2345d);\n+        assertTrue(\"toDouble(String) 2 failed\", NumberUtils.toDouble(\"1.2345\") == 1.2345d);\n+        assertTrue(\"toDouble(String) 3 failed\", NumberUtils.toDouble(\"abc\") == 0.0d);\n+        assertTrue(\"toDouble(Double.MAX_VALUE) failed\", NumberUtils.toDouble(Double.MAX_VALUE+\"\") == Double.MAX_VALUE);\n+        assertTrue(\"toDouble(Double.MIN_VALUE) failed\", NumberUtils.toDouble(Double.MIN_VALUE+\"\") == Double.MIN_VALUE);\n+        assertTrue(\"toDouble(empty) failed\", NumberUtils.toDouble(\"\") == 0.0d);\n+        assertTrue(\"toDouble(null) failed\", NumberUtils.toDouble(null) == 0.0d);\n+    }\n+\n+    /**\n+     * Test for {@link NumberUtils#toDouble(String, double)}.\n+     */\n+    public void testStringToDoubleStringD() {\n+        assertTrue(\"toDouble(String,int) 1 failed\", NumberUtils.toDouble(\"1.2345\", 5.1d) == 1.2345d);\n+        assertTrue(\"toDouble(String,int) 2 failed\", NumberUtils.toDouble(\"a\", 5.0d) == 5.0d);\n+    }\n+\n+     /**\n+     * Test for {@link NumberUtils#toByte(String)}.\n+     */\n+    public void testToByteString() {\n+        assertTrue(\"toByte(String) 1 failed\", NumberUtils.toByte(\"123\") == 123);\n+        assertTrue(\"toByte(String) 2 failed\", NumberUtils.toByte(\"abc\") == 0);\n+        assertTrue(\"toByte(empty) failed\", NumberUtils.toByte(\"\") == 0);\n+        assertTrue(\"toByte(null) failed\", NumberUtils.toByte(null) == 0);\n+    }\n+\n+    /**\n+     * Test for {@link NumberUtils#toByte(String, byte)}.\n+     */\n+    public void testToByteStringI() {\n+        assertTrue(\"toByte(String,byte) 1 failed\", NumberUtils.toByte(\"123\", (byte) 5) == 123);\n+        assertTrue(\"toByte(String,byte) 2 failed\", NumberUtils.toByte(\"12.3\", (byte) 5) == 5);\n+    }\n+\n+    /**\n+     * Test for {@link NumberUtils#toShort(String)}.\n+     */\n+    public void testToShortString() {\n+        assertTrue(\"toShort(String) 1 failed\", NumberUtils.toShort(\"12345\") == 12345);\n+        assertTrue(\"toShort(String) 2 failed\", NumberUtils.toShort(\"abc\") == 0);\n+        assertTrue(\"toShort(empty) failed\", NumberUtils.toShort(\"\") == 0);\n+        assertTrue(\"toShort(null) failed\", NumberUtils.toShort(null) == 0);\n+    }\n+\n+    /**\n+     * Test for {@link NumberUtils#toShort(String, short)}.\n+     */\n+    public void testToShortStringI() {\n+        assertTrue(\"toShort(String,short) 1 failed\", NumberUtils.toShort(\"12345\", (short) 5) == 12345);\n+        assertTrue(\"toShort(String,short) 2 failed\", NumberUtils.toShort(\"1234.5\", (short) 5) == 5);\n+    }\n+\n+    public void testCreateNumber() {\n+        // a lot of things can go wrong\n+        assertEquals(\"createNumber(String) 1 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5\"));\n+        assertEquals(\"createNumber(String) 2 failed\", new Integer(\"12345\"), NumberUtils.createNumber(\"12345\"));\n+        assertEquals(\"createNumber(String) 3 failed\", new Double(\"1234.5\"), NumberUtils.createNumber(\"1234.5D\"));\n+        assertEquals(\"createNumber(String) 3 failed\", new Double(\"1234.5\"), NumberUtils.createNumber(\"1234.5d\"));\n+        assertEquals(\"createNumber(String) 4 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5F\"));\n+        assertEquals(\"createNumber(String) 4 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5f\"));\n+        assertEquals(\"createNumber(String) 5 failed\", new Long(Integer.MAX_VALUE + 1L), NumberUtils.createNumber(\"\"\n+            + (Integer.MAX_VALUE + 1L)));\n+        assertEquals(\"createNumber(String) 6 failed\", new Long(12345), NumberUtils.createNumber(\"12345L\"));\n+        assertEquals(\"createNumber(String) 6 failed\", new Long(12345), NumberUtils.createNumber(\"12345l\"));\n+        assertEquals(\"createNumber(String) 7 failed\", new Float(\"-1234.5\"), NumberUtils.createNumber(\"-1234.5\"));\n+        assertEquals(\"createNumber(String) 8 failed\", new Integer(\"-12345\"), NumberUtils.createNumber(\"-12345\"));\n+        assertTrue(\"createNumber(String) 9 failed\", 0xFADE == NumberUtils.createNumber(\"0xFADE\").intValue());\n+        assertTrue(\"createNumber(String) 10 failed\", -0xFADE == NumberUtils.createNumber(\"-0xFADE\").intValue());\n+        assertEquals(\"createNumber(String) 11 failed\", new Double(\"1.1E200\"), NumberUtils.createNumber(\"1.1E200\"));\n+        assertEquals(\"createNumber(String) 12 failed\", new Float(\"1.1E20\"), NumberUtils.createNumber(\"1.1E20\"));\n+        assertEquals(\"createNumber(String) 13 failed\", new Double(\"-1.1E200\"), NumberUtils.createNumber(\"-1.1E200\"));\n+        assertEquals(\"createNumber(String) 14 failed\", new Double(\"1.1E-200\"), NumberUtils.createNumber(\"1.1E-200\"));\n+        assertEquals(\"createNumber(null) failed\", null, NumberUtils.createNumber(null));\n+        assertEquals(\"createNumber(String) failed\", new BigInteger(\"12345678901234567890\"), NumberUtils\n+                .createNumber(\"12345678901234567890L\"));\n+\n+        // jdk 1.2 doesn't support this. unsure about jdk 1.2.2\n+        if (SystemUtils.isJavaVersionAtLeast(1.3f)) {\n+            assertEquals(\"createNumber(String) 15 failed\", new BigDecimal(\"1.1E-700\"), NumberUtils\n+                    .createNumber(\"1.1E-700F\"));\n+        }\n+        assertEquals(\"createNumber(String) 16 failed\", new Long(\"10\" + Integer.MAX_VALUE), NumberUtils\n+                .createNumber(\"10\" + Integer.MAX_VALUE + \"L\"));\n+        assertEquals(\"createNumber(String) 17 failed\", new Long(\"10\" + Integer.MAX_VALUE), NumberUtils\n+                .createNumber(\"10\" + Integer.MAX_VALUE));\n+        assertEquals(\"createNumber(String) 18 failed\", new BigInteger(\"10\" + Long.MAX_VALUE), NumberUtils\n+                .createNumber(\"10\" + Long.MAX_VALUE));\n+    }\n+\n+    public void testCreateFloat() {\n+        assertEquals(\"createFloat(String) failed\", new Float(\"1234.5\"), NumberUtils.createFloat(\"1234.5\"));\n+        assertEquals(\"createFloat(null) failed\", null, NumberUtils.createFloat(null));\n+        this.testCreateFloatFailure(\"\");\n+        this.testCreateFloatFailure(\" \");\n+        this.testCreateFloatFailure(\"\\b\\t\\n\\f\\r\");\n+        // Funky whitespaces\n+        this.testCreateFloatFailure(\"\\u00A0\\uFEFF\\u000B\\u000C\\u001C\\u001D\\u001E\\u001F\");\n+    }\n+\n+    protected void testCreateFloatFailure(String str) {\n+        try {\n+            Float value = NumberUtils.createFloat(str);\n+            fail(\"createFloat(blank) failed: \" + value);\n+        } catch (NumberFormatException ex) {\n+            // empty\n+        }\n+    }\n+\n+    public void testCreateDouble() {\n+        assertEquals(\"createDouble(String) failed\", new Double(\"1234.5\"), NumberUtils.createDouble(\"1234.5\"));\n+        assertEquals(\"createDouble(null) failed\", null, NumberUtils.createDouble(null));\n+        this.testCreateDoubleFailure(\"\");\n+        this.testCreateDoubleFailure(\" \");\n+        this.testCreateDoubleFailure(\"\\b\\t\\n\\f\\r\");\n+        // Funky whitespaces\n+        this.testCreateDoubleFailure(\"\\u00A0\\uFEFF\\u000B\\u000C\\u001C\\u001D\\u001E\\u001F\");\n+    }\n+\n+    protected void testCreateDoubleFailure(String str) {\n+        try {\n+            Double value = NumberUtils.createDouble(str);\n+            fail(\"createDouble(blank) failed: \" + value);\n+        } catch (NumberFormatException ex) {\n+            // empty\n+        }\n+    }\n+\n+    public void testCreateInteger() {\n+        assertEquals(\"createInteger(String) failed\", new Integer(\"12345\"), NumberUtils.createInteger(\"12345\"));\n+        assertEquals(\"createInteger(null) failed\", null, NumberUtils.createInteger(null));\n+        this.testCreateIntegerFailure(\"\");\n+        this.testCreateIntegerFailure(\" \");\n+        this.testCreateIntegerFailure(\"\\b\\t\\n\\f\\r\");\n+        // Funky whitespaces\n+        this.testCreateIntegerFailure(\"\\u00A0\\uFEFF\\u000B\\u000C\\u001C\\u001D\\u001E\\u001F\");\n+    }\n+\n+    protected void testCreateIntegerFailure(String str) {\n+        try {\n+            Integer value = NumberUtils.createInteger(str);\n+            fail(\"createInteger(blank) failed: \" + value);\n+        } catch (NumberFormatException ex) {\n+            // empty\n+        }\n+    }\n+\n+    public void testCreateLong() {\n+        assertEquals(\"createLong(String) failed\", new Long(\"12345\"), NumberUtils.createLong(\"12345\"));\n+        assertEquals(\"createLong(null) failed\", null, NumberUtils.createLong(null));\n+        this.testCreateLongFailure(\"\");\n+        this.testCreateLongFailure(\" \");\n+        this.testCreateLongFailure(\"\\b\\t\\n\\f\\r\");\n+        // Funky whitespaces\n+        this.testCreateLongFailure(\"\\u00A0\\uFEFF\\u000B\\u000C\\u001C\\u001D\\u001E\\u001F\");\n+    }\n+\n+    protected void testCreateLongFailure(String str) {\n+        try {\n+            Long value = NumberUtils.createLong(str);\n+            fail(\"createLong(blank) failed: \" + value);\n+        } catch (NumberFormatException ex) {\n+            // empty\n+        }\n+    }\n+\n+    public void testCreateBigInteger() {\n+        assertEquals(\"createBigInteger(String) failed\", new BigInteger(\"12345\"), NumberUtils.createBigInteger(\"12345\"));\n+        assertEquals(\"createBigInteger(null) failed\", null, NumberUtils.createBigInteger(null));\n+        this.testCreateBigIntegerFailure(\"\");\n+        this.testCreateBigIntegerFailure(\" \");\n+        this.testCreateBigIntegerFailure(\"\\b\\t\\n\\f\\r\");\n+        // Funky whitespaces\n+        this.testCreateBigIntegerFailure(\"\\u00A0\\uFEFF\\u000B\\u000C\\u001C\\u001D\\u001E\\u001F\");\n+    }\n+\n+    protected void testCreateBigIntegerFailure(String str) {\n+        try {\n+            BigInteger value = NumberUtils.createBigInteger(str);\n+            fail(\"createBigInteger(blank) failed: \" + value);\n+        } catch (NumberFormatException ex) {\n+            // empty\n+        }\n+    }\n+\n+    public void testCreateBigDecimal() {\n+        assertEquals(\"createBigDecimal(String) failed\", new BigDecimal(\"1234.5\"), NumberUtils.createBigDecimal(\"1234.5\"));\n+        assertEquals(\"createBigDecimal(null) failed\", null, NumberUtils.createBigDecimal(null));\n+        this.testCreateBigDecimalFailure(\"\");\n+        this.testCreateBigDecimalFailure(\" \");\n+        this.testCreateBigDecimalFailure(\"\\b\\t\\n\\f\\r\");\n+        // Funky whitespaces\n+        this.testCreateBigDecimalFailure(\"\\u00A0\\uFEFF\\u000B\\u000C\\u001C\\u001D\\u001E\\u001F\");\n+    }\n+\n+    protected void testCreateBigDecimalFailure(String str) {\n+        try {\n+            BigDecimal value = NumberUtils.createBigDecimal(str);\n+            fail(\"createBigDecimal(blank) failed: \" + value);\n+        } catch (NumberFormatException ex) {\n+            // empty\n+        }\n+    }\n+\n+    // min/max tests\n+    // ----------------------------------------------------------------------\n+    public void testMinLong() {\n+        final long[] l = null;\n+        try {\n+            NumberUtils.min(l);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.min(new long[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"min(long[]) failed for array length 1\",\n+            5,\n+            NumberUtils.min(new long[] { 5 }));\n+\n+        assertEquals(\n+            \"min(long[]) failed for array length 2\",\n+            6,\n+            NumberUtils.min(new long[] { 6, 9 }));\n+\n+        assertEquals(-10, NumberUtils.min(new long[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(-10, NumberUtils.min(new long[] { -5, 0, -10, 5, 10 }));\n+    }\n+\n+    public void testMinInt() {\n+        final int[] i = null;\n+        try {\n+            NumberUtils.min(i);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.min(new int[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"min(int[]) failed for array length 1\",\n+            5,\n+            NumberUtils.min(new int[] { 5 }));\n+\n+        assertEquals(\n+            \"min(int[]) failed for array length 2\",\n+            6,\n+            NumberUtils.min(new int[] { 6, 9 }));\n+\n+        assertEquals(-10, NumberUtils.min(new int[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(-10, NumberUtils.min(new int[] { -5, 0, -10, 5, 10 }));\n+    }\n+\n+    public void testMinShort() {\n+        final short[] s = null;\n+        try {\n+            NumberUtils.min(s);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.min(new short[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"min(short[]) failed for array length 1\",\n+            5,\n+            NumberUtils.min(new short[] { 5 }));\n+\n+        assertEquals(\n+            \"min(short[]) failed for array length 2\",\n+            6,\n+            NumberUtils.min(new short[] { 6, 9 }));\n+\n+        assertEquals(-10, NumberUtils.min(new short[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(-10, NumberUtils.min(new short[] { -5, 0, -10, 5, 10 }));\n+    }\n+\n+    public void testMinByte() {\n+        final byte[] b = null;\n+        try {\n+            NumberUtils.min(b);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.min(new byte[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"min(byte[]) failed for array length 1\",\n+            5,\n+            NumberUtils.min(new byte[] { 5 }));\n+\n+        assertEquals(\n+            \"min(byte[]) failed for array length 2\",\n+            6,\n+            NumberUtils.min(new byte[] { 6, 9 }));\n+\n+        assertEquals(-10, NumberUtils.min(new byte[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(-10, NumberUtils.min(new byte[] { -5, 0, -10, 5, 10 }));\n+    }\n+\n+    public void testMinDouble() {\n+        final double[] d = null;\n+        try {\n+            NumberUtils.min(d);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.min(new double[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"min(double[]) failed for array length 1\",\n+            5.12,\n+            NumberUtils.min(new double[] { 5.12 }),\n+            0);\n+\n+        assertEquals(\n+            \"min(double[]) failed for array length 2\",\n+            6.23,\n+            NumberUtils.min(new double[] { 6.23, 9.34 }),\n+            0);\n+\n+        assertEquals(\n+            \"min(double[]) failed for array length 5\",\n+            -10.45,\n+            NumberUtils.min(new double[] { -10.45, -5.56, 0, 5.67, 10.78 }),\n+            0);\n+        assertEquals(-10, NumberUtils.min(new double[] { -10, -5, 0, 5, 10 }), 0.0001);\n+        assertEquals(-10, NumberUtils.min(new double[] { -5, 0, -10, 5, 10 }), 0.0001);\n+    }\n+\n+    public void testMinFloat() {\n+        final float[] f = null;\n+        try {\n+            NumberUtils.min(f);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.min(new float[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"min(float[]) failed for array length 1\",\n+            5.9f,\n+            NumberUtils.min(new float[] { 5.9f }),\n+            0);\n+\n+        assertEquals(\n+            \"min(float[]) failed for array length 2\",\n+            6.8f,\n+            NumberUtils.min(new float[] { 6.8f, 9.7f }),\n+            0);\n+\n+        assertEquals(\n+            \"min(float[]) failed for array length 5\",\n+            -10.6f,\n+            NumberUtils.min(new float[] { -10.6f, -5.5f, 0, 5.4f, 10.3f }),\n+            0);\n+        assertEquals(-10, NumberUtils.min(new float[] { -10, -5, 0, 5, 10 }), 0.0001f);\n+        assertEquals(-10, NumberUtils.min(new float[] { -5, 0, -10, 5, 10 }), 0.0001f);\n+    }\n+\n+    public void testMaxLong() {\n+        final long[] l = null;\n+        try {\n+            NumberUtils.max(l);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.max(new long[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"max(long[]) failed for array length 1\",\n+            5,\n+            NumberUtils.max(new long[] { 5 }));\n+\n+        assertEquals(\n+            \"max(long[]) failed for array length 2\",\n+            9,\n+            NumberUtils.max(new long[] { 6, 9 }));\n+\n+        assertEquals(\n+            \"max(long[]) failed for array length 5\",\n+            10,\n+            NumberUtils.max(new long[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(10, NumberUtils.max(new long[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(10, NumberUtils.max(new long[] { -5, 0, 10, 5, -10 }));\n+    }\n+\n+    public void testMaxInt() {\n+        final int[] i = null;\n+        try {\n+            NumberUtils.max(i);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.max(new int[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"max(int[]) failed for array length 1\",\n+            5,\n+            NumberUtils.max(new int[] { 5 }));\n+\n+        assertEquals(\n+            \"max(int[]) failed for array length 2\",\n+            9,\n+            NumberUtils.max(new int[] { 6, 9 }));\n+\n+        assertEquals(\n+            \"max(int[]) failed for array length 5\",\n+            10,\n+            NumberUtils.max(new int[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(10, NumberUtils.max(new int[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(10, NumberUtils.max(new int[] { -5, 0, 10, 5, -10 }));\n+    }\n+\n+    public void testMaxShort() {\n+        final short[] s = null;\n+        try {\n+            NumberUtils.max(s);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.max(new short[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"max(short[]) failed for array length 1\",\n+            5,\n+            NumberUtils.max(new short[] { 5 }));\n+\n+        assertEquals(\n+            \"max(short[]) failed for array length 2\",\n+            9,\n+            NumberUtils.max(new short[] { 6, 9 }));\n+\n+        assertEquals(\n+            \"max(short[]) failed for array length 5\",\n+            10,\n+            NumberUtils.max(new short[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(10, NumberUtils.max(new short[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(10, NumberUtils.max(new short[] { -5, 0, 10, 5, -10 }));\n+    }\n+\n+    public void testMaxByte() {\n+        final byte[] b = null;\n+        try {\n+            NumberUtils.max(b);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.max(new byte[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"max(byte[]) failed for array length 1\",\n+            5,\n+            NumberUtils.max(new byte[] { 5 }));\n+\n+        assertEquals(\n+            \"max(byte[]) failed for array length 2\",\n+            9,\n+            NumberUtils.max(new byte[] { 6, 9 }));\n+\n+        assertEquals(\n+            \"max(byte[]) failed for array length 5\",\n+            10,\n+            NumberUtils.max(new byte[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(10, NumberUtils.max(new byte[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(10, NumberUtils.max(new byte[] { -5, 0, 10, 5, -10 }));\n+    }\n+\n+    public void testMaxDouble() {\n+        final double[] d = null;\n+        try {\n+            NumberUtils.max(d);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.max(new double[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"max(double[]) failed for array length 1\",\n+            5.1f,\n+            NumberUtils.max(new double[] { 5.1f }),\n+            0);\n+\n+        assertEquals(\n+            \"max(double[]) failed for array length 2\",\n+            9.2f,\n+            NumberUtils.max(new double[] { 6.3f, 9.2f }),\n+            0);\n+\n+        assertEquals(\n+            \"max(double[]) failed for float length 5\",\n+            10.4f,\n+            NumberUtils.max(new double[] { -10.5f, -5.6f, 0, 5.7f, 10.4f }),\n+            0);\n+        assertEquals(10, NumberUtils.max(new double[] { -10, -5, 0, 5, 10 }), 0.0001);\n+        assertEquals(10, NumberUtils.max(new double[] { -5, 0, 10, 5, -10 }), 0.0001);\n+    }\n+ \n+    public void testMaxFloat() {\n+        final float[] f = null;\n+        try {\n+            NumberUtils.max(f);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.max(new float[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"max(float[]) failed for array length 1\",\n+            5.1f,\n+            NumberUtils.max(new float[] { 5.1f }),\n+            0);\n+\n+        assertEquals(\n+            \"max(float[]) failed for array length 2\",\n+            9.2f,\n+            NumberUtils.max(new float[] { 6.3f, 9.2f }),\n+            0);\n+\n+        assertEquals(\n+            \"max(float[]) failed for float length 5\",\n+            10.4f,\n+            NumberUtils.max(new float[] { -10.5f, -5.6f, 0, 5.7f, 10.4f }),\n+            0);\n+        assertEquals(10, NumberUtils.max(new float[] { -10, -5, 0, 5, 10 }), 0.0001f);\n+        assertEquals(10, NumberUtils.max(new float[] { -5, 0, 10, 5, -10 }), 0.0001f);\n+    }\n+\n+    public void testMinimumLong() {\n+        assertEquals(\"minimum(long,long,long) 1 failed\", 12345L, NumberUtils.min(12345L, 12345L + 1L, 12345L + 2L));\n+        assertEquals(\"minimum(long,long,long) 2 failed\", 12345L, NumberUtils.min(12345L + 1L, 12345L, 12345 + 2L));\n+        assertEquals(\"minimum(long,long,long) 3 failed\", 12345L, NumberUtils.min(12345L + 1L, 12345L + 2L, 12345L));\n+        assertEquals(\"minimum(long,long,long) 4 failed\", 12345L, NumberUtils.min(12345L + 1L, 12345L, 12345L));\n+        assertEquals(\"minimum(long,long,long) 5 failed\", 12345L, NumberUtils.min(12345L, 12345L, 12345L));\n+    }\n+\n+    public void testMinimumInt() {\n+        assertEquals(\"minimum(int,int,int) 1 failed\", 12345, NumberUtils.min(12345, 12345 + 1, 12345 + 2));\n+        assertEquals(\"minimum(int,int,int) 2 failed\", 12345, NumberUtils.min(12345 + 1, 12345, 12345 + 2));\n+        assertEquals(\"minimum(int,int,int) 3 failed\", 12345, NumberUtils.min(12345 + 1, 12345 + 2, 12345));\n+        assertEquals(\"minimum(int,int,int) 4 failed\", 12345, NumberUtils.min(12345 + 1, 12345, 12345));\n+        assertEquals(\"minimum(int,int,int) 5 failed\", 12345, NumberUtils.min(12345, 12345, 12345));\n+    }\n+\n+    public void testMinimumShort() {\n+        short low = 1234;\n+        short mid = 1234 + 1;\n+        short high = 1234 + 2;\n+        assertEquals(\"minimum(short,short,short) 1 failed\", low, NumberUtils.min(low, mid, high));\n+        assertEquals(\"minimum(short,short,short) 1 failed\", low, NumberUtils.min(mid, low, high));\n+        assertEquals(\"minimum(short,short,short) 1 failed\", low, NumberUtils.min(mid, high, low));\n+        assertEquals(\"minimum(short,short,short) 1 failed\", low, NumberUtils.min(low, mid, low));\n+    }\n+\n+    public void testMinimumByte() {\n+        byte low = 123;\n+        byte mid = 123 + 1;\n+        byte high = 123 + 2;\n+        assertEquals(\"minimum(byte,byte,byte) 1 failed\", low, NumberUtils.min(low, mid, high));\n+        assertEquals(\"minimum(byte,byte,byte) 1 failed\", low, NumberUtils.min(mid, low, high));\n+        assertEquals(\"minimum(byte,byte,byte) 1 failed\", low, NumberUtils.min(mid, high, low));\n+        assertEquals(\"minimum(byte,byte,byte) 1 failed\", low, NumberUtils.min(low, mid, low));\n+    }\n+\n+    public void testMinimumDouble() {\n+        double low = 12.3;\n+        double mid = 12.3 + 1;\n+        double high = 12.3 + 2;\n+        assertEquals(low, NumberUtils.min(low, mid, high), 0.0001);\n+        assertEquals(low, NumberUtils.min(mid, low, high), 0.0001);\n+        assertEquals(low, NumberUtils.min(mid, high, low), 0.0001);\n+        assertEquals(low, NumberUtils.min(low, mid, low), 0.0001);\n+        assertEquals(mid, NumberUtils.min(high, mid, high), 0.0001);\n+    }\n+\n+    public void testMinimumFloat() {\n+        float low = 12.3f;\n+        float mid = 12.3f + 1;\n+        float high = 12.3f + 2;\n+        assertEquals(low, NumberUtils.min(low, mid, high), 0.0001f);\n+        assertEquals(low, NumberUtils.min(mid, low, high), 0.0001f);\n+        assertEquals(low, NumberUtils.min(mid, high, low), 0.0001f);\n+        assertEquals(low, NumberUtils.min(low, mid, low), 0.0001f);\n+        assertEquals(mid, NumberUtils.min(high, mid, high), 0.0001f);\n+    }\n+\n+    public void testMaximumLong() {\n+        assertEquals(\"maximum(long,long,long) 1 failed\", 12345L, NumberUtils.max(12345L, 12345L - 1L, 12345L - 2L));\n+        assertEquals(\"maximum(long,long,long) 2 failed\", 12345L, NumberUtils.max(12345L - 1L, 12345L, 12345L - 2L));\n+        assertEquals(\"maximum(long,long,long) 3 failed\", 12345L, NumberUtils.max(12345L - 1L, 12345L - 2L, 12345L));\n+        assertEquals(\"maximum(long,long,long) 4 failed\", 12345L, NumberUtils.max(12345L - 1L, 12345L, 12345L));\n+        assertEquals(\"maximum(long,long,long) 5 failed\", 12345L, NumberUtils.max(12345L, 12345L, 12345L));\n+    }\n+\n+    public void testMaximumInt() {\n+        assertEquals(\"maximum(int,int,int) 1 failed\", 12345, NumberUtils.max(12345, 12345 - 1, 12345 - 2));\n+        assertEquals(\"maximum(int,int,int) 2 failed\", 12345, NumberUtils.max(12345 - 1, 12345, 12345 - 2));\n+        assertEquals(\"maximum(int,int,int) 3 failed\", 12345, NumberUtils.max(12345 - 1, 12345 - 2, 12345));\n+        assertEquals(\"maximum(int,int,int) 4 failed\", 12345, NumberUtils.max(12345 - 1, 12345, 12345));\n+        assertEquals(\"maximum(int,int,int) 5 failed\", 12345, NumberUtils.max(12345, 12345, 12345));\n+    }\n+\n+    public void testMaximumShort() {\n+        short low = 1234;\n+        short mid = 1234 + 1;\n+        short high = 1234 + 2;\n+        assertEquals(\"maximum(short,short,short) 1 failed\", high, NumberUtils.max(low, mid, high));\n+        assertEquals(\"maximum(short,short,short) 1 failed\", high, NumberUtils.max(mid, low, high));\n+        assertEquals(\"maximum(short,short,short) 1 failed\", high, NumberUtils.max(mid, high, low));\n+        assertEquals(\"maximum(short,short,short) 1 failed\", high, NumberUtils.max(high, mid, high));\n+    }\n+\n+    public void testMaximumByte() {\n+        byte low = 123;\n+        byte mid = 123 + 1;\n+        byte high = 123 + 2;\n+        assertEquals(\"maximum(byte,byte,byte) 1 failed\", high, NumberUtils.max(low, mid, high));\n+        assertEquals(\"maximum(byte,byte,byte) 1 failed\", high, NumberUtils.max(mid, low, high));\n+        assertEquals(\"maximum(byte,byte,byte) 1 failed\", high, NumberUtils.max(mid, high, low));\n+        assertEquals(\"maximum(byte,byte,byte) 1 failed\", high, NumberUtils.max(high, mid, high));\n+    }\n+\n+    public void testMaximumDouble() {\n+        double low = 12.3;\n+        double mid = 12.3 + 1;\n+        double high = 12.3 + 2;\n+        assertEquals(high, NumberUtils.max(low, mid, high), 0.0001);\n+        assertEquals(high, NumberUtils.max(mid, low, high), 0.0001);\n+        assertEquals(high, NumberUtils.max(mid, high, low), 0.0001);\n+        assertEquals(mid, NumberUtils.max(low, mid, low), 0.0001);\n+        assertEquals(high, NumberUtils.max(high, mid, high), 0.0001);\n+    }\n+\n+    public void testMaximumFloat() {\n+        float low = 12.3f;\n+        float mid = 12.3f + 1;\n+        float high = 12.3f + 2;\n+        assertEquals(high, NumberUtils.max(low, mid, high), 0.0001f);\n+        assertEquals(high, NumberUtils.max(mid, low, high), 0.0001f);\n+        assertEquals(high, NumberUtils.max(mid, high, low), 0.0001f);\n+        assertEquals(mid, NumberUtils.max(low, mid, low), 0.0001f);\n+        assertEquals(high, NumberUtils.max(high, mid, high), 0.0001f);\n+    }\n+\n+    // Testing JDK against old Lang functionality\n+    public void testCompareDouble() {\n+        assertTrue(Double.compare(Double.NaN, Double.NaN) == 0);\n+        assertTrue(Double.compare(Double.NaN, Double.POSITIVE_INFINITY) == +1);\n+        assertTrue(Double.compare(Double.NaN, Double.MAX_VALUE) == +1);\n+        assertTrue(Double.compare(Double.NaN, 1.2d) == +1);\n+        assertTrue(Double.compare(Double.NaN, 0.0d) == +1);\n+        assertTrue(Double.compare(Double.NaN, -0.0d) == +1);\n+        assertTrue(Double.compare(Double.NaN, -1.2d) == +1);\n+        assertTrue(Double.compare(Double.NaN, -Double.MAX_VALUE) == +1);\n+        assertTrue(Double.compare(Double.NaN, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(Double.compare(Double.POSITIVE_INFINITY, Double.NaN) == -1);\n+        assertTrue(Double.compare(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY) == 0);\n+        assertTrue(Double.compare(Double.POSITIVE_INFINITY, Double.MAX_VALUE) == +1);\n+        assertTrue(Double.compare(Double.POSITIVE_INFINITY, 1.2d) == +1);\n+        assertTrue(Double.compare(Double.POSITIVE_INFINITY, 0.0d) == +1);\n+        assertTrue(Double.compare(Double.POSITIVE_INFINITY, -0.0d) == +1);\n+        assertTrue(Double.compare(Double.POSITIVE_INFINITY, -1.2d) == +1);\n+        assertTrue(Double.compare(Double.POSITIVE_INFINITY, -Double.MAX_VALUE) == +1);\n+        assertTrue(Double.compare(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(Double.compare(Double.MAX_VALUE, Double.NaN) == -1);\n+        assertTrue(Double.compare(Double.MAX_VALUE, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(Double.compare(Double.MAX_VALUE, Double.MAX_VALUE) == 0);\n+        assertTrue(Double.compare(Double.MAX_VALUE, 1.2d) == +1);\n+        assertTrue(Double.compare(Double.MAX_VALUE, 0.0d) == +1);\n+        assertTrue(Double.compare(Double.MAX_VALUE, -0.0d) == +1);\n+        assertTrue(Double.compare(Double.MAX_VALUE, -1.2d) == +1);\n+        assertTrue(Double.compare(Double.MAX_VALUE, -Double.MAX_VALUE) == +1);\n+        assertTrue(Double.compare(Double.MAX_VALUE, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(Double.compare(1.2d, Double.NaN) == -1);\n+        assertTrue(Double.compare(1.2d, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(Double.compare(1.2d, Double.MAX_VALUE) == -1);\n+        assertTrue(Double.compare(1.2d, 1.2d) == 0);\n+        assertTrue(Double.compare(1.2d, 0.0d) == +1);\n+        assertTrue(Double.compare(1.2d, -0.0d) == +1);\n+        assertTrue(Double.compare(1.2d, -1.2d) == +1);\n+        assertTrue(Double.compare(1.2d, -Double.MAX_VALUE) == +1);\n+        assertTrue(Double.compare(1.2d, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(Double.compare(0.0d, Double.NaN) == -1);\n+        assertTrue(Double.compare(0.0d, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(Double.compare(0.0d, Double.MAX_VALUE) == -1);\n+        assertTrue(Double.compare(0.0d, 1.2d) == -1);\n+        assertTrue(Double.compare(0.0d, 0.0d) == 0);\n+        assertTrue(Double.compare(0.0d, -0.0d) == +1);\n+        assertTrue(Double.compare(0.0d, -1.2d) == +1);\n+        assertTrue(Double.compare(0.0d, -Double.MAX_VALUE) == +1);\n+        assertTrue(Double.compare(0.0d, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(Double.compare(-0.0d, Double.NaN) == -1);\n+        assertTrue(Double.compare(-0.0d, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(Double.compare(-0.0d, Double.MAX_VALUE) == -1);\n+        assertTrue(Double.compare(-0.0d, 1.2d) == -1);\n+        assertTrue(Double.compare(-0.0d, 0.0d) == -1);\n+        assertTrue(Double.compare(-0.0d, -0.0d) == 0);\n+        assertTrue(Double.compare(-0.0d, -1.2d) == +1);\n+        assertTrue(Double.compare(-0.0d, -Double.MAX_VALUE) == +1);\n+        assertTrue(Double.compare(-0.0d, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(Double.compare(-1.2d, Double.NaN) == -1);\n+        assertTrue(Double.compare(-1.2d, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(Double.compare(-1.2d, Double.MAX_VALUE) == -1);\n+        assertTrue(Double.compare(-1.2d, 1.2d) == -1);\n+        assertTrue(Double.compare(-1.2d, 0.0d) == -1);\n+        assertTrue(Double.compare(-1.2d, -0.0d) == -1);\n+        assertTrue(Double.compare(-1.2d, -1.2d) == 0);\n+        assertTrue(Double.compare(-1.2d, -Double.MAX_VALUE) == +1);\n+        assertTrue(Double.compare(-1.2d, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(Double.compare(-Double.MAX_VALUE, Double.NaN) == -1);\n+        assertTrue(Double.compare(-Double.MAX_VALUE, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(Double.compare(-Double.MAX_VALUE, Double.MAX_VALUE) == -1);\n+        assertTrue(Double.compare(-Double.MAX_VALUE, 1.2d) == -1);\n+        assertTrue(Double.compare(-Double.MAX_VALUE, 0.0d) == -1);\n+        assertTrue(Double.compare(-Double.MAX_VALUE, -0.0d) == -1);\n+        assertTrue(Double.compare(-Double.MAX_VALUE, -1.2d) == -1);\n+        assertTrue(Double.compare(-Double.MAX_VALUE, -Double.MAX_VALUE) == 0);\n+        assertTrue(Double.compare(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(Double.compare(Double.NEGATIVE_INFINITY, Double.NaN) == -1);\n+        assertTrue(Double.compare(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(Double.compare(Double.NEGATIVE_INFINITY, Double.MAX_VALUE) == -1);\n+        assertTrue(Double.compare(Double.NEGATIVE_INFINITY, 1.2d) == -1);\n+        assertTrue(Double.compare(Double.NEGATIVE_INFINITY, 0.0d) == -1);\n+        assertTrue(Double.compare(Double.NEGATIVE_INFINITY, -0.0d) == -1);\n+        assertTrue(Double.compare(Double.NEGATIVE_INFINITY, -1.2d) == -1);\n+        assertTrue(Double.compare(Double.NEGATIVE_INFINITY, -Double.MAX_VALUE) == -1);\n+        assertTrue(Double.compare(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY) == 0);\n+    }\n+\n+    public void testCompareFloat() {\n+        assertTrue(Float.compare(Float.NaN, Float.NaN) == 0);\n+        assertTrue(Float.compare(Float.NaN, Float.POSITIVE_INFINITY) == +1);\n+        assertTrue(Float.compare(Float.NaN, Float.MAX_VALUE) == +1);\n+        assertTrue(Float.compare(Float.NaN, 1.2f) == +1);\n+        assertTrue(Float.compare(Float.NaN, 0.0f) == +1);\n+        assertTrue(Float.compare(Float.NaN, -0.0f) == +1);\n+        assertTrue(Float.compare(Float.NaN, -1.2f) == +1);\n+        assertTrue(Float.compare(Float.NaN, -Float.MAX_VALUE) == +1);\n+        assertTrue(Float.compare(Float.NaN, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(Float.compare(Float.POSITIVE_INFINITY, Float.NaN) == -1);\n+        assertTrue(Float.compare(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY) == 0);\n+        assertTrue(Float.compare(Float.POSITIVE_INFINITY, Float.MAX_VALUE) == +1);\n+        assertTrue(Float.compare(Float.POSITIVE_INFINITY, 1.2f) == +1);\n+        assertTrue(Float.compare(Float.POSITIVE_INFINITY, 0.0f) == +1);\n+        assertTrue(Float.compare(Float.POSITIVE_INFINITY, -0.0f) == +1);\n+        assertTrue(Float.compare(Float.POSITIVE_INFINITY, -1.2f) == +1);\n+        assertTrue(Float.compare(Float.POSITIVE_INFINITY, -Float.MAX_VALUE) == +1);\n+        assertTrue(Float.compare(Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(Float.compare(Float.MAX_VALUE, Float.NaN) == -1);\n+        assertTrue(Float.compare(Float.MAX_VALUE, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(Float.compare(Float.MAX_VALUE, Float.MAX_VALUE) == 0);\n+        assertTrue(Float.compare(Float.MAX_VALUE, 1.2f) == +1);\n+        assertTrue(Float.compare(Float.MAX_VALUE, 0.0f) == +1);\n+        assertTrue(Float.compare(Float.MAX_VALUE, -0.0f) == +1);\n+        assertTrue(Float.compare(Float.MAX_VALUE, -1.2f) == +1);\n+        assertTrue(Float.compare(Float.MAX_VALUE, -Float.MAX_VALUE) == +1);\n+        assertTrue(Float.compare(Float.MAX_VALUE, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(Float.compare(1.2f, Float.NaN) == -1);\n+        assertTrue(Float.compare(1.2f, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(Float.compare(1.2f, Float.MAX_VALUE) == -1);\n+        assertTrue(Float.compare(1.2f, 1.2f) == 0);\n+        assertTrue(Float.compare(1.2f, 0.0f) == +1);\n+        assertTrue(Float.compare(1.2f, -0.0f) == +1);\n+        assertTrue(Float.compare(1.2f, -1.2f) == +1);\n+        assertTrue(Float.compare(1.2f, -Float.MAX_VALUE) == +1);\n+        assertTrue(Float.compare(1.2f, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(Float.compare(0.0f, Float.NaN) == -1);\n+        assertTrue(Float.compare(0.0f, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(Float.compare(0.0f, Float.MAX_VALUE) == -1);\n+        assertTrue(Float.compare(0.0f, 1.2f) == -1);\n+        assertTrue(Float.compare(0.0f, 0.0f) == 0);\n+        assertTrue(Float.compare(0.0f, -0.0f) == +1);\n+        assertTrue(Float.compare(0.0f, -1.2f) == +1);\n+        assertTrue(Float.compare(0.0f, -Float.MAX_VALUE) == +1);\n+        assertTrue(Float.compare(0.0f, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(Float.compare(-0.0f, Float.NaN) == -1);\n+        assertTrue(Float.compare(-0.0f, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(Float.compare(-0.0f, Float.MAX_VALUE) == -1);\n+        assertTrue(Float.compare(-0.0f, 1.2f) == -1);\n+        assertTrue(Float.compare(-0.0f, 0.0f) == -1);\n+        assertTrue(Float.compare(-0.0f, -0.0f) == 0);\n+        assertTrue(Float.compare(-0.0f, -1.2f) == +1);\n+        assertTrue(Float.compare(-0.0f, -Float.MAX_VALUE) == +1);\n+        assertTrue(Float.compare(-0.0f, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(Float.compare(-1.2f, Float.NaN) == -1);\n+        assertTrue(Float.compare(-1.2f, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(Float.compare(-1.2f, Float.MAX_VALUE) == -1);\n+        assertTrue(Float.compare(-1.2f, 1.2f) == -1);\n+        assertTrue(Float.compare(-1.2f, 0.0f) == -1);\n+        assertTrue(Float.compare(-1.2f, -0.0f) == -1);\n+        assertTrue(Float.compare(-1.2f, -1.2f) == 0);\n+        assertTrue(Float.compare(-1.2f, -Float.MAX_VALUE) == +1);\n+        assertTrue(Float.compare(-1.2f, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(Float.compare(-Float.MAX_VALUE, Float.NaN) == -1);\n+        assertTrue(Float.compare(-Float.MAX_VALUE, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(Float.compare(-Float.MAX_VALUE, Float.MAX_VALUE) == -1);\n+        assertTrue(Float.compare(-Float.MAX_VALUE, 1.2f) == -1);\n+        assertTrue(Float.compare(-Float.MAX_VALUE, 0.0f) == -1);\n+        assertTrue(Float.compare(-Float.MAX_VALUE, -0.0f) == -1);\n+        assertTrue(Float.compare(-Float.MAX_VALUE, -1.2f) == -1);\n+        assertTrue(Float.compare(-Float.MAX_VALUE, -Float.MAX_VALUE) == 0);\n+        assertTrue(Float.compare(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(Float.compare(Float.NEGATIVE_INFINITY, Float.NaN) == -1);\n+        assertTrue(Float.compare(Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(Float.compare(Float.NEGATIVE_INFINITY, Float.MAX_VALUE) == -1);\n+        assertTrue(Float.compare(Float.NEGATIVE_INFINITY, 1.2f) == -1);\n+        assertTrue(Float.compare(Float.NEGATIVE_INFINITY, 0.0f) == -1);\n+        assertTrue(Float.compare(Float.NEGATIVE_INFINITY, -0.0f) == -1);\n+        assertTrue(Float.compare(Float.NEGATIVE_INFINITY, -1.2f) == -1);\n+        assertTrue(Float.compare(Float.NEGATIVE_INFINITY, -Float.MAX_VALUE) == -1);\n+        assertTrue(Float.compare(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY) == 0);\n+    }\n+\n+    public void testIsDigits() {\n+        assertEquals(\"isDigits(null) failed\", false, NumberUtils.isDigits(null));\n+        assertEquals(\"isDigits('') failed\", false, NumberUtils.isDigits(\"\"));\n+        assertEquals(\"isDigits(String) failed\", true, NumberUtils.isDigits(\"12345\"));\n+        assertEquals(\"isDigits(String) neg 1 failed\", false, NumberUtils.isDigits(\"1234.5\"));\n+        assertEquals(\"isDigits(String) neg 3 failed\", false, NumberUtils.isDigits(\"1ab\"));\n+        assertEquals(\"isDigits(String) neg 4 failed\", false, NumberUtils.isDigits(\"abc\"));\n+    }\n+    \n+    /**\n+     * Tests isNumber(String) and tests that createNumber(String) returns\n+     * a valid number iff isNumber(String) returns false.\n+     */\n+    public void testIsNumber() {\n+        String val = \"12345\";\n+        assertTrue(\"isNumber(String) 1 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 1 failed\", checkCreateNumber(val));\n+        val = \"1234.5\";\n+        assertTrue(\"isNumber(String) 2 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 2 failed\", checkCreateNumber(val));\n+        val = \".12345\";\n+        assertTrue(\"isNumber(String) 3 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 3 failed\", checkCreateNumber(val));\n+        val = \"1234E5\";\n+        assertTrue(\"isNumber(String) 4 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 4 failed\", checkCreateNumber(val));\n+        val = \"1234E+5\";\n+        assertTrue(\"isNumber(String) 5 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 5 failed\", checkCreateNumber(val));\n+        val = \"1234E-5\";\n+        assertTrue(\"isNumber(String) 6 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 6 failed\", checkCreateNumber(val));\n+        val = \"123.4E5\";\n+        assertTrue(\"isNumber(String) 7 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 7 failed\", checkCreateNumber(val));\n+        val = \"-1234\";\n+        assertTrue(\"isNumber(String) 8 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 8 failed\", checkCreateNumber(val));\n+        val = \"-1234.5\";\n+        assertTrue(\"isNumber(String) 9 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 9 failed\", checkCreateNumber(val));\n+        val = \"-.12345\";\n+        assertTrue(\"isNumber(String) 10 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 10 failed\", checkCreateNumber(val));\n+        val = \"-1234E5\";\n+        assertTrue(\"isNumber(String) 11 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 11 failed\", checkCreateNumber(val));\n+        val = \"0\";\n+        assertTrue(\"isNumber(String) 12 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 12 failed\", checkCreateNumber(val));\n+        val = \"-0\";\n+        assertTrue(\"isNumber(String) 13 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 13 failed\", checkCreateNumber(val));\n+        val = \"01234\";\n+        assertTrue(\"isNumber(String) 14 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 14 failed\", checkCreateNumber(val));\n+        val = \"-01234\";\n+        assertTrue(\"isNumber(String) 15 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 15 failed\", checkCreateNumber(val));\n+        val = \"0xABC123\";\n+        assertTrue(\"isNumber(String) 16 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 16 failed\", checkCreateNumber(val));\n+        val = \"0x0\";\n+        assertTrue(\"isNumber(String) 17 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 17 failed\", checkCreateNumber(val));\n+        val = \"123.4E21D\";\n+        assertTrue(\"isNumber(String) 19 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 19 failed\", checkCreateNumber(val));\n+        val = \"-221.23F\";\n+        assertTrue(\"isNumber(String) 20 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 20 failed\", checkCreateNumber(val));\n+        val = \"22338L\";\n+        assertTrue(\"isNumber(String) 21 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 21 failed\", checkCreateNumber(val));\n+        val = null;\n+        assertTrue(\"isNumber(String) 1 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 1 Neg failed\", !checkCreateNumber(val));\n+        val = \"\";\n+        assertTrue(\"isNumber(String) 2 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 2 Neg failed\", !checkCreateNumber(val));\n+        val = \"--2.3\";\n+        assertTrue(\"isNumber(String) 3 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 3 Neg failed\", !checkCreateNumber(val));\n+        val = \".12.3\";\n+        assertTrue(\"isNumber(String) 4 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 4 Neg failed\", !checkCreateNumber(val));\n+        val = \"-123E\";\n+        assertTrue(\"isNumber(String) 5 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 5 Neg failed\", !checkCreateNumber(val));\n+        val = \"-123E+-212\";\n+        assertTrue(\"isNumber(String) 6 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 6 Neg failed\", !checkCreateNumber(val));\n+        val = \"-123E2.12\";\n+        assertTrue(\"isNumber(String) 7 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 7 Neg failed\", !checkCreateNumber(val));\n+        val = \"0xGF\";\n+        assertTrue(\"isNumber(String) 8 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 8 Neg failed\", !checkCreateNumber(val));\n+        val = \"0xFAE-1\";\n+        assertTrue(\"isNumber(String) 9 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 9 Neg failed\", !checkCreateNumber(val));\n+        val = \".\";\n+        assertTrue(\"isNumber(String) 10 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 10 Neg failed\", !checkCreateNumber(val));\n+        val = \"-0ABC123\";\n+        assertTrue(\"isNumber(String) 11 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 11 Neg failed\", !checkCreateNumber(val));\n+        val = \"123.4E-D\";\n+        assertTrue(\"isNumber(String) 12 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 12 Neg failed\", !checkCreateNumber(val));\n+        val = \"123.4ED\";\n+        assertTrue(\"isNumber(String) 13 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 13 Neg failed\", !checkCreateNumber(val));\n+        val = \"1234E5l\";\n+        assertTrue(\"isNumber(String) 14 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 14 Neg failed\", !checkCreateNumber(val));\n+        val = \"11a\";\n+        assertTrue(\"isNumber(String) 15 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 15 Neg failed\", !checkCreateNumber(val)); \n+        val = \"1a\";\n+        assertTrue(\"isNumber(String) 16 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 16 Neg failed\", !checkCreateNumber(val)); \n+        val = \"a\";\n+        assertTrue(\"isNumber(String) 17 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 17 Neg failed\", !checkCreateNumber(val)); \n+        val = \"11g\";\n+        assertTrue(\"isNumber(String) 18 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 18 Neg failed\", !checkCreateNumber(val)); \n+        val = \"11z\";\n+        assertTrue(\"isNumber(String) 19 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 19 Neg failed\", !checkCreateNumber(val)); \n+        val = \"11def\";\n+        assertTrue(\"isNumber(String) 20 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 20 Neg failed\", !checkCreateNumber(val)); \n+        val = \"11d11\";\n+        assertTrue(\"isNumber(String) 21 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 21 Neg failed\", !checkCreateNumber(val)); \n+        val = \"11 11\";\n+        assertTrue(\"isNumber(String) 22 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 22 Neg failed\", !checkCreateNumber(val));\n+        val = \" 1111\";\n+        assertTrue(\"isNumber(String) 23 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 23 Neg failed\", !checkCreateNumber(val));\n+        val = \"1111 \";\n+        assertTrue(\"isNumber(String) 24 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 24 Neg failed\", !checkCreateNumber(val));\n+\n+    }\n+\n+    private boolean checkCreateNumber(String val) {\n+        try {\n+            Object obj = NumberUtils.createNumber(val);\n+            if (obj == null) {\n+                return false;\n+            }\n+            return true;\n+        } catch (NumberFormatException e) {\n+            return false;\n+       }\n+    }\n+\n+    @SuppressWarnings(\"cast\") // suppress instanceof warning check\n+    public void testConstants() {\n+        assertTrue(NumberUtils.LONG_ZERO instanceof Long);\n+        assertTrue(NumberUtils.LONG_ONE instanceof Long);\n+        assertTrue(NumberUtils.LONG_MINUS_ONE instanceof Long);\n+        assertTrue(NumberUtils.INTEGER_ZERO instanceof Integer);\n+        assertTrue(NumberUtils.INTEGER_ONE instanceof Integer);\n+        assertTrue(NumberUtils.INTEGER_MINUS_ONE instanceof Integer);\n+        assertTrue(NumberUtils.SHORT_ZERO instanceof Short);\n+        assertTrue(NumberUtils.SHORT_ONE instanceof Short);\n+        assertTrue(NumberUtils.SHORT_MINUS_ONE instanceof Short);\n+        assertTrue(NumberUtils.BYTE_ZERO instanceof Byte);\n+        assertTrue(NumberUtils.BYTE_ONE instanceof Byte);\n+        assertTrue(NumberUtils.BYTE_MINUS_ONE instanceof Byte);\n+        assertTrue(NumberUtils.DOUBLE_ZERO instanceof Double);\n+        assertTrue(NumberUtils.DOUBLE_ONE instanceof Double);\n+        assertTrue(NumberUtils.DOUBLE_MINUS_ONE instanceof Double);\n+        assertTrue(NumberUtils.FLOAT_ZERO instanceof Float);\n+        assertTrue(NumberUtils.FLOAT_ONE instanceof Float);\n+        assertTrue(NumberUtils.FLOAT_MINUS_ONE instanceof Float);\n+        \n+        assertTrue(NumberUtils.LONG_ZERO.longValue() == 0);\n+        assertTrue(NumberUtils.LONG_ONE.longValue() == 1);\n+        assertTrue(NumberUtils.LONG_MINUS_ONE.longValue() == -1);\n+        assertTrue(NumberUtils.INTEGER_ZERO.intValue() == 0);\n+        assertTrue(NumberUtils.INTEGER_ONE.intValue() == 1);\n+        assertTrue(NumberUtils.INTEGER_MINUS_ONE.intValue() == -1);\n+        assertTrue(NumberUtils.SHORT_ZERO.shortValue() == 0);\n+        assertTrue(NumberUtils.SHORT_ONE.shortValue() == 1);\n+        assertTrue(NumberUtils.SHORT_MINUS_ONE.shortValue() == -1);\n+        assertTrue(NumberUtils.BYTE_ZERO.byteValue() == 0);\n+        assertTrue(NumberUtils.BYTE_ONE.byteValue() == 1);\n+        assertTrue(NumberUtils.BYTE_MINUS_ONE.byteValue() == -1);\n+        assertTrue(NumberUtils.DOUBLE_ZERO.doubleValue() == 0.0d);\n+        assertTrue(NumberUtils.DOUBLE_ONE.doubleValue() == 1.0d);\n+        assertTrue(NumberUtils.DOUBLE_MINUS_ONE.doubleValue() == -1.0d);\n+        assertTrue(NumberUtils.FLOAT_ZERO.floatValue() == 0.0f);\n+        assertTrue(NumberUtils.FLOAT_ONE.floatValue() == 1.0f);\n+        assertTrue(NumberUtils.FLOAT_MINUS_ONE.floatValue() == -1.0f);\n+    }\n+\n+    public void testLang300() {\n+        NumberUtils.createNumber(\"-1l\");\n+        NumberUtils.createNumber(\"01l\");\n+        NumberUtils.createNumber(\"1l\");\n+    }\n+\n+    public void testLang381() {\n+        assertTrue(Double.isNaN(NumberUtils.min(1.2, 2.5, Double.NaN)));\n+        assertTrue(Double.isNaN(NumberUtils.max(1.2, 2.5, Double.NaN)));\n+        assertTrue(Float.isNaN(NumberUtils.min(1.2f, 2.5f, Float.NaN)));\n+        assertTrue(Float.isNaN(NumberUtils.max(1.2f, 2.5f, Float.NaN)));\n+\n+        double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN };\n+        assertTrue(Double.isNaN(NumberUtils.max(a)));\n+        assertTrue(Double.isNaN(NumberUtils.min(a)));\n+\n+        double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN };\n+        assertTrue(Double.isNaN(NumberUtils.max(b)));\n+        assertTrue(Double.isNaN(NumberUtils.min(b)));\n+\n+        float[] aF = new float[] { 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN };\n+        assertTrue(Float.isNaN(NumberUtils.max(aF)));\n+\n+        float[] bF = new float[] { Float.NaN, 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN };\n+        assertTrue(Float.isNaN(NumberUtils.max(bF)));\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/mutable/MutableBooleanTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.mutable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @since 2.2\n+ * @see MutableBoolean\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MutableBooleanTest extends TestCase {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(MutableBooleanTest.class);\n+    }\n+\n+    public MutableBooleanTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public void testCompareTo() {\n+        final MutableBoolean mutBool = new MutableBoolean(false);\n+\n+        assertEquals(0, mutBool.compareTo(new MutableBoolean(false)));\n+        assertEquals(-1, mutBool.compareTo(new MutableBoolean(true)));\n+        mutBool.setValue(true);\n+        assertEquals(+1, mutBool.compareTo(new MutableBoolean(false)));\n+        assertEquals(0, mutBool.compareTo(new MutableBoolean(true)));\n+\n+        try {\n+            mutBool.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {\n+        }\n+    }\n+\n+    // ----------------------------------------------------------------\n+    public void testConstructors() {\n+        assertEquals(false, new MutableBoolean().booleanValue());\n+\n+        assertEquals(true, new MutableBoolean(true).booleanValue());\n+        assertEquals(false, new MutableBoolean(false).booleanValue());\n+\n+        assertEquals(true, new MutableBoolean(Boolean.TRUE).booleanValue());\n+        assertEquals(false, new MutableBoolean(Boolean.FALSE).booleanValue());\n+\n+        try {\n+            new MutableBoolean(null);\n+            fail();\n+        } catch (NullPointerException ex) {\n+        }\n+    }\n+\n+    public void testEquals() {\n+        final MutableBoolean mutBoolA = new MutableBoolean(false);\n+        final MutableBoolean mutBoolB = new MutableBoolean(false);\n+        final MutableBoolean mutBoolC = new MutableBoolean(true);\n+\n+        assertEquals(true, mutBoolA.equals(mutBoolA));\n+        assertEquals(true, mutBoolA.equals(mutBoolB));\n+        assertEquals(true, mutBoolB.equals(mutBoolA));\n+        assertEquals(true, mutBoolB.equals(mutBoolB));\n+        assertEquals(false, mutBoolA.equals(mutBoolC));\n+        assertEquals(false, mutBoolB.equals(mutBoolC));\n+        assertEquals(true, mutBoolC.equals(mutBoolC));\n+        assertEquals(false, mutBoolA.equals(null));\n+        assertEquals(false, mutBoolA.equals(Boolean.FALSE));\n+        assertEquals(false, mutBoolA.equals(\"false\"));\n+    }\n+\n+    public void testGetSet() {\n+        assertEquals(false, new MutableBoolean().booleanValue());\n+        assertEquals(Boolean.FALSE, new MutableBoolean().getValue());\n+        \n+        final MutableBoolean mutBool = new MutableBoolean(false);\n+        assertEquals(Boolean.FALSE, mutBool.toBoolean());\n+        assertEquals(false, mutBool.booleanValue());\n+        assertEquals(true, mutBool.isFalse());\n+        assertEquals(false, mutBool.isTrue());\n+\n+        mutBool.setValue(Boolean.TRUE);\n+        assertEquals(Boolean.TRUE, mutBool.toBoolean());\n+        assertEquals(true, mutBool.booleanValue());\n+        assertEquals(false, mutBool.isFalse());\n+        assertEquals(true, mutBool.isTrue());\n+\n+        mutBool.setValue(false);\n+        assertEquals(false, mutBool.booleanValue());\n+\n+        mutBool.setValue(true);\n+        assertEquals(true, mutBool.booleanValue());\n+\n+        try {\n+            mutBool.setValue(null);\n+            fail();\n+        } catch (NullPointerException ex) {\n+        }\n+    }\n+\n+    public void testHashCode() {\n+        final MutableBoolean mutBoolA = new MutableBoolean(false);\n+        final MutableBoolean mutBoolB = new MutableBoolean(false);\n+        final MutableBoolean mutBoolC = new MutableBoolean(true);\n+\n+        assertEquals(true, mutBoolA.hashCode() == mutBoolA.hashCode());\n+        assertEquals(true, mutBoolA.hashCode() == mutBoolB.hashCode());\n+        assertEquals(false, mutBoolA.hashCode() == mutBoolC.hashCode());\n+        assertEquals(true, mutBoolA.hashCode() == Boolean.FALSE.hashCode());\n+        assertEquals(true, mutBoolC.hashCode() == Boolean.TRUE.hashCode());\n+    }\n+\n+    public void testToString() {\n+        assertEquals(Boolean.FALSE.toString(), new MutableBoolean(false).toString());\n+        assertEquals(Boolean.TRUE.toString(), new MutableBoolean(true).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/mutable/MutableByteTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Id$\n+ * @see MutableByte\n+ */\n+public class MutableByteTest extends TestCase {\n+\n+    public MutableByteTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(MutableByteTest.class);\n+    }\n+\n+    // ----------------------------------------------------------------\n+    public void testConstructors() {\n+        assertEquals((byte) 0, new MutableByte().byteValue());\n+        \n+        assertEquals((byte) 1, new MutableByte((byte) 1).byteValue());\n+        \n+        assertEquals((byte) 2, new MutableByte(Byte.valueOf((byte) 2)).byteValue());\n+        assertEquals((byte) 3, new MutableByte(new MutableByte((byte) 3)).byteValue());\n+\n+        assertEquals((byte) 2, new MutableByte(\"2\").byteValue());\n+\n+        try {\n+            new MutableByte((Number)null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testGetSet() {\n+        final MutableByte mutNum = new MutableByte((byte) 0);\n+        assertEquals((byte) 0, new MutableByte().byteValue());\n+        assertEquals(Byte.valueOf((byte) 0), new MutableByte().getValue());\n+        \n+        mutNum.setValue((byte) 1);\n+        assertEquals((byte) 1, mutNum.byteValue());\n+        assertEquals(Byte.valueOf((byte) 1), mutNum.getValue());\n+        \n+        mutNum.setValue(Byte.valueOf((byte) 2));\n+        assertEquals((byte) 2, mutNum.byteValue());\n+        assertEquals(Byte.valueOf((byte) 2), mutNum.getValue());\n+        \n+        mutNum.setValue(new MutableByte((byte) 3));\n+        assertEquals((byte) 3, mutNum.byteValue());\n+        assertEquals(Byte.valueOf((byte) 3), mutNum.getValue());\n+        try {\n+            mutNum.setValue(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testEquals() {\n+        final MutableByte mutNumA = new MutableByte((byte) 0);\n+        final MutableByte mutNumB = new MutableByte((byte) 0);\n+        final MutableByte mutNumC = new MutableByte((byte) 1);\n+\n+        assertEquals(true, mutNumA.equals(mutNumA));\n+        assertEquals(true, mutNumA.equals(mutNumB));\n+        assertEquals(true, mutNumB.equals(mutNumA));\n+        assertEquals(true, mutNumB.equals(mutNumB));\n+        assertEquals(false, mutNumA.equals(mutNumC));\n+        assertEquals(false, mutNumB.equals(mutNumC));\n+        assertEquals(true, mutNumC.equals(mutNumC));\n+        assertEquals(false, mutNumA.equals(null));\n+        assertEquals(false, mutNumA.equals(Byte.valueOf((byte) 0)));\n+        assertEquals(false, mutNumA.equals(\"0\"));\n+    }\n+\n+    public void testHashCode() {\n+        final MutableByte mutNumA = new MutableByte((byte) 0);\n+        final MutableByte mutNumB = new MutableByte((byte) 0);\n+        final MutableByte mutNumC = new MutableByte((byte) 1);\n+\n+        assertEquals(true, mutNumA.hashCode() == mutNumA.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == mutNumB.hashCode());\n+        assertEquals(false, mutNumA.hashCode() == mutNumC.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == Byte.valueOf((byte) 0).hashCode());\n+    }\n+\n+    public void testCompareTo() {\n+        final MutableByte mutNum = new MutableByte((byte) 0);\n+\n+        assertEquals((byte) 0, mutNum.compareTo(new MutableByte((byte) 0)));\n+        assertEquals((byte) +1, mutNum.compareTo(new MutableByte((byte) -1)));\n+        assertEquals((byte) -1, mutNum.compareTo(new MutableByte((byte) 1)));\n+        try {\n+            mutNum.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testPrimitiveValues() {\n+        MutableByte mutNum = new MutableByte( (byte) 1 );\n+        \n+        assertEquals( 1.0F, mutNum.floatValue(), 0 );\n+        assertEquals( 1.0, mutNum.doubleValue(), 0 );\n+        assertEquals( (byte) 1, mutNum.byteValue() );\n+        assertEquals( (short) 1, mutNum.shortValue() );\n+        assertEquals( 1, mutNum.intValue() );\n+        assertEquals( 1L, mutNum.longValue() );\n+    }\n+\n+    public void testToByte() {\n+        assertEquals(Byte.valueOf((byte) 0), new MutableByte((byte) 0).toByte());\n+        assertEquals(Byte.valueOf((byte) 123), new MutableByte((byte) 123).toByte());\n+    }\n+\n+    public void testIncrement() {\n+        MutableByte mutNum = new MutableByte((byte) 1);\n+        mutNum.increment();\n+        \n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(2L, mutNum.longValue());\n+    }\n+\n+    public void testDecrement() {\n+        MutableByte mutNum = new MutableByte((byte) 1);\n+        mutNum.decrement();\n+        \n+        assertEquals(0, mutNum.intValue());\n+        assertEquals(0L, mutNum.longValue());\n+    }\n+\n+    public void testAddValuePrimitive() {\n+        MutableByte mutNum = new MutableByte((byte) 1);\n+        mutNum.add((byte)1);\n+        \n+        assertEquals((byte) 2, mutNum.byteValue());\n+    }\n+\n+    public void testAddValueObject() {\n+        MutableByte mutNum = new MutableByte((byte) 1);\n+        mutNum.add(new Integer(1));\n+        \n+        assertEquals((byte) 2, mutNum.byteValue());\n+    }\n+\n+    public void testSubtractValuePrimitive() {\n+        MutableByte mutNum = new MutableByte((byte) 1);\n+        mutNum.subtract((byte) 1);\n+        \n+        assertEquals((byte) 0, mutNum.byteValue());\n+    }\n+\n+    public void testSubtractValueObject() {\n+        MutableByte mutNum = new MutableByte((byte) 1);\n+        mutNum.subtract(new Integer(1));\n+        \n+        assertEquals((byte) 0, mutNum.byteValue());\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"0\", new MutableByte((byte) 0).toString());\n+        assertEquals(\"10\", new MutableByte((byte) 10).toString());\n+        assertEquals(\"-123\", new MutableByte((byte) -123).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/mutable/MutableDoubleTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Id$\n+ * @see MutableDouble\n+ */\n+public class MutableDoubleTest extends TestCase {\n+\n+    public MutableDoubleTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(MutableDoubleTest.class);\n+    }\n+\n+    // ----------------------------------------------------------------\n+    public void testConstructors() {\n+        assertEquals(0d, new MutableDouble().doubleValue(), 0.0001d);\n+        \n+        assertEquals(1d, new MutableDouble(1d).doubleValue(), 0.0001d);\n+        \n+        assertEquals(2d, new MutableDouble(new Double(2d)).doubleValue(), 0.0001d);\n+        assertEquals(3d, new MutableDouble(new MutableDouble(3d)).doubleValue(), 0.0001d);\n+        \n+        assertEquals(2d, new MutableDouble(\"2.0\").doubleValue(), 0.0001d);\n+\n+        try {\n+            new MutableDouble((Number)null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testGetSet() {\n+        final MutableDouble mutNum = new MutableDouble(0d);\n+        assertEquals(0d, new MutableDouble().doubleValue(), 0.0001d);\n+        assertEquals(new Double(0), new MutableDouble().getValue());\n+        \n+        mutNum.setValue(1);\n+        assertEquals(1d, mutNum.doubleValue(), 0.0001d);\n+        assertEquals(new Double(1d), mutNum.getValue());\n+        \n+        mutNum.setValue(new Double(2d));\n+        assertEquals(2d, mutNum.doubleValue(), 0.0001d);\n+        assertEquals(new Double(2d), mutNum.getValue());\n+        \n+        mutNum.setValue(new MutableDouble(3d));\n+        assertEquals(3d, mutNum.doubleValue(), 0.0001d);\n+        assertEquals(new Double(3d), mutNum.getValue());\n+        try {\n+            mutNum.setValue(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testNanInfinite() {\n+        MutableDouble mutNum = new MutableDouble(Double.NaN);\n+        assertEquals(true, mutNum.isNaN());\n+        \n+        mutNum = new MutableDouble(Double.POSITIVE_INFINITY);\n+        assertEquals(true, mutNum.isInfinite());\n+        \n+        mutNum = new MutableDouble(Double.NEGATIVE_INFINITY);\n+        assertEquals(true, mutNum.isInfinite());\n+    }\n+\n+    public void testEquals() {\n+        final MutableDouble mutNumA = new MutableDouble(0d);\n+        final MutableDouble mutNumB = new MutableDouble(0d);\n+        final MutableDouble mutNumC = new MutableDouble(1d);\n+\n+        assertEquals(true, mutNumA.equals(mutNumA));\n+        assertEquals(true, mutNumA.equals(mutNumB));\n+        assertEquals(true, mutNumB.equals(mutNumA));\n+        assertEquals(true, mutNumB.equals(mutNumB));\n+        assertEquals(false, mutNumA.equals(mutNumC));\n+        assertEquals(false, mutNumB.equals(mutNumC));\n+        assertEquals(true, mutNumC.equals(mutNumC));\n+        assertEquals(false, mutNumA.equals(null));\n+        assertEquals(false, mutNumA.equals(new Double(0d)));\n+        assertEquals(false, mutNumA.equals(\"0\"));\n+    }\n+\n+    public void testHashCode() {\n+        final MutableDouble mutNumA = new MutableDouble(0d);\n+        final MutableDouble mutNumB = new MutableDouble(0d);\n+        final MutableDouble mutNumC = new MutableDouble(1d);\n+\n+        assertEquals(true, mutNumA.hashCode() == mutNumA.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == mutNumB.hashCode());\n+        assertEquals(false, mutNumA.hashCode() == mutNumC.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == new Double(0d).hashCode());\n+    }\n+\n+    public void testCompareTo() {\n+        final MutableDouble mutNum = new MutableDouble(0d);\n+\n+        assertEquals(0, mutNum.compareTo(new MutableDouble(0d)));\n+        assertEquals(+1, mutNum.compareTo(new MutableDouble(-1d)));\n+        assertEquals(-1, mutNum.compareTo(new MutableDouble(1d)));\n+        try {\n+            mutNum.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testPrimitiveValues() {\n+        MutableDouble mutNum = new MutableDouble(1.7);\n+        \n+        assertEquals( 1.7F, mutNum.floatValue(), 0 );\n+        assertEquals( 1.7, mutNum.doubleValue(), 0 );\n+        assertEquals( (byte) 1, mutNum.byteValue() );\n+        assertEquals( (short) 1, mutNum.shortValue() );\n+        assertEquals( 1, mutNum.intValue() );\n+        assertEquals( 1L, mutNum.longValue() );\n+    }\n+\n+    public void testToDouble() {\n+        assertEquals(new Double(0d), new MutableDouble(0d).toDouble());\n+        assertEquals(new Double(12.3d), new MutableDouble(12.3d).toDouble());\n+    }\n+\n+    public void testIncrement() {\n+        MutableDouble mutNum = new MutableDouble(1);\n+        mutNum.increment();\n+        \n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(2L, mutNum.longValue());\n+    }\n+\n+    public void testDecrement() {\n+        MutableDouble mutNum = new MutableDouble(1);\n+        mutNum.decrement();\n+        \n+        assertEquals(0, mutNum.intValue());\n+        assertEquals(0L, mutNum.longValue());\n+    }\n+\n+    public void testAddValuePrimitive() {\n+        MutableDouble mutNum = new MutableDouble(1);\n+        mutNum.add(1.1d);\n+        \n+        assertEquals(2.1d, mutNum.doubleValue(), 0.01d);\n+    }\n+\n+    public void testAddValueObject() {\n+        MutableDouble mutNum = new MutableDouble(1);\n+        mutNum.add(new Double(1.1d));\n+        \n+        assertEquals(2.1d, mutNum.doubleValue(), 0.01d);\n+    }\n+\n+    public void testSubtractValuePrimitive() {\n+        MutableDouble mutNum = new MutableDouble(1);\n+        mutNum.subtract(0.9d);\n+        \n+        assertEquals(0.1d, mutNum.doubleValue(), 0.01d);\n+    }\n+\n+    public void testSubtractValueObject() {\n+        MutableDouble mutNum = new MutableDouble(1);\n+        mutNum.subtract(new Double(0.9d));\n+        \n+        assertEquals(0.1d, mutNum.doubleValue(), 0.01d);\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"0.0\", new MutableDouble(0d).toString());\n+        assertEquals(\"10.0\", new MutableDouble(10d).toString());\n+        assertEquals(\"-123.0\", new MutableDouble(-123d).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/mutable/MutableFloatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Id$\n+ * @see MutableFloat\n+ */\n+public class MutableFloatTest extends TestCase {\n+\n+    public MutableFloatTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(MutableFloatTest.class);\n+    }\n+\n+    // ----------------------------------------------------------------\n+    public void testConstructors() {\n+        assertEquals(0f, new MutableFloat().floatValue(), 0.0001f);\n+        \n+        assertEquals(1f, new MutableFloat(1f).floatValue(), 0.0001f);\n+        \n+        assertEquals(2f, new MutableFloat(new Float(2f)).floatValue(), 0.0001f);\n+        assertEquals(3f, new MutableFloat(new MutableFloat(3f)).floatValue(), 0.0001f);\n+\n+        assertEquals(2f, new MutableDouble(\"2.0\").floatValue(), 0.0001f);\n+\n+        try {\n+            new MutableFloat((Number)null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testGetSet() {\n+        final MutableFloat mutNum = new MutableFloat(0f);\n+        assertEquals(0f, new MutableFloat().floatValue(), 0.0001f);\n+        assertEquals(new Float(0), new MutableFloat().getValue());\n+        \n+        mutNum.setValue(1);\n+        assertEquals(1f, mutNum.floatValue(), 0.0001f);\n+        assertEquals(new Float(1f), mutNum.getValue());\n+        \n+        mutNum.setValue(new Float(2f));\n+        assertEquals(2f, mutNum.floatValue(), 0.0001f);\n+        assertEquals(new Float(2f), mutNum.getValue());\n+        \n+        mutNum.setValue(new MutableFloat(3f));\n+        assertEquals(3f, mutNum.floatValue(), 0.0001f);\n+        assertEquals(new Float(3f), mutNum.getValue());\n+        try {\n+            mutNum.setValue(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testNanInfinite() {\n+        MutableFloat mutNum = new MutableFloat(Float.NaN);\n+        assertEquals(true, mutNum.isNaN());\n+        \n+        mutNum = new MutableFloat(Float.POSITIVE_INFINITY);\n+        assertEquals(true, mutNum.isInfinite());\n+        \n+        mutNum = new MutableFloat(Float.NEGATIVE_INFINITY);\n+        assertEquals(true, mutNum.isInfinite());\n+    }\n+\n+    public void testEquals() {\n+        final MutableFloat mutNumA = new MutableFloat(0f);\n+        final MutableFloat mutNumB = new MutableFloat(0f);\n+        final MutableFloat mutNumC = new MutableFloat(1f);\n+\n+        assertEquals(true, mutNumA.equals(mutNumA));\n+        assertEquals(true, mutNumA.equals(mutNumB));\n+        assertEquals(true, mutNumB.equals(mutNumA));\n+        assertEquals(true, mutNumB.equals(mutNumB));\n+        assertEquals(false, mutNumA.equals(mutNumC));\n+        assertEquals(false, mutNumB.equals(mutNumC));\n+        assertEquals(true, mutNumC.equals(mutNumC));\n+        assertEquals(false, mutNumA.equals(null));\n+        assertEquals(false, mutNumA.equals(new Float(0f)));\n+        assertEquals(false, mutNumA.equals(\"0\"));\n+    }\n+\n+    public void testHashCode() {\n+        final MutableFloat mutNumA = new MutableFloat(0f);\n+        final MutableFloat mutNumB = new MutableFloat(0f);\n+        final MutableFloat mutNumC = new MutableFloat(1f);\n+\n+        assertEquals(true, mutNumA.hashCode() == mutNumA.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == mutNumB.hashCode());\n+        assertEquals(false, mutNumA.hashCode() == mutNumC.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == new Float(0f).hashCode());\n+    }\n+\n+    public void testCompareTo() {\n+        final MutableFloat mutNum = new MutableFloat(0f);\n+\n+        assertEquals(0, mutNum.compareTo(new MutableFloat(0f)));\n+        assertEquals(+1, mutNum.compareTo(new MutableFloat(-1f)));\n+        assertEquals(-1, mutNum.compareTo(new MutableFloat(1f)));\n+        try {\n+            mutNum.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testPrimitiveValues() {\n+        MutableFloat mutNum = new MutableFloat(1.7F);\n+        \n+        assertEquals( 1, mutNum.intValue() );\n+        assertEquals( 1.7, mutNum.doubleValue(), 0.00001 );\n+        assertEquals( (byte) 1, mutNum.byteValue() );\n+        assertEquals( (short) 1, mutNum.shortValue() );\n+        assertEquals( 1, mutNum.intValue() );\n+        assertEquals( 1L, mutNum.longValue() );\n+    }\n+\n+    public void testToFloat() {\n+        assertEquals(new Float(0f), new MutableFloat(0f).toFloat());\n+        assertEquals(new Float(12.3f), new MutableFloat(12.3f).toFloat());\n+    }\n+\n+    public void testIncrement() {\n+        MutableFloat mutNum = new MutableFloat(1);\n+        mutNum.increment();\n+        \n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(2L, mutNum.longValue());\n+    }\n+\n+    public void testDecrement() {\n+        MutableFloat mutNum = new MutableFloat(1);\n+        mutNum.decrement();\n+        \n+        assertEquals(0, mutNum.intValue());\n+        assertEquals(0L, mutNum.longValue());\n+    }\n+\n+    public void testAddValuePrimitive() {\n+        MutableFloat mutNum = new MutableFloat(1);\n+        mutNum.add(1.1f);\n+        \n+        assertEquals(2.1f, mutNum.floatValue(), 0.01f);\n+    }\n+\n+    public void testAddValueObject() {\n+        MutableFloat mutNum = new MutableFloat(1);\n+        mutNum.add(new Float(1.1f));\n+        \n+        assertEquals(2.1f, mutNum.floatValue(), 0.01f);\n+    }\n+\n+    public void testSubtractValuePrimitive() {\n+        MutableFloat mutNum = new MutableFloat(1);\n+        mutNum.subtract(0.9f);\n+        \n+        assertEquals(0.1f, mutNum.floatValue(), 0.01f);\n+    }\n+\n+    public void testSubtractValueObject() {\n+        MutableFloat mutNum = new MutableFloat(1);\n+        mutNum.subtract(new Float(0.9f));\n+        \n+        assertEquals(0.1f, mutNum.floatValue(), 0.01f);\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"0.0\", new MutableFloat(0f).toString());\n+        assertEquals(\"10.0\", new MutableFloat(10f).toString());\n+        assertEquals(\"-123.0\", new MutableFloat(-123f).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/mutable/MutableIntTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Id$\n+ * @see MutableInt\n+ */\n+public class MutableIntTest extends TestCase {\n+\n+    public MutableIntTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(MutableIntTest.class);\n+    }\n+\n+    // ----------------------------------------------------------------\n+    public void testConstructors() {\n+        assertEquals(0, new MutableInt().intValue());\n+        \n+        assertEquals(1, new MutableInt(1).intValue());\n+        \n+        assertEquals(2, new MutableInt(new Integer(2)).intValue());\n+        assertEquals(3, new MutableInt(new MutableLong(3)).intValue());\n+\n+        assertEquals(2, new MutableInt(\"2\").intValue());\n+\n+        try {\n+            new MutableInt((Number)null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testGetSet() {\n+        final MutableInt mutNum = new MutableInt(0);\n+        assertEquals(0, new MutableInt().intValue());\n+        assertEquals(new Integer(0), new MutableInt().getValue());\n+        \n+        mutNum.setValue(1);\n+        assertEquals(1, mutNum.intValue());\n+        assertEquals(new Integer(1), mutNum.getValue());\n+        \n+        mutNum.setValue(new Integer(2));\n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(new Integer(2), mutNum.getValue());\n+        \n+        mutNum.setValue(new MutableLong(3));\n+        assertEquals(3, mutNum.intValue());\n+        assertEquals(new Integer(3), mutNum.getValue());\n+        try {\n+            mutNum.setValue(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testEquals() {\n+        this.testEquals(new MutableInt(0), new MutableInt(0), new MutableInt(1));\n+        // Should Numbers be supported? GaryG July-21-2005.\n+        //this.testEquals(mutNumA, new Integer(0), mutNumC);\n+    }\n+\n+    /**\n+     * @param numA must not be a 0 Integer; must not equal numC.\n+     * @param numB must equal numA; must not equal numC.\n+     * @param numC must not equal numA; must not equal numC.\n+     */\n+    void testEquals(final Number numA, final Number numB, final Number numC) {\n+        assertEquals(true, numA.equals(numA));\n+        assertEquals(true, numA.equals(numB));\n+        assertEquals(true, numB.equals(numA));\n+        assertEquals(true, numB.equals(numB));\n+        assertEquals(false, numA.equals(numC));\n+        assertEquals(false, numB.equals(numC));\n+        assertEquals(true, numC.equals(numC));\n+        assertEquals(false, numA.equals(null));\n+        assertEquals(false, numA.equals(new Integer(0)));\n+        assertEquals(false, numA.equals(\"0\"));\n+    }\n+\n+    public void testHashCode() {\n+        final MutableInt mutNumA = new MutableInt(0);\n+        final MutableInt mutNumB = new MutableInt(0);\n+        final MutableInt mutNumC = new MutableInt(1);\n+\n+        assertEquals(true, mutNumA.hashCode() == mutNumA.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == mutNumB.hashCode());\n+        assertEquals(false, mutNumA.hashCode() == mutNumC.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == new Integer(0).hashCode());\n+    }\n+\n+    public void testCompareTo() {\n+        final MutableInt mutNum = new MutableInt(0);\n+\n+        assertEquals(0, mutNum.compareTo(new MutableInt(0)));\n+        assertEquals(+1, mutNum.compareTo(new MutableInt(-1)));\n+        assertEquals(-1, mutNum.compareTo(new MutableInt(1)));\n+        try {\n+            mutNum.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testPrimitiveValues() {\n+        MutableInt mutNum = new MutableInt(1);\n+        \n+        assertEquals( (byte) 1, mutNum.byteValue() );\n+        assertEquals( (short) 1, mutNum.shortValue() );\n+        assertEquals( 1.0F, mutNum.floatValue(), 0 );\n+        assertEquals( 1.0, mutNum.doubleValue(), 0 );\n+        assertEquals( 1L, mutNum.longValue() );\n+    }\n+\n+    public void testToInteger() {\n+        assertEquals(new Integer(0), new MutableInt(0).toInteger());\n+        assertEquals(new Integer(123), new MutableInt(123).toInteger());\n+    }\n+\n+    public void testIncrement() {\n+        MutableInt mutNum = new MutableInt(1);\n+        mutNum.increment();\n+        \n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(2L, mutNum.longValue());\n+    }\n+\n+    public void testDecrement() {\n+        MutableInt mutNum = new MutableInt(1);\n+        mutNum.decrement();\n+        \n+        assertEquals(0, mutNum.intValue());\n+        assertEquals(0L, mutNum.longValue());\n+    }\n+\n+    public void testAddValuePrimitive() {\n+        MutableInt mutNum = new MutableInt(1);\n+        mutNum.add(1);\n+        \n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(2L, mutNum.longValue());\n+    }\n+\n+    public void testAddValueObject() {\n+        MutableInt mutNum = new MutableInt(1);\n+        mutNum.add(new Integer(1));\n+        \n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(2L, mutNum.longValue());\n+    }\n+\n+    public void testSubtractValuePrimitive() {\n+        MutableInt mutNum = new MutableInt(1);\n+        mutNum.subtract(1);\n+        \n+        assertEquals(0, mutNum.intValue());\n+        assertEquals(0L, mutNum.longValue());\n+    }\n+\n+    public void testSubtractValueObject() {\n+        MutableInt mutNum = new MutableInt(1);\n+        mutNum.subtract(new Integer(1));\n+        \n+        assertEquals(0, mutNum.intValue());\n+        assertEquals(0L, mutNum.longValue());\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"0\", new MutableInt(0).toString());\n+        assertEquals(\"10\", new MutableInt(10).toString());\n+        assertEquals(\"-123\", new MutableInt(-123).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/mutable/MutableLongTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Id$\n+ * @see MutableLong\n+ */\n+public class MutableLongTest extends TestCase {\n+\n+    public MutableLongTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(MutableLongTest.class);\n+    }\n+\n+    // ----------------------------------------------------------------\n+    public void testConstructors() {\n+        assertEquals(0, new MutableLong().longValue());\n+        \n+        assertEquals(1, new MutableLong(1).longValue());\n+        \n+        assertEquals(2, new MutableLong(new Long(2)).longValue());\n+        assertEquals(3, new MutableLong(new MutableLong(3)).longValue());\n+\n+        assertEquals(2, new MutableLong(\"2\").longValue());\n+\n+        try {\n+            new MutableLong((Number)null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testGetSet() {\n+        final MutableLong mutNum = new MutableLong(0);\n+        assertEquals(0, new MutableLong().longValue());\n+        assertEquals(new Long(0), new MutableLong().getValue());\n+        \n+        mutNum.setValue(1);\n+        assertEquals(1, mutNum.longValue());\n+        assertEquals(new Long(1), mutNum.getValue());\n+        \n+        mutNum.setValue(new Long(2));\n+        assertEquals(2, mutNum.longValue());\n+        assertEquals(new Long(2), mutNum.getValue());\n+        \n+        mutNum.setValue(new MutableLong(3));\n+        assertEquals(3, mutNum.longValue());\n+        assertEquals(new Long(3), mutNum.getValue());\n+        try {\n+            mutNum.setValue(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testEquals() {\n+        final MutableLong mutNumA = new MutableLong(0);\n+        final MutableLong mutNumB = new MutableLong(0);\n+        final MutableLong mutNumC = new MutableLong(1);\n+\n+        assertEquals(true, mutNumA.equals(mutNumA));\n+        assertEquals(true, mutNumA.equals(mutNumB));\n+        assertEquals(true, mutNumB.equals(mutNumA));\n+        assertEquals(true, mutNumB.equals(mutNumB));\n+        assertEquals(false, mutNumA.equals(mutNumC));\n+        assertEquals(false, mutNumB.equals(mutNumC));\n+        assertEquals(true, mutNumC.equals(mutNumC));\n+        assertEquals(false, mutNumA.equals(null));\n+        assertEquals(false, mutNumA.equals(new Long(0)));\n+        assertEquals(false, mutNumA.equals(\"0\"));\n+    }\n+\n+    public void testHashCode() {\n+        final MutableLong mutNumA = new MutableLong(0);\n+        final MutableLong mutNumB = new MutableLong(0);\n+        final MutableLong mutNumC = new MutableLong(1);\n+\n+        assertEquals(true, mutNumA.hashCode() == mutNumA.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == mutNumB.hashCode());\n+        assertEquals(false, mutNumA.hashCode() == mutNumC.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == new Long(0).hashCode());\n+    }\n+\n+    public void testCompareTo() {\n+        final MutableLong mutNum = new MutableLong(0);\n+\n+        assertEquals(0, mutNum.compareTo(new MutableLong(0)));\n+        assertEquals(+1, mutNum.compareTo(new MutableLong(-1)));\n+        assertEquals(-1, mutNum.compareTo(new MutableLong(1)));\n+        try {\n+            mutNum.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testPrimitiveValues() {\n+        MutableLong mutNum = new MutableLong(1L);\n+\n+        assertEquals( 1.0F, mutNum.floatValue(), 0 );\n+        assertEquals( 1.0, mutNum.doubleValue(), 0 );\n+        assertEquals( (byte) 1, mutNum.byteValue() );\n+        assertEquals( (short) 1, mutNum.shortValue() );\n+        assertEquals( 1, mutNum.intValue() );\n+        assertEquals( 1L, mutNum.longValue() );\n+    }\n+\n+    public void testToLong() {\n+        assertEquals(new Long(0L), new MutableLong(0L).toLong());\n+        assertEquals(new Long(123L), new MutableLong(123L).toLong());\n+    }\n+\n+    public void testIncrement() {\n+        MutableLong mutNum = new MutableLong(1);\n+        mutNum.increment();\n+        \n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(2L, mutNum.longValue());\n+    }\n+\n+    public void testDecrement() {\n+        MutableLong mutNum = new MutableLong(1);\n+        mutNum.decrement();\n+        \n+        assertEquals(0, mutNum.intValue());\n+        assertEquals(0L, mutNum.longValue());\n+    }\n+\n+    public void testAddValuePrimitive() {\n+        MutableLong mutNum = new MutableLong(1);\n+        mutNum.add(1);\n+        \n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(2L, mutNum.longValue());\n+    }\n+\n+    public void testAddValueObject() {\n+        MutableLong mutNum = new MutableLong(1);\n+        mutNum.add(new Long(1));\n+        \n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(2L, mutNum.longValue());\n+    }\n+\n+    public void testSubtractValuePrimitive() {\n+        MutableLong mutNum = new MutableLong(1);\n+        mutNum.subtract(1);\n+        \n+        assertEquals(0, mutNum.intValue());\n+        assertEquals(0L, mutNum.longValue());\n+    }\n+\n+    public void testSubtractValueObject() {\n+        MutableLong mutNum = new MutableLong(1);\n+        mutNum.subtract(new Long(1));\n+        \n+        assertEquals(0, mutNum.intValue());\n+        assertEquals(0L, mutNum.longValue());\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"0\", new MutableLong(0).toString());\n+        assertEquals(\"10\", new MutableLong(10).toString());\n+        assertEquals(\"-123\", new MutableLong(-123).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/mutable/MutableObjectTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Id$\n+ * @see MutableShort\n+ */\n+public class MutableObjectTest extends TestCase {\n+\n+    public MutableObjectTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(MutableObjectTest.class);\n+    }\n+\n+    // ----------------------------------------------------------------\n+    public void testConstructors() {\n+        assertEquals(null, new MutableObject<String>().getValue());\n+        \n+        Integer i = new Integer(6);\n+        assertSame(i, new MutableObject<Integer>(i).getValue());\n+        assertSame(\"HI\", new MutableObject<String>(\"HI\").getValue());\n+        assertSame(null, new MutableObject<Object>(null).getValue());\n+    }\n+\n+    public void testGetSet() {\n+        final MutableObject<String> mutNum = new MutableObject<String>();\n+        assertEquals(null, new MutableObject<Object>().getValue());\n+        \n+        mutNum.setValue(\"HELLO\");\n+        assertSame(\"HELLO\", mutNum.getValue());\n+        \n+        mutNum.setValue(null);\n+        assertSame(null, mutNum.getValue());\n+    }\n+\n+    public void testEquals() {\n+        final MutableObject<String> mutNumA = new MutableObject<String>(\"ALPHA\");\n+        final MutableObject<String> mutNumB = new MutableObject<String>(\"ALPHA\");\n+        final MutableObject<String> mutNumC = new MutableObject<String>(\"BETA\");\n+        final MutableObject<String> mutNumD = new MutableObject<String>(null);\n+\n+        assertEquals(true, mutNumA.equals(mutNumA));\n+        assertEquals(true, mutNumA.equals(mutNumB));\n+        assertEquals(true, mutNumB.equals(mutNumA));\n+        assertEquals(true, mutNumB.equals(mutNumB));\n+        assertEquals(false, mutNumA.equals(mutNumC));\n+        assertEquals(false, mutNumB.equals(mutNumC));\n+        assertEquals(true, mutNumC.equals(mutNumC));\n+        assertEquals(false, mutNumA.equals(mutNumD));\n+        assertEquals(true, mutNumD.equals(mutNumD));\n+        \n+        assertEquals(false, mutNumA.equals(null));\n+        assertEquals(false, mutNumA.equals(new Object()));\n+        assertEquals(false, mutNumA.equals(\"0\"));\n+    }\n+\n+    public void testHashCode() {\n+        final MutableObject<String> mutNumA = new MutableObject<String>(\"ALPHA\");\n+        final MutableObject<String> mutNumB = new MutableObject<String>(\"ALPHA\");\n+        final MutableObject<String> mutNumC = new MutableObject<String>(\"BETA\");\n+        final MutableObject<String> mutNumD = new MutableObject<String>(null);\n+\n+        assertEquals(true, mutNumA.hashCode() == mutNumA.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == mutNumB.hashCode());\n+        assertEquals(false, mutNumA.hashCode() == mutNumC.hashCode());\n+        assertEquals(false, mutNumA.hashCode() == mutNumD.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == \"ALPHA\".hashCode());\n+        assertEquals(0, mutNumD.hashCode());\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"HI\", new MutableObject<String>(\"HI\").toString());\n+        assertEquals(\"10.0\", new MutableObject<Double>(new Double(10)).toString());\n+        assertEquals(\"null\", new MutableObject<Object>(null).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/mutable/MutableShortTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Id$\n+ * @see MutableShort\n+ */\n+public class MutableShortTest extends TestCase {\n+\n+    public MutableShortTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(MutableShortTest.class);\n+    }\n+\n+    // ----------------------------------------------------------------\n+    public void testConstructors() {\n+        assertEquals((short) 0, new MutableShort().shortValue());\n+        \n+        assertEquals((short) 1, new MutableShort((short) 1).shortValue());\n+        \n+        assertEquals((short) 2, new MutableShort(new Short((short) 2)).shortValue());\n+        assertEquals((short) 3, new MutableShort(new MutableShort((short) 3)).shortValue());\n+\n+        assertEquals((short) 2, new MutableShort(\"2\").shortValue());\n+\n+        try {\n+            new MutableShort((Number)null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testGetSet() {\n+        final MutableShort mutNum = new MutableShort((short) 0);\n+        assertEquals((short) 0, new MutableShort().shortValue());\n+        assertEquals(new Short((short) 0), new MutableShort().getValue());\n+        \n+        mutNum.setValue((short) 1);\n+        assertEquals((short) 1, mutNum.shortValue());\n+        assertEquals(new Short((short) 1), mutNum.getValue());\n+        \n+        mutNum.setValue(new Short((short) 2));\n+        assertEquals((short) 2, mutNum.shortValue());\n+        assertEquals(new Short((short) 2), mutNum.getValue());\n+        \n+        mutNum.setValue(new MutableShort((short) 3));\n+        assertEquals((short) 3, mutNum.shortValue());\n+        assertEquals(new Short((short) 3), mutNum.getValue());\n+        try {\n+            mutNum.setValue(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testEquals() {\n+        final MutableShort mutNumA = new MutableShort((short) 0);\n+        final MutableShort mutNumB = new MutableShort((short) 0);\n+        final MutableShort mutNumC = new MutableShort((short) 1);\n+\n+        assertEquals(true, mutNumA.equals(mutNumA));\n+        assertEquals(true, mutNumA.equals(mutNumB));\n+        assertEquals(true, mutNumB.equals(mutNumA));\n+        assertEquals(true, mutNumB.equals(mutNumB));\n+        assertEquals(false, mutNumA.equals(mutNumC));\n+        assertEquals(false, mutNumB.equals(mutNumC));\n+        assertEquals(true, mutNumC.equals(mutNumC));\n+        assertEquals(false, mutNumA.equals(null));\n+        assertEquals(false, mutNumA.equals(new Short((short) 0)));\n+        assertEquals(false, mutNumA.equals(\"0\"));\n+    }\n+\n+    public void testHashCode() {\n+        final MutableShort mutNumA = new MutableShort((short) 0);\n+        final MutableShort mutNumB = new MutableShort((short) 0);\n+        final MutableShort mutNumC = new MutableShort((short) 1);\n+\n+        assertEquals(true, mutNumA.hashCode() == mutNumA.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == mutNumB.hashCode());\n+        assertEquals(false, mutNumA.hashCode() == mutNumC.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == new Short((short) 0).hashCode());\n+    }\n+\n+    public void testCompareTo() {\n+        final MutableShort mutNum = new MutableShort((short) 0);\n+\n+        assertEquals((short) 0, mutNum.compareTo(new MutableShort((short) 0)));\n+        assertEquals((short) +1, mutNum.compareTo(new MutableShort((short) -1)));\n+        assertEquals((short) -1, mutNum.compareTo(new MutableShort((short) 1)));\n+        try {\n+            mutNum.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testPrimitiveValues() {\n+        MutableShort mutNum = new MutableShort( (short) 1 );\n+        \n+        assertEquals( 1.0F, mutNum.floatValue(), 0 );\n+        assertEquals( 1.0, mutNum.doubleValue(), 0 );\n+        assertEquals( (byte) 1, mutNum.byteValue() );\n+        assertEquals( (short) 1, mutNum.shortValue() );\n+        assertEquals( 1, mutNum.intValue() );\n+        assertEquals( 1L, mutNum.longValue() );\n+    }\n+\n+    public void testToShort() {\n+        assertEquals(new Short((short) 0), new MutableShort((short) 0).toShort());\n+        assertEquals(new Short((short) 123), new MutableShort((short) 123).toShort());\n+    }\n+\n+    public void testIncrement() {\n+        MutableShort mutNum = new MutableShort((short) 1);\n+        mutNum.increment();\n+        \n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(2L, mutNum.longValue());\n+    }\n+\n+    public void testDecrement() {\n+        MutableShort mutNum = new MutableShort((short) 1);\n+        mutNum.decrement();\n+        \n+        assertEquals(0, mutNum.intValue());\n+        assertEquals(0L, mutNum.longValue());\n+    }\n+\n+    public void testAddValuePrimitive() {\n+        MutableShort mutNum = new MutableShort((short) 1);\n+        mutNum.add((short) 1);\n+        \n+        assertEquals((short) 2, mutNum.shortValue());\n+    }\n+\n+    public void testAddValueObject() {\n+        MutableShort mutNum = new MutableShort((short) 1);\n+        mutNum.add(new Short((short) 1));\n+        \n+        assertEquals((short) 2, mutNum.shortValue());\n+    }\n+\n+    public void testSubtractValuePrimitive() {\n+        MutableShort mutNum = new MutableShort((short) 1);\n+        mutNum.subtract((short) 1);\n+        \n+        assertEquals((short) 0, mutNum.shortValue());\n+    }\n+\n+    public void testSubtractValueObject() {\n+        MutableShort mutNum = new MutableShort((short) 1);\n+        mutNum.subtract(new Short((short) 1));\n+        \n+        assertEquals((short) 0, mutNum.shortValue());\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"0\", new MutableShort((short) 0).toString());\n+        assertEquals(\"10\", new MutableShort((short) 10).toString());\n+        assertEquals(\"-123\", new MutableShort((short) -123).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/reflect/ConstructorUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import java.lang.reflect.Constructor;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.math.NumberUtils;\n+\n+/**\n+ * Unit tests ConstructorUtils\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public class ConstructorUtilsTest extends TestCase {\n+    public static class TestBean {\n+        private String toString;\n+\n+        public TestBean() {\n+            toString = \"()\";\n+        }\n+\n+        public TestBean(int i) {\n+            toString = \"(int)\";\n+        }\n+\n+        public TestBean(Integer i) {\n+            toString = \"(Integer)\";\n+        }\n+\n+        public TestBean(double d) {\n+            toString = \"(double)\";\n+        }\n+\n+        public TestBean(String s) {\n+            toString = \"(String)\";\n+        }\n+\n+        public TestBean(Object o) {\n+            toString = \"(Object)\";\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return toString;\n+        }\n+    }\n+\n+    private static class PrivateClass {\n+        @SuppressWarnings(\"unused\")\n+        public PrivateClass() {\n+        }\n+    }\n+\n+    private Map<Class<?>, Class<?>[]> classCache;\n+\n+    public ConstructorUtilsTest(String name) {\n+        super(name);\n+        classCache = new HashMap<Class<?>, Class<?>[]>();\n+    }\n+\n+    /**\n+     * Run the test cases as a suite.\n+     * @return the Test\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ConstructorUtilsTest.class);\n+        suite.setName(\"ConstructorUtils Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        classCache.clear();\n+    }\n+\n+    public void testConstructor() throws Exception {\n+        assertNotNull(MethodUtils.class.newInstance());\n+    }\n+\n+    public void testInvokeConstructor() throws Exception {\n+        assertEquals(\"()\", ConstructorUtils.invokeConstructor(TestBean.class,\n+                ArrayUtils.EMPTY_CLASS_ARRAY).toString());\n+        assertEquals(\"()\", ConstructorUtils.invokeConstructor(TestBean.class,\n+                (Class[]) null).toString());\n+        assertEquals(\"(String)\", ConstructorUtils.invokeConstructor(\n+                TestBean.class, \"\").toString());\n+        assertEquals(\"(Object)\", ConstructorUtils.invokeConstructor(\n+                TestBean.class, new Object()).toString());\n+        assertEquals(\"(Object)\", ConstructorUtils.invokeConstructor(\n+                TestBean.class, Boolean.TRUE).toString());\n+        assertEquals(\"(Integer)\", ConstructorUtils.invokeConstructor(\n+                TestBean.class, NumberUtils.INTEGER_ONE).toString());\n+        assertEquals(\"(int)\", ConstructorUtils.invokeConstructor(\n+                TestBean.class, NumberUtils.BYTE_ONE).toString());\n+        assertEquals(\"(double)\", ConstructorUtils.invokeConstructor(\n+                TestBean.class, NumberUtils.LONG_ONE).toString());\n+        assertEquals(\"(double)\", ConstructorUtils.invokeConstructor(\n+                TestBean.class, NumberUtils.DOUBLE_ONE).toString());\n+    }\n+\n+    public void testInvokeExactConstructor() throws Exception {\n+        assertEquals(\"()\", ConstructorUtils.invokeExactConstructor(\n+                TestBean.class, ArrayUtils.EMPTY_CLASS_ARRAY).toString());\n+        assertEquals(\"()\", ConstructorUtils.invokeExactConstructor(\n+                TestBean.class, (Class[]) null).toString());\n+        assertEquals(\"(String)\", ConstructorUtils.invokeExactConstructor(\n+                TestBean.class, \"\").toString());\n+        assertEquals(\"(Object)\", ConstructorUtils.invokeExactConstructor(\n+                TestBean.class, new Object()).toString());\n+        assertEquals(\"(Integer)\", ConstructorUtils.invokeExactConstructor(\n+                TestBean.class, NumberUtils.INTEGER_ONE).toString());\n+        assertEquals(\"(double)\", ConstructorUtils.invokeExactConstructor(\n+                TestBean.class, new Object[] { NumberUtils.DOUBLE_ONE },\n+                new Class[] { Double.TYPE }).toString());\n+\n+        try {\n+            ConstructorUtils.invokeExactConstructor(TestBean.class,\n+                    NumberUtils.BYTE_ONE);\n+            fail(\"should throw NoSuchMethodException\");\n+        } catch (NoSuchMethodException e) {\n+        }\n+        try {\n+            ConstructorUtils.invokeExactConstructor(TestBean.class,\n+                    NumberUtils.LONG_ONE);\n+            fail(\"should throw NoSuchMethodException\");\n+        } catch (NoSuchMethodException e) {\n+        }\n+        try {\n+            ConstructorUtils.invokeExactConstructor(TestBean.class,\n+                    Boolean.TRUE);\n+            fail(\"should throw NoSuchMethodException\");\n+        } catch (NoSuchMethodException e) {\n+        }\n+    }\n+\n+    public void testGetAccessibleConstructor() throws Exception {\n+        assertNotNull(ConstructorUtils.getAccessibleConstructor(Object.class\n+                .getConstructor(ArrayUtils.EMPTY_CLASS_ARRAY)));\n+        assertNull(ConstructorUtils.getAccessibleConstructor(PrivateClass.class\n+                .getConstructor(ArrayUtils.EMPTY_CLASS_ARRAY)));\n+    }\n+\n+    public void testGetAccessibleConstructorFromDescription() throws Exception {\n+        assertNotNull(ConstructorUtils.getAccessibleConstructor(Object.class,\n+                ArrayUtils.EMPTY_CLASS_ARRAY));\n+        assertNull(ConstructorUtils.getAccessibleConstructor(\n+                PrivateClass.class, ArrayUtils.EMPTY_CLASS_ARRAY));\n+    }\n+\n+    public void testGetMatchingAccessibleMethod() throws Exception {\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY);\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class, null,\n+                ArrayUtils.EMPTY_CLASS_ARRAY);\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(String.class), singletonArray(String.class));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Object.class), singletonArray(Object.class));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Boolean.class), singletonArray(Object.class));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Byte.class), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Byte.TYPE), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Short.class), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Short.TYPE), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Character.class), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Character.TYPE), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Integer.class), singletonArray(Integer.class));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Integer.TYPE), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Long.class), singletonArray(Double.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Long.TYPE), singletonArray(Double.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Float.class), singletonArray(Double.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Float.TYPE), singletonArray(Double.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Double.class), singletonArray(Double.TYPE));\n+        expectMatchingAccessibleConstructorParameterTypes(TestBean.class,\n+                singletonArray(Double.TYPE), singletonArray(Double.TYPE));\n+    }\n+\n+    private void expectMatchingAccessibleConstructorParameterTypes(Class<?> cls,\n+            Class<?>[] requestTypes, Class<?>[] actualTypes) {\n+        Constructor<?> c = ConstructorUtils.getMatchingAccessibleConstructor(cls,\n+                requestTypes);\n+        assertTrue(toString(c.getParameterTypes()) + \" not equals \"\n+                + toString(actualTypes), Arrays.equals(actualTypes, c\n+                .getParameterTypes()));\n+    }\n+\n+    private String toString(Class<?>[] c) {\n+        return Arrays.asList(c).toString();\n+    }\n+\n+    private Class<?>[] singletonArray(Class<?> c) {\n+        Class<?>[] result = classCache.get(c);\n+        if (result == null) {\n+            result = new Class[] { c };\n+            classCache.put(c, result);\n+        }\n+        return result;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/reflect/FieldUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import java.lang.reflect.Field;\n+\n+import org.apache.commons.lang.reflect.testbed.Ambig;\n+import org.apache.commons.lang.reflect.testbed.Foo;\n+import org.apache.commons.lang.reflect.testbed.PrivatelyShadowedChild;\n+import org.apache.commons.lang.reflect.testbed.PublicChild;\n+import org.apache.commons.lang.reflect.testbed.PubliclyShadowedChild;\n+import org.apache.commons.lang.reflect.testbed.StaticContainer;\n+import org.apache.commons.lang.reflect.testbed.StaticContainerChild;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Unit tests FieldUtils\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public class FieldUtilsTest extends TestCase {\n+\n+    static final String S = \"s\";\n+    static final String SS = \"ss\";\n+    static final Integer I0 = new Integer(0);\n+    static final Integer I1 = new Integer(1);\n+    static final Double D0 = new Double(0.0);\n+    static final Double D1 = new Double(1.0);\n+\n+    private PublicChild publicChild;\n+    private PubliclyShadowedChild publiclyShadowedChild;\n+    private PrivatelyShadowedChild privatelyShadowedChild;\n+    private Class<?> parentClass = PublicChild.class.getSuperclass();\n+\n+    /**\n+     * Run the test cases as a suite.\n+     * @return the Test\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(FieldUtilsTest.class);\n+        suite.setName(\"FieldUtils Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        StaticContainer.reset();\n+        publicChild = new PublicChild();\n+        publiclyShadowedChild = new PubliclyShadowedChild();\n+        privatelyShadowedChild = new PrivatelyShadowedChild();\n+    }\n+\n+    public void testGetField() {\n+        assertEquals(Foo.class, FieldUtils.getField(PublicChild.class, \"VALUE\").getDeclaringClass());\n+        assertEquals(parentClass, FieldUtils.getField(PublicChild.class, \"s\").getDeclaringClass());\n+        assertNull(FieldUtils.getField(PublicChild.class, \"b\"));\n+        assertNull(FieldUtils.getField(PublicChild.class, \"i\"));\n+        assertNull(FieldUtils.getField(PublicChild.class, \"d\"));\n+        assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, \"VALUE\").getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"s\")\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"b\")\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"i\")\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"d\")\n+                .getDeclaringClass());\n+        assertEquals(Foo.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"VALUE\").getDeclaringClass());\n+        assertEquals(parentClass, FieldUtils.getField(PrivatelyShadowedChild.class, \"s\").getDeclaringClass());\n+        assertNull(FieldUtils.getField(PrivatelyShadowedChild.class, \"b\"));\n+        assertNull(FieldUtils.getField(PrivatelyShadowedChild.class, \"i\"));\n+        assertNull(FieldUtils.getField(PrivatelyShadowedChild.class, \"d\"));\n+    }\n+\n+    public void testGetFieldForceAccess() {\n+        assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, \"VALUE\", true).getDeclaringClass());\n+        assertEquals(parentClass, FieldUtils.getField(PublicChild.class, \"s\", true).getDeclaringClass());\n+        assertEquals(parentClass, FieldUtils.getField(PublicChild.class, \"b\", true).getDeclaringClass());\n+        assertEquals(parentClass, FieldUtils.getField(PublicChild.class, \"i\", true).getDeclaringClass());\n+        assertEquals(parentClass, FieldUtils.getField(PublicChild.class, \"d\", true).getDeclaringClass());\n+        assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, \"VALUE\", true).getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"s\", true)\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"b\", true)\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"i\", true)\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"d\", true)\n+                .getDeclaringClass());\n+        assertEquals(Foo.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"VALUE\", true).getDeclaringClass());\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"s\", true)\n+                .getDeclaringClass());\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"b\", true)\n+                .getDeclaringClass());\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"i\", true)\n+                .getDeclaringClass());\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"d\", true)\n+                .getDeclaringClass());\n+    }\n+\n+    public void testGetDeclaredField() {\n+        assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"VALUE\"));\n+        assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"s\"));\n+        assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"b\"));\n+        assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"i\"));\n+        assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"d\"));\n+        assertNull(FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"VALUE\"));\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"s\")\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"b\")\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"i\")\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"d\")\n+                .getDeclaringClass());\n+        assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"VALUE\"));\n+        assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"s\"));\n+        assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"b\"));\n+        assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"i\"));\n+        assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"d\"));\n+    }\n+\n+    public void testGetDeclaredFieldForceAccess() {\n+        assertEquals(PublicChild.class, FieldUtils.getDeclaredField(PublicChild.class, \"VALUE\", true)\n+                .getDeclaringClass());\n+        assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"s\", true));\n+        assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"b\", true));\n+        assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"i\", true));\n+        assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"d\", true));\n+        assertNull(FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"VALUE\", true));\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"s\", true)\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"b\", true)\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"i\", true)\n+                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"d\", true)\n+                .getDeclaringClass());\n+        assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"VALUE\", true));\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"s\", true)\n+                .getDeclaringClass());\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"b\", true)\n+                .getDeclaringClass());\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"i\", true)\n+                .getDeclaringClass());\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"d\", true)\n+                .getDeclaringClass());\n+    }\n+\n+    public void testReadStaticField() throws Exception {\n+        assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, \"VALUE\")));\n+    }\n+\n+    public void testReadStaticFieldForceAccess() throws Exception {\n+        assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, \"VALUE\")));\n+        assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(PublicChild.class, \"VALUE\")));\n+    }\n+\n+    public void testReadNamedStaticField() throws Exception {\n+        assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, \"VALUE\"));\n+        assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, \"VALUE\"));\n+        assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, \"VALUE\"));\n+        assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, \"VALUE\"));\n+    }\n+\n+    public void testReadNamedStaticFieldForceAccess() throws Exception {\n+        assertEquals(Foo.VALUE, FieldUtils.readStaticField(Foo.class, \"VALUE\", true));\n+        assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, \"VALUE\", true));\n+        assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, \"VALUE\", true));\n+        assertEquals(\"child\", FieldUtils.readStaticField(PublicChild.class, \"VALUE\", true));\n+    }\n+\n+    public void testReadDeclaredNamedStaticField() throws Exception {\n+        assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(Foo.class, \"VALUE\"));\n+        try {\n+            assertEquals(\"child\", FieldUtils.readDeclaredStaticField(PublicChild.class, \"VALUE\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PubliclyShadowedChild.class, \"VALUE\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PrivatelyShadowedChild.class, \"VALUE\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testReadDeclaredNamedStaticFieldForceAccess() throws Exception {\n+        assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(Foo.class, \"VALUE\", true));\n+        assertEquals(\"child\", FieldUtils.readDeclaredStaticField(PublicChild.class, \"VALUE\", true));\n+        try {\n+            assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PubliclyShadowedChild.class, \"VALUE\", true));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PrivatelyShadowedChild.class, \"VALUE\", true));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testReadField() throws Exception {\n+        Field parentS = FieldUtils.getDeclaredField(parentClass, \"s\");\n+        assertEquals(\"s\", FieldUtils.readField(parentS, publicChild));\n+        assertEquals(\"s\", FieldUtils.readField(parentS, publiclyShadowedChild));\n+        assertEquals(\"s\", FieldUtils.readField(parentS, privatelyShadowedChild));\n+        Field parentB = FieldUtils.getDeclaredField(parentClass, \"b\", true);\n+        assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publicChild));\n+        assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publiclyShadowedChild));\n+        assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, privatelyShadowedChild));\n+        Field parentI = FieldUtils.getDeclaredField(parentClass, \"i\", true);\n+        assertEquals(I0, FieldUtils.readField(parentI, publicChild));\n+        assertEquals(I0, FieldUtils.readField(parentI, publiclyShadowedChild));\n+        assertEquals(I0, FieldUtils.readField(parentI, privatelyShadowedChild));\n+        Field parentD = FieldUtils.getDeclaredField(parentClass, \"d\", true);\n+        assertEquals(D0, FieldUtils.readField(parentD, publicChild));\n+        assertEquals(D0, FieldUtils.readField(parentD, publiclyShadowedChild));\n+        assertEquals(D0, FieldUtils.readField(parentD, privatelyShadowedChild));\n+    }\n+\n+    public void testReadFieldForceAccess() throws Exception {\n+        Field parentS = FieldUtils.getDeclaredField(parentClass, \"s\");\n+        parentS.setAccessible(false);\n+        assertEquals(\"s\", FieldUtils.readField(parentS, publicChild, true));\n+        assertEquals(\"s\", FieldUtils.readField(parentS, publiclyShadowedChild, true));\n+        assertEquals(\"s\", FieldUtils.readField(parentS, privatelyShadowedChild, true));\n+        Field parentB = FieldUtils.getDeclaredField(parentClass, \"b\", true);\n+        parentB.setAccessible(false);\n+        assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publicChild, true));\n+        assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publiclyShadowedChild, true));\n+        assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, privatelyShadowedChild, true));\n+        Field parentI = FieldUtils.getDeclaredField(parentClass, \"i\", true);\n+        parentI.setAccessible(false);\n+        assertEquals(I0, FieldUtils.readField(parentI, publicChild, true));\n+        assertEquals(I0, FieldUtils.readField(parentI, publiclyShadowedChild, true));\n+        assertEquals(I0, FieldUtils.readField(parentI, privatelyShadowedChild, true));\n+        Field parentD = FieldUtils.getDeclaredField(parentClass, \"d\", true);\n+        parentD.setAccessible(false);\n+        assertEquals(D0, FieldUtils.readField(parentD, publicChild, true));\n+        assertEquals(D0, FieldUtils.readField(parentD, publiclyShadowedChild, true));\n+        assertEquals(D0, FieldUtils.readField(parentD, privatelyShadowedChild, true));\n+    }\n+\n+    public void testReadNamedField() throws Exception {\n+        assertEquals(\"s\", FieldUtils.readField(publicChild, \"s\"));\n+        assertEquals(\"ss\", FieldUtils.readField(publiclyShadowedChild, \"s\"));\n+        assertEquals(\"s\", FieldUtils.readField(privatelyShadowedChild, \"s\"));\n+        try {\n+            assertEquals(Boolean.FALSE, FieldUtils.readField(publicChild, \"b\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(Boolean.TRUE, FieldUtils.readField(publiclyShadowedChild, \"b\"));\n+        try {\n+            assertEquals(Boolean.FALSE, FieldUtils.readField(privatelyShadowedChild, \"b\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            assertEquals(I0, FieldUtils.readField(publicChild, \"i\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(I1, FieldUtils.readField(publiclyShadowedChild, \"i\"));\n+        try {\n+            assertEquals(I0, FieldUtils.readField(privatelyShadowedChild, \"i\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            assertEquals(D0, FieldUtils.readField(publicChild, \"d\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(D1, FieldUtils.readField(publiclyShadowedChild, \"d\"));\n+        try {\n+            assertEquals(D0, FieldUtils.readField(privatelyShadowedChild, \"d\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testReadNamedFieldForceAccess() throws Exception {\n+        assertEquals(\"s\", FieldUtils.readField(publicChild, \"s\", true));\n+        assertEquals(\"ss\", FieldUtils.readField(publiclyShadowedChild, \"s\", true));\n+        assertEquals(\"ss\", FieldUtils.readField(privatelyShadowedChild, \"s\", true));\n+        assertEquals(Boolean.FALSE, FieldUtils.readField(publicChild, \"b\", true));\n+        assertEquals(Boolean.TRUE, FieldUtils.readField(publiclyShadowedChild, \"b\", true));\n+        assertEquals(Boolean.TRUE, FieldUtils.readField(privatelyShadowedChild, \"b\", true));\n+        assertEquals(I0, FieldUtils.readField(publicChild, \"i\", true));\n+        assertEquals(I1, FieldUtils.readField(publiclyShadowedChild, \"i\", true));\n+        assertEquals(I1, FieldUtils.readField(privatelyShadowedChild, \"i\", true));\n+        assertEquals(D0, FieldUtils.readField(publicChild, \"d\", true));\n+        assertEquals(D1, FieldUtils.readField(publiclyShadowedChild, \"d\", true));\n+        assertEquals(D1, FieldUtils.readField(privatelyShadowedChild, \"d\", true));\n+    }\n+\n+    public void testReadDeclaredNamedField() throws Exception {\n+        try {\n+            assertEquals(\"s\", FieldUtils.readDeclaredField(publicChild, \"s\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(\"ss\", FieldUtils.readDeclaredField(publiclyShadowedChild, \"s\"));\n+        try {\n+            assertEquals(\"s\", FieldUtils.readDeclaredField(privatelyShadowedChild, \"s\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publicChild, \"b\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(publiclyShadowedChild, \"b\"));\n+        try {\n+            assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(privatelyShadowedChild, \"b\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            assertEquals(I0, FieldUtils.readDeclaredField(publicChild, \"i\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(I1, FieldUtils.readDeclaredField(publiclyShadowedChild, \"i\"));\n+        try {\n+            assertEquals(I0, FieldUtils.readDeclaredField(privatelyShadowedChild, \"i\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            assertEquals(D0, FieldUtils.readDeclaredField(publicChild, \"d\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(D1, FieldUtils.readDeclaredField(publiclyShadowedChild, \"d\"));\n+        try {\n+            assertEquals(D0, FieldUtils.readDeclaredField(privatelyShadowedChild, \"d\"));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testReadDeclaredNamedFieldForceAccess() throws Exception {\n+        try {\n+            assertEquals(\"s\", FieldUtils.readDeclaredField(publicChild, \"s\", true));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(\"ss\", FieldUtils.readDeclaredField(publiclyShadowedChild, \"s\", true));\n+        assertEquals(\"ss\", FieldUtils.readDeclaredField(privatelyShadowedChild, \"s\", true));\n+        try {\n+            assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publicChild, \"b\", true));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(publiclyShadowedChild, \"b\", true));\n+        assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(privatelyShadowedChild, \"b\", true));\n+        try {\n+            assertEquals(I0, FieldUtils.readDeclaredField(publicChild, \"i\", true));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(I1, FieldUtils.readDeclaredField(publiclyShadowedChild, \"i\", true));\n+        assertEquals(I1, FieldUtils.readDeclaredField(privatelyShadowedChild, \"i\", true));\n+        try {\n+            assertEquals(D0, FieldUtils.readDeclaredField(publicChild, \"d\", true));\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        assertEquals(D1, FieldUtils.readDeclaredField(publiclyShadowedChild, \"d\", true));\n+        assertEquals(D1, FieldUtils.readDeclaredField(privatelyShadowedChild, \"d\", true));\n+    }\n+\n+    public void testWriteStaticField() throws Exception {\n+        Field field = StaticContainer.class.getDeclaredField(\"mutablePublic\");\n+        FieldUtils.writeStaticField(field, \"new\");\n+        assertEquals(\"new\", StaticContainer.mutablePublic);\n+        field = StaticContainer.class.getDeclaredField(\"mutableProtected\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\");\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = StaticContainer.class.getDeclaredField(\"mutablePackage\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\");\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = StaticContainer.class.getDeclaredField(\"mutablePrivate\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\");\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PUBLIC\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\");\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PROTECTED\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\");\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PACKAGE\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\");\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PRIVATE\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\");\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testWriteStaticFieldForceAccess() throws Exception {\n+        Field field = StaticContainer.class.getDeclaredField(\"mutablePublic\");\n+        FieldUtils.writeStaticField(field, \"new\", true);\n+        assertEquals(\"new\", StaticContainer.mutablePublic);\n+        field = StaticContainer.class.getDeclaredField(\"mutableProtected\");\n+        FieldUtils.writeStaticField(field, \"new\", true);\n+        assertEquals(\"new\", StaticContainer.getMutableProtected());\n+        field = StaticContainer.class.getDeclaredField(\"mutablePackage\");\n+        FieldUtils.writeStaticField(field, \"new\", true);\n+        assertEquals(\"new\", StaticContainer.getMutablePackage());\n+        field = StaticContainer.class.getDeclaredField(\"mutablePrivate\");\n+        FieldUtils.writeStaticField(field, \"new\", true);\n+        assertEquals(\"new\", StaticContainer.getMutablePrivate());\n+        field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PUBLIC\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PROTECTED\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PACKAGE\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PRIVATE\");\n+        try {\n+            FieldUtils.writeStaticField(field, \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testWriteNamedStaticField() throws Exception {\n+        FieldUtils.writeStaticField(StaticContainerChild.class, \"mutablePublic\", \"new\");\n+        assertEquals(\"new\", StaticContainer.mutablePublic);\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"mutableProtected\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"mutablePackage\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"mutablePrivate\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PUBLIC\", \"new\");\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PROTECTED\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PACKAGE\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PRIVATE\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testWriteNamedStaticFieldForceAccess() throws Exception {\n+        FieldUtils.writeStaticField(StaticContainerChild.class, \"mutablePublic\", \"new\", true);\n+        assertEquals(\"new\", StaticContainer.mutablePublic);\n+        FieldUtils.writeStaticField(StaticContainerChild.class, \"mutableProtected\", \"new\", true);\n+        assertEquals(\"new\", StaticContainer.getMutableProtected());\n+        FieldUtils.writeStaticField(StaticContainerChild.class, \"mutablePackage\", \"new\", true);\n+        assertEquals(\"new\", StaticContainer.getMutablePackage());\n+        FieldUtils.writeStaticField(StaticContainerChild.class, \"mutablePrivate\", \"new\", true);\n+        assertEquals(\"new\", StaticContainer.getMutablePrivate());\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PUBLIC\", \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PROTECTED\", \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PACKAGE\", \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PRIVATE\", \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testWriteDeclaredNamedStaticField() throws Exception {\n+        FieldUtils.writeStaticField(StaticContainer.class, \"mutablePublic\", \"new\");\n+        assertEquals(\"new\", StaticContainer.mutablePublic);\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"mutableProtected\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"mutablePackage\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"mutablePrivate\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PUBLIC\", \"new\");\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PROTECTED\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PACKAGE\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PRIVATE\", \"new\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testWriteDeclaredNamedStaticFieldForceAccess() throws Exception {\n+        FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"mutablePublic\", \"new\", true);\n+        assertEquals(\"new\", StaticContainer.mutablePublic);\n+        FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"mutableProtected\", \"new\", true);\n+        assertEquals(\"new\", StaticContainer.getMutableProtected());\n+        FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"mutablePackage\", \"new\", true);\n+        assertEquals(\"new\", StaticContainer.getMutablePackage());\n+        FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"mutablePrivate\", \"new\", true);\n+        assertEquals(\"new\", StaticContainer.getMutablePrivate());\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PUBLIC\", \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PROTECTED\", \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PACKAGE\", \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PRIVATE\", \"new\", true);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testWriteField() throws Exception {\n+        Field field = parentClass.getDeclaredField(\"s\");\n+        FieldUtils.writeField(field, publicChild, \"S\");\n+        assertEquals(\"S\", field.get(publicChild));\n+        field = parentClass.getDeclaredField(\"b\");\n+        try {\n+            FieldUtils.writeField(field, publicChild, Boolean.TRUE);\n+            fail(\"Expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = parentClass.getDeclaredField(\"i\");\n+        try {\n+            FieldUtils.writeField(field, publicChild, new Integer(Integer.MAX_VALUE));\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+        field = parentClass.getDeclaredField(\"d\");\n+        try {\n+            FieldUtils.writeField(field, publicChild, new Double(Double.MAX_VALUE));\n+        } catch (IllegalAccessException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testWriteFieldForceAccess() throws Exception {\n+        Field field = parentClass.getDeclaredField(\"s\");\n+        FieldUtils.writeField(field, publicChild, \"S\", true);\n+        assertEquals(\"S\", field.get(publicChild));\n+        field = parentClass.getDeclaredField(\"b\");\n+        FieldUtils.writeField(field, publicChild, Boolean.TRUE, true);\n+        assertEquals(Boolean.TRUE, field.get(publicChild));\n+        field = parentClass.getDeclaredField(\"i\");\n+        FieldUtils.writeField(field, publicChild, new Integer(Integer.MAX_VALUE), true);\n+        assertEquals(new Integer(Integer.MAX_VALUE), field.get(publicChild));\n+        field = parentClass.getDeclaredField(\"d\");\n+        FieldUtils.writeField(field, publicChild, new Double(Double.MAX_VALUE), true);\n+        assertEquals(new Double(Double.MAX_VALUE), field.get(publicChild));\n+    }\n+\n+    public void testWriteNamedField() throws Exception {\n+        FieldUtils.writeField(publicChild, \"s\", \"S\");\n+        assertEquals(\"S\", FieldUtils.readField(publicChild, \"s\"));\n+        try {\n+            FieldUtils.writeField(publicChild, \"b\", Boolean.TRUE);\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeField(publicChild, \"i\", new Integer(1));\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeField(publicChild, \"d\", new Double(1.0));\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+\n+        FieldUtils.writeField(publiclyShadowedChild, \"s\", \"S\");\n+        assertEquals(\"S\", FieldUtils.readField(publiclyShadowedChild, \"s\"));\n+        FieldUtils.writeField(publiclyShadowedChild, \"b\", Boolean.FALSE);\n+        assertEquals(Boolean.FALSE, FieldUtils.readField(publiclyShadowedChild, \"b\"));\n+        FieldUtils.writeField(publiclyShadowedChild, \"i\", new Integer(0));\n+        assertEquals(new Integer(0), FieldUtils.readField(publiclyShadowedChild, \"i\"));\n+        FieldUtils.writeField(publiclyShadowedChild, \"d\", new Double(0.0));\n+        assertEquals(new Double(0.0), FieldUtils.readField(publiclyShadowedChild, \"d\"));\n+\n+        FieldUtils.writeField(privatelyShadowedChild, \"s\", \"S\");\n+        assertEquals(\"S\", FieldUtils.readField(privatelyShadowedChild, \"s\"));\n+        try {\n+            FieldUtils.writeField(privatelyShadowedChild, \"b\", Boolean.TRUE);\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeField(privatelyShadowedChild, \"i\", new Integer(1));\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeField(privatelyShadowedChild, \"d\", new Double(1.0));\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testWriteNamedFieldForceAccess() throws Exception {\n+        FieldUtils.writeField(publicChild, \"s\", \"S\", true);\n+        assertEquals(\"S\", FieldUtils.readField(publicChild, \"s\", true));\n+        FieldUtils.writeField(publicChild, \"b\", Boolean.TRUE, true);\n+        assertEquals(Boolean.TRUE, FieldUtils.readField(publicChild, \"b\", true));\n+        FieldUtils.writeField(publicChild, \"i\", new Integer(1), true);\n+        assertEquals(new Integer(1), FieldUtils.readField(publicChild, \"i\", true));\n+        FieldUtils.writeField(publicChild, \"d\", new Double(1.0), true);\n+        assertEquals(new Double(1.0), FieldUtils.readField(publicChild, \"d\", true));\n+\n+        FieldUtils.writeField(publiclyShadowedChild, \"s\", \"S\", true);\n+        assertEquals(\"S\", FieldUtils.readField(publiclyShadowedChild, \"s\", true));\n+        FieldUtils.writeField(publiclyShadowedChild, \"b\", Boolean.FALSE, true);\n+        assertEquals(Boolean.FALSE, FieldUtils.readField(publiclyShadowedChild, \"b\", true));\n+        FieldUtils.writeField(publiclyShadowedChild, \"i\", new Integer(0), true);\n+        assertEquals(new Integer(0), FieldUtils.readField(publiclyShadowedChild, \"i\", true));\n+        FieldUtils.writeField(publiclyShadowedChild, \"d\", new Double(0.0), true);\n+        assertEquals(new Double(0.0), FieldUtils.readField(publiclyShadowedChild, \"d\", true));\n+\n+        FieldUtils.writeField(privatelyShadowedChild, \"s\", \"S\", true);\n+        assertEquals(\"S\", FieldUtils.readField(privatelyShadowedChild, \"s\", true));\n+        FieldUtils.writeField(privatelyShadowedChild, \"b\", Boolean.FALSE, true);\n+        assertEquals(Boolean.FALSE, FieldUtils.readField(privatelyShadowedChild, \"b\", true));\n+        FieldUtils.writeField(privatelyShadowedChild, \"i\", new Integer(0), true);\n+        assertEquals(new Integer(0), FieldUtils.readField(privatelyShadowedChild, \"i\", true));\n+        FieldUtils.writeField(privatelyShadowedChild, \"d\", new Double(0.0), true);\n+        assertEquals(new Double(0.0), FieldUtils.readField(privatelyShadowedChild, \"d\", true));\n+    }\n+\n+    public void testWriteDeclaredNamedField() throws Exception {\n+        try {\n+            FieldUtils.writeDeclaredField(publicChild, \"s\", \"S\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredField(publicChild, \"b\", Boolean.TRUE);\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredField(publicChild, \"i\", new Integer(1));\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredField(publicChild, \"d\", new Double(1.0));\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+\n+        FieldUtils.writeDeclaredField(publiclyShadowedChild, \"s\", \"S\");\n+        assertEquals(\"S\", FieldUtils.readDeclaredField(publiclyShadowedChild, \"s\"));\n+        FieldUtils.writeDeclaredField(publiclyShadowedChild, \"b\", Boolean.FALSE);\n+        assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publiclyShadowedChild, \"b\"));\n+        FieldUtils.writeDeclaredField(publiclyShadowedChild, \"i\", new Integer(0));\n+        assertEquals(new Integer(0), FieldUtils.readDeclaredField(publiclyShadowedChild, \"i\"));\n+        FieldUtils.writeDeclaredField(publiclyShadowedChild, \"d\", new Double(0.0));\n+        assertEquals(new Double(0.0), FieldUtils.readDeclaredField(publiclyShadowedChild, \"d\"));\n+\n+        try {\n+            FieldUtils.writeDeclaredField(privatelyShadowedChild, \"s\", \"S\");\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredField(privatelyShadowedChild, \"b\", Boolean.TRUE);\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredField(privatelyShadowedChild, \"i\", new Integer(1));\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredField(privatelyShadowedChild, \"d\", new Double(1.0));\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+    }\n+\n+    public void testWriteDeclaredNamedFieldForceAccess() throws Exception {\n+        try {\n+            FieldUtils.writeDeclaredField(publicChild, \"s\", \"S\", true);\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredField(publicChild, \"b\", Boolean.TRUE, true);\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredField(publicChild, \"i\", new Integer(1), true);\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+        try {\n+            FieldUtils.writeDeclaredField(publicChild, \"d\", new Double(1.0), true);\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+\n+        FieldUtils.writeDeclaredField(publiclyShadowedChild, \"s\", \"S\", true);\n+        assertEquals(\"S\", FieldUtils.readDeclaredField(publiclyShadowedChild, \"s\", true));\n+        FieldUtils.writeDeclaredField(publiclyShadowedChild, \"b\", Boolean.FALSE, true);\n+        assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publiclyShadowedChild, \"b\", true));\n+        FieldUtils.writeDeclaredField(publiclyShadowedChild, \"i\", new Integer(0), true);\n+        assertEquals(new Integer(0), FieldUtils.readDeclaredField(publiclyShadowedChild, \"i\", true));\n+        FieldUtils.writeDeclaredField(publiclyShadowedChild, \"d\", new Double(0.0), true);\n+        assertEquals(new Double(0.0), FieldUtils.readDeclaredField(publiclyShadowedChild, \"d\", true));\n+\n+        FieldUtils.writeDeclaredField(privatelyShadowedChild, \"s\", \"S\", true);\n+        assertEquals(\"S\", FieldUtils.readDeclaredField(privatelyShadowedChild, \"s\", true));\n+        FieldUtils.writeDeclaredField(privatelyShadowedChild, \"b\", Boolean.FALSE, true);\n+        assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(privatelyShadowedChild, \"b\", true));\n+        FieldUtils.writeDeclaredField(privatelyShadowedChild, \"i\", new Integer(0), true);\n+        assertEquals(new Integer(0), FieldUtils.readDeclaredField(privatelyShadowedChild, \"i\", true));\n+        FieldUtils.writeDeclaredField(privatelyShadowedChild, \"d\", new Double(0.0), true);\n+        assertEquals(new Double(0.0), FieldUtils.readDeclaredField(privatelyShadowedChild, \"d\", true));\n+    }\n+\n+    public void testAmbig() {\n+        try {\n+            FieldUtils.getField(Ambig.class, \"VALUE\");\n+            fail(\"should have failed on interface field ambiguity\");\n+        } catch (IllegalArgumentException e) {\n+            // pass\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/reflect/MethodUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.math.NumberUtils;\n+import org.apache.commons.lang.mutable.Mutable;\n+import org.apache.commons.lang.mutable.MutableObject;\n+\n+/**\n+ * Unit tests MethodUtils\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public class MethodUtilsTest extends TestCase {\n+    public static class TestBean {\n+\n+        public static String bar() {\n+            return \"bar()\";\n+        }\n+\n+        public static String bar(int i) {\n+            return \"bar(int)\";\n+        }\n+\n+        public static String bar(Integer i) {\n+            return \"bar(Integer)\";\n+        }\n+\n+        public static String bar(double d) {\n+            return \"bar(double)\";\n+        }\n+\n+        public static String bar(String s) {\n+            return \"bar(String)\";\n+        }\n+\n+        public static String bar(Object o) {\n+            return \"bar(Object)\";\n+        }\n+\n+        public String foo() {\n+            return \"foo()\";\n+        }\n+\n+        public String foo(int i) {\n+            return \"foo(int)\";\n+        }\n+\n+        public String foo(Integer i) {\n+            return \"foo(Integer)\";\n+        }\n+\n+        public String foo(double d) {\n+            return \"foo(double)\";\n+        }\n+\n+        public String foo(String s) {\n+            return \"foo(String)\";\n+        }\n+\n+        public String foo(Object o) {\n+            return \"foo(Object)\";\n+        }\n+    }\n+\n+    private static class TestMutable implements Mutable<Object> {\n+        public Object getValue() {\n+            return null;\n+        }\n+\n+        public void setValue(Object value) {\n+        }\n+    }\n+\n+    private TestBean testBean;\n+    private Map<Class<?>, Class<?>[]> classCache;\n+\n+    public MethodUtilsTest(String name) {\n+        super(name);\n+        classCache = new HashMap<Class<?>, Class<?>[]>();\n+    }\n+\n+    /**\n+     * Run the test cases as a suite.\n+     * @return the Test\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(MethodUtilsTest.class);\n+        suite.setName(\"MethodUtils Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        testBean = new TestBean();\n+        classCache.clear();\n+    }\n+\n+    public void testConstructor() throws Exception {\n+        assertNotNull(MethodUtils.class.newInstance());\n+    }\n+\n+    public void testInvokeMethod() throws Exception {\n+        assertEquals(\"foo()\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                ArrayUtils.EMPTY_CLASS_ARRAY));\n+        assertEquals(\"foo()\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                (Class[]) null));\n+        assertEquals(\"foo(String)\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                \"\"));\n+        assertEquals(\"foo(Object)\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                new Object()));\n+        assertEquals(\"foo(Object)\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                Boolean.TRUE));\n+        assertEquals(\"foo(Integer)\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                NumberUtils.INTEGER_ONE));\n+        assertEquals(\"foo(int)\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                NumberUtils.BYTE_ONE));\n+        assertEquals(\"foo(double)\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                NumberUtils.LONG_ONE));\n+        assertEquals(\"foo(double)\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                NumberUtils.DOUBLE_ONE));\n+    }\n+\n+    public void testInvokeExactMethod() throws Exception {\n+        assertEquals(\"foo()\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                ArrayUtils.EMPTY_CLASS_ARRAY));\n+        assertEquals(\"foo()\", MethodUtils.invokeMethod(testBean, \"foo\",\n+                (Class[]) null));\n+        assertEquals(\"foo(String)\", MethodUtils.invokeExactMethod(testBean,\n+                \"foo\", \"\"));\n+        assertEquals(\"foo(Object)\", MethodUtils.invokeExactMethod(testBean,\n+                \"foo\", new Object()));\n+        assertEquals(\"foo(Integer)\", MethodUtils.invokeExactMethod(testBean,\n+                \"foo\", NumberUtils.INTEGER_ONE));\n+        assertEquals(\"foo(double)\", MethodUtils.invokeExactMethod(testBean,\n+                \"foo\", new Object[] { NumberUtils.DOUBLE_ONE },\n+                new Class[] { Double.TYPE }));\n+\n+        try {\n+            MethodUtils\n+                    .invokeExactMethod(testBean, \"foo\", NumberUtils.BYTE_ONE);\n+            fail(\"should throw NoSuchMethodException\");\n+        } catch (NoSuchMethodException e) {\n+        }\n+        try {\n+            MethodUtils\n+                    .invokeExactMethod(testBean, \"foo\", NumberUtils.LONG_ONE);\n+            fail(\"should throw NoSuchMethodException\");\n+        } catch (NoSuchMethodException e) {\n+        }\n+        try {\n+            MethodUtils.invokeExactMethod(testBean, \"foo\", Boolean.TRUE);\n+            fail(\"should throw NoSuchMethodException\");\n+        } catch (NoSuchMethodException e) {\n+        }\n+    }\n+\n+    public void testInvokeStaticMethod() throws Exception {\n+        assertEquals(\"bar()\", MethodUtils.invokeStaticMethod(TestBean.class,\n+                \"bar\", ArrayUtils.EMPTY_CLASS_ARRAY));\n+        assertEquals(\"bar()\", MethodUtils.invokeStaticMethod(TestBean.class,\n+                \"bar\", (Class[]) null));\n+        assertEquals(\"bar(String)\", MethodUtils.invokeStaticMethod(\n+                TestBean.class, \"bar\", \"\"));\n+        assertEquals(\"bar(Object)\", MethodUtils.invokeStaticMethod(\n+                TestBean.class, \"bar\", new Object()));\n+        assertEquals(\"bar(Object)\", MethodUtils.invokeStaticMethod(\n+                TestBean.class, \"bar\", Boolean.TRUE));\n+        assertEquals(\"bar(Integer)\", MethodUtils.invokeStaticMethod(\n+                TestBean.class, \"bar\", NumberUtils.INTEGER_ONE));\n+        assertEquals(\"bar(int)\", MethodUtils.invokeStaticMethod(TestBean.class,\n+                \"bar\", NumberUtils.BYTE_ONE));\n+        assertEquals(\"bar(double)\", MethodUtils.invokeStaticMethod(\n+                TestBean.class, \"bar\", NumberUtils.LONG_ONE));\n+        assertEquals(\"bar(double)\", MethodUtils.invokeStaticMethod(\n+                TestBean.class, \"bar\", NumberUtils.DOUBLE_ONE));\n+    }\n+\n+    public void testInvokeExactStaticMethod() throws Exception {\n+        assertEquals(\"bar()\", MethodUtils.invokeStaticMethod(TestBean.class,\n+                \"bar\", ArrayUtils.EMPTY_CLASS_ARRAY));\n+        assertEquals(\"bar()\", MethodUtils.invokeStaticMethod(TestBean.class,\n+                \"bar\", (Class[]) null));\n+        assertEquals(\"bar(String)\", MethodUtils.invokeExactStaticMethod(\n+                TestBean.class, \"bar\", \"\"));\n+        assertEquals(\"bar(Object)\", MethodUtils.invokeExactStaticMethod(\n+                TestBean.class, \"bar\", new Object()));\n+        assertEquals(\"bar(Integer)\", MethodUtils.invokeExactStaticMethod(\n+                TestBean.class, \"bar\", NumberUtils.INTEGER_ONE));\n+        assertEquals(\"bar(double)\", MethodUtils.invokeExactStaticMethod(\n+                TestBean.class, \"bar\", new Object[] { NumberUtils.DOUBLE_ONE },\n+                new Class[] { Double.TYPE }));\n+\n+        try {\n+            MethodUtils.invokeExactStaticMethod(TestBean.class, \"bar\",\n+                    NumberUtils.BYTE_ONE);\n+            fail(\"should throw NoSuchMethodException\");\n+        } catch (NoSuchMethodException e) {\n+        }\n+        try {\n+            MethodUtils.invokeExactStaticMethod(TestBean.class, \"bar\",\n+                    NumberUtils.LONG_ONE);\n+            fail(\"should throw NoSuchMethodException\");\n+        } catch (NoSuchMethodException e) {\n+        }\n+        try {\n+            MethodUtils.invokeExactStaticMethod(TestBean.class, \"bar\",\n+                    Boolean.TRUE);\n+            fail(\"should throw NoSuchMethodException\");\n+        } catch (NoSuchMethodException e) {\n+        }\n+    }\n+\n+    public void testGetAccessibleInterfaceMethod() throws Exception {\n+\n+        Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null };\n+        for (int i = 0; i < p.length; i++) {\n+            Method method = TestMutable.class.getMethod(\"getValue\", p[i]);\n+            Method accessibleMethod = MethodUtils.getAccessibleMethod(method);\n+            assertNotSame(accessibleMethod, method);\n+            assertSame(Mutable.class, accessibleMethod.getDeclaringClass());\n+        }\n+    }\n+\n+    public void testGetAccessibleInterfaceMethodFromDescription()\n+            throws Exception {\n+        Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null };\n+        for (int i = 0; i < p.length; i++) {\n+            Method accessibleMethod = MethodUtils.getAccessibleMethod(\n+                    TestMutable.class, \"getValue\", p[i]);\n+            assertSame(Mutable.class, accessibleMethod.getDeclaringClass());\n+        }\n+    }\n+\n+    public void testGetAccessiblePublicMethod() throws Exception {\n+        assertSame(MutableObject.class, MethodUtils.getAccessibleMethod(\n+                MutableObject.class.getMethod(\"getValue\",\n+                        ArrayUtils.EMPTY_CLASS_ARRAY)).getDeclaringClass());\n+    }\n+\n+    public void testGetAccessiblePublicMethodFromDescription() throws Exception {\n+        assertSame(MutableObject.class, MethodUtils.getAccessibleMethod(\n+                MutableObject.class, \"getValue\", ArrayUtils.EMPTY_CLASS_ARRAY)\n+                .getDeclaringClass());\n+    }\n+\n+    public void testGetMatchingAccessibleMethod() throws Exception {\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY);\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                null, ArrayUtils.EMPTY_CLASS_ARRAY);\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(String.class), singletonArray(String.class));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Object.class), singletonArray(Object.class));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Boolean.class), singletonArray(Object.class));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Byte.class), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Byte.TYPE), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Short.class), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Short.TYPE), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Character.class), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Character.TYPE), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Integer.class), singletonArray(Integer.class));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Integer.TYPE), singletonArray(Integer.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Long.class), singletonArray(Double.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Long.TYPE), singletonArray(Double.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Float.class), singletonArray(Double.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Float.TYPE), singletonArray(Double.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Double.class), singletonArray(Double.TYPE));\n+        expectMatchingAccessibleMethodParameterTypes(TestBean.class, \"foo\",\n+                singletonArray(Double.TYPE), singletonArray(Double.TYPE));\n+    }\n+\n+    private void expectMatchingAccessibleMethodParameterTypes(Class<?> cls,\n+            String methodName, Class<?>[] requestTypes, Class<?>[] actualTypes) {\n+        Method m = MethodUtils.getMatchingAccessibleMethod(cls, methodName,\n+                requestTypes);\n+        assertTrue(toString(m.getParameterTypes()) + \" not equals \"\n+                + toString(actualTypes), Arrays.equals(actualTypes, m\n+                .getParameterTypes()));\n+    }\n+\n+    private String toString(Class<?>[] c) {\n+        return Arrays.asList(c).toString();\n+    }\n+\n+    private Class<?>[] singletonArray(Class<?> c) {\n+        Class<?>[] result = classCache.get(c);\n+        if (result == null) {\n+            result = new Class[] { c };\n+            classCache.put(c, result);\n+        }\n+        return result;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/reflect/TypeUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import static junit.framework.Assert.*;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.TypeVariable;\n+import java.util.List;\n+\n+import org.apache.commons.lang.reflect.testbed.*;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Test TypeUtils\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public class TypeUtilsTest {\n+    private Field stringParentField;\n+    private Field integerParentField;\n+    private Field foosField;\n+    private Field barParentsField;\n+    private TypeVariable<?> genericParentT;\n+    private TypeVariable<?> listType;\n+    private TypeVariable<?> iterableType;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        stringParentField = GenericTypeHolder.class.getDeclaredField(\"stringParent\");\n+        integerParentField = GenericTypeHolder.class.getDeclaredField(\"integerParent\");\n+        foosField = GenericTypeHolder.class.getDeclaredField(\"foos\");\n+        barParentsField = GenericTypeHolder.class.getDeclaredField(\"barParents\");\n+        genericParentT = GenericParent.class.getTypeParameters()[0];\n+        listType = List.class.getTypeParameters()[0];\n+        iterableType = Iterable.class.getTypeParameters()[0];\n+    }\n+\n+    @Test\n+    public void testGetRawTypeClass() throws Exception {\n+        assertEquals(GenericParent.class, TypeUtils.getRawType(null, GenericParent.class));\n+    }\n+\n+    @Test\n+    public void testGetRawTypeParameterizedType() throws Exception {\n+        assertEquals(GenericParent.class, TypeUtils.getRawType(GenericTypeHolder.class,\n+                stringParentField.getGenericType()));\n+        assertEquals(GenericParent.class, TypeUtils.getRawType(GenericTypeHolder.class,\n+                integerParentField.getGenericType()));\n+        assertEquals(List.class, TypeUtils.getRawType(GenericTypeHolder.class, foosField\n+                .getGenericType()));\n+    }\n+\n+    @Test\n+    public void testGetRawTypeTypeVariable() throws Exception {\n+        assertEquals(String.class, TypeUtils.getRawType(StringParameterizedChild.class,\n+                genericParentT));\n+        assertEquals(String.class, TypeUtils.getRawType(stringParentField.getGenericType(),\n+                genericParentT));\n+        assertEquals(Foo.class, TypeUtils.getRawType(foosField.getGenericType(), iterableType));\n+        assertEquals(Foo.class, TypeUtils.getRawType(foosField.getGenericType(), listType));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testGetRawTypeUnresolvableTypeVariable() {\n+        TypeUtils.getRawType(GenericParent.class, genericParentT);\n+    }\n+\n+    @Test\n+    public void testGetRawTypeGenericArray() throws Exception {\n+        assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class,\n+                barParentsField.getGenericType()));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/reflect/testbed/Ambig.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+/**\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public class Ambig implements Foo, Bar {\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/reflect/testbed/Bar.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+/**\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public interface Bar {\n+    public static final String VALUE = \"bar\";\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/reflect/testbed/Foo.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+/**\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public interface Foo {\n+    public static final String VALUE = \"foo\";\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/reflect/testbed/GenericParent.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+/**\n+ * Class declaring a parameter variable.\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public class GenericParent<T> {\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/reflect/testbed/GenericTypeHolder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+import java.util.List;\n+\n+/**\n+ * Holds generic testbed types.\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public class GenericTypeHolder {\n+    public GenericParent<String> stringParent;\n+    public GenericParent<Integer> integerParent;\n+    public List<Foo> foos;\n+    public GenericParent<Bar>[] barParents;\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/reflect/testbed/Parent.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+/**\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+class Parent implements Foo {\n+    public String s = \"s\";\n+    protected boolean b = false;\n+    int i = 0;\n+    @SuppressWarnings(\"unused\")\n+    private double d = 0.0;\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/reflect/testbed/PrivatelyShadowedChild.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+/**\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+@SuppressWarnings({ \"unused\", \"hiding\" }) // deliberate re-use of variable names\n+public class PrivatelyShadowedChild extends Parent {\n+    private String s = \"ss\";\n+    private boolean b = true;\n+    private int i = 1;\n+    private double d = 1.0;\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/reflect/testbed/PublicChild.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+/**\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public class PublicChild extends Parent {\n+    @SuppressWarnings(\"hiding\") // deliberate reuse of variable name\n+    static final String VALUE = \"child\";\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/reflect/testbed/PubliclyShadowedChild.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+/**\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"hiding\") // deliberate re-use of variable names\n+public class PubliclyShadowedChild extends Parent {\n+    public String s = \"ss\";\n+    public boolean b = true;\n+    public int i = 1;\n+    public double d = 1.0;\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/reflect/testbed/StaticContainer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+/**\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public class StaticContainer {\n+    public static final Object IMMUTABLE_PUBLIC = \"public\";\n+    protected static final Object IMMUTABLE_PROTECTED = \"protected\";\n+    static final Object IMMUTABLE_PACKAGE = \"\";\n+    @SuppressWarnings(\"unused\")\n+    private static final Object IMMUTABLE_PRIVATE = \"private\";\n+\n+    public static Object mutablePublic;\n+    protected static Object mutableProtected;\n+    static Object mutablePackage;\n+    private static Object mutablePrivate;\n+\n+    public static void reset() {\n+        mutablePublic = null;\n+        mutableProtected = null;\n+        mutablePackage = null;\n+        mutablePrivate = null;\n+    }\n+\n+    public static Object getMutableProtected() {\n+        return mutableProtected;\n+    }\n+\n+    public static Object getMutablePackage() {\n+        return mutablePackage;\n+    }\n+\n+    public static Object getMutablePrivate() {\n+        return mutablePrivate;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/reflect/testbed/StaticContainerChild.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+/**\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public class StaticContainerChild extends StaticContainer {\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/reflect/testbed/StringParameterizedChild.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.reflect.testbed;\n+\n+/**\n+ * {@link GenericParent} subclass that explicitly specifies <T> as {@link String}.\n+ * @author mbenson\n+ * @version $Id$\n+ */\n+public class StringParameterizedChild extends GenericParent<String> {\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/text/CompositeFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text;\n+\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.ParsePosition;\n+import java.text.SimpleDateFormat;\n+import java.util.Locale;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests for {@link org.apache.commons.lang.text.CompositeFormat}.\n+ */\n+public class CompositeFormatTest extends TestCase {\n+\n+    /**\n+     * Main method.\n+     * \n+     * @param args  command line arguments, ignored\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Return a new test suite containing this test case.\n+     * \n+     * @return a new test suite containing this test case\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(CompositeFormatTest.class);\n+        suite.setName(\"CompositeFormat Tests\");\n+        return suite;\n+    }\n+\n+    /**\n+     * Create a new test case with the specified name.\n+     * \n+     * @param name\n+     *            name\n+     */\n+    public CompositeFormatTest(String name) {\n+        super(name);\n+    }\n+\n+\n+    /**\n+     * Ensures that the parse/format separation is correctly maintained. \n+     */\n+    public void testCompositeFormat() {\n+\n+        Format parser = new Format() {\n+            @Override\n+            public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+                throw new UnsupportedOperationException(\"Not implemented\");\n+            }\n+\n+            @Override\n+            public Object parseObject(String source, ParsePosition pos) {\n+                return null;    // do nothing\n+            }\n+        };\n+\n+        Format formatter = new Format() {\n+            @Override\n+            public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+                return null;    // do nothing\n+            }\n+\n+            @Override\n+            public Object parseObject(String source, ParsePosition pos) {\n+                throw new UnsupportedOperationException(\"Not implemented\");\n+            }\n+        };\n+\n+        CompositeFormat composite = new CompositeFormat(parser, formatter);\n+\n+        composite.parseObject(\"\", null);\n+        composite.format(new Object(), new StringBuffer(), null);\n+        assertEquals( \"Parser get method incorrectly implemented\", parser, composite.getParser() );\n+        assertEquals( \"Formatter get method incorrectly implemented\", formatter, composite.getFormatter() );\n+    }\n+\n+    public void testUsage() throws Exception {\n+        Format f1 = new SimpleDateFormat(\"MMddyyyy\", Locale.ENGLISH);\n+        Format f2 = new SimpleDateFormat(\"MMMM d, yyyy\", Locale.ENGLISH);\n+        CompositeFormat c = new CompositeFormat(f1, f2);\n+        String testString = \"January 3, 2005\";\n+        assertEquals(testString, c.format(c.parseObject(\"01032005\")));\n+        assertEquals(testString, c.reformat(\"01032005\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/text/ExtendedMessageFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.text.ChoiceFormat;\n+import java.text.DateFormat;\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.MessageFormat;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.SystemUtils;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test case for {@link ExtendedMessageFormat}.\n+ *\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+public class ExtendedMessageFormatTest extends TestCase {\n+\n+    private final Map<String, FormatFactory> registry = new HashMap<String, FormatFactory>();\n+\n+    /**\n+     * Return a new test suite containing this test case.\n+     * \n+     * @return a new test suite containing this test case\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ExtendedMessageFormatTest.class);\n+        suite.setName(\"ExtendedMessageFormat Tests\");\n+        return suite;\n+    }\n+\n+    /**\n+     * Create a new test case.\n+     *\n+     * @param name The name of the test\n+     */\n+    public ExtendedMessageFormatTest(String name) {\n+        super(name);\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        registry.put(\"lower\", new LowerCaseFormatFactory());\n+        registry.put(\"upper\", new UpperCaseFormatFactory());\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    /**\n+     * Test extended formats.\n+     */\n+    public void testExtendedFormats() {\n+        String pattern = \"Lower: {0,lower} Upper: {1,upper}\";\n+        ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);\n+        assertPatternsEqual(\"TOPATTERN\", pattern, emf.toPattern());\n+        assertEquals(\"Lower: foo Upper: BAR\", emf.format(new Object[] {\"foo\", \"bar\"}));\n+        assertEquals(\"Lower: foo Upper: BAR\", emf.format(new Object[] {\"Foo\", \"Bar\"}));\n+        assertEquals(\"Lower: foo Upper: BAR\", emf.format(new Object[] {\"FOO\", \"BAR\"}));\n+        assertEquals(\"Lower: foo Upper: BAR\", emf.format(new Object[] {\"FOO\", \"bar\"}));\n+        assertEquals(\"Lower: foo Upper: BAR\", emf.format(new Object[] {\"foo\", \"BAR\"}));\n+    }\n+\n+    /**\n+     * Test Bug LANG-477 - out of memory error with escaped quote\n+     */\n+    public void testEscapedQuote_LANG_477() {\n+        String pattern = \"it''s a {0,lower} 'test'!\";\n+        ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);\n+        assertEquals(\"it's a dummy test!\", emf.format(new Object[] {\"DUMMY\"}));\n+    }\n+\n+    /**\n+     * Test extended and built in formats.\n+     */\n+    public void testExtendedAndBuiltInFormats() {\n+        Calendar cal = Calendar.getInstance();\n+        cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05);\n+        Object[] args = new Object[] {\"John Doe\", cal.getTime(), new Double(\"12345.67\")};\n+        String builtinsPattern = \"DOB: {1,date,short} Salary: {2,number,currency}\";\n+        String extendedPattern = \"Name: {0,upper} \";\n+        String pattern = extendedPattern + builtinsPattern;\n+\n+        HashSet<Locale> testLocales = new HashSet<Locale>();\n+        testLocales.addAll(Arrays.asList(DateFormat.getAvailableLocales()));\n+        testLocales.retainAll(Arrays.asList(NumberFormat.getAvailableLocales()));\n+        testLocales.add(null);\n+\n+        for (Iterator<Locale> l = testLocales.iterator(); l.hasNext();) {\n+            Locale locale = l.next();\n+            MessageFormat builtins = createMessageFormat(builtinsPattern, locale);\n+            String expectedPattern = extendedPattern + builtins.toPattern();\n+            DateFormat df = null;\n+            NumberFormat nf = null;\n+            ExtendedMessageFormat emf = null;\n+            if (locale == null) {\n+                df = DateFormat.getDateInstance(DateFormat.SHORT);\n+                nf = NumberFormat.getCurrencyInstance();\n+                emf = new ExtendedMessageFormat(pattern, registry);\n+            } else {\n+                df = DateFormat.getDateInstance(DateFormat.SHORT, locale);\n+                nf = NumberFormat.getCurrencyInstance(locale);\n+                emf = new ExtendedMessageFormat(pattern, locale, registry);\n+            }\n+            StringBuffer expected = new StringBuffer();\n+            expected.append(\"Name: \");\n+            expected.append(args[0].toString().toUpperCase());\n+            expected.append(\" DOB: \");\n+            expected.append(df.format(args[1]));\n+            expected.append(\" Salary: \");\n+            expected.append(nf.format(args[2]));\n+            assertPatternsEqual(\"pattern comparison for locale \" + locale, expectedPattern, emf.toPattern());\n+            assertEquals(String.valueOf(locale), expected.toString(), emf.format(args));\n+        }\n+    }\n+\n+//    /**\n+//     * Test extended formats with choice format.\n+//     *\n+//     * N.B. FAILING - currently sub-formats not supported\n+//     */\n+//    public void testExtendedWithChoiceFormat() {\n+//        String pattern = \"Choice: {0,choice,1.0#{1,lower}|2.0#{1,upper}}\";\n+//        ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);\n+//        assertPatterns(null, pattern, emf.toPattern());\n+//        try {\n+//            assertEquals(\"one\", emf.format(new Object[] {new Integer(1), \"ONE\"}));\n+//            assertEquals(\"TWO\", emf.format(new Object[] {new Integer(2), \"two\"}));\n+//        } catch (IllegalArgumentException e) {\n+//            // currently sub-formats not supported\n+//        }\n+//    }\n+\n+//    /**\n+//     * Test mixed extended and built-in formats with choice format.\n+//     *\n+//     * N.B. FAILING - currently sub-formats not supported\n+//     */\n+//    public void testExtendedAndBuiltInWithChoiceFormat() {\n+//        String pattern = \"Choice: {0,choice,1.0#{0} {1,lower} {2,number}|2.0#{0} {1,upper} {2,number,currency}}\";\n+//        Object[] lowArgs  = new Object[] {new Integer(1), \"Low\",  new Double(\"1234.56\")};\n+//        Object[] highArgs = new Object[] {new Integer(2), \"High\", new Double(\"9876.54\")};\n+//        Locale[] availableLocales = ChoiceFormat.getAvailableLocales();\n+//        Locale[] testLocales = new Locale[availableLocales.length + 1];\n+//        testLocales[0] = null;\n+//        System.arraycopy(availableLocales, 0, testLocales, 1, availableLocales.length);\n+//        for (int i = 0; i < testLocales.length; i++) {\n+//            NumberFormat nf = null;\n+//            NumberFormat cf = null;\n+//            ExtendedMessageFormat emf = null;\n+//            if (testLocales[i] == null) {\n+//                nf = NumberFormat.getNumberInstance();\n+//                cf = NumberFormat.getCurrencyInstance();\n+//                emf = new ExtendedMessageFormat(pattern, registry);\n+//            } else {\n+//                nf = NumberFormat.getNumberInstance(testLocales[i]);\n+//                cf = NumberFormat.getCurrencyInstance(testLocales[i]);\n+//                emf = new ExtendedMessageFormat(pattern, testLocales[i], registry);\n+//            }\n+//            assertPatterns(null, pattern, emf.toPattern());\n+//            try {\n+//                String lowExpected = lowArgs[0] + \" low \"    + nf.format(lowArgs[2]);\n+//                String highExpected = highArgs[0] + \" HIGH \"  + cf.format(highArgs[2]);\n+//                assertEquals(lowExpected,  emf.format(lowArgs));\n+//                assertEquals(highExpected, emf.format(highArgs));\n+//            } catch (IllegalArgumentException e) {\n+//                // currently sub-formats not supported\n+//            }\n+//        }\n+//    }\n+\n+    /**\n+     * Test the built in choice format.\n+     */\n+    public void testBuiltInChoiceFormat() {\n+        Object[] values = new Number[] {new Integer(1), new Double(\"2.2\"), new Double(\"1234.5\")};\n+        String choicePattern = null;\n+        Locale[] availableLocales = ChoiceFormat.getAvailableLocales();\n+\n+        choicePattern = \"{0,choice,1#One|2#Two|3#Many {0,number}}\";\n+        for (int i = 0; i < values.length; i++) {\n+            checkBuiltInFormat(values[i] + \": \" + choicePattern, new Object[] {values[i]}, availableLocales);\n+        }\n+\n+        choicePattern = \"{0,choice,1#''One''|2#\\\"Two\\\"|3#''{Many}'' {0,number}}\";\n+        for (int i = 0; i < values.length; i++) {\n+            checkBuiltInFormat(values[i] + \": \" + choicePattern, new Object[] {values[i]}, availableLocales);\n+        }\n+    }\n+\n+    /**\n+     * Test the built in date/time formats\n+     */\n+    public void testBuiltInDateTimeFormat() {\n+        Calendar cal = Calendar.getInstance();\n+        cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05);\n+        Object[] args = new Object[] {cal.getTime()};\n+        Locale[] availableLocales = DateFormat.getAvailableLocales();\n+\n+        checkBuiltInFormat(\"1: {0,date,short}\",    args, availableLocales);\n+        checkBuiltInFormat(\"2: {0,date,medium}\",   args, availableLocales);\n+        checkBuiltInFormat(\"3: {0,date,long}\",     args, availableLocales);\n+        checkBuiltInFormat(\"4: {0,date,full}\",     args, availableLocales);\n+        checkBuiltInFormat(\"5: {0,date,d MMM yy}\", args, availableLocales);\n+        checkBuiltInFormat(\"6: {0,time,short}\",    args, availableLocales);\n+        checkBuiltInFormat(\"7: {0,time,medium}\",   args, availableLocales);\n+        checkBuiltInFormat(\"8: {0,time,long}\",     args, availableLocales);\n+        checkBuiltInFormat(\"9: {0,time,full}\",     args, availableLocales);\n+        checkBuiltInFormat(\"10: {0,time,HH:mm}\",   args, availableLocales);\n+        checkBuiltInFormat(\"11: {0,date}\",         args, availableLocales);\n+        checkBuiltInFormat(\"12: {0,time}\",         args, availableLocales);\n+    }\n+\n+    public void testOverriddenBuiltinFormat() {\n+        Calendar cal = Calendar.getInstance();\n+        cal.set(2007, Calendar.JANUARY, 23);\n+        Object[] args = new Object[] {cal.getTime()};\n+        Locale[] availableLocales = DateFormat.getAvailableLocales();\n+        Map<String, ? extends FormatFactory> registry = Collections.singletonMap(\"date\", new OverrideShortDateFormatFactory());\n+\n+        //check the non-overridden builtins:\n+        checkBuiltInFormat(\"1: {0,date}\", registry,          args, availableLocales);\n+        checkBuiltInFormat(\"2: {0,date,medium}\", registry,   args, availableLocales);\n+        checkBuiltInFormat(\"3: {0,date,long}\", registry,     args, availableLocales);\n+        checkBuiltInFormat(\"4: {0,date,full}\", registry,     args, availableLocales);\n+        checkBuiltInFormat(\"5: {0,date,d MMM yy}\", registry, args, availableLocales);\n+\n+        //check the overridden format:\n+        for (int i = -1; i < availableLocales.length; i++) {\n+            Locale locale = i < 0 ? null : availableLocales[i];\n+            MessageFormat dateDefault = createMessageFormat(\"{0,date}\", locale);\n+            String pattern = \"{0,date,short}\";\n+            ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry);\n+            assertEquals(\"overridden date,short format\", dateDefault.format(args), dateShort.format(args));\n+            assertEquals(\"overridden date,short pattern\", pattern, dateShort.toPattern());\n+        }\n+    }\n+\n+    /**\n+     * Test the built in number formats.\n+     */\n+    public void testBuiltInNumberFormat() {\n+        Object[] args = new Object[] {new Double(\"6543.21\")};\n+        Locale[] availableLocales = NumberFormat.getAvailableLocales();\n+        checkBuiltInFormat(\"1: {0,number}\",            args, availableLocales);\n+        checkBuiltInFormat(\"2: {0,number,integer}\",    args, availableLocales);\n+        checkBuiltInFormat(\"3: {0,number,currency}\",   args, availableLocales);\n+        checkBuiltInFormat(\"4: {0,number,percent}\",    args, availableLocales);\n+        checkBuiltInFormat(\"5: {0,number,00000.000}\",  args, availableLocales);\n+    }\n+\n+    /**\n+     * Test a built in format for the specified Locales, plus <code>null</code> Locale.\n+     * @param pattern MessageFormat pattern\n+     * @param args MessageFormat arguments\n+     * @param locales to test\n+     */\n+    private void checkBuiltInFormat(String pattern, Object[] args, Locale[] locales) {\n+        checkBuiltInFormat(pattern, null, args, locales);\n+    }\n+\n+    /**\n+     * Test a built in format for the specified Locales, plus <code>null</code> Locale.\n+     * @param pattern MessageFormat pattern\n+     * @param registry FormatFactory registry to use\n+     * @param args MessageFormat arguments\n+     * @param locales to test\n+     */\n+    private void checkBuiltInFormat(String pattern, Map<String, ?> registry, Object[] args, Locale[] locales) {\n+        checkBuiltInFormat(pattern, registry, args, (Locale) null);\n+        for (int i = 0; i < locales.length; i++) {\n+            checkBuiltInFormat(pattern, registry, args, locales[i]);\n+        }\n+    }\n+\n+    /**\n+     * Create an ExtendedMessageFormat for the specified pattern and locale and check the\n+     * formated output matches the expected result for the parameters.\n+     * @param pattern string\n+     * @param registry map\n+     * @param args Object[]\n+     * @param locale Locale\n+     */\n+    private void checkBuiltInFormat(String pattern, Map<String, ?> registry, Object[] args, Locale locale) {\n+        StringBuffer buffer = new StringBuffer();\n+        buffer.append(\"Pattern=[\");\n+        buffer.append(pattern);\n+        buffer.append(\"], locale=[\");\n+        buffer.append(locale);\n+        buffer.append(\"]\");\n+        MessageFormat mf = createMessageFormat(pattern, locale);\n+        // System.out.println(buffer + \", result=[\" + mf.format(args) +\"]\");\n+        ExtendedMessageFormat emf = null;\n+        if (locale == null) {\n+            emf = new ExtendedMessageFormat(pattern);\n+        } else {\n+            emf = new ExtendedMessageFormat(pattern, locale);\n+        }\n+        assertEquals(\"format \"    + buffer.toString(), mf.format(args), emf.format(args));\n+        assertPatternsEqual(\"toPattern \" + buffer.toString(), mf.toPattern(),  emf.toPattern());\n+    }\n+\n+    //can't trust what MessageFormat does with toPattern() pre 1.4:\n+    private void assertPatternsEqual(String message, String expected, String actual) {\n+        if (SystemUtils.isJavaVersionAtLeast(1.4f)) {\n+            assertEquals(message, expected, actual);\n+        }\n+    }\n+\n+    /**\n+     * Replace MessageFormat(String, Locale) constructor (not available until JDK 1.4).\n+     * @param pattern string\n+     * @param locale Locale\n+     * @return MessageFormat\n+     */\n+    private MessageFormat createMessageFormat(String pattern, Locale locale) {\n+        MessageFormat result = new MessageFormat(pattern);\n+        if (locale != null) {\n+            result.setLocale(locale);\n+            result.applyPattern(pattern);\n+        }\n+        return result;\n+    }\n+\n+    // ------------------------ Test Formats ------------------------\n+\n+    /**\n+     * {@link Format} implementation which converts to lower case.\n+     */\n+    private static class LowerCaseFormat extends Format {\n+        @Override\n+        public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+            return toAppendTo.append(((String)obj).toLowerCase());\n+        }\n+        @Override\n+        public Object parseObject(String source, ParsePosition pos) {throw new UnsupportedOperationException();}\n+    }\n+\n+    /**\n+     * {@link Format} implementation which converts to upper case.\n+     */\n+    private static class UpperCaseFormat extends Format {\n+        @Override\n+        public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+            return toAppendTo.append(((String)obj).toUpperCase());\n+        }\n+        @Override\n+        public Object parseObject(String source, ParsePosition pos) {throw new UnsupportedOperationException();}\n+    }\n+\n+\n+    // ------------------------ Test Format Factories ---------------\n+    /**\n+     * {@link FormatFactory} implementation for lower case format.\n+     */\n+    private static class LowerCaseFormatFactory implements FormatFactory {\n+        private static final Format LOWER_INSTANCE = new LowerCaseFormat();\n+        public Format getFormat(String name, String arguments, Locale locale) {\n+            return LOWER_INSTANCE;\n+        }\n+    }\n+    /**\n+     * {@link FormatFactory} implementation for upper case format.\n+     */\n+    private static class UpperCaseFormatFactory implements FormatFactory {\n+        private static final Format UPPER_INSTANCE = new UpperCaseFormat();\n+        public Format getFormat(String name, String arguments, Locale locale) {\n+            return UPPER_INSTANCE;\n+        }\n+    }\n+    /**\n+     * {@link FormatFactory} implementation to override date format \"short\" to \"default\".\n+     */\n+    private static class OverrideShortDateFormatFactory implements FormatFactory {\n+        public Format getFormat(String name, String arguments, Locale locale) {\n+            return !\"short\".equals(arguments) ? null\n+                    : locale == null ? DateFormat\n+                            .getDateInstance(DateFormat.DEFAULT) : DateFormat\n+                            .getDateInstance(DateFormat.DEFAULT, locale);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/text/StrBuilderAppendInsertTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.lang.SystemUtils;\n+\n+/**\n+ * Unit tests for {@link org.apache.commons.lang.text.StrBuilder}.\n+ *\n+ * @version $Id$\n+ */\n+public class StrBuilderAppendInsertTest extends TestCase {\n+\n+    /** The system line separator. */\n+    private static final String SEP = SystemUtils.LINE_SEPARATOR;\n+\n+    /** Test subclass of Object, with a toString method. */\n+    private static final Object FOO = new Object() {\n+        @Override\n+        public String toString() {\n+            return \"foo\";\n+        }\n+    };\n+\n+    /**\n+     * Main method.\n+     * \n+     * @param args  command line arguments, ignored\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Return a new test suite containing this test case.\n+     * \n+     * @return a new test suite containing this test case\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StrBuilderAppendInsertTest.class);\n+        suite.setName(\"StrBuilder Tests\");\n+        return suite;\n+    }\n+\n+    /**\n+     * Create a new test case with the specified name.\n+     * \n+     * @param name  the name\n+     */\n+    public StrBuilderAppendInsertTest(String name) {\n+        super(name);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendNewLine() {\n+        StrBuilder sb = new StrBuilder(\"---\");\n+        sb.appendNewLine().append(\"+++\");\n+        assertEquals(\"---\" + SEP + \"+++\", sb.toString());\n+        \n+        sb = new StrBuilder(\"---\");\n+        sb.setNewLineText(\"#\").appendNewLine().setNewLineText(null).appendNewLine();\n+        assertEquals(\"---#\" + SEP, sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendWithNullText() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"NULL\");\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.appendNull();\n+        assertEquals(\"NULL\", sb.toString());\n+\n+        sb.append((Object) null);\n+        assertEquals(\"NULLNULL\", sb.toString());\n+\n+        sb.append(FOO);\n+        assertEquals(\"NULLNULLfoo\", sb.toString());\n+\n+        sb.append((String) null);\n+        assertEquals(\"NULLNULLfooNULL\", sb.toString());\n+\n+        sb.append(\"\");\n+        assertEquals(\"NULLNULLfooNULL\", sb.toString());\n+\n+        sb.append(\"bar\");\n+        assertEquals(\"NULLNULLfooNULLbar\", sb.toString());\n+\n+        sb.append((StringBuffer) null);\n+        assertEquals(\"NULLNULLfooNULLbarNULL\", sb.toString());\n+\n+        sb.append(new StringBuffer(\"baz\"));\n+        assertEquals(\"NULLNULLfooNULLbarNULLbaz\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_Object() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendNull();\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.append((Object) null);\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.append(FOO);\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append((StringBuffer) null);\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(new StringBuffer(\"baz\"));\n+        assertEquals(\"foobaz\", sb.toString());\n+\n+        sb.append(new StrBuilder(\"yes\"));\n+        assertEquals(\"foobazyes\", sb.toString());\n+\n+        sb.append((CharSequence) \"Seq\");\n+        assertEquals(\"foobazyesSeq\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_String() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"NULL\").append((String) null);\n+        assertEquals(\"NULL\", sb.toString());\n+\n+        sb = new StrBuilder();\n+        sb.append(\"foo\");\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(\"\");\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(\"bar\");\n+        assertEquals(\"foobar\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_String_int_int() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"NULL\").append((String) null, 0, 1);\n+        assertEquals(\"NULL\", sb.toString());\n+\n+        sb = new StrBuilder();\n+        sb.append(\"foo\", 0, 3);\n+        assertEquals(\"foo\", sb.toString());\n+\n+        try {\n+            sb.append(\"bar\", -1, 1);\n+            fail(\"append(char[], -1,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(\"bar\", 3, 1);\n+            fail(\"append(char[], 3,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(\"bar\", 1, -1);\n+            fail(\"append(char[],, -1) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(\"bar\", 1, 3);\n+            fail(\"append(char[], 1, 3) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(\"bar\", -1, 3);\n+            fail(\"append(char[], -1, 3) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(\"bar\", 4, 0);\n+            fail(\"append(char[], 4, 0) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.append(\"bar\", 3, 0);\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(\"abcbardef\", 3, 3);\n+        assertEquals(\"foobar\", sb.toString());\n+\n+        sb.append( (CharSequence)\"abcbardef\", 4, 3);\n+        assertEquals(\"foobarard\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_StringBuffer() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"NULL\").append((StringBuffer) null);\n+        assertEquals(\"NULL\", sb.toString());\n+\n+        sb = new StrBuilder();\n+        sb.append(new StringBuffer(\"foo\"));\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(new StringBuffer(\"\"));\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(new StringBuffer(\"bar\"));\n+        assertEquals(\"foobar\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_StringBuffer_int_int() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"NULL\").append((StringBuffer) null, 0, 1);\n+        assertEquals(\"NULL\", sb.toString());\n+\n+        sb = new StrBuilder();\n+        sb.append(new StringBuffer(\"foo\"), 0, 3);\n+        assertEquals(\"foo\", sb.toString());\n+\n+        try {\n+            sb.append(new StringBuffer(\"bar\"), -1, 1);\n+            fail(\"append(char[], -1,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new StringBuffer(\"bar\"), 3, 1);\n+            fail(\"append(char[], 3,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new StringBuffer(\"bar\"), 1, -1);\n+            fail(\"append(char[],, -1) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new StringBuffer(\"bar\"), 1, 3);\n+            fail(\"append(char[], 1, 3) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new StringBuffer(\"bar\"), -1, 3);\n+            fail(\"append(char[], -1, 3) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new StringBuffer(\"bar\"), 4, 0);\n+            fail(\"append(char[], 4, 0) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.append(new StringBuffer(\"bar\"), 3, 0);\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(new StringBuffer(\"abcbardef\"), 3, 3);\n+        assertEquals(\"foobar\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_StrBuilder() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"NULL\").append((StrBuilder) null);\n+        assertEquals(\"NULL\", sb.toString());\n+\n+        sb = new StrBuilder();\n+        sb.append(new StrBuilder(\"foo\"));\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(new StrBuilder(\"\"));\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(new StrBuilder(\"bar\"));\n+        assertEquals(\"foobar\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_StrBuilder_int_int() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"NULL\").append((StrBuilder) null, 0, 1);\n+        assertEquals(\"NULL\", sb.toString());\n+\n+        sb = new StrBuilder();\n+        sb.append(new StrBuilder(\"foo\"), 0, 3);\n+        assertEquals(\"foo\", sb.toString());\n+\n+        try {\n+            sb.append(new StrBuilder(\"bar\"), -1, 1);\n+            fail(\"append(char[], -1,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new StrBuilder(\"bar\"), 3, 1);\n+            fail(\"append(char[], 3,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new StrBuilder(\"bar\"), 1, -1);\n+            fail(\"append(char[],, -1) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new StrBuilder(\"bar\"), 1, 3);\n+            fail(\"append(char[], 1, 3) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new StrBuilder(\"bar\"), -1, 3);\n+            fail(\"append(char[], -1, 3) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new StrBuilder(\"bar\"), 4, 0);\n+            fail(\"append(char[], 4, 0) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.append(new StrBuilder(\"bar\"), 3, 0);\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(new StrBuilder(\"abcbardef\"), 3, 3);\n+        assertEquals(\"foobar\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_CharArray() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"NULL\").append((char[]) null);\n+        assertEquals(\"NULL\", sb.toString());\n+\n+        sb = new StrBuilder();\n+        sb.append(new char[0]);\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.append(new char[]{'f', 'o', 'o'});\n+        assertEquals(\"foo\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_CharArray_int_int() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"NULL\").append((char[]) null, 0, 1);\n+        assertEquals(\"NULL\", sb.toString());\n+\n+        sb = new StrBuilder();\n+        sb.append(new char[]{'f', 'o', 'o'}, 0, 3);\n+        assertEquals(\"foo\", sb.toString());\n+\n+        try {\n+            sb.append(new char[]{'b', 'a', 'r'}, -1, 1);\n+            fail(\"append(char[], -1,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new char[]{'b', 'a', 'r'}, 3, 1);\n+            fail(\"append(char[], 3,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new char[]{'b', 'a', 'r'}, 1, -1);\n+            fail(\"append(char[],, -1) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new char[]{'b', 'a', 'r'}, 1, 3);\n+            fail(\"append(char[], 1, 3) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new char[]{'b', 'a', 'r'}, -1, 3);\n+            fail(\"append(char[], -1, 3) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new char[]{'b', 'a', 'r'}, 4, 0);\n+            fail(\"append(char[], 4, 0) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.append(new char[]{'b', 'a', 'r'}, 3, 0);\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(new char[]{'a', 'b', 'c', 'b', 'a', 'r', 'd', 'e', 'f'}, 3, 3);\n+        assertEquals(\"foobar\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_Boolean() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.append(true);\n+        assertEquals(\"true\", sb.toString());\n+\n+        sb.append(false);\n+        assertEquals(\"truefalse\", sb.toString());\n+\n+        sb.append('!');\n+        assertEquals(\"truefalse!\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_PrimitiveNumber() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.append(0);\n+        assertEquals(\"0\", sb.toString());\n+\n+        sb.append(1L);\n+        assertEquals(\"01\", sb.toString());\n+\n+        sb.append(2.3f);\n+        assertEquals(\"012.3\", sb.toString());\n+\n+        sb.append(4.5d);\n+        assertEquals(\"012.34.5\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendln_Object() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendln((Object) null);\n+        assertEquals(\"\" + SEP, sb.toString());\n+\n+        sb.appendln(FOO);\n+        assertEquals(SEP + \"foo\" + SEP, sb.toString());\n+\n+        sb.appendln(new Integer(6));\n+        assertEquals(SEP + \"foo\" + SEP + \"6\" + SEP, sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendln_String() {\n+        final int[] count = new int[2];\n+        StrBuilder sb = new StrBuilder() {\n+            @Override\n+            public StrBuilder append(String str) {\n+                count[0]++;\n+                return super.append(str);\n+            }\n+            @Override\n+            public StrBuilder appendNewLine() {\n+                count[1]++;\n+                return super.appendNewLine();\n+            }\n+        };\n+        sb.appendln(\"foo\");\n+        assertEquals(\"foo\" + SEP, sb.toString());\n+        assertEquals(2, count[0]);  // appendNewLine() calls append(String)\n+        assertEquals(1, count[1]);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendln_String_int_int() {\n+        final int[] count = new int[2];\n+        StrBuilder sb = new StrBuilder() {\n+            @Override\n+            public StrBuilder append(String str, int startIndex, int length) {\n+                count[0]++;\n+                return super.append(str, startIndex, length);\n+            }\n+            @Override\n+            public StrBuilder appendNewLine() {\n+                count[1]++;\n+                return super.appendNewLine();\n+            }\n+        };\n+        sb.appendln(\"foo\", 0, 3);\n+        assertEquals(\"foo\" + SEP, sb.toString());\n+        assertEquals(1, count[0]);\n+        assertEquals(1, count[1]);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendln_StringBuffer() {\n+        final int[] count = new int[2];\n+        StrBuilder sb = new StrBuilder() {\n+            @Override\n+            public StrBuilder append(StringBuffer str) {\n+                count[0]++;\n+                return super.append(str);\n+            }\n+            @Override\n+            public StrBuilder appendNewLine() {\n+                count[1]++;\n+                return super.appendNewLine();\n+            }\n+        };\n+        sb.appendln(new StringBuffer(\"foo\"));\n+        assertEquals(\"foo\" + SEP, sb.toString());\n+        assertEquals(1, count[0]);\n+        assertEquals(1, count[1]);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendln_StringBuffer_int_int() {\n+        final int[] count = new int[2];\n+        StrBuilder sb = new StrBuilder() {\n+            @Override\n+            public StrBuilder append(StringBuffer str, int startIndex, int length) {\n+                count[0]++;\n+                return super.append(str, startIndex, length);\n+            }\n+            @Override\n+            public StrBuilder appendNewLine() {\n+                count[1]++;\n+                return super.appendNewLine();\n+            }\n+        };\n+        sb.appendln(new StringBuffer(\"foo\"), 0, 3);\n+        assertEquals(\"foo\" + SEP, sb.toString());\n+        assertEquals(1, count[0]);\n+        assertEquals(1, count[1]);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendln_StrBuilder() {\n+        final int[] count = new int[2];\n+        StrBuilder sb = new StrBuilder() {\n+            @Override\n+            public StrBuilder append(StrBuilder str) {\n+                count[0]++;\n+                return super.append(str);\n+            }\n+            @Override\n+            public StrBuilder appendNewLine() {\n+                count[1]++;\n+                return super.appendNewLine();\n+            }\n+        };\n+        sb.appendln(new StrBuilder(\"foo\"));\n+        assertEquals(\"foo\" + SEP, sb.toString());\n+        assertEquals(1, count[0]);\n+        assertEquals(1, count[1]);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendln_StrBuilder_int_int() {\n+        final int[] count = new int[2];\n+        StrBuilder sb = new StrBuilder() {\n+            @Override\n+            public StrBuilder append(StrBuilder str, int startIndex, int length) {\n+                count[0]++;\n+                return super.append(str, startIndex, length);\n+            }\n+            @Override\n+            public StrBuilder appendNewLine() {\n+                count[1]++;\n+                return super.appendNewLine();\n+            }\n+        };\n+        sb.appendln(new StrBuilder(\"foo\"), 0, 3);\n+        assertEquals(\"foo\" + SEP, sb.toString());\n+        assertEquals(1, count[0]);\n+        assertEquals(1, count[1]);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendln_CharArray() {\n+        final int[] count = new int[2];\n+        StrBuilder sb = new StrBuilder() {\n+            @Override\n+            public StrBuilder append(char[] str) {\n+                count[0]++;\n+                return super.append(str);\n+            }\n+            @Override\n+            public StrBuilder appendNewLine() {\n+                count[1]++;\n+                return super.appendNewLine();\n+            }\n+        };\n+        sb.appendln(\"foo\".toCharArray());\n+        assertEquals(\"foo\" + SEP, sb.toString());\n+        assertEquals(1, count[0]);\n+        assertEquals(1, count[1]);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendln_CharArray_int_int() {\n+        final int[] count = new int[2];\n+        StrBuilder sb = new StrBuilder() {\n+            @Override\n+            public StrBuilder append(char[] str, int startIndex, int length) {\n+                count[0]++;\n+                return super.append(str, startIndex, length);\n+            }\n+            @Override\n+            public StrBuilder appendNewLine() {\n+                count[1]++;\n+                return super.appendNewLine();\n+            }\n+        };\n+        sb.appendln(\"foo\".toCharArray(), 0, 3);\n+        assertEquals(\"foo\" + SEP, sb.toString());\n+        assertEquals(1, count[0]);\n+        assertEquals(1, count[1]);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendln_Boolean() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendln(true);\n+        assertEquals(\"true\" + SEP, sb.toString());\n+        \n+        sb.clear();\n+        sb.appendln(false);\n+        assertEquals(\"false\" + SEP, sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendln_PrimitiveNumber() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendln(0);\n+        assertEquals(\"0\" + SEP, sb.toString());\n+        \n+        sb.clear();\n+        sb.appendln(1L);\n+        assertEquals(\"1\" + SEP, sb.toString());\n+        \n+        sb.clear();\n+        sb.appendln(2.3f);\n+        assertEquals(\"2.3\" + SEP, sb.toString());\n+        \n+        sb.clear();\n+        sb.appendln(4.5d);\n+        assertEquals(\"4.5\" + SEP, sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendPadding() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.append(\"foo\");\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.appendPadding(-1, '-');\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.appendPadding(0, '-');\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.appendPadding(1, '-');\n+        assertEquals(\"foo-\", sb.toString());\n+\n+        sb.appendPadding(16, '-');\n+        assertEquals(20, sb.length());\n+        //            12345678901234567890\n+        assertEquals(\"foo-----------------\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendFixedWidthPadLeft() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendFixedWidthPadLeft(\"foo\", -1, '-');\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(\"foo\", 0, '-');\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(\"foo\", 1, '-');\n+        assertEquals(\"o\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(\"foo\", 2, '-');\n+        assertEquals(\"oo\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(\"foo\", 3, '-');\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(\"foo\", 4, '-');\n+        assertEquals(\"-foo\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(\"foo\", 10, '-');\n+        assertEquals(10, sb.length());\n+        //            1234567890\n+        assertEquals(\"-------foo\", sb.toString());\n+\n+        sb.clear();\n+        sb.setNullText(\"null\");\n+        sb.appendFixedWidthPadLeft(null, 5, '-');\n+        assertEquals(\"-null\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendFixedWidthPadLeft_int() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendFixedWidthPadLeft(123, -1, '-');\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(123, 0, '-');\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(123, 1, '-');\n+        assertEquals(\"3\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(123, 2, '-');\n+        assertEquals(\"23\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(123, 3, '-');\n+        assertEquals(\"123\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(123, 4, '-');\n+        assertEquals(\"-123\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(123, 10, '-');\n+        assertEquals(10, sb.length());\n+        //            1234567890\n+        assertEquals(\"-------123\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendFixedWidthPadRight() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendFixedWidthPadRight(\"foo\", -1, '-');\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(\"foo\", 0, '-');\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(\"foo\", 1, '-');\n+        assertEquals(\"f\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(\"foo\", 2, '-');\n+        assertEquals(\"fo\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(\"foo\", 3, '-');\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(\"foo\", 4, '-');\n+        assertEquals(\"foo-\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(\"foo\", 10, '-');\n+        assertEquals(10, sb.length());\n+        //            1234567890\n+        assertEquals(\"foo-------\", sb.toString());\n+\n+        sb.clear();\n+        sb.setNullText(\"null\");\n+        sb.appendFixedWidthPadRight(null, 5, '-');\n+        assertEquals(\"null-\", sb.toString());\n+    }\n+\n+    // See: http://issues.apache.org/jira/browse/LANG-299\n+    public void testLang299() {\n+        StrBuilder sb = new StrBuilder(1);\n+        sb.appendFixedWidthPadRight(\"foo\", 1, '-');\n+        assertEquals(\"f\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendFixedWidthPadRight_int() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendFixedWidthPadRight(123, -1, '-');\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(123, 0, '-');\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(123, 1, '-');\n+        assertEquals(\"1\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(123, 2, '-');\n+        assertEquals(\"12\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(123, 3, '-');\n+        assertEquals(\"123\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(123, 4, '-');\n+        assertEquals(\"123-\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(123, 10, '-');\n+        assertEquals(10, sb.length());\n+        //            1234567890\n+        assertEquals(\"123-------\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendAll_Array() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendAll((Object[]) null);\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendAll(new Object[0]);\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendAll(new Object[]{\"foo\", \"bar\", \"baz\"});\n+        assertEquals(\"foobarbaz\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendAll_Collection() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendAll((Collection<?>) null);\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendAll(Collections.EMPTY_LIST);\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendAll(Arrays.asList(new Object[]{\"foo\", \"bar\", \"baz\"}));\n+        assertEquals(\"foobarbaz\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendAll_Iterator() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendAll((Iterator<?>) null);\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendAll(Collections.EMPTY_LIST.iterator());\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendAll(Arrays.asList(new Object[]{\"foo\", \"bar\", \"baz\"}).iterator());\n+        assertEquals(\"foobarbaz\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendWithSeparators_Array() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendWithSeparators((Object[]) null, \",\");\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(new Object[0], \",\");\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(new Object[]{\"foo\", \"bar\", \"baz\"}, \",\");\n+        assertEquals(\"foo,bar,baz\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(new Object[]{\"foo\", \"bar\", \"baz\"}, null);\n+        assertEquals(\"foobarbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(new Object[]{\"foo\", null, \"baz\"}, \",\");\n+        assertEquals(\"foo,,baz\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendWithSeparators_Collection() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendWithSeparators((Collection<?>) null, \",\");\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(Collections.EMPTY_LIST, \",\");\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(Arrays.asList(new Object[]{\"foo\", \"bar\", \"baz\"}), \",\");\n+        assertEquals(\"foo,bar,baz\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(Arrays.asList(new Object[]{\"foo\", \"bar\", \"baz\"}), null);\n+        assertEquals(\"foobarbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(Arrays.asList(new Object[]{\"foo\", null, \"baz\"}), \",\");\n+        assertEquals(\"foo,,baz\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendWithSeparators_Iterator() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendWithSeparators((Iterator<?>) null, \",\");\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(Collections.EMPTY_LIST.iterator(), \",\");\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(Arrays.asList(new Object[]{\"foo\", \"bar\", \"baz\"}).iterator(), \",\");\n+        assertEquals(\"foo,bar,baz\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(Arrays.asList(new Object[]{\"foo\", \"bar\", \"baz\"}).iterator(), null);\n+        assertEquals(\"foobarbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(Arrays.asList(new Object[]{\"foo\", null, \"baz\"}).iterator(), \",\");\n+        assertEquals(\"foo,,baz\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendWithSeparatorsWithNullText() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"null\");\n+        sb.appendWithSeparators(new Object[]{\"foo\", null, \"baz\"}, \",\");\n+        assertEquals(\"foo,null,baz\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(Arrays.asList(new Object[]{\"foo\", null, \"baz\"}), \",\");\n+        assertEquals(\"foo,null,baz\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendSeparator_String() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendSeparator(\",\");  // no effect\n+        assertEquals(\"\", sb.toString());\n+        sb.append(\"foo\");\n+        assertEquals(\"foo\", sb.toString());\n+        sb.appendSeparator(\",\");\n+        assertEquals(\"foo,\", sb.toString());\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testAppendSeparator_String_String() {\n+        StrBuilder sb = new StrBuilder();\n+        final String startSeparator = \"order by \";\n+        final String standardSeparator = \",\";\n+        final String foo = \"foo\";\n+        sb.appendSeparator(null, null);\n+        assertEquals(\"\", sb.toString());\n+        sb.appendSeparator(standardSeparator, null);\n+        assertEquals(\"\", sb.toString());\n+        sb.appendSeparator(standardSeparator, startSeparator); \n+        assertEquals(startSeparator, sb.toString());\n+        sb.appendSeparator(null, null); \n+        assertEquals(startSeparator, sb.toString());\n+        sb.appendSeparator(null, startSeparator); \n+        assertEquals(startSeparator, sb.toString());\n+        sb.append(foo);\n+        assertEquals(startSeparator + foo, sb.toString());\n+        sb.appendSeparator(standardSeparator, startSeparator);\n+        assertEquals(startSeparator + foo + standardSeparator, sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendSeparator_char() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendSeparator(',');  // no effect\n+        assertEquals(\"\", sb.toString());\n+        sb.append(\"foo\");\n+        assertEquals(\"foo\", sb.toString());\n+        sb.appendSeparator(',');\n+        assertEquals(\"foo,\", sb.toString());\n+    }\n+    public void testAppendSeparator_char_char() {\n+        StrBuilder sb = new StrBuilder();\n+        final char startSeparator = ':';\n+        final char standardSeparator = ',';\n+        final String foo = \"foo\";\n+        sb.appendSeparator(standardSeparator, startSeparator);  // no effect\n+        assertEquals(String.valueOf(startSeparator), sb.toString());\n+        sb.append(foo);\n+        assertEquals(String.valueOf(startSeparator) + foo, sb.toString());\n+        sb.appendSeparator(standardSeparator, startSeparator);\n+        assertEquals(String.valueOf(startSeparator) + foo + standardSeparator, sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendSeparator_String_int() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendSeparator(\",\", 0);  // no effect\n+        assertEquals(\"\", sb.toString());\n+        sb.append(\"foo\");\n+        assertEquals(\"foo\", sb.toString());\n+        sb.appendSeparator(\",\", 1);\n+        assertEquals(\"foo,\", sb.toString());\n+        \n+        sb.appendSeparator(\",\", -1);  // no effect\n+        assertEquals(\"foo,\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendSeparator_char_int() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendSeparator(',', 0);  // no effect\n+        assertEquals(\"\", sb.toString());\n+        sb.append(\"foo\");\n+        assertEquals(\"foo\", sb.toString());\n+        sb.appendSeparator(',', 1);\n+        assertEquals(\"foo,\", sb.toString());\n+        \n+        sb.appendSeparator(',', -1);  // no effect\n+        assertEquals(\"foo,\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testInsert() {\n+\n+        StrBuilder sb = new StrBuilder();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, FOO);\n+            fail(\"insert(-1, Object) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, FOO);\n+            fail(\"insert(7, Object) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, (Object) null);\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        sb.insert(0, FOO);\n+        assertEquals(\"foobarbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, \"foo\");\n+            fail(\"insert(-1, String) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, \"foo\");\n+            fail(\"insert(7, String) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, (String) null);\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        sb.insert(0, \"foo\");\n+        assertEquals(\"foobarbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, new char[]{'f', 'o', 'o'});\n+            fail(\"insert(-1, char[]) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, new char[]{'f', 'o', 'o'});\n+            fail(\"insert(7, char[]) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, (char[]) null);\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        sb.insert(0, new char[0]);\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        sb.insert(0, new char[]{'f', 'o', 'o'});\n+        assertEquals(\"foobarbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3);\n+            fail(\"insert(-1, char[], 3, 3) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3);\n+            fail(\"insert(7, char[], 3, 3) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, (char[]) null, 0, 0);\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        sb.insert(0, new char[0], 0, 0);\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, -1, 3);\n+            fail(\"insert(0, char[], -1, 3) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 10, 3);\n+            fail(\"insert(0, char[], 10, 3) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, -1);\n+            fail(\"insert(0, char[], 0, -1) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 10);\n+            fail(\"insert(0, char[], 0, 10) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 0);\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3);\n+        assertEquals(\"foobarbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, true);\n+            fail(\"insert(-1, boolean) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, true);\n+            fail(\"insert(7, boolean) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, true);\n+        assertEquals(\"truebarbaz\", sb.toString());\n+\n+        sb.insert(0, false);\n+        assertEquals(\"falsetruebarbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, '!');\n+            fail(\"insert(-1, char) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, '!');\n+            fail(\"insert(7, char) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, '!');\n+        assertEquals(\"!barbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, 0);\n+            fail(\"insert(-1, int) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, 0);\n+            fail(\"insert(7, int) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, '0');\n+        assertEquals(\"0barbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, 1L);\n+            fail(\"insert(-1, long) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, 1L);\n+            fail(\"insert(7, long) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, 1L);\n+        assertEquals(\"1barbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, 2.3F);\n+            fail(\"insert(-1, float) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, 2.3F);\n+            fail(\"insert(7, float) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, 2.3F);\n+        assertEquals(\"2.3barbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, 4.5D);\n+            fail(\"insert(-1, double) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, 4.5D);\n+            fail(\"insert(7, double) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, 4.5D);\n+        assertEquals(\"4.5barbaz\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testInsertWithNullText() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"null\");\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, FOO);\n+            fail(\"insert(-1, Object) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, FOO);\n+            fail(\"insert(7, Object) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, (Object) null);\n+        assertEquals(\"nullbarbaz\", sb.toString());\n+\n+        sb.insert(0, FOO);\n+        assertEquals(\"foonullbarbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, \"foo\");\n+            fail(\"insert(-1, String) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, \"foo\");\n+            fail(\"insert(7, String) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, (String) null);\n+        assertEquals(\"nullbarbaz\", sb.toString());\n+\n+        sb.insert(0, \"foo\");\n+        assertEquals(\"foonullbarbaz\", sb.toString());\n+\n+        sb.insert(0, (char[]) null);\n+        assertEquals(\"nullfoonullbarbaz\", sb.toString());\n+\n+        sb.insert(0, (char[]) null, 0, 0);\n+        assertEquals(\"nullnullfoonullbarbaz\", sb.toString());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/text/StrBuilderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text;\n+\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.util.Arrays;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+\n+/**\n+ * Unit tests for {@link org.apache.commons.lang.text.StrBuilder}.\n+ * \n+ * @author Michael Heuer\n+ * @version $Id$\n+ */\n+public class StrBuilderTest extends TestCase {\n+\n+    /**\n+     * Main method.\n+     * \n+     * @param args  command line arguments, ignored\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Return a new test suite containing this test case.\n+     * \n+     * @return a new test suite containing this test case\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StrBuilderTest.class);\n+        suite.setName(\"StrBuilder Tests\");\n+        return suite;\n+    }\n+\n+    /**\n+     * Create a new test case with the specified name.\n+     * \n+     * @param name\n+     *            name\n+     */\n+    public StrBuilderTest(String name) {\n+        super(name);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructors() {\n+        StrBuilder sb0 = new StrBuilder();\n+        assertEquals(32, sb0.capacity());\n+        assertEquals(0, sb0.length());\n+        assertEquals(0, sb0.size());\n+\n+        StrBuilder sb1 = new StrBuilder(32);\n+        assertEquals(32, sb1.capacity());\n+        assertEquals(0, sb1.length());\n+        assertEquals(0, sb1.size());\n+\n+        StrBuilder sb2 = new StrBuilder(0);\n+        assertEquals(32, sb2.capacity());\n+        assertEquals(0, sb2.length());\n+        assertEquals(0, sb2.size());\n+\n+        StrBuilder sb3 = new StrBuilder(-1);\n+        assertEquals(32, sb3.capacity());\n+        assertEquals(0, sb3.length());\n+        assertEquals(0, sb3.size());\n+\n+        StrBuilder sb4 = new StrBuilder(1);\n+        assertEquals(1, sb4.capacity());\n+        assertEquals(0, sb4.length());\n+        assertEquals(0, sb4.size());\n+\n+        StrBuilder sb5 = new StrBuilder((String) null);\n+        assertEquals(32, sb5.capacity());\n+        assertEquals(0, sb5.length());\n+        assertEquals(0, sb5.size());\n+\n+        StrBuilder sb6 = new StrBuilder(\"\");\n+        assertEquals(32, sb6.capacity());\n+        assertEquals(0, sb6.length());\n+        assertEquals(0, sb6.size());\n+\n+        StrBuilder sb7 = new StrBuilder(\"foo\");\n+        assertEquals(35, sb7.capacity());\n+        assertEquals(3, sb7.length());\n+        assertEquals(3, sb7.size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testChaining() {\n+        StrBuilder sb = new StrBuilder();\n+        assertSame(sb, sb.setNewLineText(null));\n+        assertSame(sb, sb.setNullText(null));\n+        assertSame(sb, sb.setLength(1));\n+        assertSame(sb, sb.setCharAt(0, 'a'));\n+        assertSame(sb, sb.ensureCapacity(0));\n+        assertSame(sb, sb.minimizeCapacity());\n+        assertSame(sb, sb.clear());\n+        assertSame(sb, sb.reverse());\n+        assertSame(sb, sb.trim());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetSetNewLineText() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(null, sb.getNewLineText());\n+\n+        sb.setNewLineText(\"#\");\n+        assertEquals(\"#\", sb.getNewLineText());\n+\n+        sb.setNewLineText(\"\");\n+        assertEquals(\"\", sb.getNewLineText());\n+\n+        sb.setNewLineText((String) null);\n+        assertEquals(null, sb.getNewLineText());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetSetNullText() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(null, sb.getNullText());\n+\n+        sb.setNullText(\"null\");\n+        assertEquals(\"null\", sb.getNullText());\n+\n+        sb.setNullText(\"\");\n+        assertEquals(null, sb.getNullText());\n+\n+        sb.setNullText(\"NULL\");\n+        assertEquals(\"NULL\", sb.getNullText());\n+\n+        sb.setNullText((String) null);\n+        assertEquals(null, sb.getNullText());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCapacityAndLength() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(32, sb.capacity());\n+        assertEquals(0, sb.length());\n+        assertEquals(0, sb.size());\n+        assertTrue(sb.isEmpty());\n+\n+        sb.minimizeCapacity();\n+        assertEquals(0, sb.capacity());\n+        assertEquals(0, sb.length());\n+        assertEquals(0, sb.size());\n+        assertTrue(sb.isEmpty());\n+\n+        sb.ensureCapacity(32);\n+        assertTrue(sb.capacity() >= 32);\n+        assertEquals(0, sb.length());\n+        assertEquals(0, sb.size());\n+        assertTrue(sb.isEmpty());\n+\n+        sb.append(\"foo\");\n+        assertTrue(sb.capacity() >= 32);\n+        assertEquals(3, sb.length());\n+        assertEquals(3, sb.size());\n+        assertTrue(sb.isEmpty() == false);\n+\n+        sb.clear();\n+        assertTrue(sb.capacity() >= 32);\n+        assertEquals(0, sb.length());\n+        assertEquals(0, sb.size());\n+        assertTrue(sb.isEmpty());\n+\n+        sb.append(\"123456789012345678901234567890123\");\n+        assertTrue(sb.capacity() > 32);\n+        assertEquals(33, sb.length());\n+        assertEquals(33, sb.size());\n+        assertTrue(sb.isEmpty() == false);\n+\n+        sb.ensureCapacity(16);\n+        assertTrue(sb.capacity() > 16);\n+        assertEquals(33, sb.length());\n+        assertEquals(33, sb.size());\n+        assertTrue(sb.isEmpty() == false);\n+\n+        sb.minimizeCapacity();\n+        assertEquals(33, sb.capacity());\n+        assertEquals(33, sb.length());\n+        assertEquals(33, sb.size());\n+        assertTrue(sb.isEmpty() == false);\n+\n+        try {\n+            sb.setLength(-1);\n+            fail(\"setLength(-1) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.setLength(33);\n+        assertEquals(33, sb.capacity());\n+        assertEquals(33, sb.length());\n+        assertEquals(33, sb.size());\n+        assertTrue(sb.isEmpty() == false);\n+\n+        sb.setLength(16);\n+        assertTrue(sb.capacity() >= 16);\n+        assertEquals(16, sb.length());\n+        assertEquals(16, sb.size());\n+        assertEquals(\"1234567890123456\", sb.toString());\n+        assertTrue(sb.isEmpty() == false);\n+\n+        sb.setLength(32);\n+        assertTrue(sb.capacity() >= 32);\n+        assertEquals(32, sb.length());\n+        assertEquals(32, sb.size());\n+        assertEquals(\"1234567890123456\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", sb.toString());\n+        assertTrue(sb.isEmpty() == false);\n+\n+        sb.setLength(0);\n+        assertTrue(sb.capacity() >= 32);\n+        assertEquals(0, sb.length());\n+        assertEquals(0, sb.size());\n+        assertTrue(sb.isEmpty());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testLength() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(0, sb.length());\n+        \n+        sb.append(\"Hello\");\n+        assertEquals(5, sb.length());\n+    }\n+\n+    public void testSetLength() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.append(\"Hello\");\n+        sb.setLength(2);  // shorten\n+        assertEquals(\"He\", sb.toString());\n+        sb.setLength(2);  // no change\n+        assertEquals(\"He\", sb.toString());\n+        sb.setLength(3);  // lengthen\n+        assertEquals(\"He\\0\", sb.toString());\n+\n+        try {\n+            sb.setLength(-1);\n+            fail(\"setLength(-1) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCapacity() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(sb.buffer.length, sb.capacity());\n+        \n+        sb.append(\"HelloWorldHelloWorldHelloWorldHelloWorld\");\n+        assertEquals(sb.buffer.length, sb.capacity());\n+    }\n+\n+    public void testEnsureCapacity() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.ensureCapacity(2);\n+        assertEquals(true, sb.capacity() >= 2);\n+        \n+        sb.ensureCapacity(-1);\n+        assertEquals(true, sb.capacity() >= 0);\n+        \n+        sb.append(\"HelloWorld\");\n+        sb.ensureCapacity(40);\n+        assertEquals(true, sb.capacity() >= 40);\n+    }\n+\n+    public void testMinimizeCapacity() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.minimizeCapacity();\n+        assertEquals(0, sb.capacity());\n+        \n+        sb.append(\"HelloWorld\");\n+        sb.minimizeCapacity();\n+        assertEquals(10, sb.capacity());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSize() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(0, sb.size());\n+        \n+        sb.append(\"Hello\");\n+        assertEquals(5, sb.size());\n+    }\n+\n+    public void testIsEmpty() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(true, sb.isEmpty());\n+        \n+        sb.append(\"Hello\");\n+        assertEquals(false, sb.isEmpty());\n+        \n+        sb.clear();\n+        assertEquals(true, sb.isEmpty());\n+    }\n+\n+    public void testClear() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.append(\"Hello\");\n+        sb.clear();\n+        assertEquals(0, sb.length());\n+        assertEquals(true, sb.buffer.length >= 5);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCharAt() {\n+        StrBuilder sb = new StrBuilder();\n+        try {\n+            sb.charAt(0);\n+            fail(\"charAt(0) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        try {\n+            sb.charAt(-1);\n+            fail(\"charAt(-1) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        sb.append(\"foo\");\n+        assertEquals('f', sb.charAt(0));\n+        assertEquals('o', sb.charAt(1));\n+        assertEquals('o', sb.charAt(2));\n+        try {\n+            sb.charAt(-1);\n+            fail(\"charAt(-1) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        try {\n+            sb.charAt(3);\n+            fail(\"charAt(3) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSetCharAt() {\n+        StrBuilder sb = new StrBuilder();\n+        try {\n+            sb.setCharAt(0, 'f');\n+            fail(\"setCharAt(0,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        try {\n+            sb.setCharAt(-1, 'f');\n+            fail(\"setCharAt(-1,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        sb.append(\"foo\");\n+        sb.setCharAt(0, 'b');\n+        sb.setCharAt(1, 'a');\n+        sb.setCharAt(2, 'r');\n+        try {\n+            sb.setCharAt(3, '!');\n+            fail(\"setCharAt(3,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        assertEquals(\"bar\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDeleteCharAt() {\n+        StrBuilder sb = new StrBuilder(\"abc\");\n+        sb.deleteCharAt(0);\n+        assertEquals(\"bc\", sb.toString()); \n+        \n+        try {\n+            sb.deleteCharAt(1000);\n+            fail(\"Expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToCharArray() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, sb.toCharArray());\n+\n+        char[] a = sb.toCharArray();\n+        assertNotNull(\"toCharArray() result is null\", a);\n+        assertEquals(\"toCharArray() result is too large\", 0, a.length);\n+\n+        sb.append(\"junit\");\n+        a = sb.toCharArray();\n+        assertEquals(\"toCharArray() result incorrect length\", 5, a.length);\n+        assertTrue(\"toCharArray() result does not match\", Arrays.equals(\"junit\".toCharArray(), a));\n+    }\n+\n+    public void testToCharArrayIntInt() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, sb.toCharArray(0, 0));\n+\n+        sb.append(\"junit\");\n+        char[] a = sb.toCharArray(0, 20); // too large test\n+        assertEquals(\"toCharArray(int,int) result incorrect length\", 5, a.length);\n+        assertTrue(\"toCharArray(int,int) result does not match\", Arrays.equals(\"junit\".toCharArray(), a));\n+\n+        a = sb.toCharArray(0, 4);\n+        assertEquals(\"toCharArray(int,int) result incorrect length\", 4, a.length);\n+        assertTrue(\"toCharArray(int,int) result does not match\", Arrays.equals(\"juni\".toCharArray(), a));\n+\n+        a = sb.toCharArray(0, 4);\n+        assertEquals(\"toCharArray(int,int) result incorrect length\", 4, a.length);\n+        assertTrue(\"toCharArray(int,int) result does not match\", Arrays.equals(\"juni\".toCharArray(), a));\n+\n+        a = sb.toCharArray(0, 1);\n+        assertNotNull(\"toCharArray(int,int) result is null\", a);\n+\n+        try {\n+            sb.toCharArray(-1, 5);\n+            fail(\"no string index out of bound on -1\");\n+        } catch (IndexOutOfBoundsException e) {\n+        }\n+\n+        try {\n+            sb.toCharArray(6, 5);\n+            fail(\"no string index out of bound on -1\");\n+        } catch (IndexOutOfBoundsException e) {\n+        }\n+    }\n+\n+    public void testGetChars ( ) {\n+        StrBuilder sb = new StrBuilder();\n+        \n+        char[] input = new char[10];\n+        char[] a = sb.getChars(input);\n+        assertSame (input, a);\n+        assertTrue(Arrays.equals(new char[10], a));\n+        \n+        sb.append(\"junit\");\n+        a = sb.getChars(input);\n+        assertSame(input, a);\n+        assertTrue(Arrays.equals(new char[] {'j','u','n','i','t',0,0,0,0,0},a));\n+        \n+        a = sb.getChars(null);\n+        assertNotSame(input,a);\n+        assertEquals(5,a.length);\n+        assertTrue(Arrays.equals(\"junit\".toCharArray(),a));\n+        \n+        input = new char[5];\n+        a = sb.getChars(input);\n+        assertSame(input, a);\n+        \n+        input = new char[4];\n+        a = sb.getChars(input);\n+        assertNotSame(input, a);\n+    }\n+\n+    public void testGetCharsIntIntCharArrayInt( ) {\n+        StrBuilder sb = new StrBuilder();\n+               \n+        sb.append(\"junit\");\n+        char[] a = new char[5];\n+        sb.getChars(0,5,a,0);\n+        assertTrue(Arrays.equals(new char[] {'j','u','n','i','t'},a));\n+        \n+        a = new char[5];\n+        sb.getChars(0,2,a,3);\n+        assertTrue(Arrays.equals(new char[] {0,0,0,'j','u'},a));\n+        \n+        try {\n+            sb.getChars(-1,0,a,0);\n+            fail(\"no exception\");\n+        }\n+        catch (IndexOutOfBoundsException e) {\n+        }\n+        \n+        try {\n+            sb.getChars(0,-1,a,0);\n+            fail(\"no exception\");\n+        }\n+        catch (IndexOutOfBoundsException e) {\n+        }\n+        \n+        try {\n+            sb.getChars(0,20,a,0);\n+            fail(\"no exception\");\n+        }\n+        catch (IndexOutOfBoundsException e) {\n+        }\n+        \n+        try {\n+            sb.getChars(4,2,a,0);\n+            fail(\"no exception\");\n+        }\n+        catch (IndexOutOfBoundsException e) {\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDeleteIntInt() {\n+        StrBuilder sb = new StrBuilder(\"abc\");\n+        sb.delete(0, 1);\n+        assertEquals(\"bc\", sb.toString()); \n+        sb.delete(1, 2);\n+        assertEquals(\"b\", sb.toString());\n+        sb.delete(0, 1);\n+        assertEquals(\"\", sb.toString()); \n+        sb.delete(0, 1000);\n+        assertEquals(\"\", sb.toString()); \n+        \n+        try {\n+            sb.delete(1, 2);\n+            fail(\"Expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            sb.delete(-1, 1);\n+            fail(\"Expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        \n+        sb = new StrBuilder(\"anything\");\n+        try {\n+            sb.delete(2, 1);\n+            fail(\"Expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDeleteAll_char() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.deleteAll('X');\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.deleteAll('a');\n+        assertEquals(\"bcbccb\", sb.toString());\n+        sb.deleteAll('c');\n+        assertEquals(\"bbb\", sb.toString());\n+        sb.deleteAll('b');\n+        assertEquals(\"\", sb.toString());\n+\n+        sb = new StrBuilder(\"\");\n+        sb.deleteAll('b');\n+        assertEquals(\"\", sb.toString());\n+    }\n+\n+    public void testDeleteFirst_char() {\n+        StrBuilder sb = new StrBuilder(\"abcba\");\n+        sb.deleteFirst('X');\n+        assertEquals(\"abcba\", sb.toString());\n+        sb.deleteFirst('a');\n+        assertEquals(\"bcba\", sb.toString());\n+        sb.deleteFirst('c');\n+        assertEquals(\"bba\", sb.toString());\n+        sb.deleteFirst('b');\n+        assertEquals(\"ba\", sb.toString());\n+\n+        sb = new StrBuilder(\"\");\n+        sb.deleteFirst('b');\n+        assertEquals(\"\", sb.toString());\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testDeleteAll_String() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.deleteAll((String) null);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.deleteAll(\"\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        \n+        sb.deleteAll(\"X\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.deleteAll(\"a\");\n+        assertEquals(\"bcbccb\", sb.toString());\n+        sb.deleteAll(\"c\");\n+        assertEquals(\"bbb\", sb.toString());\n+        sb.deleteAll(\"b\");\n+        assertEquals(\"\", sb.toString());\n+\n+        sb = new StrBuilder(\"abcbccba\");\n+        sb.deleteAll(\"bc\");\n+        assertEquals(\"acba\", sb.toString());\n+\n+        sb = new StrBuilder(\"\");\n+        sb.deleteAll(\"bc\");\n+        assertEquals(\"\", sb.toString());\n+    }\n+\n+    public void testDeleteFirst_String() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.deleteFirst((String) null);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.deleteFirst(\"\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+\n+        sb.deleteFirst(\"X\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.deleteFirst(\"a\");\n+        assertEquals(\"bcbccba\", sb.toString());\n+        sb.deleteFirst(\"c\");\n+        assertEquals(\"bbccba\", sb.toString());\n+        sb.deleteFirst(\"b\");\n+        assertEquals(\"bccba\", sb.toString());\n+\n+        sb = new StrBuilder(\"abcbccba\");\n+        sb.deleteFirst(\"bc\");\n+        assertEquals(\"abccba\", sb.toString());\n+\n+        sb = new StrBuilder(\"\");\n+        sb.deleteFirst(\"bc\");\n+        assertEquals(\"\", sb.toString());\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testDeleteAll_StrMatcher() {\n+        StrBuilder sb = new StrBuilder(\"A0xA1A2yA3\");\n+        sb.deleteAll((StrMatcher) null);\n+        assertEquals(\"A0xA1A2yA3\", sb.toString());\n+        sb.deleteAll(A_NUMBER_MATCHER);\n+        assertEquals(\"xy\", sb.toString());\n+\n+        sb = new StrBuilder(\"Ax1\");\n+        sb.deleteAll(A_NUMBER_MATCHER);\n+        assertEquals(\"Ax1\", sb.toString());\n+\n+        sb = new StrBuilder(\"\");\n+        sb.deleteAll(A_NUMBER_MATCHER);\n+        assertEquals(\"\", sb.toString());\n+    }\n+\n+    public void testDeleteFirst_StrMatcher() {\n+        StrBuilder sb = new StrBuilder(\"A0xA1A2yA3\");\n+        sb.deleteFirst((StrMatcher) null);\n+        assertEquals(\"A0xA1A2yA3\", sb.toString());\n+        sb.deleteFirst(A_NUMBER_MATCHER);\n+        assertEquals(\"xA1A2yA3\", sb.toString());\n+\n+        sb = new StrBuilder(\"Ax1\");\n+        sb.deleteFirst(A_NUMBER_MATCHER);\n+        assertEquals(\"Ax1\", sb.toString());\n+\n+        sb = new StrBuilder(\"\");\n+        sb.deleteFirst(A_NUMBER_MATCHER);\n+        assertEquals(\"\", sb.toString());\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testReplace_int_int_String() {\n+        StrBuilder sb = new StrBuilder(\"abc\");\n+        sb.replace(0, 1, \"d\");\n+        assertEquals(\"dbc\", sb.toString());\n+        sb.replace(0, 1, \"aaa\");\n+        assertEquals(\"aaabc\", sb.toString());\n+        sb.replace(0, 3, \"\");\n+        assertEquals(\"bc\", sb.toString());\n+        sb.replace(1, 2, (String) null);\n+        assertEquals(\"b\", sb.toString());\n+        sb.replace(1, 1000, \"text\");\n+        assertEquals(\"btext\", sb.toString());\n+        sb.replace(0, 1000, \"text\");\n+        assertEquals(\"text\", sb.toString());\n+        \n+        sb = new StrBuilder(\"atext\");\n+        sb.replace(1, 1, \"ny\");\n+        assertEquals(\"anytext\", sb.toString());\n+        try {\n+            sb.replace(2, 1, \"anything\");\n+            fail(\"Expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        \n+        sb = new StrBuilder();\n+        try {\n+            sb.replace(1, 2, \"anything\");\n+            fail(\"Expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            sb.replace(-1, 1, \"anything\");\n+            fail(\"Expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReplaceAll_char_char() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.replaceAll('x', 'y');\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceAll('a', 'd');\n+        assertEquals(\"dbcbccbd\", sb.toString());\n+        sb.replaceAll('b', 'e');\n+        assertEquals(\"dececced\", sb.toString());\n+        sb.replaceAll('c', 'f');\n+        assertEquals(\"defeffed\", sb.toString());\n+        sb.replaceAll('d', 'd');\n+        assertEquals(\"defeffed\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReplaceFirst_char_char() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.replaceFirst('x', 'y');\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceFirst('a', 'd');\n+        assertEquals(\"dbcbccba\", sb.toString());\n+        sb.replaceFirst('b', 'e');\n+        assertEquals(\"decbccba\", sb.toString());\n+        sb.replaceFirst('c', 'f');\n+        assertEquals(\"defbccba\", sb.toString());\n+        sb.replaceFirst('d', 'd');\n+        assertEquals(\"defbccba\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReplaceAll_String_String() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.replaceAll((String) null, null);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceAll((String) null, \"anything\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceAll(\"\", null);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceAll(\"\", \"anything\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        \n+        sb.replaceAll(\"x\", \"y\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceAll(\"a\", \"d\");\n+        assertEquals(\"dbcbccbd\", sb.toString());\n+        sb.replaceAll(\"d\", null);\n+        assertEquals(\"bcbccb\", sb.toString());\n+        sb.replaceAll(\"cb\", \"-\");\n+        assertEquals(\"b-c-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"abcba\");\n+        sb.replaceAll(\"b\", \"xbx\");\n+        assertEquals(\"axbxcxbxa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"bb\");\n+        sb.replaceAll(\"b\", \"xbx\");\n+        assertEquals(\"xbxxbx\", sb.toString());\n+    }\n+\n+    public void testReplaceFirst_String_String() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.replaceFirst((String) null, null);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceFirst((String) null, \"anything\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceFirst(\"\", null);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceFirst(\"\", \"anything\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        \n+        sb.replaceFirst(\"x\", \"y\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceFirst(\"a\", \"d\");\n+        assertEquals(\"dbcbccba\", sb.toString());\n+        sb.replaceFirst(\"d\", null);\n+        assertEquals(\"bcbccba\", sb.toString());\n+        sb.replaceFirst(\"cb\", \"-\");\n+        assertEquals(\"b-ccba\", sb.toString());\n+        \n+        sb = new StrBuilder(\"abcba\");\n+        sb.replaceFirst(\"b\", \"xbx\");\n+        assertEquals(\"axbxcba\", sb.toString());\n+        \n+        sb = new StrBuilder(\"bb\");\n+        sb.replaceFirst(\"b\", \"xbx\");\n+        assertEquals(\"xbxb\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReplaceAll_StrMatcher_String() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.replaceAll((StrMatcher) null, null);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceAll((StrMatcher) null, \"anything\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceAll(StrMatcher.noneMatcher(), null);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceAll(StrMatcher.noneMatcher(), \"anything\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        \n+        sb.replaceAll(StrMatcher.charMatcher('x'), \"y\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceAll(StrMatcher.charMatcher('a'), \"d\");\n+        assertEquals(\"dbcbccbd\", sb.toString());\n+        sb.replaceAll(StrMatcher.charMatcher('d'), null);\n+        assertEquals(\"bcbccb\", sb.toString());\n+        sb.replaceAll(StrMatcher.stringMatcher(\"cb\"), \"-\");\n+        assertEquals(\"b-c-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"abcba\");\n+        sb.replaceAll(StrMatcher.charMatcher('b'), \"xbx\");\n+        assertEquals(\"axbxcxbxa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"bb\");\n+        sb.replaceAll(StrMatcher.charMatcher('b'), \"xbx\");\n+        assertEquals(\"xbxxbx\", sb.toString());\n+        \n+        sb = new StrBuilder(\"A1-A2A3-A4\");\n+        sb.replaceAll(A_NUMBER_MATCHER, \"***\");\n+        assertEquals(\"***-******-***\", sb.toString());\n+    }\n+\n+    public void testReplaceFirst_StrMatcher_String() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.replaceFirst((StrMatcher) null, null);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceFirst((StrMatcher) null, \"anything\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceFirst(StrMatcher.noneMatcher(), null);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceFirst(StrMatcher.noneMatcher(), \"anything\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        \n+        sb.replaceFirst(StrMatcher.charMatcher('x'), \"y\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceFirst(StrMatcher.charMatcher('a'), \"d\");\n+        assertEquals(\"dbcbccba\", sb.toString());\n+        sb.replaceFirst(StrMatcher.charMatcher('d'), null);\n+        assertEquals(\"bcbccba\", sb.toString());\n+        sb.replaceFirst(StrMatcher.stringMatcher(\"cb\"), \"-\");\n+        assertEquals(\"b-ccba\", sb.toString());\n+        \n+        sb = new StrBuilder(\"abcba\");\n+        sb.replaceFirst(StrMatcher.charMatcher('b'), \"xbx\");\n+        assertEquals(\"axbxcba\", sb.toString());\n+        \n+        sb = new StrBuilder(\"bb\");\n+        sb.replaceFirst(StrMatcher.charMatcher('b'), \"xbx\");\n+        assertEquals(\"xbxb\", sb.toString());\n+        \n+        sb = new StrBuilder(\"A1-A2A3-A4\");\n+        sb.replaceFirst(A_NUMBER_MATCHER, \"***\");\n+        assertEquals(\"***-A2A3-A4\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReplace_StrMatcher_String_int_int_int_VaryMatcher() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.replace((StrMatcher) null, \"x\", 0, sb.length(), -1);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        \n+        sb.replace(StrMatcher.charMatcher('a'), \"x\", 0, sb.length(), -1);\n+        assertEquals(\"xbcbccbx\", sb.toString());\n+        \n+        sb.replace(StrMatcher.stringMatcher(\"cb\"), \"x\", 0, sb.length(), -1);\n+        assertEquals(\"xbxcxx\", sb.toString());\n+        \n+        sb = new StrBuilder(\"A1-A2A3-A4\");\n+        sb.replace(A_NUMBER_MATCHER, \"***\", 0, sb.length(), -1);\n+        assertEquals(\"***-******-***\", sb.toString());\n+        \n+        sb = new StrBuilder();\n+        sb.replace(A_NUMBER_MATCHER, \"***\", 0, sb.length(), -1);\n+        assertEquals(\"\", sb.toString());\n+    }\n+\n+    public void testReplace_StrMatcher_String_int_int_int_VaryReplace() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.replace(StrMatcher.stringMatcher(\"cb\"), \"cb\", 0, sb.length(), -1);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        \n+        sb = new StrBuilder(\"abcbccba\");\n+        sb.replace(StrMatcher.stringMatcher(\"cb\"), \"-\", 0, sb.length(), -1);\n+        assertEquals(\"ab-c-a\", sb.toString());\n+        \n+        sb = new StrBuilder(\"abcbccba\");\n+        sb.replace(StrMatcher.stringMatcher(\"cb\"), \"+++\", 0, sb.length(), -1);\n+        assertEquals(\"ab+++c+++a\", sb.toString());\n+        \n+        sb = new StrBuilder(\"abcbccba\");\n+        sb.replace(StrMatcher.stringMatcher(\"cb\"), \"\", 0, sb.length(), -1);\n+        assertEquals(\"abca\", sb.toString());\n+        \n+        sb = new StrBuilder(\"abcbccba\");\n+        sb.replace(StrMatcher.stringMatcher(\"cb\"), null, 0, sb.length(), -1);\n+        assertEquals(\"abca\", sb.toString());\n+    }\n+\n+    public void testReplace_StrMatcher_String_int_int_int_VaryStartIndex() {\n+        StrBuilder sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, sb.length(), -1);\n+        assertEquals(\"-x--y-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 1, sb.length(), -1);\n+        assertEquals(\"aax--y-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 2, sb.length(), -1);\n+        assertEquals(\"aax--y-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 3, sb.length(), -1);\n+        assertEquals(\"aax--y-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 4, sb.length(), -1);\n+        assertEquals(\"aaxa-ay-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 5, sb.length(), -1);\n+        assertEquals(\"aaxaa-y-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 6, sb.length(), -1);\n+        assertEquals(\"aaxaaaay-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 7, sb.length(), -1);\n+        assertEquals(\"aaxaaaay-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 8, sb.length(), -1);\n+        assertEquals(\"aaxaaaay-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 9, sb.length(), -1);\n+        assertEquals(\"aaxaaaayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 10, sb.length(), -1);\n+        assertEquals(\"aaxaaaayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        try {\n+            sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 11, sb.length(), -1);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        assertEquals(\"aaxaaaayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        try {\n+            sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", -1, sb.length(), -1);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        assertEquals(\"aaxaaaayaa\", sb.toString());\n+    }\n+\n+    public void testReplace_StrMatcher_String_int_int_int_VaryEndIndex() {\n+        StrBuilder sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 0, -1);\n+        assertEquals(\"aaxaaaayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 2, -1);\n+        assertEquals(\"-xaaaayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 3, -1);\n+        assertEquals(\"-xaaaayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 4, -1);\n+        assertEquals(\"-xaaaayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 5, -1);\n+        assertEquals(\"-x-aayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 6, -1);\n+        assertEquals(\"-x-aayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 7, -1);\n+        assertEquals(\"-x--yaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 8, -1);\n+        assertEquals(\"-x--yaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 9, -1);\n+        assertEquals(\"-x--yaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 10, -1);\n+        assertEquals(\"-x--y-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 1000, -1);\n+        assertEquals(\"-x--y-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        try {\n+            sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 2, 1, -1);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        assertEquals(\"aaxaaaayaa\", sb.toString());\n+    }\n+\n+    public void testReplace_StrMatcher_String_int_int_int_VaryCount() {\n+        StrBuilder sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 10, -1);\n+        assertEquals(\"-x--y-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 10, 0);\n+        assertEquals(\"aaxaaaayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 10, 1);\n+        assertEquals(\"-xaaaayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 10, 2);\n+        assertEquals(\"-x-aayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 10, 3);\n+        assertEquals(\"-x--yaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 10, 4);\n+        assertEquals(\"-x--y-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 10, 5);\n+        assertEquals(\"-x--y-\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReverse() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(\"\", sb.reverse().toString());\n+        \n+        sb.clear().append(true);\n+        assertEquals(\"eurt\", sb.reverse().toString());\n+        assertEquals(\"true\", sb.reverse().toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTrim() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(\"\", sb.reverse().toString());\n+        \n+        sb.clear().append(\" \\u0000 \");\n+        assertEquals(\"\", sb.trim().toString());\n+        \n+        sb.clear().append(\" \\u0000 a b c\");\n+        assertEquals(\"a b c\", sb.trim().toString());\n+        \n+        sb.clear().append(\"a b c \\u0000 \");\n+        assertEquals(\"a b c\", sb.trim().toString());\n+        \n+        sb.clear().append(\" \\u0000 a b c \\u0000 \");\n+        assertEquals(\"a b c\", sb.trim().toString());\n+        \n+        sb.clear().append(\"a b c\");\n+        assertEquals(\"a b c\", sb.trim().toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testStartsWith() {\n+        StrBuilder sb = new StrBuilder();\n+        assertFalse(sb.startsWith(\"a\"));\n+        assertFalse(sb.startsWith(null));\n+        assertTrue(sb.startsWith(\"\"));\n+        sb.append(\"abc\");\n+        assertTrue(sb.startsWith(\"a\"));\n+        assertTrue(sb.startsWith(\"ab\"));\n+        assertTrue(sb.startsWith(\"abc\"));\n+        assertFalse(sb.startsWith(\"cba\"));\n+    }\n+\n+    public void testEndsWith() {\n+        StrBuilder sb = new StrBuilder();\n+        assertFalse(sb.endsWith(\"a\"));\n+        assertFalse(sb.endsWith(\"c\"));\n+        assertTrue(sb.endsWith(\"\"));\n+        assertFalse(sb.endsWith(null));\n+        sb.append(\"abc\");\n+        assertTrue(sb.endsWith(\"c\"));\n+        assertTrue(sb.endsWith(\"bc\"));\n+        assertTrue(sb.endsWith(\"abc\"));\n+        assertFalse(sb.endsWith(\"cba\"));\n+        assertFalse(sb.endsWith(\"abcd\"));\n+        assertFalse(sb.endsWith(\" abc\"));\n+        assertFalse(sb.endsWith(\"abc \"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSubSequenceIntInt() {\n+       StrBuilder sb = new StrBuilder (\"hello goodbye\");\n+       // Start index is negative\n+       try {\n+            sb.subSequence(-1, 5);\n+            fail();\n+        } catch (IndexOutOfBoundsException e) {}\n+        \n+        // End index is negative\n+       try {\n+            sb.subSequence(2, -1);\n+            fail();\n+        } catch (IndexOutOfBoundsException e) {}\n+        \n+        // End index greater than length()\n+        try {\n+            sb.subSequence(2, sb.length() + 1);\n+            fail();\n+        } catch (IndexOutOfBoundsException e) {}\n+        \n+        // Start index greater then end index\n+        try {\n+            sb.subSequence(3, 2);\n+            fail();\n+        } catch (IndexOutOfBoundsException e) {}\n+        \n+        // Normal cases\n+        assertEquals (\"hello\", sb.subSequence(0, 5));\n+        assertEquals (\"hello goodbye\".subSequence(0, 6), sb.subSequence(0, 6));\n+        assertEquals (\"goodbye\", sb.subSequence(6, 13));\n+        assertEquals (\"hello goodbye\".subSequence(6,13), sb.subSequence(6, 13));\n+    }\n+\n+    public void testSubstringInt() {\n+        StrBuilder sb = new StrBuilder (\"hello goodbye\");\n+        assertEquals (\"goodbye\", sb.substring(6));\n+        assertEquals (\"hello goodbye\".substring(6), sb.substring(6));\n+        assertEquals (\"hello goodbye\", sb.substring(0));\n+        assertEquals (\"hello goodbye\".substring(0), sb.substring(0));\n+        try {\n+            sb.substring(-1);\n+            fail ();\n+        } catch (IndexOutOfBoundsException e) {}\n+        \n+        try {\n+            sb.substring(15);\n+            fail ();\n+        } catch (IndexOutOfBoundsException e) {}\n+    \n+    }\n+    \n+    public void testSubstringIntInt() {\n+        StrBuilder sb = new StrBuilder (\"hello goodbye\");\n+        assertEquals (\"hello\", sb.substring(0, 5));\n+        assertEquals (\"hello goodbye\".substring(0, 6), sb.substring(0, 6));\n+        \n+        assertEquals (\"goodbye\", sb.substring(6, 13));\n+        assertEquals (\"hello goodbye\".substring(6,13), sb.substring(6, 13));\n+        \n+        assertEquals (\"goodbye\", sb.substring(6, 20));\n+        \n+        try {\n+            sb.substring(-1, 5);\n+            fail();\n+        } catch (IndexOutOfBoundsException e) {}\n+        \n+        try {\n+            sb.substring(15, 20);\n+            fail();\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testMidString() {\n+        StrBuilder sb = new StrBuilder(\"hello goodbye hello\");\n+        assertEquals(\"goodbye\", sb.midString(6, 7));\n+        assertEquals(\"hello\", sb.midString(0, 5));\n+        assertEquals(\"hello\", sb.midString(-5, 5));\n+        assertEquals(\"\", sb.midString(0, -1));\n+        assertEquals(\"\", sb.midString(20, 2));\n+        assertEquals(\"hello\", sb.midString(14, 22));\n+    }\n+\n+    public void testRightString() {\n+        StrBuilder sb = new StrBuilder(\"left right\");\n+        assertEquals(\"right\", sb.rightString(5));\n+        assertEquals(\"\", sb.rightString(0));\n+        assertEquals(\"\", sb.rightString(-5));\n+        assertEquals(\"left right\", sb.rightString(15));\n+    }\n+\n+    public void testLeftString() {\n+        StrBuilder sb = new StrBuilder(\"left right\");\n+        assertEquals(\"left\", sb.leftString(4));\n+        assertEquals(\"\", sb.leftString(0));\n+        assertEquals(\"\", sb.leftString(-5));\n+        assertEquals(\"left right\", sb.leftString(15));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testContains_char() {\n+        StrBuilder sb = new StrBuilder(\"abcdefghijklmnopqrstuvwxyz\");\n+        assertEquals(true, sb.contains('a'));\n+        assertEquals(true, sb.contains('o'));\n+        assertEquals(true, sb.contains('z'));\n+        assertEquals(false, sb.contains('1'));\n+    }\n+\n+    public void testContains_String() {\n+        StrBuilder sb = new StrBuilder(\"abcdefghijklmnopqrstuvwxyz\");\n+        assertEquals(true, sb.contains(\"a\"));\n+        assertEquals(true, sb.contains(\"pq\"));\n+        assertEquals(true, sb.contains(\"z\"));\n+        assertEquals(false, sb.contains(\"zyx\"));\n+        assertEquals(false, sb.contains((String) null));\n+    }\n+\n+    public void testContains_StrMatcher() {\n+        StrBuilder sb = new StrBuilder(\"abcdefghijklmnopqrstuvwxyz\");\n+        assertEquals(true, sb.contains(StrMatcher.charMatcher('a')));\n+        assertEquals(true, sb.contains(StrMatcher.stringMatcher(\"pq\")));\n+        assertEquals(true, sb.contains(StrMatcher.charMatcher('z')));\n+        assertEquals(false, sb.contains(StrMatcher.stringMatcher(\"zy\")));\n+        assertEquals(false, sb.contains((StrMatcher) null));\n+\n+        sb = new StrBuilder();\n+        assertEquals(false, sb.contains(A_NUMBER_MATCHER));\n+        sb.append(\"B A1 C\");\n+        assertEquals(true, sb.contains(A_NUMBER_MATCHER));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testIndexOf_char() {\n+        StrBuilder sb = new StrBuilder(\"abab\");\n+        assertEquals(0, sb.indexOf('a'));\n+        \n+        // should work like String#indexOf\n+        assertEquals(\"abab\".indexOf('a'), sb.indexOf('a'));\n+\n+        assertEquals(1, sb.indexOf('b'));\n+        assertEquals(\"abab\".indexOf('b'), sb.indexOf('b'));\n+\n+        assertEquals(-1, sb.indexOf('z'));\n+    }\n+\n+    public void testIndexOf_char_int() {\n+        StrBuilder sb = new StrBuilder(\"abab\");\n+        assertEquals(0, sb.indexOf('a', -1));\n+        assertEquals(0, sb.indexOf('a', 0));\n+        assertEquals(2, sb.indexOf('a', 1));\n+        assertEquals(-1, sb.indexOf('a', 4));\n+        assertEquals(-1, sb.indexOf('a', 5));\n+\n+        // should work like String#indexOf\n+        assertEquals(\"abab\".indexOf('a', 1), sb.indexOf('a', 1));\n+\n+        assertEquals(3, sb.indexOf('b', 2));\n+        assertEquals(\"abab\".indexOf('b', 2), sb.indexOf('b', 2));\n+\n+        assertEquals(-1, sb.indexOf('z', 2));\n+\n+        sb = new StrBuilder(\"xyzabc\");\n+        assertEquals(2, sb.indexOf('z', 0));\n+        assertEquals(-1, sb.indexOf('z', 3));\n+    }\n+\n+    public void testLastIndexOf_char() {\n+        StrBuilder sb = new StrBuilder(\"abab\");\n+        \n+        assertEquals (2, sb.lastIndexOf('a'));\n+        //should work like String#lastIndexOf\n+        assertEquals (\"abab\".lastIndexOf('a'), sb.lastIndexOf('a'));\n+        \n+        assertEquals(3, sb.lastIndexOf('b'));\n+        assertEquals (\"abab\".lastIndexOf('b'), sb.lastIndexOf('b'));\n+        \n+        assertEquals (-1, sb.lastIndexOf('z'));\n+    }\n+\n+    public void testLastIndexOf_char_int() {\n+        StrBuilder sb = new StrBuilder(\"abab\");\n+        assertEquals(-1, sb.lastIndexOf('a', -1));\n+        assertEquals(0, sb.lastIndexOf('a', 0));\n+        assertEquals(0, sb.lastIndexOf('a', 1));\n+\n+        // should work like String#lastIndexOf\n+        assertEquals(\"abab\".lastIndexOf('a', 1), sb.lastIndexOf('a', 1));\n+\n+        assertEquals(1, sb.lastIndexOf('b', 2));\n+        assertEquals(\"abab\".lastIndexOf('b', 2), sb.lastIndexOf('b', 2));\n+\n+        assertEquals(-1, sb.lastIndexOf('z', 2));\n+\n+        sb = new StrBuilder(\"xyzabc\");\n+        assertEquals(2, sb.lastIndexOf('z', sb.length()));\n+        assertEquals(-1, sb.lastIndexOf('z', 1));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testIndexOf_String() {\n+        StrBuilder sb = new StrBuilder(\"abab\");\n+        \n+        assertEquals(0, sb.indexOf(\"a\"));\n+        //should work like String#indexOf\n+        assertEquals(\"abab\".indexOf(\"a\"), sb.indexOf(\"a\"));\n+        \n+        assertEquals(0, sb.indexOf(\"ab\"));\n+        //should work like String#indexOf\n+        assertEquals(\"abab\".indexOf(\"ab\"), sb.indexOf(\"ab\"));\n+        \n+        assertEquals(1, sb.indexOf(\"b\"));\n+        assertEquals(\"abab\".indexOf(\"b\"), sb.indexOf(\"b\"));\n+        \n+        assertEquals(1, sb.indexOf(\"ba\"));\n+        assertEquals(\"abab\".indexOf(\"ba\"), sb.indexOf(\"ba\"));\n+        \n+        assertEquals(-1, sb.indexOf(\"z\"));\n+        \n+        assertEquals(-1, sb.indexOf((String) null));\n+    }\n+\n+    public void testIndexOf_String_int() {\n+        StrBuilder sb = new StrBuilder(\"abab\");\n+        assertEquals(0, sb.indexOf(\"a\", -1));\n+        assertEquals(0, sb.indexOf(\"a\", 0));\n+        assertEquals(2, sb.indexOf(\"a\", 1));\n+        assertEquals(2, sb.indexOf(\"a\", 2));\n+        assertEquals(-1, sb.indexOf(\"a\", 3));\n+        assertEquals(-1, sb.indexOf(\"a\", 4));\n+        assertEquals(-1, sb.indexOf(\"a\", 5));\n+        \n+        assertEquals(-1, sb.indexOf(\"abcdef\", 0));\n+        assertEquals(0, sb.indexOf(\"\", 0));\n+        assertEquals(1, sb.indexOf(\"\", 1));\n+        \n+        //should work like String#indexOf\n+        assertEquals (\"abab\".indexOf(\"a\", 1), sb.indexOf(\"a\", 1));\n+        \n+        assertEquals(2, sb.indexOf(\"ab\", 1));\n+        //should work like String#indexOf\n+        assertEquals(\"abab\".indexOf(\"ab\", 1), sb.indexOf(\"ab\", 1));\n+        \n+        assertEquals(3, sb.indexOf(\"b\", 2));\n+        assertEquals(\"abab\".indexOf(\"b\", 2), sb.indexOf(\"b\", 2));\n+        \n+        assertEquals(1, sb.indexOf(\"ba\", 1));\n+        assertEquals(\"abab\".indexOf(\"ba\", 2), sb.indexOf(\"ba\", 2));\n+        \n+        assertEquals(-1, sb.indexOf(\"z\", 2));\n+        \n+        sb = new StrBuilder(\"xyzabc\");\n+        assertEquals(2, sb.indexOf(\"za\", 0));\n+        assertEquals(-1, sb.indexOf(\"za\", 3));\n+        \n+        assertEquals(-1, sb.indexOf((String) null, 2));\n+    }\n+\n+    public void testLastIndexOf_String() {\n+        StrBuilder sb = new StrBuilder(\"abab\");\n+        \n+        assertEquals(2, sb.lastIndexOf(\"a\"));\n+        //should work like String#lastIndexOf\n+        assertEquals(\"abab\".lastIndexOf(\"a\"), sb.lastIndexOf(\"a\"));\n+        \n+        assertEquals(2, sb.lastIndexOf(\"ab\"));\n+        //should work like String#lastIndexOf\n+        assertEquals(\"abab\".lastIndexOf(\"ab\"), sb.lastIndexOf(\"ab\"));\n+        \n+        assertEquals(3, sb.lastIndexOf(\"b\"));\n+        assertEquals(\"abab\".lastIndexOf(\"b\"), sb.lastIndexOf(\"b\"));\n+        \n+        assertEquals(1, sb.lastIndexOf(\"ba\"));\n+        assertEquals(\"abab\".lastIndexOf(\"ba\"), sb.lastIndexOf(\"ba\"));\n+        \n+        assertEquals(-1, sb.lastIndexOf(\"z\"));\n+        \n+        assertEquals(-1, sb.lastIndexOf((String) null));\n+    }\n+\n+    public void testLastIndexOf_String_int() {\n+        StrBuilder sb = new StrBuilder(\"abab\");\n+        assertEquals(-1, sb.lastIndexOf(\"a\", -1));\n+        assertEquals(0, sb.lastIndexOf(\"a\", 0));\n+        assertEquals(0, sb.lastIndexOf(\"a\", 1));\n+        assertEquals(2, sb.lastIndexOf(\"a\", 2));\n+        assertEquals(2, sb.lastIndexOf(\"a\", 3));\n+        assertEquals(2, sb.lastIndexOf(\"a\", 4));\n+        assertEquals(2, sb.lastIndexOf(\"a\", 5));\n+        \n+        assertEquals(-1, sb.lastIndexOf(\"abcdef\", 3));\n+        assertEquals(\"abab\".lastIndexOf(\"\", 3), sb.lastIndexOf(\"\", 3));\n+        assertEquals(\"abab\".lastIndexOf(\"\", 1), sb.lastIndexOf(\"\", 1));\n+        \n+        //should work like String#lastIndexOf\n+        assertEquals(\"abab\".lastIndexOf(\"a\", 1), sb.lastIndexOf(\"a\", 1));\n+        \n+        assertEquals(0, sb.lastIndexOf(\"ab\", 1));\n+        //should work like String#lastIndexOf\n+        assertEquals(\"abab\".lastIndexOf(\"ab\", 1), sb.lastIndexOf(\"ab\", 1));\n+        \n+        assertEquals(1, sb.lastIndexOf(\"b\", 2));\n+        assertEquals(\"abab\".lastIndexOf(\"b\", 2), sb.lastIndexOf(\"b\", 2));\n+        \n+        assertEquals(1, sb.lastIndexOf(\"ba\", 2));\n+        assertEquals(\"abab\".lastIndexOf(\"ba\", 2), sb.lastIndexOf(\"ba\", 2));\n+        \n+        assertEquals(-1, sb.lastIndexOf(\"z\", 2));\n+        \n+        sb = new StrBuilder(\"xyzabc\");\n+        assertEquals(2, sb.lastIndexOf(\"za\", sb.length()));\n+        assertEquals(-1, sb.lastIndexOf(\"za\", 1));\n+        \n+        assertEquals(-1, sb.lastIndexOf((String) null, 2));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testIndexOf_StrMatcher() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(-1, sb.indexOf((StrMatcher) null));\n+        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a')));\n+        \n+        sb.append(\"ab bd\");\n+        assertEquals(0, sb.indexOf(StrMatcher.charMatcher('a')));\n+        assertEquals(1, sb.indexOf(StrMatcher.charMatcher('b')));\n+        assertEquals(2, sb.indexOf(StrMatcher.spaceMatcher()));\n+        assertEquals(4, sb.indexOf(StrMatcher.charMatcher('d')));\n+        assertEquals(-1, sb.indexOf(StrMatcher.noneMatcher()));\n+        assertEquals(-1, sb.indexOf((StrMatcher) null));\n+        \n+        sb.append(\" A1 junction\");\n+        assertEquals(6, sb.indexOf(A_NUMBER_MATCHER));\n+    }\n+\n+    public void testIndexOf_StrMatcher_int() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(-1, sb.indexOf((StrMatcher) null, 2));\n+        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'), 2));\n+        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'), 0));\n+        \n+        sb.append(\"ab bd\");\n+        assertEquals(0, sb.indexOf(StrMatcher.charMatcher('a'), -2));\n+        assertEquals(0, sb.indexOf(StrMatcher.charMatcher('a'), 0));\n+        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'), 2));\n+        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'), 20));\n+        \n+        assertEquals(1, sb.indexOf(StrMatcher.charMatcher('b'), -1));\n+        assertEquals(1, sb.indexOf(StrMatcher.charMatcher('b'), 0));\n+        assertEquals(1, sb.indexOf(StrMatcher.charMatcher('b'), 1));\n+        assertEquals(3, sb.indexOf(StrMatcher.charMatcher('b'), 2));\n+        assertEquals(3, sb.indexOf(StrMatcher.charMatcher('b'), 3));\n+        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('b'), 4));\n+        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('b'), 5));\n+        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('b'), 6));\n+        \n+        assertEquals(2, sb.indexOf(StrMatcher.spaceMatcher(), -2));\n+        assertEquals(2, sb.indexOf(StrMatcher.spaceMatcher(), 0));\n+        assertEquals(2, sb.indexOf(StrMatcher.spaceMatcher(), 2));\n+        assertEquals(-1, sb.indexOf(StrMatcher.spaceMatcher(), 4));\n+        assertEquals(-1, sb.indexOf(StrMatcher.spaceMatcher(), 20));\n+        \n+        assertEquals(-1, sb.indexOf(StrMatcher.noneMatcher(), 0));\n+        assertEquals(-1, sb.indexOf((StrMatcher) null, 0));\n+        \n+        sb.append(\" A1 junction with A2\");\n+        assertEquals(6, sb.indexOf(A_NUMBER_MATCHER, 5));\n+        assertEquals(6, sb.indexOf(A_NUMBER_MATCHER, 6));\n+        assertEquals(23, sb.indexOf(A_NUMBER_MATCHER, 7));\n+        assertEquals(23, sb.indexOf(A_NUMBER_MATCHER, 22));\n+        assertEquals(23, sb.indexOf(A_NUMBER_MATCHER, 23));\n+        assertEquals(-1, sb.indexOf(A_NUMBER_MATCHER, 24));\n+    }\n+\n+    public void testLastIndexOf_StrMatcher() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(-1, sb.lastIndexOf((StrMatcher) null));\n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a')));\n+        \n+        sb.append(\"ab bd\");\n+        assertEquals(0, sb.lastIndexOf(StrMatcher.charMatcher('a')));\n+        assertEquals(3, sb.lastIndexOf(StrMatcher.charMatcher('b')));\n+        assertEquals(2, sb.lastIndexOf(StrMatcher.spaceMatcher()));\n+        assertEquals(4, sb.lastIndexOf(StrMatcher.charMatcher('d')));\n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.noneMatcher()));\n+        assertEquals(-1, sb.lastIndexOf((StrMatcher) null));\n+        \n+        sb.append(\" A1 junction\");\n+        assertEquals(6, sb.lastIndexOf(A_NUMBER_MATCHER));\n+    }\n+\n+    public void testLastIndexOf_StrMatcher_int() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(-1, sb.lastIndexOf((StrMatcher) null, 2));\n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a'), 2));\n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a'), 0));\n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a'), -1));\n+        \n+        sb.append(\"ab bd\");\n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a'), -2));\n+        assertEquals(0, sb.lastIndexOf(StrMatcher.charMatcher('a'), 0));\n+        assertEquals(0, sb.lastIndexOf(StrMatcher.charMatcher('a'), 2));\n+        assertEquals(0, sb.lastIndexOf(StrMatcher.charMatcher('a'), 20));\n+        \n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('b'), -1));\n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('b'), 0));\n+        assertEquals(1, sb.lastIndexOf(StrMatcher.charMatcher('b'), 1));\n+        assertEquals(1, sb.lastIndexOf(StrMatcher.charMatcher('b'), 2));\n+        assertEquals(3, sb.lastIndexOf(StrMatcher.charMatcher('b'), 3));\n+        assertEquals(3, sb.lastIndexOf(StrMatcher.charMatcher('b'), 4));\n+        assertEquals(3, sb.lastIndexOf(StrMatcher.charMatcher('b'), 5));\n+        assertEquals(3, sb.lastIndexOf(StrMatcher.charMatcher('b'), 6));\n+        \n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.spaceMatcher(), -2));\n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.spaceMatcher(), 0));\n+        assertEquals(2, sb.lastIndexOf(StrMatcher.spaceMatcher(), 2));\n+        assertEquals(2, sb.lastIndexOf(StrMatcher.spaceMatcher(), 4));\n+        assertEquals(2, sb.lastIndexOf(StrMatcher.spaceMatcher(), 20));\n+        \n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.noneMatcher(), 0));\n+        assertEquals(-1, sb.lastIndexOf((StrMatcher) null, 0));\n+        \n+        sb.append(\" A1 junction with A2\");\n+        assertEquals(-1, sb.lastIndexOf(A_NUMBER_MATCHER, 5));\n+        assertEquals(-1, sb.lastIndexOf(A_NUMBER_MATCHER, 6)); // A matches, 1 is outside bounds\n+        assertEquals(6, sb.lastIndexOf(A_NUMBER_MATCHER, 7));\n+        assertEquals(6, sb.lastIndexOf(A_NUMBER_MATCHER, 22));\n+        assertEquals(6, sb.lastIndexOf(A_NUMBER_MATCHER, 23)); // A matches, 2 is outside bounds\n+        assertEquals(23, sb.lastIndexOf(A_NUMBER_MATCHER, 24));\n+    }\n+\n+    static final StrMatcher A_NUMBER_MATCHER = new StrMatcher() {\n+        @Override\n+        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+            if (buffer[pos] == 'A') {\n+                pos++;\n+                if (pos < bufferEnd && buffer[pos] >= '0' && buffer[pos] <= '9') {\n+                    return 2;\n+                }\n+            }\n+            return 0;\n+        }\n+    };\n+\n+    //-----------------------------------------------------------------------\n+    public void testAsTokenizer() throws Exception {\n+        // from Javadoc\n+        StrBuilder b = new StrBuilder();\n+        b.append(\"a b \");\n+        StrTokenizer t = b.asTokenizer();\n+        \n+        String[] tokens1 = t.getTokenArray();\n+        assertEquals(2, tokens1.length);\n+        assertEquals(\"a\", tokens1[0]);\n+        assertEquals(\"b\", tokens1[1]);\n+        assertEquals(2, t.size());\n+        \n+        b.append(\"c d \");\n+        String[] tokens2 = t.getTokenArray();\n+        assertEquals(2, tokens2.length);\n+        assertEquals(\"a\", tokens2[0]);\n+        assertEquals(\"b\", tokens2[1]);\n+        assertEquals(2, t.size());\n+        assertEquals(\"a\", t.next());\n+        assertEquals(\"b\", t.next());\n+        \n+        t.reset();\n+        String[] tokens3 = t.getTokenArray();\n+        assertEquals(4, tokens3.length);\n+        assertEquals(\"a\", tokens3[0]);\n+        assertEquals(\"b\", tokens3[1]);\n+        assertEquals(\"c\", tokens3[2]);\n+        assertEquals(\"d\", tokens3[3]);\n+        assertEquals(4, t.size());\n+        assertEquals(\"a\", t.next());\n+        assertEquals(\"b\", t.next());\n+        assertEquals(\"c\", t.next());\n+        assertEquals(\"d\", t.next());\n+        \n+        assertEquals(\"a b c d \", t.getContent());\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testAsReader() throws Exception {\n+        StrBuilder sb = new StrBuilder(\"some text\");\n+        Reader reader = sb.asReader();\n+        assertEquals(true, reader.ready());\n+        char[] buf = new char[40];\n+        assertEquals(9, reader.read(buf));\n+        assertEquals(\"some text\", new String(buf, 0, 9));\n+        \n+        assertEquals(-1, reader.read());\n+        assertEquals(false, reader.ready());\n+        assertEquals(0, reader.skip(2));\n+        assertEquals(0, reader.skip(-1));\n+        \n+        assertEquals(true, reader.markSupported());\n+        reader = sb.asReader();\n+        assertEquals('s', reader.read());\n+        reader.mark(-1);\n+        char[] array = new char[3];\n+        assertEquals(3, reader.read(array, 0, 3));\n+        assertEquals('o', array[0]);\n+        assertEquals('m', array[1]);\n+        assertEquals('e', array[2]);\n+        reader.reset();\n+        assertEquals(1, reader.read(array, 1, 1));\n+        assertEquals('o', array[0]);\n+        assertEquals('o', array[1]);\n+        assertEquals('e', array[2]);\n+        assertEquals(2, reader.skip(2));\n+        assertEquals(' ', reader.read());\n+        \n+        assertEquals(true, reader.ready());\n+        reader.close();\n+        assertEquals(true, reader.ready());\n+        \n+        reader = sb.asReader();\n+        array = new char[3];\n+        try {\n+            reader.read(array, -1, 0);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            reader.read(array, 0, -1);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            reader.read(array, 100, 1);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            reader.read(array, 0, 100);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            reader.read(array, Integer.MAX_VALUE, Integer.MAX_VALUE);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        \n+        assertEquals(0, reader.read(array, 0, 0));\n+        assertEquals(0, array[0]);\n+        assertEquals(0, array[1]);\n+        assertEquals(0, array[2]);\n+        \n+        reader.skip(9);\n+        assertEquals(-1, reader.read(array, 0, 1));\n+        \n+        reader.reset();\n+        array = new char[30];\n+        assertEquals(9, reader.read(array, 0, 30));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAsWriter() throws Exception {\n+        StrBuilder sb = new StrBuilder(\"base\");\n+        Writer writer = sb.asWriter();\n+        \n+        writer.write('l');\n+        assertEquals(\"basel\", sb.toString());\n+        \n+        writer.write(new char[] {'i', 'n'});\n+        assertEquals(\"baselin\", sb.toString());\n+        \n+        writer.write(new char[] {'n', 'e', 'r'}, 1, 2);\n+        assertEquals(\"baseliner\", sb.toString());\n+        \n+        writer.write(\" rout\");\n+        assertEquals(\"baseliner rout\", sb.toString());\n+        \n+        writer.write(\"ping that server\", 1, 3);\n+        assertEquals(\"baseliner routing\", sb.toString());\n+        \n+        writer.flush();  // no effect\n+        assertEquals(\"baseliner routing\", sb.toString());\n+        \n+        writer.close();  // no effect\n+        assertEquals(\"baseliner routing\", sb.toString());\n+        \n+        writer.write(\" hi\");  // works after close\n+        assertEquals(\"baseliner routing hi\", sb.toString());\n+        \n+        sb.setLength(4);  // mix and match\n+        writer.write('d');\n+        assertEquals(\"based\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEqualsIgnoreCase() {\n+        StrBuilder sb1 = new StrBuilder();\n+        StrBuilder sb2 = new StrBuilder();\n+        assertEquals(true, sb1.equalsIgnoreCase(sb1));\n+        assertEquals(true, sb1.equalsIgnoreCase(sb2));\n+        assertEquals(true, sb2.equalsIgnoreCase(sb2));\n+        \n+        sb1.append(\"abc\");\n+        assertEquals(false, sb1.equalsIgnoreCase(sb2));\n+        \n+        sb2.append(\"ABC\");\n+        assertEquals(true, sb1.equalsIgnoreCase(sb2));\n+        \n+        sb2.clear().append(\"abc\");\n+        assertEquals(true, sb1.equalsIgnoreCase(sb2));\n+        assertEquals(true, sb1.equalsIgnoreCase(sb1));\n+        assertEquals(true, sb2.equalsIgnoreCase(sb2));\n+        \n+        sb2.clear().append(\"aBc\");\n+        assertEquals(true, sb1.equalsIgnoreCase(sb2));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEquals() {\n+        StrBuilder sb1 = new StrBuilder();\n+        StrBuilder sb2 = new StrBuilder();\n+        assertEquals(true, sb1.equals(sb2));\n+        assertEquals(true, sb1.equals(sb1));\n+        assertEquals(true, sb2.equals(sb2));\n+        assertEquals(true, sb1.equals((Object) sb2));\n+        \n+        sb1.append(\"abc\");\n+        assertEquals(false, sb1.equals(sb2));\n+        assertEquals(false, sb1.equals((Object) sb2));\n+        \n+        sb2.append(\"ABC\");\n+        assertEquals(false, sb1.equals(sb2));\n+        assertEquals(false, sb1.equals((Object) sb2));\n+        \n+        sb2.clear().append(\"abc\");\n+        assertEquals(true, sb1.equals(sb2));\n+        assertEquals(true, sb1.equals((Object) sb2));\n+        \n+        assertEquals(false, sb1.equals(new Integer(1)));\n+        assertEquals(false, sb1.equals(\"abc\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testHashCode() {\n+        StrBuilder sb = new StrBuilder();\n+        int hc1a = sb.hashCode();\n+        int hc1b = sb.hashCode();\n+        assertEquals(0, hc1a);\n+        assertEquals(hc1a, hc1b);\n+        \n+        sb.append(\"abc\");\n+        int hc2a = sb.hashCode();\n+        int hc2b = sb.hashCode();\n+        assertEquals(true, hc2a != 0);\n+        assertEquals(hc2a, hc2b);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        StrBuilder sb = new StrBuilder(\"abc\");\n+        assertEquals(\"abc\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToStringBuffer() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(new StringBuffer().toString(), sb.toStringBuffer().toString());\n+        \n+        sb.append(\"junit\");\n+        assertEquals(new StringBuffer(\"junit\").toString(), sb.toStringBuffer().toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testLang294() {\n+        StrBuilder sb = new StrBuilder(\"\\n%BLAH%\\nDo more stuff\\neven more stuff\\n%BLAH%\\n\");\n+        sb.deleteAll(\"\\n%BLAH%\");\n+        assertEquals(\"\\nDo more stuff\\neven more stuff\\n\", sb.toString()); \n+    }\n+\n+    public void testIndexOfLang294() {\n+        StrBuilder sb = new StrBuilder(\"onetwothree\");\n+        sb.deleteFirst(\"three\");\n+        assertEquals(-1, sb.indexOf(\"three\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testLang295() {\n+        StrBuilder sb = new StrBuilder(\"onetwothree\");\n+        sb.deleteFirst(\"three\");\n+        assertFalse( \"The contains(char) method is looking beyond the end of the string\", sb.contains('h'));\n+        assertEquals( \"The indexOf(char) method is looking beyond the end of the string\", -1, sb.indexOf('h'));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testLang412Right() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendFixedWidthPadRight(null, 10, '*');\n+        assertEquals( \"Failed to invoke appendFixedWidthPadRight correctly\", \"**********\", sb.toString());\n+    }\n+\n+    public void testLang412Left() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendFixedWidthPadLeft(null, 10, '*');\n+        assertEquals( \"Failed to invoke appendFixedWidthPadLeft correctly\", \"**********\", sb.toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/text/StrLookupTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Test class for StrLookup.\n+ *\n+ * @version $Id$\n+ */\n+public class StrLookupTest extends TestCase {\n+\n+    /**\n+     * Main method.\n+     * \n+     * @param args  command line arguments, ignored\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Return a new test suite containing this test case.\n+     * \n+     * @return a new test suite containing this test case\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StrLookupTest.class);\n+        suite.setName(\"StrLookup Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNoneLookup() {\n+        assertEquals(null, StrLookup.noneLookup().lookup(null));\n+        assertEquals(null, StrLookup.noneLookup().lookup(\"\"));\n+        assertEquals(null, StrLookup.noneLookup().lookup(\"any\"));\n+    }\n+\n+    public void testSystemProperiesLookup() {\n+        assertEquals(System.getProperty(\"os.name\"), StrLookup.systemPropertiesLookup().lookup(\"os.name\"));\n+        assertEquals(null, StrLookup.systemPropertiesLookup().lookup(\"\"));\n+        assertEquals(null, StrLookup.systemPropertiesLookup().lookup(\"other\"));\n+        try {\n+            StrLookup.systemPropertiesLookup().lookup(null);\n+            fail();\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMapLookup() {\n+        Map<String, Object> map = new HashMap<String, Object>();\n+        map.put(\"key\", \"value\");\n+        map.put(\"number\", new Integer(2));\n+        assertEquals(\"value\", StrLookup.mapLookup(map).lookup(\"key\"));\n+        assertEquals(\"2\", StrLookup.mapLookup(map).lookup(\"number\"));\n+        assertEquals(null, StrLookup.mapLookup(map).lookup(null));\n+        assertEquals(null, StrLookup.mapLookup(map).lookup(\"\"));\n+        assertEquals(null, StrLookup.mapLookup(map).lookup(\"other\"));\n+    }\n+\n+    public void testMapLookup_nullMap() {\n+        Map<String, ?> map = null;\n+        assertEquals(null, StrLookup.mapLookup(map).lookup(null));\n+        assertEquals(null, StrLookup.mapLookup(map).lookup(\"\"));\n+        assertEquals(null, StrLookup.mapLookup(map).lookup(\"any\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/text/StrMatcherTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests for {@link org.apache.commons.lang.text.StrMatcher}.\n+ *\n+ * @version $Id$\n+ */\n+public class StrMatcherTest extends TestCase {\n+\n+    private static final char[] BUFFER1 = \"0,1\\t2 3\\n\\r\\f\\u0000'\\\"\".toCharArray();\n+\n+    private static final char[] BUFFER2 = \"abcdef\".toCharArray();\n+\n+    /**\n+     * Main method.\n+     * \n+     * @param args  command line arguments, ignored\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Return a new test suite containing this test case.\n+     * \n+     * @return a new test suite containing this test case\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StrMatcherTest.class);\n+        suite.setName(\"StrMatcher Tests\");\n+        return suite;\n+    }\n+\n+    /**\n+     * Create a new test case with the specified name.\n+     * \n+     * @param name  the name\n+     */\n+    public StrMatcherTest(String name) {\n+        super(name);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCommaMatcher() {\n+        StrMatcher matcher = StrMatcher.commaMatcher();\n+        assertSame(matcher, StrMatcher.commaMatcher());\n+        assertEquals(0, matcher.isMatch(BUFFER1, 0));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 1));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 2));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTabMatcher() {\n+        StrMatcher matcher = StrMatcher.tabMatcher();\n+        assertSame(matcher, StrMatcher.tabMatcher());\n+        assertEquals(0, matcher.isMatch(BUFFER1, 2));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 3));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 4));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSpaceMatcher() {\n+        StrMatcher matcher = StrMatcher.spaceMatcher();\n+        assertSame(matcher, StrMatcher.spaceMatcher());\n+        assertEquals(0, matcher.isMatch(BUFFER1, 4));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 5));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 6));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSplitMatcher() {\n+        StrMatcher matcher = StrMatcher.splitMatcher();\n+        assertSame(matcher, StrMatcher.splitMatcher());\n+        assertEquals(0, matcher.isMatch(BUFFER1, 2));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 3));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 4));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 5));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 6));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 7));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 8));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 9));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 10));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTrimMatcher() {\n+        StrMatcher matcher = StrMatcher.trimMatcher();\n+        assertSame(matcher, StrMatcher.trimMatcher());\n+        assertEquals(0, matcher.isMatch(BUFFER1, 2));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 3));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 4));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 5));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 6));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 7));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 8));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 9));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 10));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSingleQuoteMatcher() {\n+        StrMatcher matcher = StrMatcher.singleQuoteMatcher();\n+        assertSame(matcher, StrMatcher.singleQuoteMatcher());\n+        assertEquals(0, matcher.isMatch(BUFFER1, 10));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 11));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 12));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDoubleQuoteMatcher() {\n+        StrMatcher matcher = StrMatcher.doubleQuoteMatcher();\n+        assertSame(matcher, StrMatcher.doubleQuoteMatcher());\n+        assertEquals(0, matcher.isMatch(BUFFER1, 11));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 12));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testQuoteMatcher() {\n+        StrMatcher matcher = StrMatcher.quoteMatcher();\n+        assertSame(matcher, StrMatcher.quoteMatcher());\n+        assertEquals(0, matcher.isMatch(BUFFER1, 10));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 11));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 12));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNoneMatcher() {\n+        StrMatcher matcher = StrMatcher.noneMatcher();\n+        assertSame(matcher, StrMatcher.noneMatcher());\n+        assertEquals(0, matcher.isMatch(BUFFER1, 0));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 1));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 2));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 3));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 4));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 5));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 6));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 7));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 8));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 9));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 10));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 11));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 12));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCharMatcher_char() {\n+        StrMatcher matcher = StrMatcher.charMatcher('c');\n+        assertEquals(0, matcher.isMatch(BUFFER2, 0));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 1));\n+        assertEquals(1, matcher.isMatch(BUFFER2, 2));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 3));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 4));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 5));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCharSetMatcher_String() {\n+        StrMatcher matcher = StrMatcher.charSetMatcher(\"ace\");\n+        assertEquals(1, matcher.isMatch(BUFFER2, 0));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 1));\n+        assertEquals(1, matcher.isMatch(BUFFER2, 2));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 3));\n+        assertEquals(1, matcher.isMatch(BUFFER2, 4));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 5));\n+        assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher(\"\"));\n+        assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher((String) null));\n+        assertTrue(StrMatcher.charSetMatcher(\"a\") instanceof StrMatcher.CharMatcher);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCharSetMatcher_charArray() {\n+        StrMatcher matcher = StrMatcher.charSetMatcher(\"ace\".toCharArray());\n+        assertEquals(1, matcher.isMatch(BUFFER2, 0));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 1));\n+        assertEquals(1, matcher.isMatch(BUFFER2, 2));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 3));\n+        assertEquals(1, matcher.isMatch(BUFFER2, 4));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 5));\n+        assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher(new char[0]));\n+        assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher((char[]) null));\n+        assertTrue(StrMatcher.charSetMatcher(\"a\".toCharArray()) instanceof StrMatcher.CharMatcher);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testStringMatcher_String() {\n+        StrMatcher matcher = StrMatcher.stringMatcher(\"bc\");\n+        assertEquals(0, matcher.isMatch(BUFFER2, 0));\n+        assertEquals(2, matcher.isMatch(BUFFER2, 1));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 2));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 3));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 4));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 5));\n+        assertSame(StrMatcher.noneMatcher(), StrMatcher.stringMatcher(\"\"));\n+        assertSame(StrMatcher.noneMatcher(), StrMatcher.stringMatcher((String) null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMatcherIndices() {\n+        // remember that the API contract is tight for the isMatch() method\n+        // all the onus is on the caller, so invalid inputs are not\n+        // the concern of StrMatcher, and are not bugs\n+        StrMatcher matcher = StrMatcher.stringMatcher(\"bc\");\n+        assertEquals(2, matcher.isMatch(BUFFER2, 1, 1, BUFFER2.length));\n+        assertEquals(2, matcher.isMatch(BUFFER2, 1, 0, 3));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 1, 0, 2));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/text/StrSubstitutorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.lang.mutable.MutableObject;\n+\n+/**\n+ * Test class for StrSubstitutor.\n+ * \n+ * @author Oliver Heger\n+ * @version $Id$\n+ */\n+public class StrSubstitutorTest extends TestCase {\n+\n+    private Map<String, String> values;\n+\n+    /**\n+     * Main method.\n+     * \n+     * @param args  command line arguments, ignored\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Return a new test suite containing this test case.\n+     * \n+     * @return a new test suite containing this test case\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StrSubstitutorTest.class);\n+        suite.setName(\"StrSubstitutor Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        values = new HashMap<String, String>();\n+        values.put(\"animal\", \"quick brown fox\");\n+        values.put(\"target\", \"lazy dog\");\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+        values = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests simple key replace.\n+     */\n+    public void testReplaceSimple() {\n+        doTestReplace(\"The quick brown fox jumps over the lazy dog.\", \"The ${animal} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests simple key replace.\n+     */\n+    public void testReplaceSolo() {\n+        doTestReplace(\"quick brown fox\", \"${animal}\", false);\n+    }\n+\n+    /**\n+     * Tests replace with no variables.\n+     */\n+    public void testReplaceNoVariables() {\n+        doTestNoReplace(\"The balloon arrived.\");\n+    }\n+\n+    /**\n+     * Tests replace with null.\n+     */\n+    public void testReplaceNull() {\n+        doTestNoReplace(null);\n+    }\n+\n+    /**\n+     * Tests replace with null.\n+     */\n+    public void testReplaceEmpty() {\n+        doTestNoReplace(\"\");\n+    }\n+\n+    /**\n+     * Tests key replace changing map after initialization (not recommended).\n+     */\n+    public void testReplaceChangedMap() {\n+        StrSubstitutor sub = new StrSubstitutor(values);\n+        values.put(\"target\", \"moon\");\n+        assertEquals(\"The quick brown fox jumps over the moon.\", sub.replace(\"The ${animal} jumps over the ${target}.\"));\n+    }\n+\n+    /**\n+     * Tests unknown key replace.\n+     */\n+    public void testReplaceUnknownKey() {\n+        doTestReplace(\"The ${person} jumps over the lazy dog.\", \"The ${person} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests adjacent keys.\n+     */\n+    public void testReplaceAdjacentAtStart() {\n+        values.put(\"code\", \"GBP\");\n+        values.put(\"amount\", \"12.50\");\n+        StrSubstitutor sub = new StrSubstitutor(values);\n+        assertEquals(\"GBP12.50 charged\", sub.replace(\"${code}${amount} charged\"));\n+    }\n+\n+    /**\n+     * Tests adjacent keys.\n+     */\n+    public void testReplaceAdjacentAtEnd() {\n+        values.put(\"code\", \"GBP\");\n+        values.put(\"amount\", \"12.50\");\n+        StrSubstitutor sub = new StrSubstitutor(values);\n+        assertEquals(\"Amount is GBP12.50\", sub.replace(\"Amount is ${code}${amount}\"));\n+    }\n+\n+    /**\n+     * Tests simple recursive replace.\n+     */\n+    public void testReplaceRecursive() {\n+        values.put(\"animal\", \"${critter}\");\n+        values.put(\"target\", \"${pet}\");\n+        values.put(\"pet\", \"${petCharacteristic} dog\");\n+        values.put(\"petCharacteristic\", \"lazy\");\n+        values.put(\"critter\", \"${critterSpeed} ${critterColor} ${critterType}\");\n+        values.put(\"critterSpeed\", \"quick\");\n+        values.put(\"critterColor\", \"brown\");\n+        values.put(\"critterType\", \"fox\");\n+        doTestReplace(\"The quick brown fox jumps over the lazy dog.\", \"The ${animal} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests escaping.\n+     */\n+    public void testReplaceEscaping() {\n+        doTestReplace(\"The ${animal} jumps over the lazy dog.\", \"The $${animal} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests escaping.\n+     */\n+    public void testReplaceSoloEscaping() {\n+        doTestReplace(\"${animal}\", \"$${animal}\", false);\n+    }\n+\n+    /**\n+     * Tests complex escaping.\n+     */\n+    public void testReplaceComplexEscaping() {\n+        doTestReplace(\"The ${quick brown fox} jumps over the lazy dog.\", \"The $${${animal}} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests when no prefix or suffix.\n+     */\n+    public void testReplaceNoPefixNoSuffix() {\n+        doTestReplace(\"The animal jumps over the lazy dog.\", \"The animal jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests when no incomplete prefix.\n+     */\n+    public void testReplaceIncompletePefix() {\n+        doTestReplace(\"The {animal} jumps over the lazy dog.\", \"The {animal} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests when prefix but no suffix.\n+     */\n+    public void testReplacePrefixNoSuffix() {\n+        doTestReplace(\"The ${animal jumps over the ${target} lazy dog.\", \"The ${animal jumps over the ${target} ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests when suffix but no prefix.\n+     */\n+    public void testReplaceNoPrefixSuffix() {\n+        doTestReplace(\"The animal} jumps over the lazy dog.\", \"The animal} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests when no variable name.\n+     */\n+    public void testReplaceEmptyKeys() {\n+        doTestReplace(\"The ${} jumps over the lazy dog.\", \"The ${} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests replace creates output same as input.\n+     */\n+    public void testReplaceToIdentical() {\n+        values.put(\"animal\", \"$${${thing}}\");\n+        values.put(\"thing\", \"animal\");\n+        doTestReplace(\"The ${animal} jumps.\", \"The ${animal} jumps.\", true);\n+    }\n+\n+    /**\n+     * Tests a cyclic replace operation.\n+     * The cycle should be detected and cause an exception to be thrown.\n+     */\n+    public void testCyclicReplacement() {\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"animal\", \"${critter}\");\n+        map.put(\"target\", \"${pet}\");\n+        map.put(\"pet\", \"${petCharacteristic} dog\");\n+        map.put(\"petCharacteristic\", \"lazy\");\n+        map.put(\"critter\", \"${critterSpeed} ${critterColor} ${critterType}\");\n+        map.put(\"critterSpeed\", \"quick\");\n+        map.put(\"critterColor\", \"brown\");\n+        map.put(\"critterType\", \"${animal}\");\n+        StrSubstitutor sub = new StrSubstitutor(map);\n+        try {\n+            sub.replace(\"The ${animal} jumps over the ${target}.\");\n+            fail(\"Cyclic replacement was not detected!\");\n+        } catch (IllegalStateException ex) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Tests interpolation with weird boundary patterns.\n+     */\n+    public void testReplaceWeirdPattens() {\n+        doTestNoReplace(\"\");\n+        doTestNoReplace(\"${}\");\n+        doTestNoReplace(\"${ }\");\n+        doTestNoReplace(\"${\\t}\");\n+        doTestNoReplace(\"${\\n}\");\n+        doTestNoReplace(\"${\\b}\");\n+        doTestNoReplace(\"${\");\n+        doTestNoReplace(\"$}\");\n+        doTestNoReplace(\"}\");\n+        doTestNoReplace(\"${}$\");\n+        doTestNoReplace(\"${${\");\n+        doTestNoReplace(\"${${}}\");\n+        doTestNoReplace(\"${$${}}\");\n+        doTestNoReplace(\"${$$${}}\");\n+        doTestNoReplace(\"${$$${$}}\");\n+        doTestNoReplace(\"${${}}\");\n+        doTestNoReplace(\"${${ }}\");\n+    }\n+\n+    /**\n+     * Tests simple key replace.\n+     */\n+    public void testReplacePartialString_noReplace() {\n+        StrSubstitutor sub = new StrSubstitutor();\n+        assertEquals(\"${animal} jumps\", sub.replace(\"The ${animal} jumps over the ${target}.\", 4, 15));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests protected.\n+     */\n+    public void testResolveVariable() {\n+        final StrBuilder builder = new StrBuilder(\"Hi ${name}!\");\n+        Map<String, Object> map = new HashMap<String, Object>();\n+        map.put(\"name\", \"commons\");\n+        StrSubstitutor sub = new StrSubstitutor(map) {\n+            @Override\n+            protected String resolveVariable(String variableName, StrBuilder buf, int startPos, int endPos) {\n+                assertEquals(\"name\", variableName);\n+                assertSame(builder, buf);\n+                assertEquals(3, startPos);\n+                assertEquals(10, endPos);\n+                return \"jakarta\";\n+            }\n+        };\n+        sub.replaceIn(builder);\n+        assertEquals(\"Hi jakarta!\", builder.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests constructor.\n+     */\n+    public void testConstructorNoArgs() {\n+        StrSubstitutor sub = new StrSubstitutor();\n+        assertEquals(\"Hi ${name}\", sub.replace(\"Hi ${name}\"));\n+    }\n+\n+    /**\n+     * Tests constructor.\n+     */\n+    public void testConstructorMapPrefixSuffix() {\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"name\", \"commons\");\n+        StrSubstitutor sub = new StrSubstitutor(map, \"<\", \">\");\n+        assertEquals(\"Hi < commons\", sub.replace(\"Hi $< <name>\"));\n+    }\n+\n+    /**\n+     * Tests constructor.\n+     */\n+    public void testConstructorMapFull() {\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"name\", \"commons\");\n+        StrSubstitutor sub = new StrSubstitutor(map, \"<\", \">\", '!');\n+        assertEquals(\"Hi < commons\", sub.replace(\"Hi !< <name>\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests get set.\n+     */\n+    public void testGetSetEscape() {\n+        StrSubstitutor sub = new StrSubstitutor();\n+        assertEquals('$', sub.getEscapeChar());\n+        sub.setEscapeChar('<');\n+        assertEquals('<', sub.getEscapeChar());\n+    }\n+\n+    /**\n+     * Tests get set.\n+     */\n+    public void testGetSetPrefix() {\n+        StrSubstitutor sub = new StrSubstitutor();\n+        assertEquals(true, sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher);\n+        sub.setVariablePrefix('<');\n+        assertEquals(true, sub.getVariablePrefixMatcher() instanceof StrMatcher.CharMatcher);\n+        \n+        sub.setVariablePrefix(\"<<\");\n+        assertEquals(true, sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher);\n+        try {\n+            sub.setVariablePrefix((String) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        assertEquals(true, sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher);\n+        \n+        StrMatcher matcher = StrMatcher.commaMatcher();\n+        sub.setVariablePrefixMatcher(matcher);\n+        assertSame(matcher, sub.getVariablePrefixMatcher());\n+        try {\n+            sub.setVariablePrefixMatcher((StrMatcher) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        assertSame(matcher, sub.getVariablePrefixMatcher());\n+    }\n+\n+    /**\n+     * Tests get set.\n+     */\n+    public void testGetSetSuffix() {\n+        StrSubstitutor sub = new StrSubstitutor();\n+        assertEquals(true, sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher);\n+        sub.setVariableSuffix('<');\n+        assertEquals(true, sub.getVariableSuffixMatcher() instanceof StrMatcher.CharMatcher);\n+        \n+        sub.setVariableSuffix(\"<<\");\n+        assertEquals(true, sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher);\n+        try {\n+            sub.setVariableSuffix((String) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        assertEquals(true, sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher);\n+        \n+        StrMatcher matcher = StrMatcher.commaMatcher();\n+        sub.setVariableSuffixMatcher(matcher);\n+        assertSame(matcher, sub.getVariableSuffixMatcher());\n+        try {\n+            sub.setVariableSuffixMatcher((StrMatcher) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        assertSame(matcher, sub.getVariableSuffixMatcher());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests static.\n+     */\n+    public void testStaticReplace() {\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"name\", \"commons\");\n+        assertEquals(\"Hi commons!\", StrSubstitutor.replace(\"Hi ${name}!\", map));\n+    }\n+\n+    /**\n+     * Tests static.\n+     */\n+    public void testStaticReplacePrefixSuffix() {\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"name\", \"commons\");\n+        assertEquals(\"Hi commons!\", StrSubstitutor.replace(\"Hi <name>!\", map, \"<\", \">\"));\n+    }\n+\n+    /**\n+     * Tests interpolation with system properties.\n+     */\n+    public void testStaticReplaceSystemProperties() {\n+        StrBuilder buf = new StrBuilder();\n+        buf.append(\"Hi \").append(System.getProperty(\"user.name\"));\n+        buf.append(\", you are working with \");\n+        buf.append(System.getProperty(\"os.name\"));\n+        buf.append(\", your home directory is \");\n+        buf.append(System.getProperty(\"user.home\")).append('.');\n+        assertEquals(buf.toString(), StrSubstitutor.replaceSystemProperties(\"Hi ${user.name}, you are \"\n+            + \"working with ${os.name}, your home \"\n+            + \"directory is ${user.home}.\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void doTestReplace(String expectedResult, String replaceTemplate, boolean substring) {\n+        String expectedShortResult = expectedResult.substring(1, expectedResult.length() - 1);\n+        StrSubstitutor sub = new StrSubstitutor(values);\n+        \n+        // replace using String\n+        assertEquals(expectedResult, sub.replace(replaceTemplate));\n+        if (substring) {\n+            assertEquals(expectedShortResult, sub.replace(replaceTemplate, 1, replaceTemplate.length() - 2));\n+        }\n+        \n+        // replace using char[]\n+        char[] chars = replaceTemplate.toCharArray();\n+        assertEquals(expectedResult, sub.replace(chars));\n+        if (substring) {\n+            assertEquals(expectedShortResult, sub.replace(chars, 1, chars.length - 2));\n+        }\n+        \n+        // replace using StringBuffer\n+        StringBuffer buf = new StringBuffer(replaceTemplate);\n+        assertEquals(expectedResult, sub.replace(buf));\n+        if (substring) {\n+            assertEquals(expectedShortResult, sub.replace(buf, 1, buf.length() - 2));\n+        }\n+        \n+        // replace using StrBuilder\n+        StrBuilder bld = new StrBuilder(replaceTemplate);\n+        assertEquals(expectedResult, sub.replace(bld));\n+        if (substring) {\n+            assertEquals(expectedShortResult, sub.replace(bld, 1, bld.length() - 2));\n+        }\n+        \n+        // replace using object\n+        MutableObject<String> obj = new MutableObject<String>(replaceTemplate);  // toString returns template\n+        assertEquals(expectedResult, sub.replace(obj));\n+        \n+        // replace in StringBuffer\n+        buf = new StringBuffer(replaceTemplate);\n+        assertEquals(true, sub.replaceIn(buf));\n+        assertEquals(expectedResult, buf.toString());\n+        if (substring) {\n+            buf = new StringBuffer(replaceTemplate);\n+            assertEquals(true, sub.replaceIn(buf, 1, buf.length() - 2));\n+            assertEquals(expectedResult, buf.toString());  // expect full result as remainder is untouched\n+        }\n+        \n+        // replace in StrBuilder\n+        bld = new StrBuilder(replaceTemplate);\n+        assertEquals(true, sub.replaceIn(bld));\n+        assertEquals(expectedResult, bld.toString());\n+        if (substring) {\n+            bld = new StrBuilder(replaceTemplate);\n+            assertEquals(true, sub.replaceIn(bld, 1, bld.length() - 2));\n+            assertEquals(expectedResult, bld.toString());  // expect full result as remainder is untouched\n+        }\n+    }\n+\n+    private void doTestNoReplace(String replaceTemplate) {\n+        StrSubstitutor sub = new StrSubstitutor(values);\n+        \n+        if (replaceTemplate == null) {\n+            assertEquals(null, sub.replace((String) null));\n+            assertEquals(null, sub.replace((String) null, 0, 100));\n+            assertEquals(null, sub.replace((char[]) null));\n+            assertEquals(null, sub.replace((char[]) null, 0, 100));\n+            assertEquals(null, sub.replace((StringBuffer) null));\n+            assertEquals(null, sub.replace((StringBuffer) null, 0, 100));\n+            assertEquals(null, sub.replace((StrBuilder) null));\n+            assertEquals(null, sub.replace((StrBuilder) null, 0, 100));\n+            assertEquals(null, sub.replace((Object) null));\n+            assertEquals(false, sub.replaceIn((StringBuffer) null));\n+            assertEquals(false, sub.replaceIn((StringBuffer) null, 0, 100));\n+            assertEquals(false, sub.replaceIn((StrBuilder) null));\n+            assertEquals(false, sub.replaceIn((StrBuilder) null, 0, 100));\n+        } else {\n+            assertEquals(replaceTemplate, sub.replace(replaceTemplate));\n+            StrBuilder bld = new StrBuilder(replaceTemplate);\n+            assertEquals(false, sub.replaceIn(bld));\n+            assertEquals(replaceTemplate, bld.toString());\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/text/StrTokenizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.ObjectUtils;\n+\n+/**\n+ * Unit test for Tokenizer.\n+ * \n+ * @author Matthew Inger\n+ */\n+public class StrTokenizerTest extends TestCase {\n+\n+    private static final String CSV_SIMPLE_FIXTURE = \"A,b,c\";\n+\n+    private static final String TSV_SIMPLE_FIXTURE = \"A\\tb\\tc\";\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StrTokenizerTest.class);\n+        suite.setName(\"TokenizerTest Tests\");\n+        return suite;\n+    }\n+\n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param name\n+     */\n+    public StrTokenizerTest(String name) {\n+        super(name);\n+    }\n+\n+    private void checkClone(StrTokenizer tokenizer) {\n+        assertFalse(StrTokenizer.getCSVInstance() == tokenizer);\n+        assertFalse(StrTokenizer.getTSVInstance() == tokenizer);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void test1() {\n+\n+        String input = \"a;b;c;\\\"d;\\\"\\\"e\\\";f; ; ;  \";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        String tokens[] = tok.getTokenArray();\n+\n+        String expected[] = new String[]{\"a\", \"b\", \"c\", \"d;\\\"e\", \"f\", \"\", \"\", \"\",};\n+\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+    public void test2() {\n+\n+        String input = \"a;b;c ;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(StrMatcher.noneMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        String tokens[] = tok.getTokenArray();\n+\n+        String expected[] = new String[]{\"a\", \"b\", \"c \", \"d;\\\"e\", \"f\", \" \", \" \", \"\",};\n+\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+    public void test3() {\n+\n+        String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(StrMatcher.noneMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        String tokens[] = tok.getTokenArray();\n+\n+        String expected[] = new String[]{\"a\", \"b\", \" c\", \"d;\\\"e\", \"f\", \" \", \" \", \"\",};\n+\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+    public void test4() {\n+\n+        String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(true);\n+        String tokens[] = tok.getTokenArray();\n+\n+        String expected[] = new String[]{\"a\", \"b\", \"c\", \"d;\\\"e\", \"f\",};\n+\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+    public void test5() {\n+\n+        String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        String tokens[] = tok.getTokenArray();\n+\n+        String expected[] = new String[]{\"a\", \"b\", \"c\", \"d;\\\"e\", \"f\", null, null, null,};\n+\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+    public void test6() {\n+\n+        String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        // tok.setTreatingEmptyAsNull(true);\n+        String tokens[] = tok.getTokenArray();\n+\n+        String expected[] = new String[]{\"a\", \"b\", \" c\", \"d;\\\"e\", \"f\", null, null, null,};\n+\n+        int nextCount = 0;\n+        while (tok.hasNext()) {\n+            tok.next();\n+            nextCount++;\n+        }\n+\n+        int prevCount = 0;\n+        while (tok.hasPrevious()) {\n+            tok.previous();\n+            prevCount++;\n+        }\n+\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n+\n+        assertTrue(\"could not cycle through entire token list\" + \" using the 'hasNext' and 'next' methods\",\n+                nextCount == expected.length);\n+\n+        assertTrue(\"could not cycle through entire token list\" + \" using the 'hasPrevious' and 'previous' methods\",\n+                prevCount == expected.length);\n+\n+    }\n+\n+    public void test7() {\n+\n+        String input = \"a   b c \\\"d e\\\" f \";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterMatcher(StrMatcher.spaceMatcher());\n+        tok.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());\n+        tok.setIgnoredMatcher(StrMatcher.noneMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        String tokens[] = tok.getTokenArray();\n+\n+        String expected[] = new String[]{\"a\", \"\", \"\", \"b\", \"c\", \"d e\", \"f\", \"\",};\n+\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+    public void test8() {\n+\n+        String input = \"a   b c \\\"d e\\\" f \";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterMatcher(StrMatcher.spaceMatcher());\n+        tok.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());\n+        tok.setIgnoredMatcher(StrMatcher.noneMatcher());\n+        tok.setIgnoreEmptyTokens(true);\n+        String tokens[] = tok.getTokenArray();\n+\n+        String expected[] = new String[]{\"a\", \"b\", \"c\", \"d e\", \"f\",};\n+\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+    public void testBasic1() {\n+        String input = \"a  b c\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasic2() {\n+        String input = \"a \\nb\\fc\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasic3() {\n+        String input = \"a \\nb\\u0001\\fc\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\\u0001\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasic4() {\n+        String input = \"a \\\"b\\\" c\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"\\\"b\\\"\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasic5() {\n+        String input = \"a:b':c\";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b'\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicDelim1() {\n+        String input = \"a:b:c\";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicDelim2() {\n+        String input = \"a:b:c\";\n+        StrTokenizer tok = new StrTokenizer(input, ',');\n+        assertEquals(\"a:b:c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicEmpty1() {\n+        String input = \"a  b c\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setIgnoreEmptyTokens(false);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicEmpty2() {\n+        String input = \"a  b c\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuoted1() {\n+        String input = \"a 'b' c\";\n+        StrTokenizer tok = new StrTokenizer(input, ' ', '\\'');\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuoted2() {\n+        String input = \"a:'b':\";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuoted3() {\n+        String input = \"a:'b''c'\";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b'c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuoted4() {\n+        String input = \"a: 'b' 'c' :d\";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b c\", tok.next());\n+        assertEquals(\"d\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuoted5() {\n+        String input = \"a: 'b'x'c' :d\";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"bxc\", tok.next());\n+        assertEquals(\"d\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuoted6() {\n+        String input = \"a:'b'\\\"c':d\";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setQuoteMatcher(StrMatcher.quoteMatcher());\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\\\"c:d\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuoted7() {\n+        String input = \"a:\\\"There's a reason here\\\":b\";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setQuoteMatcher(StrMatcher.quoteMatcher());\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"There's a reason here\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuotedTrimmed1() {\n+        String input = \"a: 'b' :\";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicTrimmed1() {\n+        String input = \"a: b :  \";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicTrimmed2() {\n+        String input = \"a:  b  :\";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setTrimmerMatcher(StrMatcher.stringMatcher(\"  \"));\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicIgnoreTrimmed1() {\n+        String input = \"a: bIGNOREc : \";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setIgnoredMatcher(StrMatcher.stringMatcher(\"IGNORE\"));\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"bc\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicIgnoreTrimmed2() {\n+        String input = \"IGNOREaIGNORE: IGNORE bIGNOREc IGNORE : IGNORE \";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setIgnoredMatcher(StrMatcher.stringMatcher(\"IGNORE\"));\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"bc\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicIgnoreTrimmed3() {\n+        String input = \"IGNOREaIGNORE: IGNORE bIGNOREc IGNORE : IGNORE \";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setIgnoredMatcher(StrMatcher.stringMatcher(\"IGNORE\"));\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"  bc  \", tok.next());\n+        assertEquals(\"  \", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicIgnoreTrimmed4() {\n+        String input = \"IGNOREaIGNORE: IGNORE 'bIGNOREc'IGNORE'd' IGNORE : IGNORE \";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        tok.setIgnoredMatcher(StrMatcher.stringMatcher(\"IGNORE\"));\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"bIGNOREcd\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testListArray() {\n+        String input = \"a  b c\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        String[] array = tok.getTokenArray();\n+        List<?> list = tok.getTokenList();\n+        \n+        assertEquals(Arrays.asList(array), list);\n+        assertEquals(3, list.size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCSV(String data) {\n+        this.testXSVAbc(StrTokenizer.getCSVInstance(data));\n+        this.testXSVAbc(StrTokenizer.getCSVInstance(data.toCharArray()));\n+    }\n+\n+    public void testCSVEmpty() {\n+        this.testEmpty(StrTokenizer.getCSVInstance());\n+        this.testEmpty(StrTokenizer.getCSVInstance(\"\"));\n+    }\n+\n+    public void testCSVSimple() {\n+        this.testCSV(CSV_SIMPLE_FIXTURE);\n+    }\n+\n+    public void testCSVSimpleNeedsTrim() {\n+        this.testCSV(\"   \" + CSV_SIMPLE_FIXTURE);\n+        this.testCSV(\"   \\n\\t  \" + CSV_SIMPLE_FIXTURE);\n+        this.testCSV(\"   \\n  \" + CSV_SIMPLE_FIXTURE + \"\\n\\n\\r\");\n+    }\n+\n+    void testEmpty(StrTokenizer tokenizer) {\n+        this.checkClone(tokenizer);\n+        assertEquals(false, tokenizer.hasNext());\n+        assertEquals(false, tokenizer.hasPrevious());\n+        assertEquals(null, tokenizer.nextToken());\n+        assertEquals(0, tokenizer.size());\n+        try {\n+            tokenizer.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+    }\n+\n+    public void testGetContent() {\n+        String input = \"a   b c \\\"d e\\\" f \";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        assertEquals(input, tok.getContent());\n+\n+        tok = new StrTokenizer(input.toCharArray());\n+        assertEquals(input, tok.getContent());\n+        \n+        tok = new StrTokenizer();\n+        assertEquals(null, tok.getContent());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testChaining() {\n+        StrTokenizer tok = new StrTokenizer();\n+        assertEquals(tok, tok.reset());\n+        assertEquals(tok, tok.reset(\"\"));\n+        assertEquals(tok, tok.reset(new char[0]));\n+        assertEquals(tok, tok.setDelimiterChar(' '));\n+        assertEquals(tok, tok.setDelimiterString(\" \"));\n+        assertEquals(tok, tok.setDelimiterMatcher(null));\n+        assertEquals(tok, tok.setQuoteChar(' '));\n+        assertEquals(tok, tok.setQuoteMatcher(null));\n+        assertEquals(tok, tok.setIgnoredChar(' '));\n+        assertEquals(tok, tok.setIgnoredMatcher(null));\n+        assertEquals(tok, tok.setTrimmerMatcher(null));\n+        assertEquals(tok, tok.setEmptyTokenAsNull(false));\n+        assertEquals(tok, tok.setIgnoreEmptyTokens(false));\n+    }\n+\n+    /**\n+     * Tests that the {@link StrTokenizer#clone()} clone method catches {@link CloneNotSupportedException} and returns\n+     * <code>null</code>.\n+     */\n+    public void testCloneNotSupportedException() {\n+        Object notCloned = (new StrTokenizer() {\n+            @Override\n+            Object cloneReset() throws CloneNotSupportedException {\n+                throw new CloneNotSupportedException(\"test\");\n+            }\n+        }).clone();\n+        assertNull(notCloned);\n+    }\n+\n+    public void testCloneNull() {\n+        StrTokenizer tokenizer = new StrTokenizer((char[]) null);\n+        // Start sanity check\n+        assertEquals(null, tokenizer.nextToken());\n+        tokenizer.reset();\n+        assertEquals(null, tokenizer.nextToken());\n+        // End sanity check\n+        StrTokenizer clonedTokenizer = (StrTokenizer) tokenizer.clone();\n+        tokenizer.reset();\n+        assertEquals(null, tokenizer.nextToken());\n+        assertEquals(null, clonedTokenizer.nextToken());\n+    }\n+\n+    public void testCloneReset() {\n+        char[] input = new char[]{'a'};\n+        StrTokenizer tokenizer = new StrTokenizer(input);\n+        // Start sanity check\n+        assertEquals(\"a\", tokenizer.nextToken());\n+        tokenizer.reset(input);\n+        assertEquals(\"a\", tokenizer.nextToken());\n+        // End sanity check\n+        StrTokenizer clonedTokenizer = (StrTokenizer) tokenizer.clone();\n+        input[0] = 'b';\n+        tokenizer.reset(input);\n+        assertEquals(\"b\", tokenizer.nextToken());\n+        assertEquals(\"a\", clonedTokenizer.nextToken());\n+    }\n+  \n+    // -----------------------------------------------------------------------\n+    public void testConstructor_String() {\n+        StrTokenizer tok = new StrTokenizer(\"a b\");\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer(\"\");\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer((String) null);\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_String_char() {\n+        StrTokenizer tok = new StrTokenizer(\"a b\", ' ');\n+        assertEquals(1, tok.getDelimiterMatcher().isMatch(\" \".toCharArray(), 0, 0, 1));\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer(\"\", ' ');\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer((String) null, ' ');\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_String_char_char() {\n+        StrTokenizer tok = new StrTokenizer(\"a b\", ' ', '\"');\n+        assertEquals(1, tok.getDelimiterMatcher().isMatch(\" \".toCharArray(), 0, 0, 1));\n+        assertEquals(1, tok.getQuoteMatcher().isMatch(\"\\\"\".toCharArray(), 0, 0, 1));\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer(\"\", ' ', '\"');\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer((String) null, ' ', '\"');\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_charArray() {\n+        StrTokenizer tok = new StrTokenizer(\"a b\".toCharArray());\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer(new char[0]);\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer((char[]) null);\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_charArray_char() {\n+        StrTokenizer tok = new StrTokenizer(\"a b\".toCharArray(), ' ');\n+        assertEquals(1, tok.getDelimiterMatcher().isMatch(\" \".toCharArray(), 0, 0, 1));\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer(new char[0], ' ');\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer((char[]) null, ' ');\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_charArray_char_char() {\n+        StrTokenizer tok = new StrTokenizer(\"a b\".toCharArray(), ' ', '\"');\n+        assertEquals(1, tok.getDelimiterMatcher().isMatch(\" \".toCharArray(), 0, 0, 1));\n+        assertEquals(1, tok.getQuoteMatcher().isMatch(\"\\\"\".toCharArray(), 0, 0, 1));\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer(new char[0], ' ', '\"');\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer((char[]) null, ' ', '\"');\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReset() {\n+        StrTokenizer tok = new StrTokenizer(\"a b c\");\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok.reset();\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReset_String() {\n+        StrTokenizer tok = new StrTokenizer(\"x x x\");\n+        tok.reset(\"d e\");\n+        assertEquals(\"d\", tok.next());\n+        assertEquals(\"e\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok.reset((String) null);\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReset_charArray() {\n+        StrTokenizer tok = new StrTokenizer(\"x x x\");\n+        \n+        char[] array = new char[] {'a', 'b', 'c'};\n+        tok.reset(array);\n+        assertEquals(\"abc\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok.reset((char[]) null);\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTSV() {\n+        this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE));\n+        this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE.toCharArray()));\n+    }\n+\n+    public void testTSVEmpty() {\n+        this.testEmpty(StrTokenizer.getCSVInstance());\n+        this.testEmpty(StrTokenizer.getCSVInstance(\"\"));\n+    }\n+\n+    void testXSVAbc(StrTokenizer tokenizer) {\n+        this.checkClone(tokenizer);\n+        assertEquals(-1, tokenizer.previousIndex());\n+        assertEquals(0, tokenizer.nextIndex());\n+        assertEquals(null, tokenizer.previousToken());\n+        assertEquals(\"A\", tokenizer.nextToken());\n+        assertEquals(1, tokenizer.nextIndex());\n+        assertEquals(\"b\", tokenizer.nextToken());\n+        assertEquals(2, tokenizer.nextIndex());\n+        assertEquals(\"c\", tokenizer.nextToken());\n+        assertEquals(3, tokenizer.nextIndex());\n+        assertEquals(null, tokenizer.nextToken());\n+        assertEquals(3, tokenizer.nextIndex());\n+        assertEquals(\"c\", tokenizer.previousToken());\n+        assertEquals(2, tokenizer.nextIndex());\n+        assertEquals(\"b\", tokenizer.previousToken());\n+        assertEquals(1, tokenizer.nextIndex());\n+        assertEquals(\"A\", tokenizer.previousToken());\n+        assertEquals(0, tokenizer.nextIndex());\n+        assertEquals(null, tokenizer.previousToken());\n+        assertEquals(0, tokenizer.nextIndex());\n+        assertEquals(-1, tokenizer.previousIndex());\n+        assertEquals(3, tokenizer.size());\n+    }\n+\n+    public void testIteration() {\n+        StrTokenizer tkn = new StrTokenizer(\"a b c\");\n+        assertEquals(false, tkn.hasPrevious());\n+        try {\n+            tkn.previous();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        assertEquals(true, tkn.hasNext());\n+        \n+        assertEquals(\"a\", tkn.next());\n+        try {\n+            tkn.remove();\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+        try {\n+            tkn.set(\"x\");\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+        try {\n+            tkn.add(\"y\");\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+        assertEquals(true, tkn.hasPrevious());\n+        assertEquals(true, tkn.hasNext());\n+        \n+        assertEquals(\"b\", tkn.next());\n+        assertEquals(true, tkn.hasPrevious());\n+        assertEquals(true, tkn.hasNext());\n+        \n+        assertEquals(\"c\", tkn.next());\n+        assertEquals(true, tkn.hasPrevious());\n+        assertEquals(false, tkn.hasNext());\n+        \n+        try {\n+            tkn.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        assertEquals(true, tkn.hasPrevious());\n+        assertEquals(false, tkn.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTokenizeSubclassInputChange() {\n+        StrTokenizer tkn = new StrTokenizer(\"a b c d e\") {\n+            @Override\n+            protected List<String> tokenize(char[] chars, int offset, int count) {\n+                return super.tokenize(\"w x y z\".toCharArray(), 2, 5);\n+            }\n+        };\n+        assertEquals(\"x\", tkn.next());\n+        assertEquals(\"y\", tkn.next());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTokenizeSubclassOutputChange() {\n+        StrTokenizer tkn = new StrTokenizer(\"a b c\") {\n+            @Override\n+            protected List<String> tokenize(char[] chars, int offset, int count) {\n+                List<String> list = super.tokenize(chars, offset, count);\n+                Collections.reverse(list);\n+                return list;\n+            }\n+        };\n+        assertEquals(\"c\", tkn.next());\n+        assertEquals(\"b\", tkn.next());\n+        assertEquals(\"a\", tkn.next());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        StrTokenizer tkn = new StrTokenizer(\"a b c d e\");\n+        assertEquals(\"StrTokenizer[not tokenized yet]\", tkn.toString());\n+        tkn.next();\n+        assertEquals(\"StrTokenizer[a, b, c, d, e]\", tkn.toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/text/translate/EntityArraysTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text.translate;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit tests for {@link org.apache.commons.lang.text.translate.EntityArrays}.\n+ */\n+public class EntityArraysTest extends TestCase {\n+\n+    public void testConstructorExists() {\n+        new EntityArrays();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/text/translate/LookupTranslatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text.translate;\n+\n+import junit.framework.TestCase;\n+\n+import java.io.StringWriter;\n+import java.io.IOException;\n+\n+/**\n+ * Unit tests for {@link org.apache.commons.lang.text.translate.LookupTranslator}.\n+ */\n+public class LookupTranslatorTest extends TestCase {\n+\n+    public void testBasicLookup() throws IOException {\n+        LookupTranslator lt = new LookupTranslator(new CharSequence[][] { { \"one\", \"two\" } });\n+        StringWriter out = new StringWriter();\n+        int result = lt.translate(\"one\", 0, out);\n+        assertEquals(\"Incorrect codepoint consumption\", 3, result);\n+        assertEquals(\"Incorrect value\", \"two\", out.toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/text/translate/NumericEntityEscaperTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text.translate;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit tests for {@link org.apache.commons.lang.text.translate.NumericEntityEscaper}.\n+ */\n+public class NumericEntityEscaperTest extends TestCase {\n+\n+    public void testBelow() {\n+        NumericEntityEscaper nee = NumericEntityEscaper.below('F');\n+\n+        String input = \"ADFGZ\";\n+        String result = nee.translate(input);\n+        assertEquals(\"Failed to escape numeric entities via the below method\", \"&#65;&#68;FGZ\", result);\n+    }\n+\n+    public void testBetween() {\n+        NumericEntityEscaper nee = NumericEntityEscaper.between('F', 'L');\n+\n+        String input = \"ADFGZ\";\n+        String result = nee.translate(input);\n+        assertEquals(\"Failed to escape numeric entities via the between method\", \"AD&#70;&#71;Z\", result);\n+    }\n+\n+    public void testAbove() {\n+        NumericEntityEscaper nee = NumericEntityEscaper.above('F');\n+\n+        String input = \"ADFGZ\";\n+        String result = nee.translate(input);\n+        assertEquals(\"Failed to escape numeric entities via the above method\", \"ADF&#71;&#90;\", result);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/text/translate/UnicodeEscaperTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text.translate;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit tests for {@link org.apache.commons.lang.text.translate.UnicodeEscaper}.\n+ */\n+public class UnicodeEscaperTest extends TestCase {\n+\n+    public void testBelow() {\n+        UnicodeEscaper nee = UnicodeEscaper.below('F');\n+\n+        String input = \"ADFGZ\";\n+        String result = nee.translate(input);\n+        assertEquals(\"Failed to escape unicode characters via the below method\", \"\\\\u0041\\\\u0044FGZ\", result);\n+    }\n+\n+    public void testBetween() {\n+        UnicodeEscaper nee = UnicodeEscaper.between('F', 'L');\n+\n+        String input = \"ADFGZ\";\n+        String result = nee.translate(input);\n+        assertEquals(\"Failed to escape unicode characters via the between method\", \"AD\\\\u0046\\\\u0047Z\", result);\n+    }\n+\n+    public void testAbove() {\n+        UnicodeEscaper nee = UnicodeEscaper.above('F');\n+\n+        String input = \"ADFGZ\";\n+        String result = nee.translate(input);\n+        assertEquals(\"Failed to escape unicode characters via the above method\", \"ADF\\\\u0047\\\\u005A\", result);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/text/translate/UnicodeUnescaperTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text.translate;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit tests for {@link org.apache.commons.lang.text.translate.UnicodeEscaper}.\n+ */\n+public class UnicodeUnescaperTest extends TestCase {\n+\n+    // Requested in LANG-507\n+    public void testUPlus() {\n+        UnicodeUnescaper uu = new UnicodeUnescaper();\n+\n+        String input = \"\\\\u+0047\";\n+        try {\n+            uu.translate(input);\n+            fail(\"Default behaviour should not parse u+\");\n+        } catch(IllegalArgumentException iae) {\n+            // expected\n+        }\n+\n+        uu = new UnicodeUnescaper(UnicodeUnescaper.OPTION.escapePlus);\n+        assertEquals(\"Failed to unescape unicode characters with 'u+' notation\", \"G\", uu.translate(input));\n+    }\n+\n+    public void testUuuuu() {\n+        UnicodeUnescaper uu = new UnicodeUnescaper();\n+\n+        String input = \"\\\\uuuuuuuu0047\";\n+        String result = uu.translate(input);\n+        assertEquals(\"Failed to unescape unicode characters with many 'u' characters\", \"G\", result);\n+    }\n+\n+    public void testLessThanFour() {\n+        UnicodeUnescaper uu = new UnicodeUnescaper();\n+\n+        String input = \"\\\\0047\\\\u006\";\n+        try {\n+            uu.translate(input);\n+            fail(\"A lack of digits in a unicode escape sequence failed to throw an exception\");\n+        } catch(IllegalArgumentException iae) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/time/DateFormatUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.Calendar;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * TestCase for DateFormatUtils.\n+ *\n+ * @author Apache Software Foundation\n+ * @author Apache Ant - DateUtilsTest\n+ * @author <a href=\"mailto:sbailliez@apache.org\">Stephane Bailliez</a>\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ */\n+public class DateFormatUtilsTest extends TestCase {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(DateFormatUtilsTest.class);\n+        suite.setName(\"DateFormatUtils Tests\");\n+        return suite;\n+    }\n+\n+    public DateFormatUtilsTest(String s) {\n+        super(s);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new DateFormatUtils());\n+        Constructor<?>[] cons = DateFormatUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(DateFormatUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(DateFormatUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testFormat() {\n+        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n+        c.set(2005,0,1,12,0,0);\n+        c.setTimeZone(TimeZone.getDefault());\n+        StringBuffer buffer = new StringBuffer ();\n+        int year = c.get(Calendar.YEAR);\n+        int month = c.get(Calendar.MONTH) + 1;\n+        int day = c.get(Calendar.DAY_OF_MONTH);\n+        int hour = c.get(Calendar.HOUR_OF_DAY);\n+        buffer.append (year);\n+        buffer.append(month);\n+        buffer.append(day);\n+        buffer.append(hour);\n+        assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime(), \"yyyyMdH\"));\n+        \n+        assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime().getTime(), \"yyyyMdH\"));\n+        \n+        assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime(), \"yyyyMdH\", Locale.US));\n+        \n+        assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime().getTime(), \"yyyyMdH\", Locale.US));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testFormatCalendar() {\n+        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n+        c.set(2005,0,1,12,0,0);\n+        c.setTimeZone(TimeZone.getDefault());\n+        StringBuffer buffer = new StringBuffer ();\n+        int year = c.get(Calendar.YEAR);\n+        int month = c.get(Calendar.MONTH) + 1;\n+        int day = c.get(Calendar.DAY_OF_MONTH);\n+        int hour = c.get(Calendar.HOUR_OF_DAY);\n+        buffer.append (year);\n+        buffer.append(month);\n+        buffer.append(day);\n+        buffer.append(hour);\n+        assertEquals(buffer.toString(), DateFormatUtils.format(c, \"yyyyMdH\"));\n+        \n+        assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime(), \"yyyyMdH\"));\n+        \n+        assertEquals(buffer.toString(), DateFormatUtils.format(c, \"yyyyMdH\", Locale.US));\n+        \n+        assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime(), \"yyyyMdH\", Locale.US));\n+    }\n+    \n+    public void testFormatUTC() {\n+        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n+        c.set(2005,0,1,12,0,0);\n+        assertEquals (\"2005-01-01T12:00:00\", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern()));\n+        \n+        assertEquals (\"2005-01-01T12:00:00\", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern()));\n+        \n+        assertEquals (\"2005-01-01T12:00:00\", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US));\n+        \n+        assertEquals (\"2005-01-01T12:00:00\", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US));\n+    }\n+    \n+    public void testDateTimeISO(){\n+        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        Calendar cal = Calendar.getInstance(timeZone);\n+        cal.set(2002,1,23,9,11,12);\n+        String text = DateFormatUtils.format(cal.getTime(), \n+                        DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23T09:11:12\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                      DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23T09:11:12\", text);\n+        text = DateFormatUtils.ISO_DATETIME_FORMAT.format(cal);\n+        assertEquals(\"2002-02-23T09:11:12\", text);\n+        \n+        text = DateFormatUtils.format(cal.getTime(), \n+                      DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23T09:11:12-03:00\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                      DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23T09:11:12-03:00\", text);\n+        text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(cal);\n+        assertEquals(\"2002-02-23T09:11:12-03:00\", text);\n+    }\n+\n+    public void testDateISO(){\n+        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        Calendar cal = Calendar.getInstance(timeZone);\n+        cal.set(2002,1,23,10,11,12);\n+        String text = DateFormatUtils.format(cal.getTime(), \n+                        DateFormatUtils.ISO_DATE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                        DateFormatUtils.ISO_DATE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23\", text);\n+        text = DateFormatUtils.ISO_DATE_FORMAT.format(cal);\n+        assertEquals(\"2002-02-23\", text);\n+        \n+        text = DateFormatUtils.format(cal.getTime(), \n+                      DateFormatUtils.ISO_DATE_TIME_ZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23-03:00\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                      DateFormatUtils.ISO_DATE_TIME_ZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23-03:00\", text);\n+        text = DateFormatUtils.ISO_DATE_TIME_ZONE_FORMAT.format(cal);\n+        assertEquals(\"2002-02-23-03:00\", text);\n+    }\n+\n+    public void testTimeISO(){\n+        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        Calendar cal = Calendar.getInstance(timeZone);\n+        cal.set(2002,1,23,10,11,12);\n+        String text = DateFormatUtils.format(cal.getTime(), \n+                        DateFormatUtils.ISO_TIME_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"T10:11:12\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                        DateFormatUtils.ISO_TIME_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"T10:11:12\", text);\n+        text = DateFormatUtils.ISO_TIME_FORMAT.format(cal);\n+        assertEquals(\"T10:11:12\", text);\n+        \n+        text = DateFormatUtils.format(cal.getTime(), \n+                      DateFormatUtils.ISO_TIME_TIME_ZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"T10:11:12-03:00\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                      DateFormatUtils.ISO_TIME_TIME_ZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"T10:11:12-03:00\", text);\n+        text = DateFormatUtils.ISO_TIME_TIME_ZONE_FORMAT.format(cal);\n+        assertEquals(\"T10:11:12-03:00\", text);\n+    }\n+\n+    public void testTimeNoTISO(){\n+        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        Calendar cal = Calendar.getInstance(timeZone);\n+        cal.set(2002,1,23,10,11,12);\n+        String text = DateFormatUtils.format(cal.getTime(), \n+                        DateFormatUtils.ISO_TIME_NO_T_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"10:11:12\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                        DateFormatUtils.ISO_TIME_NO_T_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"10:11:12\", text);\n+        text = DateFormatUtils.ISO_TIME_NO_T_FORMAT.format(cal);\n+        assertEquals(\"10:11:12\", text);\n+        \n+        text = DateFormatUtils.format(cal.getTime(), \n+                      DateFormatUtils.ISO_TIME_NO_T_TIME_ZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"10:11:12-03:00\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                      DateFormatUtils.ISO_TIME_NO_T_TIME_ZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"10:11:12-03:00\", text);\n+        text = DateFormatUtils.ISO_TIME_NO_T_TIME_ZONE_FORMAT.format(cal);\n+        assertEquals(\"10:11:12-03:00\", text);\n+    }\n+\n+    public void testSMTP(){\n+        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        Calendar cal = Calendar.getInstance(timeZone);\n+        cal.set(2003,5,8,10,11,12);\n+        String text = DateFormatUtils.format(cal.getTime(), \n+                        DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone,\n+                        DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale());\n+        assertEquals(\"Sun, 08 Jun 2003 10:11:12 -0300\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                        DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone,\n+                        DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale());\n+        assertEquals(\"Sun, 08 Jun 2003 10:11:12 -0300\", text);\n+        text = DateFormatUtils.SMTP_DATETIME_FORMAT.format(cal);\n+        assertEquals(\"Sun, 08 Jun 2003 10:11:12 -0300\", text);\n+        \n+        // format UTC\n+        text = DateFormatUtils.formatUTC(cal.getTime().getTime(), \n+                        DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(),\n+                        DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale());\n+        assertEquals(\"Sun, 08 Jun 2003 13:11:12 +0000\", text);\n+    }\n+\n+    /*\n+    public void testLang312() {\n+        String pattern = \"dd/MM/yyyy\";\n+        String expected = \"19/04/1948\";\n+        TimeZone timeZone = TimeZone.getTimeZone(\"CET\");\n+        Locale locale = Locale.GERMANY;\n+\n+        // show Calendar is good\n+        Calendar cal = Calendar.getInstance(timeZone, locale);\n+        cal.set(1948, 3, 19);\n+        assertEquals(expected, DateFormatUtils.format( cal.getTime(), pattern, timeZone, locale ) );\n+\n+        Date date = new Date(48, 3, 19);\n+\n+        // test JDK\n+        java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat(pattern, locale);\n+        sdf.setTimeZone(timeZone);\n+// There's nothing we can do if the JDK fails, so just going to pring a warning in this case\n+//        assertEquals(expected, sdf.format( date ) );\n+        if( ! expected.equals( sdf.format( date ) ) ) {\n+            System.out.println(\"WARNING: JDK test failed - testLang312()\");\n+        }\n+\n+        // test Commons\n+        assertEquals(expected, DateFormatUtils.format( date, pattern, timeZone, locale ) );\n+    }\n+    */\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/time/DateUtilsFragmentTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class DateUtilsFragmentTest extends TestCase {\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(DateUtilsFragmentTest.class);\n+        suite.setName(\"DateUtils Fragment Tests\");\n+        return suite;\n+    }\n+\n+    private static final int months = 7;   // second final prime before 12\n+    private static final int days = 23;    // second final prime before 31 (and valid)\n+    private static final int hours = 19;   // second final prime before 24\n+    private static final int minutes = 53; // second final prime before 60\n+    private static final int seconds = 47; // third final prime before 60\n+    private static final int millis = 991; // second final prime before 1000\n+\n+    private Date aDate;\n+    private Calendar aCalendar;\n+\n+    @Override\n+    protected void setUp() {\n+        aCalendar = Calendar.getInstance();\n+        aCalendar.set(2005, months, days, hours, minutes, seconds);\n+        aCalendar.set(Calendar.MILLISECOND, millis);\n+        aDate = aCalendar.getTime();\n+    }\n+    \n+    public void testNullDate() {\n+        try {\n+            DateUtils.getFragmentInMilliseconds((Date) null, Calendar.MILLISECOND);\n+            fail();\n+        } catch(IllegalArgumentException iae) {}\n+\n+        try {\n+            DateUtils.getFragmentInSeconds((Date) null, Calendar.MILLISECOND);\n+            fail();\n+        } catch(IllegalArgumentException iae) {}\n+\n+        try {\n+            DateUtils.getFragmentInMinutes((Date) null, Calendar.MILLISECOND);\n+            fail();\n+        } catch(IllegalArgumentException iae) {}\n+\n+        try {\n+            DateUtils.getFragmentInHours((Date) null, Calendar.MILLISECOND);\n+            fail();\n+        } catch(IllegalArgumentException iae) {}\n+\n+        try {\n+            DateUtils.getFragmentInDays((Date) null, Calendar.MILLISECOND);\n+            fail();\n+        } catch(IllegalArgumentException iae) {}\n+    }\n+\n+    public void testNullCalendar() {\n+        try {\n+            DateUtils.getFragmentInMilliseconds((Calendar) null, Calendar.MILLISECOND);\n+            fail();\n+        } catch(IllegalArgumentException iae) {}\n+\n+        try {\n+            DateUtils.getFragmentInSeconds((Calendar) null, Calendar.MILLISECOND);\n+            fail();\n+        } catch(IllegalArgumentException iae) {}\n+\n+        try {\n+            DateUtils.getFragmentInMinutes((Calendar) null, Calendar.MILLISECOND);\n+            fail();\n+        } catch(IllegalArgumentException iae) {}\n+\n+        try {\n+            DateUtils.getFragmentInHours((Calendar) null, Calendar.MILLISECOND);\n+            fail();\n+        } catch(IllegalArgumentException iae) {}\n+\n+        try {\n+            DateUtils.getFragmentInDays((Calendar) null, Calendar.MILLISECOND);\n+            fail();\n+        } catch(IllegalArgumentException iae) {}\n+    }\n+    \n+    public void testInvalidFragmentWithDate() {\n+        try {\n+            DateUtils.getFragmentInMilliseconds(aDate, 0);\n+            fail();\n+        } catch(IllegalArgumentException iae) {}\n+\n+        try {\n+            DateUtils.getFragmentInSeconds(aDate, 0);\n+            fail();\n+        } catch(IllegalArgumentException iae) {}\n+\n+        try {\n+            DateUtils.getFragmentInMinutes(aDate, 0);\n+            fail();\n+        } catch(IllegalArgumentException iae) {}\n+\n+        try {\n+            DateUtils.getFragmentInHours(aDate, 0);\n+            fail();\n+        } catch(IllegalArgumentException iae) {}\n+\n+        try {\n+            DateUtils.getFragmentInDays(aDate, 0);\n+            fail();\n+        } catch(IllegalArgumentException iae) {}\n+    }\n+\n+    public void testInvalidFragmentWithCalendar() {\n+        try {\n+            DateUtils.getFragmentInMilliseconds(aCalendar, 0);\n+            fail();\n+        } catch(IllegalArgumentException iae) {}\n+\n+        try {\n+            DateUtils.getFragmentInSeconds(aCalendar, 0);\n+            fail();\n+        } catch(IllegalArgumentException iae) {}\n+\n+        try {\n+            DateUtils.getFragmentInMinutes(aCalendar, 0);\n+            fail();\n+        } catch(IllegalArgumentException iae) {}\n+\n+        try {\n+            DateUtils.getFragmentInHours(aCalendar, 0);\n+            fail();\n+        } catch(IllegalArgumentException iae) {}\n+\n+        try {\n+            DateUtils.getFragmentInDays(aCalendar, 0);\n+            fail();\n+        } catch(IllegalArgumentException iae) {}\n+    }\n+\n+    public void testMillisecondFragmentInLargerUnitWithDate() {\n+        assertEquals(0, DateUtils.getFragmentInMilliseconds(aDate, Calendar.MILLISECOND));\n+        assertEquals(0, DateUtils.getFragmentInSeconds(aDate, Calendar.MILLISECOND));\n+        assertEquals(0, DateUtils.getFragmentInMinutes(aDate, Calendar.MILLISECOND));\n+        assertEquals(0, DateUtils.getFragmentInHours(aDate, Calendar.MILLISECOND));\n+        assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.MILLISECOND));\n+    }\n+\n+    public void testMillisecondFragmentInLargerUnitWithCalendar() {\n+        assertEquals(0, DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.MILLISECOND));\n+        assertEquals(0, DateUtils.getFragmentInSeconds(aCalendar, Calendar.MILLISECOND));\n+        assertEquals(0, DateUtils.getFragmentInMinutes(aCalendar, Calendar.MILLISECOND));\n+        assertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.MILLISECOND));\n+        assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.MILLISECOND));\n+    }\n+    \n+    public void testSecondFragmentInLargerUnitWithDate() {\n+        assertEquals(0, DateUtils.getFragmentInSeconds(aDate, Calendar.SECOND));\n+        assertEquals(0, DateUtils.getFragmentInMinutes(aDate, Calendar.SECOND));\n+        assertEquals(0, DateUtils.getFragmentInHours(aDate, Calendar.SECOND));\n+        assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.SECOND));\n+    }\n+\n+    public void testSecondFragmentInLargerUnitWithCalendar() {\n+        assertEquals(0, DateUtils.getFragmentInSeconds(aCalendar, Calendar.SECOND));\n+        assertEquals(0, DateUtils.getFragmentInMinutes(aCalendar, Calendar.SECOND));\n+        assertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.SECOND));\n+        assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.SECOND));\n+    }\n+    \n+    public void testMinuteFragmentInLargerUnitWithDate() {\n+        assertEquals(0, DateUtils.getFragmentInMinutes(aDate, Calendar.MINUTE));\n+        assertEquals(0, DateUtils.getFragmentInHours(aDate, Calendar.MINUTE));\n+        assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.MINUTE));\n+    }\n+\n+    public void testMinuteFragmentInLargerUnitWithCalendar() {\n+        assertEquals(0, DateUtils.getFragmentInMinutes(aCalendar, Calendar.MINUTE));\n+        assertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.MINUTE));\n+        assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.MINUTE));\n+    }\n+\n+    public void testHourOfDayFragmentInLargerUnitWithDate() {\n+        assertEquals(0, DateUtils.getFragmentInHours(aDate, Calendar.HOUR_OF_DAY));\n+        assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.HOUR_OF_DAY));\n+    }\n+\n+    public void testHourOfDayFragmentInLargerUnitWithCalendar() {\n+        assertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.HOUR_OF_DAY));\n+        assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.HOUR_OF_DAY));\n+    }\n+\n+    public void testDayOfYearFragmentInLargerUnitWithDate() {\n+        assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.DAY_OF_YEAR));\n+    }\n+\n+    public void testDayOfYearFragmentInLargerUnitWithCalendar() {\n+        assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.DAY_OF_YEAR));\n+    }\n+\n+    public void testDateFragmentInLargerUnitWithDate() {\n+        assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.DATE));\n+    }\n+\n+    public void testDateFragmentInLargerUnitWithCalendar() {\n+        assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.DATE));\n+    }\n+\n+    //Calendar.SECOND as useful fragment\n+    \n+    public void testMillisecondsOfSecondWithDate() {\n+        long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.SECOND);\n+        assertEquals(millis, testResult);\n+    }\n+\n+    public void testMillisecondsOfSecondWithCalendar() {\n+        long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.SECOND);\n+        assertEquals(millis, testResult);\n+        assertEquals(aCalendar.get(Calendar.MILLISECOND), testResult);\n+    }\n+\n+    //Calendar.MINUTE as useful fragment\n+\n+    public void testMillisecondsOfMinuteWithDate() {\n+        long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.MINUTE);\n+        assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND), testResult);\n+    }\n+\n+    public void testMillisecondsOfMinuteWithCalender() {\n+        long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.MINUTE);\n+        assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND), testResult);\n+    }\n+\n+    public void testSecondsofMinuteWithDate() {\n+        long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.MINUTE);\n+        assertEquals(seconds, testResult);\n+    }\n+\n+    public void testSecondsofMinuteWithCalendar() {\n+        long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.MINUTE);\n+        assertEquals(seconds, testResult);\n+        assertEquals(aCalendar.get(Calendar.SECOND), testResult);\n+    }\n+\n+    //Calendar.HOUR_OF_DAY as useful fragment\n+    \n+    public void testMillisecondsOfHourWithDate() {\n+        long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.HOUR_OF_DAY);\n+        assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE), testResult);\n+    }\n+    \n+    public void testMillisecondsOfHourWithCalendar() {\n+        long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.HOUR_OF_DAY);\n+        assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE), testResult);\n+    }\n+\n+    public void testSecondsofHourWithDate() {\n+        long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.HOUR_OF_DAY);\n+        assertEquals(\n+                seconds\n+                        + (minutes\n+                                * DateUtils.MILLIS_PER_MINUTE / DateUtils.MILLIS_PER_SECOND),\n+                testResult);\n+    }\n+\n+    public void testSecondsofHourWithCalendar() {\n+        long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.HOUR_OF_DAY);\n+        assertEquals(\n+                seconds\n+                        + (minutes\n+                                * DateUtils.MILLIS_PER_MINUTE / DateUtils.MILLIS_PER_SECOND),\n+                testResult);\n+    }\n+\n+    public void testMinutesOfHourWithDate() {\n+        long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.HOUR_OF_DAY);\n+        assertEquals(minutes, testResult);\n+    }\n+\n+    public void testMinutesOfHourWithCalendar() {\n+        long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.HOUR_OF_DAY);\n+        assertEquals(minutes, testResult);\n+    }\n+\n+    //Calendar.DATE and Calendar.DAY_OF_YEAR as useful fragment\n+    public void testMillisecondsOfDayWithDate() {\n+        long testresult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.DATE);\n+        long expectedValue = millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR); \n+        assertEquals(expectedValue, testresult);\n+        testresult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.DAY_OF_YEAR);\n+        assertEquals(expectedValue, testresult);\n+    }\n+    \n+    public void testMillisecondsOfDayWithCalendar() {\n+        long testresult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.DATE);\n+        long expectedValue = millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR); \n+        assertEquals(expectedValue, testresult);\n+        testresult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.DAY_OF_YEAR);\n+        assertEquals(expectedValue, testresult);\n+    }\n+\n+    public void testSecondsOfDayWithDate() {\n+        long testresult = DateUtils.getFragmentInSeconds(aDate, Calendar.DATE);\n+        long expectedValue = seconds + ((minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_SECOND;\n+        assertEquals(expectedValue, testresult);\n+        testresult = DateUtils.getFragmentInSeconds(aDate, Calendar.DAY_OF_YEAR);\n+        assertEquals(expectedValue, testresult);\n+    }\n+\n+    public void testSecondsOfDayWithCalendar() {\n+        long testresult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.DATE);\n+        long expectedValue = seconds + ((minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_SECOND;\n+        assertEquals(expectedValue, testresult);\n+        testresult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.DAY_OF_YEAR);\n+        assertEquals(expectedValue, testresult);\n+    }\n+\n+    public void testMinutesOfDayWithDate() {\n+        long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE);\n+        long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE; \n+        assertEquals(expectedValue,testResult);\n+        testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR);\n+        assertEquals(expectedValue,testResult);\n+    }\n+\n+    public void testMinutesOfDayWithCalendar() {\n+        long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.DATE);\n+        long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE; \n+        assertEquals(expectedValue, testResult);\n+        testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.DAY_OF_YEAR);\n+        assertEquals(expectedValue, testResult);\n+    }\n+    \n+    public void testHoursOfDayWithDate() {\n+        long testResult = DateUtils.getFragmentInHours(aDate, Calendar.DATE);\n+        long expectedValue = hours; \n+        assertEquals(expectedValue,testResult);\n+        testResult = DateUtils.getFragmentInHours(aDate, Calendar.DAY_OF_YEAR);\n+        assertEquals(expectedValue,testResult);\n+    }\n+\n+    public void testHoursOfDayWithCalendar() {\n+        long testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.DATE);\n+        long expectedValue = hours; \n+        assertEquals(expectedValue, testResult);\n+        testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.DAY_OF_YEAR);\n+        assertEquals(expectedValue, testResult);\n+    }\n+    \n+    \n+    //Calendar.MONTH as useful fragment\n+    public void testMillisecondsOfMonthWithDate() {\n+        long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.MONTH);\n+        assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE)\n+                                + (hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY),\n+                testResult);\n+    }\n+\n+    public void testMillisecondsOfMonthWithCalendar() {\n+        long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.MONTH);\n+        assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE)\n+                + (hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY),\n+testResult);\n+    }\n+    \n+    public void testSecondsOfMonthWithDate() {\n+        long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.MONTH);\n+        assertEquals(\n+                seconds\n+                        + ((minutes * DateUtils.MILLIS_PER_MINUTE)\n+                                + (hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY))\n+                        / DateUtils.MILLIS_PER_SECOND,\n+                testResult);\n+    }\n+\n+    public void testSecondsOfMonthWithCalendar() {\n+        long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.MONTH);\n+        assertEquals(\n+                seconds\n+                        + ((minutes * DateUtils.MILLIS_PER_MINUTE)\n+                                + (hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY))\n+                        / DateUtils.MILLIS_PER_SECOND,\n+                testResult);\n+    }\n+\n+    public void testMinutesOfMonthWithDate() {\n+        long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.MONTH);\n+        assertEquals(minutes\n+                                + ((hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY))\n+                        / DateUtils.MILLIS_PER_MINUTE,\n+                testResult);\n+    }\n+\n+    public void testMinutesOfMonthWithCalendar() {\n+        long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.MONTH);\n+        assertEquals( minutes  +((hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY))\n+                        / DateUtils.MILLIS_PER_MINUTE,\n+                testResult);\n+    }\n+\n+    public void testHoursOfMonthWithDate() {\n+        long testResult = DateUtils.getFragmentInHours(aDate, Calendar.MONTH);\n+        assertEquals(hours + ((days * DateUtils.MILLIS_PER_DAY))\n+                        / DateUtils.MILLIS_PER_HOUR,\n+                testResult);\n+    }\n+\n+    public void testHoursOfMonthWithCalendar() {\n+        long testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.MONTH);\n+        assertEquals( hours +((days * DateUtils.MILLIS_PER_DAY))\n+                        / DateUtils.MILLIS_PER_HOUR,\n+                testResult);\n+    }\n+    \n+    //Calendar.YEAR as useful fragment\n+    public void testMillisecondsOfYearWithDate() {\n+        long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.YEAR);\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(aDate);\n+        assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE)\n+                                + (hours * DateUtils.MILLIS_PER_HOUR) + (cal.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY),\n+                testResult);\n+    }\n+\n+    public void testMillisecondsOfYearWithCalendar() {\n+        long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.YEAR);\n+        assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE)\n+                + (hours * DateUtils.MILLIS_PER_HOUR) + (aCalendar.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY),\n+testResult);\n+    }\n+    \n+    public void testSecondsOfYearWithDate() {\n+        long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.YEAR);\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(aDate);\n+        assertEquals(\n+                seconds\n+                        + ((minutes * DateUtils.MILLIS_PER_MINUTE)\n+                                + (hours * DateUtils.MILLIS_PER_HOUR) + (cal.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY))\n+                        / DateUtils.MILLIS_PER_SECOND,\n+                testResult);\n+    }\n+\n+    public void testSecondsOfYearWithCalendar() {\n+        long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.YEAR);\n+        assertEquals(\n+                seconds\n+                        + ((minutes * DateUtils.MILLIS_PER_MINUTE)\n+                                + (hours * DateUtils.MILLIS_PER_HOUR) + (aCalendar.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY))\n+                        / DateUtils.MILLIS_PER_SECOND,\n+                testResult);\n+    }\n+\n+    public void testMinutesOfYearWithDate() {\n+        long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.YEAR);\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(aDate);\n+        assertEquals(minutes\n+                                + ((hours * DateUtils.MILLIS_PER_HOUR) + (cal.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY))\n+                        / DateUtils.MILLIS_PER_MINUTE,\n+                testResult);\n+    }\n+\n+    public void testMinutesOfYearWithCalendar() {\n+        long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.YEAR);\n+        assertEquals( minutes  +((hours * DateUtils.MILLIS_PER_HOUR) + (aCalendar.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY))\n+                        / DateUtils.MILLIS_PER_MINUTE,\n+                testResult);\n+    }\n+\n+    public void testHoursOfYearWithDate() {\n+        long testResult = DateUtils.getFragmentInHours(aDate, Calendar.YEAR);\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(aDate);\n+        assertEquals(hours + ((cal.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY))\n+                        / DateUtils.MILLIS_PER_HOUR,\n+                testResult);\n+    }\n+\n+    public void testHoursOfYearWithCalendar() {\n+        long testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.YEAR);\n+        assertEquals( hours +((aCalendar.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY))\n+                        / DateUtils.MILLIS_PER_HOUR,\n+                testResult);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/time/DateUtilsRoundingTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * These Unit-tests will check all possible extremes when using some rounding-methods of DateUtils.\n+ * The extremes are tested at the switch-point in milliseconds\n+ * \n+ * According to the implementation SEMI_MONTH will either round/truncate to the 1st or 16th\n+ * When rounding Calendar.MONTH it depends on the number of days within that month.\n+ * A month with 28 days will be rounded up from the 15th\n+ * A month with 29 or 30 days will be rounded up from the 16th\n+ * A month with 31 days will be rounded up from the 17th\n+ * \n+ * @author Robert Scholte\n+ * @since 3.0\n+ *\n+ */\n+// TODO: Add DateUtils.ceil()-tests if method is available\n+public class DateUtilsRoundingTest extends TestCase {\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(DateUtilsRoundingTest.class);\n+        suite.setName(\"DateUtils Rounding Tests\");\n+        return suite;\n+    }\n+\n+    DateFormat dateTimeParser;\n+    \n+    Date januaryOneDate;\n+    Date targetYearDate;\n+    //No targetMonths, these must be tested for every type of month(28-31 days)\n+    Date targetDateDate, targetDayOfMonthDate, targetAmDate, targetPmDate;\n+    Date targetHourOfDayDate, targetHourDate;\n+    Date targetMinuteDate;\n+    Date targetSecondDate;\n+    Date targetMilliSecondDate;\n+\n+    Calendar januaryOneCalendar;\n+    FastDateFormat fdf = DateFormatUtils.ISO_DATETIME_FORMAT;\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        dateTimeParser = new SimpleDateFormat(\"MMM dd, yyyy H:mm:ss.SSS\", Locale.ENGLISH);\n+        \n+        targetYearDate = dateTimeParser.parse(\"January 1, 2007 0:00:00.000\");\n+        targetDateDate = targetDayOfMonthDate = dateTimeParser.parse(\"June 1, 2008 0:00:00.000\");\n+        targetAmDate =  dateTimeParser.parse(\"June 1, 2008 0:00:00.000\");\n+        targetPmDate = dateTimeParser.parse(\"June 1, 2008 12:00:00.000\");\n+        targetHourDate = dateTimeParser.parse(\"June 1, 2008 8:00:00.000\");\n+        targetHourOfDayDate = dateTimeParser.parse(\"June 1, 2008 8:00:00.000\");\n+        targetMinuteDate =  dateTimeParser.parse(\"June 1, 2008 8:15:00.000\");\n+        targetSecondDate =  dateTimeParser.parse(\"June 1, 2008 8:15:14.000\");\n+        targetMilliSecondDate =  dateTimeParser.parse(\"June 1, 2008 8:15:14.231\");\n+        \n+        januaryOneDate = dateTimeParser.parse(\"January 1, 2008 0:00:00.000\");\n+        januaryOneCalendar = Calendar.getInstance();\n+        januaryOneCalendar.setTime(januaryOneDate);\n+    }\n+\n+    /**\n+     * Tests DateUtils.round()-method with Calendar.Year\n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testRoundYear() throws Exception {\n+        final int calendarField = Calendar.YEAR;\n+        Date roundedUpDate = dateTimeParser.parse(\"January 1, 2008 0:00:00.000\");\n+        Date roundedDownDate = targetYearDate;\n+        Date lastRoundedDownDate = dateTimeParser.parse(\"June 30, 2007 23:59:59.999\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+    }\n+    \n+    /**\n+     * Tests DateUtils.round()-method with Calendar.MONTH\n+     * Includes rounding months with 28, 29, 30 and 31 days\n+     * Includes rounding to January 1\n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testRoundMonth() throws Exception {\n+        final int calendarField = Calendar.MONTH;\n+        Date roundedUpDate, roundedDownDate, lastRoundedDownDate;\n+        Date minDate, maxDate;\n+        \n+        //month with 28 days\n+        roundedUpDate = dateTimeParser.parse(\"March 1, 2007 0:00:00.000\");\n+        roundedDownDate = dateTimeParser.parse(\"February 1, 2007 0:00:00.000\");\n+        lastRoundedDownDate = dateTimeParser.parse(\"February 14, 2007 23:59:59.999\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+\n+        //month with 29 days\n+        roundedUpDate = dateTimeParser.parse(\"March 1, 2008 0:00:00.000\");\n+        roundedDownDate = dateTimeParser.parse(\"February 1, 2008 0:00:00.000\");\n+        lastRoundedDownDate = dateTimeParser.parse(\"February 15, 2008 23:59:59.999\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+        \n+        //month with 30 days\n+        roundedUpDate = dateTimeParser.parse(\"May 1, 2008 0:00:00.000\");\n+        roundedDownDate = dateTimeParser.parse(\"April 1, 2008 0:00:00.000\");\n+        lastRoundedDownDate = dateTimeParser.parse(\"April 15, 2008 23:59:59.999\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+        \n+        //month with 31 days\n+        roundedUpDate = dateTimeParser.parse(\"June 1, 2008 0:00:00.000\");\n+        roundedDownDate = dateTimeParser.parse(\"May 1, 2008 0:00:00.000\");\n+        lastRoundedDownDate = dateTimeParser.parse(\"May 16, 2008 23:59:59.999\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+        \n+        //round to January 1\n+        minDate = dateTimeParser.parse(\"December 17, 2007 00:00:00.000\");\n+        maxDate = dateTimeParser.parse(\"January 16, 2008 23:59:59.999\");\n+        roundToJanuaryFirst(minDate, maxDate, calendarField);\n+    }\n+    \n+    /**\n+     * Tests DateUtils.round()-method with DateUtils.SEMI_MONTH\n+     * Includes rounding months with 28, 29, 30 and 31 days, each with first and second half \n+     * Includes rounding to January 1\n+     *      \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testRoundSemiMonth() throws Exception {\n+        final int calendarField = DateUtils.SEMI_MONTH;\n+        Date roundedUpDate, roundedDownDate, lastRoundedDownDate;\n+        Date minDate, maxDate;\n+        \n+        //month with 28 days (1)\n+        roundedUpDate = dateTimeParser.parse(\"February 16, 2007 0:00:00.000\");\n+        roundedDownDate = dateTimeParser.parse(\"February 1, 2007 0:00:00.000\");\n+        lastRoundedDownDate = dateTimeParser.parse(\"February 8, 2007 23:59:59.999\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+\n+        //month with 28 days (2)\n+        roundedUpDate = dateTimeParser.parse(\"March 1, 2007 0:00:00.000\");\n+        roundedDownDate = dateTimeParser.parse(\"February 16, 2007 0:00:00.000\");\n+        lastRoundedDownDate = dateTimeParser.parse(\"February 23, 2007 23:59:59.999\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+\n+        //month with 29 days (1)\n+        roundedUpDate = dateTimeParser.parse(\"February 16, 2008 0:00:00.000\");\n+        roundedDownDate = dateTimeParser.parse(\"February 1, 2008 0:00:00.000\");\n+        lastRoundedDownDate = dateTimeParser.parse(\"February 8, 2008 23:59:59.999\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+        \n+        //month with 29 days (2)\n+        roundedUpDate = dateTimeParser.parse(\"March 1, 2008 0:00:00.000\");\n+        roundedDownDate = dateTimeParser.parse(\"February 16, 2008 0:00:00.000\");\n+        lastRoundedDownDate = dateTimeParser.parse(\"February 23, 2008 23:59:59.999\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+\n+        //month with 30 days (1)\n+        roundedUpDate = dateTimeParser.parse(\"April 16, 2008 0:00:00.000\");\n+        roundedDownDate = dateTimeParser.parse(\"April 1, 2008 0:00:00.000\");\n+        lastRoundedDownDate = dateTimeParser.parse(\"April 8, 2008 23:59:59.999\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+\n+        //month with 30 days (2)\n+        roundedUpDate = dateTimeParser.parse(\"May 1, 2008 0:00:00.000\");\n+        roundedDownDate = dateTimeParser.parse(\"April 16, 2008 0:00:00.000\");\n+        lastRoundedDownDate = dateTimeParser.parse(\"April 23, 2008 23:59:59.999\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+        \n+        //month with 31 days (1)\n+        roundedUpDate = dateTimeParser.parse(\"May 16, 2008 0:00:00.000\");\n+        roundedDownDate = dateTimeParser.parse(\"May 1, 2008 0:00:00.000\");\n+        lastRoundedDownDate = dateTimeParser.parse(\"May 8, 2008 23:59:59.999\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+\n+        //month with 31 days (2)\n+        roundedUpDate = dateTimeParser.parse(\"June 1, 2008 0:00:00.000\");\n+        roundedDownDate = dateTimeParser.parse(\"May 16, 2008 0:00:00.000\");\n+        lastRoundedDownDate = dateTimeParser.parse(\"May 23, 2008 23:59:59.999\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+        \n+        //round to January 1\n+        minDate = dateTimeParser.parse(\"December 24, 2007 00:00:00.000\");\n+        maxDate = dateTimeParser.parse(\"January 8, 2008 23:59:59.999\");\n+        roundToJanuaryFirst(minDate, maxDate, calendarField);\n+    }\n+    \n+    /**\n+     * Tests DateUtils.round()-method with Calendar.DATE\n+     * Includes rounding the extremes of one day \n+     * Includes rounding to January 1\n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testRoundDate() throws Exception {\n+        final int calendarField = Calendar.DATE;\n+        Date roundedUpDate, roundedDownDate, lastRoundedDownDate;\n+        Date minDate, maxDate;\n+\n+        roundedUpDate = dateTimeParser.parse(\"June 2, 2008 0:00:00.000\");\n+        roundedDownDate = targetDateDate;\n+        lastRoundedDownDate = dateTimeParser.parse(\"June 1, 2008 11:59:59.999\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+        \n+        //round to January 1\n+        minDate = dateTimeParser.parse(\"December 31, 2007 12:00:00.000\");\n+        maxDate = dateTimeParser.parse(\"January 1, 2008 11:59:59.999\");\n+        roundToJanuaryFirst(minDate, maxDate, calendarField);\n+    }\n+    \n+    /**\n+     * Tests DateUtils.round()-method with Calendar.DAY_OF_MONTH\n+     * Includes rounding the extremes of one day \n+     * Includes rounding to January 1\n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testRoundDayOfMonth() throws Exception {\n+        final int calendarField = Calendar.DAY_OF_MONTH;\n+        Date roundedUpDate, roundedDownDate, lastRoundedDownDate;\n+        Date minDate, maxDate;\n+\n+        roundedUpDate = dateTimeParser.parse(\"June 2, 2008 0:00:00.000\");\n+        roundedDownDate = targetDayOfMonthDate;\n+        lastRoundedDownDate = dateTimeParser.parse(\"June 1, 2008 11:59:59.999\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+        \n+        //round to January 1\n+        minDate = dateTimeParser.parse(\"December 31, 2007 12:00:00.000\");\n+        maxDate = dateTimeParser.parse(\"January 1, 2008 11:59:59.999\");\n+        roundToJanuaryFirst(minDate, maxDate, calendarField);\n+    }\n+    \n+    /**\n+     * Tests DateUtils.round()-method with Calendar.AM_PM\n+     * Includes rounding the extremes of both AM and PM of one day \n+     * Includes rounding to January 1\n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testRoundAmPm() throws Exception {\n+        final int calendarField = Calendar.AM_PM;\n+        Date roundedUpDate, roundedDownDate, lastRoundedDownDate;\n+        Date minDate, maxDate;\n+\n+        //AM\n+        roundedUpDate = dateTimeParser.parse(\"June 1, 2008 12:00:00.000\");\n+        roundedDownDate = targetAmDate;\n+        lastRoundedDownDate = dateTimeParser.parse(\"June 1, 2008 5:59:59.999\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+\n+        //PM\n+        roundedUpDate = dateTimeParser.parse(\"June 2, 2008 0:00:00.000\");\n+        roundedDownDate = targetPmDate;\n+        lastRoundedDownDate = dateTimeParser.parse(\"June 1, 2008 17:59:59.999\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+\n+        //round to January 1\n+        minDate = dateTimeParser.parse(\"December 31, 2007 18:00:00.000\");\n+        maxDate = dateTimeParser.parse(\"January 1, 2008 5:59:59.999\");\n+        roundToJanuaryFirst(minDate, maxDate, calendarField);\n+    }\n+    \n+    /**\n+     * Tests DateUtils.round()-method with Calendar.HOUR_OF_DAY\n+     * Includes rounding the extremes of one hour \n+     * Includes rounding to January 1\n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testRoundHourOfDay() throws Exception {\n+        final int calendarField = Calendar.HOUR_OF_DAY;\n+        Date roundedUpDate, roundedDownDate, lastRoundedDownDate;\n+        Date minDate, maxDate;\n+\n+        roundedUpDate = dateTimeParser.parse(\"June 1, 2008 9:00:00.000\");\n+        roundedDownDate = targetHourOfDayDate;\n+        lastRoundedDownDate = dateTimeParser.parse(\"June 1, 2008 8:29:59.999\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+        \n+        //round to January 1\n+        minDate = dateTimeParser.parse(\"December 31, 2007 23:30:00.000\");\n+        maxDate = dateTimeParser.parse(\"January 1, 2008 0:29:59.999\");\n+        roundToJanuaryFirst(minDate, maxDate, calendarField);\n+    }\n+    \n+    /**\n+     * Tests DateUtils.round()-method with Calendar.HOUR\n+     * Includes rounding the extremes of one hour \n+     * Includes rounding to January 1\n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testRoundHour() throws Exception {\n+        final int calendarField = Calendar.HOUR;\n+        Date roundedUpDate, roundedDownDate, lastRoundedDownDate;\n+        Date minDate, maxDate;\n+\n+        roundedUpDate = dateTimeParser.parse(\"June 1, 2008 9:00:00.000\");\n+        roundedDownDate = targetHourDate;\n+        lastRoundedDownDate = dateTimeParser.parse(\"June 1, 2008 8:29:59.999\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+        \n+        //round to January 1\n+        minDate = dateTimeParser.parse(\"December 31, 2007 23:30:00.000\");\n+        maxDate = dateTimeParser.parse(\"January 1, 2008 0:29:59.999\");\n+        roundToJanuaryFirst(minDate, maxDate, calendarField);\n+    }\n+    \n+    /**\n+     * Tests DateUtils.round()-method with Calendar.MINUTE\n+     * Includes rounding the extremes of one minute \n+     * Includes rounding to January 1\n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testRoundMinute() throws Exception {\n+        final int calendarField = Calendar.MINUTE;\n+        Date roundedUpDate, roundedDownDate, lastRoundedDownDate;\n+        Date minDate, maxDate;\n+\n+        roundedUpDate = dateTimeParser.parse(\"June 1, 2008 8:16:00.000\");\n+        roundedDownDate = targetMinuteDate;\n+        lastRoundedDownDate = dateTimeParser.parse(\"June 1, 2008 8:15:29.999\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+        \n+        //round to January 1\n+        minDate = dateTimeParser.parse(\"December 31, 2007 23:59:30.000\");\n+        maxDate = dateTimeParser.parse(\"January 1, 2008 0:00:29.999\");\n+        roundToJanuaryFirst(minDate, maxDate, calendarField);\n+    }\n+    \n+    /**\n+     * Tests DateUtils.round()-method with Calendar.SECOND\n+     * Includes rounding the extremes of one second \n+     * Includes rounding to January 1\n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testRoundSecond() throws Exception {\n+        final int calendarField = Calendar.SECOND;\n+        Date roundedUpDate, roundedDownDate, lastRoundedDownDate;\n+        Date minDate, maxDate;\n+\n+        roundedUpDate = dateTimeParser.parse(\"June 1, 2008 8:15:15.000\");\n+        roundedDownDate = targetSecondDate;\n+        lastRoundedDownDate = dateTimeParser.parse(\"June 1, 2008 8:15:14.499\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+        \n+        //round to January 1\n+        minDate = dateTimeParser.parse(\"December 31, 2007 23:59:59.500\");\n+        maxDate = dateTimeParser.parse(\"January 1, 2008 0:00:00.499\");\n+        roundToJanuaryFirst(minDate, maxDate, calendarField);\n+    }\n+    \n+    /**\n+     * Tests DateUtils.round()-method with Calendar.MILLISECOND\n+     * Includes rounding the extremes of one second \n+     * Includes rounding to January 1\n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testRoundMilliSecond() throws Exception {\n+        final int calendarField = Calendar.MILLISECOND;\n+        Date roundedUpDate, roundedDownDate, lastRoundedDownDate;\n+        Date minDate, maxDate;\n+\n+        roundedDownDate = lastRoundedDownDate = targetMilliSecondDate;\n+        roundedUpDate = dateTimeParser.parse(\"June 1, 2008 8:15:14.232\");\n+        baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n+        \n+        //round to January 1\n+        minDate = maxDate = januaryOneDate;\n+        roundToJanuaryFirst(minDate, maxDate, calendarField);\n+    }\n+    \n+    /**\n+     * Test DateUtils.truncate()-method with Calendar.YEAR\n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testTruncateYear() throws Exception {\n+        final int calendarField = Calendar.YEAR;\n+        Date lastTruncateDate = dateTimeParser.parse(\"December 31, 2007 23:59:59.999\");\n+        baseTruncateTest(targetYearDate, lastTruncateDate, calendarField);\n+    }\n+\n+    /**\n+     * Test DateUtils.truncate()-method with Calendar.MONTH\n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testTruncateMonth() throws Exception {\n+        final int calendarField = Calendar.MONTH;\n+        Date truncatedDate = dateTimeParser.parse(\"March 1, 2008 0:00:00.000\");\n+        Date lastTruncateDate = dateTimeParser.parse(\"March 31, 2008 23:59:59.999\");\n+        baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);\n+    }\n+\n+    /**\n+     * Test DateUtils.truncate()-method with DateUtils.SEMI_MONTH\n+     * Includes truncating months with 28, 29, 30 and 31 days, each with first and second half\n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testTruncateSemiMonth() throws Exception {\n+        final int calendarField = DateUtils.SEMI_MONTH;\n+        Date truncatedDate, lastTruncateDate;\n+        \n+        //month with 28 days (1)\n+        truncatedDate = dateTimeParser.parse(\"February 1, 2007 0:00:00.000\");\n+        lastTruncateDate = dateTimeParser.parse(\"February 15, 2007 23:59:59.999\");\n+        baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);\n+\n+        //month with 28 days (2)\n+        truncatedDate = dateTimeParser.parse(\"February 16, 2007 0:00:00.000\");\n+        lastTruncateDate = dateTimeParser.parse(\"February 28, 2007 23:59:59.999\");\n+        baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);\n+\n+        //month with 29 days (1)\n+        truncatedDate = dateTimeParser.parse(\"February 1, 2008 0:00:00.000\");\n+        lastTruncateDate = dateTimeParser.parse(\"February 15, 2008 23:59:59.999\");\n+        baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);\n+\n+        //month with 29 days (2)\n+        truncatedDate = dateTimeParser.parse(\"February 16, 2008 0:00:00.000\");\n+        lastTruncateDate = dateTimeParser.parse(\"February 29, 2008 23:59:59.999\");\n+        baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);\n+\n+        //month with 30 days (1)\n+        truncatedDate = dateTimeParser.parse(\"April 1, 2008 0:00:00.000\");\n+        lastTruncateDate = dateTimeParser.parse(\"April 15, 2008 23:59:59.999\");\n+        baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);\n+\n+        //month with 30 days (2)\n+        truncatedDate = dateTimeParser.parse(\"April 16, 2008 0:00:00.000\");\n+        lastTruncateDate = dateTimeParser.parse(\"April 30, 2008 23:59:59.999\");\n+        baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);\n+        \n+        //month with 31 days (1)\n+        truncatedDate = dateTimeParser.parse(\"March 1, 2008 0:00:00.000\");\n+        lastTruncateDate = dateTimeParser.parse(\"March 15, 2008 23:59:59.999\");\n+        baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);\n+\n+        //month with 31 days (2)\n+        truncatedDate = dateTimeParser.parse(\"March 16, 2008 0:00:00.000\");\n+        lastTruncateDate = dateTimeParser.parse(\"March 31, 2008 23:59:59.999\");\n+        baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);\n+\n+    }\n+\n+    /**\n+     * Test DateUtils.truncate()-method with Calendar.DATE\n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testTruncateDate() throws Exception {\n+        final int calendarField = Calendar.DATE;\n+        Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 23:59:59.999\");\n+        baseTruncateTest(targetDateDate, lastTruncateDate, calendarField);\n+    }\n+    \n+    /**\n+     * Test DateUtils.truncate()-method with Calendar.DAY_OF_MONTH\n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testTruncateDayOfMonth() throws Exception {\n+        final int calendarField = Calendar.DAY_OF_MONTH;\n+        Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 23:59:59.999\");\n+        baseTruncateTest(targetDayOfMonthDate, lastTruncateDate, calendarField);\n+    }\n+    \n+    /**\n+     * Test DateUtils.truncate()-method with Calendar.AM_PM\n+     * Includes truncating the extremes of both AM and PM of one day \n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testTruncateAmPm() throws Exception {\n+        final int calendarField = Calendar.AM_PM;\n+        \n+        //AM\n+        Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 11:59:59.999\");\n+        baseTruncateTest(targetAmDate, lastTruncateDate, calendarField);\n+\n+        //PM\n+        lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 23:59:59.999\");\n+        baseTruncateTest(targetPmDate, lastTruncateDate, calendarField);\n+    }\n+    \n+    /**\n+     * Test DateUtils.truncate()-method with Calendar.HOUR\n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testTruncateHour() throws Exception {\n+        final int calendarField = Calendar.HOUR;\n+        Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 8:59:59.999\");\n+        baseTruncateTest(targetHourDate, lastTruncateDate, calendarField);\n+    }\n+    \n+    /**\n+     * Test DateUtils.truncate()-method with Calendar.HOUR_OF_DAY\n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testTruncateHourOfDay() throws Exception {\n+        final int calendarField = Calendar.HOUR_OF_DAY;\n+        Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 8:59:59.999\");\n+        baseTruncateTest(targetHourOfDayDate, lastTruncateDate, calendarField);\n+    }\n+    \n+    /**\n+     * Test DateUtils.truncate()-method with Calendar.MINUTE\n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testTruncateMinute() throws Exception {\n+        final int calendarField = Calendar.MINUTE;\n+        Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 8:15:59.999\");\n+        baseTruncateTest(targetMinuteDate, lastTruncateDate, calendarField);\n+    }\n+    \n+    /**\n+     * Test DateUtils.truncate()-method with Calendar.SECOND\n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testTruncateSecond() throws Exception {\n+        final int calendarField = Calendar.SECOND;\n+        Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 8:15:14.999\");\n+        baseTruncateTest(targetSecondDate, lastTruncateDate, calendarField);\n+    }\n+    \n+    /**\n+     * Test DateUtils.truncate()-method with Calendar.SECOND\n+     * \n+     * @throws Exception\n+     * @since 3.0\n+     */\n+    public void testTruncateMilliSecond() throws Exception {\n+        final int calendarField = Calendar.MILLISECOND;\n+        baseTruncateTest(targetMilliSecondDate, targetMilliSecondDate, calendarField);\n+    }\n+        \n+    /**\n+     * When using this basetest all extremes are tested.<br> \n+     * It will test the Date, Calendar and Object-implementation<br>\n+     * lastRoundDownDate should round down to roundedDownDate<br>\n+     * lastRoundDownDate + 1 millisecond should round up to roundedUpDate\n+     * \n+     * @param roundedUpDate the next rounded date after <strong>roundedDownDate</strong> when using <strong>calendarField</strong>\n+     * @param roundedDownDate the result if <strong>lastRoundDownDate</strong> was rounded with <strong>calendarField</strong>\n+     * @param lastRoundDownDate rounding this value with <strong>calendarField</strong> will result in <strong>roundedDownDate</strong>\n+     * @param calendarField\n+     * @since 3.0\n+     */\n+    protected void baseRoundTest(final Date roundedUpDate, final Date roundedDownDate, final Date lastRoundDownDate, final int calendarField) {\n+        Date firstRoundUpDate = DateUtils.addMilliseconds(lastRoundDownDate, 1);\n+        \n+        //Date-comparison\n+        assertEquals(roundedDownDate, DateUtils.round(roundedDownDate, calendarField));\n+        assertEquals(roundedUpDate, DateUtils.round(roundedUpDate, calendarField));\n+        assertEquals(roundedDownDate, DateUtils.round(lastRoundDownDate, calendarField));\n+        assertEquals(roundedUpDate, DateUtils.round(firstRoundUpDate, calendarField));\n+        \n+        //Calendar-initiations\n+        Calendar roundedUpCalendar, roundedDownCalendar, lastRoundDownCalendar, firstRoundUpCalendar; \n+        roundedDownCalendar = Calendar.getInstance();\n+        roundedUpCalendar = Calendar.getInstance();\n+        lastRoundDownCalendar = Calendar.getInstance();\n+        firstRoundUpCalendar = Calendar.getInstance();\n+        roundedDownCalendar.setTime(roundedDownDate);\n+        roundedUpCalendar.setTime(roundedUpDate);\n+        lastRoundDownCalendar.setTime(lastRoundDownDate);\n+        firstRoundUpCalendar.setTime(firstRoundUpDate);\n+\n+        //Calendar-comparison\n+        assertEquals(roundedDownCalendar, DateUtils.round(roundedDownCalendar, calendarField));\n+        assertEquals(roundedUpCalendar, DateUtils.round(roundedUpCalendar, calendarField));\n+        assertEquals(roundedDownCalendar, DateUtils.round(lastRoundDownCalendar, calendarField));\n+        assertEquals(roundedUpCalendar, DateUtils.round(firstRoundUpCalendar, calendarField));\n+\n+        //Object-comparison\n+        assertEquals(roundedDownDate, DateUtils.round((Object) roundedDownDate, calendarField));\n+        assertEquals(roundedUpDate, DateUtils.round((Object) roundedUpDate, calendarField));\n+        assertEquals(roundedDownDate, DateUtils.round((Object) lastRoundDownDate, calendarField));\n+        assertEquals(roundedUpDate, DateUtils.round((Object) firstRoundUpDate, calendarField));\n+        assertEquals(roundedDownDate, DateUtils.round((Object) roundedDownCalendar, calendarField));\n+        assertEquals(roundedUpDate, DateUtils.round((Object) roundedUpCalendar, calendarField));\n+        assertEquals(roundedDownDate, DateUtils.round((Object) lastRoundDownDate, calendarField));\n+        assertEquals(roundedUpDate, DateUtils.round((Object) firstRoundUpDate, calendarField));\n+    }\n+    \n+    /**\n+     * When using this basetest all extremes are tested.<br> \n+     * It will test the Date, Calendar and Object-implementation<br>\n+     * lastTruncateDate should round down to truncatedDate<br>\n+     * lastTruncateDate + 1 millisecond should never round down to truncatedDate\n+     * \n+     * @param truncatedDate expected Date when <strong>lastTruncateDate</strong> is truncated with <strong>calendarField</strong>\n+     * @param lastTruncateDate the last possible Date which will truncate to <strong>truncatedDate</strong> with <strong>calendarField</strong>\n+     * @param calendarField a Calendar.field value\n+     * @since 3.0\n+     */\n+    protected void baseTruncateTest(final Date truncatedDate, final Date lastTruncateDate, final int calendarField) {\n+        Date nextTruncateDate = DateUtils.addMilliseconds(lastTruncateDate, 1);\n+        \n+        //Date-comparison\n+        assertEquals(\"Truncating \"+ fdf.format(truncatedDate) +\" as Date with CalendarField-value \"+ calendarField +\" must return itself\", truncatedDate, DateUtils.truncate(truncatedDate, calendarField));\n+        assertEquals(truncatedDate, DateUtils.truncate(lastTruncateDate, calendarField));\n+        assertFalse(fdf.format(lastTruncateDate) +\" is not an extreme when truncating as Date with CalendarField-value \"+ calendarField, truncatedDate.equals(DateUtils.truncate(nextTruncateDate, calendarField)));\n+        \n+        //Calendar-initiations\n+        Calendar truncatedCalendar, lastTruncateCalendar, nextTruncateCalendar; \n+        truncatedCalendar = Calendar.getInstance();\n+        lastTruncateCalendar = Calendar.getInstance();\n+        nextTruncateCalendar = Calendar.getInstance();\n+        truncatedCalendar.setTime(truncatedDate);\n+        lastTruncateCalendar.setTime(lastTruncateDate);\n+        nextTruncateCalendar.setTime(nextTruncateDate);\n+\n+        //Calendar-comparison\n+        assertEquals(\"Truncating \"+ fdf.format(truncatedCalendar) +\" as Calendar with CalendarField-value \"+ calendarField +\" must return itself\", truncatedCalendar, DateUtils.truncate(truncatedCalendar, calendarField));\n+        assertEquals(truncatedCalendar, DateUtils.truncate(lastTruncateCalendar, calendarField));\n+        assertFalse(fdf.format(lastTruncateCalendar) +\" is not an extreme when truncating as Calendar with CalendarField-value \"+ calendarField, truncatedCalendar.equals(DateUtils.truncate(nextTruncateCalendar, calendarField)));\n+\n+        //Object-comparison\n+        assertEquals(\"Truncating \"+ fdf.format(truncatedDate) +\" as Date cast to Object with CalendarField-value \"+ calendarField +\" must return itself as Date\", truncatedDate, DateUtils.truncate((Object) truncatedDate, calendarField));\n+        assertEquals(truncatedDate, DateUtils.truncate((Object) lastTruncateDate, calendarField));\n+        assertFalse(fdf.format(lastTruncateDate) +\" is not an extreme when truncating as Date cast to Object with CalendarField-value \"+ calendarField, truncatedDate.equals(DateUtils.truncate((Object) nextTruncateDate, calendarField)));\n+        assertEquals(\"Truncating \"+ fdf.format(truncatedCalendar) +\" as Calendar cast to Object with CalendarField-value \"+ calendarField +\" must return itself as Date\", truncatedDate, DateUtils.truncate((Object) truncatedCalendar, calendarField));\n+        assertEquals(truncatedDate, DateUtils.truncate((Object) lastTruncateCalendar, calendarField));\n+        assertFalse(fdf.format(lastTruncateCalendar) +\" is not an extreme when truncating as Calendar cast to Object with CalendarField-value \"+ calendarField, truncatedDate.equals(DateUtils.truncate((Object) nextTruncateCalendar, calendarField)));\n+    }\n+    \n+    /**\n+     * \n+     * Any January 1 could be considered as the ultimate extreme.\n+     * Instead of comparing the results if the input has a difference of 1 millisecond we check the output to be exactly January first. \n+     * \n+     * @param minDate\n+     * @param maxDate\n+     * @param calendarField\n+     * @since 3.0\n+     */\n+    protected void roundToJanuaryFirst(Date minDate, Date maxDate, int calendarField) {\n+        assertEquals(\"Rounding \"+ fdf.format(januaryOneDate) +\" as Date with CalendarField-value \"+ calendarField +\" must return itself\", januaryOneDate, DateUtils.round(januaryOneDate, calendarField));\n+        assertEquals(januaryOneDate, DateUtils.round(minDate, calendarField));\n+        assertEquals(januaryOneDate, DateUtils.round(maxDate, calendarField));\n+        \n+        Calendar minCalendar = Calendar.getInstance();\n+        minCalendar.setTime(minDate);\n+        Calendar maxCalendar = Calendar.getInstance();\n+        maxCalendar.setTime(maxDate);\n+        assertEquals(\"Rounding \"+ fdf.format(januaryOneCalendar) +\" as Date with CalendarField-value \"+ calendarField +\" must return itself\", januaryOneCalendar, DateUtils.round(januaryOneCalendar, calendarField));\n+        assertEquals(januaryOneCalendar, DateUtils.round(minCalendar, calendarField));\n+        assertEquals(januaryOneCalendar, DateUtils.round(maxCalendar, calendarField));\n+\n+        Date toPrevRoundDate = DateUtils.addMilliseconds(minDate, -1);\n+        Date toNextRoundDate = DateUtils.addMilliseconds(maxDate, 1);\n+        assertFalse(fdf.format(minDate) +\" is not an lower-extreme when rounding as Date with CalendarField-value \"+ calendarField, januaryOneDate.equals(DateUtils.round(toPrevRoundDate, calendarField)));\n+        assertFalse(fdf.format(maxDate) +\" is not an upper-extreme when rounding as Date with CalendarField-value \"+ calendarField, januaryOneDate.equals(DateUtils.round(toNextRoundDate, calendarField)));\n+        \n+        Calendar toPrevRoundCalendar = Calendar.getInstance();\n+        toPrevRoundCalendar.setTime(toPrevRoundDate);\n+        Calendar toNextRoundCalendar = Calendar.getInstance();\n+        toNextRoundCalendar.setTime(toNextRoundDate);\n+        assertFalse(fdf.format(minCalendar) +\" is not an lower-extreme when rounding as Date with CalendarField-value \"+ calendarField, januaryOneDate.equals(DateUtils.round(toPrevRoundDate, calendarField)));\n+        assertFalse(fdf.format(maxCalendar) +\" is not an upper-extreme when rounding as Date with CalendarField-value \"+ calendarField, januaryOneDate.equals(DateUtils.round(toNextRoundDate, calendarField)));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/time/DateUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.NoSuchElementException;\n+import java.util.TimeZone;\n+\n+import junit.framework.AssertionFailedError;\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.lang.SystemUtils;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.time.DateUtils}.\n+ *\n+ * @author <a href=\"mailto:sergek@lokitech.com\">Serge Knystautas</a>\n+ * @author <a href=\"mailto:steve@mungoknotwise.com\">Steven Caswell</a>\n+ */\n+public class DateUtilsTest extends TestCase {\n+\n+    private static final long MILLIS_TEST;\n+    static {\n+        GregorianCalendar cal = new GregorianCalendar(2000, 6, 5, 4, 3, 2);\n+        cal.set(Calendar.MILLISECOND, 1);\n+        MILLIS_TEST = cal.getTime().getTime();\n+    }\n+\n+    DateFormat dateParser = null;\n+    DateFormat dateTimeParser = null;\n+    DateFormat timeZoneDateParser = null;\n+    Date dateAmPm1 = null;\n+    Date dateAmPm2 = null;\n+    Date dateAmPm3 = null;\n+    Date dateAmPm4 = null;\n+    Date date0 = null;\n+    Date date1 = null;\n+    Date date2 = null;\n+    Date date3 = null;\n+    Date date4 = null;\n+    Date date5 = null;\n+    Date date6 = null;\n+    Date date7 = null;\n+    Date date8 = null;\n+    Calendar calAmPm1 = null;\n+    Calendar calAmPm2 = null;\n+    Calendar calAmPm3 = null;\n+    Calendar calAmPm4 = null;\n+    Calendar cal1 = null;\n+    Calendar cal2 = null;\n+    Calendar cal3 = null;\n+    Calendar cal4 = null;\n+    Calendar cal5 = null;\n+    Calendar cal6 = null;\n+    Calendar cal7 = null;\n+    Calendar cal8 = null;\n+    TimeZone zone = null;\n+    TimeZone defaultZone = null;\n+\n+    public DateUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(DateUtilsTest.class);\n+        suite.setName(\"DateUtils Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+\n+        dateParser = new SimpleDateFormat(\"MMM dd, yyyy\", Locale.ENGLISH);\n+        dateTimeParser = new SimpleDateFormat(\"MMM dd, yyyy H:mm:ss.SSS\", Locale.ENGLISH);\n+\n+        dateAmPm1 = dateTimeParser.parse(\"February 3, 2002 01:10:00.000\");\n+        dateAmPm2 = dateTimeParser.parse(\"February 3, 2002 11:10:00.000\");\n+        dateAmPm3 = dateTimeParser.parse(\"February 3, 2002 13:10:00.000\");\n+        dateAmPm4 = dateTimeParser.parse(\"February 3, 2002 19:10:00.000\");\n+        date0 = dateTimeParser.parse(\"February 3, 2002 12:34:56.789\");\n+        date1 = dateTimeParser.parse(\"February 12, 2002 12:34:56.789\");\n+        date2 = dateTimeParser.parse(\"November 18, 2001 1:23:11.321\");\n+        defaultZone = TimeZone.getDefault();\n+        zone = TimeZone.getTimeZone(\"MET\");\n+        TimeZone.setDefault(zone);\n+        dateTimeParser.setTimeZone(zone);\n+        date3 = dateTimeParser.parse(\"March 30, 2003 05:30:45.000\");\n+        date4 = dateTimeParser.parse(\"March 30, 2003 01:10:00.000\");\n+        date5 = dateTimeParser.parse(\"March 30, 2003 01:40:00.000\");\n+        date6 = dateTimeParser.parse(\"March 30, 2003 02:10:00.000\");\n+        date7 = dateTimeParser.parse(\"March 30, 2003 02:40:00.000\");\n+        date8 = dateTimeParser.parse(\"October 26, 2003 05:30:45.000\");\n+        dateTimeParser.setTimeZone(defaultZone);\n+        TimeZone.setDefault(defaultZone);\n+        calAmPm1 = Calendar.getInstance();\n+        calAmPm1.setTime(dateAmPm1);\n+        calAmPm2 = Calendar.getInstance();\n+        calAmPm2.setTime(dateAmPm2);\n+        calAmPm3 = Calendar.getInstance();\n+        calAmPm3.setTime(dateAmPm3);\n+        calAmPm4 = Calendar.getInstance();\n+        calAmPm4.setTime(dateAmPm4);\n+        cal1 = Calendar.getInstance();\n+        cal1.setTime(date1);\n+        cal2 = Calendar.getInstance();\n+        cal2.setTime(date2);\n+        TimeZone.setDefault(zone);\n+        cal3 = Calendar.getInstance();\n+        cal3.setTime(date3);\n+        cal4 = Calendar.getInstance();\n+        cal4.setTime(date4);\n+        cal5 = Calendar.getInstance();\n+        cal5.setTime(date5);\n+        cal6 = Calendar.getInstance();\n+        cal6.setTime(date6);\n+        cal7 = Calendar.getInstance();\n+        cal7.setTime(date7);\n+        cal8 = Calendar.getInstance();\n+        cal8.setTime(date8);\n+        TimeZone.setDefault(defaultZone);\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new DateUtils());\n+        Constructor<?>[] cons = DateUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(DateUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(DateUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsSameDay_Date() {\n+        Date date1 = new GregorianCalendar(2004, 6, 9, 13, 45).getTime();\n+        Date date2 = new GregorianCalendar(2004, 6, 9, 13, 45).getTime();\n+        assertEquals(true, DateUtils.isSameDay(date1, date2));\n+        date2 = new GregorianCalendar(2004, 6, 10, 13, 45).getTime();\n+        assertEquals(false, DateUtils.isSameDay(date1, date2));\n+        date1 = new GregorianCalendar(2004, 6, 10, 13, 45).getTime();\n+        assertEquals(true, DateUtils.isSameDay(date1, date2));\n+        date2 = new GregorianCalendar(2005, 6, 10, 13, 45).getTime();\n+        assertEquals(false, DateUtils.isSameDay(date1, date2));\n+        try {\n+            DateUtils.isSameDay((Date) null, (Date) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsSameDay_Cal() {\n+        GregorianCalendar cal1 = new GregorianCalendar(2004, 6, 9, 13, 45);\n+        GregorianCalendar cal2 = new GregorianCalendar(2004, 6, 9, 13, 45);\n+        assertEquals(true, DateUtils.isSameDay(cal1, cal2));\n+        cal2.add(Calendar.DAY_OF_YEAR, 1);\n+        assertEquals(false, DateUtils.isSameDay(cal1, cal2));\n+        cal1.add(Calendar.DAY_OF_YEAR, 1);\n+        assertEquals(true, DateUtils.isSameDay(cal1, cal2));\n+        cal2.add(Calendar.YEAR, 1);\n+        assertEquals(false, DateUtils.isSameDay(cal1, cal2));\n+        try {\n+            DateUtils.isSameDay((Calendar) null, (Calendar) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsSameInstant_Date() {\n+        Date date1 = new GregorianCalendar(2004, 6, 9, 13, 45).getTime();\n+        Date date2 = new GregorianCalendar(2004, 6, 9, 13, 45).getTime();\n+        assertEquals(true, DateUtils.isSameInstant(date1, date2));\n+        date2 = new GregorianCalendar(2004, 6, 10, 13, 45).getTime();\n+        assertEquals(false, DateUtils.isSameInstant(date1, date2));\n+        date1 = new GregorianCalendar(2004, 6, 10, 13, 45).getTime();\n+        assertEquals(true, DateUtils.isSameInstant(date1, date2));\n+        date2 = new GregorianCalendar(2005, 6, 10, 13, 45).getTime();\n+        assertEquals(false, DateUtils.isSameInstant(date1, date2));\n+        try {\n+            DateUtils.isSameInstant((Date) null, (Date) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsSameInstant_Cal() {\n+        GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT+1\"));\n+        GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-1\"));\n+        cal1.set(2004, 6, 9, 13, 45, 0);\n+        cal1.set(Calendar.MILLISECOND, 0);\n+        cal2.set(2004, 6, 9, 13, 45, 0);\n+        cal2.set(Calendar.MILLISECOND, 0);\n+        assertEquals(false, DateUtils.isSameInstant(cal1, cal2));\n+        \n+        cal2.set(2004, 6, 9, 11, 45, 0);\n+        assertEquals(true, DateUtils.isSameInstant(cal1, cal2));\n+        try {\n+            DateUtils.isSameInstant((Calendar) null, (Calendar) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsSameLocalTime_Cal() {\n+        GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT+1\"));\n+        GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-1\"));\n+        cal1.set(2004, 6, 9, 13, 45, 0);\n+        cal1.set(Calendar.MILLISECOND, 0);\n+        cal2.set(2004, 6, 9, 13, 45, 0);\n+        cal2.set(Calendar.MILLISECOND, 0);\n+        assertEquals(true, DateUtils.isSameLocalTime(cal1, cal2));\n+        \n+        cal2.set(2004, 6, 9, 11, 45, 0);\n+        assertEquals(false, DateUtils.isSameLocalTime(cal1, cal2));\n+        try {\n+            DateUtils.isSameLocalTime((Calendar) null, (Calendar) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testParseDate() throws Exception {\n+        GregorianCalendar cal = new GregorianCalendar(1972, 11, 3);\n+        String dateStr = \"1972-12-03\";\n+        String[] parsers = new String[] {\"yyyy'-'DDD\", \"yyyy'-'MM'-'dd\", \"yyyyMMdd\"};\n+        Date date = DateUtils.parseDate(dateStr, parsers);\n+        assertEquals(cal.getTime(), date);\n+        \n+        dateStr = \"1972-338\";\n+        date = DateUtils.parseDate(dateStr, parsers);\n+        assertEquals(cal.getTime(), date);\n+        \n+        dateStr = \"19721203\";\n+        date = DateUtils.parseDate(dateStr, parsers);\n+        assertEquals(cal.getTime(), date);\n+        \n+        try {\n+            DateUtils.parseDate(\"PURPLE\", parsers);\n+            fail();\n+        } catch (ParseException ex) {}\n+        try {\n+            DateUtils.parseDate(\"197212AB\", parsers);\n+            fail();\n+        } catch (ParseException ex) {}\n+        try {\n+            DateUtils.parseDate(null, parsers);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.parseDate(dateStr, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.parseDate(dateStr, new String[0]);\n+            fail();\n+        } catch (ParseException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddYears() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.addYears(base, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addYears(base, 1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2001, 6, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addYears(base, -1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 1999, 6, 5, 4, 3, 2, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddMonths() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.addMonths(base, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addMonths(base, 1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 7, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addMonths(base, -1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 5, 5, 4, 3, 2, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddWeeks() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.addWeeks(base, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addWeeks(base, 1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 12, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addWeeks(base, -1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);      // july\n+        assertDate(result, 2000, 5, 28, 4, 3, 2, 1);   // june\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddDays() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.addDays(base, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addDays(base, 1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 6, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addDays(base, -1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 4, 4, 3, 2, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddHours() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.addHours(base, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addHours(base, 1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 5, 3, 2, 1);\n+        \n+        result = DateUtils.addHours(base, -1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 3, 3, 2, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddMinutes() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.addMinutes(base, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addMinutes(base, 1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 4, 2, 1);\n+        \n+        result = DateUtils.addMinutes(base, -1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 2, 2, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddSeconds() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.addSeconds(base, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addSeconds(base, 1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 3, 1);\n+        \n+        result = DateUtils.addSeconds(base, -1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 1, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddMilliseconds() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.addMilliseconds(base, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addMilliseconds(base, 1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 2);\n+        \n+        result = DateUtils.addMilliseconds(base, -1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 0);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testSetYears() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.setYears(base, 2000);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 1);\n+\n+        result = DateUtils.setYears(base, 2008);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2008, 6, 5, 4, 3, 2, 1);\n+\n+        result = DateUtils.setYears(base, 2005);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2005, 6, 5, 4, 3, 2, 1);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testSetMonths() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.setMonths(base, 5);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 5, 5, 4, 3, 2, 1);\n+\n+        result = DateUtils.setMonths(base, 1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 1, 5, 4, 3, 2, 1);\n+\n+        try {\n+            result = DateUtils.setMonths(base, 12);\n+            fail(\"DateUtils.setMonths did not throw an expected IllegalArguementException.\");\n+        } catch (IllegalArgumentException e) {\n+\n+        }\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testSetDays() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.setDays(base, 1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 1, 4, 3, 2, 1);\n+\n+        result = DateUtils.setDays(base, 29);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 29, 4, 3, 2, 1);\n+\n+        try {\n+            result = DateUtils.setDays(base, 32);\n+            fail(\"DateUtils.setDays did not throw an expected IllegalArguementException.\");\n+        } catch (IllegalArgumentException e) {\n+\n+        }\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testSetHours() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.setHours(base, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 0, 3, 2, 1);\n+\n+        result = DateUtils.setHours(base, 23);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 23, 3, 2, 1);\n+\n+        try {\n+            result = DateUtils.setHours(base, 24);\n+            fail(\"DateUtils.setHours did not throw an expected IllegalArguementException.\");\n+        } catch (IllegalArgumentException e) {\n+\n+        }\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testSetMinutes() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.setMinutes(base, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 0, 2, 1);\n+\n+        result = DateUtils.setMinutes(base, 59);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 59, 2, 1);\n+\n+        try {\n+            result = DateUtils.setMinutes(base, 60);\n+            fail(\"DateUtils.setMinutes did not throw an expected IllegalArguementException.\");\n+        } catch (IllegalArgumentException e) {\n+\n+        }\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testSetSeconds() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.setSeconds(base, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 0, 1);\n+\n+        result = DateUtils.setSeconds(base, 59);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 59, 1);\n+\n+        try {\n+            result = DateUtils.setSeconds(base, 60);\n+            fail(\"DateUtils.setSeconds did not throw an expected IllegalArguementException.\");\n+        } catch (IllegalArgumentException e) {\n+\n+        }\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testSetMilliseconds() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.setMilliseconds(base, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 0);\n+\n+        result = DateUtils.setMilliseconds(base, 999);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 999);\n+\n+        try {\n+            result = DateUtils.setMilliseconds(base, 1000);\n+            fail(\"DateUtils.setMilliseconds did not throw an expected IllegalArguementException.\");\n+        } catch (IllegalArgumentException e) {\n+\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void assertDate(Date date, int year, int month, int day, int hour, int min, int sec, int mil) throws Exception {\n+        GregorianCalendar cal = new GregorianCalendar();\n+        cal.setTime(date);\n+        assertEquals(year, cal.get(Calendar.YEAR));\n+        assertEquals(month, cal.get(Calendar.MONTH));\n+        assertEquals(day, cal.get(Calendar.DAY_OF_MONTH));\n+        assertEquals(hour, cal.get(Calendar.HOUR_OF_DAY));\n+        assertEquals(min, cal.get(Calendar.MINUTE));\n+        assertEquals(sec, cal.get(Calendar.SECOND));\n+        assertEquals(mil, cal.get(Calendar.MILLISECOND));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests various values with the round method\n+     */\n+    public void testRound() throws Exception {\n+        // tests for public static Date round(Date date, int field)\n+        assertEquals(\"round year-1 failed\",\n+                dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.round(date1, Calendar.YEAR));\n+        assertEquals(\"round year-2 failed\",\n+                dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.round(date2, Calendar.YEAR));\n+        assertEquals(\"round month-1 failed\",\n+                dateParser.parse(\"February 1, 2002\"),\n+                DateUtils.round(date1, Calendar.MONTH));\n+        assertEquals(\"round month-2 failed\",\n+                dateParser.parse(\"December 1, 2001\"),\n+                DateUtils.round(date2, Calendar.MONTH));\n+        assertEquals(\"round semimonth-0 failed\",\n+                dateParser.parse(\"February 1, 2002\"),\n+                DateUtils.round(date0, DateUtils.SEMI_MONTH));\n+        assertEquals(\"round semimonth-1 failed\",\n+                dateParser.parse(\"February 16, 2002\"),\n+                DateUtils.round(date1, DateUtils.SEMI_MONTH));\n+        assertEquals(\"round semimonth-2 failed\",\n+                dateParser.parse(\"November 16, 2001\"),\n+                DateUtils.round(date2, DateUtils.SEMI_MONTH));\n+        \n+        \n+        assertEquals(\"round date-1 failed\",\n+                dateParser.parse(\"February 13, 2002\"),\n+                DateUtils.round(date1, Calendar.DATE));\n+        assertEquals(\"round date-2 failed\",\n+                dateParser.parse(\"November 18, 2001\"),\n+                DateUtils.round(date2, Calendar.DATE));\n+        assertEquals(\"round hour-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 13:00:00.000\"),\n+                DateUtils.round(date1, Calendar.HOUR));\n+        assertEquals(\"round hour-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"),\n+                DateUtils.round(date2, Calendar.HOUR));\n+        assertEquals(\"round minute-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:35:00.000\"),\n+                DateUtils.round(date1, Calendar.MINUTE));\n+        assertEquals(\"round minute-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"),\n+                DateUtils.round(date2, Calendar.MINUTE));\n+        assertEquals(\"round second-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"),\n+                DateUtils.round(date1, Calendar.SECOND));\n+        assertEquals(\"round second-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"),\n+                DateUtils.round(date2, Calendar.SECOND));\n+        assertEquals(\"round ampm-1 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"),\n+                DateUtils.round(dateAmPm1, Calendar.AM_PM));\n+        assertEquals(\"round ampm-2 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.round(dateAmPm2, Calendar.AM_PM));\n+        assertEquals(\"round ampm-3 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.round(dateAmPm3, Calendar.AM_PM));\n+        assertEquals(\"round ampm-4 failed\",\n+                dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"),\n+                DateUtils.round(dateAmPm4, Calendar.AM_PM));\n+\n+        // tests for public static Date round(Object date, int field)\n+        assertEquals(\"round year-1 failed\",\n+                dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.round((Object) date1, Calendar.YEAR));\n+        assertEquals(\"round year-2 failed\",\n+                dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.round((Object) date2, Calendar.YEAR));\n+        assertEquals(\"round month-1 failed\",\n+                dateParser.parse(\"February 1, 2002\"),\n+                DateUtils.round((Object) date1, Calendar.MONTH));\n+        assertEquals(\"round month-2 failed\",\n+                dateParser.parse(\"December 1, 2001\"),\n+                DateUtils.round((Object) date2, Calendar.MONTH));\n+        assertEquals(\"round semimonth-1 failed\",\n+                dateParser.parse(\"February 16, 2002\"),\n+                DateUtils.round((Object) date1, DateUtils.SEMI_MONTH));\n+        assertEquals(\"round semimonth-2 failed\",\n+                dateParser.parse(\"November 16, 2001\"),\n+                DateUtils.round((Object) date2, DateUtils.SEMI_MONTH));\n+        assertEquals(\"round date-1 failed\",\n+                dateParser.parse(\"February 13, 2002\"),\n+                DateUtils.round((Object) date1, Calendar.DATE));\n+        assertEquals(\"round date-2 failed\",\n+                dateParser.parse(\"November 18, 2001\"),\n+                DateUtils.round((Object) date2, Calendar.DATE));\n+        assertEquals(\"round hour-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 13:00:00.000\"),\n+                DateUtils.round((Object) date1, Calendar.HOUR));\n+        assertEquals(\"round hour-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"),\n+                DateUtils.round((Object) date2, Calendar.HOUR));\n+        assertEquals(\"round minute-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:35:00.000\"),\n+                DateUtils.round((Object) date1, Calendar.MINUTE));\n+        assertEquals(\"round minute-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"),\n+                DateUtils.round((Object) date2, Calendar.MINUTE));\n+        assertEquals(\"round second-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"),\n+                DateUtils.round((Object) date1, Calendar.SECOND));\n+        assertEquals(\"round second-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"),\n+                DateUtils.round((Object) date2, Calendar.SECOND));\n+        assertEquals(\"round calendar second-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"),\n+                DateUtils.round((Object) cal1, Calendar.SECOND));\n+        assertEquals(\"round calendar second-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"),\n+                DateUtils.round((Object) cal2, Calendar.SECOND));\n+        assertEquals(\"round ampm-1 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"),\n+                DateUtils.round((Object) dateAmPm1, Calendar.AM_PM));\n+        assertEquals(\"round ampm-2 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.round((Object) dateAmPm2, Calendar.AM_PM));\n+        assertEquals(\"round ampm-3 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.round((Object) dateAmPm3, Calendar.AM_PM));\n+        assertEquals(\"round ampm-4 failed\",\n+                dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"),\n+                DateUtils.round((Object) dateAmPm4, Calendar.AM_PM));\n+\n+        try {\n+            DateUtils.round((Date) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.round((Calendar) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.round((Object) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.round(\"\", Calendar.SECOND);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        try {\n+            DateUtils.round(date1, -9999);\n+            fail();\n+        } catch(IllegalArgumentException ex) {}\n+\n+        assertEquals(\"round ampm-1 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"),\n+                DateUtils.round((Object) calAmPm1, Calendar.AM_PM));\n+        assertEquals(\"round ampm-2 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.round((Object) calAmPm2, Calendar.AM_PM));\n+        assertEquals(\"round ampm-3 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.round((Object) calAmPm3, Calendar.AM_PM));\n+        assertEquals(\"round ampm-4 failed\",\n+                dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"),\n+                DateUtils.round((Object) calAmPm4, Calendar.AM_PM));\n+        \n+        // Fix for http://issues.apache.org/bugzilla/show_bug.cgi?id=25560 / LANG-13\n+        // Test rounding across the beginning of daylight saving time\n+        TimeZone.setDefault(zone);\n+        dateTimeParser.setTimeZone(zone);\n+        assertEquals(\"round MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"),\n+                DateUtils.round(date4, Calendar.DATE));\n+        assertEquals(\"round MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"),\n+                DateUtils.round((Object) cal4, Calendar.DATE));\n+        assertEquals(\"round MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"),\n+                DateUtils.round(date5, Calendar.DATE));\n+        assertEquals(\"round MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"),\n+                DateUtils.round((Object) cal5, Calendar.DATE));\n+        assertEquals(\"round MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"),\n+                DateUtils.round(date6, Calendar.DATE));\n+        assertEquals(\"round MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"),\n+                DateUtils.round((Object) cal6, Calendar.DATE));\n+        assertEquals(\"round MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"),\n+                DateUtils.round(date7, Calendar.DATE));\n+        assertEquals(\"round MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"),\n+                DateUtils.round((Object) cal7, Calendar.DATE));\n+        \n+        assertEquals(\"round MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 01:00:00.000\"),\n+                DateUtils.round(date4, Calendar.HOUR_OF_DAY));\n+        assertEquals(\"round MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 01:00:00.000\"),\n+                DateUtils.round((Object) cal4, Calendar.HOUR_OF_DAY));\n+        if (SystemUtils.isJavaVersionAtLeast(1.4f)) {\n+            assertEquals(\"round MET date across DST change-over\",\n+                    dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"),\n+                    DateUtils.round(date5, Calendar.HOUR_OF_DAY));\n+            assertEquals(\"round MET date across DST change-over\",\n+                    dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"),\n+                    DateUtils.round((Object) cal5, Calendar.HOUR_OF_DAY));\n+            assertEquals(\"round MET date across DST change-over\",\n+                    dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"),\n+                    DateUtils.round(date6, Calendar.HOUR_OF_DAY));\n+            assertEquals(\"round MET date across DST change-over\",\n+                    dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"),\n+                    DateUtils.round((Object) cal6, Calendar.HOUR_OF_DAY));\n+            assertEquals(\"round MET date across DST change-over\",\n+                    dateTimeParser.parse(\"March 30, 2003 04:00:00.000\"),\n+                    DateUtils.round(date7, Calendar.HOUR_OF_DAY));\n+            assertEquals(\"round MET date across DST change-over\",\n+                    dateTimeParser.parse(\"March 30, 2003 04:00:00.000\"),\n+                    DateUtils.round((Object) cal7, Calendar.HOUR_OF_DAY));\n+        } else {\n+            this.warn(\"WARNING: Some date rounding tests not run since the current version is \" + SystemUtils.JAVA_VERSION);\n+        }\n+        TimeZone.setDefault(defaultZone);\n+        dateTimeParser.setTimeZone(defaultZone);\n+    }\n+\n+    /**\n+     * Tests the Changes Made by LANG-346 to the DateUtils.modify() private method invoked\n+     * by DateUtils.round().\n+     */\n+    public void testRoundLang346() throws Exception\n+    {\n+        TimeZone.setDefault(defaultZone);\n+        dateTimeParser.setTimeZone(defaultZone);\n+        Calendar testCalendar = Calendar.getInstance();\n+        testCalendar.set(2007, 6, 2, 8, 8, 50);\n+        Date date = testCalendar.getTime();\n+        assertEquals(\"Minute Round Up Failed\",\n+                     dateTimeParser.parse(\"July 2, 2007 08:09:00.000\"),\n+                     DateUtils.round(date, Calendar.MINUTE));\n+\n+        testCalendar.set(2007, 6, 2, 8, 8, 20);\n+        date = testCalendar.getTime();\n+        assertEquals(\"Minute No Round Failed\",\n+                     dateTimeParser.parse(\"July 2, 2007 08:08:00.000\"),\n+                     DateUtils.round(date, Calendar.MINUTE));\n+\n+        testCalendar.set(2007, 6, 2, 8, 8, 50);\n+        testCalendar.set(Calendar.MILLISECOND, 600);\n+        date = testCalendar.getTime();\n+\n+        assertEquals(\"Second Round Up with 600 Milli Seconds Failed\",\n+                     dateTimeParser.parse(\"July 2, 2007 08:08:51.000\"),\n+                     DateUtils.round(date, Calendar.SECOND));\n+\n+        testCalendar.set(2007, 6, 2, 8, 8, 50);\n+        testCalendar.set(Calendar.MILLISECOND, 200);\n+        date = testCalendar.getTime();\n+        assertEquals(\"Second Round Down with 200 Milli Seconds Failed\",\n+                     dateTimeParser.parse(\"July 2, 2007 08:08:50.000\"),\n+                     DateUtils.round(date, Calendar.SECOND));\n+\n+        testCalendar.set(2007, 6, 2, 8, 8, 20);\n+        testCalendar.set(Calendar.MILLISECOND, 600);\n+        date = testCalendar.getTime();\n+        assertEquals(\"Second Round Up with 200 Milli Seconds Failed\",\n+                     dateTimeParser.parse(\"July 2, 2007 08:08:21.000\"),\n+                     DateUtils.round(date, Calendar.SECOND));\n+\n+        testCalendar.set(2007, 6, 2, 8, 8, 20);\n+        testCalendar.set(Calendar.MILLISECOND, 200);\n+        date = testCalendar.getTime();\n+        assertEquals(\"Second Round Down with 200 Milli Seconds Failed\",\n+                     dateTimeParser.parse(\"July 2, 2007 08:08:20.000\"),\n+                     DateUtils.round(date, Calendar.SECOND));\n+\n+        testCalendar.set(2007, 6, 2, 8, 8, 50);\n+        date = testCalendar.getTime();\n+        assertEquals(\"Hour Round Down Failed\",\n+                     dateTimeParser.parse(\"July 2, 2007 08:00:00.000\"),\n+                     DateUtils.round(date, Calendar.HOUR));\n+\n+        testCalendar.set(2007, 6, 2, 8, 31, 50);\n+        date = testCalendar.getTime();\n+        assertEquals(\"Hour Round Up Failed\",\n+                     dateTimeParser.parse(\"July 2, 2007 09:00:00.000\"),\n+                     DateUtils.round(date, Calendar.HOUR));\n+    }\n+\n+    /**\n+     * Tests various values with the trunc method\n+     */\n+    public void testTruncate() throws Exception {\n+        // tests public static Date truncate(Date date, int field)\n+        assertEquals(\"truncate year-1 failed\",\n+                dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.truncate(date1, Calendar.YEAR));\n+        assertEquals(\"truncate year-2 failed\",\n+                dateParser.parse(\"January 1, 2001\"),\n+                DateUtils.truncate(date2, Calendar.YEAR));\n+        assertEquals(\"truncate month-1 failed\",\n+                dateParser.parse(\"February 1, 2002\"),\n+                DateUtils.truncate(date1, Calendar.MONTH));\n+        assertEquals(\"truncate month-2 failed\",\n+                dateParser.parse(\"November 1, 2001\"),\n+                DateUtils.truncate(date2, Calendar.MONTH));\n+        assertEquals(\"truncate semimonth-1 failed\",\n+                dateParser.parse(\"February 1, 2002\"),\n+                DateUtils.truncate(date1, DateUtils.SEMI_MONTH));\n+        assertEquals(\"truncate semimonth-2 failed\",\n+                dateParser.parse(\"November 16, 2001\"),\n+                DateUtils.truncate(date2, DateUtils.SEMI_MONTH));\n+        assertEquals(\"truncate date-1 failed\",\n+                dateParser.parse(\"February 12, 2002\"),\n+                DateUtils.truncate(date1, Calendar.DATE));\n+        assertEquals(\"truncate date-2 failed\",\n+                dateParser.parse(\"November 18, 2001\"),\n+                DateUtils.truncate(date2, Calendar.DATE));\n+        assertEquals(\"truncate hour-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:00:00.000\"),\n+                DateUtils.truncate(date1, Calendar.HOUR));\n+        assertEquals(\"truncate hour-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"),\n+                DateUtils.truncate(date2, Calendar.HOUR));\n+        assertEquals(\"truncate minute-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:00.000\"),\n+                DateUtils.truncate(date1, Calendar.MINUTE));\n+        assertEquals(\"truncate minute-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"),\n+                DateUtils.truncate(date2, Calendar.MINUTE));\n+        assertEquals(\"truncate second-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:56.000\"),\n+                DateUtils.truncate(date1, Calendar.SECOND));\n+        assertEquals(\"truncate second-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"),\n+                DateUtils.truncate(date2, Calendar.SECOND));\n+        assertEquals(\"truncate ampm-1 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"),\n+                DateUtils.truncate(dateAmPm1, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-2 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"),\n+                DateUtils.truncate(dateAmPm2, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-3 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.truncate(dateAmPm3, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-4 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.truncate(dateAmPm4, Calendar.AM_PM));\n+\n+        // tests public static Date truncate(Object date, int field)\n+        assertEquals(\"truncate year-1 failed\",\n+                dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.truncate((Object) date1, Calendar.YEAR));\n+        assertEquals(\"truncate year-2 failed\",\n+                dateParser.parse(\"January 1, 2001\"),\n+                DateUtils.truncate((Object) date2, Calendar.YEAR));\n+        assertEquals(\"truncate month-1 failed\",\n+                dateParser.parse(\"February 1, 2002\"),\n+                DateUtils.truncate((Object) date1, Calendar.MONTH));\n+        assertEquals(\"truncate month-2 failed\",\n+                dateParser.parse(\"November 1, 2001\"),\n+                DateUtils.truncate((Object) date2, Calendar.MONTH));\n+        assertEquals(\"truncate semimonth-1 failed\",\n+                dateParser.parse(\"February 1, 2002\"),\n+                DateUtils.truncate((Object) date1, DateUtils.SEMI_MONTH));\n+        assertEquals(\"truncate semimonth-2 failed\",\n+                dateParser.parse(\"November 16, 2001\"),\n+                DateUtils.truncate((Object) date2, DateUtils.SEMI_MONTH));\n+        assertEquals(\"truncate date-1 failed\",\n+                dateParser.parse(\"February 12, 2002\"),\n+                DateUtils.truncate((Object) date1, Calendar.DATE));\n+        assertEquals(\"truncate date-2 failed\",\n+                dateParser.parse(\"November 18, 2001\"),\n+                DateUtils.truncate((Object) date2, Calendar.DATE));\n+        assertEquals(\"truncate hour-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:00:00.000\"),\n+                DateUtils.truncate((Object) date1, Calendar.HOUR));\n+        assertEquals(\"truncate hour-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"),\n+                DateUtils.truncate((Object) date2, Calendar.HOUR));\n+        assertEquals(\"truncate minute-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:00.000\"),\n+                DateUtils.truncate((Object) date1, Calendar.MINUTE));\n+        assertEquals(\"truncate minute-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"),\n+                DateUtils.truncate((Object) date2, Calendar.MINUTE));\n+        assertEquals(\"truncate second-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:56.000\"),\n+                DateUtils.truncate((Object) date1, Calendar.SECOND));\n+        assertEquals(\"truncate second-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"),\n+                DateUtils.truncate((Object) date2, Calendar.SECOND));\n+        assertEquals(\"truncate ampm-1 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"),\n+                DateUtils.truncate((Object) dateAmPm1, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-2 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"),\n+                DateUtils.truncate((Object) dateAmPm2, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-3 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.truncate((Object) dateAmPm3, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-4 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.truncate((Object) dateAmPm4, Calendar.AM_PM));\n+        \n+        assertEquals(\"truncate calendar second-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:56.000\"),\n+                DateUtils.truncate((Object) cal1, Calendar.SECOND));\n+        assertEquals(\"truncate calendar second-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"),\n+                DateUtils.truncate((Object) cal2, Calendar.SECOND));\n+        \n+        assertEquals(\"truncate ampm-1 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"),\n+                DateUtils.truncate((Object) calAmPm1, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-2 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"),\n+                DateUtils.truncate((Object) calAmPm2, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-3 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.truncate((Object) calAmPm3, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-4 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.truncate((Object) calAmPm4, Calendar.AM_PM));\n+        \n+        try {\n+            DateUtils.truncate((Date) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.truncate((Calendar) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.truncate((Object) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.truncate(\"\", Calendar.SECOND);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+\n+        // Fix for http://issues.apache.org/bugzilla/show_bug.cgi?id=25560\n+        // Test truncate across beginning of daylight saving time\n+        TimeZone.setDefault(zone);\n+        dateTimeParser.setTimeZone(zone);\n+        assertEquals(\"truncate MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"),\n+                DateUtils.truncate(date3, Calendar.DATE));\n+        assertEquals(\"truncate MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"),\n+                DateUtils.truncate((Object) cal3, Calendar.DATE));\n+        // Test truncate across end of daylight saving time\n+        assertEquals(\"truncate MET date across DST change-over\",\n+                dateTimeParser.parse(\"October 26, 2003 00:00:00.000\"),\n+                DateUtils.truncate(date8, Calendar.DATE));\n+        assertEquals(\"truncate MET date across DST change-over\",\n+                dateTimeParser.parse(\"October 26, 2003 00:00:00.000\"),\n+                DateUtils.truncate((Object) cal8, Calendar.DATE));\n+        TimeZone.setDefault(defaultZone);\n+        dateTimeParser.setTimeZone(defaultZone);\n+        \n+        // Bug 31395, large dates\n+        Date endOfTime = new Date(Long.MAX_VALUE); // fyi: Sun Aug 17 07:12:55 CET 292278994 -- 807 millis\n+        GregorianCalendar endCal = new GregorianCalendar();\n+        endCal.setTime(endOfTime);\n+        try {\n+            DateUtils.truncate(endCal, Calendar.DATE);\n+            fail();\n+        } catch (ArithmeticException ex) {}\n+        endCal.set(Calendar.YEAR, 280000001);\n+        try {\n+            DateUtils.truncate(endCal, Calendar.DATE);\n+            fail();\n+        } catch (ArithmeticException ex) {}\n+        endCal.set(Calendar.YEAR, 280000000);\n+        Calendar cal = DateUtils.truncate(endCal, Calendar.DATE);\n+        assertEquals(0, cal.get(Calendar.HOUR));\n+    }\n+\n+    /**\n+     * Tests for LANG-59\n+     *\n+     * see http://issues.apache.org/jira/browse/LANG-59\n+     */\n+    public void testTruncateLang59() throws Exception {\n+        if (!SystemUtils.isJavaVersionAtLeast(1.4f)) {\n+            this.warn(\"WARNING: Test for LANG-59 not run since the current version is \" + SystemUtils.JAVA_VERSION);\n+            return;\n+        }\n+\n+        // Set TimeZone to Mountain Time\n+        TimeZone MST_MDT = TimeZone.getTimeZone(\"MST7MDT\");\n+        TimeZone.setDefault(MST_MDT);\n+        DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS z\");\n+        format.setTimeZone(MST_MDT);\n+\n+        Date oct31_01MDT = new Date(1099206000000L); \n+\n+        Date oct31MDT             = new Date(oct31_01MDT.getTime()       - 3600000L); // - 1 hour\n+        Date oct31_01_02MDT       = new Date(oct31_01MDT.getTime()       + 120000L);  // + 2 minutes\n+        Date oct31_01_02_03MDT    = new Date(oct31_01_02MDT.getTime()    + 3000L);    // + 3 seconds\n+        Date oct31_01_02_03_04MDT = new Date(oct31_01_02_03MDT.getTime() + 4L);       // + 4 milliseconds\n+\n+        assertEquals(\"Check 00:00:00.000\", \"2004-10-31 00:00:00.000 MDT\", format.format(oct31MDT));\n+        assertEquals(\"Check 01:00:00.000\", \"2004-10-31 01:00:00.000 MDT\", format.format(oct31_01MDT));\n+        assertEquals(\"Check 01:02:00.000\", \"2004-10-31 01:02:00.000 MDT\", format.format(oct31_01_02MDT));\n+        assertEquals(\"Check 01:02:03.000\", \"2004-10-31 01:02:03.000 MDT\", format.format(oct31_01_02_03MDT));\n+        assertEquals(\"Check 01:02:03.004\", \"2004-10-31 01:02:03.004 MDT\", format.format(oct31_01_02_03_04MDT));\n+\n+        // ------- Demonstrate Problem -------\n+        Calendar gval = Calendar.getInstance();\n+        gval.setTime(new Date(oct31_01MDT.getTime()));\n+        gval.set(Calendar.MINUTE, gval.get(Calendar.MINUTE)); // set minutes to the same value\n+        assertEquals(\"Demonstrate Problem\", gval.getTime().getTime(), oct31_01MDT.getTime() + 3600000L);\n+\n+        // ---------- Test Truncate ----------\n+        assertEquals(\"Truncate Calendar.MILLISECOND\",\n+                oct31_01_02_03_04MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MILLISECOND));\n+\n+        assertEquals(\"Truncate Calendar.SECOND\",\n+                   oct31_01_02_03MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.SECOND));\n+\n+        assertEquals(\"Truncate Calendar.MINUTE\",\n+                      oct31_01_02MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MINUTE));\n+\n+        assertEquals(\"Truncate Calendar.HOUR_OF_DAY\",\n+                         oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY));\n+\n+        assertEquals(\"Truncate Calendar.HOUR\",\n+                         oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR));\n+\n+        assertEquals(\"Truncate Calendar.DATE\",\n+                            oct31MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.DATE));\n+\n+\n+        // ---------- Test Round (down) ----------\n+        assertEquals(\"Round Calendar.MILLISECOND\",\n+                oct31_01_02_03_04MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MILLISECOND));\n+\n+        assertEquals(\"Round Calendar.SECOND\",\n+                   oct31_01_02_03MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.SECOND));\n+\n+        assertEquals(\"Round Calendar.MINUTE\",\n+                      oct31_01_02MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MINUTE));\n+\n+        assertEquals(\"Round Calendar.HOUR_OF_DAY\",\n+                         oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY));\n+\n+        assertEquals(\"Round Calendar.HOUR\",\n+                         oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR));\n+\n+        assertEquals(\"Round Calendar.DATE\",\n+                            oct31MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.DATE));\n+\n+        // restore default time zone\n+        TimeZone.setDefault(defaultZone);\n+    }\n+    \n+    /**\n+     * Tests various values with the ceiling method\n+     */\n+    public void testCeil() throws Exception {\n+        // tests public static Date ceiling(Date date, int field)\n+        assertEquals(\"ceiling year-1 failed\",\n+                dateParser.parse(\"January 1, 2003\"),\n+                DateUtils.ceiling(date1, Calendar.YEAR));\n+        assertEquals(\"ceiling year-2 failed\",\n+                dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.ceiling(date2, Calendar.YEAR));\n+        assertEquals(\"ceiling month-1 failed\",\n+                dateParser.parse(\"March 1, 2002\"),\n+                DateUtils.ceiling(date1, Calendar.MONTH));\n+        assertEquals(\"ceiling month-2 failed\",\n+                dateParser.parse(\"December 1, 2001\"),\n+                DateUtils.ceiling(date2, Calendar.MONTH));\n+        assertEquals(\"ceiling semimonth-1 failed\",\n+                dateParser.parse(\"February 16, 2002\"),\n+                DateUtils.ceiling(date1, DateUtils.SEMI_MONTH));\n+        assertEquals(\"ceiling semimonth-2 failed\",\n+                dateParser.parse(\"December 1, 2001\"),\n+                DateUtils.ceiling(date2, DateUtils.SEMI_MONTH));\n+        assertEquals(\"ceiling date-1 failed\",\n+                dateParser.parse(\"February 13, 2002\"),\n+                DateUtils.ceiling(date1, Calendar.DATE));\n+        assertEquals(\"ceiling date-2 failed\",\n+                dateParser.parse(\"November 19, 2001\"),\n+                DateUtils.ceiling(date2, Calendar.DATE));\n+        assertEquals(\"ceiling hour-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 13:00:00.000\"),\n+                DateUtils.ceiling(date1, Calendar.HOUR));\n+        assertEquals(\"ceiling hour-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 2:00:00.000\"),\n+                DateUtils.ceiling(date2, Calendar.HOUR));\n+        assertEquals(\"ceiling minute-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:35:00.000\"),\n+                DateUtils.ceiling(date1, Calendar.MINUTE));\n+        assertEquals(\"ceiling minute-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:24:00.000\"),\n+                DateUtils.ceiling(date2, Calendar.MINUTE));\n+        assertEquals(\"ceiling second-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"),\n+                DateUtils.ceiling(date1, Calendar.SECOND));\n+        assertEquals(\"ceiling second-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:12.000\"),\n+                DateUtils.ceiling(date2, Calendar.SECOND));\n+        assertEquals(\"ceiling ampm-1 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.ceiling(dateAmPm1, Calendar.AM_PM));\n+        assertEquals(\"ceiling ampm-2 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.ceiling(dateAmPm2, Calendar.AM_PM));\n+        assertEquals(\"ceiling ampm-3 failed\",\n+                dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"),\n+                DateUtils.ceiling(dateAmPm3, Calendar.AM_PM));\n+        assertEquals(\"ceiling ampm-4 failed\",\n+                dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"),\n+                DateUtils.ceiling(dateAmPm4, Calendar.AM_PM));\n+        \n+     // tests public static Date ceiling(Object date, int field)\n+        assertEquals(\"ceiling year-1 failed\",\n+                dateParser.parse(\"January 1, 2003\"),\n+                DateUtils.ceiling((Object) date1, Calendar.YEAR));\n+        assertEquals(\"ceiling year-2 failed\",\n+                dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.ceiling((Object) date2, Calendar.YEAR));\n+        assertEquals(\"ceiling month-1 failed\",\n+                dateParser.parse(\"March 1, 2002\"),\n+                DateUtils.ceiling((Object) date1, Calendar.MONTH));\n+        assertEquals(\"ceiling month-2 failed\",\n+                dateParser.parse(\"December 1, 2001\"),\n+                DateUtils.ceiling((Object) date2, Calendar.MONTH));\n+        assertEquals(\"ceiling semimonth-1 failed\",\n+                dateParser.parse(\"February 16, 2002\"),\n+                DateUtils.ceiling((Object) date1, DateUtils.SEMI_MONTH));\n+        assertEquals(\"ceiling semimonth-2 failed\",\n+                dateParser.parse(\"December 1, 2001\"),\n+                DateUtils.ceiling((Object) date2, DateUtils.SEMI_MONTH));\n+        assertEquals(\"ceiling date-1 failed\",\n+                dateParser.parse(\"February 13, 2002\"),\n+                DateUtils.ceiling((Object) date1, Calendar.DATE));\n+        assertEquals(\"ceiling date-2 failed\",\n+                dateParser.parse(\"November 19, 2001\"),\n+                DateUtils.ceiling((Object) date2, Calendar.DATE));\n+        assertEquals(\"ceiling hour-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 13:00:00.000\"),\n+                DateUtils.ceiling((Object) date1, Calendar.HOUR));\n+        assertEquals(\"ceiling hour-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 2:00:00.000\"),\n+                DateUtils.ceiling((Object) date2, Calendar.HOUR));\n+        assertEquals(\"ceiling minute-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:35:00.000\"),\n+                DateUtils.ceiling((Object) date1, Calendar.MINUTE));\n+        assertEquals(\"ceiling minute-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:24:00.000\"),\n+                DateUtils.ceiling((Object) date2, Calendar.MINUTE));\n+        assertEquals(\"ceiling second-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"),\n+                DateUtils.ceiling((Object) date1, Calendar.SECOND));\n+        assertEquals(\"ceiling second-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:12.000\"),\n+                DateUtils.ceiling((Object) date2, Calendar.SECOND));\n+        assertEquals(\"ceiling ampm-1 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.ceiling((Object) dateAmPm1, Calendar.AM_PM));\n+        assertEquals(\"ceiling ampm-2 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.ceiling((Object) dateAmPm2, Calendar.AM_PM));\n+        assertEquals(\"ceiling ampm-3 failed\",\n+                dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"),\n+                DateUtils.ceiling((Object) dateAmPm3, Calendar.AM_PM));\n+        assertEquals(\"ceiling ampm-4 failed\",\n+                dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"),\n+                DateUtils.ceiling((Object) dateAmPm4, Calendar.AM_PM));\n+        \n+        assertEquals(\"ceiling calendar second-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"),\n+                DateUtils.ceiling((Object) cal1, Calendar.SECOND));\n+        assertEquals(\"ceiling calendar second-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:12.000\"),\n+                DateUtils.ceiling((Object) cal2, Calendar.SECOND));\n+        \n+        assertEquals(\"ceiling ampm-1 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.ceiling((Object) calAmPm1, Calendar.AM_PM));\n+        assertEquals(\"ceiling ampm-2 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.ceiling((Object) calAmPm2, Calendar.AM_PM));\n+        assertEquals(\"ceiling ampm-3 failed\",\n+                dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"),\n+                DateUtils.ceiling((Object) calAmPm3, Calendar.AM_PM));\n+        assertEquals(\"ceiling ampm-4 failed\",\n+                dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"),\n+                DateUtils.ceiling((Object) calAmPm4, Calendar.AM_PM));\n+\n+        try {\n+            DateUtils.ceiling((Date) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.ceiling((Calendar) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.ceiling((Object) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.ceiling(\"\", Calendar.SECOND);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        try {\n+            DateUtils.ceiling(date1, -9999);\n+            fail();\n+        } catch(IllegalArgumentException ex) {}\n+\n+        \n+        // Fix for http://issues.apache.org/bugzilla/show_bug.cgi?id=25560\n+        // Test ceiling across the beginning of daylight saving time\n+        TimeZone.setDefault(zone);\n+        dateTimeParser.setTimeZone(zone);\n+\n+        assertEquals(\"ceiling MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 31, 2003 00:00:00.000\"),\n+                DateUtils.ceiling(date4, Calendar.DATE));\n+        assertEquals(\"ceiling MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 31, 2003 00:00:00.000\"),\n+                DateUtils.ceiling((Object) cal4, Calendar.DATE));\n+        assertEquals(\"ceiling MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 31, 2003 00:00:00.000\"),\n+                DateUtils.ceiling(date5, Calendar.DATE));\n+        assertEquals(\"ceiling MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 31, 2003 00:00:00.000\"),\n+                DateUtils.ceiling((Object) cal5, Calendar.DATE));\n+        assertEquals(\"ceiling MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 31, 2003 00:00:00.000\"),\n+                DateUtils.ceiling(date6, Calendar.DATE));\n+        assertEquals(\"ceiling MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 31, 2003 00:00:00.000\"),\n+                DateUtils.ceiling((Object) cal6, Calendar.DATE));\n+        assertEquals(\"ceiling MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 31, 2003 00:00:00.000\"),\n+                DateUtils.ceiling(date7, Calendar.DATE));\n+        assertEquals(\"ceiling MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 31, 2003 00:00:00.000\"),\n+                DateUtils.ceiling((Object) cal7, Calendar.DATE));\n+        \n+        assertEquals(\"ceiling MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"),\n+                DateUtils.ceiling(date4, Calendar.HOUR_OF_DAY));\n+        assertEquals(\"ceiling MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"),\n+                DateUtils.ceiling((Object) cal4, Calendar.HOUR_OF_DAY));\n+        if (SystemUtils.isJavaVersionAtLeast(1.4f)) {\n+            assertEquals(\"ceiling MET date across DST change-over\",\n+                    dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"),\n+                    DateUtils.ceiling(date5, Calendar.HOUR_OF_DAY));\n+            assertEquals(\"ceiling MET date across DST change-over\",\n+                    dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"),\n+                    DateUtils.ceiling((Object) cal5, Calendar.HOUR_OF_DAY));\n+            assertEquals(\"ceiling MET date across DST change-over\",\n+                    dateTimeParser.parse(\"March 30, 2003 04:00:00.000\"),\n+                    DateUtils.ceiling(date6, Calendar.HOUR_OF_DAY));\n+            assertEquals(\"ceiling MET date across DST change-over\",\n+                    dateTimeParser.parse(\"March 30, 2003 04:00:00.000\"),\n+                    DateUtils.ceiling((Object) cal6, Calendar.HOUR_OF_DAY));\n+            assertEquals(\"ceiling MET date across DST change-over\",\n+                    dateTimeParser.parse(\"March 30, 2003 04:00:00.000\"),\n+                    DateUtils.ceiling(date7, Calendar.HOUR_OF_DAY));\n+            assertEquals(\"ceiling MET date across DST change-over\",\n+                    dateTimeParser.parse(\"March 30, 2003 04:00:00.000\"),\n+                    DateUtils.ceiling((Object) cal7, Calendar.HOUR_OF_DAY));\n+        } else {\n+            this.warn(\"WARNING: Some date ceiling tests not run since the current version is \" + SystemUtils.JAVA_VERSION);\n+        }\n+        TimeZone.setDefault(defaultZone);\n+        dateTimeParser.setTimeZone(defaultZone);\n+        \n+     // Bug 31395, large dates\n+        Date endOfTime = new Date(Long.MAX_VALUE); // fyi: Sun Aug 17 07:12:55 CET 292278994 -- 807 millis\n+        GregorianCalendar endCal = new GregorianCalendar();\n+        endCal.setTime(endOfTime);\n+        try {\n+            DateUtils.ceiling(endCal, Calendar.DATE);\n+            fail();\n+        } catch (ArithmeticException ex) {}\n+        endCal.set(Calendar.YEAR, 280000001);\n+        try {\n+            DateUtils.ceiling(endCal, Calendar.DATE);\n+            fail();\n+        } catch (ArithmeticException ex) {}\n+        endCal.set(Calendar.YEAR, 280000000);\n+        Calendar cal = DateUtils.ceiling(endCal, Calendar.DATE);\n+        assertEquals(0, cal.get(Calendar.HOUR));\n+    }\n+\n+    /**\n+     * Tests the iterator exceptions\n+     */\n+    public void testIteratorEx() throws Exception {\n+        try {\n+            DateUtils.iterator(Calendar.getInstance(), -9999);\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.iterator((Date) null, DateUtils.RANGE_WEEK_CENTER);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.iterator((Calendar) null, DateUtils.RANGE_WEEK_CENTER);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.iterator((Object) null, DateUtils.RANGE_WEEK_CENTER);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.iterator(\"\", DateUtils.RANGE_WEEK_CENTER);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    /**\n+     * Tests the calendar iterator for week ranges\n+     */\n+    public void testWeekIterator() throws Exception {\n+        Calendar now = Calendar.getInstance();\n+        for (int i = 0; i< 7; i++) {\n+            Calendar today = DateUtils.truncate(now, Calendar.DATE);\n+            Calendar sunday = DateUtils.truncate(now, Calendar.DATE);\n+            sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK));\n+            Calendar monday = DateUtils.truncate(now, Calendar.DATE);\n+            if (monday.get(Calendar.DAY_OF_WEEK) == 1) {\n+                //This is sunday... roll back 6 days\n+                monday.add(Calendar.DATE, -6);\n+            } else {\n+                monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK));\n+            }\n+            Calendar centered = DateUtils.truncate(now, Calendar.DATE);\n+            centered.add(Calendar.DATE, -3);\n+            \n+            Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY);\n+            assertWeekIterator(it, sunday);\n+            it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY);\n+            assertWeekIterator(it, monday);\n+            it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE);\n+            assertWeekIterator(it, today);\n+            it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER);\n+            assertWeekIterator(it, centered);\n+            \n+            it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER);\n+            assertWeekIterator(it, centered);\n+            it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER);\n+            assertWeekIterator(it, centered);\n+            try {\n+                it.next();\n+                fail();\n+            } catch (NoSuchElementException ex) {}\n+            it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER);\n+            it.next();\n+            try {\n+                it.remove();\n+            } catch( UnsupportedOperationException ex) {}\n+            \n+            now.add(Calendar.DATE,1);\n+        }\n+    }\n+            \n+    /**\n+     * Tests the calendar iterator for month-based ranges\n+     */\n+    public void testMonthIterator() throws Exception {\n+        Iterator<?> it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_SUNDAY);\n+        assertWeekIterator(it,\n+                dateParser.parse(\"January 27, 2002\"),\n+                dateParser.parse(\"March 2, 2002\"));\n+\n+        it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_MONDAY);\n+        assertWeekIterator(it,\n+                dateParser.parse(\"January 28, 2002\"),\n+                dateParser.parse(\"March 3, 2002\"));\n+\n+        it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_SUNDAY);\n+        assertWeekIterator(it,\n+                dateParser.parse(\"October 28, 2001\"),\n+                dateParser.parse(\"December 1, 2001\"));\n+\n+        it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_MONDAY);\n+        assertWeekIterator(it,\n+                dateParser.parse(\"October 29, 2001\"),\n+                dateParser.parse(\"December 2, 2001\"));\n+    }\n+\n+    /**\n+     * This checks that this is a 7 element iterator of Calendar objects\n+     * that are dates (no time), and exactly 1 day spaced after each other.\n+     */\n+    private static void assertWeekIterator(Iterator<?> it, Calendar start) {\n+        Calendar end = (Calendar) start.clone();\n+        end.add(Calendar.DATE, 6);\n+\n+        assertWeekIterator(it, start, end);\n+    }\n+\n+    /**\n+     * Convenience method for when working with Date objects\n+     */\n+    private static void assertWeekIterator(Iterator<?> it, Date start, Date end) {\n+        Calendar calStart = Calendar.getInstance();\n+        calStart.setTime(start);\n+        Calendar calEnd = Calendar.getInstance();\n+        calEnd.setTime(end);\n+\n+        assertWeekIterator(it, calStart, calEnd);\n+    }\n+\n+    /**\n+     * This checks that this is a 7 divisble iterator of Calendar objects\n+     * that are dates (no time), and exactly 1 day spaced after each other\n+     * (in addition to the proper start and stop dates)\n+     */\n+    private static void assertWeekIterator(Iterator<?> it, Calendar start, Calendar end) {\n+        Calendar cal = (Calendar) it.next();\n+        assertEquals(\"\", start, cal, 0);\n+        Calendar last = null;\n+        int count = 1;\n+        while (it.hasNext()) {\n+            //Check this is just a date (no time component)\n+            assertEquals(\"\", cal, DateUtils.truncate(cal, Calendar.DATE), 0);\n+\n+            last = cal;\n+            cal = (Calendar) it.next();\n+            count++;\n+\n+            //Check that this is one day more than the last date\n+            last.add(Calendar.DATE, 1);\n+            assertEquals(\"\", last, cal, 0);\n+        }\n+        if (count % 7 != 0) {\n+            throw new AssertionFailedError(\"There were \" + count + \" days in this iterator\");\n+        }\n+        assertEquals(\"\", end, cal, 0);\n+    }\n+\n+    /**\n+     * Used to check that Calendar objects are close enough\n+     * delta is in milliseconds\n+     */\n+    private static void assertEquals(String message, Calendar cal1, Calendar cal2, long delta) {\n+        if (Math.abs(cal1.getTime().getTime() - cal2.getTime().getTime()) > delta) {\n+            throw new AssertionFailedError(\n+                    message + \" expected \" + cal1.getTime() + \" but got \" + cal2.getTime());\n+        }\n+    }\n+\n+    void warn(String msg) {\n+        System.err.println(msg);\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/time/DurationFormatUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.time;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.Calendar;\n+import java.util.TimeZone;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * TestCase for DurationFormatUtils.\n+ * \n+ * @author Apache Software Foundation\n+ * @author Apache Ant - DateUtilsTest\n+ * @author <a href=\"mailto:sbailliez@apache.org\">Stephane Bailliez</a>\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ */\n+public class DurationFormatUtilsTest extends TestCase {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(DurationFormatUtilsTest.class);\n+        suite.setName(\"DurationFormatUtils Tests\");\n+        return suite;\n+    }\n+\n+    public DurationFormatUtilsTest(String s) {\n+        super(s);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new DurationFormatUtils());\n+        Constructor<?>[] cons = DurationFormatUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(DurationFormatUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(DurationFormatUtils.class.getModifiers()));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testFormatDurationWords() {\n+        String text = null;\n+\n+        text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false);\n+        assertEquals(\"50 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false);\n+        assertEquals(\"1 minute 5 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false);\n+        assertEquals(\"2 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false);\n+        assertEquals(\"2 minutes 1 second\", text);\n+        text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false);\n+        assertEquals(\"1 hour 12 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false);\n+        assertEquals(\"1 day 0 hours 0 minutes 0 seconds\", text);\n+\n+        text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true);\n+        assertEquals(\"50 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true);\n+        assertEquals(\"1 minute 5 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true);\n+        assertEquals(\"2 minutes\", text);\n+        text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true);\n+        assertEquals(\"2 minutes 1 second\", text);\n+        text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true);\n+        assertEquals(\"1 hour 12 minutes\", text);\n+        text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true);\n+        assertEquals(\"1 day\", text);\n+\n+        text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true);\n+        assertEquals(\"0 days 0 hours 0 minutes 50 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(65 * 1000, false, true);\n+        assertEquals(\"0 days 0 hours 1 minute 5 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(120 * 1000, false, true);\n+        assertEquals(\"0 days 0 hours 2 minutes\", text);\n+        text = DurationFormatUtils.formatDurationWords(121 * 1000, false, true);\n+        assertEquals(\"0 days 0 hours 2 minutes 1 second\", text);\n+        text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, true);\n+        assertEquals(\"0 days 1 hour 12 minutes\", text);\n+        text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, false, true);\n+        assertEquals(\"1 day\", text);\n+\n+        text = DurationFormatUtils.formatDurationWords(50 * 1000, false, false);\n+        assertEquals(\"0 days 0 hours 0 minutes 50 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(65 * 1000, false, false);\n+        assertEquals(\"0 days 0 hours 1 minute 5 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(120 * 1000, false, false);\n+        assertEquals(\"0 days 0 hours 2 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(121 * 1000, false, false);\n+        assertEquals(\"0 days 0 hours 2 minutes 1 second\", text);\n+        text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, false);\n+        assertEquals(\"0 days 1 hour 12 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false);\n+        assertEquals(\"1 day 1 hour 12 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(2 * 24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false);\n+        assertEquals(\"2 days 1 hour 12 minutes 0 seconds\", text);\n+        for (int i = 2; i < 31; i++) {\n+            text = DurationFormatUtils.formatDurationWords(i * 24 * 60 * 60 * 1000L, false, false);\n+            // assertEquals(i + \" days 0 hours 0 minutes 0 seconds\", text);\n+            //            \n+            // junit.framework.ComparisonFailure: expected:<25 days 0 hours 0 minutes 0...> but was:<-24 days -17 hours\n+            // -2 minutes -47...>\n+            // at junit.framework.Assert.assertEquals(Assert.java:81)\n+            // at junit.framework.Assert.assertEquals(Assert.java:87)\n+            // at\n+            // org.apache.commons.lang.time.DurationFormatUtilsTest.testFormatDurationWords(DurationFormatUtilsTest.java:124)\n+            // at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n+            // at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n+            // at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n+            // at java.lang.reflect.Method.invoke(Method.java:324)\n+            // at junit.framework.TestCase.runTest(TestCase.java:154)\n+            // at junit.framework.TestCase.runBare(TestCase.java:127)\n+            // at junit.framework.TestResult$1.protect(TestResult.java:106)\n+            // at junit.framework.TestResult.runProtected(TestResult.java:124)\n+            // at junit.framework.TestResult.run(TestResult.java:109)\n+            // at junit.framework.TestCase.run(TestCase.java:118)\n+            // at junit.framework.TestSuite.runTest(TestSuite.java:208)\n+            // at junit.framework.TestSuite.run(TestSuite.java:203)\n+            // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)\n+            // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)\n+            // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)\n+        }\n+    }\n+\n+    /**\n+     * Tests that \"1 <unit>s\" gets converted to \"1 <unit>\" but that \"11 <unit>s\" is left alone.\n+     */\n+    public void testFormatDurationPluralWords() {\n+        long oneSecond = 1000;\n+        long oneMinute = oneSecond * 60;\n+        long oneHour = oneMinute * 60;\n+        long oneDay = oneHour * 24;\n+        String text = null;\n+\n+        text = DurationFormatUtils.formatDurationWords(oneSecond, false, false);\n+        assertEquals(\"0 days 0 hours 0 minutes 1 second\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneSecond * 2, false, false);\n+        assertEquals(\"0 days 0 hours 0 minutes 2 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneSecond * 11, false, false);\n+        assertEquals(\"0 days 0 hours 0 minutes 11 seconds\", text);\n+\n+        text = DurationFormatUtils.formatDurationWords(oneMinute, false, false);\n+        assertEquals(\"0 days 0 hours 1 minute 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneMinute * 2, false, false);\n+        assertEquals(\"0 days 0 hours 2 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneMinute * 11, false, false);\n+        assertEquals(\"0 days 0 hours 11 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneMinute + oneSecond, false, false);\n+        assertEquals(\"0 days 0 hours 1 minute 1 second\", text);\n+\n+        text = DurationFormatUtils.formatDurationWords(oneHour, false, false);\n+        assertEquals(\"0 days 1 hour 0 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneHour * 2, false, false);\n+        assertEquals(\"0 days 2 hours 0 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneHour * 11, false, false);\n+        assertEquals(\"0 days 11 hours 0 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneHour + oneMinute + oneSecond, false, false);\n+        assertEquals(\"0 days 1 hour 1 minute 1 second\", text);\n+\n+        text = DurationFormatUtils.formatDurationWords(oneDay, false, false);\n+        assertEquals(\"1 day 0 hours 0 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneDay * 2, false, false);\n+        assertEquals(\"2 days 0 hours 0 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneDay * 11, false, false);\n+        assertEquals(\"11 days 0 hours 0 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneDay + oneHour + oneMinute + oneSecond, false, false);\n+        assertEquals(\"1 day 1 hour 1 minute 1 second\", text);\n+    }\n+\n+    public void testFormatDurationHMS() {\n+        long time = 0;\n+        assertEquals(\"0:00:00.000\", DurationFormatUtils.formatDurationHMS(time));\n+\n+        time = 1;\n+        assertEquals(\"0:00:00.001\", DurationFormatUtils.formatDurationHMS(time));\n+\n+        time = 15;\n+        assertEquals(\"0:00:00.015\", DurationFormatUtils.formatDurationHMS(time));\n+\n+        time = 165;\n+        assertEquals(\"0:00:00.165\", DurationFormatUtils.formatDurationHMS(time));\n+\n+        time = 1675;\n+        assertEquals(\"0:00:01.675\", DurationFormatUtils.formatDurationHMS(time));\n+\n+        time = 13465;\n+        assertEquals(\"0:00:13.465\", DurationFormatUtils.formatDurationHMS(time));\n+\n+        time = 72789;\n+        assertEquals(\"0:01:12.789\", DurationFormatUtils.formatDurationHMS(time));\n+\n+        time = 12789 + 32 * 60000;\n+        assertEquals(\"0:32:12.789\", DurationFormatUtils.formatDurationHMS(time));\n+\n+        time = 12789 + 62 * 60000;\n+        assertEquals(\"1:02:12.789\", DurationFormatUtils.formatDurationHMS(time));\n+    }\n+\n+    public void testFormatDurationISO() {\n+        assertEquals(\"P0Y0M0DT0H0M0.000S\", DurationFormatUtils.formatDurationISO(0L));\n+        assertEquals(\"P0Y0M0DT0H0M0.001S\", DurationFormatUtils.formatDurationISO(1L));\n+        assertEquals(\"P0Y0M0DT0H0M0.010S\", DurationFormatUtils.formatDurationISO(10L));\n+        assertEquals(\"P0Y0M0DT0H0M0.100S\", DurationFormatUtils.formatDurationISO(100L));\n+        assertEquals(\"P0Y0M0DT0H1M15.321S\", DurationFormatUtils.formatDurationISO(75321L));\n+    }\n+\n+    public void testFormatDuration() {\n+        long duration = 0;\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"y\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"M\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"d\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"H\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"m\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"s\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"S\"));\n+        assertEquals(\"0000\", DurationFormatUtils.formatDuration(duration, \"SSSS\"));\n+        assertEquals(\"0000\", DurationFormatUtils.formatDuration(duration, \"yyyy\"));\n+        assertEquals(\"0000\", DurationFormatUtils.formatDuration(duration, \"yyMM\"));\n+\n+        duration = 60 * 1000;\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"y\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"M\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"d\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"H\"));\n+        assertEquals(\"1\", DurationFormatUtils.formatDuration(duration, \"m\"));\n+        assertEquals(\"60\", DurationFormatUtils.formatDuration(duration, \"s\"));\n+        assertEquals(\"60000\", DurationFormatUtils.formatDuration(duration, \"S\"));\n+        assertEquals(\"01:00\", DurationFormatUtils.formatDuration(duration, \"mm:ss\"));\n+\n+        Calendar base = Calendar.getInstance();\n+        base.set(2000, 0, 1, 0, 0, 0);\n+        base.set(Calendar.MILLISECOND, 0);\n+\n+        Calendar cal = Calendar.getInstance();\n+        cal.set(2003, 1, 1, 0, 0, 0);\n+        cal.set(Calendar.MILLISECOND, 0);\n+        duration = cal.getTime().getTime() - base.getTime().getTime(); // duration from 2000-01-01 to cal\n+        // don't use 1970 in test as time zones were less reliable in 1970 than now\n+        // remember that duration formatting ignores time zones, working on strict hour lengths\n+        int days = 366 + 365 + 365 + 31;\n+        assertEquals(\"0 0 \" + days, DurationFormatUtils.formatDuration(duration, \"y M d\"));\n+    }\n+\n+    public void testFormatPeriodISO() {\n+        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        Calendar base = Calendar.getInstance(timeZone);\n+        base.set(1970, 0, 1, 0, 0, 0);\n+        base.set(Calendar.MILLISECOND, 0);\n+\n+        Calendar cal = Calendar.getInstance(timeZone);\n+        cal.set(2002, 1, 23, 9, 11, 12);\n+        cal.set(Calendar.MILLISECOND, 1);\n+        String text;\n+        // repeat a test from testDateTimeISO to compare extended and not extended.\n+        text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(cal);\n+        assertEquals(\"2002-02-23T09:11:12-03:00\", text);\n+        // test fixture is the same as above, but now with extended format.\n+        text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(),\n+                DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone);\n+        assertEquals(\"P32Y1M22DT9H11M12.001S\", text);\n+        // test fixture from example in http://www.w3.org/TR/xmlschema-2/#duration\n+        cal.set(1971, 1, 3, 10, 30, 0);\n+        cal.set(Calendar.MILLISECOND, 0);\n+        text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(),\n+                DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone);\n+        assertEquals(\"P1Y1M2DT10H30M0.000S\", text);\n+        // want a way to say 'don't print the seconds in format()' or other fields for that matter:\n+        // assertEquals(\"P1Y2M3DT10H30M\", text);\n+    }\n+\n+    public void testFormatPeriod() {\n+        Calendar cal1970 = Calendar.getInstance();\n+        cal1970.set(1970, 0, 1, 0, 0, 0);\n+        cal1970.set(Calendar.MILLISECOND, 0);\n+        long time1970 = cal1970.getTime().getTime();\n+\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"y\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"M\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"d\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"H\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"m\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"s\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"S\"));\n+        assertEquals(\"0000\", DurationFormatUtils.formatPeriod(time1970, time1970, \"SSSS\"));\n+        assertEquals(\"0000\", DurationFormatUtils.formatPeriod(time1970, time1970, \"yyyy\"));\n+        assertEquals(\"0000\", DurationFormatUtils.formatPeriod(time1970, time1970, \"yyMM\"));\n+\n+        long time = time1970 + 60 * 1000;\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time, \"y\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time, \"M\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time, \"d\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time, \"H\"));\n+        assertEquals(\"1\", DurationFormatUtils.formatPeriod(time1970, time, \"m\"));\n+        assertEquals(\"60\", DurationFormatUtils.formatPeriod(time1970, time, \"s\"));\n+        assertEquals(\"60000\", DurationFormatUtils.formatPeriod(time1970, time, \"S\"));\n+        assertEquals(\"01:00\", DurationFormatUtils.formatPeriod(time1970, time, \"mm:ss\"));\n+\n+        Calendar cal = Calendar.getInstance();\n+        cal.set(1973, 6, 1, 0, 0, 0);\n+        cal.set(Calendar.MILLISECOND, 0);\n+        time = cal.getTime().getTime();\n+        assertEquals(\"36\", DurationFormatUtils.formatPeriod(time1970, time, \"yM\"));\n+        assertEquals(\"3 years 6 months\", DurationFormatUtils.formatPeriod(time1970, time, \"y' years 'M' months'\"));\n+        assertEquals(\"03/06\", DurationFormatUtils.formatPeriod(time1970, time, \"yy/MM\"));\n+\n+        cal.set(1973, 10, 1, 0, 0, 0);\n+        cal.set(Calendar.MILLISECOND, 0);\n+        time = cal.getTime().getTime();\n+        assertEquals(\"310\", DurationFormatUtils.formatPeriod(time1970, time, \"yM\"));\n+        assertEquals(\"3 years 10 months\", DurationFormatUtils.formatPeriod(time1970, time, \"y' years 'M' months'\"));\n+        assertEquals(\"03/10\", DurationFormatUtils.formatPeriod(time1970, time, \"yy/MM\"));\n+\n+        cal.set(1974, 0, 1, 0, 0, 0);\n+        cal.set(Calendar.MILLISECOND, 0);\n+        time = cal.getTime().getTime();\n+        assertEquals(\"40\", DurationFormatUtils.formatPeriod(time1970, time, \"yM\"));\n+        assertEquals(\"4 years 0 months\", DurationFormatUtils.formatPeriod(time1970, time, \"y' years 'M' months'\"));\n+        assertEquals(\"04/00\", DurationFormatUtils.formatPeriod(time1970, time, \"yy/MM\"));\n+        assertEquals(\"48\", DurationFormatUtils.formatPeriod(time1970, time, \"M\"));\n+        assertEquals(\"48\", DurationFormatUtils.formatPeriod(time1970, time, \"MM\"));\n+        assertEquals(\"048\", DurationFormatUtils.formatPeriod(time1970, time, \"MMM\"));\n+    }\n+\n+    public void testLexx() {\n+        // tests each constant\n+        assertArrayEquals(new DurationFormatUtils.Token[]{\n+            new DurationFormatUtils.Token(DurationFormatUtils.y, 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.M, 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.d, 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.H, 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.m, 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.s, 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.S, 1)}, DurationFormatUtils.lexx(\"yMdHmsS\"));\n+\n+        // tests the ISO8601-like\n+        assertArrayEquals(new DurationFormatUtils.Token[]{\n+            new DurationFormatUtils.Token(DurationFormatUtils.H, 1),\n+            new DurationFormatUtils.Token(new StringBuffer(\":\"), 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.m, 2),\n+            new DurationFormatUtils.Token(new StringBuffer(\":\"), 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.s, 2),\n+            new DurationFormatUtils.Token(new StringBuffer(\".\"), 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx(\"H:mm:ss.SSS\"));\n+\n+        // test the iso extended format\n+        assertArrayEquals(new DurationFormatUtils.Token[]{\n+            new DurationFormatUtils.Token(new StringBuffer(\"P\"), 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.y, 4),\n+            new DurationFormatUtils.Token(new StringBuffer(\"Y\"), 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.M, 1),\n+            new DurationFormatUtils.Token(new StringBuffer(\"M\"), 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.d, 1),\n+            new DurationFormatUtils.Token(new StringBuffer(\"DT\"), 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.H, 1),\n+            new DurationFormatUtils.Token(new StringBuffer(\"H\"), 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.m, 1),\n+            new DurationFormatUtils.Token(new StringBuffer(\"M\"), 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.s, 1),\n+            new DurationFormatUtils.Token(new StringBuffer(\".\"), 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.S, 1),\n+            new DurationFormatUtils.Token(new StringBuffer(\"S\"), 1)}, DurationFormatUtils\n+                .lexx(DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN));\n+\n+        // test failures in equals\n+        DurationFormatUtils.Token token = new DurationFormatUtils.Token(DurationFormatUtils.y, 4);\n+        assertFalse(\"Token equal to non-Token class. \", token.equals(new Object()));\n+        assertFalse(\"Token equal to Token with wrong value class. \", token.equals(new DurationFormatUtils.Token(\n+                new Object())));\n+        assertFalse(\"Token equal to Token with different count. \", token.equals(new DurationFormatUtils.Token(\n+                DurationFormatUtils.y, 1)));\n+        DurationFormatUtils.Token numToken = new DurationFormatUtils.Token(new Integer(1), 4);\n+        assertTrue(\"Token with Number value not equal to itself. \", numToken.equals(numToken));\n+    }\n+\n+\n+    // http://issues.apache.org/bugzilla/show_bug.cgi?id=38401\n+    public void testBugzilla38401() {\n+        assertEqualDuration( \"0000/00/30 16:00:00 000\", new int[] { 2006, 0, 26, 18, 47, 34 }, \n+                             new int[] { 2006, 1, 26, 10, 47, 34 }, \"yyyy/MM/dd HH:mm:ss SSS\");\n+    }\n+\n+    // https://issues.apache.org/jira/browse/LANG-281\n+    public void testJiraLang281() {\n+        assertEqualDuration( \"09\", new int[] { 2005, 11, 31, 0, 0, 0 }, \n+                             new int[] { 2006, 9, 6, 0, 0, 0 }, \"MM\");\n+    }\n+    \n+    // Testing the under a day range in DurationFormatUtils.formatPeriod\n+    public void testLowDurations() {\n+        for(int hr=0; hr < 24; hr++) {\n+            for(int min=0; min < 60; min++) {\n+                for(int sec=0; sec < 60; sec++) {\n+                    assertEqualDuration( hr + \":\" + min + \":\" + sec, \n+                                         new int[] { 2000, 0, 1, 0, 0, 0, 0 },\n+                                         new int[] { 2000, 0, 1, hr, min, sec },\n+                                         \"H:m:s\"\n+                                       );\n+                }\n+            }\n+        }\n+    }\n+\n+    // Attempting to test edge cases in DurationFormatUtils.formatPeriod\n+    public void testEdgeDurations() {\n+        assertEqualDuration( \"01\", new int[] { 2006, 0, 15, 0, 0, 0 }, \n+                             new int[] { 2006, 2, 10, 0, 0, 0 }, \"MM\");\n+        assertEqualDuration( \"12\", new int[] { 2005, 0, 15, 0, 0, 0 }, \n+                             new int[] { 2006, 0, 15, 0, 0, 0 }, \"MM\");\n+        assertEqualDuration( \"12\", new int[] { 2005, 0, 15, 0, 0, 0 }, \n+                             new int[] { 2006, 0, 16, 0, 0, 0 }, \"MM\");\n+        assertEqualDuration( \"11\", new int[] { 2005, 0, 15, 0, 0, 0 }, \n+                             new int[] { 2006, 0, 14, 0, 0, 0 }, \"MM\");\n+        \n+        assertEqualDuration( \"01 26\", new int[] { 2006, 0, 15, 0, 0, 0 },\n+                             new int[] { 2006, 2, 10, 0, 0, 0 }, \"MM dd\");\n+        assertEqualDuration( \"54\", new int[] { 2006, 0, 15, 0, 0, 0 },\n+                             new int[] { 2006, 2, 10, 0, 0, 0 }, \"dd\"); \n+        \n+        assertEqualDuration( \"09 12\", new int[] { 2006, 1, 20, 0, 0, 0 },\n+                             new int[] { 2006, 11, 4, 0, 0, 0 }, \"MM dd\");\n+        assertEqualDuration( \"287\", new int[] { 2006, 1, 20, 0, 0, 0 },\n+                             new int[] { 2006, 11, 4, 0, 0, 0 }, \"dd\"); \n+\n+        assertEqualDuration( \"11 30\", new int[] { 2006, 0, 2, 0, 0, 0 },\n+                             new int[] { 2007, 0, 1, 0, 0, 0 }, \"MM dd\"); \n+        assertEqualDuration( \"364\", new int[] { 2006, 0, 2, 0, 0, 0 },\n+                             new int[] { 2007, 0, 1, 0, 0, 0 }, \"dd\"); \n+\n+        assertEqualDuration( \"12 00\", new int[] { 2006, 0, 1, 0, 0, 0 },\n+                             new int[] { 2007, 0, 1, 0, 0, 0 }, \"MM dd\"); \n+        assertEqualDuration( \"365\", new int[] { 2006, 0, 1, 0, 0, 0 },\n+                             new int[] { 2007, 0, 1, 0, 0, 0 }, \"dd\"); \n+    \n+        assertEqualDuration( \"31\", new int[] { 2006, 0, 1, 0, 0, 0 },\n+                new int[] { 2006, 1, 1, 0, 0, 0 }, \"dd\"); \n+        \n+        assertEqualDuration( \"92\", new int[] { 2005, 9, 1, 0, 0, 0 },\n+                new int[] { 2006, 0, 1, 0, 0, 0 }, \"dd\"); \n+        assertEqualDuration( \"77\", new int[] { 2005, 9, 16, 0, 0, 0 },\n+                new int[] { 2006, 0, 1, 0, 0, 0 }, \"dd\"); \n+\n+        // test month larger in start than end\n+        assertEqualDuration( \"136\", new int[] { 2005, 9, 16, 0, 0, 0 },\n+                new int[] { 2006, 2, 1, 0, 0, 0 }, \"dd\"); \n+        // test when start in leap year\n+        assertEqualDuration( \"136\", new int[] { 2004, 9, 16, 0, 0, 0 },\n+                new int[] { 2005, 2, 1, 0, 0, 0 }, \"dd\"); \n+        // test when end in leap year\n+        assertEqualDuration( \"137\", new int[] { 2003, 9, 16, 0, 0, 0 },\n+                new int[] { 2004, 2, 1, 0, 0, 0 }, \"dd\");         \n+        // test when end in leap year but less than end of feb\n+        assertEqualDuration( \"135\", new int[] { 2003, 9, 16, 0, 0, 0 },\n+                new int[] { 2004, 1, 28, 0, 0, 0 }, \"dd\"); \n+\n+        assertEqualDuration( \"364\", new int[] { 2007, 0, 2, 0, 0, 0 },\n+                new int[] { 2008, 0, 1, 0, 0, 0 }, \"dd\"); \n+        assertEqualDuration( \"729\", new int[] { 2006, 0, 2, 0, 0, 0 },\n+                new int[] { 2008, 0, 1, 0, 0, 0 }, \"dd\"); \n+\n+        assertEqualDuration( \"365\", new int[] { 2007, 2, 2, 0, 0, 0 },\n+                new int[] { 2008, 2, 1, 0, 0, 0 }, \"dd\"); \n+        assertEqualDuration( \"333\", new int[] { 2007, 1, 2, 0, 0, 0 },\n+                new int[] { 2008, 0, 1, 0, 0, 0 }, \"dd\"); \n+\n+        assertEqualDuration( \"28\", new int[] { 2008, 1, 2, 0, 0, 0 },\n+                new int[] { 2008, 2, 1, 0, 0, 0 }, \"dd\"); \n+        assertEqualDuration( \"393\", new int[] { 2007, 1, 2, 0, 0, 0 },\n+                new int[] { 2008, 2, 1, 0, 0, 0 }, \"dd\"); \n+\n+        assertEqualDuration( \"369\", new int[] { 2004, 0, 29, 0, 0, 0 },\n+                new int[] { 2005, 1, 1, 0, 0, 0 }, \"dd\"); \n+\n+        assertEqualDuration( \"338\", new int[] { 2004, 1, 29, 0, 0, 0 },\n+                new int[] { 2005, 1, 1, 0, 0, 0 }, \"dd\"); \n+\n+        assertEqualDuration( \"28\", new int[] { 2004, 2, 8, 0, 0, 0 },\n+                new int[] { 2004, 3, 5, 0, 0, 0 }, \"dd\"); \n+\n+        assertEqualDuration( \"48\", new int[] { 1992, 1, 29, 0, 0, 0 },\n+                new int[] { 1996, 1, 29, 0, 0, 0 }, \"M\"); \n+        \n+        \n+        // this seems odd - and will fail if I throw it in as a brute force \n+        // below as it expects the answer to be 12. It's a tricky edge case\n+        assertEqualDuration( \"11\", new int[] { 1996, 1, 29, 0, 0, 0 },\n+                new int[] { 1997, 1, 28, 0, 0, 0 }, \"M\"); \n+        // again - this seems odd\n+        assertEqualDuration( \"11 28\", new int[] { 1996, 1, 29, 0, 0, 0 },\n+                new int[] { 1997, 1, 28, 0, 0, 0 }, \"M d\"); \n+        \n+    }\n+    \n+    public void testDurationsByBruteForce() {\n+        bruteForce(2006, 0, 1, \"d\", Calendar.DAY_OF_MONTH);\n+        bruteForce(2006, 0, 2, \"d\", Calendar.DAY_OF_MONTH);\n+        bruteForce(2007, 1, 2, \"d\", Calendar.DAY_OF_MONTH);\n+        bruteForce(2004, 1, 29, \"d\", Calendar.DAY_OF_MONTH);\n+        bruteForce(1996, 1, 29, \"d\", Calendar.DAY_OF_MONTH);\n+\n+        bruteForce(1969, 1, 28, \"M\", Calendar.MONTH);  // tests for 48 years\n+        //bruteForce(1996, 1, 29, \"M\", Calendar.MONTH);  // this will fail\n+    }\n+    \n+    private int FOUR_YEARS = 365 * 3 + 366;\n+    \n+    // Takes a minute to run, so generally turned off\n+//    public void testBrutally() {\n+//        Calendar c = Calendar.getInstance();\n+//        c.set(2004, 0, 1, 0, 0, 0);\n+//        for (int i=0; i < FOUR_YEARS; i++) {\n+//            bruteForce(c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH), \"d\", Calendar.DAY_OF_MONTH );\n+//            c.add(Calendar.DAY_OF_MONTH, 1);\n+//        }\n+//    }        \n+    \n+    private void bruteForce(int year, int month, int day, String format, int calendarType) {\n+        String msg = year + \"-\" + month + \"-\" + day + \" to \";\n+        Calendar c = Calendar.getInstance();\n+        c.set(year, month, day, 0, 0, 0);\n+        int[] array1 = new int[] { year, month, day, 0, 0, 0 };\n+        int[] array2 = new int[] { year, month, day, 0, 0, 0 };\n+        for (int i=0; i < FOUR_YEARS; i++) {\n+            array2[0] = c.get(Calendar.YEAR);\n+            array2[1] = c.get(Calendar.MONTH);\n+            array2[2] = c.get(Calendar.DAY_OF_MONTH);\n+            String tmpMsg = msg + array2[0] + \"-\" + array2[1] + \"-\" + array2[2] + \" at \";\n+            assertEqualDuration( tmpMsg + i, Integer.toString(i), array1, array2, format );\n+            c.add(calendarType, 1);\n+        }\n+    }\n+\n+    private void assertEqualDuration(String expected, int[] start, int[] end, String format) {\n+        assertEqualDuration(null, expected, start, end, format);\n+    }\n+    private void assertEqualDuration(String message, String expected, int[] start, int[] end, String format) {\n+        Calendar cal1 = Calendar.getInstance();\n+        cal1.set(start[0], start[1], start[2], start[3], start[4], start[5]);\n+        cal1.set(Calendar.MILLISECOND, 0);\n+        Calendar cal2 = Calendar.getInstance();\n+        cal2.set(end[0], end[1], end[2], end[3], end[4], end[5]);\n+        cal2.set(Calendar.MILLISECOND, 0);\n+        long milli1 = cal1.getTime().getTime();\n+        long milli2 = cal2.getTime().getTime();\n+        String result = DurationFormatUtils.formatPeriod(milli1, milli2, format);\n+        if (message == null) {\n+            assertEquals(expected, result);\n+        } else {\n+            assertEquals(message, expected, result);\n+        }\n+    }\n+\n+    private void assertArrayEquals(DurationFormatUtils.Token[] obj1, DurationFormatUtils.Token[] obj2) {\n+        assertEquals(\"Arrays are unequal length. \", obj1.length, obj2.length);\n+        for (int i = 0; i < obj1.length; i++) {\n+            assertTrue(\"Index \" + i + \" not equal, \" + obj1[i] + \" vs \" + obj2[i], obj1[i].equals(obj2[i]));\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/time/FastDateFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.lang.SerializationUtils;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.time.FastDateFormat}.\n+ *\n+ * @author Sean Schofield\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author Fredrik Westermarck\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class FastDateFormatTest extends TestCase {\n+\n+    public FastDateFormatTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(FastDateFormatTest.class);\n+        suite.setName(\"FastDateFormat Tests\");\n+\n+        return suite;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    public void test_getInstance() {\n+        FastDateFormat format1 = FastDateFormat.getInstance();\n+        FastDateFormat format2 = FastDateFormat.getInstance();\n+        assertSame(format1, format2);\n+        assertEquals(new SimpleDateFormat().toPattern(), format1.getPattern());\n+    }\n+\n+    public void test_getInstance_String() {\n+        FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\");\n+        FastDateFormat format2 = FastDateFormat.getInstance(\"MM-DD-yyyy\");\n+        FastDateFormat format3 = FastDateFormat.getInstance(\"MM-DD-yyyy\");\n+\n+        assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n+        assertSame(format2, format3);\n+        assertEquals(\"MM/DD/yyyy\", format1.getPattern());\n+        assertEquals(TimeZone.getDefault(), format1.getTimeZone());\n+        assertEquals(TimeZone.getDefault(), format2.getTimeZone());\n+        assertEquals(false, format1.getTimeZoneOverridesCalendar());\n+        assertEquals(false, format2.getTimeZoneOverridesCalendar());\n+    }\n+\n+    public void test_getInstance_String_TimeZone() {\n+        Locale realDefaultLocale = Locale.getDefault();\n+        TimeZone realDefaultZone = TimeZone.getDefault();\n+        try {\n+            Locale.setDefault(Locale.US);\n+            TimeZone.setDefault(TimeZone.getTimeZone(\"America/New_York\"));\n+\n+            FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\",\n+                    TimeZone.getTimeZone(\"Atlantic/Reykjavik\"));\n+            FastDateFormat format2 = FastDateFormat.getInstance(\"MM/DD/yyyy\");\n+            FastDateFormat format3 = FastDateFormat.getInstance(\"MM/DD/yyyy\", TimeZone.getDefault());\n+            FastDateFormat format4 = FastDateFormat.getInstance(\"MM/DD/yyyy\", TimeZone.getDefault());\n+            FastDateFormat format5 = FastDateFormat.getInstance(\"MM-DD-yyyy\", TimeZone.getDefault());\n+            FastDateFormat format6 = FastDateFormat.getInstance(\"MM-DD-yyyy\");\n+\n+            assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n+            assertEquals(TimeZone.getTimeZone(\"Atlantic/Reykjavik\"), format1.getTimeZone());\n+            assertEquals(true, format1.getTimeZoneOverridesCalendar());\n+            assertEquals(TimeZone.getDefault(), format2.getTimeZone());\n+            assertEquals(false, format2.getTimeZoneOverridesCalendar());\n+            assertSame(format3, format4);\n+            assertTrue(format3 != format5); // -- junit 3.8 version -- assertFalse(format3 == format5);\n+            assertTrue(format4 != format6); // -- junit 3.8 version -- assertFalse(format3 == format5);\n+\n+        } finally {\n+            Locale.setDefault(realDefaultLocale);\n+            TimeZone.setDefault(realDefaultZone);\n+        }\n+    }\n+\n+    public void test_getInstance_String_Locale() {\n+        Locale realDefaultLocale = Locale.getDefault();\n+        try {\n+            Locale.setDefault(Locale.US);\n+            FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\", Locale.GERMANY);\n+            FastDateFormat format2 = FastDateFormat.getInstance(\"MM/DD/yyyy\");\n+            FastDateFormat format3 = FastDateFormat.getInstance(\"MM/DD/yyyy\", Locale.GERMANY);\n+\n+            assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n+            assertSame(format1, format3);\n+            assertSame(Locale.GERMANY, format1.getLocale());\n+\n+        } finally {\n+            Locale.setDefault(realDefaultLocale);\n+        }\n+    }\n+\n+    public void test_changeDefault_Locale_DateInstance() {\n+        Locale realDefaultLocale = Locale.getDefault();\n+        try {\n+            Locale.setDefault(Locale.US);\n+            FastDateFormat format1 = FastDateFormat.getDateInstance(FastDateFormat.FULL, Locale.GERMANY);\n+            FastDateFormat format2 = FastDateFormat.getDateInstance(FastDateFormat.FULL);\n+            Locale.setDefault(Locale.GERMANY);\n+            FastDateFormat format3 = FastDateFormat.getDateInstance(FastDateFormat.FULL);\n+\n+            assertSame(Locale.GERMANY, format1.getLocale());\n+            assertSame(Locale.US, format2.getLocale());\n+            assertSame(Locale.GERMANY, format3.getLocale());\n+            assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n+            assertTrue(format2 != format3);\n+\n+        } finally {\n+            Locale.setDefault(realDefaultLocale);\n+        }\n+    }\n+\n+    public void test_changeDefault_Locale_DateTimeInstance() {\n+        Locale realDefaultLocale = Locale.getDefault();\n+        try {\n+            Locale.setDefault(Locale.US);\n+            FastDateFormat format1 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL, Locale.GERMANY);\n+            FastDateFormat format2 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL);\n+            Locale.setDefault(Locale.GERMANY);\n+            FastDateFormat format3 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL);\n+\n+            assertSame(Locale.GERMANY, format1.getLocale());\n+            assertSame(Locale.US, format2.getLocale());\n+            assertSame(Locale.GERMANY, format3.getLocale());\n+            assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n+            assertTrue(format2 != format3);\n+\n+        } finally {\n+            Locale.setDefault(realDefaultLocale);\n+        }\n+    }\n+\n+    public void test_getInstance_String_TimeZone_Locale() {\n+        Locale realDefaultLocale = Locale.getDefault();\n+        TimeZone realDefaultZone = TimeZone.getDefault();\n+        try {\n+            Locale.setDefault(Locale.US);\n+            TimeZone.setDefault(TimeZone.getTimeZone(\"America/New_York\"));\n+\n+            FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\",\n+                    TimeZone.getTimeZone(\"Atlantic/Reykjavik\"), Locale.GERMANY);\n+            FastDateFormat format2 = FastDateFormat.getInstance(\"MM/DD/yyyy\", Locale.GERMANY);\n+            FastDateFormat format3 = FastDateFormat.getInstance(\"MM/DD/yyyy\",\n+                    TimeZone.getDefault(), Locale.GERMANY);\n+\n+            assertTrue(format1 != format2); // -- junit 3.8 version -- assertNotSame(format1, format2);\n+            assertEquals(TimeZone.getTimeZone(\"Atlantic/Reykjavik\"), format1.getTimeZone());\n+            assertEquals(TimeZone.getDefault(), format2.getTimeZone());\n+            assertEquals(TimeZone.getDefault(), format3.getTimeZone());\n+            assertEquals(true, format1.getTimeZoneOverridesCalendar());\n+            assertEquals(false, format2.getTimeZoneOverridesCalendar());\n+            assertEquals(true, format3.getTimeZoneOverridesCalendar());\n+            assertEquals(Locale.GERMANY, format1.getLocale());\n+            assertEquals(Locale.GERMANY, format2.getLocale());\n+            assertEquals(Locale.GERMANY, format3.getLocale());\n+\n+        } finally {\n+            Locale.setDefault(realDefaultLocale);\n+            TimeZone.setDefault(realDefaultZone);\n+        }\n+    }\n+\n+    public void testFormat() {\n+        Locale realDefaultLocale = Locale.getDefault();\n+        TimeZone realDefaultZone = TimeZone.getDefault();\n+        try {\n+            Locale.setDefault(Locale.US);\n+            TimeZone.setDefault(TimeZone.getTimeZone(\"America/New_York\"));\n+            FastDateFormat fdf = null;\n+            SimpleDateFormat sdf = null;\n+\n+            GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20);\n+            GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00);\n+            Date date1 = cal1.getTime();\n+            Date date2 = cal2.getTime();\n+            long millis1 = date1.getTime();\n+            long millis2 = date2.getTime();\n+\n+            fdf = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss\");\n+            sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n+            assertEquals(sdf.format(date1), fdf.format(date1));\n+            assertEquals(\"2003-01-10T15:33:20\", fdf.format(date1));\n+            assertEquals(\"2003-01-10T15:33:20\", fdf.format(cal1));\n+            assertEquals(\"2003-01-10T15:33:20\", fdf.format(millis1));\n+            assertEquals(\"2003-07-10T09:00:00\", fdf.format(date2));\n+            assertEquals(\"2003-07-10T09:00:00\", fdf.format(cal2));\n+            assertEquals(\"2003-07-10T09:00:00\", fdf.format(millis2));\n+\n+            fdf = FastDateFormat.getInstance(\"Z\");\n+            assertEquals(\"-0500\", fdf.format(date1));\n+            assertEquals(\"-0500\", fdf.format(cal1));\n+            assertEquals(\"-0500\", fdf.format(millis1));\n+\n+            fdf = FastDateFormat.getInstance(\"Z\");\n+            assertEquals(\"-0400\", fdf.format(date2));\n+            assertEquals(\"-0400\", fdf.format(cal2));\n+            assertEquals(\"-0400\", fdf.format(millis2));\n+\n+            fdf = FastDateFormat.getInstance(\"ZZ\");\n+            assertEquals(\"-05:00\", fdf.format(date1));\n+            assertEquals(\"-05:00\", fdf.format(cal1));\n+            assertEquals(\"-05:00\", fdf.format(millis1));\n+\n+            fdf = FastDateFormat.getInstance(\"ZZ\");\n+            assertEquals(\"-04:00\", fdf.format(date2));\n+            assertEquals(\"-04:00\", fdf.format(cal2));\n+            assertEquals(\"-04:00\", fdf.format(millis2));\n+\n+            String pattern = \"GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M\" +\n+                \" dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z\";\n+            fdf = FastDateFormat.getInstance(pattern);\n+            sdf = new SimpleDateFormat(pattern);\n+            assertEquals(sdf.format(date1), fdf.format(date1));\n+            assertEquals(sdf.format(date2), fdf.format(date2));\n+\n+        } finally {\n+            Locale.setDefault(realDefaultLocale);\n+            TimeZone.setDefault(realDefaultZone);\n+        }\n+    }\n+\n+    /**\n+     * Test case for {@link FastDateFormat#getDateInstance(int, java.util.Locale)}.\n+     */\n+    public void testShortDateStyleWithLocales() {\n+        Locale usLocale = Locale.US;\n+        Locale swedishLocale = new Locale(\"sv\", \"SE\");\n+        Calendar cal = Calendar.getInstance();\n+        cal.set(2004, 1, 3);\n+        FastDateFormat fdf = FastDateFormat.getDateInstance(FastDateFormat.SHORT, usLocale);\n+        assertEquals(\"2/3/04\", fdf.format(cal));\n+\n+        fdf = FastDateFormat.getDateInstance(FastDateFormat.SHORT, swedishLocale);\n+        assertEquals(\"2004-02-03\", fdf.format(cal));\n+\n+    }\n+\n+    /**\n+     * Tests that pre-1000AD years get padded with yyyy\n+     */\n+    public void testLowYearPadding() {\n+        Calendar cal = Calendar.getInstance();\n+        FastDateFormat format = FastDateFormat.getInstance(\"yyyy/MM/DD\");\n+\n+        cal.set(1,0,1);\n+        assertEquals(\"0001/01/01\", format.format(cal));\n+        cal.set(10,0,1);\n+        assertEquals(\"0010/01/01\", format.format(cal));\n+        cal.set(100,0,1);\n+        assertEquals(\"0100/01/01\", format.format(cal));\n+        cal.set(999,0,1);\n+        assertEquals(\"0999/01/01\", format.format(cal));\n+    }\n+    /**\n+     * Show Bug #39410 is solved\n+     */\n+    public void testMilleniumBug() {\n+        Calendar cal = Calendar.getInstance();\n+        FastDateFormat format = FastDateFormat.getInstance(\"dd.MM.yyyy\");\n+\n+        cal.set(1000,0,1);\n+        assertEquals(\"01.01.1000\", format.format(cal));\n+    }\n+\n+    /**\n+     * testLowYearPadding showed that the date was buggy\n+     * This test confirms it, getting 366 back as a date\n+     */\n+     // TODO: Fix this problem\n+    public void testSimpleDate() {\n+        Calendar cal = Calendar.getInstance();\n+        FastDateFormat format = FastDateFormat.getInstance(\"yyyy/MM/dd\");\n+\n+        cal.set(2004,11,31);\n+        assertEquals(\"2004/12/31\", format.format(cal));\n+        cal.set(999,11,31);\n+        assertEquals(\"0999/12/31\", format.format(cal));\n+        cal.set(1,2,2);\n+        assertEquals(\"0001/03/02\", format.format(cal));\n+    }\n+\n+    public void testLang303() {\n+        Calendar cal = Calendar.getInstance();\n+        cal.set(2004,11,31);\n+\n+        FastDateFormat format = FastDateFormat.getInstance(\"yyyy/MM/dd\");\n+        String output = format.format(cal);\n+\n+        format = (FastDateFormat) SerializationUtils.deserialize( SerializationUtils.serialize( format ) );\n+        assertEquals(output, format.format(cal));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang3/time/StopWatchTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import junit.framework.Assert;\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * TestCase for StopWatch.\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class StopWatchTest extends TestCase {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StopWatchTest.class);\n+        suite.setName(\"StopWatch Tests\");\n+        return suite;\n+    }\n+\n+    public StopWatchTest(String s) {\n+        super(s);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testStopWatchSimple(){\n+        StopWatch watch = new StopWatch();\n+        watch.start();\n+            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n+        watch.stop();\n+        long time = watch.getTime();\n+        assertEquals(time, watch.getTime());\n+        \n+        assertTrue(time >= 500);\n+        assertTrue(time < 700);\n+        \n+        watch.reset();\n+        assertEquals(0, watch.getTime());\n+    }\n+    \n+    public void testStopWatchSimpleGet(){\n+        StopWatch watch = new StopWatch();\n+        assertEquals(0, watch.getTime());\n+        assertEquals(\"0:00:00.000\", watch.toString());\n+        \n+        watch.start();\n+            try {Thread.sleep(500);} catch (InterruptedException ex) {}\n+        assertTrue(watch.getTime() < 2000);\n+    }\n+    \n+    public void testStopWatchSplit(){\n+        StopWatch watch = new StopWatch();\n+        watch.start();\n+            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n+        watch.split();\n+        long splitTime = watch.getSplitTime();\n+        String splitStr = watch.toSplitString();\n+            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n+        watch.unsplit();\n+            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n+        watch.stop();\n+        long totalTime = watch.getTime();\n+\n+        assertEquals(\"Formatted split string not the correct length\", \n+                     splitStr.length(), 11);\n+        assertTrue(splitTime >= 500);\n+        assertTrue(splitTime < 700);\n+        assertTrue(totalTime >= 1500);\n+        assertTrue(totalTime < 1900);\n+    }\n+    \n+    public void testStopWatchSuspend(){\n+        StopWatch watch = new StopWatch();\n+        watch.start();\n+            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n+        watch.suspend();\n+        long suspendTime = watch.getTime();\n+            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n+        watch.resume();\n+            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n+        watch.stop();\n+        long totalTime = watch.getTime();\n+        \n+        assertTrue(suspendTime >= 500);\n+        assertTrue(suspendTime < 700);\n+        assertTrue(totalTime >= 1000);\n+        assertTrue(totalTime < 1300);\n+    }\n+\n+    public void testLang315() {\n+        StopWatch watch = new StopWatch();\n+        watch.start();\n+            try {Thread.sleep(200);} catch (InterruptedException ex) {}\n+        watch.suspend();\n+        long suspendTime = watch.getTime();\n+            try {Thread.sleep(200);} catch (InterruptedException ex) {}\n+        watch.stop();\n+        long totalTime = watch.getTime();\n+        assertTrue( suspendTime == totalTime );\n+    }\n+\n+    // test bad states\n+    public void testBadStates() {\n+        StopWatch watch = new StopWatch();\n+        try {\n+            watch.stop();\n+            fail(\"Calling stop on an unstarted StopWatch should throw an exception. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+        try {\n+            watch.stop();\n+            fail(\"Calling stop on an unstarted StopWatch should throw an exception. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+        try {\n+            watch.suspend();\n+            fail(\"Calling suspend on an unstarted StopWatch should throw an exception. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+        try {\n+            watch.split();\n+            fail(\"Calling split on a non-running StopWatch should throw an exception. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+        try {\n+            watch.unsplit();\n+            fail(\"Calling unsplit on an unsplit StopWatch should throw an exception. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+        try {\n+            watch.resume();\n+            fail(\"Calling resume on an unsuspended StopWatch should throw an exception. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+        watch.start();\n+\n+        try {\n+            watch.start();\n+            fail(\"Calling start on a started StopWatch should throw an exception. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+        try {\n+            watch.unsplit();\n+            fail(\"Calling unsplit on an unsplit StopWatch should throw an exception. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+        try {\n+            watch.getSplitTime();\n+            fail(\"Calling getSplitTime on an unsplit StopWatch should throw an exception. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+        try {\n+            watch.resume();\n+            fail(\"Calling resume on an unsuspended StopWatch should throw an exception. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+        watch.stop();\n+\n+        try {\n+            watch.start();\n+            fail(\"Calling start on a stopped StopWatch should throw an exception as it needs to be reset. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetStartTime() {\n+        long beforeStopWatch = System.currentTimeMillis();\n+        StopWatch watch = new StopWatch();\n+        try {\n+            watch.getStartTime();\n+            fail(\"Calling getStartTime on an unstarted StopWatch should throw an exception\");\n+        } catch (IllegalStateException expected) {\n+            // expected\n+        }\n+        watch.start();\n+        try {\n+            watch.getStartTime();\n+            Assert.assertTrue(watch.getStartTime() >= beforeStopWatch);\n+        } catch (IllegalStateException ex) {\n+            fail(\"Start time should be available: \" + ex.getMessage());\n+        }\n+        watch.reset();\n+        try {\n+            watch.getStartTime();\n+            fail(\"Calling getStartTime on a reset, but unstarted StopWatch should throw an exception\");\n+        } catch (IllegalStateException expected) {\n+            // expected\n+        }\n+    }\n+\n+}", "timestamp": 1260444831, "metainfo": ""}