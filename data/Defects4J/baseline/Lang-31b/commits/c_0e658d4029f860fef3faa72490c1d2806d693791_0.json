{"sha": "0e658d4029f860fef3faa72490c1d2806d693791", "log": "Added compare methods for double and float Added min/max methods for long Added public constructor with comment   ", "commit": "\n--- a/src/java/org/apache/commons/lang/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/NumberUtils.java\n import java.math.BigInteger;\n import java.math.BigDecimal;\n /**\n- * Provides extra functionality for java Number classes.\n+ * Provides extra functionality for Java Number classes.\n  *\n  * @author <a href=\"mailto:bayard@generationjava.com\">Henri Yandell</a>\n  * @author <a href=\"mailto:rand_mcneely@yahoo.com\">Rand McNeely</a>\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n- * @version $Id: NumberUtils.java,v 1.1 2002/07/19 03:35:54 bayard Exp $\n+ * @author <a href=\"mailto:steve.downey@netfolio.com\">Steve Downey</a>\n+ * @version $Id: NumberUtils.java,v 1.2 2002/09/15 10:26:42 scolebourne Exp $\n  */\n public final class NumberUtils {\n \n+    /**\n+     * NumberUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>NumberUtils.stringToInt(\"6\");</code>.\n+     * This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.\n+     */\n+    public NumberUtils() {\n+    }\n+\n+    //--------------------------------------------------------------------\n+    \n     /**\n      * Convert a String to an int, returning zero if the conversion fails\n      * \n         }\n     }\n \n+    //--------------------------------------------------------------------\n+    \n     // must handle Long, Float, Integer, Float, Short,\n     //                  BigDecimal, BigInteger and Byte\n     // useful methods:\n         return s.length() > 0;\n     }\n \n+    //--------------------------------------------------------------------\n+    \n     /**\n      * Convert a String to a Float\n      * \n         return bd;\n     }\n \n-    /**\n-     * Get the minimum of three values.\n+    //--------------------------------------------------------------------\n+    \n+    /**\n+     * Gets the minimum of three long values.\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static long minimum(long a, long b, long c) {\n+        if (b < a) {\n+            a = b;\n+        }\n+        if (c < a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * Gets the minimum of three int values.\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n      */\n     public static int minimum(int a, int b, int c) {\n         if (b < a) {\n     }\n \n     /**\n-     * Get the maximum of three values.\n+     * Gets the maximum of three long values.\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static long maximum(long a, long b, long c) {\n+        if (b > a) {\n+            a = b;\n+        }\n+        if (c > a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * Gets the maximum of three int values.\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n      */\n     public static int maximum(int a, int b, int c) {\n         if (b > a) {\n         return a;\n     }\n \n+    //--------------------------------------------------------------------\n+    \n+    /**\n+     * Compares two doubles for order.\n+     * <p>\n+     * This method is more comprhensive than the standard Java greater than,\n+     * less than and equals operators.\n+     * It returns -1 if the first value is less than the second.\n+     * It returns +1 if the first value is greater than the second.\n+     * It returns 0 if the values are equal.\n+     * <p>\n+     * The ordering is as follows, largest to smallest:\n+     * <ul>\n+     * <li>NaN\n+     * <li>Positive infinity\n+     * <li>Maximum double\n+     * <li>Normal positve numbers\n+     * <li>+0.0\n+     * <li>-0.0\n+     * <li>Minimum double (-Double.MAX_VALUE)\n+     * <li>Normal negative numbers\n+     * <li>Negative infinity\n+     * </ul>\n+     * Comparing NaN with NaN will return 0.\n+     * \n+     * @param lhs  the first double\n+     * @param rhs  the second double\n+     * @return -1 if lhs is less, +1 if greater, 0 if equal to rhs\n+     */\n+    public static int compare(double lhs, double rhs) {\n+        if (lhs < rhs) {\n+            return -1;\n+        }\n+        if (lhs > rhs) {\n+            return +1;\n+        }\n+        // Need to compare bits to handle 0.0 == -0.0 being true\n+        // compare should put -0.0 < +0.0\n+        // Two NaNs are also == for compare purposes\n+        // where NaN == NaN is false\n+        long lhsBits = Double.doubleToLongBits(lhs);\n+        long rhsBits = Double.doubleToLongBits(rhs);\n+        if (lhsBits == rhsBits) {\n+            return 0;\n+        }\n+        // Something exotic! A comparison to NaN or 0.0 vs -0.0\n+        // Fortunately NaN's long is > than everything else\n+        // Also negzeros bits < poszero\n+        // NAN: 9221120237041090560\n+        // MAX: 9218868437227405311\n+        // NEGZERO: -9223372036854775808\n+        if (lhsBits < rhsBits) {\n+            return -1;\n+        } else {\n+            return +1;\n+        }\n+    }\n+    \n+    /**\n+     * Compares two floats for order.\n+     * <p>\n+     * This method is more comprhensive than the standard Java greater than,\n+     * less than and equals operators.\n+     * It returns -1 if the first value is less than the second.\n+     * It returns +1 if the first value is greater than the second.\n+     * It returns 0 if the values are equal.\n+     * <p>\n+     * The ordering is as follows, largest to smallest:\n+     * <ul>\n+     * <li>NaN\n+     * <li>Positive infinity\n+     * <li>Maximum float\n+     * <li>Normal positve numbers\n+     * <li>+0.0\n+     * <li>-0.0\n+     * <li>Normal negative numbers\n+     * <li>Minimum float (-Float.MAX_VALUE)\n+     * <li>Negative infinity\n+     * </ul>\n+     * Comparing NaN with NaN will return 0.\n+     * \n+     * @param lhs  the first float\n+     * @param rhs  the second float\n+     * @return -1 if lhs is less, +1 if greater, 0 if equal to rhs\n+     */\n+    public static int compare(float lhs, float rhs) {\n+        if (lhs < rhs) {\n+            return -1;\n+        }\n+        if (lhs > rhs) {\n+            return +1;\n+        }\n+        //Need to compare bits to handle 0.0 == -0.0 being true\n+        // compare should put -0.0 < +0.0\n+        // Two NaNs are also == for compare purposes\n+        // where NaN == NaN is false\n+        int lhsBits = Float.floatToIntBits(lhs);\n+        int rhsBits = Float.floatToIntBits(rhs);\n+        if (lhsBits == rhsBits) {\n+            return 0;\n+        }\n+        //Something exotic! A comparison to NaN or 0.0 vs -0.0\n+        //Fortunately NaN's int is > than everything else\n+        //Also negzeros bits < poszero\n+        //NAN: 2143289344\n+        //MAX: 2139095039\n+        //NEGZERO: -2147483648\n+        if (lhsBits < rhsBits) {\n+            return -1;\n+        } else {\n+            return +1;\n+        }\n+    }\n+    \n+    //--------------------------------------------------------------------\n+    \n     /**\n      * Checks whether the String contains only digit characters.\n      * Null and blank string will return false.", "timestamp": 1032085602, "metainfo": ""}