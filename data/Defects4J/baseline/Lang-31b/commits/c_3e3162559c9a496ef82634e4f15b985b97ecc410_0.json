{"sha": "3e3162559c9a496ef82634e4f15b985b97ecc410", "log": "Applying my patch from LANG-379, based on Robert Scholte's patch adding the 'getFragment' family of methods  ", "commit": "\n--- a/src/java/org/apache/commons/lang/time/DateUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DateUtils.java\n /**\n  * <p>A suite of utilities surrounding the use of the\n  * {@link java.util.Calendar} and {@link java.util.Date} object.</p>\n+ * \n+ * <p>DateUtils contains a lot of common methods considering manipulations of Dates or Calendars.\n+ * Some methods require some extra explanation.\n+ * The truncate and round methods could be considered the Math.floor(), Math.ceil() or Math.round versions for dates\n+ * This way date-fields will be ignored in bottom-up order.\n+ * As a complement to these methods we've introduced some fragment-methods. With these methods the Date-fields will be ignored in top-down order.\n+ * Since a date without a year is not a valid date, you have to decide in what kind of date-field you want your result, for instance milliseconds or days.\n+ * </p>\n+ *   \n+ *   \n  *\n  * @author <a href=\"mailto:sergek@lokitech.com\">Serge Knystautas</a>\n  * @author Stephen Colebourne\n  * @author Janek Bogucki\n  * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n  * @author Phil Steitz\n+ * @author Robert Scholte\n  * @since 2.0\n  * @version $Id$\n  */\n             throw new ClassCastException(\"Could not iterate based on \" + focus);\n         }\n     }\n+    \n+    /**\n+     * <p>Returns the number of milliseconds within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p>\n+     * \n+     * <p>Asking the milliseconds of any date will only return the number of milliseconds\n+     * of the current second (resulting in a number between 0 and 999). This \n+     * method will retrieve the number of milliseconds for any fragment. \n+     * For example, if you want to calculate the number of milliseconds past today, \n+     * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will\n+     * be all milliseconds of the past hour(s), minutes(s) and second(s).</p>\n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a SECOND field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10538 (10*1000 + 538)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0 (a millisecond cannot be split in milliseconds)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date the date to work with, not null\n+     * @param fragment the Calendar field part of date to calculate \n+     * @return number of milliseconds within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or\n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInMilliseconds(Date date, int fragment) {\n+        return getFragment(date, fragment, Calendar.MILLISECOND);    \n+    }\n+    \n+    /**\n+     * <p>Returns the number of seconds within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the seconds of any date will only return the number of seconds\n+     * of the current minute (resulting in a number between 0 and 59). This \n+     * method will retrieve the number of seconds for any fragment. \n+     * For example, if you want to calculate the number of seconds past today, \n+     * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will\n+     * be all seconds of the past hour(s) and minutes(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a SECOND field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10 (equivalent to deprecated date.getSeconds())</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10 (equivalent to deprecated date.getSeconds())</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 26110 (7*3600 + 15*60 + 10)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0 (a millisecond cannot be split in seconds)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date the date to work with, not null\n+     * @param fragment the Calendar field part of date to calculate \n+     * @return number of seconds within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or\n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInSeconds(Date date, int fragment) {\n+        return getFragment(date, fragment, Calendar.SECOND);\n+    }\n+    \n+    /**\n+     * <p>Returns the number of minutes within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the minutes of any date will only return the number of minutes\n+     * of the current hour (resulting in a number between 0 and 59). This \n+     * method will retrieve the number of minutes for any fragment. \n+     * For example, if you want to calculate the number of minutes past this month, \n+     * your fragment is Calendar.MONTH. The result will be all minutes of the \n+     * past day(s) and hour(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a MINUTE field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15 (equivalent to deprecated date.getMinutes())</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15 (equivalent to deprecated date.getMinutes())</li>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 15</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 435 (7*60 + 15)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0 (a millisecond cannot be split in minutes)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date the date to work with, not null\n+     * @param fragment the Calendar field part of date to calculate \n+     * @return number of minutes within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInMinutes(Date date, int fragment) {\n+        return getFragment(date, fragment, Calendar.MINUTE);\n+    }\n+    \n+    /**\n+     * <p>Returns the number of hours within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the hours of any date will only return the number of hours\n+     * of the current day (resulting in a number between 0 and 23). This \n+     * method will retrieve the number of hours for any fragment. \n+     * For example, if you want to calculate the number of hours past this month, \n+     * your fragment is Calendar.MONTH. The result will be all hours of the \n+     * past day(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a HOUR field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7 (equivalent to deprecated date.getHours())</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7 (equivalent to deprecated date.getHours())</li>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 7</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 127 (5*24 + 7)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0 (a millisecond cannot be split in hours)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date the date to work with, not null\n+     * @param fragment the Calendar field part of date to calculate \n+     * @return number of hours within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInHours(Date date, int fragment) {\n+        return getFragment(date, fragment, Calendar.HOUR_OF_DAY);\n+    }\n+    \n+    /**\n+     * <p>Returns the number of days within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the days of any date will only return the number of days\n+     * of the current month (resulting in a number between 1 and 31). This \n+     * method will retrieve the number of days for any fragment. \n+     * For example, if you want to calculate the number of days past this year, \n+     * your fragment is Calendar.YEAR. The result will be all days of the \n+     * past month(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a DAY field will return 0.</p> \n+     *  \n+     * <p>\n+     * <ul>\n+     *  <li>January 28, 2008 with Calendar.MONTH as fragment will return 28 (equivalent to deprecated date.getDay())</li>\n+     *  <li>February 28, 2008 with Calendar.MONTH as fragment will return 28 (equivalent to deprecated date.getDay())</li>\n+     *  <li>January 28, 2008 with Calendar.YEAR as fragment will return 28</li>\n+     *  <li>February 28, 2008 with Calendar.YEAR as fragment will return 59</li>\n+     *  <li>January 28, 2008 with Calendar.MILLISECOND as fragment will return 0 (a millisecond cannot be split in days)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date the date to work with, not null\n+     * @param fragment the Calendar field part of date to calculate \n+     * @return number of days  within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInDays(Date date, int fragment) {\n+        return getFragment(date, fragment, Calendar.DAY_OF_YEAR);\n+    }\n+\n+    /**\n+     * <p>Returns the number of milliseconds within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the milliseconds of any date will only return the number of milliseconds\n+     * of the current second (resulting in a number between 0 and 999). This \n+     * method will retrieve the number of milliseconds for any fragment. \n+     * For example, if you want to calculate the number of seconds past today, \n+     * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will\n+     * be all seconds of the past hour(s), minutes(s) and second(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a MILLISECOND field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538 (equivalent to calendar.get(Calendar.MILLISECOND))</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538 (equivalent to calendar.get(Calendar.MILLISECOND))</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10538 (10*1000 + 538)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0 (a millisecond cannot be split in milliseconds)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param calendar the calendar to work with, not null\n+     * @param fragment the Calendar field part of calendar to calculate \n+     * @return number of milliseconds within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+  public static long getFragmentInMilliseconds(Calendar calendar, int fragment) {\n+    return getFragment(calendar, fragment, Calendar.MILLISECOND);\n+  }\n+    /**\n+     * <p>Returns the number of seconds within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the seconds of any date will only return the number of seconds\n+     * of the current minute (resulting in a number between 0 and 59). This \n+     * method will retrieve the number of seconds for any fragment. \n+     * For example, if you want to calculate the number of seconds past today, \n+     * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will\n+     * be all seconds of the past hour(s) and minutes(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a SECOND field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10 (equivalent to calendar.get(Calendar.SECOND))</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10 (equivalent to calendar.get(Calendar.SECOND))</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 26110 (7*3600 + 15*60 + 10)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0 (a millisecond cannot be split in seconds)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param calendar the calendar to work with, not null\n+     * @param fragment the Calendar field part of calendar to calculate \n+     * @return number of seconds within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInSeconds(Calendar calendar, int fragment) {\n+        return getFragment(calendar, fragment, Calendar.SECOND);\n+    }\n+    \n+    /**\n+     * <p>Returns the number of minutes within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the minutes of any date will only return the number of minutes\n+     * of the current hour (resulting in a number between 0 and 59). This \n+     * method will retrieve the number of minutes for any fragment. \n+     * For example, if you want to calculate the number of minutes past this month, \n+     * your fragment is Calendar.MONTH. The result will be all minutes of the \n+     * past day(s) and hour(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a MINUTE field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15 (equivalent to calendar.get(Calendar.MINUTES))</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15 (equivalent to calendar.get(Calendar.MINUTES))</li>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 15</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 435 (7*60 + 15)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0 (a millisecond cannot be split in minutes)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param calendar the calendar to work with, not null\n+     * @param fragment the Calendar field part of calendar to calculate \n+     * @return number of minutes within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInMinutes(Calendar calendar, int fragment) {\n+        return getFragment(calendar, fragment, Calendar.MINUTE);\n+    }\n+    \n+    /**\n+     * <p>Returns the number of hours within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the hours of any date will only return the number of hours\n+     * of the current day (resulting in a number between 0 and 23). This \n+     * method will retrieve the number of hours for any fragment. \n+     * For example, if you want to calculate the number of hours past this month, \n+     * your fragment is Calendar.MONTH. The result will be all hours of the \n+     * past day(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a HOUR field will return 0.</p> \n+     *  \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7 (equivalent to calendar.get(Calendar.HOUR_OF_DAY))</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7 (equivalent to calendar.get(Calendar.HOUR_OF_DAY))</li>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 7</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 127 (5*24 + 7)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0 (a millisecond cannot be split in hours)</li>\n+     * </ul>\n+     * </p>\n+     *  \n+     * @param calendar the calendar to work with, not null\n+     * @param fragment the Calendar field part of calendar to calculate \n+     * @return number of hours within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInHours(Calendar calendar, int fragment) {\n+        return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY);\n+    }\n+    \n+    /**\n+     * <p>Returns the number of days within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the days of any date will only return the number of days\n+     * of the current month (resulting in a number between 1 and 31). This \n+     * method will retrieve the number of days for any fragment. \n+     * For example, if you want to calculate the number of days past this year, \n+     * your fragment is Calendar.YEAR. The result will be all days of the \n+     * past month(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a DAY field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 28, 2008 with Calendar.MONTH as fragment will return 28 (equivalent to calendar.get(Calendar.DAY_OF_MONTH))</li>\n+     *  <li>February 28, 2008 with Calendar.MONTH as fragment will return 28 (equivalent to calendar.get(Calendar.DAY_OF_MONTH))</li>\n+     *  <li>January 28, 2008 with Calendar.YEAR as fragment will return 28 (equivalent to calendar.get(Calendar.DAY_OF_YEAR))</li>\n+     *  <li>February 28, 2008 with Calendar.YEAR as fragment will return 59 (equivalent to calendar.get(Calendar.DAY_OF_YEAR))</li>\n+     *  <li>January 28, 2008 with Calendar.MILLISECOND as fragment will return 0 (a millisecond cannot be split in days)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param calendar the calendar to work with, not null\n+     * @param fragment the Calendar field part of calendar to calculate \n+     * @return number of days within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInDays(Calendar calendar, int fragment) {\n+        return getFragment(calendar, fragment, Calendar.DAY_OF_YEAR);\n+    }\n+    \n+    /**\n+     * Date-version for fragment-calculation in any unit\n+     * \n+     * @param date the date to work with, not null\n+     * @param fragment the Calendar field part of date to calculate \n+     * @param unit Calendar field defining the unit\n+     * @return number of units within the fragment of the date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    private static long getFragment(Date date, int fragment, int unit) {\n+        if(date == null) {\n+            throw  new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar calendar = Calendar.getInstance();\n+        calendar.setTime(date);\n+        return getFragment(calendar, fragment, unit);\n+    }\n+\n+    /**\n+     * Calendar-version for fragment-calculation in any unit\n+     * \n+     * @param calendar the calendar to work with, not null\n+     * @param fragment the Calendar field part of calendar to calculate \n+     * @param unit Calendar field defining the unit\n+     * @return number of units within the fragment of the calendar\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    private static long getFragment(Calendar calendar, int fragment, int unit) {\n+        if(calendar == null) {\n+            throw  new IllegalArgumentException(\"The date must not be null\"); \n+        }\n+        long millisPerUnit = getMillisPerUnit(unit);\n+        long result = 0;\n+        \n+        // Fragments bigger than a day require a breakdown to days\n+        switch (fragment) {\n+            case Calendar.YEAR:\n+                result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;\n+                break;\n+            case Calendar.MONTH:\n+                result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;\n+                break;\n+        }\n+\n+        switch (fragment) {\n+            // Number of days already calculated for these cases\n+            case Calendar.YEAR:\n+            case Calendar.MONTH:\n+            \n+            // The rest of the valid cases\n+            case Calendar.DAY_OF_YEAR:\n+            case Calendar.DATE:\n+                result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;\n+            case Calendar.HOUR_OF_DAY:\n+                result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;\n+            case Calendar.MINUTE:\n+                result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;\n+            case Calendar.SECOND:\n+                result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;\n+                break;\n+            case Calendar.MILLISECOND: break;//never useful\n+                default: throw new IllegalArgumentException(\"The fragment \" + fragment + \" is not supported\");\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Returns the number of millis of a datefield, if this is a constant value\n+     * \n+     * @param unit A Calendar field which is a valid unit for a fragment\n+     * @return number of millis\n+     * @throws IllegalArgumentException if date can't be represented in millisenconds\n+     * @since 2.4 \n+     */\n+    private static long getMillisPerUnit(int unit) {\n+        long result = Long.MAX_VALUE;\n+        switch (unit) {\n+            case Calendar.DAY_OF_YEAR:\n+            case Calendar.DATE:\n+                result = MILLIS_PER_DAY;\n+                break;\n+            case Calendar.HOUR_OF_DAY:\n+                result = MILLIS_PER_HOUR;\n+                break;\n+            case Calendar.MINUTE:\n+                result = MILLIS_PER_MINUTE;\n+                break;\n+            case Calendar.SECOND:\n+                result = MILLIS_PER_SECOND;\n+                break;\n+            case Calendar.MILLISECOND:\n+                result = 1;\n+                break;\n+            default: throw new IllegalArgumentException(\"The unit \" + unit + \" cannot be represented is milleseconds\");\n+        }\n+        return result;\n+    }\n \n     /**\n      * <p>Date iterator.</p>\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/time/DateUtilsFragmentTest.java\n+package org.apache.commons.lang.time;\n+\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+import junit.framework.TestCase;\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.commons.lang.time.DateFormatUtils;\n+\n+public class DateUtilsFragmentTest extends TestCase {\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(DateUtilsFragmentTest.class);\n+        suite.setName(\"DateUtils Fragment Tests\");\n+        return suite;\n+    }\n+\n+\tprivate static final int months = 7;   // second final prime before 12\n+\tprivate static final int days = 23;    // second final prime before 31 (and valid)\n+\tprivate static final int hours = 19;   // second final prime before 24\n+\tprivate static final int minutes = 53; // second final prime before 60\n+\tprivate static final int seconds = 47; // third final prime before 60\n+\tprivate static final int millis = 991; // second final prime before 1000\n+\n+\tprivate Date aDate;\n+\tprivate Calendar aCalendar;\n+\n+\tprotected void setUp() {\n+\t\taCalendar = Calendar.getInstance();\n+\t\taCalendar.set(2005, months, days, hours, minutes, seconds);\n+\t\taCalendar.set(Calendar.MILLISECOND, millis);\n+\t\taDate = aCalendar.getTime();\n+\t}\n+\t\n+\tpublic void testNullDate() {\n+\t\ttry {\n+\t\t\tDateUtils.getFragmentInMilliseconds((Date) null, Calendar.MILLISECOND);\n+\t\t\tfail();\n+\t\t} catch(IllegalArgumentException iae) {}\n+\n+\t\ttry {\n+\t\t\tDateUtils.getFragmentInSeconds((Date) null, Calendar.MILLISECOND);\n+\t\t\tfail();\n+\t\t} catch(IllegalArgumentException iae) {}\n+\n+\t\ttry {\n+\t\t\tDateUtils.getFragmentInMinutes((Date) null, Calendar.MILLISECOND);\n+\t\t\tfail();\n+\t\t} catch(IllegalArgumentException iae) {}\n+\n+\t\ttry {\n+\t\t\tDateUtils.getFragmentInHours((Date) null, Calendar.MILLISECOND);\n+\t\t\tfail();\n+\t\t} catch(IllegalArgumentException iae) {}\n+\n+\t\ttry {\n+\t\t\tDateUtils.getFragmentInDays((Date) null, Calendar.MILLISECOND);\n+\t\t\tfail();\n+\t\t} catch(IllegalArgumentException iae) {}\n+\t}\n+\n+\tpublic void testNullCalendar() {\n+\t\ttry {\n+\t\t\tDateUtils.getFragmentInMilliseconds((Calendar) null, Calendar.MILLISECOND);\n+\t\t\tfail();\n+\t\t} catch(IllegalArgumentException iae) {}\n+\n+\t\ttry {\n+\t\t\tDateUtils.getFragmentInSeconds((Calendar) null, Calendar.MILLISECOND);\n+\t\t\tfail();\n+\t\t} catch(IllegalArgumentException iae) {}\n+\n+\t\ttry {\n+\t\t\tDateUtils.getFragmentInMinutes((Calendar) null, Calendar.MILLISECOND);\n+\t\t\tfail();\n+\t\t} catch(IllegalArgumentException iae) {}\n+\n+\t\ttry {\n+\t\t\tDateUtils.getFragmentInHours((Calendar) null, Calendar.MILLISECOND);\n+\t\t\tfail();\n+\t\t} catch(IllegalArgumentException iae) {}\n+\n+\t\ttry {\n+\t\t\tDateUtils.getFragmentInDays((Calendar) null, Calendar.MILLISECOND);\n+\t\t\tfail();\n+\t\t} catch(IllegalArgumentException iae) {}\n+\t}\n+\t\n+\tpublic void testInvalidFragmentWithDate() {\n+\t\ttry {\n+\t\t\tDateUtils.getFragmentInMilliseconds(aDate, 0);\n+\t\t\tfail();\n+\t\t} catch(IllegalArgumentException iae) {}\n+\n+\t\ttry {\n+\t\t\tDateUtils.getFragmentInSeconds(aDate, 0);\n+\t\t\tfail();\n+\t\t} catch(IllegalArgumentException iae) {}\n+\n+\t\ttry {\n+\t\t\tDateUtils.getFragmentInMinutes(aDate, 0);\n+\t\t\tfail();\n+\t\t} catch(IllegalArgumentException iae) {}\n+\n+\t\ttry {\n+\t\t\tDateUtils.getFragmentInHours(aDate, 0);\n+\t\t\tfail();\n+\t\t} catch(IllegalArgumentException iae) {}\n+\n+\t\ttry {\n+\t\t\tDateUtils.getFragmentInDays(aDate, 0);\n+\t\t\tfail();\n+\t\t} catch(IllegalArgumentException iae) {}\n+\t}\n+\n+\tpublic void testInvalidFragmentWithCalendar() {\n+\t\ttry {\n+\t\t\tDateUtils.getFragmentInMilliseconds(aCalendar, 0);\n+\t\t\tfail();\n+\t\t} catch(IllegalArgumentException iae) {}\n+\n+\t\ttry {\n+\t\t\tDateUtils.getFragmentInSeconds(aCalendar, 0);\n+\t\t\tfail();\n+\t\t} catch(IllegalArgumentException iae) {}\n+\n+\t\ttry {\n+\t\t\tDateUtils.getFragmentInMinutes(aCalendar, 0);\n+\t\t\tfail();\n+\t\t} catch(IllegalArgumentException iae) {}\n+\n+\t\ttry {\n+\t\t\tDateUtils.getFragmentInHours(aCalendar, 0);\n+\t\t\tfail();\n+\t\t} catch(IllegalArgumentException iae) {}\n+\n+\t\ttry {\n+\t\t\tDateUtils.getFragmentInDays(aCalendar, 0);\n+\t\t\tfail();\n+\t\t} catch(IllegalArgumentException iae) {}\n+\t}\n+\n+\tpublic void testMillisecondFragmentInLargerUnitWithDate() {\n+\t\tassertEquals(0, DateUtils.getFragmentInMilliseconds(aDate, Calendar.MILLISECOND));\n+\t\tassertEquals(0, DateUtils.getFragmentInSeconds(aDate, Calendar.MILLISECOND));\n+\t\tassertEquals(0, DateUtils.getFragmentInMinutes(aDate, Calendar.MILLISECOND));\n+\t\tassertEquals(0, DateUtils.getFragmentInHours(aDate, Calendar.MILLISECOND));\n+\t\tassertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.MILLISECOND));\n+\t}\n+\n+\tpublic void testMillisecondFragmentInLargerUnitWithCalendar() {\n+\t\tassertEquals(0, DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.MILLISECOND));\n+\t\tassertEquals(0, DateUtils.getFragmentInSeconds(aCalendar, Calendar.MILLISECOND));\n+\t\tassertEquals(0, DateUtils.getFragmentInMinutes(aCalendar, Calendar.MILLISECOND));\n+\t\tassertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.MILLISECOND));\n+\t\tassertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.MILLISECOND));\n+\t}\n+\t\n+\tpublic void testSecondFragmentInLargerUnitWithDate() {\n+\t\tassertEquals(0, DateUtils.getFragmentInSeconds(aDate, Calendar.SECOND));\n+\t\tassertEquals(0, DateUtils.getFragmentInMinutes(aDate, Calendar.SECOND));\n+\t\tassertEquals(0, DateUtils.getFragmentInHours(aDate, Calendar.SECOND));\n+\t\tassertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.SECOND));\n+\t}\n+\n+\tpublic void testSecondFragmentInLargerUnitWithCalendar() {\n+\t\tassertEquals(0, DateUtils.getFragmentInSeconds(aCalendar, Calendar.SECOND));\n+\t\tassertEquals(0, DateUtils.getFragmentInMinutes(aCalendar, Calendar.SECOND));\n+\t\tassertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.SECOND));\n+\t\tassertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.SECOND));\n+\t}\n+\t\n+\tpublic void testMinuteFragmentInLargerUnitWithDate() {\n+\t\tassertEquals(0, DateUtils.getFragmentInMinutes(aDate, Calendar.MINUTE));\n+\t\tassertEquals(0, DateUtils.getFragmentInHours(aDate, Calendar.MINUTE));\n+\t\tassertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.MINUTE));\n+\t}\n+\n+\tpublic void testMinuteFragmentInLargerUnitWithCalendar() {\n+\t\tassertEquals(0, DateUtils.getFragmentInMinutes(aCalendar, Calendar.MINUTE));\n+\t\tassertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.MINUTE));\n+\t\tassertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.MINUTE));\n+\t}\n+\n+\tpublic void testHourOfDayFragmentInLargerUnitWithDate() {\n+\t\tassertEquals(0, DateUtils.getFragmentInHours(aDate, Calendar.HOUR_OF_DAY));\n+\t\tassertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.HOUR_OF_DAY));\n+\t}\n+\n+\tpublic void testHourOfDayFragmentInLargerUnitWithCalendar() {\n+\t\tassertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.HOUR_OF_DAY));\n+\t\tassertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.HOUR_OF_DAY));\n+\t}\n+\n+\tpublic void testDayOfYearFragmentInLargerUnitWithDate() {\n+\t\tassertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.DAY_OF_YEAR));\n+\t}\n+\n+\tpublic void testDayOfYearFragmentInLargerUnitWithCalendar() {\n+\t\tassertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.DAY_OF_YEAR));\n+\t}\n+\n+\tpublic void testDateFragmentInLargerUnitWithDate() {\n+\t\tassertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.DATE));\n+\t}\n+\n+\tpublic void testDateFragmentInLargerUnitWithCalendar() {\n+\t\tassertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.DATE));\n+\t}\n+\n+\t//Calendar.SECOND as useful fragment\n+\t\n+\tpublic void testMillisecondsOfSecondWithDate() {\n+\t\tlong testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.SECOND);\n+\t\tassertEquals(millis, testResult);\n+\t}\n+\n+\tpublic void testMillisecondsOfSecondWithCalendar() {\n+\t\tlong testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.SECOND);\n+\t\tassertEquals(millis, testResult);\n+\t\tassertEquals(aCalendar.get(Calendar.MILLISECOND), testResult);\n+\t}\n+\n+\t//Calendar.MINUTE as useful fragment\n+\n+\tpublic void testMillisecondsOfMinuteWithDate() {\n+\t\tlong testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.MINUTE);\n+\t\tassertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND), testResult);\n+\t}\n+\n+\tpublic void testMillisecondsOfMinuteWithCalender() {\n+\t\tlong testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.MINUTE);\n+\t\tassertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND), testResult);\n+\t}\n+\n+\tpublic void testSecondsofMinuteWithDate() {\n+\t\tlong testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.MINUTE);\n+\t\tassertEquals(seconds, testResult);\n+\t}\n+\n+\tpublic void testSecondsofMinuteWithCalendar() {\n+\t\tlong testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.MINUTE);\n+\t\tassertEquals(seconds, testResult);\n+\t\tassertEquals(aCalendar.get(Calendar.SECOND), testResult);\n+\t}\n+\n+\t//Calendar.HOUR_OF_DAY as useful fragment\n+\t\n+\tpublic void testMillisecondsOfHourWithDate() {\n+\t\tlong testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.HOUR_OF_DAY);\n+\t\tassertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE), testResult);\n+\t}\n+\t\n+\tpublic void testMillisecondsOfHourWithCalendar() {\n+\t\tlong testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.HOUR_OF_DAY);\n+\t\tassertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE), testResult);\n+\t}\n+\n+\tpublic void testSecondsofHourWithDate() {\n+\t\tlong testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.HOUR_OF_DAY);\n+\t\tassertEquals(\n+\t\t\t\tseconds\n+\t\t\t\t\t\t+ (minutes\n+\t\t\t\t\t\t\t\t* DateUtils.MILLIS_PER_MINUTE / DateUtils.MILLIS_PER_SECOND),\n+\t\t\t\ttestResult);\n+\t}\n+\n+\tpublic void testSecondsofHourWithCalendar() {\n+\t\tlong testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.HOUR_OF_DAY);\n+\t\tassertEquals(\n+\t\t\t\tseconds\n+\t\t\t\t\t\t+ (minutes\n+\t\t\t\t\t\t\t\t* DateUtils.MILLIS_PER_MINUTE / DateUtils.MILLIS_PER_SECOND),\n+\t\t\t\ttestResult);\n+\t}\n+\n+\tpublic void testMinutesOfHourWithDate() {\n+\t\tlong testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.HOUR_OF_DAY);\n+\t\tassertEquals(minutes, testResult);\n+\t}\n+\n+\tpublic void testMinutesOfHourWithCalendar() {\n+\t\tlong testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.HOUR_OF_DAY);\n+\t\tassertEquals(minutes, testResult);\n+\t}\n+\n+\t//Calendar.DATE and Calendar.DAY_OF_YEAR as useful fragment\n+\tpublic void testMillisecondsOfDayWithDate() {\n+\t\tlong testresult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.DATE);\n+\t\tlong expectedValue = millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR); \n+\t\tassertEquals(expectedValue, testresult);\n+\t\ttestresult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.DAY_OF_YEAR);\n+\t\tassertEquals(expectedValue, testresult);\n+\t}\n+\t\n+\tpublic void testMillisecondsOfDayWithCalendar() {\n+\t\tlong testresult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.DATE);\n+\t\tlong expectedValue = millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR); \n+\t\tassertEquals(expectedValue, testresult);\n+\t\ttestresult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.DAY_OF_YEAR);\n+\t\tassertEquals(expectedValue, testresult);\n+\t}\n+\n+\tpublic void testSecondsOfDayWithDate() {\n+\t\tlong testresult = DateUtils.getFragmentInSeconds(aDate, Calendar.DATE);\n+\t\tlong expectedValue = seconds + ((minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_SECOND;\n+\t\tassertEquals(expectedValue, testresult);\n+\t\ttestresult = DateUtils.getFragmentInSeconds(aDate, Calendar.DAY_OF_YEAR);\n+\t\tassertEquals(expectedValue, testresult);\n+\t}\n+\n+\tpublic void testSecondsOfDayWithCalendar() {\n+\t\tlong testresult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.DATE);\n+\t\tlong expectedValue = seconds + ((minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_SECOND;\n+\t\tassertEquals(expectedValue, testresult);\n+\t\ttestresult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.DAY_OF_YEAR);\n+\t\tassertEquals(expectedValue, testresult);\n+\t}\n+\n+\tpublic void testMinutesOfDayWithDate() {\n+\t\tlong testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE);\n+\t\tlong expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE; \n+\t\tassertEquals(expectedValue,testResult);\n+\t\ttestResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR);\n+\t\tassertEquals(expectedValue,testResult);\n+\t}\n+\n+\tpublic void testMinutesOfDayWithCalendar() {\n+\t\tlong testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.DATE);\n+\t\tlong expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE; \n+\t\tassertEquals(expectedValue, testResult);\n+\t\ttestResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.DAY_OF_YEAR);\n+\t\tassertEquals(expectedValue, testResult);\n+\t}\n+\t\n+\tpublic void testHoursOfDayWithDate() {\n+\t\tlong testResult = DateUtils.getFragmentInHours(aDate, Calendar.DATE);\n+\t\tlong expectedValue = hours; \n+\t\tassertEquals(expectedValue,testResult);\n+\t\ttestResult = DateUtils.getFragmentInHours(aDate, Calendar.DAY_OF_YEAR);\n+\t\tassertEquals(expectedValue,testResult);\n+\t}\n+\n+\tpublic void testHoursOfDayWithCalendar() {\n+\t\tlong testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.DATE);\n+\t\tlong expectedValue = hours; \n+\t\tassertEquals(expectedValue, testResult);\n+\t\ttestResult = DateUtils.getFragmentInHours(aCalendar, Calendar.DAY_OF_YEAR);\n+\t\tassertEquals(expectedValue, testResult);\n+\t}\n+\t\n+\t\n+\t//Calendar.MONTH as useful fragment\n+\tpublic void testMillisecondsOfMonthWithDate() {\n+\t\tlong testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.MONTH);\n+\t\tassertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE)\n+\t\t\t\t\t\t\t\t+ (hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY),\n+\t\t\t\ttestResult);\n+\t}\n+\n+\tpublic void testMillisecondsOfMonthWithCalendar() {\n+\t\tlong testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.MONTH);\n+\t\tassertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE)\n+\t\t\t\t+ (hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY),\n+testResult);\n+\t}\n+\t\n+\tpublic void testSecondsOfMonthWithDate() {\n+\t\tlong testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.MONTH);\n+\t\tassertEquals(\n+\t\t\t\tseconds\n+\t\t\t\t\t\t+ ((minutes * DateUtils.MILLIS_PER_MINUTE)\n+\t\t\t\t\t\t\t\t+ (hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY))\n+\t\t\t\t\t\t/ DateUtils.MILLIS_PER_SECOND,\n+\t\t\t\ttestResult);\n+\t}\n+\n+\tpublic void testSecondsOfMonthWithCalendar() {\n+\t\tlong testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.MONTH);\n+\t\tassertEquals(\n+\t\t\t\tseconds\n+\t\t\t\t\t\t+ ((minutes * DateUtils.MILLIS_PER_MINUTE)\n+\t\t\t\t\t\t\t\t+ (hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY))\n+\t\t\t\t\t\t/ DateUtils.MILLIS_PER_SECOND,\n+\t\t\t\ttestResult);\n+\t}\n+\n+\tpublic void testMinutesOfMonthWithDate() {\n+\t\tlong testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.MONTH);\n+\t\tassertEquals(minutes\n+\t\t\t\t\t\t\t\t+ ((hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY))\n+\t\t\t\t\t\t/ DateUtils.MILLIS_PER_MINUTE,\n+\t\t\t\ttestResult);\n+\t}\n+\n+\tpublic void testMinutesOfMonthWithCalendar() {\n+\t\tlong testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.MONTH);\n+\t\tassertEquals( minutes  +((hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY))\n+\t\t\t\t\t\t/ DateUtils.MILLIS_PER_MINUTE,\n+\t\t\t\ttestResult);\n+\t}\n+\n+\tpublic void testHoursOfMonthWithDate() {\n+\t\tlong testResult = DateUtils.getFragmentInHours(aDate, Calendar.MONTH);\n+\t\tassertEquals(hours + ((days * DateUtils.MILLIS_PER_DAY))\n+\t\t\t\t\t\t/ DateUtils.MILLIS_PER_HOUR,\n+\t\t\t\ttestResult);\n+\t}\n+\n+\tpublic void testHoursOfMonthWithCalendar() {\n+\t\tlong testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.MONTH);\n+\t\tassertEquals( hours +((days * DateUtils.MILLIS_PER_DAY))\n+\t\t\t\t\t\t/ DateUtils.MILLIS_PER_HOUR,\n+\t\t\t\ttestResult);\n+\t}\n+\t\n+\t//Calendar.YEAR as useful fragment\n+\tpublic void testMillisecondsOfYearWithDate() {\n+\t\tlong testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.YEAR);\n+\t\tCalendar cal = Calendar.getInstance();\n+\t\tcal.setTime(aDate);\n+\t\tassertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE)\n+\t\t\t\t\t\t\t\t+ (hours * DateUtils.MILLIS_PER_HOUR) + (cal.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY),\n+\t\t\t\ttestResult);\n+\t}\n+\n+\tpublic void testMillisecondsOfYearWithCalendar() {\n+\t\tlong testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.YEAR);\n+\t\tassertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE)\n+\t\t\t\t+ (hours * DateUtils.MILLIS_PER_HOUR) + (aCalendar.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY),\n+testResult);\n+\t}\n+\t\n+\tpublic void testSecondsOfYearWithDate() {\n+\t\tlong testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.YEAR);\n+\t\tCalendar cal = Calendar.getInstance();\n+\t\tcal.setTime(aDate);\n+\t\tassertEquals(\n+\t\t\t\tseconds\n+\t\t\t\t\t\t+ ((minutes * DateUtils.MILLIS_PER_MINUTE)\n+\t\t\t\t\t\t\t\t+ (hours * DateUtils.MILLIS_PER_HOUR) + (cal.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY))\n+\t\t\t\t\t\t/ DateUtils.MILLIS_PER_SECOND,\n+\t\t\t\ttestResult);\n+\t}\n+\n+\tpublic void testSecondsOfYearWithCalendar() {\n+\t\tlong testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.YEAR);\n+\t\tassertEquals(\n+\t\t\t\tseconds\n+\t\t\t\t\t\t+ ((minutes * DateUtils.MILLIS_PER_MINUTE)\n+\t\t\t\t\t\t\t\t+ (hours * DateUtils.MILLIS_PER_HOUR) + (aCalendar.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY))\n+\t\t\t\t\t\t/ DateUtils.MILLIS_PER_SECOND,\n+\t\t\t\ttestResult);\n+\t}\n+\n+\tpublic void testMinutesOfYearWithDate() {\n+\t\tlong testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.YEAR);\n+\t\tCalendar cal = Calendar.getInstance();\n+\t\tcal.setTime(aDate);\n+\t\tassertEquals(minutes\n+\t\t\t\t\t\t\t\t+ ((hours * DateUtils.MILLIS_PER_HOUR) + (cal.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY))\n+\t\t\t\t\t\t/ DateUtils.MILLIS_PER_MINUTE,\n+\t\t\t\ttestResult);\n+\t}\n+\n+\tpublic void testMinutesOfYearWithCalendar() {\n+\t\tlong testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.YEAR);\n+\t\tassertEquals( minutes  +((hours * DateUtils.MILLIS_PER_HOUR) + (aCalendar.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY))\n+\t\t\t\t\t\t/ DateUtils.MILLIS_PER_MINUTE,\n+\t\t\t\ttestResult);\n+\t}\n+\n+\tpublic void testHoursOfYearWithDate() {\n+\t\tlong testResult = DateUtils.getFragmentInHours(aDate, Calendar.YEAR);\n+\t\tCalendar cal = Calendar.getInstance();\n+\t\tcal.setTime(aDate);\n+\t\tassertEquals(hours + ((cal.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY))\n+\t\t\t\t\t\t/ DateUtils.MILLIS_PER_HOUR,\n+\t\t\t\ttestResult);\n+\t}\n+\n+\tpublic void testHoursOfYearWithCalendar() {\n+\t\tlong testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.YEAR);\n+\t\tassertEquals( hours +((aCalendar.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY))\n+\t\t\t\t\t\t/ DateUtils.MILLIS_PER_HOUR,\n+\t\t\t\ttestResult);\n+\t}\n+}\n--- a/src/test/org/apache/commons/lang/time/TimeTestSuite.java\n+++ b/src/test/org/apache/commons/lang/time/TimeTestSuite.java\n         suite.addTest(DurationFormatUtilsTest.suite());\n         suite.addTest(StopWatchTest.suite());\n         suite.addTest(FastDateFormatTest.suite());\n+        suite.addTest(DateUtilsFragmentTest.suite());\n         return suite;\n     }\n }", "timestamp": 1201849976, "metainfo": ""}