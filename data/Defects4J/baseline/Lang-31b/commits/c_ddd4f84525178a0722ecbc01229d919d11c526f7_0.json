{"sha": "ddd4f84525178a0722ecbc01229d919d11c526f7", "log": "Test LocaleUtils  ", "commit": "\n--- a/src/java/org/apache/commons/lang/LocaleUtils.java\n+++ b/src/java/org/apache/commons/lang/LocaleUtils.java\n package org.apache.commons.lang;\n \n import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Locale;\n+import java.util.Map;\n import java.util.Set;\n \n /**\n  */\n public class LocaleUtils {\n \n+    /** Unmodifiable list of available locales. */\n+    private static final List cAvailableLocaleList;\n+    /** Unmodifiable set of available locales. */\n+    private static Set cAvailableLocaleSet;\n+    /** Unmodifiable map of language locales by country. */\n+    private static final Map cLanguagesByCountry = Collections.synchronizedMap(new HashMap());\n+    /** Unmodifiable map of country locales by language. */\n+    private static final Map cCountriesByLanguage = Collections.synchronizedMap(new HashMap());\n+    static {\n+        List list = Arrays.asList(Locale.getAvailableLocales());\n+        cAvailableLocaleList = Collections.unmodifiableList(list);\n+    }\n+\n     /**\n      * <p><code>LocaleUtils</code> instances should NOT be constructed in standard programming.\n      * Instead, the class should be used as <code>LocaleUtils.toLocale(\"en_GB\");</code>.</p>\n      *   LocaleUtils.toLocale(\"en_GB\")  = new Locale(\"en\", \"GB\")\n      *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")\n      * </pre>\n+     * \n+     * <p>This method validates the input strictly.\n+     * The language code must be lowercase.\n+     * The country code must be uppercase.\n+     * The separator must be an underscore.\n+     * The length must be correct.\n+     * </p>\n      *\n      * @param str  the locale String to convert, null returns null\n-     * @return a Locale\n+     * @return a Locale, null if null input\n      * @throws IllegalArgumentException if the string is an invalid format\n      */\n     public static Locale toLocale(String str) {\n         if (str == null) {\n             return null;\n         }\n-        if (str.length() != 2 &&\n-            str.length() != 5 &&\n-            str.length() < 7) {\n+        int len = str.length();\n+        if (len != 2 && len != 5 && len < 7) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n-        if (Character.isLowerCase(str.charAt(0)) == false ||\n-            Character.isLowerCase(str.charAt(1)) == false) {\n+        char ch0 = str.charAt(0);\n+        char ch1 = str.charAt(1);\n+        if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n-        if (str.length() == 2) {\n+        if (len == 2) {\n             return new Locale(str, \"\");\n         } else {\n-            if (Character.isUpperCase(str.charAt(3)) == false ||\n-                Character.isUpperCase(str.charAt(4)) == false) {\n+            if (str.charAt(2) != '_') {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n             }\n-            if (str.length() == 5) {\n+            char ch3 = str.charAt(3);\n+            char ch4 = str.charAt(4);\n+            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+            }\n+            if (len == 5) {\n                 return new Locale(str.substring(0, 2), str.substring(3, 5));\n             } else {\n+                if (str.charAt(5) != '_') {\n+                    throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+                }\n                 return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n             }\n         }\n      * </pre>\n      *\n      * @param locale  the locale to start from\n-     * @return the list of Locale objects, 0 being locale\n+     * @return the unmodifiable list of Locale objects, 0 being locale, never null\n      */\n     public static List localeLookupList(Locale locale) {\n         return localeLookupList(locale, locale);\n      *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\"]\n      * </pre>\n      *\n-     * <p>This method takes a country code and searches to find the\n-     * languages available for that country. Variant locales are removed.</p>\n+     * <p>The result list begins with the most specific locale, then the\n+     * next more general and so on, finishing with the default locale.\n+     * The list will never contain the same locale twice.</p>\n      *\n      * @param locale  the locale to start from, null returns empty list\n      * @param defaultLocale  the default locale to use if no other is found\n-     * @return the list of Locale objects, 0 being locale\n+     * @return the unmodifiable list of Locale objects, 0 being locale, never null\n      */\n     public static List localeLookupList(Locale locale, Locale defaultLocale) {\n         List list = new ArrayList(4);\n                 list.add(defaultLocale);\n             }\n         }\n-        return list;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * <p>Obtains the set of languages supported for a given country.</p>\n-     \n+        return Collections.unmodifiableList(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains an unmodifiable list of installed locales.</p>\n+     * \n+     * <p>This method is a wrapper around {@link Locale#getAvailableLocales()}.\n+     * It is more efficient, as the JDK method must create a new array each\n+     * time it is called.</p>\n+     *\n+     * @return the unmodifiable list of available locales\n+     */\n+    public static List availableLocaleList() {\n+        return cAvailableLocaleList;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains an unmodifiable set of installed locales.</p>\n+     * \n+     * <p>This method is a wrapper around {@link Locale#getAvailableLocales()}.\n+     * It is more efficient, as the JDK method must create a new array each\n+     * time it is called.</p>\n+     *\n+     * @return the unmodifiable set of available locales\n+     */\n+    public static Set availableLocaleSet() {\n+        Set set = cAvailableLocaleSet;\n+        if (set == null) {\n+            set = new HashSet(availableLocaleList());\n+            set = Collections.unmodifiableSet(set);\n+            cAvailableLocaleSet = set;\n+        }\n+        return set;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if the locale specified is in the list of available locales.</p>\n+     *\n+     * @return true if the locale is a known locale\n+     */\n+    public static boolean isAvailableLocale(Locale locale) {\n+        return cAvailableLocaleSet.contains(locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains the list of languages supported for a given country.</p>\n+     *\n      * <p>This method takes a country code and searches to find the\n      * languages available for that country. Variant locales are removed.</p>\n      *\n      * @param countryCode  the 2 letter country code, null returns empty\n-     * @return a Set of Locale objects\n-     */\n-    public static Set languagesByCountry(String countryCode) {\n-        Set set = new HashSet();\n-        Locale[] array = Locale.getAvailableLocales();\n-        if (countryCode != null) {\n-            for (int i = 0; i < array.length; i++) {\n-                if (countryCode.equals(array[i].getCountry()) &&\n-                        array[i].getVariant().length() == 0) {\n-                    set.add(array[i]);\n+     * @return an unmodifiable List of Locale objects, never null\n+     */\n+    public static List languagesByCountry(String countryCode) {\n+        List langs = (List) cLanguagesByCountry.get(countryCode);\n+        if (langs == null) {\n+            if (countryCode != null) {\n+                langs = new ArrayList();\n+                List locales = availableLocaleList();\n+                for (int i = 0; i < locales.size(); i++) {\n+                    Locale locale = (Locale) locales.get(i);\n+                    if (countryCode.equals(locale.getCountry()) &&\n+                            locale.getVariant().length() == 0) {\n+                        langs.add(locale);\n+                    }\n                 }\n-            }\n-        }\n-        return set;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * <p>Obtains the set of countries supported for a given language.</p>\n+                langs = Collections.unmodifiableList(langs);\n+            } else {\n+                langs = Collections.EMPTY_LIST;\n+            }\n+            cLanguagesByCountry.put(countryCode, langs);\n+        }\n+        return langs;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains the list of countries supported for a given language.</p>\n      * \n      * <p>This method takes a language code and searches to find the\n      * countries available for that language. Variant locales are removed.</p>\n      *\n      * @param languageCode  the 2 letter language code, null returns empty\n-     * @return a Set of Locale objects\n-     */\n-    public static Set countriesByLanguage(String languageCode) {\n-        Set set = new HashSet();\n-        Locale[] array = Locale.getAvailableLocales();\n-        if (languageCode != null) {\n-            for (int i = 0; i < array.length; i++) {\n-                if (languageCode.equals(array[i].getLanguage()) &&\n-                        array[i].getVariant().length() == 0) {\n-                    set.add(array[i]);\n+     * @return an unmodifiable List of Locale objects, never null\n+     */\n+    public static List countriesByLanguage(String languageCode) {\n+        List countries = (List) cCountriesByLanguage.get(languageCode);\n+        if (countries == null) {\n+            if (languageCode != null) {\n+                countries = new ArrayList();\n+                List locales = availableLocaleList();\n+                for (int i = 0; i < locales.size(); i++) {\n+                    Locale locale = (Locale) locales.get(i);\n+                    if (languageCode.equals(locale.getLanguage()) &&\n+                            locale.getCountry().length() != 0 &&\n+                            locale.getVariant().length() == 0) {\n+                        countries.add(locale);\n+                    }\n                 }\n-            }\n-        }\n-        return set;\n+                countries = Collections.unmodifiableList(countries);\n+            } else {\n+                countries = Collections.EMPTY_LIST;\n+            }\n+            cCountriesByLanguage.put(languageCode, countries);\n+        }\n+        return countries;\n     }\n \n }\n--- a/src/test/org/apache/commons/lang/LangTestSuite.java\n+++ b/src/test/org/apache/commons/lang/LangTestSuite.java\n         suite.addTest(IllegalClassExceptionTest.suite());\n         suite.addTest(IncompleteArgumentExceptionTest.suite());\n         suite.addTest(IntHashMapTest.suite());\n+        suite.addTest(LocaleUtilsTest.suite());\n         suite.addTest(NotImplementedExceptionTest.suite());\n         suite.addTest(NullArgumentExceptionTest.suite());\n         suite.addTest(NumberRangeTest.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/LocaleUtilsTest.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests for {@link LocaleUtils}.\n+ *\n+ * @author Chris Hyzer\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public class LocaleUtilsTest extends TestCase {\n+\n+    private static final Locale LOCALE_EN = new Locale(\"en\", \"\");\n+    private static final Locale LOCALE_EN_US = new Locale(\"en\", \"US\");\n+    private static final Locale LOCALE_EN_US_ZZZZ = new Locale(\"en\", \"US\", \"ZZZZ\");\n+    private static final Locale LOCALE_FR = new Locale(\"fr\", \"\");\n+    private static final Locale LOCALE_FR_CA = new Locale(\"fr\", \"CA\");\n+    private static final Locale LOCALE_QQ = new Locale(\"qq\", \"\");\n+    private static final Locale LOCALE_QQ_ZZ = new Locale(\"qq\", \"ZZ\");\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param name\n+     */\n+    public LocaleUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Main.\n+     * @param args\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Run the test cases as a suite.\n+     * @return the Test\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(LocaleUtilsTest.class);\n+        suite.setName(\"LocaleUtilsTest Tests\");\n+        return suite;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test that constructors are public, and work, etc.\n+     */\n+    public void testConstructor() {\n+        assertNotNull(new LocaleUtils());\n+        Constructor[] cons = LocaleUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(LocaleUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(LocaleUtils.class.getModifiers()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Pass in a valid language, test toLocale.\n+     *\n+     * @param language  the language string\n+     */\n+    private void assertValidToLocale(String language) {\n+        Locale locale = LocaleUtils.toLocale(language);\n+        assertNotNull(\"valid locale\", locale);\n+        assertEquals(language, locale.getLanguage());\n+        //country and variant are empty\n+        assertTrue(locale.getCountry() == null || locale.getCountry().length() == 0);\n+        assertTrue(locale.getVariant() == null || locale.getVariant().length() == 0);\n+    }\n+\n+    /**\n+     * Pass in a valid language, test toLocale.\n+     *\n+     * @param localeString to pass to toLocale()\n+     * @param language of the resulting Locale\n+     * @param country of the resulting Locale\n+     */\n+    private void assertValidToLocale(String localeString, String language, String country) {\n+        Locale locale = LocaleUtils.toLocale(localeString);\n+        assertNotNull(\"valid locale\", locale);\n+        assertEquals(language, locale.getLanguage());\n+        assertEquals(country, locale.getCountry());\n+        //variant is empty\n+        assertTrue(locale.getVariant() == null || locale.getVariant().length() == 0);\n+    }\n+\n+    /**\n+     * Pass in a valid language, test toLocale.\n+     *\n+     * @param localeString to pass to toLocale()\n+     * @param language of the resulting Locale\n+     * @param country of the resulting Locale\n+     * @param variant of the resulting Locale\n+     */\n+    private void assertValidToLocale(\n+            String localeString, String language, \n+            String country, String variant) {\n+        Locale locale = LocaleUtils.toLocale(localeString);\n+        assertNotNull(\"valid locale\", locale);\n+        assertEquals(language, locale.getLanguage());\n+        assertEquals(country, locale.getCountry());\n+        assertEquals(variant, locale.getVariant());\n+        \n+    }\n+\n+    /**\n+     * Test toLocale() method.\n+     */\n+    public void testToLocale_1Part() {\n+        assertEquals(null, LocaleUtils.toLocale((String) null));\n+        \n+        assertValidToLocale(\"us\");\n+        assertValidToLocale(\"fr\");\n+        assertValidToLocale(\"de\");\n+        assertValidToLocale(\"zh\");\n+        // Valid format but lang doesnt exist, should make instance anyway\n+        assertValidToLocale(\"qq\");\n+        \n+        try {\n+            LocaleUtils.toLocale(\"Us\");\n+            fail(\"Should fail if not lowercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"US\");\n+            fail(\"Should fail if not lowercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"uS\");\n+            fail(\"Should fail if not lowercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"u#\");\n+            fail(\"Should fail if not lowercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        \n+        try {\n+            LocaleUtils.toLocale(\"u\");\n+            fail(\"Must be 2 chars if less than 5\");\n+        } catch (IllegalArgumentException iae) {}\n+       \n+        try {\n+            LocaleUtils.toLocale(\"uuu\");\n+            fail(\"Must be 2 chars if less than 5\");\n+        } catch (IllegalArgumentException iae) {}\n+\n+        try {\n+            LocaleUtils.toLocale(\"uu_U\");\n+            fail(\"Must be 2 chars if less than 5\");\n+        } catch (IllegalArgumentException iae) {}\n+    }        \n+\n+    /**\n+     * Test toLocale() method.\n+     */\n+    public void testToLocale_2Part() {\n+        assertValidToLocale(\"us_EN\", \"us\", \"EN\");\n+        //valid though doesnt exist\n+        assertValidToLocale(\"us_ZH\", \"us\", \"ZH\");\n+        \n+        try {\n+            LocaleUtils.toLocale(\"us-EN\");\n+            fail(\"Should fail as not underscore\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"us_En\");\n+            fail(\"Should fail second part not uppercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"us_en\");\n+            fail(\"Should fail second part not uppercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"us_eN\");\n+            fail(\"Should fail second part not uppercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"uS_EN\");\n+            fail(\"Should fail first part not lowercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"us_E3\");\n+            fail(\"Should fail second part not uppercase\");\n+        } catch (IllegalArgumentException iae) {}\n+    }        \n+\n+    /**\n+     * Test toLocale() method.\n+     */\n+    public void testToLocale_3Part() {\n+        assertValidToLocale(\"us_EN_a\", \"us\", \"EN\", \"a\");\n+        assertValidToLocale(\"us_EN_A\", \"us\", \"EN\", \"A\");\n+        assertValidToLocale(\"us_EN_SFsafdFDsdfF\", \"us\", \"EN\", \"SFsafdFDsdfF\");\n+        \n+        try {\n+            LocaleUtils.toLocale(\"us_EN-a\");\n+            fail(\"Should fail as not underscore\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"uu_UU_\");\n+            fail(\"Must be 3, 5 or 7+ in length\");\n+        } catch (IllegalArgumentException iae) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Helper method for local lookups.\n+     *\n+     * @param locale  the input locale\n+     * @param defaultLocale  the input default locale\n+     * @param expected  expected results\n+     */\n+    private void assertLocaleLookupList(Locale locale, Locale defaultLocale, Locale[] expected) {\n+        List localeList = defaultLocale == null ?\n+                LocaleUtils.localeLookupList(locale) :\n+                LocaleUtils.localeLookupList(locale, defaultLocale);\n+        \n+        assertEquals(expected.length, localeList.size());\n+        assertEquals(Arrays.asList(expected), localeList);\n+        try {\n+            localeList.add(\"Unmodifiable\");\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test localeLookupList() method.\n+     */\n+    public void testLocaleLookupList_Locale() {\n+        assertLocaleLookupList(null, null, new Locale[0]);\n+        assertLocaleLookupList(LOCALE_QQ, null, new Locale[]{LOCALE_QQ});\n+        assertLocaleLookupList(LOCALE_EN, null, new Locale[]{LOCALE_EN});\n+        assertLocaleLookupList(LOCALE_EN, null, new Locale[]{LOCALE_EN});\n+        assertLocaleLookupList(LOCALE_EN_US, null,\n+            new Locale[] {\n+                LOCALE_EN_US,\n+                LOCALE_EN});\n+        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, null,\n+            new Locale[] {\n+                LOCALE_EN_US_ZZZZ,\n+                LOCALE_EN_US,\n+                new Locale(\"en\")});\n+    }        \n+\n+    /**\n+     * Test localeLookupList() method.\n+     */\n+    public void testLocaleLookupList_LocaleLocale() {\n+        assertLocaleLookupList(LOCALE_QQ, LOCALE_QQ, \n+                new Locale[]{LOCALE_QQ});\n+        assertLocaleLookupList(LOCALE_EN, LOCALE_EN, \n+                new Locale[]{LOCALE_EN});\n+        \n+        assertLocaleLookupList(LOCALE_EN_US, LOCALE_EN_US, \n+            new Locale[]{\n+                LOCALE_EN_US,\n+                LOCALE_EN});\n+        assertLocaleLookupList(LOCALE_EN_US, LOCALE_QQ,\n+            new Locale[] {\n+                LOCALE_EN_US,\n+                LOCALE_EN,\n+                LOCALE_QQ});\n+        assertLocaleLookupList(LOCALE_EN_US, LOCALE_QQ_ZZ,\n+            new Locale[] {\n+                LOCALE_EN_US,\n+                LOCALE_EN,\n+                LOCALE_QQ_ZZ});\n+        \n+        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, null,\n+            new Locale[] {\n+                LOCALE_EN_US_ZZZZ,\n+                LOCALE_EN_US,\n+                LOCALE_EN});\n+        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_EN_US_ZZZZ,\n+            new Locale[] {\n+                LOCALE_EN_US_ZZZZ,\n+                LOCALE_EN_US,\n+                LOCALE_EN});\n+        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_QQ,\n+            new Locale[] {\n+                LOCALE_EN_US_ZZZZ,\n+                LOCALE_EN_US,\n+                LOCALE_EN,\n+                LOCALE_QQ});\n+        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_QQ_ZZ,\n+            new Locale[] {\n+                LOCALE_EN_US_ZZZZ,\n+                LOCALE_EN_US,\n+                LOCALE_EN,\n+                LOCALE_QQ_ZZ});\n+        assertLocaleLookupList(LOCALE_FR_CA, LOCALE_EN,\n+            new Locale[] {\n+                LOCALE_FR_CA,\n+                LOCALE_FR,\n+                LOCALE_EN});\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test availableLocaleList() method.\n+     */\n+    public void testAvailableLocaleList() {\n+        List list = LocaleUtils.availableLocaleList();\n+        List list2 = LocaleUtils.availableLocaleList();\n+        assertNotNull(list);\n+        assertSame(list, list2);\n+        Locale[] jdkLocaleArray = Locale.getAvailableLocales();\n+        List jdkLocaleList = Arrays.asList(jdkLocaleArray);\n+        assertEquals(jdkLocaleList, list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test availableLocaleSet() method.\n+     */\n+    public void testAvailableLocaleSet() {\n+        Set set = LocaleUtils.availableLocaleSet();\n+        Set set2 = LocaleUtils.availableLocaleSet();\n+        assertNotNull(set);\n+        assertSame(set, set2);\n+        Locale[] jdkLocaleArray = Locale.getAvailableLocales();\n+        List jdkLocaleList = Arrays.asList(jdkLocaleArray);\n+        Set jdkLocaleSet = new HashSet(jdkLocaleList);\n+        assertEquals(jdkLocaleSet, set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test availableLocaleSet() method.\n+     */\n+    public void testIsAvailableLocale() {\n+        Set set = LocaleUtils.availableLocaleSet();\n+        assertEquals(set.contains(LOCALE_EN), LocaleUtils.isAvailableLocale(LOCALE_EN));\n+        assertEquals(set.contains(LOCALE_EN_US), LocaleUtils.isAvailableLocale(LOCALE_EN_US));\n+        assertEquals(set.contains(LOCALE_EN_US_ZZZZ), LocaleUtils.isAvailableLocale(LOCALE_EN_US_ZZZZ));\n+        assertEquals(set.contains(LOCALE_FR), LocaleUtils.isAvailableLocale(LOCALE_FR));\n+        assertEquals(set.contains(LOCALE_FR_CA), LocaleUtils.isAvailableLocale(LOCALE_FR_CA));\n+        assertEquals(set.contains(LOCALE_QQ), LocaleUtils.isAvailableLocale(LOCALE_QQ));\n+        assertEquals(set.contains(LOCALE_QQ_ZZ), LocaleUtils.isAvailableLocale(LOCALE_QQ_ZZ));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Make sure the language by country is correct.\n+     *\n+     * @param country\n+     * @param languages array of languages that should be returned\n+     */\n+    private void assertLanguageByCountry(String country, String[] languages) {\n+        List list = LocaleUtils.languagesByCountry(country);\n+        List list2 = LocaleUtils.languagesByCountry(country);\n+        assertNotNull(list);\n+        assertSame(list, list2);\n+        assertEquals(languages.length, list.size());\n+        //search through langauges\n+        for (int i = 0; i < languages.length; i++) {\n+            Iterator iterator = list.iterator();\n+            boolean found = false;\n+            // see if it was returned by the set\n+            while (iterator.hasNext()) {\n+                Locale locale = (Locale) iterator.next();\n+                // should have an en empty variant\n+                assertTrue(locale.getVariant() == null\n+                        || locale.getVariant().length() == 0);\n+                assertEquals(country, locale.getCountry());\n+                if (languages[i].equals(locale.getLanguage())) {\n+                    found = true;\n+                    break;\n+                }\n+            }\n+            if (!found) {\n+                fail(\"Cound not find language: \" + languages[i]\n+                        + \" for country: \" + country);\n+            }\n+        }\n+        try {\n+            list.add(\"Unmodifiable\");\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+    }\n+\n+    /**\n+     * Test languagesByCountry() method.\n+     */\n+    public void testLanguagesByCountry() {\n+        assertLanguageByCountry(null, new String[0]);\n+        assertLanguageByCountry(\"US\", new String[]{\"en\"});\n+        assertLanguageByCountry(\"ZZ\", new String[0]);\n+        assertLanguageByCountry(\"CH\", new String[]{\"fr\", \"de\", \"it\"});\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Make sure the language by country is correct.\n+     *\n+     * @param language\n+     * @param countries array of countries that should be returned\n+     */\n+    private void assertCountriesByLanguage(String language, String[] countries) {\n+        List list = LocaleUtils.countriesByLanguage(language);\n+        List list2 = LocaleUtils.countriesByLanguage(language);\n+        assertNotNull(list);\n+        assertSame(list, list2);\n+        assertEquals(countries.length, list.size());\n+        //search through langauges\n+        for (int i = 0; i < countries.length; i++) {\n+            Iterator iterator = list.iterator();\n+            boolean found = false;\n+            // see if it was returned by the set\n+            while (iterator.hasNext()) {\n+                Locale locale = (Locale) iterator.next();\n+                // should have an en empty variant\n+                assertTrue(locale.getVariant() == null\n+                        || locale.getVariant().length() == 0);\n+                assertEquals(language, locale.getLanguage());\n+                if (countries[i].equals(locale.getCountry())) {\n+                    found = true;\n+                    break;\n+                }\n+            }\n+            if (!found) {\n+                fail(\"Cound not find language: \" + countries[i]\n+                        + \" for country: \" + language);\n+            }\n+        }\n+        try {\n+            list.add(\"Unmodifiable\");\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+    }\n+\n+    /**\n+     * Test languagesByCountry() method.\n+     */\n+    public void testCountriesByLanguage() {\n+        assertCountriesByLanguage(null, new String[0]);\n+        assertCountriesByLanguage(\"de\", new String[]{\"DE\", \"CH\", \"AT\", \"LU\"});\n+        assertCountriesByLanguage(\"zz\", new String[0]);\n+        assertCountriesByLanguage(\"it\", new String[]{\"IT\", \"CH\"});\n+    }\n+\n+}", "timestamp": 1127517451, "metainfo": ""}