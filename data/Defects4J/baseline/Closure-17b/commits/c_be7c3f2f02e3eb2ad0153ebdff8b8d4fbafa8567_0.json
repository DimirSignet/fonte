{"sha": "be7c3f2f02e3eb2ad0153ebdff8b8d4fbafa8567", "log": "Enhancement to CheckPathBetweenNodes. This is needed to fix a bug in variable inlining. (Alan) R=robert DELTA=164  (145 added, 8 deleted, 11 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckPathsBetweenNodes.java\n+++ b/src/com/google/javascript/jscomp/CheckPathsBetweenNodes.java\n  * DiGraphNode, DiGraphNode, Predicate, Predicate)}, for a\n  * description of this algorithm.\n  *\n+ * @autohr acleung@google.com (Alan Leung)\n *\n  *\n  * @param <N> The node type.\n  */\n class CheckPathsBetweenNodes<N, E> {\n \n-  private Predicate<N> nodePredicate;\n-  private Predicate<DiGraphEdge<N, E>> edgePredicate;\n-  private boolean result;\n+  private final Predicate<N> nodePredicate;\n+  private final Predicate<DiGraphEdge<N, E>> edgePredicate;\n+  private final boolean inclusive;\n \n   // This algorithm works in two stages. First, the depth-first search (DFS)\n   // tree is calculated with A as the root. During when constructing the DFS\n   private static final Annotation GRAY = new Annotation() {};\n   // Finished visiting.\n   private static final Annotation BLACK = new Annotation() {};\n+  \n+  private final DiGraph<N, E> graph;\n+  private final DiGraphNode<N, E> start;\n+  private final DiGraphNode<N, E> end;\n \n   /**\n    * Given a graph G with nodes A and B, this algorithm determines if all paths\n    *     A node to B (inclusive) must match.\n    * @param edgePredicate Edges to consider as part of the graph. Edges in\n    *     graph that don't match edgePredicate will be ignored.\n+   * @param inclusive Includes node A and B in the test for the node predicate.\n+   */\n+  CheckPathsBetweenNodes(DiGraph<N, E> graph, DiGraphNode<N, E> a,\n+      DiGraphNode<N, E> b, Predicate<N> nodePredicate,\n+      Predicate<DiGraphEdge<N, E>> edgePredicate, boolean inclusive) {\n+    this.graph = graph;\n+    this.start = a;\n+    this.end = b;\n+    this.nodePredicate = nodePredicate;\n+    this.edgePredicate = edgePredicate;\n+    this.inclusive = inclusive;\n+  }\n+  \n+  /**\n+   * Inclusive check.\n    */\n   CheckPathsBetweenNodes(DiGraph<N, E> graph, DiGraphNode<N, E> a,\n       DiGraphNode<N, E> b, Predicate<N> nodePredicate,\n       Predicate<DiGraphEdge<N, E>> edgePredicate) {\n-    this.nodePredicate = nodePredicate;\n-    this.edgePredicate = edgePredicate;\n-\n+    this(graph, a, b, nodePredicate, edgePredicate, true);\n+  }\n+  \n+\n+  /**\n+   * @return true iff all paths contain at least one node that satisfy the\n+   *     predicate\n+   */\n+  public boolean allPathsSatisfyPredicate() {\n+    setUp();\n+    boolean result = checkAllPathsWithoutBackEdges(start, end);\n+    tearDown();\n+    return result;\n+  }\n+  \n+  /**\n+   * @return true iff some paths contain at least one node that satisfy the\n+   *     predicate\n+   */\n+  public boolean somePathsSatisfyPredicate() {\n+    setUp();\n+    boolean result = checkSomePathsWithoutBackEdges(start, end);\n+    tearDown();\n+    return result;\n+  }\n+\n+  private void setUp() {\n     graph.pushNodeAnnotations();\n     graph.pushEdgeAnnotations();\n-\n-    discoverBackEdges(a);\n-    result = checkAllPathsWithoutBackEdges(a, b);\n-\n+    discoverBackEdges(this.start);\n+  }\n+  \n+  private void tearDown() {\n     graph.popNodeAnnotations();\n     graph.popEdgeAnnotations();\n   }\n-\n-  /**\n-   * @return true iff all paths contain at least one node that satisfy the\n-   *     predicate\n-   */\n-  public boolean allPathsSatisfyPredicate() {\n-    return result;\n-  }\n-\n+  \n   private void discoverBackEdges(DiGraphNode<N, E> u) {\n     u.setAnnotation(GRAY);\n     for (DiGraphEdge<N, E> e : u.getOutEdges()) {\n    */\n   private boolean checkAllPathsWithoutBackEdges(DiGraphNode<N, E> a,\n       DiGraphNode<N, E> b) {\n-    if (nodePredicate.apply(a.getValue())) {\n+    if (nodePredicate.apply(a.getValue()) &&\n+        (inclusive || (a != start && a != end))) {\n       return true;\n     }\n     if (a == b) {\n     }\n     return true;\n   }\n+  \n+  /**\n+   * Verify that some non-looping paths from {@code a} to {@code b} pass\n+   * through at least one node where {@code nodePredicate} is true.\n+   */\n+  private boolean checkSomePathsWithoutBackEdges(DiGraphNode<N, E> a,\n+      DiGraphNode<N, E> b) {\n+    if (nodePredicate.apply(a.getValue()) &&\n+        (inclusive || (a != start && a != end))) {\n+      return true;\n+    }\n+    if (a == b) {\n+      return false;\n+    }\n+    for (DiGraphEdge<N, E> e : a.getOutEdges()) {\n+      if (ignoreEdge(e)) {\n+        continue;\n+      }\n+      if (e.getAnnotation() == BACK_EDGE) {\n+        continue;\n+      }\n+      DiGraphNode<N, E> next = e.getDestination();\n+      if (checkSomePathsWithoutBackEdges(next, b)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n }\n--- a/test/com/google/javascript/jscomp/CheckPathsBetweenNodesTest.java\n+++ b/test/com/google/javascript/jscomp/CheckPathsBetweenNodesTest.java\n \n /**\n  * Tests for {@link CheckPathsBetweenNodes}.\n- * \n+ *\n+ * @autohr acleung@google.com (Alan Leung)\n *\n  */\n public class CheckPathsBetweenNodesTest extends TestCase {\n     assertGood(createTest(g, \"a\", \"d\", Predicates.equalTo(\"a\"), ALL_EDGE));\n     assertBad(createTest(g, \"a\", \"d\", Predicates.equalTo(\"z\"), ALL_EDGE));\n   }\n-  \n+\n+  \n+  /**\n+   * Much of the tests are done by testing all paths. We quickly verified\n+   * that some paths are indeed correct for the some path case.\n+   */\n+  public void testSomePath1() {\n+    DiGraph<String, String> g = new LinkedDirectedGraph<String, String>();\n+    g.createDirectedGraphNode(\"a\");\n+    g.createDirectedGraphNode(\"b\");\n+    g.createDirectedGraphNode(\"c\");\n+    g.createDirectedGraphNode(\"d\");\n+\n+    g.connect(\"a\", \"-\", \"b\");\n+    g.connect(\"a\", \"-\", \"c\");\n+    g.connect(\"b\", \"-\", \"d\");\n+    g.connect(\"c\", \"-\", \"d\");\n+    \n+    assertTrue(createTest(g, \"a\", \"d\", Predicates.equalTo(\"b\"), ALL_EDGE)\n+        .somePathsSatisfyPredicate());\n+    assertTrue(createTest(g, \"a\", \"d\", Predicates.equalTo(\"c\"), ALL_EDGE)\n+        .somePathsSatisfyPredicate());\n+    assertTrue(createTest(g, \"a\", \"d\", Predicates.equalTo(\"a\"), ALL_EDGE)\n+        .somePathsSatisfyPredicate());\n+    assertTrue(createTest(g, \"a\", \"d\", Predicates.equalTo(\"d\"), ALL_EDGE)\n+        .somePathsSatisfyPredicate());\n+    assertFalse(createTest(g, \"a\", \"d\", Predicates.equalTo(\"NONE\"), ALL_EDGE)\n+        .somePathsSatisfyPredicate());\n+  }\n+  \n+  public void testSomePath2() {\n+    // No Paths between nodes, by definition, always false.\n+    DiGraph<String, String> g = new LinkedDirectedGraph<String, String>();\n+    g.createDirectedGraphNode(\"a\");\n+    g.createDirectedGraphNode(\"b\");\n+\n+    assertFalse(createTest(g, \"a\", \"b\", Predicates.equalTo(\"b\"), ALL_EDGE)\n+        .somePathsSatisfyPredicate());\n+    assertFalse(createTest(g, \"a\", \"b\", Predicates.equalTo(\"d\"), ALL_EDGE)\n+        .somePathsSatisfyPredicate());\n+    assertTrue(createTest(g, \"a\", \"b\", Predicates.equalTo(\"a\"), ALL_EDGE)\n+        .somePathsSatisfyPredicate());\n+  }\n+  \n+  public void testNonInclusive() {\n+    // No Paths between nodes, by definition, always false.\n+    DiGraph<String, String> g = new LinkedDirectedGraph<String, String>();\n+    g.createDirectedGraphNode(\"a\");\n+    g.createDirectedGraphNode(\"b\");\n+    g.createDirectedGraphNode(\"c\");\n+    g.connect(\"a\", \"-\", \"b\");\n+    g.connect(\"b\", \"-\", \"c\");\n+    assertFalse(createNonInclusiveTest(g, \"a\", \"b\",\n+        Predicates.equalTo(\"a\"), ALL_EDGE).somePathsSatisfyPredicate());\n+    assertFalse(createNonInclusiveTest(g, \"a\", \"b\",\n+        Predicates.equalTo(\"b\"), ALL_EDGE).somePathsSatisfyPredicate());\n+    assertTrue(createNonInclusiveTest(g, \"a\", \"c\",\n+        Predicates.equalTo(\"b\"), ALL_EDGE).somePathsSatisfyPredicate());\n+  }\n+\n   private static <N, E> void assertGood(CheckPathsBetweenNodes<N, E> test) {\n     assertTrue(test.allPathsSatisfyPredicate());\n   }\n         nodePredicate, edgePredicate);\n   }\n   \n+  private static CheckPathsBetweenNodes<String, String>\n+      createNonInclusiveTest(\n+        DiGraph<String, String> graph,\n+        String entry,\n+        String exit,\n+        Predicate<String> nodePredicate,\n+        Predicate<DiGraphEdge<String, String>> edgePredicate) {\n+    return new CheckPathsBetweenNodes<String, String>(graph,\n+        graph.getDirectedGraphNode(entry), graph.getDirectedGraphNode(exit),\n+        nodePredicate, edgePredicate, false);\n+  }\n+  \n   private static Predicate<DiGraphEdge<String, String>>\n       edgeIs(final Object val) {\n     return new Predicate<DiGraphEdge<String, String>>() {", "timestamp": 1269642157, "metainfo": ""}