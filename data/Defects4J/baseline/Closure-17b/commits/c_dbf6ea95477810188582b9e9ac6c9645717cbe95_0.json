{"sha": "dbf6ea95477810188582b9e9ac6c9645717cbe95", "log": "Automated g4 rollback  *** Reason for rollback ***  broke some stuff  *** Original change description ***  You are in a maze of twisty 'if' branches, all alike. cleanup the logic for identifying dead expressions. Fixes issue 753  DELTA=73  (35 added, 22 deleted, 16 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5044   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n       return;\n     }\n \n-    // Do not try to remove a block or an expr result. We already handle\n-    // these cases when we visit the child, and the peephole passes will\n-    // fix up the tree in more clever ways when these are removed.\n-    if (n.isExprResult() || n.isBlock()) {\n-      return;\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-      return;\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n+    int pt = parent.getType();\n+    if (pt == Token.COMMA) {\n+      Node gramps = parent.getParent();\n+      if (gramps.isCall() &&\n+          parent == gramps.getFirstChild()) {\n+        // Semantically, a direct call to eval is different from an indirect\n+        // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n+        // expression to a comma to be a no-op if it's used to indirect\n+        // an eval.\n+        if (n == parent.getFirstChild() &&\n+            parent.getChildCount() == 2 &&\n+            n.getNext().isName() &&\n+            \"eval\".equals(n.getNext().getString())) {\n+          return;\n+        }\n+      }\n+\n+      if (n == parent.getLastChild()) {\n+        for (Node an : parent.getAncestors()) {\n+          int ancestorType = an.getType();\n+          if (ancestorType == Token.COMMA)\n+            continue;\n+          if (ancestorType != Token.EXPR_RESULT &&\n+              ancestorType != Token.BLOCK)\n+            return;\n+          else\n+            break;\n+        }\n+      }\n+    } else if (pt != Token.EXPR_RESULT && pt != Token.BLOCK) {\n+      if (pt == Token.FOR && parent.getChildCount() == 4 &&\n+          (n == parent.getFirstChild() ||\n+           n == parent.getFirstChild().getNext().getNext())) {\n+        // Fall through and look for warnings for the 1st and 3rd child\n+        // of a for.\n+      } else {\n+        return;  // it might be OK to not have a side-effect\n+      }\n+    }\n+\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n+    if (isSimpleOp ||\n+        !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n+      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+        // This no-op statement was there so that JSDoc information could\n+        // be attached to the name. This check should not complain about it.\n+        return;\n+      } else if (n.isExprResult()) {\n+        // we already reported the problem when we visited the child.\n+        return;\n+      }\n+\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n     // TODO(johnlenz): consider sharing some code with trySimpleUnusedResult.\n     Node parent = expr.getParent();\n     switch (parent.getType()) {\n-      case Token.BLOCK:\n       case Token.EXPR_RESULT:\n         return false;\n       case Token.HOOK:\n         return (expr == parent.getFirstChild())\n             ? true : isExpressionResultUsed(parent);\n       case Token.COMMA:\n-        Node gramps = parent.getParent();\n-        if (gramps.isCall() &&\n-            parent == gramps.getFirstChild()) {\n-          // Semantically, a direct call to eval is different from an indirect\n-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n-          // expression to a comma to be a no-op if it's used to indirect\n-          // an eval. This we pretend that this is \"used\".\n-          if (expr == parent.getFirstChild() &&\n-              parent.getChildCount() == 2 &&\n-              expr.getNext().isName() &&\n-              \"eval\".equals(expr.getNext().getString())) {\n-            return true;\n-          }\n-        }\n-\n         return (expr == parent.getFirstChild())\n             ? false : isExpressionResultUsed(parent);\n       case Token.FOR:\n--- a/test/com/google/javascript/jscomp/CheckSideEffectsTest.java\n+++ b/test/com/google/javascript/jscomp/CheckSideEffectsTest.java\n          \"var a, b; a = 5, JSCOMPILER_PRESERVE(b == 6)\", e);\n     test(\"var a, b; a = (5, 6)\",\n          \"var a, b; a = (JSCOMPILER_PRESERVE(5), 6)\", e);\n-    test(\"var a, b; a = (bar(), 6, 7)\",\n-         \"var a, b; a = (bar(), JSCOMPILER_PRESERVE(6), 7)\", e);\n-    test(\"var a, b; a = (bar(), bar(), 7, 8)\",\n-         \"var a, b; a = (bar(), bar(), JSCOMPILER_PRESERVE(7), 8)\", e);\n     test(\"var a, b; a = (b = 7, 6)\", ok);\n     test(\"function x(){}\\nfunction f(a, b){}\\nf(1,(x(), 2));\", ok);\n     test(\"function x(){}\\nfunction f(a, b){}\\nf(1,(2, 3));\",\n          \"for(JSCOMPILER_PRESERVE(void 0); true; foo()) { bar() }\", e);\n     test(\"for(foo(); true; void 0) { bar() }\",\n          \"for(foo(); true; JSCOMPILER_PRESERVE(void 0)) { bar() }\", e);\n-    test(\"for(foo(); true; (1, bar())) { bar() }\",\n-         \"for(foo(); true; (JSCOMPILER_PRESERVE(1), bar())) { bar() }\", e);\n \n     test(\"for(foo in bar) { foo() }\", ok);\n     test(\"for (i = 0; el = el.previousSibling; i++) {}\", ok);", "timestamp": 1340142196, "metainfo": ""}