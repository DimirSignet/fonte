{"sha": "cc67102f3b08386cf78cdac3b7c038efc853acd2", "log": "Remove redundant code.  R=jschorr DELTA=139  (3 added, 130 deleted, 6 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1448   ", "commit": "\n--- a/src/com/google/debugging/sourcemap/SourceMapGeneratorV2.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapGeneratorV2.java\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+\n import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.Deque;\n       LineMapEncoder.encodeEntry(sb, id, lastId, reps);\n \n       if (validate) {\n-        LineMapDecoder.LineEntry entry = LineMapDecoder.decodeLineEntry(\n-            sb.toString(), lastId);\n+        SourceMapLineDecoder.LineEntry entry =\n+            SourceMapLineDecoder.decodeLineEntry(sb.toString(), lastId);\n         Preconditions.checkState(entry.id == id && entry.reps == reps,\n             \"expected (%s,%s) but got (%s,%s)\",\n             id, reps, entry.id, entry.reps);\n   }\n \n   /**\n-   * A line mapping decoder class used for testing and validation.\n-   */\n-  @VisibleForTesting\n-  public static class LineMapDecoder {\n-    private static LineEntry decodeLineEntry(String in, int lastId) {\n-      return decodeLineEntry(new StringParser(in), lastId);\n-    }\n-\n-    private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n-      int repDigits = 0;\n-\n-      // Determine the number of digits used for the repetition count.\n-      // Each \"!\" indicates another base64 digit.\n-      for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n-        repDigits++;\n-        reader.next(); // consume the \"!\"\n-      }\n-\n-      int idDigits = 0;\n-      int reps = 0;\n-      if (repDigits == 0) {\n-        // No repetition digit escapes, so the next character represents the\n-        // number of digits in the id (bottom 2 bits) and the number of\n-        // repetitions (top 4 digits).\n-        char digit = reader.next();\n-        int value = addBase64Digit(digit, 0);\n-        reps = (value >> 2);\n-        idDigits = (value & 3);\n-      } else {\n-        char digit = reader.next();\n-        idDigits = addBase64Digit(digit, 0);\n-\n-        int value = 0;\n-        for (int i = 0; i < repDigits; i++) {\n-          digit = reader.next();\n-          value = addBase64Digit(digit, value);\n-        }\n-        reps = value;\n-      }\n-\n-      // Adjust for 1 offset encoding.\n-      reps += 1;\n-      idDigits += 1;\n-\n-      // Decode the id token.\n-      int value = 0;\n-      for (int i = 0; i < idDigits; i++) {\n-        char digit = reader.next();\n-        value = addBase64Digit(digit, value);\n-      }\n-      int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n-      return new LineEntry(mappingId, reps);\n-    }\n-\n-    public static List<Integer> decodeLine(String lineSource) {\n-      return decodeLine(new StringParser(lineSource));\n-    }\n-\n-    static private List<Integer> decodeLine(StringParser reader) {\n-      List<Integer> result = Lists.newArrayListWithCapacity(512);\n-      int lastId = 0;\n-      while (reader.hasNext()) {\n-        LineEntry entry = decodeLineEntry(reader, lastId);\n-        lastId = entry.id;\n-\n-        for (int i=0; i < entry.reps; i++) {\n-          result.add(entry.id);\n-        }\n-      }\n-\n-      return result;\n-    }\n-\n-    /**\n-     * Build base64 number a digit at a time, most significant digit first.\n-     */\n-    private static int addBase64Digit(char digit, int previousValue) {\n-      return (previousValue * 64) + BASE64_MAP.indexOf(digit);\n-    }\n-\n-    /**\n-     * @return the id from the relative id.\n-     */\n-    public static int getIdFromRelativeId(int rawId, int digits, int lastId) {\n-      // The value range depends on the number of digits\n-      int base = 1 << (digits * 6);\n-      return ((rawId >= base/2) ? rawId - base : rawId) + lastId;\n-      // return (rawId - (base/2)) + lastId;\n-    }\n-\n-    static class LineEntry {\n-      final int id;\n-      final int reps;\n-      public LineEntry(int id, int reps) {\n-        this.id = id;\n-        this.reps = reps;\n-      }\n-    }\n-\n-    /**\n-     * A simple class for maintaining the current location\n-     * in the input.\n-     */\n-    static class StringParser {\n-      final String content;\n-      int current = 0;\n-\n-      StringParser(String content) {\n-        this.content = content;\n-      }\n-\n-      char next() {\n-        return content.charAt(current++);\n-      }\n-\n-      char peek() {\n-        return content.charAt(current);\n-      }\n-\n-      boolean hasNext() {\n-        return  current < content.length() -1;\n-      }\n-    }\n-  }\n-\n-  /**\n    * Mark any visited mapping as \"used\".\n    */\n   private class UsedMappingCheck implements MappingVisitor {\n--- a/src/com/google/debugging/sourcemap/SourceMapLineDecoder.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapLineDecoder.java\n  * @author johnlenz@google.com (John Lenz)\n  * @author jschorr@google.com (Joseph Schorr)\n  */\n-// NOTE : Copied from the JSC to avoid a dependency.\n-// TODO(user): Move this into a central shared location.\n class SourceMapLineDecoder {\n   /**\n    *  A map used to convert integer values in the range 0-63 to their base64\n \n   private SourceMapLineDecoder() {}\n \n-  private static LineEntry decodeLineEntry(String in, int lastId) {\n+  static LineEntry decodeLineEntry(String in, int lastId) {\n     return decodeLineEntry(new StringParser(in), lastId);\n   }\n \n   /**\n    * @return the id from the relative id.\n    */\n-  private static int getIdFromRelativeId(int rawId, int digits, int lastId) {\n+  static int getIdFromRelativeId(int rawId, int digits, int lastId) {\n     // The value range depends on the number of digits\n     int base = 1 << (digits * 6);\n     return ((rawId >= base/2) ? rawId - base : rawId) + lastId;\n--- a/test/com/google/debugging/sourcemap/SourceMapGeneratorV2Test.java\n+++ b/test/com/google/debugging/sourcemap/SourceMapGeneratorV2Test.java\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n-import com.google.debugging.sourcemap.SourceMapGeneratorV2.LineMapDecoder;\n import com.google.debugging.sourcemap.SourceMapGeneratorV2.LineMapEncoder;\n import com.google.javascript.jscomp.Compiler;\n import com.google.javascript.jscomp.CompilerOptions;\n   private int getRelativeId(int id, int lastId) {\n     int length = LineMapEncoder.getRelativeMappingIdLength(id, lastId);\n     int result = LineMapEncoder.getRelativeMappingId(id, length, lastId);\n-    int inverse = LineMapDecoder.getIdFromRelativeId(result, length, lastId);\n+    int inverse = SourceMapLineDecoder.getIdFromRelativeId(\n+                      result, length, lastId);\n     assertEquals(id, inverse);\n     return result;\n   }\n         for (int i=0; i< lineMaps.length(); i++) {\n           String lineEntry = lineMaps.getString(i);\n           List<Integer> entries =\n-              SourceMapGeneratorV2.LineMapDecoder.decodeLine(lineEntry);\n+              SourceMapLineDecoder.decodeLine(lineEntry);\n           String msg = \"line: \" + entries;\n           System.err.println(msg);\n           characterMap.add(entries);", "timestamp": 1302720482, "metainfo": ""}