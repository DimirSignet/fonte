{"sha": "e88cd847e5f7f0b0aa23aa3d8860bcf58896fa28", "log": "In my sample, using this approach to running the peephole optimizations to a fixed point reduces build time by ~30%, the number of overall runs for the \"code removing passes\" are reduced from 30 to 14 for one target and InlineVariables becomes the \"long pole\".  R=acleung DELTA=153  (113 added, 3 deleted, 37 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4281   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n+++ b/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n  */\n abstract class AbstractPeepholeOptimization {\n \n-  private NodeTraversal currentTraversal;\n+  private AbstractCompiler compiler;\n \n   /**\n    * Given a node to optimize and a traversal, optimize the node. Subclasses\n    * @param n The node for which the error should be reported\n    */\n   protected void error(DiagnosticType diagnostic, Node n) {\n-    JSError error = currentTraversal.makeError(n, diagnostic, n.toString());\n-    currentTraversal.getCompiler().report(error);\n+    JSError error =\n+        JSError.make(NodeUtil.getSourceName(n), n, diagnostic, n.toString());\n+    compiler.report(error);\n   }\n \n   /**\n    * Subclasses must call these if they have changed the AST.\n    */\n   protected void reportCodeChange() {\n-    Preconditions.checkNotNull(currentTraversal);\n-    currentTraversal.getCompiler().reportCodeChange();\n+    Preconditions.checkNotNull(compiler);\n+    compiler.reportCodeChange();\n   }\n \n   /**\n     /* Our implementation delegates to the compiler. We provide this\n      * method because we don't want to expose Compiler to PeepholeOptimizations.\n      */\n-    Preconditions.checkNotNull(currentTraversal);\n-    return currentTraversal.getCompiler().areNodesEqualForInlining(n1, n2);\n+    Preconditions.checkNotNull(compiler);\n+    return compiler.areNodesEqualForInlining(n1, n2);\n   }\n \n   /**\n    *  and has the Denormalize pass not yet been run?)\n    */\n   protected boolean isASTNormalized() {\n-    Preconditions.checkNotNull(currentTraversal);\n-    Preconditions.checkNotNull(currentTraversal.getCompiler());\n+    Preconditions.checkNotNull(compiler);\n \n-    return currentTraversal.getCompiler().getLifeCycleStage().isNormalized();\n+    return compiler.getLifeCycleStage().isNormalized();\n   }\n \n   /**\n    * Informs the optimization that a traversal will begin.\n    */\n-  void beginTraversal(NodeTraversal traversal) {\n-    currentTraversal = traversal;\n+  void beginTraversal(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n   }\n \n   /**\n    * Informs the optimization that a traversal has completed.\n    */\n-  void endTraversal(NodeTraversal traversal) {\n-    currentTraversal = null;\n+  void endTraversal(AbstractCompiler compiler) {\n+    this.compiler = null;\n   }\n \n   // NodeUtil's mayEffectMutableState and mayHaveSideEffects need access to the\n    * state.\n    */\n   boolean mayEffectMutableState(Node n) {\n-    return NodeUtil.mayEffectMutableState(n, currentTraversal.getCompiler());\n+    return NodeUtil.mayEffectMutableState(n, compiler);\n   }\n \n   /**\n    * @return Whether the node may have side effects when executed.\n    */\n   boolean mayHaveSideEffects(Node n) {\n-    return NodeUtil.mayHaveSideEffects(n, currentTraversal.getCompiler());\n+    return NodeUtil.mayHaveSideEffects(n, compiler);\n   }\n \n   /**\n    *     ignored when this is true.\n    */\n   boolean isEcmaScript5OrGreater() {\n-    return currentTraversal != null\n-        && currentTraversal.getCompiler().acceptEcmaScript5();\n+    return compiler != null\n+        && compiler.acceptEcmaScript5();\n   }\n \n   /**\n    */\n   CodingConvention getCodingConvention() {\n     // Note: this assumes a thread safe coding convention object.\n-    return currentTraversal.getCompiler().getCodingConvention();\n+    return compiler.getCodingConvention();\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n+++ b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n import com.google.javascript.rhino.Node;\n+\n+import java.util.ArrayList;\n \n /**\n  * A compiler pass to run various peephole optimizations (e.g. constant folding,\n  * @author dcc@google.com (Devin Coughlin)\n  * @author acleung@google.com (Alan Leung)(\n  */\n-class PeepholeOptimizationsPass extends AbstractPostOrderCallback\n+class PeepholeOptimizationsPass\n     implements CompilerPass {\n   private AbstractCompiler compiler;\n \n   // Use an array here for faster iteration compared to ImmutableSet\n-  // TODO should sort based on likelihood that a given optimzation can\n-  // modify something.\n   private final AbstractPeepholeOptimization[] peepholeOptimizations;\n+\n+  // Track whether the a scope has been modified so that it can be revisited\n+  // immediately.\n+  private StateStack traversalState = new StateStack();\n+\n+  static private class ScopeState {\n+    boolean changed;\n+    boolean traverseChildScopes;\n+    ScopeState() {\n+      reset();\n+    }\n+\n+    void reset() {\n+      changed = false;\n+      traverseChildScopes = true;\n+    }\n+  }\n+\n+  static private class StateStack {\n+    private ArrayList<ScopeState> states = Lists.newArrayList();\n+    private int currentDepth = 0;\n+\n+    StateStack() {\n+      states.add(new ScopeState());\n+    }\n+\n+    ScopeState peek() {\n+      return states.get(currentDepth);\n+    }\n+\n+    void push() {\n+      currentDepth++;\n+      if (states.size() <= currentDepth) {\n+        states.add(new ScopeState());\n+      } else {\n+        states.get(currentDepth).reset();\n+      }\n+    }\n+\n+    void pop() {\n+      currentDepth--;\n+    }\n+  }\n+\n+  private class PeepholeChangeHandler implements CodeChangeHandler {\n+    @Override\n+    public void reportChange() {\n+      traversalState.peek().changed = true;\n+    }\n+  }\n \n   /**\n    * Creates a peephole optimization pass that runs the given\n \n   @Override\n   public void process(Node externs, Node root) {\n-    NodeTraversal t = new NodeTraversal(compiler, this);\n-\n-    beginTraversal(t);\n-    t.traverse(root);\n-    endTraversal(t);\n-  }\n-\n-  @Override\n-  public void visit(NodeTraversal t, Node n, Node parent) {\n+    PeepholeChangeHandler handler = new PeepholeChangeHandler();\n+    compiler.addChangeHandler(handler);\n+    beginTraversal();\n+    traverse(root);\n+    endTraversal();\n+    compiler.removeChangeHandler(handler);\n+  }\n+\n+  private void traverse(Node node) {\n+    // The goal here is to avoid retraversing\n+    // the entire AST to catch newly created opportunities.\n+    // So we track whether a \"unit of code\" has changed,\n+    // and revisit immediately.\n+    if (!shouldVisit(node)) {\n+      return;\n+    }\n+\n+    int visits = 0;\n+    do {\n+      for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n+        traverse(c);\n+      }\n+\n+      visit(node);\n+      visits++;\n+\n+      Preconditions.checkState(visits < 10000, \"too many interations\");\n+    } while (shouldRetraverse(node));\n+\n+    exitNode(node);\n+  }\n+\n+  private boolean shouldRetraverse(Node node) {\n+    if (node.getParent() != null && node.isFunction() || node.isScript()) {\n+      ScopeState state = traversalState.peek();\n+      if (state.changed) {\n+        // prepare to re-visit the scope:\n+        // when revisiting, only visit the immediate scope\n+        // this reduces the cost of getting to a fixed\n+        // point in global scope.\n+        state.changed = false;\n+        state.traverseChildScopes = false;\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean shouldVisit(Node node) {\n+    if (node.isFunction() || node.isScript()) {\n+      ScopeState previous = traversalState.peek();\n+      if (!previous.traverseChildScopes) {\n+        return false;\n+      }\n+      traversalState.push();\n+    }\n+    return true;\n+  }\n+\n+  private void exitNode(Node node) {\n+    if (node.isFunction() || node.isScript()) {\n+      traversalState.pop();\n+    }\n+  }\n+\n+  public void visit(Node n) {\n     Node currentVersionOfNode = n;\n     boolean somethingChanged = false;\n \n    * Make sure that all the optimizations have the current traversal so they\n    * can report errors.\n    */\n-  private void beginTraversal(NodeTraversal t) {\n+  private void beginTraversal() {\n     for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\n-      optimization.beginTraversal(t);\n-    }\n-  }\n-\n-  private void endTraversal(NodeTraversal t) {\n+      optimization.beginTraversal(compiler);\n+    }\n+  }\n+\n+  private void endTraversal() {\n     for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\n-      optimization.endTraversal(t);\n+      optimization.endTraversal(compiler);\n     }\n   }\n }\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n       \"  return a;\" +\n       \"}\";\n \n-    test(options, code, expected);\n+    // TODO(johnlenz): re-enable this.\n+    // Once a \"x ? a : a\" => \"a\" optimization is added.\n+    // test(options, code, expected);\n   }\n \n   public void testLateStatementFusion() {", "timestamp": 1330378906, "metainfo": ""}