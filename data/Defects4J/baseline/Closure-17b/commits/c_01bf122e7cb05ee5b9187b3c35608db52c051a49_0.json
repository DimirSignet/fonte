{"sha": "01bf122e7cb05ee5b9187b3c35608db52c051a49", "log": "Check and maintain the \"FREE_CALL\" attribute so we can verify we aren't using it incorrectly.  R=nicksantos DELTA=104  (90 added, 7 deleted, 7 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2407   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AliasExternals.java\n+++ b/src/com/google/javascript/jscomp/AliasExternals.java\n       Node callName = Node.newString(Token.NAME,\n         getMutatorFor(propNameNode.getString()));\n       Node call = new Node(Token.CALL, callName, propSrc, propDest);\n+      call.putBooleanProp(Node.FREE_CALL, true);\n \n       // And replace the assign statement with the new call\n       replaceNode(parentNode.getParent(), parentNode, call);\n--- a/src/com/google/javascript/jscomp/AliasKeywords.java\n+++ b/src/com/google/javascript/jscomp/AliasKeywords.java\n           compiler.getCodingConvention(),\n           getAliasName(), throwNode, getAliasName());\n       Node aliasCall = new Node(Token.CALL, name, throwNode.removeFirstChild());\n+      aliasCall.putBooleanProp(Node.FREE_CALL, true);\n       Node exprResult = new Node(Token.EXPR_RESULT, aliasCall);\n       parent.replaceChild(throwNode, exprResult);\n     }\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n     Node ref = NodeUtil.newName(\n         compiler.getCodingConvention(), alias, n, originalName);\n     NodeUtil.copyNameAnnotations(n.getLastChild(), ref);\n+    if (parent.getType() == Token.CALL && n == parent.getFirstChild()) {\n+      // The node was a call target, we are deliberately flatten these as\n+      // we node the \"this\" isn't provided by the namespace. Mark it as such:\n+      parent.putBooleanProp(Node.FREE_CALL, true);\n+    }\n+\n     JSType type = n.getJSType();\n     if (type != null) {\n       ref.setJSType(type);\n--- a/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n           Node proto = prop.getPrototype();\n           int stubId = idGenerator.newId();\n \n+          // example: JSCompiler_stubMethod(id);\n+          Node stubCall = new Node(Token.CALL,\n+              Node.newString(Token.NAME, STUB_METHOD_NAME),\n+              Node.newNumber(stubId))\n+              .copyInformationFromForTree(value);\n+          stubCall.putBooleanProp(Node.FREE_CALL, true);\n+\n           // stub out the method in the original module\n-          valueParent.replaceChild(value,\n-              // A.prototype.b = JSCompiler_stubMethod(id);\n-              new Node(Token.CALL,\n-                      Node.newString(Token.NAME, STUB_METHOD_NAME),\n-                      Node.newNumber(stubId))\n-                  .copyInformationFromForTree(value));\n+          // A.prototype.b = JSCompiler_stubMethod(id);\n+          valueParent.replaceChild(value, stubCall);\n \n           // unstub the function body in the deeper module\n           Node unstubParent = compiler.getNodeForCodeInsertion(\n               deepestCommonModuleRef);\n+          Node unstubCall = new Node(Token.CALL,\n+              Node.newString(Token.NAME, UNSTUB_METHOD_NAME),\n+              Node.newNumber(stubId),\n+              value);\n+          unstubCall.putBooleanProp(Node.FREE_CALL, true);\n           unstubParent.addChildToFront(\n               // A.prototype.b = JSCompiler_unstubMethod(id, body);\n               new Node(Token.EXPR_RESULT,\n                       new Node(Token.GETPROP,\n                           proto.cloneTree(),\n                           Node.newString(Token.STRING, nameInfo.name)),\n-                      new Node(Token.CALL,\n-                          Node.newString(Token.NAME, UNSTUB_METHOD_NAME),\n-                          Node.newNumber(stubId),\n-                          value)))\n+                      unstubCall))\n                   .copyInformationFromForTree(value));\n \n           compiler.reportCodeChange();\n--- a/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n+++ b/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n       parent.addChildToFront(\n           Node.newString(Token.NAME, newMethodName)\n               .copyInformationFrom(node));\n+      Preconditions.checkState(parent.getType() == Token.CALL);\n+      parent.putBooleanProp(Node.FREE_CALL, true);\n       compiler.reportCodeChange();\n \n       if (specializationState != null) {\n--- a/src/com/google/javascript/jscomp/ExportTestFunctions.java\n+++ b/src/com/google/javascript/jscomp/ExportTestFunctions.java\n   private void exportTestFunction(String testFunctionName, Node node,\n       Node scriptNode) {\n \n-    Node call = new Node(Token.CALL, NodeUtil.newQualifiedNameNode(\n+    Node exportCallTarget = NodeUtil.newQualifiedNameNode(\n         compiler.getCodingConvention(),\n-        exportSymbolFunction, node, testFunctionName));\n+        exportSymbolFunction, node, testFunctionName);\n+    Node call = new Node(Token.CALL, exportCallTarget);\n+    if (exportCallTarget.getType() == Token.NAME) {\n+      call.putBooleanProp(Node.FREE_CALL, true);\n+    }\n     call.addChildToBack(Node.newString(testFunctionName));\n     call.addChildToBack(NodeUtil.newQualifiedNameNode(\n         compiler.getCodingConvention(),\n--- a/src/com/google/javascript/jscomp/FunctionRewriter.java\n+++ b/src/com/google/javascript/jscomp/FunctionRewriter.java\n     protected final Node buildCallNode(String methodName, Node argumentNode,\n                                        int lineno, int charno) {\n       Node call = new Node(Token.CALL, lineno, charno);\n+      call.putBooleanProp(Node.FREE_CALL, true);\n       call.addChildToBack(Node.newString(Token.NAME, methodName));\n       if (argumentNode != null) {\n         call.addChildToBack(argumentNode.cloneTree());\n--- a/src/com/google/javascript/jscomp/InstrumentFunctions.java\n+++ b/src/com/google/javascript/jscomp/InstrumentFunctions.java\n       Node call = new Node(Token.CALL,\n           Node.newString(Token.NAME, appNameSetter),\n           Node.newString(appNameStr));\n+      call.putBooleanProp(Node.FREE_CALL, true);\n       Node expr = new Node(Token.EXPR_RESULT, call);\n \n       Node addingRoot = compiler.getNodeForCodeInsertion(null);\n     }\n \n     private Node newReportFunctionExitNode() {\n-      return new Node(Token.CALL,\n+      Node call = new Node(Token.CALL,\n           Node.newString(Token.NAME, reportFunctionExitName),\n           Node.newNumber(functionId));\n+      call.putBooleanProp(Node.FREE_CALL, true);\n+      return call;\n     }\n \n     /**\n         Node call = new Node(Token.CALL,\n             Node.newString(Token.NAME, reportFunctionName),\n             Node.newNumber(id));\n+        call.putBooleanProp(Node.FREE_CALL, true);\n         Node expr = new Node(Token.EXPR_RESULT, call);\n         body.addChildToFront(expr);\n         compiler.reportCodeChange();\n         Node call = new Node(Token.CALL,\n             Node.newString(Token.NAME, definedFunctionName),\n             Node.newNumber(id));\n+        call.putBooleanProp(Node.FREE_CALL, true);\n         Node expr = NodeUtil.newExpr(call);\n \n         Node addingRoot = null;\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    * A new CALL node with the \"FREE_CALL\" set based on call target.\n    */\n   static Node newCallNode(Node callTarget, Node... parameters) {\n-    boolean isFreeCall = isName(callTarget);\n+    boolean isFreeCall = !isGet(callTarget);\n     Node call = new Node(Token.CALL, callTarget);\n     call.putBooleanProp(Node.FREE_CALL, isFreeCall);\n     for (Node parameter : parameters) {\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n     Node replacement = value.detachFromParent();\n     if (key.getType() == Token.GET){\n       replacement = new Node(Token.CALL, replacement);\n+      replacement.putBooleanProp(Node.FREE_CALL, true);\n     }\n \n     n.getParent().replaceChild(n, replacement);\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n         String className = n.getFirstChild().getString();\n         if (STANDARD_OBJECT_CONSTRUCTORS.contains(className)) {\n           n.setType(Token.CALL);\n+          n.putBooleanProp(Node.FREE_CALL, true);\n           reportCodeChange();\n         }\n       }\n--- a/src/com/google/javascript/jscomp/jsonml/Reader.java\n+++ b/src/com/google/javascript/jscomp/jsonml/Reader.java\n     parent.addChildToBack(node);\n \n     transformAllChildren(element, node);\n+\n+    // Keep track of of the \"this\" context of a call.  A call without an\n+    // explicit \"this\" is a free call.\n+    Node first = node.getFirstChild();\n+    if (first.getType() != Token.GETPROP && first.getType() != Token.GETELEM) {\n+      node.putBooleanProp(Node.FREE_CALL, true);\n+    }\n   }\n \n   private void transformCase(JsonML element, Node parent)\n       throws JsonMLException {\n \n     Node node = createNode(Token.CALL, element);\n+    node.putBooleanProp(Node.FREE_CALL, true);\n     parent.addChildToBack(node);\n \n     Node child = Node.newString(Token.NAME, \"eval\");\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n       if (quoted1 != quoted2) {\n         return false;\n       }\n+    } else if (type == Token.CALL) {\n+      if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) {\n+        return false;\n+      }\n     }\n \n     if (recurse) {\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n          \"f(function(){return this})\");\n   }\n \n+  public void testInlineObject() {\n+    new StringCompare().testInlineObject();\n+  }\n+\n+  private static class StringCompare extends CompilerTestCase {\n+    private boolean allowGlobalFunctionInlining = true;\n+\n+    StringCompare() {\n+      super(\"\", false);\n+      this.enableNormalize();\n+      this.enableMarkNoSideEffects();\n+    }\n+\n+    @Override\n+    public void setUp() throws Exception {\n+      super.setUp();\n+      super.enableLineNumberCheck(true);\n+      allowGlobalFunctionInlining = true;\n+    }\n+\n+    @Override\n+    protected CompilerPass getProcessor(Compiler compiler) {\n+      compiler.resetUniqueNameId();\n+      return new InlineFunctions(\n+          compiler,\n+          compiler.getUniqueNameIdSupplier(),\n+          allowGlobalFunctionInlining,\n+          true, // allowLocalFunctionInlining\n+          true, // allowBlockInlining\n+          true); // assumeStrictThis\n+    }\n+\n+    public void testInlineObject() {\n+      allowGlobalFunctionInlining = false;\n+      // TODO(johnlenz): normalize the AST so an AST comparison can be done.\n+      // As is, the expected AST does not match the actual correct result:\n+      // The AST matches \"g.a()\" with a FREE_CALL annotation, but this as\n+      // expected string would fail as it won't be mark as a free call.\n+      // \"(0,g.a)()\" matches the output, but not the resulting AST.\n+      test(\"function inner(){function f(){return g.a}(f())()}\",\n+           \"function inner(){(0,g.a)()}\");\n+    }\n+  }\n+\n   public void testIssue423() {\n     test(\n         \"(function($) {\\n\" +", "timestamp": 1308952921, "metainfo": ""}