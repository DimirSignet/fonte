{"sha": "0af94b21ceb7f8f0891b85e5713ff93c230e1bb6", "log": "Part 3, source name/input id split: Change the construction of JSDocInfo to allow the determination of the source type (extern or not) without requiring the source to be looked up by name.  R=nicksantos DELTA=99  (51 added, 21 deleted, 27 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2898   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n         return;\n       }\n \n-      boolean sameInput =\n-          t.getInput().getName().equals(docInfo.getSourceName());\n+      String referenceSource = getprop.getSourceFileName();\n+      String definingSource = docInfo.getSourceName();\n+      boolean sameInput = referenceSource != null\n+          && referenceSource.equals(definingSource);\n       Visibility visibility = docInfo.getVisibility();\n       JSType ownerType = normalizeClassType(objectType);\n       if (isOverride) {\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n import com.google.common.base.Predicates;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Maps;\n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.TokenStream;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.StaticSourceFile;\n import com.google.javascript.rhino.jstype.TernaryValue;\n \n import java.util.Arrays;\n   }\n \n   /**\n+   * @param n The node.\n+   * @return The source name property on the node or its ancestors.\n+   */\n+  public static StaticSourceFile getSourceFile(Node n) {\n+    StaticSourceFile sourceName = null;\n+    while (sourceName == null && n != null) {\n+      sourceName = n.getStaticSourceFile();\n+      n = n.getParent();\n+    }\n+    return sourceName;\n+  }\n+\n+  /**\n+   * @param n The node.\n+   * @return The InputId property on the node or its ancestors.\n+   */\n+  public static InputId getInputId(Node n) {\n+    while (n != null && n.getType() != Token.SCRIPT) {\n+      n = n.getParent();\n+    }\n+\n+    return (n != null && n.getType() == Token.SCRIPT) ? n.getInputId() : null;\n+  }\n+\n+  /**\n    * A new CALL node with the \"FREE_CALL\" set based on call target.\n    */\n   static Node newCallNode(Node callTarget, Node... parameters) {\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n       boolean isExtern = false;\n       JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n       if(functionJSDocInfo != null) {\n-        String sourceName = functionJSDocInfo.getSourceName();\n-        CompilerInput functionSource = compiler.getInput(sourceName);\n-        isExtern = functionSource.isExtern();\n+        isExtern = functionJSDocInfo.getAssociatedNode().isFromExterns();\n       }\n \n       // Non-native constructors should not be called directly\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n       for (Comment comment : node.getComments()) {\n         if (comment.getCommentType() == CommentType.JSDOC &&\n             !comment.isParsed()) {\n-          irFactory.handlePossibleFileOverviewJsDoc(comment);\n+          irFactory.handlePossibleFileOverviewJsDoc(comment, irNode);\n         } else if (comment.getCommentType() == CommentType.BLOCK) {\n           irFactory.handleBlockComment(comment);\n         }\n     return false;\n   }\n \n-  private void handlePossibleFileOverviewJsDoc(Comment comment) {\n-    JsDocInfoParser jsDocParser = createJsDocInfoParser(comment);\n+  private void handlePossibleFileOverviewJsDoc(Comment comment, Node irNode) {\n+    JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);\n     comment.setParsed(true);\n     handlePossibleFileOverviewJsDoc(jsDocParser);\n   }\n \n-  private JSDocInfo handleJsDoc(AstNode node) {\n+  private JSDocInfo handleJsDoc(AstNode node, Node irNode) {\n     Comment comment = node.getJsDocNode();\n     if (comment != null) {\n-      JsDocInfoParser jsDocParser = createJsDocInfoParser(comment);\n+      JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);\n       comment.setParsed(true);\n       if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {\n         return jsDocParser.retrieveAndResetParsedJSDocInfo();\n   }\n \n   private Node transform(AstNode node) {\n-    JSDocInfo jsDocInfo = handleJsDoc(node);\n     Node irNode = justTransform(node);\n+    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n     if (jsDocInfo != null) {\n       irNode.setJSDocInfo(jsDocInfo);\n     }\n   }\n \n   private Node transformNameAsString(Name node) {\n-    JSDocInfo jsDocInfo = handleJsDoc(node);\n     Node irNode = transformDispatcher.processName(node, true);\n+    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n     if (jsDocInfo != null) {\n       irNode.setJSDocInfo(jsDocInfo);\n     }\n   }\n \n   private Node transformNumberAsString(NumberLiteral literalNode) {\n-    JSDocInfo jsDocInfo = handleJsDoc(literalNode);\n     Node irNode = newStringNode(getStringValue(literalNode.getNumber()));\n+    JSDocInfo jsDocInfo = handleJsDoc(literalNode, irNode);\n     if (jsDocInfo != null) {\n       irNode.setJSDocInfo(jsDocInfo);\n     }\n    * file-level JSDoc comments (@fileoverview and @license).\n    *\n    * @param node The JsDoc Comment node to parse.\n+   * @param irNode\n    * @return A JSDocInfoParser. Will contain either fileoverview jsdoc, or\n    *     normal jsdoc, or no jsdoc (if the method parses to the wrong level).\n    */\n-  private JsDocInfoParser createJsDocInfoParser(Comment node) {\n+  private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n     String comment = node.getValue();\n     int lineno = node.getLineno();\n     int position = node.getAbsolutePosition();\n                                lineno,\n                                position2charno(position) + numOpeningChars),\n           node,\n-          sourceFile,\n+          irNode,\n           config,\n           errorReporter);\n     jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.ScriptRuntime;\n import com.google.javascript.rhino.Token;\n-import com.google.javascript.rhino.jstype.SimpleSourceFile;\n-import com.google.javascript.rhino.jstype.StaticSourceFile;\n-\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n \n   private final JsDocTokenStream stream;\n   private final JSDocInfoBuilder jsdocBuilder;\n-  private final StaticSourceFile sourceFile;\n   private final String sourceName;\n+  private final Node associatedNode;\n   private final ErrorReporter errorReporter;\n   private final ErrorReporterParser parser = new ErrorReporterParser();\n \n \n   JsDocInfoParser(JsDocTokenStream stream,\n                   Comment commentNode,\n-                  StaticSourceFile sourceFile,\n+                  Node associatedNode,\n                   Config config,\n                   ErrorReporter errorReporter) {\n     this.stream = stream;\n-    this.sourceFile = sourceFile;\n+    this.associatedNode = associatedNode;\n \n     // Sometimes this will be null in tests.\n-    this.sourceName = sourceFile == null ? null : sourceFile.getName();\n+    this.sourceName = associatedNode == null ? \"\" : associatedNode.getSourceFileName();\n \n     this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);\n     if (commentNode != null) {\n     JsDocInfoParser parser = new JsDocInfoParser(\n         new JsDocTokenStream(typeString),\n         null,\n-        new SimpleSourceFile(\"typeparsing\", false),\n+        null,\n         config,\n         NullErrorReporter.forNewRhino());\n \n   private Node createTemplateNode() {\n     // The Node type choice is arbitrary.\n     Node templateNode = new Node(Token.SCRIPT);\n-    templateNode.setStaticSourceFile(sourceFile);\n+    templateNode.setStaticSourceFile(\n+      this.associatedNode != null ?\n+      this.associatedNode.getStaticSourceFile() :\n+      null);\n     return templateNode;\n   }\n \n   }\n \n   JSDocInfo retrieveAndResetParsedJSDocInfo() {\n-    return jsdocBuilder.build(sourceName);\n+    return jsdocBuilder.build(associatedNode);\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/JSDocInfo.java\n+++ b/src/com/google/javascript/rhino/JSDocInfo.java\n \n   private LazilyInitializedDocumentation documentation = null;\n \n-  /** The source file containing the JSDoc. */\n-  private String sourceName = null;\n+  // The Node this JSDoc is associated with.\n+  private Node associatedNode = null;\n \n   private Visibility visibility = null;\n \n     return documentation == null ? null : documentation.fileOverview;\n   }\n \n+  public Node getAssociatedNode() {\n+    return this.associatedNode;\n+  }\n+\n+  void setAssociatedNode(Node node) {\n+    this.associatedNode = node;\n+  }\n+\n   /** Gets the name of the source file that contains this JSDoc. */\n   public String getSourceName() {\n-    return sourceName;\n+    return this.associatedNode != null\n+        ? this.associatedNode.getSourceFileName() : null;\n   }\n \n   /** Gets the list of all markers for the documentation in this JSDoc. */\n   public Collection<Marker> getMarkers() {\n     return documentation == null ? null : documentation.markers;\n-  }\n-\n-  /** Sets the name of the source file that contains this JSDoc. */\n-  void setSourceName(String sourceName) {\n-    this.sourceName = sourceName;\n   }\n \n   /** Gets the template type name. */\n--- a/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n+++ b/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n    * returns it. Once this method is called, the builder can be reused to build\n    * another {@link JSDocInfo} object.\n    *\n-   * @param sourceName The source file containing the JSDoc.\n+   * @param associatedNode The source node containing the JSDoc.\n    * @return a {@link JSDocInfo} object populated with the values given to this\n    *     builder. If no value was populated, this method simply returns\n    *     {@code null}\n    */\n-  public JSDocInfo build(String sourceName) {\n+  public JSDocInfo build(Node associatedNode) {\n     if (populated) {\n       JSDocInfo built = currentInfo;\n-      built.setSourceName(sourceName);\n+      built.setAssociatedNode(associatedNode);\n       populateDefaults(built);\n       populated = false;\n       currentInfo = new JSDocInfo(this.parseDocumentation);\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n import com.google.javascript.jscomp.mozilla.rhino.ast.Comment;\n import com.google.javascript.jscomp.parsing.Config.LanguageMode;\n import com.google.javascript.jscomp.testing.TestErrorReporter;\n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.JSDocInfo.Visibility;\n import com.google.javascript.rhino.JSTypeExpression;\n \n   public void testSourceName() throws Exception {\n     JSDocInfo jsdoc = parse(\"@deprecated */\", true);\n-    assertEquals(\"testcode\", jsdoc.getSourceName());\n+    assertEquals(\"testcode\", jsdoc.getAssociatedNode().getSourceFileName());\n   }\n \n   public void testParseBlockComment() throws Exception {\n             new JsDocTokenStream(comment.getValue().substring(3),\n                 comment.getLineno()),\n             comment,\n-            file,\n+            null,\n             config,\n             testErrorReporter);\n       jsdocParser.parse();\n     Config config = new Config(extraAnnotations, extraSuppressions,\n         parseDocumentation, LanguageMode.ECMASCRIPT3, false);\n     StaticSourceFile file = new SimpleSourceFile(\"testcode\", false);\n+    Node associatedNode = new Node(Token.SCRIPT);\n+    associatedNode.setInputId(new InputId(file.getName()));\n+    associatedNode.setStaticSourceFile(file);\n     JsDocInfoParser jsdocParser = new JsDocInfoParser(\n         stream(comment),\n         new Comment(0, 0, CommentType.JSDOC, comment),\n-        file, config, errorReporter);\n+        associatedNode,\n+        config, errorReporter);\n \n     if (fileLevelJsDocBuilder != null) {\n       jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);", "timestamp": 1312475022, "metainfo": ""}