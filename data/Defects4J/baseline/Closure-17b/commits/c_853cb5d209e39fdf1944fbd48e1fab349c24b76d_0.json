{"sha": "853cb5d209e39fdf1944fbd48e1fab349c24b76d", "log": "fix up const-annotation tracking.  R=johnlenz DELTA=192  (89 added, 21 deleted, 82 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1203470   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AliasKeywords.java\n+++ b/src/com/google/javascript/jscomp/AliasKeywords.java\n \n   /** Aliases throw statements with a function call. */\n   // TODO(user): Generalize this to work with typeof expressions.\n-  private static class ThrowAliasSpecification extends AliasSpecification {\n+  private class ThrowAliasSpecification extends AliasSpecification {\n     ThrowAliasSpecification(String aliasName) {\n       super(aliasName, Token.THROW);\n     }\n \n     @Override\n     protected void aliasNode(Node throwNode, Node parent) {\n-      Node name = NodeUtil.newName(getAliasName(), throwNode, getAliasName());\n+      Node name = NodeUtil.newName(\n+          compiler.getCodingConvention(),\n+          getAliasName(), throwNode, getAliasName());\n       Node aliasCall = new Node(Token.CALL, name, throwNode.removeFirstChild());\n       Node exprResult = new Node(Token.EXPR_RESULT, aliasCall);\n       parent.replaceChild(throwNode, exprResult);\n     protected int minOccurrencesRequiredToAlias() {\n       return MIN_OCCURRENCES_REQUIRED_TO_ALIAS_THROW;\n     }\n-\n-    /**\n-     * Calculates the minimum number of occurrences of throw needed to alias\n-     * throw.\n-     */\n-    static int estimateMinOccurrencesRequriedToAlias() {\n-      // Assuming that the alias function name is two bytes in length, two bytes\n-      // will be saved per occurrence of throw:\n-      //   <code>throw e;</code>, compared to\n-      //   <code>TT(e);</code>.\n-      // However, the alias definition is some length, N, e.g.,\n-      //   <code>function TT(t){throw t;}</code>\n-      // Hence there must be more than N/2 occurrences of throw to reduce\n-      // the code size.\n-      Node alias = createAliasFunctionNode(\"TT\");\n-      return InlineCostEstimator.getCost(alias) / 2 + 1;\n-    }\n-\n-    /**\n-     * Creates a function node that takes a single argument, the object to\n-     * throw. The function throws the object.\n-     */\n-    private static Node createAliasFunctionNode(String aliasName) {\n-      Node parameterName = Node.newString(Token.NAME, \"jscomp_throw_param\");\n-      List<Node> parameters = Lists.newArrayList(parameterName.cloneNode());\n-      Node throwStatement = new Node(Token.THROW, parameterName);\n-      Node body = new Node(Token.BLOCK, throwStatement);\n-      return NodeUtil.newFunctionNode(aliasName, parameters, body, -1, -1);\n-    }\n+  }\n+\n+  /**\n+   * Calculates the minimum number of occurrences of throw needed to alias\n+   * throw.\n+   */\n+  static int estimateMinOccurrencesRequriedToAlias() {\n+    // Assuming that the alias function name is two bytes in length, two bytes\n+    // will be saved per occurrence of throw:\n+    //   <code>throw e;</code>, compared to\n+    //   <code>TT(e);</code>.\n+    // However, the alias definition is some length, N, e.g.,\n+    //   <code>function TT(t){throw t;}</code>\n+    // Hence there must be more than N/2 occurrences of throw to reduce\n+    // the code size.\n+    Node alias = createAliasFunctionNode(\"TT\");\n+    return InlineCostEstimator.getCost(alias) / 2 + 1;\n+  }\n+\n+  /**\n+   * Creates a function node that takes a single argument, the object to\n+   * throw. The function throws the object.\n+   */\n+  private static Node createAliasFunctionNode(String aliasName) {\n+    Node parameterName = Node.newString(Token.NAME, \"jscomp_throw_param\");\n+    List<Node> parameters = Lists.newArrayList(parameterName.cloneNode());\n+    Node throwStatement = new Node(Token.THROW, parameterName);\n+    Node body = new Node(Token.BLOCK, throwStatement);\n+    return NodeUtil.newFunctionNode(aliasName, parameters, body, -1, -1);\n   }\n \n   /** Aliases literal keywords (e.g., null) with variable names. */\n-  private static class KeywordAliasSpecification extends AliasSpecification {\n+  private class KeywordAliasSpecification extends AliasSpecification {\n     KeywordAliasSpecification(String aliasName, int tokenId) {\n       super(aliasName, tokenId);\n     }\n \n     @Override\n     protected void aliasNode(Node n, Node parent) {\n-      Node aliasNode = NodeUtil.newName(getAliasName(), n, getAliasName());\n+      Node aliasNode = NodeUtil.newName(\n+          compiler.getCodingConvention(), getAliasName(), n, getAliasName());\n       parent.replaceChild(n, aliasNode);\n     }\n \n     protected void insertAliasDeclaration(Node codeRoot) {\n       Node varNode = new Node(Token.VAR);\n       Node value = new Node(getTokenId());\n-      Node name = NodeUtil.newName(getAliasName(), varNode, getAliasName());\n+      Node name = NodeUtil.newName(\n+          compiler.getCodingConvention(), getAliasName(),\n+          varNode, getAliasName());\n       name.addChildToBack(value);\n       varNode.addChildToBack(name);\n       codeRoot.addChildrenToFront(varNode);\n    * MIN_OCCURRENCES_REQUIRED_TO_ALIAS_THROW times.\n    */\n   static final int MIN_OCCURRENCES_REQUIRED_TO_ALIAS_THROW =\n-      ThrowAliasSpecification.estimateMinOccurrencesRequriedToAlias();\n+      estimateMinOccurrencesRequriedToAlias();\n \n   /** Reference to JS Compiler */\n   private final AbstractCompiler compiler;\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n     //     string c\n     // AFTER:\n     //   name a$b$c\n-    Node ref = NodeUtil.newName(alias, n, originalName);\n+    Node ref = NodeUtil.newName(\n+        compiler.getCodingConvention(), alias, n, originalName);\n     NodeUtil.copyNameAnnotations(n.getLastChild(), ref);\n     parent.replaceChild(n, ref);\n     compiler.reportCodeChange();\n     Node greatGreatGramps = greatGramps.getParent();\n \n     // Create the new alias node.\n-    Node nameNode = NodeUtil.newName(alias, gramps.getFirstChild(),\n+    Node nameNode = NodeUtil.newName(\n+        compiler.getCodingConvention(), alias, gramps.getFirstChild(),\n         refName.fullName());\n     NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n \n       ref.node.getParent().removeChild(rvalue);\n \n       Node nameNode = NodeUtil.newName(\n+          compiler.getCodingConvention(),\n           alias, ref.node.getAncestor(2), n.fullName());\n \n       if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {\n--- a/src/com/google/javascript/jscomp/ExportTestFunctions.java\n+++ b/src/com/google/javascript/jscomp/ExportTestFunctions.java\n       Node scriptNode) {\n \n     Node call = new Node(Token.CALL, NodeUtil.newQualifiedNameNode(\n+        compiler.getCodingConvention(),\n         exportSymbolFunction, node, testFunctionName));\n     call.addChildToBack(Node.newString(testFunctionName));\n     call.addChildToBack(NodeUtil.newQualifiedNameNode(\n+        compiler.getCodingConvention(),\n         testFunctionName, node, testFunctionName));\n \n     Node expression = new Node(Token.EXPR_RESULT, call);\n--- a/src/com/google/javascript/jscomp/ExternExportsPass.java\n+++ b/src/com/google/javascript/jscomp/ExternExportsPass.java\n       if (!path.contains(\".\")) {\n         pathDefinition = NodeUtil.newVarNode(path, initializer);\n       } else {\n-        Node qualifiedPath = NodeUtil.newQualifiedNameNode(path, -1, -1);\n+        Node qualifiedPath = NodeUtil.newQualifiedNameNode(\n+            compiler.getCodingConvention(), path, -1, -1);\n         pathDefinition = NodeUtil.newExpr(new Node(Token.ASSIGN, qualifiedPath,\n             initializer));\n       }\n--- a/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n+++ b/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n     Node stmt = new Node(first.node.getType(),\n         new Node(Token.ASSIGN,\n             Node.newString(Token.NAME, prototypeAlias),\n-            NodeUtil.newQualifiedNameNode(className + \".prototype\",\n+            NodeUtil.newQualifiedNameNode(\n+                compiler.getCodingConvention(), className + \".prototype\",\n                 instance.parent, className + \".prototype\")))\n         .copyInformationFromForTree(first.node);\n \n     Node assignment = declar.node.getFirstChild();\n     Node lhs = assignment.getFirstChild();\n     Node name = NodeUtil.newQualifiedNameNode(\n+        compiler.getCodingConvention(),\n         prototypeAlias + \".\" + declar.memberName, declar.node,\n         declar.memberName);\n \n--- a/src/com/google/javascript/jscomp/GenerateExports.java\n+++ b/src/com/google/javascript/jscomp/GenerateExports.java\n       if (useExportSymbol) {\n         // exportSymbol(publicPath, object);\n         call = new Node(Token.CALL,\n-            NodeUtil.newQualifiedNameNode(exportSymbolFunction,\n+            NodeUtil.newQualifiedNameNode(\n+                compiler.getCodingConvention(), exportSymbolFunction,\n                 context.getNode(), export));\n         call.addChildToBack(Node.newString(export));\n-        call.addChildToBack(NodeUtil.newQualifiedNameNode(export,\n+        call.addChildToBack(NodeUtil.newQualifiedNameNode(\n+            compiler.getCodingConvention(), export,\n             context.getNode(), export));\n       } else {\n         // exportProperty(object, publicName, symbol);\n         String property = getPropertyName(node);\n         call = new Node(Token.CALL,\n             new Node[] {\n-                NodeUtil.newQualifiedNameNode(exportPropertyFunction,\n+                NodeUtil.newQualifiedNameNode(\n+                    compiler.getCodingConvention(), exportPropertyFunction,\n                     context.getNode(), exportPropertyFunction),\n-                NodeUtil.newQualifiedNameNode(parent,\n+                NodeUtil.newQualifiedNameNode(\n+                    compiler.getCodingConvention(), parent,\n                     context.getNode(), exportPropertyFunction),\n                 Node.newString(property),\n-                NodeUtil.newQualifiedNameNode(export,\n+                NodeUtil.newQualifiedNameNode(\n+                    compiler.getCodingConvention(), export,\n                     context.getNode(), exportPropertyFunction)\n             });\n       }\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    * @param charno The source character offset from start of the line.\n    * @return A NAME or GETPROP node\n    */\n-  public static Node newQualifiedNameNode(String name, int lineno, int charno) {\n+  public static Node newQualifiedNameNode(\n+      CodingConvention convention, String name, int lineno, int charno) {\n     int endPos = name.indexOf('.');\n     if (endPos == -1) {\n-      return Node.newString(Token.NAME, name, lineno, charno);\n-    }\n-    Node node = Node.newString(Token.NAME, name.substring(0, endPos),\n-                               lineno, charno);\n+      return newName(convention, name, lineno, charno);\n+    }\n+    Node node = newName(\n+        convention, name.substring(0, endPos), lineno, charno);\n     int startPos;\n     do {\n       startPos = endPos + 1;\n       String part = (endPos == -1\n                      ? name.substring(startPos)\n                      : name.substring(startPos, endPos));\n-      node = new Node(Token.GETPROP, node,\n-                      Node.newString(Token.STRING, part, lineno, charno),\n-                      lineno, charno);\n+      Node propNode = Node.newString(Token.STRING, part, lineno, charno);\n+      if (convention.isConstantKey(part)) {\n+        propNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+      }\n+      node = new Node(Token.GETPROP, node, propNode, lineno, charno);\n     } while (endPos != -1);\n \n     return node;\n    *\n    * @return A NAME or GETPROP node\n    */\n-  static Node newQualifiedNameNode(String name, Node basisNode,\n+  static Node newQualifiedNameNode(\n+      CodingConvention convention, String name, Node basisNode,\n       String originalName) {\n-    Node node = newQualifiedNameNode(name, -1, -1);\n+    Node node = newQualifiedNameNode(convention, name, -1, -1);\n     setDebugInformation(node, basisNode, originalName);\n     return node;\n   }\n     node.putProp(Node.ORIGINALNAME_PROP, originalName);\n   }\n \n+  private static Node newName(\n+      CodingConvention convention, String name, int lineno, int charno) {\n+    Node nameNode = Node.newString(Token.NAME, name, lineno, charno);\n+    if (convention.isConstant(name)) {\n+      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+    }\n+    return nameNode;\n+  }\n+\n   /**\n    * Creates a new node representing an *existing* name, copying over the source\n    * location information from the basis node.\n    *\n    * @return The node created.\n    */\n-  static Node newName(String name, Node basisNode) {\n+  static Node newName(\n+      CodingConvention convention, String name, Node basisNode) {\n     Node nameNode = Node.newString(Token.NAME, name);\n+    if (convention.isConstantKey(name)) {\n+      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+    }\n     nameNode.copyInformationFrom(basisNode);\n     return nameNode;\n   }\n    *\n    * @return The node created.\n    */\n-  static Node newName(String name, Node basisNode, String originalName) {\n-    Node nameNode = newName(name, basisNode);\n+  static Node newName(\n+      CodingConvention convention, String name,\n+      Node basisNode, String originalName) {\n+    Node nameNode = newName(convention, name, basisNode);\n     nameNode.putProp(Node.ORIGINALNAME_PROP, originalName);\n     return nameNode;\n   }\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n                 compiler.getCodingConvention(), n, parent);\n         boolean isMarkedConstant = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n         if (shouldBeConstant && !isMarkedConstant) {\n-          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n           if (assertOnChange) {\n             String name = n.getString();\n             throw new IllegalStateException(\n                 \"Unexpected const change.\\n\" +\n                 \"  name: \"+ name + \"\\n\" +\n-                \"  gramps:\" + n.getParent().getParent().toStringTree());\n+                \"  parent:\" + n.getParent().toStringTree());\n           }\n+          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         }\n       }\n     }\n           compiler, Lists.newArrayList(externs, root), this);\n     }\n \n-    private Map<String,Boolean> constantMap = Maps.newHashMap();\n+    private Map<String, Boolean> constantMap = Maps.newHashMap();\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n           (parent.getType() == Token.GETPROP &&\n            parent.getLastChild() == n);\n       if (n.getType() == Token.NAME || isProperty) {\n-        if (NodeUtil.isConstantByConvention(\n+        boolean isMarkedConstant = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n+        if (!isMarkedConstant &&\n+            NodeUtil.isConstantByConvention(\n                 compiler.getCodingConvention(), n, parent)) {\n+          if (assertOnChange) {\n+            String name = n.getString();\n+            throw new IllegalStateException(\n+                \"Unexpected const change.\\n\" +\n+                \"  name: \"+ name + \"\\n\" +\n+                \"  parent:\" + n.getParent().toStringTree());\n+          }\n           n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-          // TODO(nicksantos): Turn this on.\n-          // if (assertOnChange) {\n-          //   String name = n.getString();\n-          //   throw new IllegalStateException(\n-          //       \"Unexpected const change.\\n\" +\n-          //       \"  name: \"+ name + \"\\n\" +\n-          //       \"  gramps:\" + n.getParent().getParent().toStringTree());\n-          // }\n         }\n       }\n     }\n--- a/src/com/google/javascript/jscomp/ObjectPropertyStringPreprocess.java\n+++ b/src/com/google/javascript/jscomp/ObjectPropertyStringPreprocess.java\n       }\n \n       Node newFirstArgument = NodeUtil.newQualifiedNameNode(\n+          compiler.getCodingConvention(),\n           compiler.getCodingConvention().getGlobalObject(),\n           firstArgument.getLineno(), firstArgument.getCharno());\n       Node newSecondArgument = NodeUtil.newQualifiedNameNode(\n+          compiler.getCodingConvention(),\n           firstArgument.getQualifiedName() + \".\" +\n           firstArgument.getNext().getString(),\n           secondArgument.getLineno(), secondArgument.getCharno());\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n       n.replaceChild(\n           callee,\n           NodeUtil.newQualifiedNameNode(\n+            compiler.getCodingConvention(),\n             String.format(\"%s.call\", baseClassNode.getQualifiedName()),\n             callee, \"goog.base\"));\n       compiler.reportCodeChange();\n       n.replaceChild(\n           callee,\n           NodeUtil.newQualifiedNameNode(\n+            compiler.getCodingConvention(),\n             String.format(\"%s.superClass_.%s.call\",\n                 className.getQualifiedName(), methodName),\n             callee, \"goog.base\"));\n     private Node makeAssignmentExprNode(String namespace, Node node) {\n       Node decl = new Node(Token.EXPR_RESULT,\n           new Node(Token.ASSIGN,\n-              NodeUtil.newQualifiedNameNode(namespace, node, namespace),\n+              NodeUtil.newQualifiedNameNode(\n+                  compiler.getCodingConvention(), namespace, node, namespace),\n               createNamespaceLiteral()));\n       decl.putBooleanProp(Node.IS_NAMESPACE, true);\n       Preconditions.checkState(isNamespacePlaceholder(decl));\n--- a/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n+++ b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n         return nodeToInsertAfter;\n       }\n \n-      Node classNode = NodeUtil.newQualifiedNameNode(className, -1, -1);\n+      Node classNode = NodeUtil.newQualifiedNameNode(\n+          compiler.getCodingConvention(), className, -1, -1);\n \n       Node marker = Node.newString(\n               interfaceType == null ?\n    * values. We have checkers for value types, class types (user-defined and\n    * externed), and interface types.\n    */\n-  private static class AddChecks\n+  private class AddChecks\n       extends NodeTraversal.AbstractPostOrderCallback {\n \n     private final AbstractCompiler compiler;\n     compiler.reportCodeChange();\n   }\n \n-  private static Node jsCode(String prop) {\n-    return NodeUtil.newQualifiedNameNode(\"jscomp.typecheck.\" + prop, -1, -1);\n+  private Node jsCode(String prop) {\n+    return NodeUtil.newQualifiedNameNode(\n+        compiler.getCodingConvention(), \"jscomp.typecheck.\" + prop, -1, -1);\n   }\n \n   @VisibleForTesting\n--- a/src/com/google/javascript/jscomp/SpecializeModule.java\n+++ b/src/com/google/javascript/jscomp/SpecializeModule.java\n /**\n  * Beginnings of an optimization to specialize the initial module at the cost of\n  * increasing code in later modules. This is still very experimental.\n- * \n+ *\n  * High-level overview:\n- *  \n+ *\n  * This optimization replaces functions in the initial module with specialized\n  * versions that are only safe in the initial module. The original, general,\n  * versions of the functions are \"fixed up\" in later modules. This optimization\n  * can shrink the initial module significantly but the fixup code in later\n  * modules increases overall code size.\n- * \n+ *\n  * Implementation approach:\n- * \n+ *\n  * We take a ridiculously naive approach: remove the initial module\n  * from the rest of the AST, optimize it with existing optimization passes\n- * (recording which functions have been specialized), put it back in the AST, \n+ * (recording which functions have been specialized), put it back in the AST,\n  * and add fixups restoring the general versions of the functions in each module\n  * that depends on the initial module.\n- * \n+ *\n  * Since it is only safe to specialize functions that can be fixed up, we\n  * don't allow specialization of local functions and functions that\n  * are aliased.\n- * \n+ *\n  * We currently run three optimizations on the isolated AST: InlineFunctions,\n  * DevirtualizePrototypeMethods, and RemoveUnusedPrototypeProperties.\n- * \n+ *\n  * These optimizations rely on a coarse-grained name-based analysis to\n  * maintain safety properties and thus are likely to see some benefit when\n  * applied in isolation.\n- * \n+ *\n  * InlineFunctions is truly specializing -- it replaces functions with\n  * versions that have calls to other functions inlined into them, while\n  * RemoveUnusedPrototypeProperties is really just removing properties that\n  * aren't used in the initial module and adding copies further down in the\n  * module graph. It would probably be more elegant to give\n  * CrossModuleMethodMotion permission to make copies of methods instead.\n- * \n+ *\n  * There are additional passes that might benefit from being made\n  * specialization-aware:\n- * \n- * - OptimizeParameters \n- * \n+ *\n+ * - OptimizeParameters\n+ *\n  * - Any pass that is too slow to run over the entire AST but might\n  *      be acceptable on only the initial module:\n  *  - RemoveUnusedNames\n- *  \n+ *\n  *  - Also, any pass that uses the results of PureFunctionIdentifier to\n  *  determine when it is safe to remove code might benefit (e.g. the peephole\n  *  passes), since PureFunctionIdentifier relies on SimpleDefinitionFinder,\n  *  which would be more precise when running on only the initial module.\n- * \n+ *\n  * @author dcc@google.com (Devin Coughlin)\n  */\n public class SpecializeModule implements CompilerPass {\n   private AbstractCompiler compiler;\n-  \n+\n   private Map<Node, Node> specializedInputRootsByOriginal;\n-  \n+\n   private Map<Node, OriginalFunctionInformation>\n       functionInfoBySpecializedFunctionNode;\n-  \n+\n   private SpecializationState specializationState;\n-  \n+\n   private final PassFactory[] specializationPassFactories;\n-  \n+\n   public SpecializeModule(AbstractCompiler compiler,\n       PassFactory ...specializationPassFactories) {\n     this.compiler = compiler;\n     this.specializationPassFactories = specializationPassFactories;\n   }\n-  \n+\n   /**\n    * Performs initial module specialization.\n-   * \n+   *\n    * The process is as follows:\n-   * \n+   *\n    * 1) Make a copy of each of the inputs in the initial root and put them\n    * in a fake AST that looks like it is the whole program.\n-   * \n+   *\n    * 2) Run the specializing compiler passes over the fake initial module AST\n    * until it reaches a fixed point, recording which functions are specialized\n    * or removed.\n-   * \n+   *\n    * 3) Replace the original input roots with the specialized input roots\n-   * \n+   *\n    * 4) For each module that directly depends on the initial module, add\n    * fixups for the specialized and removed functions. Right now we add\n    * fixups for for every function that was specialzed or removed -- we could\n    * be smarter about this and for each dependent module only add the functions\n    * that it needs.\n-   * \n+   *\n    * 5) Add dummy variables declaring the removed function to the end of\n    * the now-specialized initial module. This is needed to keep\n    * {@link VarCheck} from complaining.\n   @Override\n   public void process(Node externs, Node root) {\n     JSModuleGraph moduleGraph = compiler.getModuleGraph();\n-    \n+\n     // Can't perform optimization without a module graph!\n     if (moduleGraph == null) {\n       return;\n     }\n-    \n+\n     JSModule module = moduleGraph.getRootModule();\n-      \n+\n     Node fakeModuleRoot = copyModuleInputs(module);\n-    \n+\n     SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n-    \n+\n     defFinder.process(externs, fakeModuleRoot);\n-    \n-    SimpleFunctionAliasAnalysis initialModuleFunctionAliasAnalysis = \n+\n+    SimpleFunctionAliasAnalysis initialModuleFunctionAliasAnalysis =\n         new SimpleFunctionAliasAnalysis();\n-    \n-    initialModuleFunctionAliasAnalysis.analyze(defFinder); \n-    \n+\n+    initialModuleFunctionAliasAnalysis.analyze(defFinder);\n+\n     specializationState =\n         new SpecializationState(initialModuleFunctionAliasAnalysis);\n-    \n+\n     do {\n       specializationState.resetHasChanged();\n-         \n+\n       for (SpecializationAwareCompilerPass pass : createSpecializingPasses()) {\n         pass.enableSpecialization(specializationState);\n         pass.process(externs, fakeModuleRoot);\n       }\n-    } while(specializationState.hasChanged()); \n-    \n+    } while(specializationState.hasChanged());\n+\n     // We must always add dummy variables before replacing the orginal module.\n     addDummyVarDeclarationsToInitialModule(module);\n-    replaceOriginalModuleInputsWithSpecialized();    \n-    addOriginalFunctionVersionsToDependentModules(module);   \n-  }\n-  \n+    replaceOriginalModuleInputsWithSpecialized();\n+    addOriginalFunctionVersionsToDependentModules(module);\n+  }\n+\n   /**\n    * Returns a collection of new instances of specializing passes.\n    */\n-  private Collection<SpecializationAwareCompilerPass> \n+  private Collection<SpecializationAwareCompilerPass>\n       createSpecializingPasses() {\n-    \n+\n     Collection<SpecializationAwareCompilerPass> passes = Lists.newLinkedList();\n-    \n+\n     for (PassFactory passFactory : specializationPassFactories) {\n       CompilerPass pass = passFactory.createInternal(compiler);\n-      \n-      Preconditions.checkState(pass instanceof \n+\n+      Preconditions.checkState(pass instanceof\n           SpecializationAwareCompilerPass);\n-      \n+\n       passes.add((SpecializationAwareCompilerPass) pass);\n     }\n-    \n+\n     return passes;\n   }\n-  \n+\n   /**\n    * Creates an AST that consists solely of copies of the input roots for the\n    * passed in module.\n-   * \n+   *\n    * Also records a map in {@link #functionInfoBySpecializedFunctionNode}\n    * of information about the original function keyed on the copies of the\n    * functions to specialized.\n    */\n   private Node copyModuleInputs(JSModule module) {\n-    \n+\n     specializedInputRootsByOriginal = Maps.newLinkedHashMap();\n-    \n+\n     functionInfoBySpecializedFunctionNode = Maps.newLinkedHashMap();\n-    \n+\n     Node syntheticModuleJsRoot = new Node(Token.BLOCK);\n     syntheticModuleJsRoot.setIsSyntheticBlock(true);\n-    \n+\n     for (CompilerInput input : module.getInputs()) {\n       Node originalInputRoot = input.getAstRoot(compiler);\n-      \n+\n       Node copiedInputRoot = originalInputRoot.cloneTree();\n       copiedInputRoot.copyInformationFromForTree(originalInputRoot);\n-      \n+\n       specializedInputRootsByOriginal.put(originalInputRoot,\n           copiedInputRoot);\n-      \n+\n       matchTopLevelFunctions(originalInputRoot, copiedInputRoot);\n-      \n+\n       syntheticModuleJsRoot.addChildToBack(copiedInputRoot);\n     }\n-    \n+\n     // The jsRoot needs a parent (in a normal compilation this would be the\n     // node that contains jsRoot and the externs).\n     Node syntheticExternsAndJsRoot = new Node(Token.BLOCK);\n     syntheticExternsAndJsRoot.addChildToBack(syntheticModuleJsRoot);\n-    \n+\n     return syntheticModuleJsRoot;\n   }\n-  \n+\n   /**\n    * Records information about original functions and creates a map from\n    * the specialized functions to this information.\n-   * \n+   *\n    * This information is only recorded for global functions since non-global\n    * functions cannot be inlined.\n-   * \n+   *\n    * @param original An original input root.\n-   * @param toBeSpecialized A copy of the input root (the copy to be \n+   * @param toBeSpecialized A copy of the input root (the copy to be\n    * specialized)\n    */\n-  private void matchTopLevelFunctions(Node original, Node toBeSpecialized) {  \n-    new NodeMatcher() {   \n+  private void matchTopLevelFunctions(Node original, Node toBeSpecialized) {\n+    new NodeMatcher() {\n       @Override\n       public void reportMatch(Node original, Node specialized) {\n         if (NodeUtil.isFunction(original)) {\n-          OriginalFunctionInformation functionInfo = \n+          OriginalFunctionInformation functionInfo =\n               new OriginalFunctionInformation(original);\n-         \n+\n           functionInfoBySpecializedFunctionNode.put(specialized,\n               functionInfo);\n-        }       \n-      }\n-      \n+        }\n+      }\n+\n       @Override\n       public boolean shouldTraverse(Node n1, Node n2) {\n         return !NodeUtil.isFunction(n1);\n       }\n     }.match(original, toBeSpecialized);\n   }\n-  \n+\n   /**\n    * Replaces the original input roots of the initial module with\n    * their specialized versions.\n-   * \n+   *\n    * (Since {@link JsAst} holds a pointer to original inputs roots, we actually\n    * replace the all the children of the root rather than swapping the\n    * root pointers).\n   private void replaceOriginalModuleInputsWithSpecialized() {\n     for (Node original : specializedInputRootsByOriginal.keySet()) {\n       Node specialized = specializedInputRootsByOriginal.get(original);\n-      \n+\n       original.removeChildren();\n-      \n+\n       List<Node> specializedChildren = Lists.newLinkedList();\n-      \n+\n       while (specialized.getFirstChild() != null) {\n         original.addChildToBack(specialized.removeFirstChild());\n       }\n     }\n   }\n-  \n-  /**\n-   * Adds dummy variable declarations for all the function declarations we've \n+\n+  /**\n+   * Adds dummy variable declarations for all the function declarations we've\n    * removed to the end of the initial module.\n-   * \n+   *\n    * We do this to make {@link VarCheck} happy, since it requires variables to\n    * be declared before they are used in the whole program AST and doesn't\n    * like it when they are declared multiple times.\n-   * \n+   *\n    * TODO(dcc): Be smarter about whether we need a VAR here or not.\n    */\n   private void addDummyVarDeclarationsToInitialModule(JSModule module) {\n     for (Node modifiedFunction :\n-      functionInfoBySpecializedFunctionNode.keySet()) {      \n+      functionInfoBySpecializedFunctionNode.keySet()) {\n      if (specializationState.getRemovedFunctions().contains(modifiedFunction)) {\n        OriginalFunctionInformation originalInfo =\n          functionInfoBySpecializedFunctionNode.get(modifiedFunction);\n-       \n+\n        if (originalInfo.name != null && originalInfo.originalWasDeclaration()) {\n          Node block = specializationState.removedFunctionToBlock.get(\n              modifiedFunction);\n            Node originalRoot = specializedInputRootsByOriginal.get(block);\n            block.addChildrenToBack(originalInfo.generateDummyDeclaration());\n          }\n-       }     \n+       }\n      }\n     }\n   }\n-  \n+\n   /**\n    * Adds a copy of the original versions of specialized/removed functions\n    * to each of the dependents of module.\n-   * \n+   *\n    * Currently we add all of these functions to all dependents; it\n    * would be more efficient to only add the functions that could be used.\n-   * \n+   *\n    * TODO(dcc): Only add fixup functions where needed.\n    */\n   private void addOriginalFunctionVersionsToDependentModules(JSModule module) {\n     for (JSModule directDependent : getDirectDependents(module)) {\n       CompilerInput firstInput = directDependent.getInputs().get(0);\n       Node firstInputRootNode = firstInput.getAstRoot(compiler);\n-      \n+\n       // We don't iterate specializedFunctions directly because want to maintain\n       // and specializedFunctions in source order, rather than\n       // in the order that some optimization specialized the function.\n-      \n+\n       // So since we're adding to the front of the module each time, we\n       // have to iterate in reverse source order.\n-      \n+\n       List<Node> possiblyModifiedFunctions =\n         Lists.newArrayList(functionInfoBySpecializedFunctionNode.keySet());\n-      \n+\n       Collections.reverse(possiblyModifiedFunctions);\n-      \n-      for (Node modifiedFunction : possiblyModifiedFunctions) {   \n+\n+      for (Node modifiedFunction : possiblyModifiedFunctions) {\n         boolean declarationWasSpecialized =\n           specializationState.getSpecializedFunctions()\n           .contains(modifiedFunction);\n-        \n-        boolean declarationWasRemoved = \n+\n+        boolean declarationWasRemoved =\n             specializationState.getRemovedFunctions()\n             .contains(modifiedFunction);\n-        \n+\n         if (declarationWasSpecialized || declarationWasRemoved) {\n           OriginalFunctionInformation originalInfo =\n                functionInfoBySpecializedFunctionNode.get(modifiedFunction);\n-           \n+\n            // Don't add unspecialized versions of anonymous functions\n            if (originalInfo.name != null) {\n-             Node newDefinition = \n+             Node newDefinition =\n                originalInfo.generateFixupDefinition();\n-             \n+\n              firstInputRootNode.addChildrenToFront(newDefinition);\n-           }         \n-        }       \n-      }\n-    }\n-  }\n-  \n+           }\n+        }\n+      }\n+    }\n+  }\n+\n   /**\n    * Returns a list of modules that directly depend on the given module.\n-   * \n+   *\n    * This probably deserves to be in JSModuleGraph.\n    */\n   public Collection<JSModule> getDirectDependents(JSModule module) {\n     Set<JSModule> directDependents = Sets.newHashSet();\n-    \n+\n     for (JSModule possibleDependent :\n           compiler.getModuleGraph().getAllModules()) {\n       if (possibleDependent.getDependencies().contains(module)) {\n-        directDependents.add(possibleDependent);       \n-      }\n-    }\n-    \n+        directDependents.add(possibleDependent);\n+      }\n+    }\n+\n     return directDependents;\n   }\n-    \n+\n   /**\n    * A simple abstract classes that takes two isomorphic ASTs and walks\n    * each of them together, reporting matches to subclasses.\n-   * \n+   *\n    * This could probably be hardened and moved to NodeUtil\n    */\n   private abstract static class NodeMatcher {\n-   \n+\n     /**\n      * Calls {@link #reportMatch(Node, Node)} for each pair of matching nodes\n      * from the two ASTs.\n-     * \n+     *\n      * The two ASTs must be isomorphic. Currently no error checking is\n      * performed to ensure that this is the case.\n      */\n     public void match(Node ast1, Node ast2) {\n       // Just blunder ahead and assume that the two nodes actually match\n-        \n+\n       reportMatch(ast1, ast2);\n-      \n+\n       if (shouldTraverse(ast1, ast2)) {\n         Node childOf1 = ast1.getFirstChild();\n         Node childOf2 = ast2.getFirstChild();\n-        \n+\n         while (childOf1 != null) {\n           match(childOf1, childOf2);\n           childOf1 = childOf1.getNext();\n           childOf2 = childOf2.getNext();\n         }\n       }\n-      \n-    }\n-    \n+\n+    }\n+\n     /**\n      * Subclasses should override to add their own behavior when two nodes\n      * are matched.\n-     * @param n1 A node from the AST passed as ast1 in \n+     * @param n1 A node from the AST passed as ast1 in\n      * {@link #match(Node, Node)}.\n-     * @param n2 A node from the AST passed as ast1 in \n+     * @param n2 A node from the AST passed as ast1 in\n      * {@link #match(Node, Node)}.\n      */\n     public abstract void reportMatch(Node n1, Node n2);\n-    \n+\n     /**\n      * Subclasses should override to determine whether matching should proceed\n      * under a subtree.\n   /**\n    * A class that stores information about the original version of a\n    * function that will be/was specialized or removed.\n-   * \n+   *\n    * This class stores:\n    * - how the function was defined\n    * - a copy of the original function\n    */\n-  private static class OriginalFunctionInformation {\n+  private class OriginalFunctionInformation {\n     private String name;\n-    \n-    /**\n-     *  a = function() {} if true; \n+\n+    /**\n+     *  a = function() {} if true;\n      *  function a() {} otherwise\n-     */   \n-    private boolean isAssignFunction; \n-    \n+     */\n+    private boolean isAssignFunction;\n+\n     private boolean assignHasVar;\n-    \n+\n     private Node originalFunctionCopy;\n-    \n+\n     public OriginalFunctionInformation(Node originalFunction) {\n       name = NodeUtil.getFunctionName(originalFunction);\n-      \n+\n       originalFunctionCopy = originalFunction.cloneTree();\n       originalFunctionCopy.copyInformationFromForTree(originalFunction);\n-      \n+\n       Node originalParent = originalFunction.getParent();\n-      \n+\n       isAssignFunction = NodeUtil.isAssign(originalParent) ||\n           NodeUtil.isName(originalParent);\n-      \n+\n       assignHasVar =\n           isAssignFunction && NodeUtil.isVar(originalParent.getParent());\n     }\n-    \n+\n     private Node copiedOriginalFunction() {\n       // Copy of a copy\n       Node copy = originalFunctionCopy.cloneTree();\n       copy.copyInformationFromForTree(originalFunctionCopy);\n-      \n+\n       return copy;\n     }\n-    \n+\n     /**\n      * Did the original function add its name to scope?\n      * (If so, and specialization removes it, then we'll have to\n     private boolean originalWasDeclaration() {\n       return (!isAssignFunction) || (assignHasVar);\n     }\n-        \n+\n     /**\n      * Generates a definition of the original function that can be added as\n      * a fixup in the modules that directly depend on the specialized module.\n-     * \n+     *\n      * <PRE>\n      * The trick here is that even if the original function is declared as:\n-     * \n+     *\n      * function foo() {\n      *   // stuff\n      * }\n-     * \n+     *\n      * the fixup will have to be of the form\n-     * \n+     *\n      * foo = function() {\n      *   // stuff\n      * }\n      * </PRE>\n-     * \n-     */\n-    private Node generateFixupDefinition() {  \n+     *\n+     */\n+    private Node generateFixupDefinition() {\n       Node functionCopy = copiedOriginalFunction();\n-  \n+\n       Node nameNode;\n-       \n+\n       if (isAssignFunction) {\n         nameNode =\n-           NodeUtil.newQualifiedNameNode(name, functionCopy, name);\n+           NodeUtil.newQualifiedNameNode(\n+               compiler.getCodingConvention(), name, functionCopy, name);\n       } else {\n         // Grab the name node from the original function and make that\n         // function anonymous.\n         nameNode = functionCopy.getFirstChild();\n         functionCopy.replaceChild(nameNode,\n-            NodeUtil.newName(\"\", nameNode));\n-      }\n-          \n+            NodeUtil.newName(compiler.getCodingConvention(), \"\", nameNode));\n+      }\n+\n       Node assignment = new Node(Token.ASSIGN, nameNode, functionCopy);\n       assignment.copyInformationFrom(functionCopy);\n \n       return NodeUtil.newExpr(assignment);\n     }\n-    \n+\n     /**\n      * Returns a new dummy var declaration for the function with no initial\n      * value:\n-     * \n+     *\n      * var name;\n      */\n     private Node generateDummyDeclaration() {\n       Node declaration = NodeUtil.newVarNode(name, null);\n       declaration.copyInformationFromForTree(originalFunctionCopy);\n-      \n+\n       return declaration;\n     }\n   }\n-  \n+\n   /**\n    * A class to hold state during SpecializeModule. An instance of this class\n    * is passed to specialization-aware compiler passes -- they use it to\n    * communicate with SpecializeModule.\n-   * \n-   * SpecializationAware optimizations are required to keep track of the \n+   *\n+   * SpecializationAware optimizations are required to keep track of the\n    * functions they remove and the functions that they modify so that the fixups\n    * can be added. However, not all functions can be fixed up.\n-   * \n-   * Specialization-aware classes *must* call \n+   *\n+   * Specialization-aware classes *must* call\n    * {@link #reportSpecializedFunction} when a function is modified during\n    * specialization and {@link #reportRemovedFunction} when one is removed.\n-   * \n+   *\n    * Also, when specializing, they must query {@link #canFixupFunction}\n    * before modifying a function.\n-   * \n-   * This two-way communication, is the reason we don't use \n+   *\n+   * This two-way communication, is the reason we don't use\n    * {@link AstChangeProxy} to report code changes.\n    */\n   public static class SpecializationState {\n-    \n-    /** \n+\n+    /**\n      * The functions that the pass has specialized. These functions will\n      * be fixed up in non-specialized modules to their more general versions.\n-     * \n+     *\n      * This field is also used to determine whether specialization is enabled.\n      * If not null, specialization is enabled, otherwise it is disabled.\n      */\n     private Set<Node> specializedFunctions;\n-    \n-    /**\n-     * The functions that the pass has removed. These functions will be \n+\n+    /**\n+     * The functions that the pass has removed. These functions will be\n      * redefined in non-specialized modules.\n      */\n     private Set<Node> removedFunctions;\n-    \n+\n     private Map<Node, Node> removedFunctionToBlock;\n-    \n+\n     private SimpleFunctionAliasAnalysis initialModuleAliasAnalysis;\n-    \n+\n     /** Will be true if any new functions have been removed or specialized since\n      * {@link #resetHasChanged}.\n      */\n     private boolean hasChanged = false;\n-     \n-    public SpecializationState(SimpleFunctionAliasAnalysis \n+\n+    public SpecializationState(SimpleFunctionAliasAnalysis\n         initialModuleAliasAnalysis) {\n-      \n+\n       this.initialModuleAliasAnalysis = initialModuleAliasAnalysis;\n-      \n+\n       specializedFunctions = Sets.newLinkedHashSet();\n       removedFunctions = Sets.newLinkedHashSet();\n       removedFunctionToBlock = Maps.newLinkedHashMap();\n     }\n-    \n+\n     /**\n      * Returns true if any new functions have been reported as removed or\n      * specialized since {@link #resetHasChanged()} was last called.\n     private boolean hasChanged() {\n       return hasChanged;\n     }\n-    \n+\n     private void resetHasChanged() {\n       hasChanged = false;\n     }\n-    \n+\n     /**\n      * Returns the functions specialized by this compiler pass.\n      */\n     public Set<Node> getSpecializedFunctions() {\n       return specializedFunctions;\n     }\n-    \n+\n     /**\n      * Reports that a function has been specialized.\n-     * \n+     *\n      * @param functionNode A specialized AST node with type Token.FUNCTION\n      */\n     public void reportSpecializedFunction(Node functionNode) {\n         hasChanged = true;\n       }\n     }\n-    \n+\n     /**\n      * Reports that the function containing the node has been specialized.\n      */\n     public void reportSpecializedFunctionContainingNode(Node node) {\n       Node containingFunction = containingFunction(node);\n-      \n+\n       if (containingFunction != null) {\n         reportSpecializedFunction(containingFunction);\n       }\n     }\n-    \n+\n     /**\n      * The functions removed by this compiler pass.\n      */\n     public Set<Node> getRemovedFunctions() {\n       return removedFunctions;\n     }\n-    \n+\n     /**\n      * Reports that a function has been removed.\n-     * \n+     *\n      * @param functionNode A removed AST node with type Token.FUNCTION\n      * @param declaringBlock If the function declaration puts a variable in the\n      *    scope, we need to have a VAR statement in the scope where the\n         removedFunctionToBlock.put(functionNode, declaringBlock);\n       }\n     }\n-    \n+\n     /**\n      * Returns true if the function can be fixed up (that is, if it can be\n      * safely removed or specialized).\n-     * \n+     *\n      * <p>In order to be safely fixed up, a function must be:\n      * <PRE>\n      * - in the global scope\n      *    var ns = {}; ns.f = function() {}\n      *    SomeClass.prototype.foo = function() {};\n      * </PRE>\n-     * \n+     *\n      * <p>Anonymous functions cannot be safely fixed up, nor can functions\n      * that have been aliased.\n-     * \n+     *\n      * <p>Some functions declared as object literals could be safely fixed up,\n-     * however we do not currently support this. \n+     * however we do not currently support this.\n      */\n     public boolean canFixupFunction(Node functionNode) {\n       Preconditions.checkArgument(NodeUtil.isFunction(functionNode));\n-      \n+\n       if (!nodeIsInGlobalScope(functionNode) ||\n           initialModuleAliasAnalysis.isAliased(functionNode)) {\n         return false;\n       }\n-      \n+\n       if (NodeUtil.isStatement(functionNode)) {\n         // function F() {}\n         return true;\n       }\n-      \n-      Node parent = functionNode.getParent();    \n+\n+      Node parent = functionNode.getParent();\n       Node gramps = parent.getParent();\n-      \n+\n       if (NodeUtil.isName(parent) && NodeUtil.isVar(gramps)) {\n         // var f = function() {}\n         return true;\n       }\n-      \n+\n       if (NodeUtil.isExprAssign(gramps)\n           && parent.getChildAtIndex(1) == functionNode) {\n         // f = function() {}\n         // ns.f = function() {}\n         return true;\n       }\n-      \n+\n       return false;\n     }\n-    \n+\n     /**\n      * Returns true if the function containing n can be fixed up.\n      * Also returns true if n is in the global scope -- since it is always safe\n         return true;\n       }\n     }\n-    \n+\n     /**\n      * Returns true if a node is in the global scope; false otherwise.\n      */\n     private boolean nodeIsInGlobalScope(Node node) {\n       return containingFunction(node) == null;\n     }\n-    \n+\n     /**\n      * Returns the function containing the node, or null if none exists.\n      */", "timestamp": 1289846921, "metainfo": ""}