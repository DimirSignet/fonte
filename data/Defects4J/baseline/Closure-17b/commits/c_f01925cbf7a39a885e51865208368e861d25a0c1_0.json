{"sha": "f01925cbf7a39a885e51865208368e861d25a0c1", "log": "Tests for deps generation (Nick) R=andrew  Fix for decomposing assignment-ops. (john) R=alan DELTA=159  (127 added, 21 deleted, 11 changed)  Remove unneeded imports. (John) R=robert DELTA=2  (0 added, 2 deleted, 0 changed)  Automated rollback of: Remove now unneeded checks for label names when inspecting NAME nodes. (Robert) R=Alan DELTA=6  (4 added, 0 deleted, 2 changed)  Automated rollback of: Don't use NAME for label names, introduce LABEL_NAME. This improves the correctness of the compiler as many passes don't distinguish between label names and variable names appropriately. (Robert) R=Alan DELTA=57  (12 added, 29 deleted, 16 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=gydkaf   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n         }\n         break;\n \n-      case Token.LABEL_NAME:\n-        Preconditions.checkState(!n.getString().isEmpty());\n-        addIdentifier(n.getString());\n-        break;\n-\n       case Token.NAME:\n         if (first == null || first.getType() == Token.EMPTY) {\n           addIdentifier(n.getString());\n             addExpr(first, 0, getContextForNoInOperator(context));\n           }\n         }\n+\n         break;\n \n       case Token.ARRAYLIT:\n         Preconditions.checkState(childCount <= 1);\n         add(\"continue\");\n         if (childCount == 1) {\n-          Preconditions.checkState(first.getType() == Token.LABEL_NAME);\n           add(\" \");\n           add(first);\n         }\n         Preconditions.checkState(childCount <= 1);\n         add(\"break\");\n         if (childCount == 1) {\n-          Preconditions.checkState(first.getType() == Token.LABEL_NAME);\n           add(\" \");\n           add(first);\n         }\n \n       case Token.LABEL:\n         Preconditions.checkState(childCount == 2);\n-        Preconditions.checkState(first.getType() == Token.LABEL_NAME);\n         add(first);\n         add(\":\");\n         addNonEmptyExpression(\n--- a/src/com/google/javascript/jscomp/CompilerInput.java\n+++ b/src/com/google/javascript/jscomp/CompilerInput.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n-import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n import com.google.javascript.jscomp.deps.DependencyInfo;\n import com.google.javascript.jscomp.deps.JsFileParser;\n import com.google.javascript.rhino.Node;\n--- a/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n+++ b/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n     }\n   }\n \n+  private boolean isConstantName(Node n, Set<String> knownConstants) {\n+    // Non-constant names values may have been changed.\n+    return NodeUtil.isName(n) && (NodeUtil.isConstantName(n)\n+        || knownConstants.contains(n.getString()));\n+  }\n+\n   /**\n    * @param expr The expression to extract.\n    * @param injectionPoint The node before which to added the extracted\n    */\n   private Node extractExpression(Node expr, Node injectionPoint) {\n     Node parent = expr.getParent();\n-    // The temp value is known to be constant.\n+\n+    boolean isLhsOfAssignOp = NodeUtil.isAssignmentOp(parent)\n+        && !NodeUtil.isAssign(parent)\n+        && parent.getFirstChild() == expr;\n+\n+    Node firstExtractedNode = null;\n+\n+    // Expressions on the LHS of an assignment-op must have any possible\n+    // side-effects extracted as the value must be duplicated:\n+    //    next().foo += 2;\n+    // becomes:\n+    //    var t1 = next();\n+    //    t1.foo = t1.foo + 2;\n+    if (isLhsOfAssignOp && NodeUtil.isGet(expr)) {\n+      for (Node n : expr.children()) {\n+        if (n.getType() != Token.STRING && !isConstantName(n, knownConstants)) {\n+          Node extractedNode = extractExpression(n, injectionPoint);\n+          if (firstExtractedNode == null) {\n+            firstExtractedNode = extractedNode;\n+          }\n+        }\n+      }\n+    }\n+\n+    // The temp is known to be constant.\n     String tempName = getTempConstantValueName();\n-\n-    // Replace the expression with the temporary name.\n     Node replacementValueNode = Node.newString(Token.NAME, tempName);\n-    parent.replaceChild(expr, replacementValueNode);\n+\n+    Node tempNameValue;\n+\n+    // If it is ASSIGN_XXX, keep the assignment in place and extract the\n+    // original value of the LHS operand.\n+    if (isLhsOfAssignOp) {\n+      Preconditions.checkState(NodeUtil.isName(expr) || NodeUtil.isGet(expr));\n+      // Transform \"x += 2\" into \"x = temp + 2\"\n+      Node opNode = new Node(NodeUtil.getOpFromAssignmentOp(parent))\n+          .copyInformationFrom(parent);\n+\n+      Node rightOperand = parent.getLastChild();\n+\n+      parent.setType(Token.ASSIGN);\n+      parent.replaceChild(rightOperand, opNode);\n+      opNode.addChildToFront(replacementValueNode);\n+      opNode.addChildToBack(rightOperand);\n+\n+      // The original expression is still being used, so make a clone.\n+      tempNameValue = expr.cloneTree();\n+    } else {\n+      // Replace the expression with the temporary name.\n+      parent.replaceChild(expr, replacementValueNode);\n+\n+      // Keep the original node so that CALL expressions can still be found\n+      // and inlined properly.\n+      tempNameValue = expr;\n+    }\n \n     // Re-add the expression in the declaration of the temporary name.\n     Node tempNameNode = Node.newString(Token.NAME, tempName);\n-    tempNameNode.addChildrenToBack(expr);\n+    tempNameNode.addChildToBack(tempNameValue);\n     Node tempVarNode = new Node(Token.VAR, tempNameNode);\n \n     Node injectionPointParent = injectionPoint.getParent();\n     injectionPointParent.addChildBefore(tempVarNode, injectionPoint);\n \n-    // If it is ASSIGN_XXX we need to assign it back to the original value.\n-    // Note that calling the temp constant is a lie in this case, but we do know\n-    // that it is not modified until after the exposed expression.\n-    if (NodeUtil.isAssignmentOp(parent) && !NodeUtil.isAssign(parent)) {\n-      Node gParent = parent.getParent();\n-      Node assignBack = new Node(Token.ASSIGN,\n-          expr.cloneTree(),\n-          tempNameNode.cloneNode());\n-      if (NodeUtil.isExpressionNode(gParent)) {\n-        gParent.getParent().addChildAfter(\n-            NodeUtil.newExpr(assignBack), gParent);\n-      } else {\n-        // TODO(user): Use comma here sucks. We might close some accuracy\n-        // in flow sensitive passes but as far as I know it is unavoidable.\n-        Node comma = new Node(Token.COMMA);\n-        gParent.replaceChild(parent, comma);\n-        comma.addChildrenToFront(assignBack);\n-        comma.addChildrenToFront(parent);\n-      }\n-    }\n-    return tempVarNode;\n+    if (firstExtractedNode == null) {\n+      firstExtractedNode = tempVarNode;\n+    }\n+    return firstExtractedNode;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n+++ b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n \n         // Add label\n         Node label = new Node(Token.LABEL);\n-        Node name = Node.newString(Token.LABEL_NAME, labelName);\n+        Node name = Node.newString(Token.NAME, labelName);\n         label.addChildToFront(name);\n         label.addChildToBack(block);\n \n       Preconditions.checkState(NodeUtil.isStatementBlock(parent));\n \n       Node resultNode = getReplacementReturnStatement(current, resultName);\n-      Node name = Node.newString(Token.LABEL_NAME, labelName);\n+      Node name = Node.newString(Token.NAME, labelName);\n       Node breakNode = new Node(Token.BREAK, name);\n \n       // Replace the node in parent, and reset current to the first new child.\n--- a/src/com/google/javascript/jscomp/GatherRawExports.java\n+++ b/src/com/google/javascript/jscomp/GatherRawExports.java\n   private boolean isGlobalThisObject(NodeTraversal t, Node n) {\n     if (n.getType() == Token.THIS) {\n       return t.inGlobalScope();\n-    } else if (n.getType() == Token.NAME) {\n+    } else if (n.getType() == Token.NAME && !NodeUtil.isLabelName(n)) {\n       String varName = n.getString();\n       if (varName.equals(GLOBAL_THIS_NAME)) {\n         return true;\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    *       function parameter (not a label or a empty anonymous function name).\n    */\n   static boolean isReferenceName(Node n) {\n-    return isName(n) && !n.getString().isEmpty();\n+    return isName(n) && !n.getString().isEmpty() && !isLabelName(n);\n   }\n \n   /** @return Whether the node is a label name. */\n   static boolean isLabelName(Node n) {\n-    return (n != null && n.getType() == Token.LABEL_NAME);\n+    if (n != null && n.getType() == Token.NAME) {\n+      Node parent = n.getParent();\n+      switch (parent.getType()) {\n+        case Token.LABEL:\n+        case Token.BREAK:\n+        case Token.CONTINUE:\n+          if (n == parent.getFirstChild()) {\n+            return true;\n+          }\n+      }\n+    }\n+    return false;\n   }\n \n   /** Whether the child node is the FINALLY block of a try. */\n--- a/src/com/google/javascript/jscomp/StrictModeCheck.java\n+++ b/src/com/google/javascript/jscomp/StrictModeCheck.java\n     if (n.getType() == Token.WITH) {\n       t.report(n, WITH_DISALLOWED);\n     } else if (n.getType() == Token.NAME) {\n-      if (!isDeclaration(n)) {\n+      if (!NodeUtil.isLabelName(n) && !isDeclaration(n)) {\n         checkNameUse(t, n);\n       }\n     } else if (n.getType() == Token.ASSIGN) {\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n \n       // These nodes have no interesting type behavior.\n       case Token.LABEL:\n-      case Token.LABEL_NAME:\n       case Token.SWITCH:\n       case Token.BREAK:\n       case Token.CATCH:\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n   /** {@inheritDoc} */\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() != Token.NAME) {\n+      return;\n+    }\n+\n+    if (NodeUtil.isLabelName(n)) {\n       return;\n     }\n \n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n     Node processBreakStatement(BreakStatement statementNode) {\n       Node node = new Node(Token.BREAK);\n       if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+        node.addChildToBack(transform(statementNode.getBreakLabel()));\n       }\n       return node;\n     }\n     Node processContinueStatement(ContinueStatement statementNode) {\n       Node node = new Node(Token.CONTINUE);\n       if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+        node.addChildToBack(transform(statementNode.getLabel()));\n       }\n       return node;\n     }\n \n     @Override\n     Node processLabel(Label labelNode) {\n-      return Node.newString(Token.LABEL_NAME, labelNode.getName());\n+      return Node.newString(Token.NAME, labelNode.getName());\n     }\n \n     @Override\n--- a/src/com/google/javascript/rhino/Token.java\n+++ b/src/com/google/javascript/rhino/Token.java\n         SETCONST       = 150,\n         SETCONSTVAR    = 151,\n         DEBUGGER       = 152,\n-        \n-        // JSCompiler introduced tokens\n-        LABEL_NAME     = 153,\n-        \n-        LAST_TOKEN     = 153,\n+        LAST_TOKEN     = 152,\n \n         // JSDoc-only tokens\n         ANNOTATION     = 300,\n           case SETELEM:         return \"SETELEM\";\n           case CALL:            return \"CALL\";\n           case NAME:            return \"NAME\";\n-          case LABEL_NAME:      return \"LABEL_NAME\";\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case NULL:            return \"NULL\";\n--- a/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java\n+++ b/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java\n         \"if (temp_const_1(1, temp_const_0, temp_2));\");\n   }\n \n-  public void testExposePlusEquals() {\n+  // Simple name on LHS of assignment-op.\n+  public void testExposePlusEquals1() {\n     helperExposeExpression(\n         \"var x = 0; x += foo() + 1\",\n         \"foo\",\n         \"var x = 0; var temp_const_0 = x;\" +\n-        \"temp_const_0 += foo() + 1;\" +\n-        \"x = temp_const_0;\");\n+        \"x = temp_const_0 + (foo() + 1);\");\n \n     helperExposeExpression(\n         \"var x = 0; y = (x += foo()) + x\",\n         \"foo\",\n         \"var x = 0; var temp_const_0 = x;\" +\n-        \"y = (temp_const_0 += foo(), x=temp_const_0) + x\");\n+        \"y = (x = temp_const_0 + foo()) + x\");\n+  }\n+\n+  // Structure on LHS of assignment-op.\n+  public void testExposePlusEquals2() {\n+    helperExposeExpression(\n+        \"var x = {}; x.a += foo() + 1\",\n+        \"foo\",\n+        \"var x = {}; var temp_const_0 = x; var temp_const_1 = temp_const_0.a;\" +\n+        \"temp_const_0.a = temp_const_1 + (foo() + 1);\");\n+\n+    helperExposeExpression(\n+        \"var x = {}; y = (x.a += foo()) + x.a\",\n+        \"foo\",\n+        \"var x = {}; var temp_const_0 = x; var temp_const_1 = temp_const_0.a;\" +\n+        \"y = (temp_const_0.a = temp_const_1 + foo()) + x.a\");\n+  }\n+\n+  // Constant object on LHS of assignment-op.\n+  public void testExposePlusEquals3() {\n+    helperExposeExpression(\n+        \"var XX = {};\\n\" +\n+        \"XX.a += foo() + 1\",\n+        \"foo\",\n+        \"var XX = {}; var temp_const_0 = XX.a;\" +\n+        \"XX.a = temp_const_0 + (foo() + 1);\");\n+\n+    helperExposeExpression(\n+        \"var XX = {}; y = (XX.a += foo()) + XX.a\",\n+        \"foo\",\n+        \"var XX = {}; var temp_const_0 = XX.a;\" +\n+        \"y = (XX.a = temp_const_0 + foo()) + XX.a\");\n+  }\n+\n+  // Function all on LHS of assignment-op.\n+  public void testExposePlusEquals4() {\n+    helperExposeExpression(\n+        \"var x = {}; goo().a += foo() + 1\",\n+        \"foo\",\n+        \"var x = {};\" +\n+        \"var temp_const_0 = goo();\" +\n+        \"var temp_const_1 = temp_const_0.a;\" +\n+        \"temp_const_0.a = temp_const_1 + (foo() + 1);\");\n+\n+    helperExposeExpression(\n+        \"var x = {}; y = (goo().a += foo()) + goo().a\",\n+        \"foo\",\n+        \"var x = {};\" +\n+        \"var temp_const_0 = goo();\" +\n+        \"var temp_const_1 = temp_const_0.a;\" +\n+        \"y = (temp_const_0.a = temp_const_1 + foo()) + goo().a\");\n+  }\n+\n+  // Test mulitple levels\n+  public void testExposePlusEquals5() {\n+    helperExposeExpression(\n+        \"var x = {}; goo().a.b += foo() + 1\",\n+        \"foo\",\n+        \"var x = {};\" +\n+        \"var temp_const_0 = goo().a;\" +\n+        \"var temp_const_1 = temp_const_0.b;\" +\n+        \"temp_const_0.b = temp_const_1 + (foo() + 1);\");\n+\n+    helperExposeExpression(\n+        \"var x = {}; y = (goo().a.b += foo()) + goo().a\",\n+        \"foo\",\n+        \"var x = {};\" +\n+        \"var temp_const_0 = goo().a;\" +\n+        \"var temp_const_1 = temp_const_0.b;\" +\n+        \"y = (temp_const_0.b = temp_const_1 + foo()) + goo().a\");\n   }\n \n   /** Test case helpers. */\n   /**\n    * @param name The name to look for.\n    * @param call The call to look for.\n-   * @return The return the Nth CALL node to name found in a pre-order \n+   * @return The return the Nth CALL node to name found in a pre-order\n    * traversal.\n    */\n   private static Node findCall(\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n         \"var x = 1;\" +\n         \"var JSCompiler_temp_const_0 = x;\" +\n         \"{var JSCompiler_inline_result_1; a=1; JSCompiler_inline_result_1=1}\" +\n-        \"JSCompiler_temp_const_0 += JSCompiler_inline_result_1;\" +\n-        \"x = JSCompiler_temp_const_0\");\n+        \"x = JSCompiler_temp_const_0 + JSCompiler_inline_result_1;\");\n   }\n \n   public void testDecomposeAnonymousInCall() {\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/deps/DepsFileParserTest.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.deps;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.javascript.jscomp.deps.DependencyInfo;\n+import com.google.javascript.jscomp.deps.DepsFileParser;\n+import com.google.javascript.jscomp.ErrorManager;\n+import com.google.javascript.jscomp.PrintStreamErrorManager;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Tests for {@link DepsFileParser}.\n+ *\n+ * @author agrieve@google.com (Andrew Grieve)\n+ */\n+public class DepsFileParserTest extends TestCase {\n+\n+  private DepsFileParser parser;\n+  private ErrorManager errorManager;\n+  private static final String SRC_PATH = \"/path/1.js\";\n+\n+  @Override\n+  public void setUp() {\n+    errorManager = new PrintStreamErrorManager(System.err);\n+    parser = new DepsFileParser(errorManager);\n+  }\n+\n+  /**\n+   * Tests:\n+   *  -Parsing of comments,\n+   *  -Parsing of different styles of quotes,\n+   *  -Parsing of empty arrays,\n+   *  -Parsing of non-empty arrays,\n+   *  -Correct recording of what was parsed.\n+   */\n+  public void testGoodParse() {\n+    final String CONTENTS = \"/*\"\n+        + \"goog.addDependency('no1', [], []);*//*\\n\"\n+        + \"goog.addDependency('no2', [ ], [ ]);\\n\"\n+        + \"*/goog.addDependency('yes1', [], []);\\n\"\n+        + \"/* blah */goog.addDependency(\\\"yes2\\\", [], [])/* blah*/\\n\"\n+        + \"goog.addDependency('yes3', ['a','b'], ['c']); // goog.addDependency('no3', [], []);\\n\"\n+        + \"// goog.addDependency('no4', [], []);\\n\"\n+        + \"goog.addDependency(\\\"yes4\\\", [], [ \\\"a\\\",'b' , 'c' ]); //no new line at eof\";\n+\n+    List<DependencyInfo> result = parser.parseFile(SRC_PATH, CONTENTS);\n+    List<String> EMPTY = Collections.emptyList();\n+    ImmutableList<DependencyInfo> EXPECTED = ImmutableList.<DependencyInfo>of(\n+        new SimpleDependencyInfo(\"yes1\", SRC_PATH, EMPTY, EMPTY),\n+        new SimpleDependencyInfo(\"yes2\", SRC_PATH, EMPTY, EMPTY),\n+        new SimpleDependencyInfo(\n+            \"yes3\", SRC_PATH, ImmutableList.of(\"a\", \"b\"), ImmutableList.of(\"c\")),\n+        new SimpleDependencyInfo(\n+            \"yes4\", SRC_PATH, EMPTY, ImmutableList.of(\"a\", \"b\", \"c\"))\n+    );\n+\n+    assertEquals(EXPECTED, result);\n+    assertEquals(0, errorManager.getErrorCount());\n+    assertEquals(0, errorManager.getWarningCount());\n+  }\n+\n+  public void testTooFewArgs() {\n+    parser.parseFile(SRC_PATH, \"goog.addDependency('a', []);\");\n+    assertEquals(1, errorManager.getErrorCount());\n+    assertEquals(0, errorManager.getWarningCount());\n+  }\n+\n+  public void testTooManyArgs() {\n+    parser.parseFile(SRC_PATH, \"goog.addDependency('a', [], [], []);\");\n+    assertEquals(1, errorManager.getErrorCount());\n+    assertEquals(0, errorManager.getWarningCount());\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/deps/JsFileParserTest.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.deps;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.javascript.jscomp.ErrorManager;\n+import com.google.javascript.jscomp.PrintStreamErrorManager;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.Collections;\n+\n+/**\n+ * Tests for {@link JsFileParser}.\n+ *\n+ * @author agrieve@google.com (Andrew Grieve)\n+ */\n+public class JsFileParserTest extends TestCase {\n+\n+  JsFileParser parser;\n+  private ErrorManager errorManager;\n+\n+  private static final String SRC_PATH = \"a\";\n+  private static final String CLOSURE_PATH = \"b\";\n+\n+  @Override\n+  public void setUp() {\n+    errorManager = new PrintStreamErrorManager(System.err);\n+    parser = new JsFileParser(errorManager);\n+  }\n+\n+  /**\n+   * Tests:\n+   *  -Parsing of comments,\n+   *  -Parsing of different styles of quotes,\n+   *  -Correct recording of what was parsed.\n+   */\n+  public void testParseFile() {\n+    final String CONTENTS = \"/*\"\n+      + \"goog.provide('no1');*//*\\n\"\n+      + \"goog.provide('no2');\\n\"\n+      + \"*/goog.provide('yes1');\\n\"\n+      + \"/* blah */goog.provide(\\\"yes2\\\")/* blah*/\\n\"\n+      + \"goog.require('yes3'); // goog.provide('no3');\\n\"\n+      + \"// goog.provide('no4');\\n\"\n+      + \"goog.require(\\\"bar.data.SuperstarAddStarThreadActionRequestDelegate\\\"); \"\n+      + \"//no new line at eof\";\n+\n+    DependencyInfo EXPECTED = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH,\n+        ImmutableList.of(\"yes1\", \"yes2\"),\n+        ImmutableList.of(\"yes3\", \"bar.data.SuperstarAddStarThreadActionRequestDelegate\"));\n+\n+    DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, CONTENTS);\n+\n+    assertEquals(EXPECTED, result);\n+    assertEquals(0, errorManager.getErrorCount());\n+    assertEquals(0, errorManager.getWarningCount());\n+  }\n+\n+  public void testMultiplePerLine() {\n+    final String CONTENTS = \"goog.provide('yes1');goog.provide('yes2');/*\"\n+        + \"goog.provide('no1');*/goog.provide('yes3');//goog.provide('no2');\";\n+\n+    DependencyInfo EXPECTED = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH,\n+        ImmutableList.of(\"yes1\", \"yes2\", \"yes3\"), Collections.<String>emptyList());\n+\n+    DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, CONTENTS);\n+\n+    assertEquals(EXPECTED, result);\n+    assertEquals(0, errorManager.getErrorCount());\n+    assertEquals(0, errorManager.getWarningCount());\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n     parse(\"do { a() } while (b());\");\n   }\n \n-  // The old and new parser produce different results now with labels, and\n-  // named breaks and continues, so disable these tests.\n-  public void disable_testLabel() {\n+  public void testLabel() {\n     parse(\"foo: bar\");\n   }\n \n-  public void disable_testLabel2() {\n+  public void testLabel2() {\n     parse(\"l: while (f()) { if (g()) { continue l; } }\");\n   }\n \n-  public void disable_testLabel3() {\n+  public void testLabel3() {\n     parse(\"Foo:Bar:X:{ break Bar; }\");\n   }\n ", "timestamp": 1270175530, "metainfo": ""}