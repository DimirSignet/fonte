{"sha": "fbaadc736f0031dd84bebea33abae497b47158cb", "log": "fix a mishandling of the void keyword also fix a bunch of apis fixes issue 504  R=johnlenz DELTA=126  (29 added, 0 deleted, 97 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2506   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n         // ignoring side-effects\n         return TernaryValue.TRUE;\n \n+      case Token.VOID:\n+        return TernaryValue.FALSE;\n+\n       default:\n         return getPureBooleanValue(n);\n     }\n \n       case Token.NULL:\n       case Token.FALSE:\n+        return TernaryValue.FALSE;\n+\n       case Token.VOID:\n-        return TernaryValue.FALSE;\n+        if (!mayHaveSideEffects(n.getFirstChild())) {\n+          return TernaryValue.FALSE;\n+        }\n+        break;\n \n       case Token.NAME:\n         String name = n.getString();\n         if (!mayHaveSideEffects(n)) {\n           return TernaryValue.TRUE;\n         }\n+        break;\n     }\n \n     return TernaryValue.UNKNOWN;\n--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n    * @return the replacement node, if changed, or the original if not\n    */\n   private Node tryFoldExpr(Node subtree) {\n-    Node result = trySimpilifyUnusedResult(subtree.getFirstChild());\n+    Node result = trySimplifyUnusedResult(subtree.getFirstChild());\n     if (result == null) {\n       Node parent = subtree.getParent();\n       // If the EXPR_RESULT no longer has any children, remove it as well.\n    * @param n The root of the expression to simplify.\n    * @return The replacement node, or null if the node was is not useful.\n    */\n-  private Node trySimpilifyUnusedResult(Node n) {\n-    return trySimpilifyUnusedResult(n, true);\n+  private Node trySimplifyUnusedResult(Node n) {\n+    return trySimplifyUnusedResult(n, true);\n   }\n \n   /**\n    *     it is not useful, otherwise it replaced with an EMPTY node.\n    * @return The replacement node, or null if the node was is not useful.\n    */\n-  private Node trySimpilifyUnusedResult(Node n, boolean removeUnused) {\n+  private Node trySimplifyUnusedResult(Node n, boolean removeUnused) {\n     Node result = n;\n \n     // Simplify the results of conditional expressions\n     switch (n.getType()) {\n       case Token.HOOK:\n-        Node trueNode = trySimpilifyUnusedResult(n.getFirstChild().getNext());\n-        Node falseNode = trySimpilifyUnusedResult(n.getLastChild());\n+        Node trueNode = trySimplifyUnusedResult(n.getFirstChild().getNext());\n+        Node falseNode = trySimplifyUnusedResult(n.getLastChild());\n         // If one or more of the conditional children were removed,\n         // transform the HOOK to an equivalent operation:\n         //    x() ? foo() : 1 --> x() && foo()\n           n.setType(Token.AND);\n           Preconditions.checkState(n.getChildCount() == 2);\n         } else if (trueNode == null && falseNode == null) {\n-          result = trySimpilifyUnusedResult(n.getFirstChild());\n+          result = trySimplifyUnusedResult(n.getFirstChild());\n         } else {\n           // The structure didn't change.\n           result = n;\n         // Try to remove the second operand from a AND or OR operations:\n         //    x() || f --> x()\n         //    x() && f --> x()\n-        Node conditionalResultNode = trySimpilifyUnusedResult(\n+        Node conditionalResultNode = trySimplifyUnusedResult(\n             n.getLastChild());\n         if (conditionalResultNode == null) {\n           Preconditions.checkState(n.hasOneChild());\n           // The conditionally executed code was removed, so\n           // replace the AND/OR with its LHS or remove it if it isn't useful.\n-          result = trySimpilifyUnusedResult(n.getFirstChild());\n+          result = trySimplifyUnusedResult(n.getFirstChild());\n         }\n         break;\n       case Token.FUNCTION:\n         // get split into individual EXPR_RESULT statement, if possible), so\n         // we special case COMMA (we don't want to rewrite COMMAs as new COMMAs\n         // nodes.\n-        Node left = trySimpilifyUnusedResult(n.getFirstChild());\n-        Node right = trySimpilifyUnusedResult(n.getLastChild());\n+        Node left = trySimplifyUnusedResult(n.getFirstChild());\n+        Node right = trySimplifyUnusedResult(n.getLastChild());\n         if (left == null && right == null) {\n           result = null;\n         } else if (left == null) {\n           Node resultList = null;\n           for (Node next, c = n.getFirstChild(); c != null; c = next) {\n             next = c.getNext();\n-            c = trySimpilifyUnusedResult(c);\n+            c = trySimplifyUnusedResult(c);\n             if (c != null) {\n               c.detachFromParent();\n               if (resultList == null)  {\n     Node left = n.getFirstChild();\n     Node right = left.getNext();\n \n-    left = trySimpilifyUnusedResult(left);\n+    left = trySimplifyUnusedResult(left);\n     if (left == null || !mayHaveSideEffects(left)) {\n       // Fold it!\n       n.removeChild(right);\n     Node increment = cond.getNext();\n \n     if (init.getType() != Token.EMPTY && init.getType() != Token.VAR) {\n-      init = trySimpilifyUnusedResult(init, false);\n+      init = trySimplifyUnusedResult(init, false);\n     }\n \n     if (increment.getType() != Token.EMPTY) {\n-      increment = trySimpilifyUnusedResult(increment, false);\n+      increment = trySimplifyUnusedResult(increment, false);\n     }\n \n     // There is an initializer skip it\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n          \"}\");\n   }\n \n+  public void testIssue504() {\n+    args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n+    test(\"void function() { alert('hi'); }();\",\n+         \"alert('hi');\", CheckSideEffects.USELESS_CODE_ERROR);\n+  }\n+\n   public void testDebugFlag1() {\n     args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n     args.add(\"--debug=false\");\n     test(new String[] { original }, warning);\n   }\n \n+  private void test(String original, String expected, DiagnosticType warning) {\n+    test(new String[] { original }, new String[] { expected }, warning);\n+  }\n+\n   /**\n    * Asserts that when compiling, there is an error or warning.\n    */\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n   }\n \n   public void testGetBooleanValue() {\n-    assertBooleanTrue(\"true\");\n-    assertBooleanTrue(\"10\");\n-    assertBooleanTrue(\"'0'\");\n-    assertBooleanTrue(\"/a/\");\n-    assertBooleanTrue(\"{}\");\n-    assertBooleanTrue(\"[]\");\n-    assertBooleanFalse(\"false\");\n-    assertBooleanFalse(\"null\");\n-    assertBooleanFalse(\"0\");\n-    assertBooleanFalse(\"''\");\n-    assertBooleanFalse(\"undefined\");\n-    assertBooleanFalse(\"void 0\");\n-    assertBooleanFalse(\"void foo()\");\n-    assertBooleanUnknown(\"b\");\n-    assertBooleanUnknown(\"-'0.0'\");\n+    assertPureBooleanTrue(\"true\");\n+    assertPureBooleanTrue(\"10\");\n+    assertPureBooleanTrue(\"'0'\");\n+    assertPureBooleanTrue(\"/a/\");\n+    assertPureBooleanTrue(\"{}\");\n+    assertPureBooleanTrue(\"[]\");\n+    assertPureBooleanFalse(\"false\");\n+    assertPureBooleanFalse(\"null\");\n+    assertPureBooleanFalse(\"0\");\n+    assertPureBooleanFalse(\"''\");\n+    assertPureBooleanFalse(\"undefined\");\n+    assertPureBooleanFalse(\"void 0\");\n+    assertPureBooleanUnknown(\"void foo()\");\n+    assertPureBooleanUnknown(\"b\");\n+    assertPureBooleanUnknown(\"-'0.0'\");\n \n     // Known but getBooleanValue return false for expressions with side-effects\n-    assertBooleanUnknown(\"{a:foo()}\");\n-    assertBooleanUnknown(\"[foo()]\");\n-  }\n-\n-  private void assertBooleanTrue(String val) {\n+    assertPureBooleanUnknown(\"{a:foo()}\");\n+    assertPureBooleanUnknown(\"[foo()]\");\n+  }\n+\n+  private void assertPureBooleanTrue(String val) {\n     assertEquals(TernaryValue.TRUE, NodeUtil.getPureBooleanValue(getNode(val)));\n   }\n \n-  private void assertBooleanFalse(String val) {\n+  private void assertPureBooleanFalse(String val) {\n     assertEquals(\n         TernaryValue.FALSE, NodeUtil.getPureBooleanValue(getNode(val)));\n   }\n \n-  private void assertBooleanUnknown(String val) {\n+  private void assertPureBooleanUnknown(String val) {\n     assertEquals(\n         TernaryValue.UNKNOWN, NodeUtil.getPureBooleanValue(getNode(val)));\n   }\n \n   public void testGetExpressionBooleanValue() {\n-    assertExpressionBooleanTrue(\"a=true\");\n-    assertExpressionBooleanFalse(\"a=false\");\n-\n-    assertExpressionBooleanTrue(\"a=(false,true)\");\n-    assertExpressionBooleanFalse(\"a=(true,false)\");\n-\n-    assertExpressionBooleanTrue(\"a=(false || true)\");\n-    assertExpressionBooleanFalse(\"a=(true && false)\");\n-\n-    assertExpressionBooleanTrue(\"a=!(true && false)\");\n-\n-    assertExpressionBooleanTrue(\"a,true\");\n-    assertExpressionBooleanFalse(\"a,false\");\n-\n-    assertExpressionBooleanTrue(\"true||false\");\n-    assertExpressionBooleanFalse(\"false||false\");\n-\n-    assertExpressionBooleanTrue(\"true&&true\");\n-    assertExpressionBooleanFalse(\"true&&false\");\n-\n-    assertExpressionBooleanFalse(\"!true\");\n-    assertExpressionBooleanTrue(\"!false\");\n-    assertExpressionBooleanTrue(\"!''\");\n+    assertImpureBooleanTrue(\"a=true\");\n+    assertImpureBooleanFalse(\"a=false\");\n+\n+    assertImpureBooleanTrue(\"a=(false,true)\");\n+    assertImpureBooleanFalse(\"a=(true,false)\");\n+\n+    assertImpureBooleanTrue(\"a=(false || true)\");\n+    assertImpureBooleanFalse(\"a=(true && false)\");\n+\n+    assertImpureBooleanTrue(\"a=!(true && false)\");\n+\n+    assertImpureBooleanTrue(\"a,true\");\n+    assertImpureBooleanFalse(\"a,false\");\n+\n+    assertImpureBooleanTrue(\"true||false\");\n+    assertImpureBooleanFalse(\"false||false\");\n+\n+    assertImpureBooleanTrue(\"true&&true\");\n+    assertImpureBooleanFalse(\"true&&false\");\n+\n+    assertImpureBooleanFalse(\"!true\");\n+    assertImpureBooleanTrue(\"!false\");\n+    assertImpureBooleanTrue(\"!''\");\n \n     // Assignment ops other than ASSIGN are unknown.\n-    assertExpressionBooleanUnknown(\"a *= 2\");\n+    assertImpureBooleanUnknown(\"a *= 2\");\n \n     // Complex expressions that contain anything other then \"=\", \",\", or \"!\" are\n     // unknown.\n-    assertExpressionBooleanUnknown(\"2 + 2\");\n-\n-    assertExpressionBooleanTrue(\"a=1\");\n-    assertExpressionBooleanTrue(\"a=/a/\");\n-    assertExpressionBooleanTrue(\"a={}\");\n-\n-    assertExpressionBooleanTrue(\"true\");\n-    assertExpressionBooleanTrue(\"10\");\n-    assertExpressionBooleanTrue(\"'0'\");\n-    assertExpressionBooleanTrue(\"/a/\");\n-    assertExpressionBooleanTrue(\"{}\");\n-    assertExpressionBooleanTrue(\"[]\");\n-    assertExpressionBooleanFalse(\"false\");\n-    assertExpressionBooleanFalse(\"null\");\n-    assertExpressionBooleanFalse(\"0\");\n-    assertExpressionBooleanFalse(\"''\");\n-    assertExpressionBooleanFalse(\"undefined\");\n-    assertExpressionBooleanFalse(\"void 0\");\n-    assertExpressionBooleanFalse(\"void foo()\");\n-\n-    assertExpressionBooleanTrue(\"a?true:true\");\n-    assertExpressionBooleanFalse(\"a?false:false\");\n-    assertExpressionBooleanUnknown(\"a?true:false\");\n-    assertExpressionBooleanUnknown(\"a?true:foo()\");\n-\n-    assertExpressionBooleanUnknown(\"b\");\n-    assertExpressionBooleanUnknown(\"-'0.0'\");\n-\n-    assertExpressionBooleanTrue(\"{a:foo()}\");\n-    assertExpressionBooleanTrue(\"[foo()]\");\n-  }\n-\n-  private void assertExpressionBooleanTrue(String val) {\n+    assertImpureBooleanUnknown(\"2 + 2\");\n+\n+    assertImpureBooleanTrue(\"a=1\");\n+    assertImpureBooleanTrue(\"a=/a/\");\n+    assertImpureBooleanTrue(\"a={}\");\n+\n+    assertImpureBooleanTrue(\"true\");\n+    assertImpureBooleanTrue(\"10\");\n+    assertImpureBooleanTrue(\"'0'\");\n+    assertImpureBooleanTrue(\"/a/\");\n+    assertImpureBooleanTrue(\"{}\");\n+    assertImpureBooleanTrue(\"[]\");\n+    assertImpureBooleanFalse(\"false\");\n+    assertImpureBooleanFalse(\"null\");\n+    assertImpureBooleanFalse(\"0\");\n+    assertImpureBooleanFalse(\"''\");\n+    assertImpureBooleanFalse(\"undefined\");\n+    assertImpureBooleanFalse(\"void 0\");\n+    assertImpureBooleanFalse(\"void foo()\");\n+\n+    assertImpureBooleanTrue(\"a?true:true\");\n+    assertImpureBooleanFalse(\"a?false:false\");\n+    assertImpureBooleanUnknown(\"a?true:false\");\n+    assertImpureBooleanUnknown(\"a?true:foo()\");\n+\n+    assertImpureBooleanUnknown(\"b\");\n+    assertImpureBooleanUnknown(\"-'0.0'\");\n+\n+    assertImpureBooleanTrue(\"{a:foo()}\");\n+    assertImpureBooleanTrue(\"[foo()]\");\n+  }\n+\n+  private void assertImpureBooleanTrue(String val) {\n     assertEquals(TernaryValue.TRUE,\n         NodeUtil.getImpureBooleanValue(getNode(val)));\n   }\n \n-  private void assertExpressionBooleanFalse(String val) {\n+  private void assertImpureBooleanFalse(String val) {\n     assertEquals(TernaryValue.FALSE,\n         NodeUtil.getImpureBooleanValue(getNode(val)));\n   }\n \n-  private void assertExpressionBooleanUnknown(String val) {\n+  private void assertImpureBooleanUnknown(String val) {\n     assertEquals(TernaryValue.UNKNOWN,\n         NodeUtil.getImpureBooleanValue(getNode(val)));\n   }", "timestamp": 1310007505, "metainfo": ""}