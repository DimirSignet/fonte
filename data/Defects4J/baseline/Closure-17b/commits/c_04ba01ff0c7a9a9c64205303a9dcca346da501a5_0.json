{"sha": "04ba01ff0c7a9a9c64205303a9dcca346da501a5", "log": "Add support for prefer line break at end of file. This allows us to insert code between files without affecting the source maps or deobfuscation.  This solution shifts an existing line break if it is near eof, which may result in a line longer than the normal line length advisory limit. The only alternative to that is to miss many eofs, which can impact the ability to place interstitial code, or to place a break at the end of every file, which leads to a hugely excessive number of breaks.  We could probably do better if we tracked line length across file boundaries which we currently do not.  R=acleung,johnlenz DELTA=149  (128 added, 0 deleted, 21 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4172   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodePrinter.java\n+++ b/src/com/google/javascript/jscomp/CodePrinter.java\n \n     /**\n      * Reports to the code consumer that the given line has been cut at the\n-     * given position (i.e. a \\n has been inserted there). All mappings in\n-     * the source maps after that position will be renormalized as needed.\n-     */\n-    void reportLineCut(int lineIndex, int charIndex) {\n+     * given position, i.e. a \\n has been inserted there. Or that a cut has\n+     * been undone, i.e. a previously inserted \\n has been removed.\n+     * All mappings in the source maps after that position will be renormalized\n+     * as needed.\n+     */\n+    void reportLineCut(int lineIndex, int charIndex, boolean insertion) {\n       if (createSrcMap) {\n         for (Mapping mapping : allMappings) {\n-          mapping.start = convertPosition(mapping.start, lineIndex, charIndex);\n+          mapping.start = convertPosition(mapping.start, lineIndex, charIndex,\n+              insertion);\n \n           if (mapping.end != null) {\n-            mapping.end = convertPosition(mapping.end, lineIndex, charIndex);\n+            mapping.end = convertPosition(mapping.end, lineIndex, charIndex,\n+                insertion);\n           }\n         }\n       }\n \n     /**\n      * Converts the given position by normalizing it against the insertion\n-     * of a newline at the given line and character position.\n+     * or removal of a newline at the given line and character position.\n      *\n      * @param position The existing position before the newline was inserted.\n      * @param lineIndex The index of the line at which the newline was inserted.\n      * @param characterPosition The position on the line at which the newline\n      *     was inserted.\n+     * @param insertion True if a newline was inserted, false if a newline was\n+     *     removed.\n      *\n      * @return The normalized position.\n+     * @throws IllegalStateException if an attempt to reverse a line cut is\n+     *     made on a previous line rather than the current line.\n      */\n     private FilePosition convertPosition(FilePosition position, int lineIndex,\n-                                     int characterPosition) {\n+                                     int characterPosition, boolean insertion) {\n       int originalLine = position.getLine();\n       int originalChar = position.getColumn();\n-      if (originalLine == lineIndex && originalChar >= characterPosition) {\n-        // If the position falls on the line itself, then normalize it\n-        // if it falls at or after the place the newline was inserted.\n-        return new FilePosition(\n-            originalLine + 1, originalChar - characterPosition);\n+      if (insertion) {\n+        if (originalLine == lineIndex && originalChar >= characterPosition) {\n+          // If the position falls on the line itself, then normalize it\n+          // if it falls at or after the place the newline was inserted.\n+          return new FilePosition(\n+              originalLine + 1, originalChar - characterPosition);\n+        } else {\n+          return position;\n+        }\n       } else {\n-        return position;\n+        if (originalLine == lineIndex) {\n+          return new FilePosition(\n+              originalLine - 1, originalChar + characterPosition);\n+        } else if (originalLine > lineIndex) {\n+            // Not supported, can only undo a cut on the most recent line. To\n+            // do this on a previous lines would require reevaluating the cut\n+            // positions on all subsequent lines.\n+            throw new IllegalStateException(\n+                \"Cannot undo line cut on a previous line.\");\n+        } else {\n+          return position;\n+        }\n       }\n     }\n \n     // probably require explicit modelling of the gzip algorithm.\n \n     private final boolean lineBreak;\n+    private final boolean preferLineBreakAtEndOfFile;\n     private int lineStartPosition = 0;\n     private int preferredBreakPosition = 0;\n+    private int prevCutPosition = 0;\n+    private int prevLineStartPosition = 0;\n \n   /**\n    * @param lineBreak break the lines a bit more aggressively\n    * @param sourceMapDetailLevel A filter to control which nodes get mapped into\n    *     the source map.\n    */\n-    private CompactCodePrinter(boolean lineBreak, int lineLengthThreshold,\n+    private CompactCodePrinter(boolean lineBreak,\n+        boolean preferLineBreakAtEndOfFile, int lineLengthThreshold,\n         boolean createSrcMap, SourceMap.DetailLevel sourceMapDetailLevel) {\n       super(lineLengthThreshold, createSrcMap, sourceMapDetailLevel);\n       this.lineBreak = lineBreak;\n+      this.preferLineBreakAtEndOfFile = preferLineBreakAtEndOfFile;\n     }\n \n     /**\n     @Override\n     void startNewLine() {\n       if (lineLength > 0) {\n+        prevCutPosition = code.length();\n+        prevLineStartPosition = lineStartPosition;\n         code.append('\\n');\n         lineLength = 0;\n         lineIndex++;\n             preferredBreakPosition < lineStartPosition + lineLength) {\n           int position = preferredBreakPosition;\n           code.insert(position, '\\n');\n-          reportLineCut(lineIndex, position - lineStartPosition);\n+          prevCutPosition = position;\n+          reportLineCut(lineIndex, position - lineStartPosition, true);\n           lineIndex++;\n           lineLength -= (position - lineStartPosition);\n           lineStartPosition = position + 1;\n     void notePreferredLineBreak() {\n       preferredBreakPosition = code.length();\n     }\n+\n+    @Override\n+    void endFile() {\n+      super.endFile();\n+      if (!preferLineBreakAtEndOfFile) {\n+        return;\n+      }\n+      if (lineLength > lineLengthThreshold / 2) {\n+        // Add an extra break at end of file.\n+        append(\";\");\n+        startNewLine();\n+      } else if (prevCutPosition > 0) {\n+        // Shift the previous break to end of file.\n+        for (int i = prevCutPosition; i < code.length() - 1; i++) {\n+          code.setCharAt(i, code.charAt(i+1));\n+        }\n+        code.setLength(code.length() - 1);\n+        lineStartPosition = prevLineStartPosition;\n+        lineLength = code.length() - lineStartPosition;\n+        reportLineCut(lineIndex, prevCutPosition, false);\n+        lineIndex--;\n+        prevCutPosition = 0;\n+        prevLineStartPosition = 0;\n+        append(\";\");\n+        startNewLine();\n+      } else {\n+        // A small file with no line breaks. We do nothing in this case to\n+        // avoid excessive line breaks. It's not ideal if a lot of these pile\n+        // up, but that is reasonably unlikely.\n+      }\n+    }\n+\n   }\n \n   static class Builder {\n     private final Node root;\n     private boolean prettyPrint = false;\n     private boolean lineBreak = false;\n+    private boolean preferLineBreakAtEndOfFile = false;\n     private boolean outputTypes = false;\n     private int lineLengthThreshold = DEFAULT_LINE_LENGTH_THRESHOLD;\n     private SourceMap sourceMap = null;\n     }\n \n     /**\n+     * Sets whether line breaking is preferred at end of file. This is useful\n+     * if JS serving code needs a place to insert code, such as script tags,\n+     * without interfering with source maps.\n+     * @param lineBreakAtEnd If true, prefer line breaking at end of file.\n+     */\n+    Builder setPreferLineBreakAtEndOfFile(boolean lineBreakAtEnd) {\n+      this.preferLineBreakAtEndOfFile = lineBreakAtEnd;\n+      return this;\n+    }\n+\n+    /**\n      * Sets whether to output closure-style type annotations.\n      * @param outputTypes If true, outputs closure-style type annotations.\n      */\n               ? Format.PRETTY\n               : Format.COMPACT;\n \n-      return toSource(root, outputFormat, lineBreak, lineLengthThreshold,\n-          sourceMap, sourceMapDetailLevel, outputCharset, tagAsStrict);\n+      return toSource(root, outputFormat, lineBreak, preferLineBreakAtEndOfFile,\n+          lineLengthThreshold, sourceMap, sourceMapDetailLevel, outputCharset,\n+          tagAsStrict);\n     }\n   }\n \n    * Converts a tree to js code\n    */\n   private static String toSource(Node root, Format outputFormat,\n-                                 boolean lineBreak,  int lineLengthThreshold,\n+                                 boolean lineBreak,  boolean preferEndOfFileBreak,\n+                                 int lineLengthThreshold,\n                                  SourceMap sourceMap,\n                                  SourceMap.DetailLevel sourceMapDetailLevel,\n                                  Charset outputCharset,\n     MappedCodePrinter mcp =\n         outputFormat == Format.COMPACT\n         ? new CompactCodePrinter(\n-            lineBreak, lineLengthThreshold,\n+            lineBreak, preferEndOfFileBreak, lineLengthThreshold,\n             createSourceMap, sourceMapDetailLevel)\n         : new PrettyCodePrinter(\n             lineLengthThreshold, createSourceMap, sourceMapDetailLevel);\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     CodePrinter.Builder builder = new CodePrinter.Builder(n);\n     builder.setPrettyPrint(options.prettyPrint);\n     builder.setLineBreak(options.lineBreak);\n+    builder.setPreferLineBreakAtEndOfFile(options.preferLineBreakAtEndOfFile);\n     builder.setSourceMap(sourceMap);\n     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n     builder.setTagAsStrict(firstOutput &&\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n \n   /** Line break the output a bit more aggressively */\n   public boolean lineBreak;\n+\n+  /** Prefer line breaks at end of file */\n+  public boolean preferLineBreakAtEndOfFile;\n \n   /** Prints a separator comment before each js script */\n   public boolean printInputDelimiter;\n     printInputDelimiter = false;\n     prettyPrint = false;\n     lineBreak = false;\n+    preferLineBreakAtEndOfFile = false;\n     reportPath = null;\n     tracer = TracerMode.OFF;\n     colorizeErrorOutput = false;\n \n   public void setLineBreak(boolean lineBreak) {\n     this.lineBreak = lineBreak;\n+  }\n+\n+  public void setPreferLineBreakAtEndOfFile(boolean lineBreakAtEnd) {\n+    this.preferLineBreakAtEndOfFile = lineBreakAtEnd;\n   }\n \n   public void setPrintInputDelimiter(boolean printInputDelimiter) {\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n       int lineThreshold) {\n     return new CodePrinter.Builder(parse(js)).setPrettyPrint(prettyprint)\n         .setLineLengthThreshold(lineThreshold).setLineBreak(lineBreak).build();\n+  }\n+\n+  String parsePrint(String js, boolean prettyprint, boolean lineBreak,\n+      boolean preferLineBreakAtEof, int lineThreshold) {\n+    return new CodePrinter.Builder(parse(js, true)).setPrettyPrint(prettyprint)\n+        .setLineLengthThreshold(lineThreshold).setLineBreak(lineBreak)\n+        .setPreferLineBreakAtEndOfFile(preferLineBreakAtEof)\n+        .build();\n   }\n \n   String parsePrint(String js, boolean prettyprint, boolean lineBreak,\n     assertEquals(expected,\n         parsePrint(js, false, true,\n             CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n+  }\n+\n+  public void testPreferLineBreakAtEndOfFile() {\n+    // short final line, no previous break, do nothing\n+    assertLineBreakAtEndOfFile(\n+        \"\\\"1234567890\\\";\",\n+        \"\\\"1234567890\\\"\",\n+        \"\\\"1234567890\\\"\");\n+\n+    // short final line, shift previous break to end\n+    assertLineBreakAtEndOfFile(\n+        \"\\\"123456789012345678901234567890\\\";\\\"1234567890\\\"\",\n+        \"\\\"123456789012345678901234567890\\\";\\n\\\"1234567890\\\"\",\n+        \"\\\"123456789012345678901234567890\\\";\\\"1234567890\\\";\\n\");\n+\n+    // long final line, no previous break, add a break at end\n+    assertLineBreakAtEndOfFile(\n+        \"\\\"1234567890\\\";\\\"12345678901234567890\\\";\",\n+        \"\\\"1234567890\\\";\\\"12345678901234567890\\\"\",\n+        \"\\\"1234567890\\\";\\\"12345678901234567890\\\";\\n\");\n+\n+    // long final line, previous break, add a break at end\n+    assertLineBreakAtEndOfFile(\n+        \"\\\"123456789012345678901234567890\\\";\\\"12345678901234567890\\\";\",\n+        \"\\\"123456789012345678901234567890\\\";\\n\\\"12345678901234567890\\\"\",\n+        \"\\\"123456789012345678901234567890\\\";\\n\\\"12345678901234567890\\\";\\n\");\n+  }\n+\n+  private void assertLineBreakAtEndOfFile(String js,\n+      String expectedWithoutBreakAtEnd, String expectedWithBreakAtEnd) {\n+    assertEquals(expectedWithoutBreakAtEnd,\n+        parsePrint(js, false, false, false, 30));\n+    assertEquals(expectedWithBreakAtEnd,\n+        parsePrint(js, false, false, true, 30));\n   }\n \n   public void testPrettyPrinter() {", "timestamp": 1328573608, "metainfo": ""}