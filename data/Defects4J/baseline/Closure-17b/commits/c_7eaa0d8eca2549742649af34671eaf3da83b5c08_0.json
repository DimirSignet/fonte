{"sha": "7eaa0d8eca2549742649af34671eaf3da83b5c08", "log": "Change on 2010/04/06 by john          Update RemoveConstantExpressions to handle removing expressions whose         roots are calls to functions without side-effects.          R=antonio         DELTA=19  (18 added, 0 deleted, 1 changed)  Change on 2010/04/06 by john          Cleanup NodeUtil self references.          R=robert         DELTA=12  (0 added, 0 deleted, 12 changed)  Change on 2010/04/07 by john          Make things easier for shell escaping, accept both single and double         quotes for strings in --define flags.         Fixes issue 139.          R=robert         DELTA=18  (14 added, 0 deleted, 4 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=wdwbvk   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n       } catch (NumberFormatException ignored) {\n         numJsFiles = -1;\n       }\n-      \n+\n       // We will allow modules of zero input.\n       if (numJsFiles < 0) {\n         throw new FlagUsageException(\"Invalid js file count '\" + parts[1]\n           } else if (defValue.equals(\"false\")) {\n             options.setDefineToBooleanLiteral(defName, false);\n             continue;\n-          } else if (defValue.length() > 1 &&\n-              defValue.charAt(0) == '\\'' &&\n-              defValue.charAt(defValue.length() - 1) == '\\'') {\n+          } else if (defValue.length() > 1\n+              && ((defValue.charAt(0) == '\\'' &&\n+                  defValue.charAt(defValue.length() - 1) == '\\'')\n+                  || (defValue.charAt(0) == '\\\"' &&\n+                      defValue.charAt(defValue.length() - 1) == '\\\"'))) {\n             // If the value starts and ends with a single quote,\n             // we assume that it's a string.\n             String maybeStringVal =\n                 defValue.substring(1, defValue.length() - 1);\n-            if (maybeStringVal.indexOf('\\'') == -1) {\n+            if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {\n               options.setDefineToStringLiteral(defName, maybeStringVal);\n               continue;\n             }\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    * the reason's why a subtree has side effects.\n    */\n   static boolean nodeTypeMayHaveSideEffects(Node n) {\n-    if (NodeUtil.isAssignmentOp(n)) {\n+    if (isAssignmentOp(n)) {\n       return true;\n     }\n \n         return true;\n       case Token.NAME:\n         // Non-constant names values may have been changed.\n-        return !NodeUtil.isConstantName(n)\n+        return !isConstantName(n)\n             && !knownConstants.contains(n.getString());\n \n       // Properties on constant NAMEs can still be side-effected.\n       case Token.FUNCTION:\n         // Anonymous functions definitions are not changed by side-effects,\n         // and named functions are not part of expressions.\n-        Preconditions.checkState(NodeUtil.isAnonymousFunction(n));\n+        Preconditions.checkState(isAnonymousFunction(n));\n         return false;\n     }\n \n     Node parent = block.getParent();\n     // Try to remove the block if its parent is a block/script or if its\n     // parent is label and it has exactly one child.\n-    if (NodeUtil.isStatementBlock(parent)) {\n+    if (isStatementBlock(parent)) {\n       Node previous = block;\n       while (block.hasChildren()) {\n         Node child = block.removeFirstChild();\n    * See {@link #isFunctionDeclaration}).\n    */\n   static boolean isHoistedFunctionDeclaration(Node n) {\n-    return NodeUtil.isFunctionDeclaration(n)\n+    return isFunctionDeclaration(n)\n         && (n.getParent().getType() == Token.SCRIPT\n             || n.getParent().getParent().getType() == Token.FUNCTION);\n   }\n    */\n   static boolean isVarArgsFunction(Node function) {\n     Preconditions.checkArgument(isFunction(function));\n-    return NodeUtil.isNameReferenced(\n+    return isNameReferenced(\n         function.getLastChild(),\n         \"arguments\",\n-        Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION)));\n+        Predicates.<Node>not(new MatchNodeType(Token.FUNCTION)));\n   }\n \n   /**\n   static boolean isObjectCallMethod(Node callNode, String methodName) {\n     if (callNode.getType() == Token.CALL) {\n       Node functionIndentifyingExpression = callNode.getFirstChild();\n-      if (NodeUtil.isGet(functionIndentifyingExpression)) {\n+      if (isGet(functionIndentifyingExpression)) {\n         Node last = functionIndentifyingExpression.getLastChild();\n         if (last != null && last.getType() == Token.STRING) {\n           String propName = last.getString();\n    */\n   static boolean containsTypeInOuterScope(Node node, int type) {\n     return containsType(node, type,\n-        Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION)));\n+        Predicates.<Node>not(new MatchNodeType(Token.FUNCTION)));\n   }\n \n   /**\n         // Note that by this point, unicode escapes have been converted\n         // to UTF-16 characters, so we're only searching for character\n         // values, not escapes.\n-        NodeUtil.isLatin(name);\n+        isLatin(name);\n   }\n \n   private static class VarCollector implements Visitor {\n     visitPreOrder(\n         root,\n         collector,\n-        Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION)));\n+        Predicates.<Node>not(new MatchNodeType(Token.FUNCTION)));\n     return collector.vars.values();\n   }\n \n    *     some constructor.\n    */\n   static boolean isPrototypePropertyDeclaration(Node n) {\n-    if (!NodeUtil.isExprAssign(n)) {\n+    if (!isExprAssign(n)) {\n       return false;\n     }\n     return isPrototypeProperty(n.getFirstChild().getFirstChild());\n--- a/src/com/google/javascript/jscomp/RemoveConstantExpressions.java\n+++ b/src/com/google/javascript/jscomp/RemoveConstantExpressions.java\n       this.changeProxy.registerListener(\n           new ReportCodeHasChangedListener(result));\n     }\n-    \n+\n     @Override\n     public void visit(NodeTraversal traversal, Node node, Node parent) {\n       trySimplify(parent, node);\n       }\n \n       Node exprBody = node.getFirstChild();\n-      if (!NodeUtil.nodeTypeMayHaveSideEffects(exprBody)) {\n+      if (!NodeUtil.nodeTypeMayHaveSideEffects(exprBody)\n+          || exprBody.getType() == Token.NEW\n+          || exprBody.getType() == Token.CALL) {\n         changeProxy.replaceWith(parent, node, getSideEffectNodes(exprBody));\n       }\n     }\n       }\n       return replacements;\n     }\n-    \n+\n     public Result getResult() {\n       return result;\n     }\n   }\n-  \n+\n   /**\n    * Used to reports code changes to the compiler as they happen.\n    */\n   private static class ReportCodeHasChangedListener\n       implements AstChangeProxy.ChangeListener {\n     private final Result result;\n-    \n+\n     private ReportCodeHasChangedListener(Result result) {\n       this.result = result;\n     }\n--- a/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n  \n package com.google.javascript.rhino.jstype;\n \n+import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n-import com.google.common.collect.Sets;\n import com.google.javascript.rhino.jstype.UnionType;\n \n import static com.google.javascript.rhino.jstype.JSTypeNative.ALL_TYPE;\n           result = registry.getNativeType(UNKNOWN_TYPE);\n         }\n       } else {\n-        Set<JSType> alternateSet = Sets.newUnmodifiableHashSet(alternates);\n+        Set<JSType> alternateSet = ImmutableSet.copyOf(alternates);\n         int size = alternateSet.size();\n         if (size > MAX_UNION_SIZE) {\n           result = registry.getNativeType(UNKNOWN_TYPE);\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n          \"var FOO = true, BAR = 5, CCC = true, DDD = true;\");\n   }\n \n+  public void testDefineFlag2() {\n+    args.add(\"--define=FOO='x\\\"'\");\n+    test(\"/** @define {string} */ var FOO = \\\"a\\\";\",\n+         \"var FOO = \\\"x\\\\\\\"\\\";\");\n+  }\n+\n+  public void testDefineFlag3() {\n+    args.add(\"--define=FOO=\\\"x'\\\"\");\n+    test(\"/** @define {string} */ var FOO = \\\"a\\\";\",\n+         \"var FOO = \\\"x'\\\";\");\n+  }\n+\n   public void testScriptStrictModeNoWarning() {\n     test(\"'use strict';\", \"\");\n     test(\"'no use strict';\", CheckSideEffects.USELESS_CODE_ERROR);\n--- a/test/com/google/javascript/jscomp/RemoveConstantExpressionsTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveConstantExpressionsTest.java\n   public void testRemoveFromLabel2() {\n     test(\"LBL: foo() + 1 + bar()\", \"LBL: {foo();bar()}\");\n   }\n+\n+  public void testCall1() {\n+    test(\"Math.sin(0);\", \"\");\n+  }\n+\n+  public void testCall2() {\n+    test(\"1 + Math.sin(0);\", \"\");\n+  }\n+\n+  public void testNew1() {\n+    test(\"new Date;\", \"\");\n+  }\n+\n+  public void testNew2() {\n+    test(\"1 + new Date;\", \"\");\n+  }\n }", "timestamp": 1270665242, "metainfo": ""}