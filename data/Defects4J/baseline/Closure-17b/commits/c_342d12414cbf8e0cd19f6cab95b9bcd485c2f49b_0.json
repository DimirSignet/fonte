{"sha": "342d12414cbf8e0cd19f6cab95b9bcd485c2f49b", "log": "Fixes generateExports for enums Fixes issue 310  R=johnlenz,jschorr DELTA=226  (141 added, 6 deleted, 79 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4138   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ExternExportsPass.java\n+++ b/src/com/google/javascript/jscomp/ExternExportsPass.java\n      * it to the externsRoot AST.\n      */\n     void generateExterns() {\n-      appendExtern(getExportedPath(), getFunctionValue(value));\n+      appendExtern(getExportedPath(), getValue(value));\n     }\n \n     /**\n      * a.b.c = function(x,y) { }\n      * </pre>\n      */\n-    protected void appendExtern(String path, Node functionToExport) {\n+    void appendExtern(String path, Node valueToExport) {\n       List<String> pathPrefixes = computePathPrefixes(path);\n \n       for (int i = 0; i < pathPrefixes.size(); ++i) {\n            * exported for a.b with a namespace.\n            */\n \n-          if (isCompletePathPrefix && functionToExport != null) {\n-            initializer = createExternFunction(functionToExport);\n+          if (isCompletePathPrefix && valueToExport != null) {\n+            if (valueToExport.isFunction()) {\n+              initializer = createExternFunction(valueToExport);\n+            } else {\n+              Preconditions.checkState(valueToExport.isObjectLit());\n+              initializer = createExternObjectLit(valueToExport);\n+            }\n           } else {\n-            initializer = IR.objectlit();\n+            initializer = IR.empty();\n           }\n \n           appendPathDefinition(pathPrefix, initializer);\n       Node pathDefinition;\n \n       if (!path.contains(\".\")) {\n-        pathDefinition = NodeUtil.newVarNode(path, initializer);\n+        if (initializer.isEmpty()) {\n+          pathDefinition = IR.var(IR.name(path));\n+        } else {\n+          pathDefinition = NodeUtil.newVarNode(path, initializer);\n+        }\n       } else {\n         Node qualifiedPath = NodeUtil.newQualifiedNameNode(\n             compiler.getCodingConvention(), path);\n-        pathDefinition = NodeUtil.newExpr(\n-            IR.assign(qualifiedPath, initializer));\n+        if (initializer.isEmpty()) {\n+          pathDefinition = NodeUtil.newExpr(qualifiedPath);\n+        } else {\n+          pathDefinition = NodeUtil.newExpr(\n+              IR.assign(qualifiedPath, initializer));\n+        }\n       }\n \n       externsRoot.addChildToBack(pathDefinition);\n       externFunction.setJSType(exportedFunction.getJSType());\n \n       return externFunction;\n+    }\n+\n+    /**\n+     * Given an object literal to export, create an object lit with all its\n+     * string properties. We don't care what the values of those properties\n+     * are because they are not checked.\n+     */\n+    private Node createExternObjectLit(Node exportedObjectLit) {\n+      Node lit = IR.objectlit();\n+      lit.setJSType(exportedObjectLit.getJSType());\n+\n+      // This is an indirect way of telling the typed code generator\n+      // \"print the type of this\"\n+      lit.setJSDocInfo(new JSDocInfo());\n+\n+      int index = 1;\n+      for (Node child = exportedObjectLit.getFirstChild();\n+           child != null;\n+           child = child.getNext()) {\n+        if (child.isString()) {\n+          lit.addChildToBack(\n+              IR.propdef(\n+                  IR.string(child.getString()),\n+                  IR.number(index++)));\n+        }\n+      }\n+      return lit;\n     }\n \n     /**\n \n     /**\n      * If the given value is a qualified name which refers\n-     * a function, the function's node is returned. Otherwise,\n+     * a function or object literal, the node is returned. Otherwise,\n      * {@code null} is returned.\n      */\n-    protected Node getFunctionValue(Node qualifiedNameNode) {\n+    protected Node getValue(Node qualifiedNameNode) {\n       String qualifiedName = value.getQualifiedName();\n \n       if (qualifiedName == null) {\n \n       Node definition;\n \n-      switch(definitionParent.getType()) {\n+      switch (definitionParent.getType()) {\n         case Token.ASSIGN:\n           definition = definitionParent.getLastChild();\n           break;\n             return null;\n       }\n \n-      if (!definition.isFunction()) {\n+      if (!definition.isFunction() && !definition.isObjectLit()) {\n         return null;\n       }\n \n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n    * @param key the assign node\n    */\n   private void visitObjLitKey(NodeTraversal t, Node key, Node objlit) {\n+    // Do not validate object lit value types in externs. We don't really care,\n+    // and it makes it easier to generate externs.\n+    if (objlit.isFromExterns()) {\n+      ensureTyped(t, key);\n+      return;\n+    }\n+\n     // TODO(johnlenz): Validate get and set function declarations are valid\n     // as is the functions can have \"extraneous\" bits.\n \n--- a/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.Sets;\n+import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n \n import java.nio.charset.Charset;\n import java.util.Set;\n-\n \n /**\n  * A code generator that outputs type annotations for functions and\n         Node rhs = n.getFirstChild().getLastChild();\n         add(getTypeAnnotation(rhs));\n       } else if (n.isVar()\n-          && n.getFirstChild().getFirstChild() != null\n-          && n.getFirstChild().getFirstChild().isFunction()) {\n-        add(getFunctionAnnotation(n.getFirstChild().getFirstChild()));\n+          && n.getFirstChild().getFirstChild() != null) {\n+        add(getTypeAnnotation(n.getFirstChild().getFirstChild()));\n       }\n     }\n \n   }\n \n   private String getTypeAnnotation(Node node) {\n+    // Only add annotations for things with JSDoc, or function literals.\n+    JSDocInfo jsdoc = NodeUtil.getBestJSDocInfo(node);\n+    if (jsdoc == null && !node.isFunction()) {\n+      return \"\";\n+    }\n+\n     JSType type = node.getJSType();\n     if (type == null) {\n       return \"\";\n     } else if (type.isFunctionType()) {\n       return getFunctionAnnotation(node);\n+    } else if (type.isEnumType()) {\n+      return \"/** @enum {\" +\n+          type.toMaybeEnumType().getElementsType().toAnnotationString() +\n+          \"} */\\n\";\n     } else if (!type.isUnknownType()\n-        && !type.isEmptyType() && !type.isVoidType() &&\n-        !type.isFunctionPrototypeType()) {\n-      return \"/** @type {\" + node.getJSType() + \"} */\\n\";\n+        && !type.isEmptyType()\n+        && !type.isVoidType()\n+        && !type.isFunctionPrototypeType()) {\n+      return \"/** @type {\" + node.getJSType().toAnnotationString() + \"} */\\n\";\n     } else {\n       return \"\";\n     }\n         if (paramNode == null) {\n           break;\n         }\n-        sb.append(\" * @param {\" + getParameterNodeJSDocType(n) + \"} \");\n-        sb.append(paramNode.getString());\n-        sb.append(\"\\n\");\n+        sb.append(\" * \");\n+        appendAnnotation(sb, \"param\", getParameterNodeJSDocType(n));\n+        sb.append(\" \")\n+            .append(paramNode.getString())\n+            .append(\"\\n\");\n         paramNode = paramNode.getNext();\n       }\n     }\n     // Return type\n     JSType retType = funType.getReturnType();\n     if (retType != null && !retType.isUnknownType() && !retType.isEmptyType()) {\n-      sb.append(\" * @return {\" + retType + \"}\\n\");\n+      sb.append(\" * \");\n+      appendAnnotation(sb, \"return\", retType.toAnnotationString());\n+      sb.append(\"\\n\");\n     }\n \n     // Constructor/interface\n         ObjectType superInstance =\n           funType.getSuperClassConstructor().getInstanceType();\n         if (!superInstance.toString().equals(\"Object\")) {\n-          sb.append(\" * @extends {\"  + superInstance + \"}\\n\");\n+          sb.append(\" * \");\n+          appendAnnotation(sb, \"extends\", superInstance.toAnnotationString());\n+          sb.append(\"\\n\");\n         }\n       }\n \n       if (funType.isInterface()) {\n         for (ObjectType interfaceType : funType.getExtendedInterfaces()) {\n-          sb.append(\" * @extends {\" + interfaceType + \"}\\n\");\n+          sb.append(\" * \");\n+          appendAnnotation(sb, \"extends\", interfaceType.toAnnotationString());\n+          sb.append(\"\\n\");\n         }\n       }\n \n       // Avoid duplicates, add implemented type to a set first\n       Set<String> interfaces = Sets.newTreeSet();\n       for (ObjectType interfaze : funType.getImplementedInterfaces()) {\n-        interfaces.add(interfaze.toString());\n+        interfaces.add(interfaze.toAnnotationString());\n       }\n       for (String interfaze : interfaces) {\n-        sb.append(\" * @implements {\"  + interfaze + \"}\\n\");\n+        sb.append(\" * \");\n+        appendAnnotation(sb, \"implements\", interfaze);\n+        sb.append(\"\\n\");\n       }\n \n       if (funType.isConstructor()) {\n \n     sb.append(\" */\\n\");\n     return sb.toString();\n+  }\n+\n+  private void appendAnnotation(StringBuilder sb, String name, String type) {\n+    sb.append(\"@\").append(name).append(\" {\").append(type).append(\"}\");\n   }\n \n   /**\n     } else {\n       // Fix-up optional and vararg parameters to match JSDoc type language\n       if (parameterNode.isOptionalArg()) {\n-        typeString = parameterType.restrictByNotNullOrUndefined() + \"=\";\n+        typeString =\n+            parameterType.restrictByNotNullOrUndefined().toAnnotationString() +\n+            \"=\";\n       } else if (parameterNode.isVarArgs()) {\n-        typeString = \"...\" + parameterType.restrictByNotNullOrUndefined();\n+        typeString = \"...\" +\n+            parameterType.restrictByNotNullOrUndefined().toAnnotationString();\n       } else {\n-        typeString = parameterType.toString();\n+        typeString = parameterType.toAnnotationString();\n       }\n     }\n \n--- a/src/com/google/javascript/rhino/jstype/AllType.java\n+++ b/src/com/google/javascript/rhino/jstype/AllType.java\n   }\n \n   @Override\n-  public String toString() {\n+  String toStringHelper(boolean forAnnotations) {\n     return \"*\";\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/ArrowType.java\n+++ b/src/com/google/javascript/rhino/jstype/ArrowType.java\n     }\n     return returnType == null || returnType.isUnknownType();\n   }\n+\n+  @Override\n+  String toStringHelper(boolean forAnnotations) {\n+    return super.toString();\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/BooleanType.java\n+++ b/src/com/google/javascript/rhino/jstype/BooleanType.java\n   }\n \n   @Override\n-  public String toString() {\n+  String toStringHelper(boolean forAnnotations) {\n     return getDisplayName();\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/EnumElementType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumElementType.java\n   }\n \n   @Override\n-  public String toString() {\n-    return getReferenceName() + \".<\" + primitiveType + \">\";\n+  String toStringHelper(boolean forAnnotations) {\n+    return forAnnotations ?\n+        primitiveType.toString() :\n+        (getReferenceName() + \".<\" + primitiveType + \">\");\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/EnumType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumType.java\n   }\n \n   @Override\n-  public String toString() {\n-    return getReferenceName();\n+  String toStringHelper(boolean forAnnotations) {\n+    return forAnnotations ? \"Object\" : getReferenceName();\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n    * {@code this:T} if the function expects a known type for {@code this}.\n    */\n   @Override\n-  public String toString() {\n+  String toStringHelper(boolean forAnnotations) {\n     if (!isPrettyPrint() ||\n         this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {\n       return \"Function\";\n       } else {\n         b.append(\"this:\");\n       }\n-      b.append(typeOfThis.toString());\n+      b.append(typeOfThis.toStringHelper(forAnnotations));\n     }\n     if (paramNum > 0) {\n       if (hasKnownTypeOfThis) {\n         b.append(\", \");\n       }\n       Node p = call.parameters.getFirstChild();\n-      appendArgString(b, p);\n+      appendArgString(b, p, forAnnotations);\n \n       p = p.getNext();\n       while (p != null) {\n         b.append(\", \");\n-        appendArgString(b, p);\n+        appendArgString(b, p, forAnnotations);\n         p = p.getNext();\n       }\n     }\n     b.append(\"): \");\n-    b.append(call.returnType);\n+    b.append(call.returnType.toStringHelper(forAnnotations));\n \n     setPrettyPrint(true);\n     return b.toString();\n   }\n \n-  private void appendArgString(StringBuilder b, Node p) {\n+  private void appendArgString(\n+      StringBuilder b, Node p, boolean forAnnotations) {\n     if (p.isVarArgs()) {\n-      appendVarArgsString(b, p.getJSType());\n+      appendVarArgsString(b, p.getJSType(), forAnnotations);\n     } else if (p.isOptionalArg()) {\n-      appendOptionalArgString(b, p.getJSType());\n+      appendOptionalArgString(b, p.getJSType(), forAnnotations);\n     } else {\n-      b.append(p.getJSType().toString());\n+      b.append(p.getJSType().toStringHelper(forAnnotations));\n     }\n   }\n \n   /** Gets the string representation of a var args param. */\n-  private void appendVarArgsString(StringBuilder builder, JSType paramType) {\n+  private void appendVarArgsString(StringBuilder builder, JSType paramType,\n+      boolean forAnnotations) {\n     if (paramType.isUnionType()) {\n       // Remove the optionalness from the var arg.\n       paramType = paramType.toMaybeUnionType().getRestrictedUnion(\n           registry.getNativeType(JSTypeNative.VOID_TYPE));\n     }\n-    builder.append(\"...[\").append(paramType.toString()).append(\"]\");\n+    builder.append(\"...[\").append(\n+        paramType.toStringHelper(forAnnotations)).append(\"]\");\n   }\n \n   /** Gets the string representation of an optional param. */\n   private void appendOptionalArgString(\n-      StringBuilder builder, JSType paramType) {\n+      StringBuilder builder, JSType paramType, boolean forAnnotations) {\n     if (paramType.isUnionType()) {\n       // Remove the optionalness from the var arg.\n       paramType = paramType.toMaybeUnionType().getRestrictedUnion(\n           registry.getNativeType(JSTypeNative.VOID_TYPE));\n     }\n-    builder.append(paramType).append(\"=\");\n+    builder.append(paramType.toStringHelper(forAnnotations)).append(\"=\");\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n   }\n \n   @Override\n-  public String toString() {\n+  String toStringHelper(boolean forAnnotations) {\n     if (constructor.hasReferenceName()) {\n       return constructor.getReferenceName();\n     } else {\n-      return super.toString();\n+      return super.toStringHelper(forAnnotations);\n     }\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n   }\n \n   /**\n+   * A string representation of this type, suitable for printing\n+   * in warnings.\n+   */\n+  @Override\n+  public String toString() {\n+    return toStringHelper(false);\n+  }\n+\n+  /**\n    * A hash code function for diagnosing complicated issues\n    * around type-identity.\n    */\n   public String toDebugHashCodeString() {\n     return \"{\" + this.hashCode() + \"}\";\n   }\n+\n+  /**\n+   * A string representation of this type, suitable for printing\n+   * in type annotations at code generation time.\n+   */\n+  public final String toAnnotationString() {\n+    return toStringHelper(true);\n+  }\n+\n+  /**\n+   * @param forAnnotations Whether this is for use in code generator\n+   *     annotations. Otherwise, it's for warnings.\n+   */\n+  abstract String toStringHelper(boolean forAnnotations);\n }\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n   }\n \n   @Override\n-  public String toString() {\n+  String toStringHelper(boolean forAnnotations) {\n     return reference;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/NoObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/NoObjectType.java\n   }\n \n   @Override\n-  public String toString() {\n-    return \"NoObject\";\n+  String toStringHelper(boolean forAnnotations) {\n+    return forAnnotations ? \"?\" : \"NoObject\";\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/NoResolvedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NoResolvedType.java\n   }\n \n   @Override\n-  public String toString() {\n-    return \"NoResolvedType\";\n+  String toStringHelper(boolean forAnnotations) {\n+    return forAnnotations ? \"?\" : \"NoResolvedType\";\n   }\n }\n--- a/src/com/google/javascript/rhino/jstype/NoType.java\n+++ b/src/com/google/javascript/rhino/jstype/NoType.java\n   }\n \n   @Override\n-  public String toString() {\n-    return \"None\";\n+  String toStringHelper(boolean forAnnotations) {\n+    return forAnnotations ? \"?\" : \"None\";\n   }\n }\n--- a/src/com/google/javascript/rhino/jstype/NullType.java\n+++ b/src/com/google/javascript/rhino/jstype/NullType.java\n   }\n \n   @Override\n-  public String toString() {\n+  String toStringHelper(boolean forAnnotations) {\n     return getDisplayName();\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/NumberType.java\n+++ b/src/com/google/javascript/rhino/jstype/NumberType.java\n   }\n \n   @Override\n-  public String toString() {\n+  String toStringHelper(boolean forAnnotations) {\n     return getDisplayName();\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n   }\n \n   @Override\n-  public String toString() {\n+  String toStringHelper(boolean forAnnotations) {\n     if (hasReferenceName()) {\n       return getReferenceName();\n     } else if (prettyPrint) {\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n   }\n \n   @Override\n-  public String toString() {\n-    return referencedType.toString();\n+  String toStringHelper(boolean forAnnotations) {\n+    return referencedType.toStringHelper(forAnnotations);\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/StringType.java\n+++ b/src/com/google/javascript/rhino/jstype/StringType.java\n   }\n \n   @Override\n-  public String toString() {\n+  String toStringHelper(boolean forAnnotations) {\n     return getDisplayName();\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/TemplateType.java\n+++ b/src/com/google/javascript/rhino/jstype/TemplateType.java\n   }\n \n   @Override\n-  public String toString() {\n+  String toStringHelper(boolean forAnnotations) {\n     return name;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n     return restricted.build();\n   }\n \n-  @Override public String toString() {\n+  @Override String toStringHelper(boolean forAnnotations) {\n     StringBuilder result = new StringBuilder();\n     boolean firstAlternate = true;\n \n       if (!firstAlternate) {\n         result.append(\"|\");\n       }\n-      result.append(t.toString());\n+      result.append(t.toStringHelper(forAnnotations));\n       firstAlternate = false;\n     }\n     result.append(\")\");\n--- a/src/com/google/javascript/rhino/jstype/UnknownType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnknownType.java\n   }\n \n   @Override\n-  public String toString() {\n+  String toStringHelper(boolean forAnnotations) {\n     return getReferenceName();\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/VoidType.java\n+++ b/src/com/google/javascript/rhino/jstype/VoidType.java\n   }\n \n   @Override\n-  public String toString() {\n+  String toStringHelper(boolean forAnnotations) {\n     return getDisplayName();\n   }\n \n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n         \"function t2() {\\n  }\\n\" +\n         \"  t1.prototype = t2.prototype\\n};\\n\"\n     );\n+  }\n+\n+  public void testEnumAnnotation1() {\n+    assertTypeAnnotations(\n+        \"/** @enum {string} */ var Enum = {FOO: 'x', BAR: 'y'};\",\n+        \"/** @enum {string} */\\nvar Enum = {FOO:\\\"x\\\", BAR:\\\"y\\\"};\\n\");\n+  }\n+\n+  public void testEnumAnnotation2() {\n+    assertTypeAnnotations(\n+        \"var goog = goog || {};\" +\n+        \"/** @enum {string} */ goog.Enum = {FOO: 'x', BAR: 'y'};\" +\n+        \"/** @const */ goog.Enum2 = goog.x ? {} : goog.Enum;\",\n+        \"var goog = goog || {};\\n\" +\n+        \"/** @enum {string} */\\ngoog.Enum = {FOO:\\\"x\\\", BAR:\\\"y\\\"};\\n\" +\n+        \"/** @type {(Object|{})} */\\ngoog.Enum2 = goog.x ? {} : goog.Enum;\\n\");\n   }\n \n   private void assertPrettyPrint(String js, String expected) {\n--- a/test/com/google/javascript/jscomp/ExternExportsPassTest.java\n+++ b/test/com/google/javascript/jscomp/ExternExportsPassTest.java\n   public void testExportProperty() throws Exception {\n     compileAndCheck(\"var a = {}; a.b = {}; a.b.c = function(d, e, f) {};\" +\n                     \"goog.exportProperty(a.b, 'cprop', a.b.c)\",\n-                    \"var a = {};\\n\" +\n-                    \"a.b = {};\\n\" +\n+                    \"var a;\\n\" +\n+                    \"a.b;\\n\" +\n                     \"/**\\n\" +\n                     \" * @param {*} d\\n\" +\n                     \" * @param {*} e\\n\" +\n                     \"goog.exportProperty(a.b, 'c', a.b.c);\" +\n                     \"goog.exportProperty(a.b.prototype, 'c', a.b.prototype.c);\",\n \n-                    \"var a = {};\\n\" +\n+                    \"var a;\\n\" +\n                     \"/**\\n\" +\n                     \" * @param {*} p1\\n\" +\n                     \" * @return {undefined}\\n\" +\n                     \"goog.exportProperty(a.b, 'c', a.b.c);\" +\n                     \"goog.exportProperty(a.b.prototype, 'c', a.b.prototype.c);\",\n \n+                    \"/** @type {{b: function (?): undefined}} */\\n\" +\n                     \"var hello = {};\\n\" +\n-                    \"hello.b = {};\\n\" +\n+                    \"hello.b;\\n\" +\n                     \"/**\\n\" +\n                     \" * @param {*} d\\n\" +\n                     \" * @param {*} e\\n\" +\n   public void testExportNonStaticSymbol() throws Exception {\n     compileAndCheck(\"var a = {}; a.b = {}; var d = {}; a.b.c = d;\" +\n                     \"goog.exportSymbol('foobar', a.b.c)\",\n-                    \"var foobar = {};\\n\");\n+                    \"var foobar;\\n\");\n   }\n \n   public void testExportNonStaticSymbol2() throws Exception {\n     compileAndCheck(\"var a = {}; a.b = {}; var d = null; a.b.c = d;\" +\n                     \"goog.exportSymbol('foobar', a.b.c())\",\n-                    \"var foobar = {};\\n\");\n+                    \"var foobar;\\n\");\n   }\n \n   public void testExportNonexistentProperty() throws Exception {\n     compileAndCheck(\"var a = {}; a.b = {}; a.b.c = function(d, e, f) {};\" +\n                     \"goog.exportProperty(a.b, 'none', a.b.none)\",\n-                    \"var a = {};\\n\" +\n-                    \"a.b = {};\\n\" +\n-                    \"a.b.none = {};\\n\");\n+                    \"var a;\\n\" +\n+                    \"a.b;\\n\" +\n+                    \"a.b.none;\\n\");\n   }\n \n   public void testExportSymbolWithTypeAnnotation() {\n    * Enums are not currently handled.\n    */\n    public void testExportEnum() {\n+     // We don't care what the values of the object properties are.\n+     // They're ignored by the type checker, and even if they weren't, it'd\n+     // be incomputable to get them correct in all cases\n+     // (think complex objects).\n      compileAndCheck(\n-         \"/** @enum {string}\\n @export */ var E = {A:1, B:2};\" +\n+         \"/** @enum {string}\\n @export */ var E = {A:8, B:9};\" +\n          \"goog.exportSymbol('E', E);\",\n-         // TODO(johnlenz): We would like this:\n-         // \"/**\\n\" +\n-         // \" * @enum {string}\\n\" +\n-         //\" */\\n\" +\n-         \"var E = {};\\n\"\n-     );\n+         \"/** @enum {string} */\\n\" +\n+         \"var E = {A:1, B:2};\\n\");\n    }\n \n   /** If we export a property with \"prototype\" as a path component, there\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"actual parameter 1 of f does not match formal parameter\\n\" +\n         \"found   : boolean\\n\" +\n         \"required: string\", false);\n+  }\n+\n+\n+  public void testTypeCheckCustomExterns2() throws Exception {\n+    testTypes(\n+        DEFAULT_EXTERNS + \"/** @enum {string} */ var Enum = {FOO: 1, BAR: 1};\",\n+        \"/** @param {Enum} x */ function f(x) {} f(Enum.FOO); f(true);\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: Enum.<string>\",\n+        false);\n   }\n \n   public void testParameterizedArray1() throws Exception {", "timestamp": 1327611856, "metainfo": ""}