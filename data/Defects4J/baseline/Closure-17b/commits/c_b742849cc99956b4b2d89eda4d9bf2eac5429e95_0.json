{"sha": "b742849cc99956b4b2d89eda4d9bf2eac5429e95", "log": "Simplify property checks   Tested: yes  R=johnlenz DELTA=424  (268 added, 55 deleted, 101 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4352   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   Node parseTestCode(String js) {\n     initCompilerOptionsIfTesting();\n     CompilerInput input = new CompilerInput(\n-        SourceFile.fromCode(\" [testcode] \", js));\n+        SourceFile.fromCode(\"[testcode]\", js));\n     if (inputsById == null) {\n       inputsById = Maps.newHashMap();\n     }\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n     Node lvalue = assign.getFirstChild();\n     Node rvalue = assign.getLastChild();\n \n+    // Check property sets to 'object.property' when 'object' is known.\n     if (lvalue.isGetProp()) {\n       Node object = lvalue.getFirstChild();\n       JSType objectJsType = getJSType(object);\n         }\n       }\n \n-      // /** @type ... */object.name = ...;\n-      if (info != null && info.hasType()) {\n-        visitAnnotatedAssignGetprop(t, assign,\n-            info.getType().evaluate(t.getScope(), typeRegistry), object,\n-            property, rvalue);\n-        return;\n-      }\n-\n       checkEnumAlias(t, info, rvalue);\n \n+      // Prototype assignments are special, because they actually affect\n+      // the definition of a class. These are mostly validated\n+      // during TypedScopeCreator, and we only look for the \"dumb\" cases here.\n       // object.prototype = ...;\n       if (property.equals(\"prototype\")) {\n         if (objectJsType != null && objectJsType.isFunctionType()) {\n             JSType rvalueType = rvalue.getJSType();\n             validator.expectObject(t, rvalue, rvalueType,\n                 OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n+            return;\n           }\n-        } else {\n-          // TODO(user): might want to flag that\n-        }\n-        return;\n-      }\n-\n+        }\n+      }\n+\n+      // Inheritance checks for prototype properties.\n+      //\n+      // TODO(nicksantos): This isn't the right place to do this check. We\n+      // really want to do this when we're looking at the constructor.\n+      // We'd find all its properties and make sure they followed inheritance\n+      // rules, like we currently do for @implements to make sure\n+      // all the methods are implemented.\n+      //\n+      // As-is, this misses many other ways to override a property.\n+      //\n       // object.prototype.property = ...;\n       if (object.isGetProp()) {\n         Node object2 = object.getFirstChild();\n               checkDeclaredPropertyInheritance(\n                   t, assign, functionType, property, info, getJSType(rvalue));\n             }\n-          } else {\n-            // TODO(user): might want to flag that\n           }\n-          return;\n-        }\n-      }\n-\n+        }\n+      }\n+\n+      // The generic checks for 'object.property' when 'object' is known,\n+      // and 'property' is declared on it.\n       // object.property = ...;\n       ObjectType type = ObjectType.cast(\n           objectJsType.restrictByNotNullOrUndefined());\n           validator.expectCanAssignToPropertyOf(\n               t, assign, getJSType(rvalue),\n               type.getPropertyType(property), object, property);\n-        }\n-        return;\n-      }\n-    } else if (lvalue.isName()) {\n+          return;\n+        }\n+      }\n+    }\n+\n+    // Check qualified name sets to 'object' and 'object.property'.\n+    // This can sometimes handle cases when the type of 'object' is not known.\n+    // e.g.,\n+    // var obj = createUnknownType();\n+    // /** @type {number} */ obj.foo = true;\n+    JSType leftType = getJSType(lvalue);\n+    if (lvalue.isQualifiedName()) {\n       // variable with inferred type case\n       JSType rvalueType = getJSType(assign.getLastChild());\n-      Var var = t.getScope().getVar(lvalue.getString());\n+      Var var = t.getScope().getVar(lvalue.getQualifiedName());\n       if (var != null) {\n         if (var.isTypeInferred()) {\n           return;\n         }\n-      }\n-    }\n-\n-    // fall through case\n-    JSType leftType = getJSType(lvalue);\n+\n+        if (var.getType() != null) {\n+          leftType = var.getType();\n+        }\n+      }\n+    }\n+\n+    // Fall through case for arbitrary LHS and arbitrary RHS.\n     Node rightChild = assign.getLastChild();\n     JSType rightType = getJSType(rightChild);\n     if (validator.expectCanAssignTo(\n \n     FunctionType superClass = ctorType.getSuperClassConstructor();\n     boolean superClassHasProperty = superClass != null &&\n-        superClass.getPrototype().hasProperty(propertyName);\n+        superClass.getInstanceType().hasProperty(propertyName);\n     // For interface\n     boolean superInterfacesHasProperty = false;\n     if (ctorType.isInterface()) {\n     if (superClassHasProperty) {\n       // there is a superclass implementation\n       JSType superClassPropType =\n-          superClass.getPrototype().getPropertyType(propertyName);\n+          superClass.getInstanceType().getPropertyType(propertyName);\n       if (!propertyType.canAssignTo(superClassPropType)) {\n         compiler.report(\n             t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n           t.makeError(object, INTERFACE_FUNCTION_NOT_EMPTY,\n               abstractMethodName));\n     }\n-  }\n-\n-  /**\n-   * Visits an ASSIGN node for cases such as\n-   * <pre>\n-   * object.property = ...;\n-   * </pre>\n-   * that have an {@code @type} annotation.\n-   */\n-  private void visitAnnotatedAssignGetprop(NodeTraversal t,\n-      Node assign, JSType type, Node object, String property, Node rvalue) {\n-    // verifying that the rvalue has the correct type\n-    validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type,\n-        object, property);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n         // the line numbers of both types.\n         registerMismatch(rightType, leftType, null);\n       } else {\n+        // Do not type-check interface methods, because we expect that\n+        // they will have dummy implementations that do not match the type\n+        // annotations.\n+        JSType ownerType = getJSType(owner);\n+        if (ownerType.isFunctionPrototypeType()) {\n+          FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n+          if (ownerFn.isInterface() &&\n+              rightType.isFunctionType() && leftType.isFunctionType()) {\n+            return true;\n+          }\n+        }\n+\n         mismatch(t, n,\n             \"assignment to property \" + propName + \" of \" +\n             getReadableJSTypeName(owner, true),\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n    */\n   public ObjectType getTopMostDefiningType(String propertyName) {\n     Preconditions.checkState(isConstructor() || isInterface());\n-    Preconditions.checkArgument(getPrototype().hasProperty(propertyName));\n+    Preconditions.checkArgument(getInstanceType().hasProperty(propertyName));\n     FunctionType ctor = this;\n \n     if (isInterface()) {\n       return getTopDefiningInterface(this.getInstanceType(), propertyName);\n     }\n \n-    ObjectType topInstanceType = ctor.getInstanceType();\n-    while (true) {\n+    ObjectType topInstanceType = null;\n+    do {\n       topInstanceType = ctor.getInstanceType();\n       ctor = ctor.getSuperClassConstructor();\n-      if (ctor == null || !ctor.getPrototype().hasProperty(propertyName)) {\n-        break;\n-      }\n-    }\n+    } while (ctor != null\n+        && ctor.getPrototype().hasProperty(propertyName));\n+\n     return topInstanceType;\n   }\n \n--- a/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n   static final String CLOSURE_DEFS =\n       \"var goog = {};\" +\n       \"goog.inherits = function(x, y) {};\" +\n-      \"goog.abstractMethod = function() {};\" +\n+      \"/** @type {!Function} */ goog.abstractMethod = function() {};\" +\n       \"goog.isArray = function(x) {};\" +\n       \"goog.isDef = function(x) {};\" +\n       \"goog.isFunction = function(x) {};\" +\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n   }\n \n   public void testDuplicateStaticPropertyDecl4() throws Exception {\n-    testTypes(\n+    testClosureTypesMultipleWarnings(\n         \"var goog = goog || {};\" +\n         \"/** @type {!Foo} */ goog.foo;\" +\n         \"/** @type {string} */ goog.foo = 'x';\" +\n         \"/** @constructor */ function Foo() {}\",\n-        \"variable goog.foo redefined with type string, \" +\n-        \"original definition at [testcode]:1 with type Foo\");\n+        Lists.newArrayList(\n+            \"assignment to property foo of goog\\n\" +\n+            \"found   : string\\n\" +\n+            \"required: Foo\",\n+            \"variable goog.foo redefined with type string, \" +\n+            \"original definition at [testcode]:1 with type Foo\"));\n   }\n \n   public void testDuplicateStaticPropertyDecl5() throws Exception {\n-    testTypes(\n+    testClosureTypesMultipleWarnings(\n         \"var goog = goog || {};\" +\n         \"/** @type {!Foo} */ goog.foo;\" +\n         \"/** @type {string}\\n * @suppress {duplicate} */ goog.foo = 'x';\" +\n         \"/** @constructor */ function Foo() {}\",\n-        \"variable goog.foo redefined with type string, \" +\n-        \"original definition at [testcode]:1 with type Foo\");\n+        Lists.newArrayList(\n+            \"assignment to property foo of goog\\n\" +\n+            \"found   : string\\n\" +\n+            \"required: Foo\",\n+            \"variable goog.foo redefined with type string, \" +\n+            \"original definition at [testcode]:1 with type Foo\"));\n   }\n \n   public void testDuplicateStaticPropertyDecl6() throws Exception {\n         \"function f(x) { /** @type {string} */ var x = ''; }\",\n         Lists.newArrayList(\n             \"variable x redefined with type string, original definition\" +\n-            \" at  [testcode] :2 with type number\",\n+            \" at [testcode]:2 with type number\",\n             \"initializing variable\\n\" +\n             \"found   : string\\n\" +\n             \"required: number\"));\n         \"var x = f();\" +\n         \"/** @type {string} */\" +\n         \"x.y = 3;\",\n-        \"assignment to property y of x\\n\" +\n+        \"assignment\\n\" +\n         \"found   : number\\n\" +\n         \"required: string\");\n   }\n   }\n \n   public void testErrorMismatchingPropertyOnInterface6() throws Exception {\n-    testTypes(\"/** @interface */ function T() {};\\n\" +\n+    testClosureTypesMultipleWarnings(\n+        \"/** @interface */ function T() {};\\n\" +\n         \"/** @return {number} */T.prototype.x = 1\",\n-        \"interface members can only be empty property declarations, \"\n-        + \"empty functions, or goog.abstractMethod\"\n-        );\n+        Lists.newArrayList(\n+            \"assignment to property x of T.prototype\\n\" +\n+            \"found   : number\\n\" +\n+            \"required: function (this:T): number\",\n+            \"interface members can only be empty property declarations, \" +\n+            \"empty functions, or goog.abstractMethod\"));\n   }\n \n   public void testInterfaceNonEmptyFunction() throws Exception {\n   }\n \n   public void testDirectPrototypeAssign() throws Exception {\n+    // For now, we just ignore @type annotations on the prototype.\n     testTypes(\n         \"/** @constructor */ function Foo() {}\" +\n         \"/** @constructor */ function Bar() {}\" +\n-        \"/** @type {Array} */ Bar.prototype = new Foo()\",\n-        \"assignment to property prototype of Bar\\n\" +\n-        \"found   : Foo\\n\" +\n-        \"required: (Array|null|undefined)\");\n+        \"/** @type {Array} */ Bar.prototype = new Foo()\");\n   }\n \n   // In all testResolutionViaRegistry* tests, since u is unknown, u.T can only\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n   }\n \n   public void testDuplicateStaticPropertyDecl4() throws Exception {\n-    testTypes(\n+    testClosureTypesMultipleWarnings(\n         \"var goog = goog || {};\" +\n         \"/** @type {!Foo} */ goog.foo;\" +\n         \"/** @type {string} */ goog.foo = 'x';\" +\n         \"/** @constructor */ function Foo() {}\",\n-        \"variable goog.foo redefined with type string, \" +\n-        \"original definition at [testcode]:1 with type Foo\");\n+        Lists.newArrayList(\n+            \"assignment to property foo of goog\\n\" +\n+            \"found   : string\\n\" +\n+            \"required: Foo\",\n+            \"variable goog.foo redefined with type string, \" +\n+            \"original definition at [testcode]:1 with type Foo\"));\n   }\n \n   public void testDuplicateStaticPropertyDecl5() throws Exception {\n-    testTypes(\n+    testClosureTypesMultipleWarnings(\n         \"var goog = goog || {};\" +\n         \"/** @type {!Foo} */ goog.foo;\" +\n         \"/** @type {string}\\n * @suppress {duplicate} */ goog.foo = 'x';\" +\n         \"/** @constructor */ function Foo() {}\",\n-        \"variable goog.foo redefined with type string, \" +\n-        \"original definition at [testcode]:1 with type Foo\");\n+        Lists.newArrayList(\n+            \"assignment to property foo of goog\\n\" +\n+            \"found   : string\\n\" +\n+            \"required: Foo\",\n+            \"variable goog.foo redefined with type string, \" +\n+            \"original definition at [testcode]:1 with type Foo\"));\n   }\n \n   public void testDuplicateStaticPropertyDecl6() throws Exception {\n         \"function f(x) { /** @type {string} */ var x = ''; }\",\n         Lists.newArrayList(\n             \"variable x redefined with type string, original definition\" +\n-            \" at  [testcode] :2 with type number\",\n+            \" at [testcode]:2 with type number\",\n             \"initializing variable\\n\" +\n             \"found   : string\\n\" +\n             \"required: number\"));\n         \"/** @constructor */ function F() {}\" +\n         \"/** jsdoc */ F.prototype.bar = function() {};\" +\n         \"F.prototype.bar = function() {};\");\n+  }\n+\n+  public void testDuplicateInstanceMethod5() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function F() {}\" +\n+        \"/** jsdoc \\n * @return {number} */ F.prototype.bar = function() {\" +\n+        \"  return 3;\" +\n+        \"};\" +\n+        \"/** jsdoc \\n * @suppress {duplicate} */ \" +\n+        \"F.prototype.bar = function() { return ''; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testDuplicateInstanceMethod6() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function F() {}\" +\n+        \"/** jsdoc \\n * @return {number} */ F.prototype.bar = function() {\" +\n+        \"  return 3;\" +\n+        \"};\" +\n+        \"/** jsdoc \\n * @return {string} * \\n @suppress {duplicate} */ \" +\n+        \"F.prototype.bar = function() { return ''; };\",\n+        \"assignment to property bar of F.prototype\\n\" +\n+        \"found   : function (this:F): string\\n\" +\n+        \"required: function (this:F): number\");\n   }\n \n   public void testStubFunctionDeclaration1() throws Exception {\n         \"goog.SubDisposable.prototype.dispose = function() { return 0; };\");\n   }\n \n+  public void testGoodImplements7() throws Exception {\n+    testTypes(\n+        \"var myNullFunction = function() {};\" +\n+        \"/** @interface */\\n\" +\n+        \"goog.Disposable = function() {};\" +\n+        \"/** @return {number} */\" +\n+        \"goog.Disposable.prototype.dispose = function() {};\" +\n+        \"/** @implements {goog.Disposable}\\n * @constructor */\" +\n+        \"goog.SubDisposable = function() {};\" +\n+        \"/** @return {number} \\n @override */ \" +\n+        \"goog.SubDisposable.prototype.dispose = function() { return 0; };\");\n+  }\n+\n   public void testBadImplements1() throws Exception {\n     testTypes(\"/** @interface */function Base1() {}\\n\" +\n         \"/** @interface */function Base2() {}\\n\" +\n         \"/** @implements {Disposable}\\n * @interface */function f() {}\",\n         \"f cannot implement this type; an interface can only extend, \" +\n         \"but not implement interfaces\");\n+  }\n+\n+  public void testBadImplements5() throws Exception {\n+    testTypes(\"/** @interface */function Disposable() {}\\n\" +\n+        \"/** @type {number} */ Disposable.prototype.bar = function() {};\",\n+        \"assignment to property bar of Disposable.prototype\\n\" +\n+        \"found   : function (): undefined\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testBadImplements6() throws Exception {\n+    testClosureTypesMultipleWarnings(\n+        \"/** @interface */function Disposable() {}\\n\" +\n+        \"/** @type {function()} */ Disposable.prototype.bar = 3;\",\n+        Lists.newArrayList(\n+            \"assignment to property bar of Disposable.prototype\\n\" +\n+            \"found   : number\\n\" +\n+            \"required: function (): ?\",\n+            \"interface members can only be empty property declarations, \" +\n+            \"empty functions, or goog.abstractMethod\"));\n   }\n \n   public void testInterfaceExtends() throws Exception {\n   }\n \n   public void testOverriddenParams4() throws Exception {\n-    // TODO(nicksantos): This should emit a warning.\n     testTypes(\n         \"/** @constructor */ function Foo() {}\" +\n         \"/** @type {function(...[number])} */\" +\n         \" * @type {function(number)}\\n\" +\n         \" * @override\\n\" +\n         \" */\" +\n-        \"SubFoo.prototype.bar = function(x) {};\");\n-    /*\n+        \"SubFoo.prototype.bar = function(x) {};\",\n         \"mismatch of the bar property type and the type of the \" +\n         \"property it overrides from superclass Foo\\n\" +\n-        \"original: function (this:Foo, ...[number]): undefined\\n\" +\n-        \"override: function (this:SubFoo, number): undefined\");\n-        */\n+        \"original: function (...[number]): ?\\n\" +\n+        \"override: function (number): ?\");\n   }\n \n   public void testOverriddenParams5() throws Exception {\n         \"inconsistent return type\\n\" +\n         \"found   : goog.A\\n\" +\n         \"required: number\");\n+  }\n+\n+  public void testOverriddenProperty1() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/** @type {Object} */\" +\n+        \"Foo.prototype.bar = {};\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {Foo}\\n\" +\n+        \" */ function SubFoo() {}\" +\n+        \"/**\\n\" +\n+        \" * @type {Array}\\n\" +\n+        \" * @override\\n\" +\n+        \" */\" +\n+        \"SubFoo.prototype.bar = [];\");\n+  }\n+\n+  public void testOverriddenProperty2() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {\" +\n+        \"  /** @type {Object} */\" +\n+        \"  this.bar = {};\" +\n+        \"}\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {Foo}\\n\" +\n+        \" */ function SubFoo() {}\" +\n+        \"/**\\n\" +\n+        \" * @type {Array}\\n\" +\n+        \" * @override\\n\" +\n+        \" */\" +\n+        \"SubFoo.prototype.bar = [];\");\n   }\n \n   public void testThis2() throws Exception {\n         \"Function MyClass.prototype.fn: called with 0 argument(s). \" +\n         \"Function requires at least 1 argument(s) \" +\n         \"and no more than 1 argument(s).\");\n+  }\n+\n+  public void testIssue635() throws Exception {\n+    // TODO(nicksantos): Make this emit a warning, because of the 'this' type.\n+    testTypes(\n+        \"/** @constructor */\" +\n+        \"function F() {}\" +\n+        \"F.prototype.bar = function() { this.baz(); };\" +\n+        \"F.prototype.baz = function() {};\" +\n+        \"/** @constructor */\" +\n+        \"function G() {}\" +\n+        \"G.prototype.bar = F.prototype.bar;\");\n   }\n \n   public void testIssue669() throws Exception {\n         \"var x = f();\" +\n         \"/** @type {string} */\" +\n         \"x.y = 3;\",\n-        \"assignment to property y of x\\n\" +\n+        \"assignment\\n\" +\n         \"found   : number\\n\" +\n         \"required: string\");\n   }\n         \"Bad type annotation. Unknown type goog.Missing\");\n   }\n \n-  // TODO(user): We should support this way of declaring properties as it is\n-  // widely used.\n-  //public void testInheritanceCheck15() throws Exception {\n-  //  testTypes(\n-  //      \"/** @constructor */function Super() {};\" +\n-  //      \"/** @param {number} bar */Super.prototype.foo;\" +\n-  //      \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n-  //      \"/** @override\\n  @param {number} bar */Sub.prototype.foo =\\n\" +\n-  //      \"function(bar) {};\");\n-  //}\n-\n-//   public void testInterfacePropertyOverride1() throws Exception {\n-//     testTypes(\n-//         \"/** @interface */function Super() {};\" +\n-//         \"/** @desc description */Super.prototype.foo = function() {};\" +\n-//         \"/** @interface\\n @extends {Super} */function Sub() {};\" +\n-//         \"/** @desc description */Sub.prototype.foo = function() {};\",\n-//         \"property foo is already defined by the Super extended interface\");\n-//   }\n-\n-//   public void testInterfacePropertyOverride2() throws Exception {\n-//     testTypes(\n-//         \"/** @interface */function Root() {};\" +\n-//         \"/** @desc description */Root.prototype.foo = function() {};\" +\n-//         \"/** @interface\\n @extends {Root} */function Super() {};\" +\n-//         \"/** @interface\\n @extends {Super} */function Sub() {};\" +\n-//         \"/** @desc description */Sub.prototype.foo = function() {};\",\n-//         \"property foo is already defined by the Root extended interface\");\n-//   }\n+  public void testInheritanceCheck15() throws Exception {\n+    testTypes(\n+        \"/** @constructor */function Super() {};\" +\n+        \"/** @param {number} bar */Super.prototype.foo;\" +\n+        \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n+        \"/** @override\\n  @param {number} bar */Sub.prototype.foo =\\n\" +\n+        \"function(bar) {};\");\n+  }\n+\n+  public void testInheritanceCheck16() throws Exception {\n+    testTypes(\n+        \"var goog = {};\" +\n+        \"/** @constructor */goog.Super = function() {};\" +\n+        \"/** @type {number} */ goog.Super.prototype.foo = 3;\" +\n+        \"/** @constructor\\n @extends {goog.Super} */goog.Sub = function() {};\" +\n+        \"/** @type {number} */ goog.Sub.prototype.foo = 5;\",\n+        \"property foo already defined on superclass goog.Super; \" +\n+        \"use @override to override it\");\n+  }\n+\n+  public void testInterfacePropertyOverride1() throws Exception {\n+    testTypes(\n+        \"/** @interface */function Super() {};\" +\n+        \"/** @desc description */Super.prototype.foo = function() {};\" +\n+        \"/** @interface\\n @extends {Super} */function Sub() {};\" +\n+        \"/** @desc description */Sub.prototype.foo = function() {};\");\n+  }\n+\n+  public void testInterfacePropertyOverride2() throws Exception {\n+    testTypes(\n+        \"/** @interface */function Root() {};\" +\n+        \"/** @desc description */Root.prototype.foo = function() {};\" +\n+        \"/** @interface\\n @extends {Root} */function Super() {};\" +\n+        \"/** @interface\\n @extends {Super} */function Sub() {};\" +\n+        \"/** @desc description */Sub.prototype.foo = function() {};\");\n+  }\n \n   public void testInterfaceInheritanceCheck1() throws Exception {\n     testTypes(\n   }\n \n   public void testErrorMismatchingPropertyOnInterface6() throws Exception {\n-    testTypes(\"/** @interface */ function T() {};\\n\" +\n+    testClosureTypesMultipleWarnings(\n+        \"/** @interface */ function T() {};\\n\" +\n         \"/** @return {number} */T.prototype.x = 1\",\n-        \"interface members can only be empty property declarations, \"\n-        + \"empty functions, or goog.abstractMethod\"\n-        );\n+        Lists.newArrayList(\n+            \"assignment to property x of T.prototype\\n\" +\n+            \"found   : number\\n\" +\n+            \"required: function (this:T): number\",\n+            \"interface members can only be empty property declarations, \" +\n+            \"empty functions, or goog.abstractMethod\"));\n   }\n \n   public void testInterfaceNonEmptyFunction() throws Exception {\n   }\n \n   public void testDirectPrototypeAssign() throws Exception {\n+    // For now, we just ignore @type annotations on the prototype.\n     testTypes(\n         \"/** @constructor */ function Foo() {}\" +\n         \"/** @constructor */ function Bar() {}\" +\n-        \"/** @type {Array} */ Bar.prototype = new Foo()\",\n-        \"assignment to property prototype of Bar\\n\" +\n-        \"found   : Foo\\n\" +\n-        \"required: (Array|null)\");\n+        \"/** @type {Array} */ Bar.prototype = new Foo()\");\n   }\n \n   // In all testResolutionViaRegistry* tests, since u is unknown, u.T can only", "timestamp": 1331585152, "metainfo": ""}