{"sha": "4b41128afead3509293e481aaecac1c73076231e", "log": "Better handling of namespaces and properties: - remove namespaces that are duplicated - make sure that object literals are properly analyzed  R=acleung DELTA=206  (171 added, 15 deleted, 20 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3689   ", "commit": "\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.SourcePosition;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.EnumType;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.TreeSet;\n import java.util.logging.Logger;\n-import java.util.TreeSet;\n \n import javax.annotation.Nullable;\n \n   }\n \n   /**\n+   * Gets the symbol for the given enum.\n+   */\n+  public Symbol getSymbolDeclaredBy(EnumType enumType) {\n+    return getSymbolForName(null,\n+        enumType.getElementsType().getReferenceName());\n+  }\n+\n+  /**\n    * Gets the symbol for the prototype if this is the symbol for a constructor\n    * or interface.\n    */\n    */\n   void fillNamespaceReferences() {\n     for (Symbol symbol : getAllSymbolsSorted()) {\n+      String qName = symbol.getName();\n+      int rootIndex = qName.indexOf('.');\n+      if (rootIndex == -1) {\n+        continue;\n+      }\n+\n+      Symbol root = symbol.scope.getSlot(qName.substring(0, rootIndex));\n+      if (root == null) {\n+        // In theory, this should never happen, but we fail quietly anyway\n+        // just to be safe.\n+        continue;\n+      }\n+\n       for (Reference ref : getReferences(symbol)) {\n         Node currentNode = ref.getNode();\n+        if (!currentNode.isQualifiedName()) {\n+          continue;\n+        }\n+\n         while (currentNode.isGetProp()) {\n           currentNode = currentNode.getFirstChild();\n \n           String name = currentNode.getQualifiedName();\n           if (name != null) {\n-            Symbol namespace = symbol.scope.getSlot(name);\n-\n-            if (namespace == null && symbol.scope.isGlobalScope()) {\n+            Symbol namespace = root.scope.getSlot(name);\n+\n+            if (namespace == null && root.scope.isGlobalScope()) {\n               namespace = declareSymbol(name,\n                   registry.getNativeType(JSTypeNative.UNKNOWN_TYPE),\n                   true,\n-                  symbol.scope,\n+                  root.scope,\n                   currentNode,\n                   null /* jsdoc info */);\n             }\n     // var x = new Foo();\n     // where x is just an instance of another type.\n     for (Symbol sym : getAllSymbols()) {\n-      ObjectType type = ObjectType.cast(sym.getType());\n-      if (type != null &&\n-          (type.getReferenceName() == null ||\n-           sym.getName().equals(type.getReferenceName()))) {\n+      if (needsPropertyScope(sym)) {\n         types.add(sym);\n       }\n     }\n         Collections.reverseOrder(getNaturalSymbolOrdering()));\n     for (Symbol s : types) {\n       createPropertyScopeFor(s);\n+    }\n+\n+    pruneOrphanedNames();\n+  }\n+\n+  private boolean needsPropertyScope(Symbol sym) {\n+    ObjectType type = ObjectType.cast(sym.getType());\n+    if (type == null) {\n+      return false;\n+    }\n+\n+    // Anonymous objects\n+    if (type.getReferenceName() == null) {\n+      return true;\n+    }\n+\n+    // Cosntructors/prototypes\n+    if (sym.getName().equals(type.getReferenceName())) {\n+      return true;\n+    }\n+\n+    // Enums\n+    if (type.isEnumType() &&\n+        sym.getName().equals(\n+            type.toMaybeEnumType().getElementsType().getReferenceName())) {\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Removes symbols where the namespace they're on has been removed.\n+   *\n+   * After filling property scopes, we may have two symbols represented\n+   * in different ways. For example, \"A.superClass_.foo\" and B.prototype.foo\".\n+   *\n+   * This resolves that ambiguity by pruning the duplicates.\n+   * If we have a lexical symbol with a constructor in its proeprty\n+   * chain, then we assume there's also a property path to this symbol.\n+   * In other words, we can remove \"A.superClass_.foo\" because it's rooted\n+   * at \"A\", and we built a property scope for \"A\" above.\n+   */\n+  void pruneOrphanedNames() {\n+    nextSymbol: for (Symbol s : getAllSymbolsSorted()) {\n+      if (s.isProperty()) {\n+        continue;\n+      }\n+\n+      String currentName = s.getName();\n+      int dot = -1;\n+      while (-1 != (dot = currentName.lastIndexOf('.'))) {\n+        currentName = currentName.substring(0, dot);\n+\n+        Symbol owner = s.scope.getSlot(currentName);\n+        if (owner != null\n+            && owner.getType() != null\n+            && (owner.getType().isNominalConstructor() ||\n+                owner.getType().isEnumType())) {\n+          removeSymbol(s);\n+          continue nextSymbol;\n+        }\n+      }\n     }\n   }\n \n           this);\n     }\n \n-    private void maybeDefineReference(Node n, Symbol ownerSymbol) {\n-      String propName = n.getLastChild().getString();\n-\n+    private void maybeDefineReference(\n+        Node n, String propName, Symbol ownerSymbol) {\n       // getPropertyScope() will be null in some rare cases where there\n       // are no extern declarations for built-in types (like Function).\n       if (ownerSymbol != null && ownerSymbol.getPropertyScope() != null) {\n       }\n     }\n \n+    // Try to find the symbol by its fully qualified name.\n+    private void tryDefineLexicalPropRef(String name, Node n) {\n+      if (name != null) {\n+        Symbol lexicalSym = getEnclosingScope(n).getSlot(name);\n+        if (lexicalSym != null) {\n+          lexicalSym.defineReferenceAt(n);\n+        }\n+      }\n+    }\n+\n+    private void maybeDefineTypedReference(\n+        Node n, String propName, JSType owner) {\n+      if (owner.isGlobalThisType()) {\n+          Symbol sym = globalScope.getSlot(propName);\n+          if (sym != null) {\n+            sym.defineReferenceAt(n);\n+          }\n+      } else if (owner.isNominalConstructor()) {\n+        maybeDefineReference(\n+            n, propName, getSymbolDeclaredBy(owner.toMaybeFunctionType()));\n+      } else if (owner.isEnumType()) {\n+        maybeDefineReference(\n+            n, propName, getSymbolDeclaredBy(owner.toMaybeEnumType()));\n+      } else {\n+        for (Symbol ctor : getAllSymbolsForType(owner)) {\n+          maybeDefineReference(n, propName, getSymbolForInstancesOf(ctor));\n+        }\n+      }\n+    }\n+\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.isGetProp()) {\n         JSType owner = n.getFirstChild().getJSType();\n         if (owner == null || owner.isUnknownType()) {\n-          // Try to find the symbol by its fully qualified name.\n-          String name = n.getQualifiedName();\n-          if (name != null) {\n-            Symbol lexicalSym = getEnclosingScope(n).getSlot(name);\n-            if (lexicalSym != null) {\n-              lexicalSym.defineReferenceAt(n);\n-            }\n-          }\n+          tryDefineLexicalPropRef(n.getQualifiedName(), n);\n           return;\n         }\n \n-        if (owner.isGlobalThisType()) {\n-          Symbol sym = globalScope.getSlot(n.getLastChild().getString());\n-          if (sym != null) {\n-            sym.defineReferenceAt(n);\n-          }\n-        } else if (owner.isNominalConstructor()) {\n-          maybeDefineReference(\n-              n, getSymbolDeclaredBy(owner.toMaybeFunctionType()));\n-        } else {\n-          for (Symbol ctor : getAllSymbolsForType(owner)) {\n-            maybeDefineReference(n, getSymbolForInstancesOf(ctor));\n-          }\n-        }\n+        maybeDefineTypedReference(n, n.getLastChild().getString(), owner);\n+      } else if (NodeUtil.isObjectLitKey(n, parent) &&\n+          n.getType() == Token.STRING) {\n+        JSType owner = parent.getJSType();\n+        if (owner == null || owner.isUnknownType()) {\n+          tryDefineLexicalPropRef(NodeUtil.getBestLValueName(n), n);\n+          return;\n+        }\n+\n+        maybeDefineTypedReference(n, n.getString(), owner);\n       }\n     }\n   }\n   private final Ordering<Node> NODE_ORDERING = new Ordering<Node>() {\n     @Override\n     public int compare(Node a, Node b) {\n-      int result = SOURCE_NAME_ORDERING.compare(a.getSourceFileName(), b.getSourceFileName());\n+      int result = SOURCE_NAME_ORDERING.compare(\n+          a.getSourceFileName(), b.getSourceFileName());\n       if (result != 0) {\n         return result;\n       }\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     assertEquals(3, table.getReferenceList(sym).size());\n   }\n \n+  public void testSuperClassReference() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"  var a = {b: {}};\\n\"\n+        + \"/** @constructor */\\n\"\n+        + \"a.b.BaseClass = function() {};\\n\"\n+        + \"a.b.BaseClass.prototype.doSomething = function() {\\n\"\n+        + \"  alert('hi');\\n\"\n+        + \"};\\n\"\n+        + \"/**\\n\"\n+        + \" * @constructor\\n\"\n+        + \" * @extends {a.b.BaseClass}\\n\"\n+        + \" */\\n\"\n+        + \"a.b.DerivedClass = function() {};\\n\"\n+        + \"goog.inherits(a.b.DerivedClass, a.b.BaseClass);\\n\"\n+        + \"/** @override */\\n\"\n+        + \"a.b.DerivedClass.prototype.doSomething = function() {\\n\"\n+        + \"  a.b.DerivedClass.superClass_.doSomething();\\n\"\n+        + \"};\\n\");\n+\n+    Symbol bad = getGlobalVar(\n+        table, \"a.b.DerivedClass.superClass_.doSomething\");\n+    assertNull(bad);\n+\n+    Symbol good = getGlobalVar(\n+        table, \"a.b.BaseClass.prototype.doSomething\");\n+    assertNotNull(good);\n+\n+    List<Reference> refs = table.getReferenceList(good);\n+    assertEquals(2, refs.size());\n+    assertEquals(\"a.b.DerivedClass.superClass_.doSomething\",\n+        refs.get(1).getNode().getQualifiedName());\n+  }\n+\n+  public void testInnerEnum() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"var goog = {}; goog.ui = {};\"\n+        + \"  /** @constructor */\\n\"\n+        + \"goog.ui.Zippy = function() {};\\n\"\n+        + \"/** @enum {string} */\\n\"\n+        + \"goog.ui.Zippy.EventType = { TOGGLE: 'toggle' };\\n\");\n+\n+    Symbol eventType = getGlobalVar(table, \"goog.ui.Zippy.EventType\");\n+    assertNotNull(eventType);\n+    assertTrue(eventType.getType().isEnumType());\n+\n+    Symbol toggle = getGlobalVar(table, \"goog.ui.Zippy.EventType.TOGGLE\");\n+    assertNotNull(toggle);\n+  }\n+\n   private void assertSymmetricOrdering(\n       Ordering<Symbol> ordering, Symbol first, Symbol second) {\n     assertTrue(ordering.compare(first, first) == 0);", "timestamp": 1320952281, "metainfo": ""}