{"sha": "f412f0c0efd54842b30207c845d65cb826217fd6", "log": "Create a separate token for object literal keys. i was surprised how easy this was  R=acleung,johnlenz DELTA=139  (52 added, 26 deleted, 61 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4618   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AliasStrings.java\n+++ b/src/com/google/javascript/jscomp/AliasStrings.java\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.isString() &&\n         !parent.isGetProp() &&\n-        !parent.isRegExp() &&\n-        !NodeUtil.isObjectLitKey(n, parent)) {\n+        !parent.isRegExp()) {\n \n       String str = n.getString();\n \n--- a/src/com/google/javascript/jscomp/AnonymousFunctionNamingCallback.java\n+++ b/src/com/google/javascript/jscomp/AnonymousFunctionNamingCallback.java\n          keyNode = keyNode.getNext()) {\n       Node valueNode = keyNode.getFirstChild();\n \n-      // Object literal keys may be STRING, GET, SET. Get and Set\n-      // are skipped because they can not be named.\n-      if (keyNode.isString()) {\n+      // Object literal keys may be STRING_KEY, GETTER_DEF, SETTER_DEF.\n+      // Get and Set are skipped because they can not be named.\n+      if (keyNode.isStringKey()) {\n         // concatenate the context and key name to get a new qualified name.\n         String name = namer.getCombinedName(context, namer.getName(keyNode));\n \n--- a/src/com/google/javascript/jscomp/AstValidator.java\n+++ b/src/com/google/javascript/jscomp/AstValidator.java\n       case Token.SETTER_DEF:\n         validateObjectLitSetKey(n);\n         return;\n-      case Token.STRING:\n+      case Token.STRING_KEY:\n         validateObjectLitStringKey(n);\n         return;\n       default:\n   }\n \n   private void validateObjectLitStringKey(Node n) {\n-    validateNodeType(Token.STRING, n);\n+    validateNodeType(Token.STRING_KEY, n);\n     validateChildCount(n, 1);\n     validateObjectLiteralKeyName(n);\n     validateExpression(n.getFirstChild());\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n             pType == Token.ASSIGN ||\n \n             // object literal keys\n-            pType == Token.STRING)) {\n+            pType == Token.STRING_KEY)) {\n         return false;\n       }\n \n--- a/src/com/google/javascript/jscomp/CheckMissingGetCssName.java\n+++ b/src/com/google/javascript/jscomp/CheckMissingGetCssName.java\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.isString() &&\n         !parent.isGetProp() &&\n-        !parent.isRegExp() &&\n-        !NodeUtil.isObjectLitKey(n, parent)) {\n+        !parent.isRegExp()) {\n       String s = n.getString();\n \n       for (blacklist.reset(s); blacklist.find();) {\n--- a/src/com/google/javascript/jscomp/ClosureOptimizePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ClosureOptimizePrimitives.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n import java.util.List;\n \n /**\n             keyNode = IR.string(NodeUtil.getStringValue(keyNode))\n                 .srcref(keyNode);\n           }\n+          keyNode.setType(Token.STRING_KEY);\n           keyNode.setQuotedString();\n           objNode.addChildToBack(IR.propdef(keyNode, valueNode));\n         }\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n         }\n         break;\n \n+      case Token.STRING_KEY:\n+        Preconditions.checkState(\n+            childCount == 1, \"Object lit key must have 1 child\");\n+        addJsString(n);\n+        break;\n+\n       case Token.STRING:\n-        if (childCount !=\n-            ((n.getParent() != null &&\n-              n.getParent().isObjectLit()) ? 1 : 0)) {\n-          throw new IllegalStateException(\n-              \"Unexpected String children: \" + n.getParent().toStringTree());\n-        }\n+        Preconditions.checkState(\n+            childCount == 0, \"A string may not have children\");\n         addJsString(n);\n         break;\n \n           if (c.isGetterDef() || c.isSetterDef()) {\n             add(c);\n           } else {\n-            Preconditions.checkState(c.isString());\n+            Preconditions.checkState(c.isStringKey());\n             String key = c.getString();\n             // Object literal property names don't have to be quoted if they\n             // are not JavaScript keywords\n--- a/src/com/google/javascript/jscomp/ConvertToDottedProperties.java\n+++ b/src/com/google/javascript/jscomp/ConvertToDottedProperties.java\n     switch (n.getType()) {\n       case Token.GETTER_DEF:\n       case Token.SETTER_DEF:\n-      case Token.STRING:\n-        if (NodeUtil.isObjectLitKey(n, parent) &&\n-            NodeUtil.isValidPropertyName(n.getString())) {\n+      case Token.STRING_KEY:\n+        if (NodeUtil.isValidPropertyName(n.getString())) {\n           n.putBooleanProp(Node.QUOTED_PROP, false);\n           compiler.reportCodeChange();\n         }\n--- a/src/com/google/javascript/jscomp/DefinitionsRemover.java\n+++ b/src/com/google/javascript/jscomp/DefinitionsRemover.java\n       switch (name.getType()) {\n         case Token.SETTER_DEF:\n         case Token.GETTER_DEF:\n-        case Token.STRING:\n+        case Token.STRING_KEY:\n           // TODO(johnlenz): return a GETELEM for quoted strings.\n           return IR.getprop(\n               IR.objectlit(),\n--- a/src/com/google/javascript/jscomp/Denormalize.java\n+++ b/src/com/google/javascript/jscomp/Denormalize.java\n \n     @Override\n     public void visit(NodeTraversal t, Node node, Node parent) {\n-      if (node.isName() || node.isString()) {\n+      if (node.isName() || node.isString() || node.isStringKey()) {\n         node.removeProp(Node.IS_CONSTANT_NAME);\n       }\n     }\n--- a/src/com/google/javascript/jscomp/ExpandJqueryAliases.java\n+++ b/src/com/google/javascript/jscomp/ExpandJqueryAliases.java\n \n package com.google.javascript.jscomp;\n \n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.logging.Logger;\n-\n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n-import com.google.common.collect.ImmutableSet;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.logging.Logger;\n \n /**\n  * Replace known jQuery aliases and methods with standard\n \n     while (extendArg.hasChildren()) {\n       Node currentProp = extendArg.removeFirstChild();\n+      currentProp.setType(Token.STRING);\n+\n       Node propValue = currentProp.removeFirstChild();\n \n       Node newProp;\n     @Override\n     public void exitScope(NodeTraversal t) { }\n   }\n-}\n+}\n--- a/src/com/google/javascript/jscomp/ExternExportsPass.java\n+++ b/src/com/google/javascript/jscomp/ExternExportsPass.java\n       for (Node child = exportedObjectLit.getFirstChild();\n            child != null;\n            child = child.getNext()) {\n-        if (child.isString()) {\n+        // TODO: handle getters or setters?\n+        if (child.isStringKey()) {\n           lit.addChildToBack(\n               IR.propdef(\n-                  IR.string(child.getString()),\n+                  IR.stringKey(child.getString()),\n                   IR.number(index++)));\n         }\n       }\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n       switch (n.getType()) {\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n-        case Token.STRING:\n+        case Token.STRING_KEY:\n           // This may be a key in an object literal declaration.\n           name = null;\n           if (parent != null && parent.isObjectLit()) {\n           if (name == null) return;\n           isSet = true;\n           switch (n.getType()) {\n-            case Token.STRING:\n+            case Token.STRING_KEY:\n               type = getValueType(n.getFirstChild());\n               break;\n             case Token.GETTER_DEF:\n           Node lvalue = gramps.getFirstChild();\n           name = lvalue.getQualifiedName();\n           break;\n-        case Token.STRING:\n+        case Token.STRING_KEY:\n           // OBJLIT\n           //   STRING (gramps)\n           //     OBJLIT (parent)\n--- a/src/com/google/javascript/jscomp/JsMessageVisitor.java\n+++ b/src/com/google/javascript/jscomp/JsMessageVisitor.java\n       }\n       for (Node aNode = objLitNode.getFirstChild(); aNode != null;\n            aNode = aNode.getNext()) {\n-        if (!aNode.isString()) {\n-          throw new MalformedException(\"STRING node expected as OBJLIT key\",\n+        if (!aNode.isStringKey()) {\n+          throw new MalformedException(\"STRING_KEY node expected as OBJLIT key\",\n               aNode);\n         }\n         String phName = aNode.getString();\n--- a/src/com/google/javascript/jscomp/MethodCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/MethodCompilerPass.java\n           for (Node key = n.getFirstChild(); key != null; key = key.getNext()) {\n             Node value = key.getFirstChild();\n             String name = key.getString();\n-            if (key.isString()\n+            if (key.isStringKey()\n                 && value.isFunction()) {\n               addSignature(name, value, t.getSourceName());\n             } else {\n         case Token.OBJECTLIT:\n           for (Node key = n.getFirstChild(); key != null; key = key.getNext()) {\n             switch(key.getType()) {\n-              case Token.STRING:\n+              case Token.STRING_KEY:\n                 addPossibleSignature(key.getString(), key.getFirstChild(), t);\n                 break;\n               case Token.SETTER_DEF:\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n         } else if (objLitParent.isName()) {\n           // This must be a VAR initialization.\n           rootNameNode = objLitParent;\n-        } else if (objLitParent.isString()) {\n+        } else if (objLitParent.isStringKey()) {\n           // This must be a object literal key initialization.\n           rootNameNode = objLitParent;\n         } else {\n--- a/src/com/google/javascript/jscomp/NameAnonymousFunctionsMapped.java\n+++ b/src/com/google/javascript/jscomp/NameAnonymousFunctionsMapped.java\n       switch (node.getType()) {\n         case Token.NAME:\n         case Token.STRING:\n+        case Token.STRING_KEY:\n           return node.getString();\n         default:\n           return new CodePrinter.Builder(node).build();\n--- a/src/com/google/javascript/jscomp/NodeNameExtractor.java\n+++ b/src/com/google/javascript/jscomp/NodeNameExtractor.java\n       case Token.NAME:\n         return node.getString();\n       case Token.STRING:\n+      case Token.STRING_KEY:\n         return TokenStream.isJSIdentifier(node.getString()) ?\n             node.getString() : (\"__\" + nextUniqueInt++);\n       case Token.NUMBER:\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n     // TODO(user): regex literals as well.\n     switch (n.getType()) {\n       case Token.STRING:\n+      case Token.STRING_KEY:\n         return n.getString();\n \n       case Token.NAME:\n     switch (parent.getType()) {\n       case Token.SETTER_DEF:\n       case Token.GETTER_DEF:\n-      case Token.STRING:\n+      case Token.STRING_KEY:\n         // Return the name of the literal's key.\n         return parent.getString();\n       case Token.NUMBER:\n       case Token.FALSE:\n       case Token.NULL:\n       case Token.STRING:\n+      case Token.STRING_KEY:\n       case Token.SWITCH:\n       case Token.TRY:\n       case Token.EMPTY:\n       case Token.OBJECTLIT:\n       case Token.REGEXP:\n       case Token.STRING:\n+      case Token.STRING_KEY:\n       case Token.THIS:\n       case Token.TRUE:\n         return 15;\n    */\n   static boolean isObjectLitKey(Node node, Node parent) {\n     switch (node.getType()) {\n-      case Token.STRING:\n-        return parent.isObjectLit();\n+      case Token.STRING_KEY:\n       case Token.GETTER_DEF:\n       case Token.SETTER_DEF:\n         return true;\n    */\n   static String getObjectLitKeyName(Node key) {\n     switch (key.getType()) {\n-      case Token.STRING:\n+      case Token.STRING_KEY:\n       case Token.GETTER_DEF:\n       case Token.SETTER_DEF:\n         return key.getString();\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n         if (lhs.isGetProp() && isMarkedExpose(assign)) {\n           exposedProperties.add(lhs.getLastChild().getString());\n         }\n-      } else if (NodeUtil.isObjectLitKey(n, parent) &&\n-          n.isString() &&\n-          isMarkedExpose(n)) {\n+      } else if (n.isStringKey() && isMarkedExpose(n)) {\n         exposedProperties.add(n.getString());\n       }\n     }\n           n.getParent().replaceChild(n, IR.getelem(obj, prop));\n           compiler.reportCodeChange();\n         }\n-      } else if (n.isString() && NodeUtil.isObjectLitKey(n, parent)) {\n+      } else if (n.isStringKey()) {\n         String propName = n.getString();\n         if (exposedProperties.contains(propName)) {\n           n.setQuotedString();\n \n         case Token.NAME:\n         case Token.STRING:\n+        case Token.STRING_KEY:\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n           if (!compiler.getLifeCycleStage().isNormalizedObfuscated()) {\n       Preconditions.checkState(\n           n.isName()\n           || n.isString()\n+          || n.isStringKey()\n           || n.isGetterDef()\n           || n.isSetterDef());\n \n--- a/src/com/google/javascript/jscomp/PeepholeCollectPropertyAssignments.java\n+++ b/src/com/google/javascript/jscomp/PeepholeCollectPropertyAssignments.java\n       propertyName = property.getString();\n     }\n \n-    Node newProperty = IR.string(propertyName)\n+    Node newProperty = IR.stringKey(propertyName)\n         .copyInformationFrom(property);\n     // Preserve the quotedness of a property reference\n     if (lhs.isGetElem()) {\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n           case Token.SETTER_DEF:\n             continue;\n           case Token.GETTER_DEF:\n-          case Token.STRING:\n+          case Token.STRING_KEY:\n             if (value != null && mayHaveSideEffects(value)) {\n               // The previously found value had side-effects\n               return n;\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n       for (Node key = arg.getFirstChild(); key != null;\n           key = key.getNext()) {\n         Node value = key.getFirstChild();\n-        if (!key.isString()\n+        if (!key.isStringKey()\n             || value == null\n             || !value.isString()) {\n           compiler.report(\n--- a/src/com/google/javascript/jscomp/ProcessTweaks.java\n+++ b/src/com/google/javascript/jscomp/ProcessTweaks.java\n       Node sourceInformationNode) {\n     Node objNode = IR.objectlit().srcref(sourceInformationNode);\n     for (Entry<String, Node> entry : compilerDefaultValueOverrides.entrySet()) {\n-      Node objKeyNode = IR.string(entry.getKey())\n+      Node objKeyNode = IR.stringKey(entry.getKey())\n           .copyInformationFrom(sourceInformationNode);\n       Node objValueNode = entry.getValue().cloneNode()\n           .copyInformationFrom(sourceInformationNode);\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n         }\n \n         tryDefineLexicalQualifiedNameRef(n.getQualifiedName(), n);\n-      } else if (NodeUtil.isObjectLitKey(n, parent) && n.isString()) {\n+      } else if (n.isStringKey()) {\n         JSType owner = parent.getJSType();\n         if (owner != null) {\n           boolean defined =\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n         break;\n \n       case Token.STRING:\n-        // Object literal keys are handled with OBJECTLIT\n-        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n-          ensureTyped(t, n, STRING_TYPE);\n-        } else {\n-          // Object literal keys are not typeable\n-          typeable = false;\n-        }\n+        ensureTyped(t, n, STRING_TYPE);\n+        break;\n+\n+      case Token.STRING_KEY:\n+        typeable = false;\n         break;\n \n       case Token.GETTER_DEF:\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n         objectType.defineInferredProperty(memberName, valueType, name);\n \n         // Do normal flow inference if this is a direct property assignment.\n-        if (qObjName != null && name.isString()) {\n+        if (qObjName != null && name.isStringKey()) {\n           String qKeyName = qObjName + \".\" + memberName;\n           Var var = syntacticScope.getVar(qKeyName);\n           JSType oldType = var == null ? null : var.getType();\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n           break;\n \n         case Token.STRING:\n-          // Defer keys to the Token.OBJECTLIT case\n-          if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n-            n.setJSType(getNativeType(STRING_TYPE));\n-          }\n+          n.setJSType(getNativeType(STRING_TYPE));\n           break;\n \n         case Token.NUMBER:\n--- a/src/com/google/javascript/jscomp/jsonml/Reader.java\n+++ b/src/com/google/javascript/jscomp/jsonml/Reader.java\n \n     Node node = null;\n     if (name instanceof Number) {\n-      node = IR.number(((Number) name).doubleValue());\n+      node = IR.stringKey(getStringValue(((Number) name).doubleValue()));\n     } else if (name instanceof String) {\n-      node = IR.string((String) name);\n+      node = IR.stringKey((String) name);\n     } else {\n       throw new IllegalStateException(\n           \"The name of the property has invalid type.\");\n     parent.addChildToBack(node);\n \n     transformElement(element.getChild(0), node);\n+  }\n+\n+  private static String getStringValue(double value) {\n+    long longValue = (long) value;\n+\n+    // Return \"1\" instead of \"1.0\"\n+    if (longValue == value) {\n+      return Long.toString(longValue);\n+    } else {\n+      return Double.toString(value);\n+    }\n   }\n \n   /*\n     }\n   }\n }\n-\n--- a/src/com/google/javascript/jscomp/jsonml/Writer.java\n+++ b/src/com/google/javascript/jscomp/jsonml/Writer.java\n       JsonML item;\n       Object name;\n       switch (key.getType()) {\n-        case Token.STRING:\n+        case Token.STRING_KEY:\n           item = new JsonML(TagType.DataProp);\n           name = key.getString();\n-          break;\n-        case Token.NUMBER:\n-          item = new JsonML(TagType.DataProp);\n-          name = key.getDouble();\n           break;\n         case Token.GETTER_DEF:\n           item = new JsonML(TagType.GetterProp);\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n         }\n \n         Node key = transformAsString(el.getLeft());\n+        key.setType(Token.STRING_KEY);\n+\n         Node value = transform(el.getRight());\n         if (el.isGetter()) {\n           key.setType(Token.GETTER_DEF);\n--- a/src/com/google/javascript/rhino/IR.java\n+++ b/src/com/google/javascript/rhino/IR.java\n     Node objectlit = new Node(Token.OBJECTLIT);\n     for (Node propdef : propdefs) {\n       Preconditions.checkState(\n-          propdef.isString() || propdef.isGetterDef() || propdef.isSetterDef());\n+          propdef.isStringKey() ||\n+          propdef.isGetterDef() || propdef.isSetterDef());\n       Preconditions.checkState(propdef.hasOneChild());\n       objectlit.addChildToBack(propdef);\n     }\n   // TODO(johnlenz): quoted props\n \n   public static Node propdef(Node string, Node value) {\n-    Preconditions.checkState(string.isString());\n+    Preconditions.checkState(string.isStringKey());\n     Preconditions.checkState(!string.hasChildren());\n     Preconditions.checkState(mayBeExpression(value));\n     string.addChildToFront(value);\n \n   public static Node string(String s) {\n     return Node.newString(s);\n+  }\n+\n+  public static Node stringKey(String s) {\n+    return Node.newString(Token.STRING_KEY, s);\n   }\n \n   public static Node number(double d) {\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n       if (post1 != post2) {\n         return false;\n       }\n-    } else if (type == Token.STRING) {\n-      int quoted1 = this.getIntProp(QUOTED_PROP);\n-      int quoted2 = node.getIntProp(QUOTED_PROP);\n-      if (quoted1 != quoted2) {\n-        return false;\n+    } else if (type == Token.STRING || type == Token.STRING_KEY) {\n+      if (type == Token.STRING_KEY) {\n+        int quoted1 = this.getIntProp(QUOTED_PROP);\n+        int quoted2 = node.getIntProp(QUOTED_PROP);\n+        if (quoted1 != quoted2) {\n+          return false;\n+        }\n       }\n \n       int slashV1 = this.getIntProp(SLASH_V);\n     return this.getType() == Token.STRING;\n   }\n \n+  public boolean isStringKey() {\n+    return this.getType() == Token.STRING_KEY;\n+  }\n+\n   public boolean isSwitch() {\n     return this.getType() == Token.SWITCH;\n   }\n--- a/src/com/google/javascript/rhino/Token.java\n+++ b/src/com/google/javascript/rhino/Token.java\n \n         // JSCompiler introduced tokens\n         LABEL_NAME     = 153,\n+        STRING_KEY     = 154, // object literal key\n \n         // JSDoc-only tokens\n         ANNOTATION     = 300,\n           case LABEL_NAME:      return \"LABEL_NAME\";\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n+          case STRING_KEY:      return \"STRING_KEY\";\n           case NULL:            return \"NULL\";\n           case THIS:            return \"THIS\";\n           case FALSE:           return \"FALSE\";\n--- a/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java\n+++ b/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java\n \n     checkDefinitionsInJs(\n         \"({a : 1}); o.a\",\n-        ImmutableSet.of(\"DEF STRING null -> NUMBER\",\n+        ImmutableSet.of(\"DEF STRING_KEY null -> NUMBER\",\n                         \"USE GETPROP o.a -> [NUMBER]\"));\n \n     // TODO(johnlenz): Fix this.\n     checkDefinitionsInJs(\n       \"({'a' : 1}); o['a']\",\n-      ImmutableSet.<String>of(\"DEF STRING null -> NUMBER\"));\n+      ImmutableSet.<String>of(\"DEF STRING_KEY null -> NUMBER\"));\n \n     checkDefinitionsInJs(\n       \"({1 : 1}); o[1]\",\n-      ImmutableSet.<String>of(\"DEF STRING null -> NUMBER\"));\n+      ImmutableSet.<String>of(\"DEF STRING_KEY null -> NUMBER\"));\n \n     checkDefinitionsInJs(\n         \"var a = {b : 1}; a.b\",\n         ImmutableSet.of(\"DEF NAME a -> <null>\",\n-                        \"DEF STRING null -> NUMBER\",\n+                        \"DEF STRING_KEY null -> NUMBER\",\n                         \"USE NAME a -> [<null>]\",\n                         \"USE GETPROP a.b -> [NUMBER]\"));\n   }\n             \"DEF GETPROP goog.Enum -> EXTERN <null>\",\n             \"DEF GETPROP goog.HYBRID -> EXTERN <null>\",\n             \"DEF NAME goog -> EXTERN <null>\",\n-            \"DEF STRING null -> EXTERN NUMBER\",\n+            \"DEF STRING_KEY null -> EXTERN NUMBER\",\n             \"USE GETPROP goog.Enum -> [EXTERN <null>]\",\n             \"USE GETPROP goog.Enum.ROADMAP -> [EXTERN NUMBER]\",\n             \"USE GETPROP goog.HYBRID -> [EXTERN <null>, EXTERN NUMBER]\",\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n       \"SCRIPT 1 [source_file: FileName.js] [length: 11]\\n\" +\n       \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 10]\\n\" +\n       \"        OBJECTLIT 1 [parenthesized: true] [source_file: FileName.js] [length: 9]\\n\" +\n-      \"            STRING 1 1 [quoted: 1] [source_file: FileName.js] [length: 1]\\n\" +\n+      \"            STRING_KEY 1 1 [quoted: 1] [source_file: FileName.js] [length: 1]\\n\" +\n       \"                TRUE 1 [source_file: FileName.js] [length: 4]\\n\");\n   }\n \n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n \n     Node key = n.getFirstChild();\n \n-    assertEquals(Token.STRING, key.getType());\n+    assertEquals(Token.STRING_KEY, key.getType());\n     assertEquals(3, key.getLineno());\n     assertEquals(10, key.getCharno());\n \n \n     key = key.getNext();\n \n-    assertEquals(Token.STRING, key.getType());\n+    assertEquals(Token.STRING_KEY, key.getType());\n     assertEquals(4, key.getLineno());\n     assertEquals(1, key.getCharno());\n \n     assertEquals(Token.OBJECTLIT, objectLit.getType());\n \n     Node number = objectLit.getFirstChild();\n-    assertEquals(Token.STRING, number.getType());\n+    assertEquals(Token.STRING_KEY, number.getType());\n     assertNotNull(number.getJSDocInfo());\n   }\n ", "timestamp": 1335386054, "metainfo": ""}