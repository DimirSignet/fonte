{"sha": "8be3896c7639f91d83ac220531cc5cbdc5a029d4", "log": "Clean up global namespacing a bit, to make way for additional checks. I'm not quite sure if the change w/r/t 'declaration' and 'refs' is an improvement or not--i think it will allow us to get rid of special cases down the line, but am not sure.  R=acleung DELTA=117  (40 added, 9 deleted, 68 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1542   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckGlobalNames.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalNames.java\n       }\n     }\n \n-    if (name.refs != null) {\n-      JSModuleGraph moduleGraph = compiler.getModuleGraph();\n-      for (Ref ref : name.refs) {\n-        if (!isDefined) {\n-          reportRefToUndefinedName(name, ref);\n-        } else {\n-          if (declaration != null &&\n-              ref.module != declaration.module &&\n-              !moduleGraph.dependsOn(ref.module, declaration.module)) {\n-            reportBadModuleReference(name, ref);\n-          }\n+    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n+    for (Ref ref : name.getRefs()) {\n+      if (ref == name.declaration) {\n+        continue;\n+      }\n+\n+      if (!isDefined) {\n+        reportRefToUndefinedName(name, ref);\n+      } else {\n+        if (declaration != null &&\n+            ref.getModule() != declaration.getModule() &&\n+            !moduleGraph.dependsOn(\n+                ref.getModule(), declaration.getModule())) {\n+          reportBadModuleReference(name, ref);\n         }\n       }\n     }\n \n   private void reportBadModuleReference(Name name, Ref ref) {\n     compiler.report(\n-        JSError.make(ref.sourceName, ref.node, STRICT_MODULE_DEP_QNAME,\n-                     ref.module.getName(), name.declaration.module.getName(),\n+        JSError.make(ref.source.getName(), ref.node, STRICT_MODULE_DEP_QNAME,\n+                     ref.getModule().getName(),\n+                     name.declaration.getModule().getName(),\n                      name.fullName()));\n   }\n \n     }\n \n     compiler.report(\n-        JSError.make(ref.sourceName, ref.node, level, UNDEFINED_NAME_WARNING,\n-            name.fullName()));\n+        JSError.make(ref.getSourceName(), ref.node, level,\n+            UNDEFINED_NAME_WARNING, name.fullName()));\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n-        List<Ref> refs = Lists.newArrayList(name.refs);\n+        List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n    */\n   private void checkNamespaces() {\n     for (Name name : nameMap.values()) {\n-      if (name.isNamespace() && name.refs != null &&\n+      if (name.isNamespace() &&\n           (name.aliasingGets > 0 || name.localSets + name.globalSets > 1)) {\n         boolean initialized = name.declaration != null;\n-        for (Ref ref : name.refs) {\n+        for (Ref ref : name.getRefs()) {\n+          if (ref == name.declaration) {\n+            continue;\n+          }\n+\n           if (ref.type == Ref.Type.SET_FROM_GLOBAL ||\n               ref.type == Ref.Type.SET_FROM_LOCAL) {\n             if (initialized) {\n    */\n   private void warnAboutNamespaceAliasing(Name nameObj, Ref ref) {\n     compiler.report(\n-        JSError.make(ref.sourceName, ref.node,\n+        JSError.make(ref.getSourceName(), ref.node,\n                      UNSAFE_NAMESPACE_WARNING, nameObj.fullName()));\n   }\n \n    */\n   private void warnAboutNamespaceRedefinition(Name nameObj, Ref ref) {\n     compiler.report(\n-        JSError.make(ref.sourceName, ref.node,\n+        JSError.make(ref.getSourceName(), ref.node,\n                      NAMESPACE_REDEFINED_WARNING, nameObj.fullName()));\n   }\n \n    * @param alias The flattened name (e.g. \"a$b\" or \"a$b$c$d\")\n    */\n   private void flattenReferencesTo(Name n, String alias) {\n-    if (n.refs != null) {\n-      String originalName = n.fullName();\n-      for (Ref r : n.refs) {\n-        Node rParent = r.node.getParent();\n-\n-        // There are two cases when we shouldn't flatten a reference:\n-        // 1) Object literal keys, because duplicate keys show up as refs.\n-        // 2) References inside a complex assign. (a = x.y = 0). These are\n-        //    called TWIN references, because they show up twice in the\n-        //    reference list. Only collapse the set, not the alias.\n-        if (!NodeUtil.isObjectLitKey(r.node, rParent) &&\n-            (r.getTwin() == null || r.isSet())) {\n-          flattenNameRef(alias, r.node, rParent, originalName);\n-        }\n+    String originalName = n.fullName();\n+    for (Ref r : n.getRefs()) {\n+      if (r == n.declaration) {\n+        // Declarations are handled separately.\n+        continue;\n+      }\n+\n+      Node rParent = r.node.getParent();\n+\n+      // There are two cases when we shouldn't flatten a reference:\n+      // 1) Object literal keys, because duplicate keys show up as refs.\n+      // 2) References inside a complex assign. (a = x.y = 0). These are\n+      //    called TWIN references, because they show up twice in the\n+      //    reference list. Only collapse the set, not the alias.\n+      if (!NodeUtil.isObjectLitKey(r.node, rParent) &&\n+          (r.getTwin() == null || r.isSet())) {\n+        flattenNameRef(alias, r.node, rParent, originalName);\n       }\n     }\n \n       flattenNameRefAtDepth(alias, n.declaration.node, depth, originalName);\n     }\n \n-    if (n.refs != null) {\n-      for (Ref r : n.refs) {\n-\n-        // References inside a complex assign (a = x.y = 0)\n-        // have twins. We should only flatten one of the twins.\n-        if (r.getTwin() == null || r.isSet()) {\n-          flattenNameRefAtDepth(alias, r.node, depth, originalName);\n-        }\n+    for (Ref r : n.getRefs()) {\n+      if (r == n.declaration) {\n+        // Declarations are handled separately.\n+        continue;\n+      }\n+\n+      // References inside a complex assign (a = x.y = 0)\n+      // have twins. We should only flatten one of the twins.\n+      if (r.getTwin() == null || r.isSet()) {\n+        flattenNameRefAtDepth(alias, r.node, depth, originalName);\n       }\n     }\n \n             public void visit(NodeTraversal t, Node n, Node parent) {\n               if (n.getType() == Token.THIS) {\n                 compiler.report(\n-                    JSError.make(name.declaration.sourceName, n,\n+                    JSError.make(name.declaration.getSourceName(), n,\n                         UNSAFE_THIS, name.fullName()));\n               }\n             }\n \n           // Determine if this is a constant var by checking the first\n           // reference to it. Don't check the declaration, as it might be null.\n-          if (p.refs.get(0).node.getLastChild().getBooleanProp(\n-                Node.IS_CONSTANT_NAME)) {\n+          if (p.getRefs().get(0).node.getLastChild().getBooleanProp(\n+                  Node.IS_CONSTANT_NAME)) {\n             nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n           }\n         }\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n \n import java.util.ArrayList;\n import java.util.HashMap;\n-import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-\n \n /**\n  * Builds a global namespace of all the objects and their properties in\n     final String name;\n     final Name parent;\n     List<Name> props;\n+\n+    /** The first global assignment to a name. */\n     Ref declaration;\n-    List<Ref> refs;\n+\n+    /** All references to a name. This must contain {@code declaration}. */\n+    private List<Ref> refs;\n+\n     Type type;\n     private boolean isClassOrEnum = false;\n     private boolean hasClassOrEnumDescendant = false;\n           if (declaration == null) {\n             declaration = ref;\n             docInfo = getDocInfoForDeclaration(ref);\n-          } else {\n-            addRefInternal(ref);\n           }\n+          addRefInternal(ref);\n           globalSets++;\n           break;\n         case SET_FROM_LOCAL:\n     }\n \n     void removeRef(Ref ref) {\n-      if (ref == declaration ||\n-          (refs != null && refs.remove(ref))) {\n+      if (refs != null && refs.remove(ref)) {\n         if (ref == declaration) {\n           declaration = null;\n           if (refs != null) {\n             for (Ref maybeNewDecl : refs) {\n               if (maybeNewDecl.type == Ref.Type.SET_FROM_GLOBAL) {\n                 declaration = maybeNewDecl;\n-                refs.remove(declaration);\n                 break;\n               }\n             }\n       }\n     }\n \n+    List<Ref> getRefs() {\n+      return refs == null ? ImmutableList.<Ref>of() : refs;\n+    }\n+\n     void addRefInternal(Ref ref) {\n       if (refs == null) {\n-        refs = new LinkedList<Ref>();\n+        refs = Lists.newArrayList();\n       }\n       refs.add(ref);\n     }\n \n     Node node;\n     final Type type;\n-    final String sourceName;\n+    final CompilerInput source;\n     final Scope scope;\n-    final JSModule module;\n \n     /**\n      * Certain types of references are actually double-refs. For example,\n      */\n     Ref(NodeTraversal t, Node name, Type type) {\n       this.node = name;\n-      this.sourceName = t.getSourceName();\n+      this.source = t.getInput();\n       this.type = type;\n       this.scope = t.getScope();\n-      this.module = t.getModule();\n     }\n \n     private Ref(Ref original, Type type) {\n       this.node = original.node;\n-      this.sourceName = original.sourceName;\n+      this.source = original.source;\n       this.type = type;\n       this.scope = original.scope;\n-      this.module = original.module;\n     }\n \n     private Ref(Type type) {\n       this.type = type;\n-      this.sourceName = \"source\";\n+      this.source = null;\n       this.scope = null;\n-      this.module = null;\n+    }\n+\n+    JSModule getModule() {\n+      return source == null ? null : source.getModule();\n+    }\n+\n+    String getSourceName() {\n+      return source == null ? \"\" : source.getName();\n     }\n \n     Ref getTwin() {\n--- a/src/com/google/javascript/jscomp/ProcessDefines.java\n+++ b/src/com/google/javascript/jscomp/ProcessDefines.java\n           allDefines.add(name);\n         } else {\n           JSError error = JSError.make(\n-              name.declaration.sourceName,\n+              name.declaration.getSourceName(),\n               name.declaration.node,\n               INVALID_DEFINE_TYPE_ERROR);\n           compiler.report(error);\n         }\n-      } else if (name.refs != null) {\n-        for (Ref ref : name.refs) {\n+      } else {\n+        for (Ref ref : name.getRefs()) {\n+          if (ref == name.declaration) {\n+            // Declarations were handled above.\n+            continue;\n+          }\n+\n           Node n = ref.node;\n           Node parent = ref.node.getParent();\n           JSDocInfo info = n.getJSDocInfo();\n           allRefInfo.put(name.declaration.node,\n                          new RefInfo(name.declaration, name));\n         }\n-        if (name.refs != null) {\n-          for (Ref ref : name.refs) {\n-            // If there's a TWIN def, only put one of the twins in.\n-            if (ref.getTwin() == null || !ref.getTwin().isSet()) {\n-              allRefInfo.put(ref.node, new RefInfo(ref, name));\n-            }\n+        for (Ref ref : name.getRefs()) {\n+          if (ref == name.declaration) {\n+            // Declarations were handled above.\n+            continue;\n+          }\n+\n+          // If there's a TWIN def, only put one of the twins in.\n+          if (ref.getTwin() == null || !ref.getTwin().isSet()) {\n+            allRefInfo.put(ref.node, new RefInfo(ref, name));\n           }\n         }\n       }\n--- a/test/com/google/javascript/jscomp/GlobalNamespaceTest.java\n+++ b/test/com/google/javascript/jscomp/GlobalNamespaceTest.java\n \n     assertEquals(set1, n.declaration);\n     assertEquals(2, n.globalSets);\n-    assertEquals(1, n.refs.size());\n+    assertEquals(2, n.getRefs().size());\n \n     n.removeRef(set1);\n \n     assertEquals(set2, n.declaration);\n     assertEquals(1, n.globalSets);\n-    assertEquals(0, n.refs.size());\n+    assertEquals(1, n.getRefs().size());\n   }\n \n   public void testRemoveDeclaration2() {\n     assertEquals(set1, n.declaration);\n     assertEquals(1, n.globalSets);\n     assertEquals(1, n.localSets);\n-    assertEquals(1, n.refs.size());\n+    assertEquals(2, n.getRefs().size());\n \n     n.removeRef(set1);\n \n--- a/test/com/google/javascript/jscomp/ProcessDefinesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessDefinesTest.java\n         \"var DEF=3;true;3\");\n \n     Name def = namespace.getNameIndex().get(\"DEF\");\n-    assertEquals(0, def.refs.size());\n+    assertEquals(1, def.getRefs().size());\n     assertEquals(1, def.globalSets);\n     assertNotNull(def.declaration);\n   }\n         \"var DEF=false;var x=function(){var y=DEF};false\");\n \n     Name def = namespace.getNameIndex().get(\"DEF\");\n-    assertEquals(1, def.refs.size());\n+    assertEquals(2, def.getRefs().size());\n     assertEquals(1, def.globalSets);\n     assertNotNull(def.declaration);\n   }\n          \"var a = {}; a.B = true; true;\");\n \n     Name aDotB = namespace.getNameIndex().get(\"a.B\");\n-    assertEquals(0, aDotB.refs.size());\n+    assertEquals(1, aDotB.getRefs().size());\n     assertEquals(1, aDotB.globalSets);\n     assertNotNull(aDotB.declaration);\n   }", "timestamp": 1303747627, "metainfo": ""}