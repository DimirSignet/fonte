{"sha": "6e85a91185aa7899955b7e05a0152b93b8da5a5d", "log": "open-source Xtb-based translation as it turns out, this is an open data format http://cldr.unicode.org/development/development-process/design-proposals/xmb  R=johnlenz DELTA=262  (248 added, 7 deleted, 7 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3237   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n+/*\n+ * Copyright 2008 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.CaseFormat;\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.jscomp.JsMessage.IdGenerator;\n+import com.google.javascript.jscomp.JsMessage.PlaceholderReference;\n+\n+import java.util.List;\n+\n+/**\n+ * An {@link IdGenerator} designed to play nicely with Google's Translation\n+ * systems. Each message is scoped to a project id, so that it does\n+ * not conflict with other messages at Google.\n+ * <p>\n+ * Just as reminder what key type used in different formats:\n+ * <ol>\n+ * <li>XMB - id. We export using this format.\n+ * <li>XTB - id. Internal, result of translation.\n+ * <li>XLB - name. External, use it if we need to share translation with third\n+ *     part.\n+ * <li>PROPERTIES - name.\n+ * </ol>\n+ *\n+ * @see http://cldr.unicode.org/development/development-process/design-proposals/xmb\n+ */\n+public class GoogleJsMessageIdGenerator implements IdGenerator {\n+\n+  private final String projectId;\n+\n+  /**\n+   * Creates an instance.\n+   *\n+   * @param projectId A TC project name (e.g. \"MyProject\")\n+   */\n+  public GoogleJsMessageIdGenerator(String projectId) {\n+    this.projectId = projectId;\n+  }\n+\n+  @Override\n+  public String generateId(String meaning, List<CharSequence> messageParts) {\n+    Preconditions.checkState(meaning != null);\n+\n+    StringBuilder sb = new StringBuilder();\n+    for (CharSequence part : messageParts) {\n+      if (part instanceof PlaceholderReference) {\n+        sb.append(CaseFormat.LOWER_CAMEL.to(\n+            CaseFormat.UPPER_UNDERSCORE,\n+            ((PlaceholderReference) part).getName()));\n+      } else {\n+        sb.append(part);\n+      }\n+    }\n+    String tcValue = sb.toString();\n+\n+    String projectScopedMeaning =\n+        (projectId != null ? (projectId + \": \") : \"\") + meaning;\n+    return String.valueOf(\n+        MessageId.GenerateId(tcValue, projectScopedMeaning));\n+  }\n+\n+\n+  /**\n+   * 64-bit fingerprint support.\n+   *\n+   * Forked from the guava-internal library.\n+   */\n+  private static final class FP {\n+    private FP() {}\n+\n+    /** Generate fingerprint of \"byte[start,limit-1]\". */\n+    private static long fingerprint(byte[] str, int start, int limit) {\n+      int hi = hash32(str, start, limit, 0);\n+      int lo = hash32(str, start, limit, 102072);\n+      if ((hi == 0) && (lo == 0 || lo == 1)) {\n+        // Turn 0/1 into another fingerprint\n+        hi ^= 0x130f9bef;\n+        lo ^= 0x94a0a928;\n+      }\n+      return (((long) hi) << 32) | (lo & 0xffffffffl);\n+    }\n+\n+    /**\n+     * Generate fingerprint of \"str\". Equivalent to utf-encoding \"str\" into\n+     * bytes and then fingerprinting those bytes.\n+     */\n+    private static long fingerprint(String str) {\n+      byte[] tmp = str.getBytes(Charsets.UTF_8);\n+      return FP.fingerprint(tmp, 0, tmp.length);\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    private static int hash32(byte[] str, int start, int limit, int c) {\n+      int a = 0x9e3779b9;\n+      int b = 0x9e3779b9;\n+      int i;\n+      for (i = start; i + 12 <= limit; i += 12) {\n+        a += (((str[i + 0] & 0xff) << 0)\n+            | ((str[i + 1] & 0xff) << 8)\n+            | ((str[i + 2] & 0xff) << 16)\n+            | ((str[i + 3] & 0xff) << 24));\n+        b += (((str[i + 4] & 0xff) << 0)\n+            | ((str[i + 5] & 0xff) << 8)\n+            | ((str[i + 6] & 0xff) << 16)\n+            | ((str[i + 7] & 0xff) << 24));\n+        c += (((str[i + 8] & 0xff) << 0)\n+            | ((str[i + 9] & 0xff) << 8) | ((str[i + 10] & 0xff) << 16)\n+            | ((str[i + 11] & 0xff) << 24));\n+\n+        // Mix\n+        a -= b;\n+        a -= c;\n+        a ^= (c >>> 13);\n+        b -= c;\n+        b -= a;\n+        b ^= (a << 8);\n+        c -= a;\n+        c -= b;\n+        c ^= (b >>> 13);\n+        a -= b;\n+        a -= c;\n+        a ^= (c >>> 12);\n+        b -= c;\n+        b -= a;\n+        b ^= (a << 16);\n+        c -= a;\n+        c -= b;\n+        c ^= (b >>> 5);\n+        a -= b;\n+        a -= c;\n+        a ^= (c >>> 3);\n+        b -= c;\n+        b -= a;\n+        b ^= (a << 10);\n+        c -= a;\n+        c -= b;\n+        c ^= (b >>> 15);\n+      }\n+\n+      c += limit - start;\n+      switch (limit - i) { // deal with rest. Cases fall through\n+        case 11:\n+          c += (str[i + 10] & 0xff) << 24;\n+        case 10:\n+          c += (str[i + 9] & 0xff) << 16;\n+        case 9:\n+          c += (str[i + 8] & 0xff) << 8;\n+          // the first byte of c is reserved for the length\n+        case 8:\n+          b += (str[i + 7] & 0xff) << 24;\n+        case 7:\n+          b += (str[i + 6] & 0xff) << 16;\n+        case 6:\n+          b += (str[i + 5] & 0xff) << 8;\n+        case 5:\n+          b += (str[i + 4] & 0xff);\n+        case 4:\n+          a += (str[i + 3] & 0xff) << 24;\n+        case 3:\n+          a += (str[i + 2] & 0xff) << 16;\n+        case 2:\n+          a += (str[i + 1] & 0xff) << 8;\n+        case 1:\n+          a += (str[i + 0] & 0xff);\n+          // case 0 : nothing left to add\n+      }\n+\n+      // Mix\n+      a -= b;\n+      a -= c;\n+      a ^= (c >>> 13);\n+      b -= c;\n+      b -= a;\n+      b ^= (a << 8);\n+      c -= a;\n+      c -= b;\n+      c ^= (b >>> 13);\n+      a -= b;\n+      a -= c;\n+      a ^= (c >>> 12);\n+      b -= c;\n+      b -= a;\n+      b ^= (a << 16);\n+      c -= a;\n+      c -= b;\n+      c ^= (b >>> 5);\n+      a -= b;\n+      a -= c;\n+      a ^= (c >>> 3);\n+      b -= c;\n+      b -= a;\n+      b ^= (a << 10);\n+      c -= a;\n+      c -= b;\n+      c ^= (b >>> 15);\n+      return c;\n+    }\n+  }\n+\n+  /**\n+   * Generates fingerprint for an English message using the FP package.\n+   * This supercedes the message id generation using C fingerprint\n+   * functions and JNI.  This is slower than the C implementation (\n+   * we're talking about microseconds here) but it avoids using JNI and\n+   * shared libraries.<p>\n+   *\n+   * Forked from the i18n library.\n+   */\n+  private static class MessageId {\n+    private final static long GenerateId(String message, String meaning) {\n+      long fp = FP.fingerprint(message);\n+      if (null != meaning && meaning.length() > 0) {\n+        // combine the fingerprints of message and meaning\n+        long fp2 = FP.fingerprint(meaning);\n+        fp = fp2 + (fp << 1) + (fp < 0 ? 1 : 0);\n+      }\n+      // To avoid negative ids we strip the high-order bit\n+      return fp & 0x7fffffffffffffffL;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/XtbMessageBundle.java\n+/*\n+ * Copyright 2006 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Maps;\n+\n+import com.sun.org.apache.xerces.internal.jaxp.SAXParserFactoryImpl;\n+\n+import org.xml.sax.Attributes;\n+import org.xml.sax.ContentHandler;\n+import org.xml.sax.EntityResolver;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLReader;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import javax.annotation.Nullable;\n+import javax.xml.XMLConstants;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+\n+/**\n+ * A MessageBundle that parses messages from an XML Translation Bundle (XTB)\n+ * file.\n+ *\n+ */\n+@SuppressWarnings(\"sunapi\")\n+public class XtbMessageBundle implements MessageBundle {\n+  private static final SecureEntityResolver NOOP_RESOLVER\n+      = new SecureEntityResolver();\n+\n+  private final String projectId;\n+  private final Map<String, JsMessage> messages;\n+  private final JsMessage.IdGenerator idGenerator;\n+\n+  public XtbMessageBundle(\n+      InputStream xtb, @Nullable String projectId, boolean unused) {\n+    this(xtb, projectId);\n+  }\n+\n+  /**\n+   * Creates an instance and initializes it with the messages in an XTB file.\n+   *\n+   * @param xtb  the XTB file as a byte stream\n+   * @param projectId  the translation console project id (i.e. name)\n+   */\n+  public XtbMessageBundle(InputStream xtb, @Nullable String projectId) {\n+    Preconditions.checkState(!\"\".equals(projectId));\n+    this.projectId = projectId;\n+    this.messages = Maps.newHashMap();\n+    this.idGenerator = new GoogleJsMessageIdGenerator(projectId);\n+\n+    try {\n+      // Use a SAX parser for speed and less memory usage.\n+      SAXParser parser = createSAXParser();\n+      XMLReader reader = parser.getXMLReader();\n+      Handler contentHandler = new Handler();\n+      reader.setContentHandler(contentHandler);\n+      reader.parse(new InputSource(xtb));\n+    } catch (ParserConfigurationException e) {\n+      throw new RuntimeException(e);\n+    } catch (SAXException e) {\n+      throw new RuntimeException(e);\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  // Inlined from guava-internal.\n+  private SAXParser createSAXParser()\n+      throws ParserConfigurationException, SAXException {\n+    SAXParserFactory factory = new SAXParserFactoryImpl();\n+    factory.setValidating(false);\n+    factory.setXIncludeAware(false);\n+    factory.setFeature(\n+        \"http://xml.org/sax/features/external-general-entities\", false);\n+    factory.setFeature(\n+        \"http://xml.org/sax/features/external-parameter-entities\",false);\n+    factory.setFeature(\n+        \"http://apache.org/xml/features/nonvalidating/load-external-dtd\",\n+        false);\n+    factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n+\n+    SAXParser parser = factory.newSAXParser();\n+    XMLReader xmlReader = parser.getXMLReader();\n+    xmlReader.setEntityResolver(NOOP_RESOLVER);\n+    return parser;\n+  }\n+\n+  @Override\n+  public JsMessage getMessage(String id) {\n+    return messages.get(id);\n+  }\n+\n+  @Override\n+  public JsMessage.IdGenerator idGenerator() {\n+    return idGenerator;\n+  }\n+\n+  @Override\n+  public Iterable<JsMessage> getAllMessages() {\n+    return Iterables.unmodifiableIterable(messages.values());\n+  }\n+\n+  /**\n+   * A {@link ContentHandler} that creates a {@link JsMessage} for each message\n+   * parsed from an XML Translation Bundle (XTB) file.\n+   */\n+  private class Handler implements ContentHandler {\n+    private static final String BUNDLE_ELEM_NAME = \"translationbundle\";\n+    private static final String LANG_ATT_NAME = \"lang\";\n+\n+    private static final String TRANSLATION_ELEM_NAME = \"translation\";\n+    private static final String MESSAGE_ID_ATT_NAME = \"id\";\n+\n+    private static final String PLACEHOLDER_ELEM_NAME = \"ph\";\n+    private static final String PLACEHOLDER_NAME_ATT_NAME = \"name\";\n+\n+    String lang;\n+    JsMessage.Builder msgBuilder;\n+\n+    @Override\n+    public void setDocumentLocator(Locator locator) {}\n+\n+    @Override\n+    public void startDocument() {}\n+\n+    @Override\n+    public void endDocument() {}\n+\n+    @Override\n+    public void startPrefixMapping(String prefix, String uri) {}\n+\n+    @Override\n+    public void endPrefixMapping(String prefix) {}\n+\n+    @Override\n+    public void startElement(String uri, String localName, String qName,\n+                             Attributes atts) {\n+      if (BUNDLE_ELEM_NAME.equals(qName)) {\n+        Preconditions.checkState(lang == null);\n+        lang = atts.getValue(LANG_ATT_NAME);\n+        Preconditions.checkState(lang != null && !lang.isEmpty());\n+      } else if (TRANSLATION_ELEM_NAME.equals(qName)) {\n+        Preconditions.checkState(msgBuilder == null);\n+        String id = atts.getValue(MESSAGE_ID_ATT_NAME);\n+        Preconditions.checkState(id != null && !id.isEmpty());\n+        msgBuilder = new JsMessage.Builder(id);\n+      } else if (PLACEHOLDER_ELEM_NAME.equals(qName)) {\n+        Preconditions.checkState(msgBuilder != null);\n+        String phRef = atts.getValue(PLACEHOLDER_NAME_ATT_NAME);\n+        phRef = JsMessageVisitor.toLowerCamelCaseWithNumericSuffixes(phRef);\n+        msgBuilder.appendPlaceholderReference(phRef);\n+      }\n+    }\n+\n+    @Override\n+    public void endElement(String uri, String localName, String qName) {\n+      if (TRANSLATION_ELEM_NAME.equals(qName)) {\n+        Preconditions.checkState(msgBuilder != null);\n+        if (!msgBuilder.hasParts()) {\n+          msgBuilder.appendStringPart(\"\");\n+        }\n+        String key = msgBuilder.getKey();\n+        messages.put(key, msgBuilder.build());\n+        msgBuilder = null;\n+      }\n+    }\n+\n+    @Override\n+    public void characters(char ch[], int start, int length) {\n+      if (msgBuilder != null) {\n+        // Append a string literal to the message.\n+        msgBuilder.appendStringPart(String.valueOf(ch, start, length));\n+      }\n+    }\n+\n+    @Override\n+    public void ignorableWhitespace(char ch[], int start, int length) {\n+      if (msgBuilder != null) {\n+        // Preserve whitespace in messages.\n+        msgBuilder.appendStringPart(String.valueOf(ch, start, length));\n+      }\n+    }\n+\n+    @Override\n+    public void processingInstruction(String target, String data) {}\n+\n+    @Override\n+    public void skippedEntity(String name) {}\n+  }\n+\n+  /**\n+   * A secure EntityResolver that returns an empty string in response to\n+   * any attempt to resolve an external entitity. The class is used by our\n+   * secure version of the internal saxon SAX parser.\n+   */\n+  private static final class SecureEntityResolver implements EntityResolver {\n+\n+    @Override\n+    public InputSource resolveEntity(String publicId, String systemId) {\n+      return new InputSource(new StringReader(\"\"));\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/XtbMessageBundleTest.java\n+/*\n+ * Copyright 2006 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+\n+import junit.framework.TestCase;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+\n+/**\n+ * Tests {@link XtbMessageBundle}.\n+ *\n+ */\n+public class XtbMessageBundleTest extends TestCase {\n+\n+  private final static String PROJECT_ID = \"TestProject\";\n+\n+  private static final String XTB =\n+      \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n+          + \"<!DOCTYPE translationbundle SYSTEM\"\n+          + \" \\\"translationbundle.dtd\\\">\\n\"\n+          + \"<translationbundle lang=\\\"zh-HK\\\">\\n\"\n+          + \"<translation id=\\\"7639678437384034548\\\">descargar</translation>\\n\"\n+          + \"<translation id=\\\"2398375912250604550\\\">Se han\\nignorado\"\n+          + \" <ph name=\\\"NUM\\\"/> conversaciones.</translation>\\n\"\n+          + \"<translation id=\\\"6323937743550839320\\\"><ph name=\\\"P_START\\\"/>Si,\"\n+          + \" puede <ph name=\\\"LINK_START_1_3\\\"/>hacer\"\n+          + \" clic<ph name=\\\"LINK_END_1_3\\\"/>\"\n+          + \" para utilizar.<ph name=\\\"P_END\\\"/><ph name=\\\"P_START\\\"/>Esperamos\"\n+          + \" poder ampliar.<ph name=\\\"P_END\\\"/></translation>\\n\"\n+          + \"<translation id=\\\"3945720239421293834\\\"></translation>\\n\"\n+          + \"</translationbundle>\";\n+\n+  public void test() {\n+    InputStream stream = new ByteArrayInputStream(XTB.getBytes(UTF_8));\n+    XtbMessageBundle bundle = new XtbMessageBundle(\n+        stream, PROJECT_ID);\n+\n+    JsMessage message = bundle.getMessage(\"7639678437384034548\");\n+    assertEquals(\"descargar\", message.toString());\n+\n+    message = bundle.getMessage(\"2398375912250604550\");\n+    assertEquals(\"Se han\\nignorado {$num} conversaciones.\",\n+        message.toString());\n+\n+    message = bundle.getMessage(\"6323937743550839320\");\n+    assertEquals(\"{$pStart}Si, puede {$linkStart_1_3}hacer \"\n+        + \"clic{$linkEnd_1_3} para utilizar.{$pEnd}{$pStart}Esperamos \"\n+        + \"poder ampliar.{$pEnd}\",\n+        message.toString());\n+\n+    message = bundle.getMessage(\"3945720239421293834\");\n+    assertEquals(\"\", message.toString());\n+    assertFalse(message.parts().isEmpty());\n+  }\n+}", "timestamp": 1315846878, "metainfo": ""}