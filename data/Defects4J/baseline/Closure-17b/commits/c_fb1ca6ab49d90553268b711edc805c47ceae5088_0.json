{"sha": "fb1ca6ab49d90553268b711edc805c47ceae5088", "log": "Create an inferface for references in the symbol table  R=acleung DELTA=275  (214 added, 16 deleted, 45 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2317   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n               aliasRefs.references.get(i);\n \n           Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNameNode(), newNode);\n+          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n           newNodes.add(newNode);\n         }\n \n--- a/src/com/google/javascript/jscomp/CompilerInput.java\n+++ b/src/com/google/javascript/jscomp/CompilerInput.java\n import com.google.javascript.jscomp.deps.JsFileParser;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.StaticSourceFile;\n \n import java.io.IOException;\n import java.util.Collection;\n  * whether the input is an extern. Also calculates provided and required types.\n  *\n  */\n-public class CompilerInput implements SourceAst, DependencyInfo {\n+public class CompilerInput\n+    implements SourceAst, DependencyInfo, StaticSourceFile {\n   private static final long serialVersionUID = 1L;\n \n   // Info about where the file lives.\n     this.module = module;\n   }\n \n+  @Override\n   public boolean isExtern() {\n     return isExtern;\n   }\n--- a/src/com/google/javascript/jscomp/GlobalVarReferenceMap.java\n+++ b/src/com/google/javascript/jscomp/GlobalVarReferenceMap.java\n     int index = 0;\n     int sourceInputOrder = inputOrder.get(sourceName);\n     for (Reference ref : refList) {\n-      int order = inputOrder.get(ref.getSourceName());\n+      int order = inputOrder.get(ref.getSourceFile().getName());\n       if (order < sourceInputOrder) {\n         lastBefore = index;\n       } else if (order > sourceInputOrder) {\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n     private boolean isInlinableObject(List<Reference> refs) {\n       boolean ret = false;\n       for (Reference ref : refs) {\n-        Node name = ref.getNameNode();\n+        Node name = ref.getNode();\n         Node parent = ref.getParent();\n         Node gramps = ref.getGrandparent();\n \n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n         ReferenceCollection refs = referenceMap.getReferences(arguments);\n         if (refs != null && !refs.references.isEmpty()) {\n           for (Reference ref : refs.references) {\n-            Node refNode = ref.getNameNode();\n+            Node refNode = ref.getNode();\n             Node refParent = ref.getParent();\n             // Any reference that is not a read of the arguments property\n             // consider a escape of the arguments object.\n           value = init.getAssignedValue();\n         } else {\n           // Create a new node for variable that is never initialized.\n-          Node srcLocation = declaration.getNameNode();\n+          Node srcLocation = declaration.getNode();\n           value = NodeUtil.newUndefinedNode(srcLocation);\n         }\n         Preconditions.checkNotNull(value);\n           referenceInfo.isAssignedOnceInLifetime()) {\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n-          Node nameNode = refs.get(i).getNameNode();\n+          Node nameNode = refs.get(i).getNode();\n           if (aliasCandidates.containsKey(nameNode)) {\n             AliasCandidate candidate = aliasCandidates.get(nameNode);\n             if (!staleVars.contains(candidate.alias) &&\n       Reference decl = null;\n \n       for (Reference r : refSet) {\n-        if (r.getNameNode() == v.getNameNode()) {\n+        if (r.getNode() == v.getNameNode()) {\n           decl = r;\n         } else {\n           inlineValue(v, r, value.cloneTree());\n      */\n     private void removeDeclaration(Reference declaration) {\n       Node varNode = declaration.getParent();\n-      varNode.removeChild(declaration.getNameNode());\n+      Node grandparent = declaration.getGrandparent();\n+\n+      varNode.removeChild(declaration.getNode());\n \n       // Remove var node if empty\n       if (!varNode.hasChildren()) {\n         Preconditions.checkState(varNode.getType() == Token.VAR);\n-\n-        Node grandparent = declaration.getGrandparent();\n         NodeUtil.removeChild(grandparent, varNode);\n       }\n \n         // This is the initial assignment.\n         ref.getGrandparent().replaceChild(ref.getParent(), value);\n       } else {\n-        ref.getParent().replaceChild(ref.getNameNode(), value);\n+        ref.getParent().replaceChild(ref.getNode(), value);\n       }\n \n       blacklistVarReferencesInTree(value, v.scope);\n       Preconditions.checkState(value != null);\n       if (value.getType() == Token.GETPROP\n           && reference.getParent().getType() == Token.CALL\n-          && reference.getParent().getFirstChild() == reference.getNameNode()) {\n+          && reference.getParent().getFirstChild() == reference.getNode()) {\n         return false;\n       }\n \n       Iterator<Node> it;\n       if (initialization.getParent().getType() == Token.VAR) {\n         it = NodeIterators.LocalVarMotion.forVar(\n-            initialization.getNameNode(),     // NAME\n+            initialization.getNode(),     // NAME\n             initialization.getParent(),       // VAR\n             initialization.getGrandparent()); // VAR container\n       } else if (initialization.getParent().getType() == Token.ASSIGN) {\n         Preconditions.checkState(\n             initialization.getGrandparent().getType() == Token.EXPR_RESULT);\n         it = NodeIterators.LocalVarMotion.forAssign(\n-            initialization.getNameNode(),     // NAME\n+            initialization.getNode(),     // NAME\n             initialization.getParent(),       // ASSIGN\n             initialization.getGrandparent(),  // EXPR_RESULT\n             initialization.getGrandparent().getParent()); // EXPR container\n         throw new IllegalStateException(\"Unexpected initialization parent \" +\n             initialization.getParent().toStringTree());\n       }\n-      Node targetName = reference.getNameNode();\n+      Node targetName = reference.getNode();\n       while (it.hasNext()) {\n         Node curNode = it.next();\n         if (curNode == targetName) {\n         // The reference is a FUNCTION declaration or normal VAR declaration\n         // with a value.\n         return NodeUtil.isFunctionDeclaration(initialization.getParent())\n-            || initialization.getNameNode().getFirstChild() != null;\n+            || initialization.getNode().getFirstChild() != null;\n       } else {\n         Node parent = initialization.getParent();\n         Preconditions.checkState(\n             parent.getType() == Token.ASSIGN\n-            && parent.getFirstChild() == initialization.getNameNode());\n+            && parent.getFirstChild() == initialization.getNode());\n         return true;\n       }\n     }\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.SimpleSourceFile;\n+import com.google.javascript.rhino.jstype.StaticReference;\n+import com.google.javascript.rhino.jstype.StaticSourceFile;\n \n import java.util.ArrayDeque;\n import java.util.Deque;\n         v = t.getScope().getVar(n.getString());\n       }\n       if (v != null && varFilter.apply(v)) {\n-        addReference(t, v,\n-            new Reference(n, parent, t, blockStack.peek()));\n+        addReference(t, v, new Reference(n, t, blockStack.peek()));\n       }\n     }\n \n   /**\n    * Represents a single declaration or reference to a variable.\n    */\n-  static final class Reference {\n+  static final class Reference implements StaticReference {\n \n     private static final Set<Integer> DECLARATION_PARENTS =\n         ImmutableSet.of(Token.VAR, Token.FUNCTION, Token.CATCH);\n \n     private final Node nameNode;\n-    private final Node parent;\n-    private final Node grandparent;\n     private final BasicBlock basicBlock;\n     private final Scope scope;\n-    private final String sourceName;\n-\n-    Reference(Node nameNode, Node parent, NodeTraversal t,\n+    private final StaticSourceFile sourceFile;\n+\n+    Reference(Node nameNode, NodeTraversal t,\n         BasicBlock basicBlock) {\n-      this(nameNode, parent, parent.getParent(), basicBlock, t.getScope(),\n-           t.getSourceName());\n+      this(nameNode, basicBlock, t.getScope(), t.getInput());\n     }\n \n     // Bleeding functions are weird, because the declaration does\n     // not appear inside their scope. So they need their own constructor.\n     static Reference newBleedingFunction(NodeTraversal t,\n         BasicBlock basicBlock, Node func) {\n-      return new Reference(func.getFirstChild(), func, func.getParent(),\n-          basicBlock, t.getScope(), t.getSourceName());\n+      return new Reference(func.getFirstChild(),\n+          basicBlock, t.getScope(), t.getInput());\n     }\n \n     /**\n      */\n     @VisibleForTesting\n     static Reference createRefForTest(String sourceName) {\n-      return new Reference(new Node(Token.NAME), null, null, null, null,\n-          sourceName);\n-    }\n-\n-    private Reference(Node nameNode, Node parent, Node grandparent,\n-        BasicBlock basicBlock, Scope scope, String sourceName) {\n+      return new Reference(new Node(Token.NAME), null, null,\n+          new SimpleSourceFile(sourceName, false));\n+    }\n+\n+    private Reference(Node nameNode,\n+        BasicBlock basicBlock, Scope scope, StaticSourceFile sourceFile) {\n       this.nameNode = nameNode;\n-      this.parent = parent;\n-      this.grandparent = grandparent;\n       this.basicBlock = basicBlock;\n       this.scope = scope;\n-      this.sourceName = sourceName;\n+      this.sourceFile = sourceFile;\n+    }\n+\n+    @Override\n+    public Var getSymbol() {\n+      return scope.getVar(nameNode.getString());\n+    }\n+\n+    @Override\n+    public Node getNode() {\n+      return nameNode;\n+    }\n+\n+    @Override\n+    public StaticSourceFile getSourceFile() {\n+      return sourceFile;\n     }\n \n     boolean isDeclaration() {\n+      Node parent = getParent();\n+      Node grandparent = parent.getParent();\n       return DECLARATION_PARENTS.contains(parent.getType()) ||\n           parent.getType() == Token.LP &&\n           grandparent.getType() == Token.FUNCTION;\n     }\n \n     boolean isVarDeclaration() {\n-      return parent.getType() == Token.VAR;\n+      return getParent().getType() == Token.VAR;\n     }\n \n     boolean isHoistedFunction() {\n-      return NodeUtil.isHoistedFunctionDeclaration(parent);\n+      return NodeUtil.isHoistedFunctionDeclaration(getParent());\n     }\n \n     /**\n       // VAR is the only type of variable declaration that may not initialize\n       // its variable. Catch blocks, named functions, and parameters all do.\n       return isDeclaration() &&\n-          (parent.getType() != Token.VAR || nameNode.getFirstChild() != null);\n+          getParent().getType() != Token.VAR ||\n+          nameNode.getFirstChild() != null;\n     }\n \n    /**\n     * return the assigned value, otherwise null.\n     */\n     Node getAssignedValue() {\n+      Node parent = getParent();\n       return (parent.getType() == Token.FUNCTION)\n-          ? parent : NodeUtil.getAssignedValue(getNameNode());\n+          ? parent : NodeUtil.getAssignedValue(nameNode);\n     }\n \n     BasicBlock getBasicBlock() {\n     }\n \n     Node getParent() {\n-      return parent;\n-    }\n-\n-    Node getNameNode() {\n-      return nameNode;\n+      return getNode().getParent();\n     }\n \n     Node getGrandparent() {\n-      return grandparent;\n+      Node parent = getParent();\n+      return parent == null ? null : parent.getParent();\n     }\n \n     private static boolean isLhsOfForInExpression(Node n) {\n     }\n \n     boolean isSimpleAssignmentToName() {\n+      Node parent = getParent();\n       return parent.getType() == Token.ASSIGN\n           && parent.getFirstChild() == nameNode;\n     }\n \n     boolean isLvalue() {\n+      Node parent = getParent();\n       int parentType = parent.getType();\n       return (parentType == Token.VAR && nameNode.getFirstChild() != null)\n           || parentType == Token.INC\n \n     Scope getScope() {\n       return scope;\n-    }\n-\n-    public String getSourceName() {\n-      return sourceName;\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n+++ b/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n             callback.getReferenceCollection(variable);\n \n         for (Reference reference : referenceCollection.references) {\n-         Node referenceNameNode = reference.getNameNode();\n+          Node referenceNameNode = reference.getNode();\n \n           // Note that this counts a declaration as a reference to itself\n           referencesByNameNode.put(referenceNameNode, variable.getNameNode());\n--- a/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n+++ b/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n           hoistedFn = reference;\n           break;\n         } else if (NodeUtil.isFunctionDeclaration(\n-            reference.getNameNode().getParent())) {\n+            reference.getNode().getParent())) {\n           isUnhoistedNamedFunction = true;\n         }\n       }\n           for (BasicBlock declaredBlock : blocksWithDeclarations) {\n             if (declaredBlock.provablyExecutesBefore(basicBlock)) {\n               compiler.report(\n-                  JSError.make(reference.getSourceName(),\n-                      reference.getNameNode(),\n+                  JSError.make(reference.getSourceFile().getName(),\n+                      reference.getNode(),\n                       checkLevel,\n                       REDECLARED_VARIABLE, v.name));\n               break;\n           for (BasicBlock declaredBlock : blocksWithDeclarations) {\n             if (!declaredBlock.provablyExecutesBefore(basicBlock)) {\n               compiler.report(\n-                  JSError.make(reference.getSourceName(),\n-                      reference.getNameNode(),\n+                  JSError.make(reference.getSourceFile().getName(),\n+                      reference.getNode(),\n                       AMBIGUOUS_FUNCTION_DECL, v.name));\n               break;\n             }\n           // to deal with possible forward declarations and recursion\n           if (reference.getScope() == v.scope) {\n             compiler.report(\n-                JSError.make(reference.getSourceName(),\n-                             reference.getNameNode(),\n+                JSError.make(reference.getSourceFile().getName(),\n+                             reference.getNode(),\n                              checkLevel,\n                              UNDECLARED_REFERENCE, v.name));\n           }\n--- /dev/null\n+++ b/src/com/google/javascript/rhino/jstype/SimpleSourceFile.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+/**\n+ * A simple implementation of {@code StaticSourceFile} for testing.\n+ *\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public final class SimpleSourceFile implements StaticSourceFile {\n+  private final String name;\n+  private final boolean extern;\n+\n+  public SimpleSourceFile(String name, boolean extern) {\n+    this.name = name;\n+    this.extern = extern;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return name;\n+  }\n+\n+  @Override\n+  public boolean isExtern() {\n+    return extern;\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/rhino/jstype/StaticReference.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+import com.google.javascript.rhino.Node;\n+\n+/**\n+ * The {@code StaticReference} tells us all the ways that a {@code StaticSlot}\n+ * is used in a program.\n+ *\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public interface StaticReference {\n+  /**\n+   * The variable that this reference points to.\n+   */\n+  StaticSlot<JSType> getSymbol();\n+\n+  /**\n+   * The node where the reference lives.\n+   */\n+  Node getNode();\n+\n+  /**\n+   * The source file where the reference lives.\n+   */\n+  StaticSourceFile getSourceFile();\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/rhino/jstype/StaticSourceFile.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+/**\n+ * The {@code StaticSourceFile} contains information about a compiler input.\n+ *\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public interface StaticSourceFile {\n+  /**\n+   * The name of the file. Must be unique across all files in the compilation.\n+   */\n+  String getName();\n+\n+  /**\n+   * Returns whether this is an externs file.\n+   */\n+  boolean isExtern();\n+}", "timestamp": 1308247937, "metainfo": ""}