{"sha": "41ecd65c09b6d39253c4f855e615daabbc7e241a", "log": "Better warnings for fixing DisambiguateProperties ignores.  R=johnlenz DELTA=164  (92 added, 23 deleted, 49 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2860   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n \n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.LinkedHashMultimap;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n       DisambiguateProperties.class.getName());\n \n   static class Warnings {\n+    // TODO(user): {1} and {2} are not exactly useful for most people.\n     static final DiagnosticType INVALIDATION = DiagnosticType.disabled(\n         \"JSC_INVALIDATION\",\n         \"Property disambiguator skipping all instances of property {0} \"\n-        + \"because of type {1} node {2}\");\n+        + \"because of type {1} node {2}. {3}\");\n   }\n \n   private final boolean showInvalidationWarnings;\n \n   private final AbstractCompiler compiler;\n   private final TypeSystem<T> typeSystem;\n+\n+  /**\n+   * Map of a type to all the related errors that invalidated the type\n+   * for disambiguation. It has be Object because of the generic nature of\n+   * this pass.\n+   */\n+  private Multimap<Object, JSError> invalidationMap;\n \n   private class Property {\n     /** The name of the property. */\n     this.typeSystem = typeSystem;\n     this.showInvalidationWarnings = compiler.getErrorLevel(\n         JSError.make(\"\", 0, 0, Warnings.INVALIDATION)) != CheckLevel.OFF;\n+    if (this.showInvalidationWarnings) {\n+      this.invalidationMap = LinkedHashMultimap.create();\n+    } else {\n+      this.invalidationMap = null;\n+    }\n   }\n \n   @Override\n     for (TypeMismatch mis : compiler.getTypeValidator().getMismatches()) {\n       addInvalidatingType(mis.typeA);\n       addInvalidatingType(mis.typeB);\n+      recordInvalidationError(mis.typeA, mis.src);\n+      recordInvalidationError(mis.typeB, mis.src);\n     }\n \n     StaticScope<T> scope = typeSystem.getRootScope();\n     NodeTraversal.traverse(compiler, externs, new FindExternProperties());\n     NodeTraversal.traverse(compiler, root, new FindRenameableProperties());\n     renameProperties();\n+  }\n+\n+  private void recordInvalidationError(JSType t, JSError error) {\n+    if (!t.isObject()) {\n+      return;\n+    }\n+    if (t.isUnionType()) {\n+      for (JSType alt : ((UnionType) t).getAlternates()) {\n+        recordInvalidationError(alt, error);\n+      }\n+      return;\n+    }\n+    if (invalidationMap != null) {\n+      invalidationMap.put(t, error);\n+    }\n   }\n \n   /**\n       if (!prop.scheduleRenaming(n.getLastChild(),\n                                  processProperty(t, prop, type, null))) {\n         if (showInvalidationWarnings) {\n+          String suggestion = \"\";\n+          if (type instanceof JSType) {\n+            JSType jsType = (JSType) type;\n+            String qName = n.getFirstChild().getQualifiedName();\n+            if (jsType.isAllType() || jsType.isUnknownType()) {\n+              if (n.getFirstChild().getType() == Token.THIS) {\n+                suggestion = \"The \\\"this\\\" object is unknown in the function,\"+\n+                    \"consider using @this\";\n+              } else {\n+                suggestion = \"Consider casting \" + qName +\n+                    \" if you know it's type.\";\n+              }\n+            } else {\n+              StringBuilder sb = new StringBuilder();\n+              printErrorLocations(sb, jsType);\n+              if (sb.length() != 0) {\n+                suggestion = \"Consider fixing errors for the following types: \";\n+                suggestion += sb.toString();\n+              }\n+            }\n+          }\n           compiler.report(JSError.make(\n               t.getSourceName(), n, Warnings.INVALIDATION, name,\n-              (type == null ? \"null\" : type.toString()), n.toString()));\n+              (type == null ? \"null\" : type.toString()), n.toString(),\n+              suggestion));\n         }\n       }\n     }\n         Property prop = getProperty(name);\n         if (!prop.scheduleRenaming(child,\n                                    processProperty(t, prop, type, null))) {\n+          // TODO(user): It doesn't look like the user can do much in this\n+          // case right now.\n           if (showInvalidationWarnings) {\n             compiler.report(JSError.make(\n                 t.getSourceName(), child, Warnings.INVALIDATION, name,\n-                (type == null ? \"null\" : type.toString()), n.toString()));\n-          }\n-        }\n-\n+                (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n+          }\n+        }\n         child = child.getNext();\n+      }\n+    }\n+\n+    private void printErrorLocations(StringBuilder sb, JSType t) {\n+      if (!t.isObject() || t.isAllType() || t.isUnionType()) {\n+        return;\n+      }\n+      if (t.isUnionType()) {\n+        for (JSType alt : ((UnionType) t).getAlternates()) {\n+          printErrorLocations(sb, alt);\n+        }\n+        return;\n+      }\n+      for (JSError error : invalidationMap.get(t)) {\n+        if(sb.length() != 0) {\n+          sb.append(\", \");\n+        }\n+        sb.append(t.toString());\n+        sb.append(\" at \");\n+        sb.append(error.sourceName);\n+        sb.append(\":\");\n+        sb.append(error.lineNumber);\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n import com.google.common.base.Objects;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.DisambiguateProperties.Warnings;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n   private final JSTypeRegistry typeRegistry;\n   private final JSType allValueTypes;\n   private boolean shouldReport = true;\n+  private final boolean recordErrors;\n   private final JSType nullOrUndefined;\n \n   // TODO(nicksantos): Provide accessors to better filter the list of type\n         STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE);\n     this.nullOrUndefined = typeRegistry.createUnionType(\n         NULL_TYPE, VOID_TYPE);\n+    this.recordErrors = compiler.getErrorLevel(\n+        JSError.make(\"\", 0, 0, Warnings.INVALIDATION)) != CheckLevel.OFF;\n   }\n \n   /**\n       if (bothIntrinsics(rightType, leftType)) {\n         // We have a superior warning for this mistake, which gives you\n         // the line numbers of both types.\n-        registerMismatch(rightType, leftType);\n+        registerMismatch(rightType, leftType, null);\n       } else {\n         mismatch(t, n,\n             \"assignment to property \" + propName + \" of \" +\n       if (bothIntrinsics(rightType, leftType)) {\n         // We have a superior warning for this mistake, which gives you\n         // the line numbers of both types.\n-        registerMismatch(rightType, leftType);\n+        registerMismatch(rightType, leftType, null);\n       } else {\n         mismatch(t, n, msg, rightType, leftType);\n       }\n   void expectCanOverride(NodeTraversal t, Node n, JSType overridingType,\n       JSType hiddenType, String propertyName, JSType ownerType) {\n     if (!overridingType.canAssignTo(hiddenType)) {\n-      registerMismatch(overridingType, hiddenType);\n-      if (shouldReport) {\n-        compiler.report(\n-            t.makeError(n, HIDDEN_PROPERTY_MISMATCH,\n-                propertyName, ownerType.toString(),\n-                hiddenType.toString(), overridingType.toString()));\n-      }\n+      registerMismatch(overridingType, hiddenType,\n+          report(t.makeError(n, HIDDEN_PROPERTY_MISMATCH, propertyName,\n+            ownerType.toString(), hiddenType.toString(),\n+            overridingType.toString())));\n     }\n   }\n \n         subObject.getImplicitPrototype().getImplicitPrototype();\n     if (!declaredSuper.equals(superObject)) {\n       if (declaredSuper.equals(getNativeType(OBJECT_TYPE))) {\n-        if (shouldReport) {\n-          compiler.report(\n-              t.makeError(n, MISSING_EXTENDS_TAG_WARNING,\n-                  subObject.toString()));\n-        }\n-        registerMismatch(superObject, declaredSuper);\n+        registerMismatch(superObject, declaredSuper, report(\n+            t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString())));\n       } else {\n         mismatch(t.getSourceName(), n,\n             \"mismatch in declaration of superclass type\",\n     type = type.restrictByNotNullOrUndefined();\n \n     if (!type.canAssignTo(castType) && !castType.canAssignTo(type)) {\n-      if (shouldReport) {\n-        compiler.report(\n-            t.makeError(n, INVALID_CAST,\n-                castType.toString(), type.toString()));\n-      }\n-      registerMismatch(type, castType);\n+      registerMismatch(type, castType, report(t.makeError(n, INVALID_CAST,\n+          castType.toString(), type.toString())));\n     }\n   }\n \n         if (!(allowDupe ||\n               var.getParentNode().getType() == Token.EXPR_RESULT) ||\n             !newType.equals(varType)) {\n-          if (shouldReport) {\n-            compiler.report(\n-                JSError.make(sourceName, n, DUP_VAR_DECLARATION,\n-                    variableName, newType.toString(), var.getInputName(),\n-                    String.valueOf(var.nameNode.getLineno()),\n-                    varType.toString()));\n-          }\n+          report(JSError.make(sourceName, n, DUP_VAR_DECLARATION,\n+              variableName, newType.toString(), var.getInputName(),\n+              String.valueOf(var.nameNode.getLineno()),\n+              varType.toString()));\n         }\n       }\n     }\n       // Not implemented\n       String sourceName = n.getSourceFileName();\n       sourceName = sourceName == null ? \"\" : sourceName;\n-      if (shouldReport) {\n-        compiler.report(JSError.make(sourceName, n,\n-            INTERFACE_METHOD_NOT_IMPLEMENTED,\n-            prop, implementedInterface.toString(), instance.toString()));\n-      }\n-      registerMismatch(instance, implementedInterface);\n+      registerMismatch(instance, implementedInterface,\n+          report(JSError.make(sourceName, n,\n+          INTERFACE_METHOD_NOT_IMPLEMENTED,\n+          prop, implementedInterface.toString(), instance.toString())));\n     } else {\n       JSType found = instance.getPropertyType(prop);\n       JSType required\n       required = required.restrictByNotNullOrUndefined();\n       if (!found.canAssignTo(required)) {\n         // Implemented, but not correctly typed\n-        if (shouldReport) {\n-          FunctionType constructor\n-            = implementedInterface.toObjectType().getConstructor();\n-          compiler.report(t.makeError(n,\n-              HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop,\n-              constructor.getTopMostDefiningType(prop).toString(),\n-              required.toString(), found.toString()));\n-        }\n-        registerMismatch(found, required);\n+        FunctionType constructor\n+          = implementedInterface.toObjectType().getConstructor();\n+        registerMismatch(found, required, report(t.makeError(n,\n+            HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop,\n+            constructor.getTopMostDefiningType(prop).toString(),\n+            required.toString(), found.toString())));\n       }\n     }\n   }\n \n   private void mismatch(String sourceName, Node n,\n                         String msg, JSType found, JSType required) {\n-    registerMismatch(found, required);\n-    if (shouldReport) {\n-      compiler.report(\n-          JSError.make(sourceName, n, TYPE_MISMATCH_WARNING,\n-                       formatFoundRequired(msg, found, required)));\n-    }\n-  }\n-\n-  private void registerMismatch(JSType found, JSType required) {\n+    registerMismatch(found, required, report(\n+        JSError.make(sourceName, n, TYPE_MISMATCH_WARNING,\n+                     formatFoundRequired(msg, found, required))));\n+  }\n+\n+  private void registerMismatch(JSType found, JSType required, JSError error) {\n     // Don't register a mismatch for differences in null or undefined or if the\n     // code didn't downcast.\n     found = found.restrictByNotNullOrUndefined();\n       return;\n     }\n \n-    mismatches.add(new TypeMismatch(found, required));\n+    mismatches.add(new TypeMismatch(found, required, error));\n     if (found instanceof FunctionType &&\n         required instanceof FunctionType) {\n       FunctionType fnTypeA = ((FunctionType) found);\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n         registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType());\n-      }\n-\n-      registerIfMismatch(fnTypeA.getReturnType(), fnTypeB.getReturnType());\n-    }\n-  }\n-\n-  private void registerIfMismatch(JSType found, JSType required) {\n+            paramItB.next().getJSType(), error);\n+      }\n+\n+      registerIfMismatch(\n+        fnTypeA.getReturnType(), fnTypeB.getReturnType(), error);\n+    }\n+  }\n+\n+  private void registerIfMismatch(\n+      JSType found, JSType required, JSError error) {\n     if (found != null && required != null &&\n         !found.canAssignTo(required)) {\n-      registerMismatch(found, required);\n+      registerMismatch(found, required, error);\n     }\n   }\n \n     return typeRegistry.getNativeType(typeId);\n   }\n \n+  private JSError report(JSError error) {\n+    if (shouldReport) {\n+      compiler.report(error);\n+    }\n+    return recordErrors ? error : null;\n+  }\n+\n   /**\n    * Signals that the first type and the second type have been\n    * used interchangeably.\n   static class TypeMismatch {\n     final JSType typeA;\n     final JSType typeB;\n+    final JSError src;\n \n     /**\n      * It's the responsibility of the class that creates the\n      * {@code TypeMismatch} to ensure that {@code a} and {@code b} are\n      * non-matching types.\n      */\n-    TypeMismatch(JSType a, JSType b) {\n+    TypeMismatch(JSType a, JSType b, JSError src) {\n       this.typeA = a;\n       this.typeB = b;\n+      this.src = src;\n     }\n \n     @Override public boolean equals(Object object) {\n--- a/test/com/google/javascript/jscomp/TypeValidatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypeValidatorTest.java\n \n     assertMismatches(\n         Lists.newArrayList(\n-            new TypeMismatch(firstFunction, secondFunction),\n+            new TypeMismatch(firstFunction, secondFunction, null),\n             fromNatives(STRING_TYPE, BOOLEAN_TYPE),\n             fromNatives(NUMBER_TYPE, STRING_TYPE)));\n   }\n \n     assertMismatches(\n         Lists.newArrayList(\n-            new TypeMismatch(firstFunction, secondFunction),\n+            new TypeMismatch(firstFunction, secondFunction, null),\n             fromNatives(STRING_TYPE, BOOLEAN_TYPE)));\n   }\n \n   private TypeMismatch fromNatives(JSTypeNative a, JSTypeNative b) {\n     JSTypeRegistry registry = compiler.getTypeRegistry();\n     return new TypeMismatch(\n-        registry.getNativeType(a), registry.getNativeType(b));\n+        registry.getNativeType(a), registry.getNativeType(b), null);\n   }\n \n   private void assertMismatches(List<TypeMismatch> expected) {", "timestamp": 1312329690, "metainfo": ""}