{"sha": "dff730a3759cad9c491f72d9905eee93962d3d35", "log": "Break out basic function analysis into a separate pass, rather than trying to do it as we go. There should be no functional change, but this should make it a lot easier to move things around in the future.  R=acleung DELTA=332  (224 added, 89 deleted, 19 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3318   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.Scope.Var;\n   private final String sourceName;\n   private final Scope scope;\n \n+  private FunctionContents contents = UnknownFunctionContents.get();\n+\n   private JSType returnType = null;\n   private boolean returnTypeInferred = false;\n   private List<ObjectType> implementedInterfaces = null;\n   private boolean isConstructor = false;\n   private boolean isInterface = false;\n   private Node parametersNode = null;\n-  private Node sourceNode = null;\n   private String templateTypeName = null;\n \n   static final DiagnosticType EXTENDS_WITHOUT_TYPEDEF = DiagnosticType.warning(\n   }\n \n   /**\n-   * Sets the FUNCTION node of this function.\n-   */\n-  FunctionTypeBuilder setSourceNode(@Nullable Node sourceNode) {\n-    this.sourceNode = sourceNode;\n+   * Sets the contents of this function.\n+   */\n+  FunctionTypeBuilder setContents(@Nullable FunctionContents contents) {\n+    if (contents != null) {\n+      this.contents = contents;\n+    }\n     return this;\n   }\n \n   }\n \n   /**\n-   * If we haven't found a return value yet, try to look at the \"return\"\n-   * statements in the function.\n-   */\n-  FunctionTypeBuilder inferReturnStatementsAsLastResort(\n-      @Nullable Node functionBlock) {\n-    if (functionBlock == null || functionBlock.isFromExterns()) {\n-      return this;\n-    }\n-    Preconditions.checkArgument(functionBlock.getType() == Token.BLOCK);\n-    if (returnType == null) {\n-      boolean hasNonEmptyReturns = false;\n-      List<Node> worklist = Lists.newArrayList(functionBlock);\n-      while (!worklist.isEmpty()) {\n-        Node current = worklist.remove(worklist.size() - 1);\n-        int cType = current.getType();\n-        if (cType == Token.RETURN && current.getFirstChild() != null) {\n-          hasNonEmptyReturns = true;\n-          break;\n-        } else if (NodeUtil.isStatementBlock(current) ||\n-            NodeUtil.isControlStructure(current)) {\n-          for (Node child = current.getFirstChild();\n-               child != null; child = child.getNext()) {\n-            worklist.add(child);\n-          }\n-        }\n-      }\n-\n-      if (!hasNonEmptyReturns) {\n-        returnType = typeRegistry.getNativeType(VOID_TYPE);\n-        returnTypeInferred = true;\n-      }\n-    }\n-    return this;\n-  }\n-\n-  /**\n    * Infer the role of the function (whether it's a constructor or interface)\n    * and what it inherits from in JSDocInfo.\n    */\n    * Builds the function type, and puts it in the registry.\n    */\n   FunctionType buildAndRegister() {\n+    if (returnType == null &&\n+        !contents.mayHaveNonEmptyReturns() && !contents.mayBeFromExterns()) {\n+      returnType = typeRegistry.getNativeType(VOID_TYPE);\n+      returnTypeInferred = true;\n+    }\n+\n     if (returnType == null) {\n       returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n     }\n     if (isConstructor) {\n       fnType = getOrCreateConstructor();\n     } else if (isInterface) {\n-      fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n+      fnType = typeRegistry.createInterfaceType(\n+          fnName, contents.getSourceNode());\n       if (getScopeDeclaredIn().isGlobal() && !fnName.isEmpty()) {\n         typeRegistry.declareType(fnName, fnType.getInstanceType());\n       }\n     } else {\n       fnType = new FunctionBuilder(typeRegistry)\n           .withName(fnName)\n-          .withSourceNode(sourceNode)\n+          .withSourceNode(contents.getSourceNode())\n           .withParamsNode(parametersNode)\n           .withReturnType(returnType, returnTypeInferred)\n           .withTypeOfThis(thisType)\n    */\n   private FunctionType getOrCreateConstructor() {\n     FunctionType fnType = typeRegistry.createConstructorType(\n-        fnName, sourceNode, parametersNode, returnType);\n+        fnName, contents.getSourceNode(), parametersNode, returnType);\n     JSType existingType = typeRegistry.getType(fnName);\n \n     if (existingType != null) {\n             typeRegistry.getNativeFunctionType(FUNCTION_FUNCTION_TYPE);\n \n         if (existingFn.getSource() == null) {\n-          existingFn.setSource(sourceNode);\n+          existingFn.setSource(contents.getSourceNode());\n         }\n \n         if (!existingFn.hasEqualCallType(fnType)) {\n       return false;\n     }\n   }\n+\n+  /** Holds data dynamically inferred about functions. */\n+  static interface FunctionContents {\n+    /** Returns the source node of this function. May be null. */\n+    Node getSourceNode();\n+\n+    /** Returns if the function may be in externs. */\n+    boolean mayBeFromExterns();\n+\n+    /** Returns if a return of a real value (not undefined) appears. */\n+    boolean mayHaveNonEmptyReturns();\n+\n+    /** Gets a list of variables in this scope that are escaped. */\n+    Iterable<String> getEscapedVarNames();\n+  }\n+\n+  static class UnknownFunctionContents implements FunctionContents {\n+    private static UnknownFunctionContents singleton =\n+        new UnknownFunctionContents();\n+\n+    static FunctionContents get() {\n+      return singleton;\n+    }\n+\n+    @Override\n+    public Node getSourceNode() {\n+      return null;\n+    }\n+\n+    @Override\n+    public boolean mayBeFromExterns() {\n+      return true;\n+    }\n+\n+    @Override\n+    public boolean mayHaveNonEmptyReturns() {\n+      return true;\n+    }\n+\n+    @Override\n+    public Iterable<String> getEscapedVarNames() {\n+      return ImmutableList.of();\n+    }\n+  }\n+\n+  static class AstFunctionContents implements FunctionContents {\n+    private final Node n;\n+    private boolean hasNonEmptyReturns = false;\n+    private Set<String> escapedVarNames;\n+\n+    AstFunctionContents(Node n) {\n+      this.n = n;\n+    }\n+\n+    @Override\n+    public Node getSourceNode() {\n+      return n;\n+    }\n+\n+    @Override\n+    public boolean mayBeFromExterns() {\n+      return n.isFromExterns();\n+    }\n+\n+    @Override\n+    public boolean mayHaveNonEmptyReturns() {\n+      return hasNonEmptyReturns;\n+    }\n+\n+    void recordNonEmptyReturn() {\n+      hasNonEmptyReturns = true;\n+    }\n+\n+    @Override\n+    public Iterable<String> getEscapedVarNames() {\n+      return escapedVarNames == null\n+          ? ImmutableList.<String>of() : escapedVarNames;\n+    }\n+\n+    void recordEscapedVarName(String name) {\n+      if (escapedVarNames == null) {\n+        escapedVarNames = Sets.newHashSet();\n+      }\n+      escapedVarNames.add(name);\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/NodeTraversal.java\n+++ b/src/com/google/javascript/jscomp/NodeTraversal.java\n   }\n \n   /**\n+   * Abstract scoped callback to visit all nodes in post order.\n+   */\n+  public abstract static class AbstractScopedCallback\n+      implements ScopedCallback {\n+    @Override\n+    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n+        Node parent) {\n+      return true;\n+    }\n+\n+    @Override\n+    public void enterScope(NodeTraversal t) {}\n+\n+    @Override\n+    public void exitScope(NodeTraversal t) {}\n+  }\n+\n+  /**\n    * Abstract callback to visit all nodes but not traverse into function\n    * bodies.\n    */\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n     /** The enclosing scope */\n     final Scope scope;\n \n+    private boolean markedEscaped = false;\n+\n     /**\n      * Creates a variable.\n      *\n     @Override\n     public String toString() {\n       return \"Scope.Var \" + name + \"{\" + type + \"}\";\n+    }\n+\n+    /** Record that this is escaped by an inner scope. */\n+    void markEscaped() {\n+      markedEscaped = true;\n+    }\n+\n+    /**\n+     * Whether this is escaped by an inner scope.\n+     * Notice that not all scope creators record this information.\n+     */\n+    boolean isMarkedEscaped() {\n+      return markedEscaped;\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n \n import com.google.common.base.Preconditions;\n-import com.google.common.collect.HashMultimap;\n-import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n-import com.google.common.collect.Multimap;\n-import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.jstype.ObjectType;\n import com.google.javascript.rhino.jstype.StaticSlot;\n \n-import java.util.Collection;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n \n /**\n  * Type inference within a script node or a function body, using the data-flow\n   private final FlowScope bottomScope;\n   private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;\n \n-  /**\n-   * Local variables that do not belong to this scope, but are assigned\n-   * in this scope.\n-   */\n-  private final Multimap<Scope, Var> assignedOuterLocalVars =\n-      HashMultimap.create();\n-\n-  /**\n-   * Vars that we should not map out type flow for.\n-   */\n-  private final Set<String> unflowableVarNames = Sets.newHashSet();\n-\n   TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg,\n                 ReverseAbstractInterpreter reverseInterpreter,\n                 Scope functionScope,\n                 Map<String, AssertionFunctionSpec> assertionFunctionsMap) {\n-    this(compiler, cfg, reverseInterpreter, functionScope,\n-         assertionFunctionsMap, ImmutableSet.<Var>of());\n-  }\n-\n-  /**\n-   * @param unflowableVars Do not do infer flow on the types of these vars.\n-   * @param assertionFunctionsMap\n-   */\n-  // TODO(nicksantos): Create a builder for this class.\n-  TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg,\n-                ReverseAbstractInterpreter reverseInterpreter,\n-                Scope functionScope,\n-                Map<String, AssertionFunctionSpec> assertionFunctionsMap,\n-                Collection<Var> unflowableVars) {\n     super(cfg, new LinkedFlowScope.FlowScopeJoinOp());\n     this.compiler = compiler;\n     this.registry = compiler.getTypeRegistry();\n     this.functionScope = LinkedFlowScope.createEntryLattice(functionScope);\n     this.assertionFunctionsMap = assertionFunctionsMap;\n \n-    for (Var unflowableVar : unflowableVars) {\n-      String name = unflowableVar.getName();\n-      if (functionScope.getVar(name) == unflowableVar) {\n-        this.unflowableVarNames.add(name);\n-      }\n-    }\n-\n     // For each local variable declared with the VAR keyword, the entry\n     // type is VOID.\n     Iterator<Var> varIt =\n         functionScope.getDeclarativelyUnboundVarsWithoutTypes();\n     while (varIt.hasNext()) {\n       Var var = varIt.next();\n-      if (this.unflowableVarNames.contains(var.getName())) {\n+      if (isUnflowable(var)) {\n         continue;\n       }\n \n   @Override\n   FlowScope createEntryLattice() {\n     return functionScope;\n-  }\n-\n-  /**\n-   * @return Local variables assigned in this scope, but which are declared in\n-   *     a scope outside of it. Hashed by the scope they're declared in.\n-   */\n-  Multimap<Scope, Var> getAssignedOuterLocalVars() {\n-    return assignedOuterLocalVars;\n   }\n \n   @Override\n       case Token.NAME:\n         String varName = left.getString();\n         Var var = syntacticScope.getVar(varName);\n-        if (var != null && var.isLocal() && var.getScope() != syntacticScope) {\n-          assignedOuterLocalVars.put(var.getScope(), var);\n-        }\n \n         // When looking at VAR initializers for declared VARs, we trust\n         // the declared type over the type it's being initialized to.\n         // 1) The var is escaped in a weird way, e.g.,\n         // function f() { var x = 3; function g() { x = null } (x); }\n         boolean isInferred = var.isTypeInferred();\n-        boolean unflowable =\n-            isInferred && unflowableVarNames.contains(varName);\n+        boolean unflowable = isInferred &&\n+            isUnflowable(syntacticScope.getVar(varName));\n \n         // 2) We're reading type information from another scope for an\n         // inferred variable.\n     if (varType == null) {\n       varType = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n     }\n-    if (unflowableVarNames.contains(varName)) {\n+    if (isUnflowable(syntacticScope.getVar(varName))) {\n       return;\n     }\n     scope.inferSlotType(varName, varType);\n+  }\n+\n+  private static boolean isUnflowable(Var v) {\n+    return v != null && v.isLocal() && v.isMarkedEscaped();\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/TypeInferencePass.java\n+++ b/src/com/google/javascript/jscomp/TypeInferencePass.java\n     TypeInference typeInference =\n         new TypeInference(\n             compiler, computeCfg(n), reverseInterpreter, scope,\n-            assertionFunctionsMap, getUnflowableVars(scope));\n+            assertionFunctionsMap);\n     try {\n       typeInference.analyze();\n-      escapedLocalVars.putAll(typeInference.getAssignedOuterLocalVars());\n \n       // Resolve any new type names found during the inference.\n       compiler.getTypeRegistry().resolveTypesInScope(scope);\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.CodingConvention.DelegateRelationship;\n import com.google.javascript.jscomp.CodingConvention.ObjectLiteralCast;\n import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\n import com.google.javascript.jscomp.CodingConvention.SubclassType;\n+import com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractScopedCallback;\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowStatementCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.ErrorReporter;\n   private final Map<String, String> delegateCallingConventions =\n       Maps.newHashMap();\n \n+  // Simple properties inferred about functions.\n+  private final Map<Node, AstFunctionContents> functionAnalysisResults =\n+      Maps.newHashMap();\n+\n   /**\n    * Defer attachment of types to nodes until all type names\n    * have been resolved. Then, we can resolve the type and attach it.\n     Scope newScope = null;\n     AbstractScopeBuilder scopeBuilder = null;\n     if (parent == null) {\n+      // Run a first-order analysis over the syntax tree.\n+      (new FirstOrderFunctionAnalyzer(compiler, functionAnalysisResults))\n+          .process(root.getFirstChild(), root.getLastChild());\n+\n       // Find all the classes in the global scope.\n       newScope = createInitialScope(root);\n \n     Preconditions.checkState(scriptRoot.getType() == Token.SCRIPT);\n     Preconditions.checkNotNull(globalScope);\n     Preconditions.checkState(globalScope.isGlobal());\n+\n+    (new FirstOrderFunctionAnalyzer(\n+        compiler, functionAnalysisResults)).process(null, scriptRoot);\n \n     // TODO(bashir): Variable declaration is not the only side effect of last\n     // global scope generation but here we only wipe that part off!\n           FunctionTypeBuilder builder =\n               new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n                   scope)\n-              .setSourceNode(fnRoot)\n+              .setContents(getFunctionAnalysisResults(fnRoot))\n               .inferFromOverriddenFunction(overriddenPropType, parametersNode)\n               .inferTemplateTypeName(info)\n               .inferReturnType(info)\n \n           functionType = builder\n               .inferParameterTypes(parametersNode, info)\n-              .inferReturnStatementsAsLastResort(fnBlock)\n               .buildAndRegister();\n         }\n       }\n      */\n     void build() {\n       NodeTraversal.traverse(compiler, scope.getRootNode(), this);\n+\n+      AstFunctionContents contents =\n+          getFunctionAnalysisResults(scope.getRootNode());\n+      if (contents != null) {\n+        for (String varName : contents.getEscapedVarNames()) {\n+          Var v = scope.getVar(varName);\n+          Preconditions.checkState(v.getScope() == scope);\n+          v.markEscaped();\n+        }\n+      }\n     }\n \n     /**\n       }\n     } // end declareArguments\n   } // end LocalScopeBuilder\n+\n+  /**\n+   * Does a first-order function analysis that just looks at simple things\n+   * like what variables are escaped, and whether 'this' is used.\n+   */\n+  private static class FirstOrderFunctionAnalyzer\n+      extends AbstractScopedCallback implements CompilerPass {\n+    private final AbstractCompiler compiler;\n+    private final Map<Node, AstFunctionContents> data;\n+\n+    FirstOrderFunctionAnalyzer(\n+        AbstractCompiler compiler, Map<Node, AstFunctionContents> outParam) {\n+      this.compiler = compiler;\n+      this.data = outParam;\n+    }\n+\n+    @Override public void process(Node externs, Node root) {\n+      if (externs == null) {\n+        NodeTraversal.traverse(compiler, root, this);\n+      } else {\n+        NodeTraversal.traverseRoots(\n+            compiler, ImmutableList.of(externs, root), this);\n+      }\n+    }\n+\n+    @Override public void enterScope(NodeTraversal t) {\n+      if (!t.inGlobalScope()) {\n+        Node n = t.getScopeRoot();\n+        data.put(n, new AstFunctionContents(n));\n+      }\n+    }\n+\n+    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (t.inGlobalScope()) {\n+        return;\n+      }\n+\n+      if (n.getType() == Token.RETURN && n.getFirstChild() != null) {\n+        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n+      } else if (n.getType() == Token.NAME && NodeUtil.isLValue(n)) {\n+        String name = n.getString();\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(name);\n+        if (var != null) {\n+          Scope ownerScope = var.getScope();\n+          if (scope != ownerScope && ownerScope.isLocal()) {\n+            data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  private AstFunctionContents getFunctionAnalysisResults(@Nullable Node n) {\n+    if (n == null) {\n+      return null;\n+    }\n+\n+    // Sometimes this will return null in things like\n+    // NameReferenceGraphConstruction that build partial scopes.\n+    return functionAnalysisResults.get(n);\n+  }\n }\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n     // Don't do type inference on GETELEMs.\n     testClosureTypes(\n         CLOSURE_DEFS +\n-        \"function f(arguments) { \" +\n+        \"function f(x) { \" +\n         \"  return goog.isString(arguments[0]) ? arguments[0] : 0;\" +\n         \"}\", null);\n   }\n     // Don't do type inference on GETELEMs.\n     testClosureTypes(\n         CLOSURE_DEFS +\n-        \"function f(arguments) { \" +\n+        \"function f(x) { \" +\n         \"  return typeof arguments[0] == 'string' ? arguments[0] : 0;\" +\n         \"}\", null);\n   }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n     // Don't do type inference on GETELEMs.\n     testClosureTypes(\n         CLOSURE_DEFS +\n-        \"function f(arguments) { \" +\n+        \"function f(x) { \" +\n         \"  return goog.isString(arguments[0]) ? arguments[0] : 0;\" +\n         \"}\", null);\n   }\n     // Don't do type inference on GETELEMs.\n     testClosureTypes(\n         CLOSURE_DEFS +\n-        \"function f(arguments) { \" +\n+        \"function f(x) { \" +\n         \"  return typeof arguments[0] == 'string' ? arguments[0] : 0;\" +\n         \"}\", null);\n   }\n         registry)\n         .processForTesting(null, n);\n \n-    assertEquals(0, compiler.getErrorCount());\n+    assertEquals(\n+        \"unexpected error(s) : \" +\n+        Joiner.on(\", \").join(compiler.getErrors()),\n+        0, compiler.getErrorCount());\n \n     if (descriptions == null) {\n       assertEquals(", "timestamp": 1316650691, "metainfo": ""}