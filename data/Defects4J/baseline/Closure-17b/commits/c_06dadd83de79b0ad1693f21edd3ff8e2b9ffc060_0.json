{"sha": "06dadd83de79b0ad1693f21edd3ff8e2b9ffc060", "log": "Add methods for visualizing the module graph  R=acleung DELTA=229  (229 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1864   ", "commit": "\n--- a/src/com/google/javascript/jscomp/JSModuleGraph.java\n+++ b/src/com/google/javascript/jscomp/JSModuleGraph.java\n import com.google.javascript.jscomp.deps.SortedDependencies;\n import com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;\n import com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;\n+import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n \n import java.util.ArrayList;\n import java.util.Collection;\n     return result;\n   }\n \n+  LinkedDirectedGraph<JSModule, String> toGraphvizGraph() {\n+    LinkedDirectedGraph<JSModule, String> graphViz =\n+        LinkedDirectedGraph.create();\n+    for (JSModule module : getAllModulesInDependencyOrder()) {\n+      graphViz.createNode(module);\n+      for (JSModule dep : module.getDependencies()) {\n+        graphViz.createNode(dep);\n+        graphViz.connect(module, \"->\", dep);\n+      }\n+    }\n+    return graphViz;\n+  }\n+\n   /**\n    * A module depth comparator that considers a deeper module to be\n    * \"greater than\" a shallower module. Uses module names to\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/graph/GraphPruner.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.graph;\n+\n+import com.google.common.base.Predicate;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n+\n+/**\n+ * Prunes a graph, creating a new graph with nodes removed.\n+ *\n+ * If a node is removed from the graph, any paths through that node\n+ * will be replaced with edges. In other words, if A and B are nodes\n+ * in the original graph and the pruned graph, then there exists a path\n+ * from A -> B in the original graph iff there's a path from A -> B\n+ * in the pruned graph.\n+ *\n+ * We do not make any guarantees about what edges are in the pruned graph.\n+ *\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public class GraphPruner<N, E> {\n+  private final DiGraph<N, E> graph;\n+\n+  public GraphPruner(DiGraph<N, E> graph) {\n+    this.graph = graph;\n+  }\n+\n+  public LinkedDirectedGraph<N, E> prune(Predicate<N> keep) {\n+    LinkedDirectedGraph<N, E> workGraph = cloneGraph(graph);\n+\n+    // Create a work graph where all nodes with a path between them have\n+    // an edge.\n+    for (DiGraphNode<N, E> node : workGraph.getDirectedGraphNodes()) {\n+      for (DiGraphEdge<N, E> inEdge : node.getInEdges()) {\n+        for (DiGraphEdge<N, E> outEdge : node.getOutEdges()) {\n+          N source = inEdge.getSource().getValue();\n+          N dest = outEdge.getDestination().getValue();\n+          if (!workGraph.isConnectedInDirection(source, dest)) {\n+            workGraph.connect(source, outEdge.getValue(), dest);\n+          }\n+        }\n+      }\n+    }\n+\n+\n+    // Build a complete subgraph of workGraph.\n+    LinkedDirectedGraph<N, E> resultGraph =\n+        LinkedDirectedGraph.create();\n+    for (DiGraphNode<N, E> node : workGraph.getDirectedGraphNodes()) {\n+      if (keep.apply(node.getValue())) {\n+        resultGraph.createNode(node.getValue());\n+\n+        for (DiGraphEdge<N, E> outEdge : node.getOutEdges()) {\n+          N source = node.getValue();\n+          N dest = outEdge.getDestination().getValue();\n+          if (keep.apply(dest)) {\n+            resultGraph.createNode(dest);\n+            if (source != dest &&\n+                !resultGraph.isConnectedInDirection(source, dest)) {\n+              resultGraph.connect(source, outEdge.getValue(), dest);\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n+    return resultGraph;\n+  }\n+\n+  private static <N, E> LinkedDirectedGraph<N, E> cloneGraph(\n+      DiGraph<N, E> graph) {\n+    LinkedDirectedGraph<N, E> newGraph = LinkedDirectedGraph.create();\n+    for (DiGraphNode<N, E> node : graph.getDirectedGraphNodes()) {\n+      newGraph.createNode(node.getValue());\n+\n+      for (DiGraphEdge<N, E> outEdge : node.getOutEdges()) {\n+        N dest = outEdge.getDestination().getValue();\n+        newGraph.createNode(dest);\n+        newGraph.connect(node.getValue(), outEdge.getValue(), dest);\n+      }\n+    }\n+\n+    return newGraph;\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/graph/GraphPrunerTest.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.graph;\n+\n+import com.google.common.base.Predicates;\n+import com.google.common.collect.Lists;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public class GraphPrunerTest extends TestCase {\n+\n+  public void testThreeNodesConnected() {\n+    DiGraph<String, String> graph = LinkedDirectedGraph.create();\n+    graph.createNode(\"A\");\n+    graph.createNode(\"B\");\n+    graph.createNode(\"C\");\n+    graph.connect(\"A\", \"--\", \"B\");\n+    graph.connect(\"B\", \"--\", \"C\");\n+\n+    DiGraph<String, String> pruned =\n+        new GraphPruner<String, String>(graph).prune(\n+            Predicates.in(Lists.newArrayList(\"A\", \"C\")));\n+    assertEquals(2, pruned.getNodes().size());\n+    assertTrue(pruned.isConnectedInDirection(\"A\", \"C\"));\n+  }\n+\n+  public void testThreeNodesDisconnected() {\n+    DiGraph<String, String> graph = LinkedDirectedGraph.create();\n+    graph.createNode(\"A\");\n+    graph.createNode(\"B\");\n+    graph.createNode(\"C\");\n+    graph.connect(\"A\", \"--\", \"B\");\n+    graph.connect(\"C\", \"--\", \"B\");\n+\n+    DiGraph<String, String> pruned =\n+        new GraphPruner<String, String>(graph).prune(\n+            Predicates.in(Lists.newArrayList(\"A\", \"C\")));\n+    assertEquals(2, pruned.getNodes().size());\n+    assertFalse(pruned.isConnectedInDirection(\"A\", \"C\"));\n+  }\n+\n+  public void testFourNodesConnected1() {\n+    DiGraph<String, String> graph = LinkedDirectedGraph.create();\n+    graph.createNode(\"A\");\n+    graph.createNode(\"B\");\n+    graph.createNode(\"C\");\n+    graph.createNode(\"D\");\n+    graph.connect(\"A\", \"--\", \"C\");\n+    graph.connect(\"B\", \"--\", \"C\");\n+    graph.connect(\"C\", \"--\", \"D\");\n+    graph.connect(\"A\", \"--\", \"D\");\n+\n+    DiGraph<String, String> pruned =\n+        new GraphPruner<String, String>(graph).prune(\n+            Predicates.not(Predicates.equalTo(\"C\")));\n+    assertEquals(3, pruned.getNodes().size());\n+    assertTrue(pruned.isConnectedInDirection(\"A\", \"D\"));\n+    assertTrue(pruned.isConnectedInDirection(\"B\", \"D\"));\n+    assertFalse(pruned.isConnectedInDirection(\"A\", \"B\"));\n+  }\n+\n+  public void testFourNodesConnected2() {\n+    DiGraph<String, String> graph = LinkedDirectedGraph.create();\n+    graph.createNode(\"A\");\n+    graph.createNode(\"B\");\n+    graph.createNode(\"C\");\n+    graph.createNode(\"D\");\n+    graph.connect(\"A\", \"--\", \"B\");\n+    graph.connect(\"B\", \"--\", \"C\");\n+    graph.connect(\"C\", \"--\", \"D\");\n+\n+    DiGraph<String, String> pruned =\n+        new GraphPruner<String, String>(graph).prune(\n+            Predicates.not(Predicates.in(Lists.newArrayList(\"B\", \"C\"))));\n+    assertEquals(2, pruned.getNodes().size());\n+    assertTrue(pruned.isConnectedInDirection(\"A\", \"D\"));\n+  }\n+\n+  public void testFiveNodesConnected() {\n+    DiGraph<String, String> graph = LinkedDirectedGraph.create();\n+    graph.createNode(\"A\");\n+    graph.createNode(\"B\");\n+    graph.createNode(\"C\");\n+    graph.createNode(\"D\");\n+    graph.createNode(\"E\");\n+    graph.connect(\"A\", \"--\", \"B\");\n+    graph.connect(\"B\", \"--\", \"C\");\n+    graph.connect(\"C\", \"--\", \"D\");\n+    graph.connect(\"D\", \"--\", \"E\");\n+    graph.connect(\"D\", \"--\", \"B\");\n+\n+    DiGraph<String, String> pruned =\n+        new GraphPruner<String, String>(graph).prune(\n+            Predicates.not(Predicates.in(Lists.newArrayList(\"B\", \"C\", \"D\"))));\n+    assertEquals(2, pruned.getNodes().size());\n+    assertTrue(pruned.isConnectedInDirection(\"A\", \"E\"));\n+  }\n+}", "timestamp": 1305254562, "metainfo": ""}