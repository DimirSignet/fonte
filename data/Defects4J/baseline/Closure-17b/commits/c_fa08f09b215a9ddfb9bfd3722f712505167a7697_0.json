{"sha": "fa08f09b215a9ddfb9bfd3722f712505167a7697", "log": "Add first cleanup pass to JSCompiler for Hot Swap compilation cleanup.  R=nicksantos,acleung,bashir DELTA=139  (106 added, 0 deleted, 33 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2831   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n   }\n \n   @Override\n-  public void hotSwapScript(Node scriptRoot) {\n+  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n     NodeTraversal.traverse(compiler, scriptRoot, this);\n   }\n \n--- a/src/com/google/javascript/jscomp/CheckProvides.java\n+++ b/src/com/google/javascript/jscomp/CheckProvides.java\n \n   @Override\n   public void process(Node externs, Node root) {\n-    hotSwapScript(root);\n+    hotSwapScript(root, null);\n   }\n \n   @Override\n-  public void hotSwapScript(Node scriptRoot) {\n+  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n     CheckProvidesCallback callback =\n         new CheckProvidesCallback(codingConvention);\n     new NodeTraversal(compiler, callback).traverse(scriptRoot);\n--- a/src/com/google/javascript/jscomp/CheckRequiresForConstructors.java\n+++ b/src/com/google/javascript/jscomp/CheckRequiresForConstructors.java\n   }\n \n   @Override\n-  public void hotSwapScript(Node scriptRoot) {\n+  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n     Callback callback = new CheckRequiresForConstructorsCallback();\n     new NodeTraversal(compiler, callback).traverseWithScope(scriptRoot,\n         SyntacticScopeCreator.generateUntypedTopScope(compiler));\n--- a/src/com/google/javascript/jscomp/CombinedCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/CombinedCompilerPass.java\n   }\n \n   @Override\n-  public void hotSwapScript(Node scriptRoot) {\n+  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n     NodeTraversal.traverse(compiler, scriptRoot, this);\n   }\n \n--- a/src/com/google/javascript/jscomp/ControlStructureCheck.java\n+++ b/src/com/google/javascript/jscomp/ControlStructureCheck.java\n   }\n \n   @Override\n-  public void hotSwapScript(Node scriptRoot) {\n+  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n     check(scriptRoot);\n   }\n \n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n           exportedNames = pass.getExportedVariableNames();\n         }\n         @Override\n-        public void hotSwapScript(Node scriptRoot) {\n-          pass.hotSwapScript(scriptRoot);\n+        public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n+          pass.hotSwapScript(scriptRoot, originalRoot);\n         }\n       };\n     }\n           makeTypeInference(compiler).process(externs, root);\n         }\n         @Override\n-        public void hotSwapScript(Node scriptRoot) {\n+        public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n           makeTypeInference(compiler).inferTypes(scriptRoot);\n         }\n       };\n         makeInferJsDocInfo(compiler).process(externs, root);\n       }\n       @Override\n-      public void hotSwapScript(Node scriptRoot) {\n-        makeInferJsDocInfo(compiler).hotSwapScript(scriptRoot);\n+      public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n+        makeInferJsDocInfo(compiler).hotSwapScript(scriptRoot, originalRoot);\n       }\n     };\n   }\n           compiler.getErrorManager().setTypedPercent(check.getTypedPercent());\n         }\n         @Override\n-        public void hotSwapScript(Node scriptRoot) {\n+        public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n           makeTypeCheck(compiler).check(scriptRoot, false);\n         }\n       };\n       }\n     }\n     @Override\n-    public void hotSwapScript(Node scriptRoot) {\n+    public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n       patchGlobalTypedScope(compiler, scriptRoot);\n     }\n   }\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/FieldCleanupPass.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.rhino.Node;\n+\n+/**\n+ * A CleanupPass implementation that will remove all field declarations on\n+ * JSTypes contributed by the original file.\n+ * <p>\n+ * This pass is expected to clear out declarations contributed to any JSType,\n+ * even if the constructor declaration is not provided in the file being\n+ * updated.\n+ *\n+ * @author tylerg@google.com (Tyler Goodwin)\n+ */\n+public class FieldCleanupPass implements HotSwapCompilerPass {\n+\n+  @Override\n+  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    // FieldCleanupPass should not do work during process.\n+  }\n+\n+}\n--- a/src/com/google/javascript/jscomp/HotSwapCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/HotSwapCompilerPass.java\n \n /**\n  * Interface for compiler passes that can be used in a hot-swap fashion.\n- *\n- * <p>The additional method is {@code hotSwapScript} which runs this pass on\n- * a subtree of the AST. Each pass that is intended to support hot-swap\n- * style should implement this interface.\n- *\n- * <p>It is assumed that {@code Node} argument of {@code hotSwapScript} is the\n- * root of a sub-tree in AST that represents a js file and so is of type\n- * {@code Token.SCRIPT}.\n+ * <p>\n+ * The additional method is {@code hotSwapScript} which runs this pass on a\n+ * subtree of the AST. Each pass that is intended to support hot-swap style\n+ * should implement this interface.\n+ * <p>\n+ * It is assumed that {@code Node} argument of {@code hotSwapScript} is the root\n+ * of a sub-tree in AST that represents a js file and so is of type {@code\n+ * Token.SCRIPT}.\n  *\n  * @author bashir@google.com (Bashir Sadjad)\n  */\n   /**\n    * Process the JS with root node root. This is supposed to be significantly\n    * faster compared to corresponding full-compiler passes.\n+   *\n    * @param scriptRoot Root node corresponding to the file that is modified,\n-   *     should be of type {@code Token.SCRIPT}.\n+   *        should be of type {@code Token.SCRIPT}.\n+   * @param originalRoot Root node corresponding to the original version of the\n+   *        file that is modified. Should be of type {@code token.SCRIPT}.\n    */\n-  void hotSwapScript(Node scriptRoot);\n+  void hotSwapScript(Node scriptRoot, Node originalRoot);\n \n }\n--- a/src/com/google/javascript/jscomp/InferJSDocInfo.java\n+++ b/src/com/google/javascript/jscomp/InferJSDocInfo.java\n   }\n \n   @Override\n-  public void hotSwapScript(Node root) {\n+  public void hotSwapScript(Node root, Node originalRoot) {\n     Preconditions.checkNotNull(root);\n     Preconditions.checkState(root.getType() == Token.SCRIPT);\n     inExterns = false;\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n   }\n \n   @Override\n-  public void hotSwapScript(Node scriptRoot) {\n+  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n     // TODO(bashir): Implement a real hot-swap version instead and make it fully\n     // consistent with the full version.\n     this.compiler.process(this);\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n    * Same as process but only runs on a part of AST associated to one script.\n    */\n   @Override\n-  public void hotSwapScript(Node scriptRoot) {\n+  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n     NodeTraversal.traverse(compiler, scriptRoot, this);\n   }\n \n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n \n   @Override\n   public void process(Node externs, Node root) {\n-    hotSwapScript(root);\n+    hotSwapScript(root, null);\n   }\n \n   @Override\n-  public void hotSwapScript(Node root) {\n+  public void hotSwapScript(Node root, Node originalRoot) {\n     Traversal traversal = new Traversal();\n     NodeTraversal.traverse(compiler, root, traversal);\n \n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n   }\n \n   @Override\n-  public void hotSwapScript(Node scriptRoot) {\n+  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n     Preconditions.checkState(scriptRoot.getType() == Token.SCRIPT);\n     NodeTraversal t = new NodeTraversal(compiler, this);\n     // Note we use the global scope to prevent wrong \"undefined-var errors\" on\n--- a/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n+++ b/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n   }\n \n   @Override\n-  public void hotSwapScript(Node scriptRoot) {\n+  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n     ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n         compiler, new ReferenceCheckingBehavior());\n-    callback.hotSwapScript(scriptRoot);\n+    callback.hotSwapScript(scriptRoot, originalRoot);\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n    */\n   abstract boolean defineProperty(String propertyName, JSType type,\n       boolean inferred, Node propertyNode);\n+\n+  /**\n+   * Removes the declared or inferred property from this ObjectType.\n+   *\n+   * @param propertyName the property's name\n+   * @return true if the property was removed successfully. False if the\n+   *         property did not exist, or could not be removed.\n+   */\n+  boolean removeProperty(String propertyName) {\n+    return false;\n+  }\n \n   /**\n    * Gets the node corresponding to the definition of the specified property.", "timestamp": 1311956118, "metainfo": ""}