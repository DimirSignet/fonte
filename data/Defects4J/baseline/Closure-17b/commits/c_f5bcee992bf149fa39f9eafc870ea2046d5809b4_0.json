{"sha": "f5bcee992bf149fa39f9eafc870ea2046d5809b4", "log": "Rewrite how AnalyzePrototypeProperties reasons about contextual information. This fixes a lot of bugs in how local and captured variables are handled. Fixes issue 600.  R=johnlenz DELTA=344  (260 added, 15 deleted, 69 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3915   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n   }\n \n   private class ProcessProperties implements NodeTraversal.ScopedCallback {\n+    // There are two types of context information on this stack:\n+    // 1) Every scope has a NameContext corresponding to its scope.\n+    //    Variables are given VAR contexts.\n+    //    Prototype properties are given PROPERTY contexts.\n+    //    The global scope is given the special [global] context.\n+    //    And function expressions that we aren't able to give a reasonable\n+    //    name are given a special [anonymous] context.\n+    // 2) Every assignment of a prototype property of a non-function is\n+    //    given a name context. These contexts do not have scopes.\n     private Stack<NameContext> symbolStack = new Stack<NameContext>();\n \n-    private ProcessProperties() {\n-      symbolStack.push(new NameContext(globalNode));\n-    }\n-\n     @Override\n     public void enterScope(NodeTraversal t) {\n-      symbolStack.peek().scope = t.getScope();\n+      Node n = t.getCurrentNode();\n+      if (n.isFunction()) {\n+        String propName = getPrototypePropertyNameFromRValue(n);\n+        if (propName != null) {\n+          symbolStack.push(\n+              new NameContext(\n+                  getNameInfoForName(propName, PROPERTY),\n+                  t.getScope()));\n+        } else if (isGlobalFunctionDeclaration(t, n)) {\n+          Node parent = n.getParent();\n+          String name = parent.isName() ?\n+              parent.getString() /* VAR */ :\n+              n.getFirstChild().getString() /* named function */;\n+          symbolStack.push(\n+              new NameContext(getNameInfoForName(name, VAR), t.getScope()));\n+        } else {\n+          // NOTE(nicksantos): We use the same anonymous node for all\n+          // functions that do not have reasonable names. I can't remember\n+          // at the moment why we do this. I think it's because anonymous\n+          // nodes can never have in-edges. They're just there as a placeholder\n+          // for scope information, and do not matter in the edge propagation.\n+          symbolStack.push(new NameContext(anonymousNode, t.getScope()));\n+        }\n+      } else {\n+        Preconditions.checkState(t.inGlobalScope());\n+        symbolStack.push(new NameContext(globalNode, t.getScope()));\n+      }\n     }\n \n     @Override\n     public void exitScope(NodeTraversal t) {\n-\n+      symbolStack.pop();\n     }\n \n     @Override\n     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-      if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(\n-                n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-      } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ?\n-            parent.getString() /* VAR */ :\n-            n.getFirstChild().getString() /* named function */;\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-      } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+      // Process prototype assignments to non-functions.\n+      String propName = processNonFunctionPrototypeAssign(n, parent);\n+      if (propName != null) {\n+        symbolStack.push(\n+            new NameContext(\n+                getNameInfoForName(propName, PROPERTY), null));\n       }\n       return true;\n     }\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.isGetProp()) {\n         String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-          processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-          addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-          addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-      } else if (n.isObjectLit() &&\n-          // Make sure that we're not handling object literals being\n-          // assigned to a prototype, as in:\n-          // Foo.prototype = {bar: 3, baz: 5};\n-          !(parent.isAssign() &&\n-            parent.getFirstChild().isGetProp() &&\n-            parent.getFirstChild().getLastChild().getString().equals(\n-                \"prototype\"))) {\n+\n+        if (n.isQualifiedName()) {\n+          if (propName.equals(\"prototype\")) {\n+            if (processPrototypeRef(t, n)) {\n+              return;\n+            }\n+          } else if (compiler.getCodingConvention().isExported(propName)) {\n+            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n+            return;\n+          } else {\n+            // Do not mark prototype prop assigns as a 'use' in the global scope.\n+            if (n.getParent().isAssign() && n.getNext() != null) {\n+              String rValueName = getPrototypePropertyNameFromRValue(n);\n+              if (rValueName != null) {\n+                return;\n+              }\n+            }\n+          }\n+        }\n+\n+        addSymbolUse(propName, t.getModule(), PROPERTY);\n+      } else if (n.isObjectLit()) {\n+        // Make sure that we're not handling object literals being\n+        // assigned to a prototype, as in:\n+        // Foo.prototype = {bar: 3, baz: 5};\n+        String lValueName = NodeUtil.getBestLValueName(\n+            NodeUtil.getBestLValue(n));\n+        if (lValueName != null && lValueName.endsWith(\".prototype\")) {\n+          return;\n+        }\n+\n         // var x = {a: 1, b: 2}\n         // should count as a use of property a and b.\n         for (Node propNameNode = n.getFirstChild(); propNameNode != null;\n             if (var.getInitialValue() != null &&\n                 var.getInitialValue().isFunction()) {\n               if (t.inGlobalScope()) {\n-                if (!processGlobalFunctionDeclaration(t, n, parent,\n-                        parent.getParent())) {\n+                if (!processGlobalFunctionDeclaration(t, n, var)) {\n                   addGlobalUseOfSymbol(name, t.getModule(), VAR);\n                 }\n               } else {\n           } else if (var.getScope() != t.getScope()){\n             for (int i = symbolStack.size() - 1; i >= 0; i--) {\n               NameContext context = symbolStack.get(i);\n-              context.name.readClosureVariables = true;\n               if (context.scope == var.getScope()) {\n                 break;\n               }\n+\n+              context.name.readClosureVariables = true;\n             }\n           }\n         }\n       }\n \n-      if (isPrototypePropertyAssign(n) ||\n-          isGlobalFunctionDeclaration(t, n) ||\n-          n.isFunction()) {\n+      // Process prototype assignments to non-functions.\n+      if (processNonFunctionPrototypeAssign(n, parent) != null) {\n         symbolStack.pop();\n       }\n     }\n     }\n \n     /**\n+     * If this is a non-function prototype assign, return the prop name.\n+     * Otherwise, return null.\n+     */\n+    private String processNonFunctionPrototypeAssign(Node n, Node parent) {\n+      if (isAssignRValue(n, parent) && !n.isFunction()) {\n+        return getPrototypePropertyNameFromRValue(n);\n+      }\n+      return null;\n+    }\n+\n+    /**\n      * Determines whether {@code n} is the FUNCTION node in a global function\n      * declaration.\n      */\n     private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {\n-      return t.inGlobalScope() &&\n-          (NodeUtil.isFunctionDeclaration(n) ||\n-           n.isFunction() &&\n-           n.getParent().isName());\n-    }\n-\n-    private boolean isPrototypePropertyAssign(Node assign) {\n-      Node n = assign.getFirstChild();\n-      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n-          && n.isGetProp()\n-          && assign.getParent().isExprResult()) {\n-        // We want to exclude the assignment itself from the usage list\n-        boolean isChainedProperty =\n-            n.getFirstChild().isGetProp();\n-\n-        if (isChainedProperty) {\n-          Node child = n.getFirstChild().getFirstChild().getNext();\n-\n-          if (child.isString() &&\n-              child.getString().equals(\"prototype\")) {\n-            return true;\n-          }\n-        }\n-      }\n-\n-      return false;\n+      // Make sure we're either in the global scope, or the function\n+      // we're looking at is the root of the current local scope.\n+      Scope s = t.getScope();\n+      if (!(s.isGlobal() ||\n+            s.getDepth() == 1 && s.getRootNode() == n)) {\n+        return false;\n+      }\n+\n+      return NodeUtil.isFunctionDeclaration(n) ||\n+          n.isFunction() && n.getParent().isName();\n+    }\n+\n+    /**\n+     * Returns true if this is the r-value of an assignment.\n+     */\n+    private boolean isAssignRValue(Node n, Node parent) {\n+      return parent != null && parent.isAssign() && parent.getFirstChild() != n;\n+    }\n+\n+    /**\n+     * Returns the name of a prototype property being assigned to this r-value.\n+     *\n+     * Returns null if this is not the R-value of a prototype property, or if\n+     * the R-value is used in multiple expressions (i.e., if there's\n+     * a prototype property assignment in a more complex expression).\n+     */\n+    private String getPrototypePropertyNameFromRValue(Node rValue) {\n+      Node lValue = NodeUtil.getBestLValue(rValue);\n+      if (lValue == null ||\n+          lValue.getParent() == null ||\n+          lValue.getParent().getParent() == null ||\n+          !(NodeUtil.isObjectLitKey(lValue, lValue.getParent()) ||\n+            NodeUtil.isExprAssign(lValue.getParent().getParent()))) {\n+        return null;\n+      }\n+\n+      String lValueName =\n+          NodeUtil.getBestLValueName(NodeUtil.getBestLValue(rValue));\n+      if (lValueName == null) {\n+        return null;\n+      }\n+      int lastDot = lValueName.lastIndexOf('.');\n+      if (lastDot == -1) {\n+        return null;\n+      }\n+\n+      String firstPart = lValueName.substring(0, lastDot);\n+      if (!firstPart.endsWith(\".prototype\")) {\n+        return null;\n+      }\n+\n+      return lValueName.substring(lastDot + 1);\n     }\n \n     /**\n      * If it is, record it and return true. Otherwise, return false.\n      */\n     private boolean processGlobalFunctionDeclaration(NodeTraversal t,\n-        Node nameNode, Node parent, Node gramps) {\n+        Node nameNode, Var v) {\n       Node firstChild = nameNode.getFirstChild();\n+      Node parent = nameNode.getParent();\n \n       if (// Check for a named FUNCTION.\n           isGlobalFunctionDeclaration(t, parent) ||\n           isGlobalFunctionDeclaration(t, firstChild)) {\n         String name = nameNode.getString();\n         getNameInfoForName(name, VAR).getDeclarations().add(\n-            new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n+            new GlobalFunction(nameNode, v, t.getModule()));\n \n         // If the function name is exported, we should create an edge here\n         // so that it's never removed.\n     }\n \n     /**\n-     * Processes the parent of a GETPROP prototype, which can either be\n+     * Processes the GETPROP of prototype, which can either be under\n      * another GETPROP (in the case of Foo.prototype.bar), or can be\n-     * an assignment (in the case of Foo.prototype = ...).\n-     */\n-    private void processPrototypeParent(NodeTraversal t, Node n) {\n+     * under an assignment (in the case of Foo.prototype = ...).\n+     * @return True if a declaration was added.\n+     */\n+    private boolean processPrototypeRef(NodeTraversal t, Node ref) {\n+      Node root = NodeUtil.getRootOfQualifiedName(ref);\n+\n+      Node n = ref.getParent();\n       switch (n.getType()) {\n         // Foo.prototype.getBar = function() { ... }\n         case Token.GETPROP:\n               NodeUtil.isExprAssign(grandParent) &&\n               NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n             String name = dest.getString();\n-            Property prop = new AssignmentProperty(grandParent, t.getModule());\n+            Property prop = new AssignmentProperty(\n+                grandParent,\n+                t.getScope().getVar(root.getString()),\n+                t.getModule());\n             getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n+            return true;\n           }\n           break;\n \n               // May be STRING, GET, or SET,\n               String name = key.getString();\n               Property prop = new LiteralProperty(\n-                  key, key.getFirstChild(), map, n, t.getModule());\n+                  key, key.getFirstChild(), map, n,\n+                  t.getScope().getVar(root.getString()),\n+                  t.getModule());\n               getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n             }\n+            return true;\n           }\n           break;\n       }\n+      return false;\n     }\n \n     private void addGlobalUseOfSymbol(String name, JSModule module,\n     void remove();\n \n     /**\n+     * The variable for the root of this symbol.\n+     */\n+    Var getRootVar();\n+\n+    /**\n      * Returns the module where this appears.\n      */\n     JSModule getModule();\n   /**\n    * A function initialized as a VAR statement or a function declaration.\n    */\n-   class GlobalFunction implements Symbol {\n+  class GlobalFunction implements Symbol {\n     private final Node nameNode;\n+    private final Var var;\n     private final JSModule module;\n \n-    GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) {\n+    GlobalFunction(Node nameNode, Var var, JSModule module) {\n+      Node parent = nameNode.getParent();\n       Preconditions.checkState(\n           parent.isVar() ||\n           NodeUtil.isFunctionDeclaration(parent));\n       this.nameNode = nameNode;\n+      this.var = var;\n       this.module = module;\n+    }\n+\n+    @Override\n+    public Var getRootVar() {\n+      return var;\n     }\n \n     @Override\n    */\n   static class AssignmentProperty implements Property {\n     private final Node exprNode;\n+    private final Var rootVar;\n     private final JSModule module;\n \n     /**\n      * @param node An EXPR node.\n      */\n-    AssignmentProperty(Node node, JSModule module) {\n+    AssignmentProperty(Node node, Var rootVar, JSModule module) {\n       this.exprNode = node;\n+      this.rootVar = rootVar;\n       this.module = module;\n+    }\n+\n+    @Override\n+    public Var getRootVar() {\n+      return rootVar;\n     }\n \n     @Override\n     private final Node value;\n     private final Node map;\n     private final Node assign;\n+    private final Var rootVar;\n     private final JSModule module;\n \n     LiteralProperty(Node key, Node value, Node map, Node assign,\n-        JSModule module) {\n+        Var rootVar, JSModule module) {\n       this.key = key;\n       this.value = value;\n       this.map = map;\n       this.assign = assign;\n+      this.rootVar = rootVar;\n       this.module = module;\n+    }\n+\n+    @Override\n+    public Var getRootVar() {\n+      return rootVar;\n     }\n \n     @Override\n    */\n   private class NameContext {\n     final NameInfo name;\n-    Scope scope;\n-    NameContext(NameInfo name) {\n+\n+    // If this is a function context, then scope will be the scope of the\n+    // corresponding function. Otherwise, it will be null.\n+    final Scope scope;\n+\n+    NameContext(NameInfo name, Scope scope) {\n       this.name = name;\n+      this.scope = scope;\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n       }\n \n       JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n-      if(deepestCommonModuleRef == null) {\n+      if (deepestCommonModuleRef == null) {\n         compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n         continue;\n       }\n \n         // We should only move a property across modules if:\n         // 1) We can move it deeper in the module graph, and\n-        // 2) it's a function.\n-        // 3) it is not a get or a set.\n+        // 2) it's a function, and\n+        // 3) it is not a get or a set, and\n+        // 4) the class is available in the global scope.\n         //\n         // #1 should be obvious. #2 is more subtle. It's possible\n         // to copy off of a prototype, as in the code:\n         // So if we move a prototype method into a deeper module, we must\n         // replace it with a stub function so that it preserves its original\n         // behavior.\n+        if (!(prop.getRootVar() != null && prop.getRootVar().isGlobal())) {\n+          continue;\n+        }\n+\n         Node value = prop.getValue();\n         if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) &&\n             value.isFunction()) {\n                   .copyInformationFromForTree(value));\n \n           compiler.reportCodeChange();\n-          logger.fine(\"Moved method: \" +\n-              proto.getQualifiedName() + \".\" + nameInfo.name +\n-              \" from module \" + prop.getModule() + \" to module \" +\n-              deepestCommonModuleRef);\n         }\n       }\n     }\n--- a/test/com/google/javascript/jscomp/CrossModuleMethodMotionTest.java\n+++ b/test/com/google/javascript/jscomp/CrossModuleMethodMotionTest.java\n         });\n   }\n \n+  public void testIssue600() {\n+    testSame(\n+        createModuleChain(\n+            \"var jQuery1 = (function() {\\n\" +\n+            \"  var jQuery2 = function() {};\\n\" +\n+            \"  var theLoneliestNumber = 1;\\n\" +\n+            \"  jQuery2.prototype = {\\n\" +\n+            \"    size: function() {\\n\" +\n+            \"      return theLoneliestNumber;\\n\" +\n+            \"    }\\n\" +\n+            \"  };\\n\" +\n+            \"  return jQuery2;\\n\" +\n+            \"})();\\n\",\n+\n+            \"(function() {\" +\n+            \"  var div = jQuery1('div');\" +\n+            \"  div.size();\" +\n+            \"})();\"));\n+  }\n+\n+  public void testIssue600b() {\n+    testSame(\n+        createModuleChain(\n+            \"var jQuery1 = (function() {\\n\" +\n+            \"  var jQuery2 = function() {};\\n\" +\n+            \"  jQuery2.prototype = {\\n\" +\n+            \"    size: function() {\\n\" +\n+            \"      return 1;\\n\" +\n+            \"    }\\n\" +\n+            \"  };\\n\" +\n+            \"  return jQuery2;\\n\" +\n+            \"})();\\n\",\n+\n+            \"(function() {\" +\n+            \"  var div = jQuery1('div');\" +\n+            \"  div.size();\" +\n+            \"})();\"));\n+  }\n+\n+  public void testIssue600c() {\n+    test(\n+        createModuleChain(\n+            \"var jQuery2 = function() {};\\n\" +\n+            \"jQuery2.prototype = {\\n\" +\n+            \"  size: function() {\\n\" +\n+            \"    return 1;\\n\" +\n+            \"  }\\n\" +\n+            \"};\\n\",\n+\n+            \"(function() {\" +\n+            \"  var div = jQuery2('div');\" +\n+            \"  div.size();\" +\n+            \"})();\"),\n+        new String[] {\n+            STUB_DECLARATIONS +\n+            \"var jQuery2 = function() {};\\n\" +\n+            \"jQuery2.prototype = {\\n\" +\n+            \"  size: JSCompiler_stubMethod(0)\\n\" +\n+            \"};\\n\",\n+            \"jQuery2.prototype.size=\" +\n+            \"    JSCompiler_unstubMethod(0,function(){return 1});\" +\n+            \"(function() {\" +\n+            \"  var div = jQuery2('div');\" +\n+            \"  div.size();\" +\n+            \"})();\"\n+        });\n+  }\n+\n+  public void testIssue600d() {\n+    test(\n+        createModuleChain(\n+            \"var jQuery2 = function() {};\\n\" +\n+            \"(function() {\" +\n+            \"  jQuery2.prototype = {\\n\" +\n+            \"    size: function() {\\n\" +\n+            \"      return 1;\\n\" +\n+            \"    }\\n\" +\n+            \"  };\\n\" +\n+            \"})();\",\n+\n+            \"(function() {\" +\n+            \"  var div = jQuery2('div');\" +\n+            \"  div.size();\" +\n+            \"})();\"),\n+        new String[] {\n+            STUB_DECLARATIONS +\n+            \"var jQuery2 = function() {};\\n\" +\n+            \"(function() {\" +\n+            \"  jQuery2.prototype = {\\n\" +\n+            \"    size: JSCompiler_stubMethod(0)\\n\" +\n+            \"  };\\n\" +\n+            \"})();\",\n+            \"jQuery2.prototype.size=\" +\n+            \"    JSCompiler_unstubMethod(0,function(){return 1});\" +\n+            \"(function() {\" +\n+            \"  var div = jQuery2('div');\" +\n+            \"  div.size();\" +\n+            \"})();\"\n+        });\n+  }\n+\n+  public void testIssue600e() {\n+    testSame(\n+        createModuleChain(\n+            \"var jQuery2 = function() {};\\n\" +\n+            \"(function() {\" +\n+            \"  var theLoneliestNumber = 1;\\n\" +\n+            \"  jQuery2.prototype = {\\n\" +\n+            \"    size: function() {\\n\" +\n+            \"      return theLoneliestNumber;\\n\" +\n+            \"    }\\n\" +\n+            \"  };\\n\" +\n+            \"})();\",\n+\n+            \"(function() {\" +\n+            \"  var div = jQuery2('div');\" +\n+            \"  div.size();\" +\n+            \"})();\"));\n+  }\n+\n }", "timestamp": 1323198234, "metainfo": ""}