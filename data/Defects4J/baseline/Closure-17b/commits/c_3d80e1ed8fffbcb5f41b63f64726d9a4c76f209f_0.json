{"sha": "3d80e1ed8fffbcb5f41b63f64726d9a4c76f209f", "log": "Inline NodeUtil.isXXX functions and call the Node.isXXX functions directly.  R=nicksantos   Revision created by MOE tool push_codebase. MOE_MIGRATION=3673   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n             parent.getString() /* VAR */ :\n             n.getFirstChild().getString() /* named function */;\n         symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-      } else if (NodeUtil.isFunction(n)) {\n+      } else if (n.isFunction()) {\n         symbolStack.push(new NameContext(anonymousNode));\n       }\n       return true;\n \n       if (isPrototypePropertyAssign(n) ||\n           isGlobalFunctionDeclaration(t, n) ||\n-          NodeUtil.isFunction(n)) {\n+          n.isFunction()) {\n         symbolStack.pop();\n       }\n     }\n     public Node getFunctionNode() {\n       Node parent = nameNode.getParent();\n \n-      if (NodeUtil.isFunction(parent)) {\n+      if (parent.isFunction()) {\n         return parent;\n       } else {\n         // we are the name of a var node, so the function is name's second child\n--- a/src/com/google/javascript/jscomp/AstParallelizer.java\n+++ b/src/com/google/javascript/jscomp/AstParallelizer.java\n     Predicate<Node> shouldSplit = new Predicate<Node>() {\n       @Override\n       public boolean apply(Node input) {\n-        return NodeUtil.isFunction(input);\n+        return input.isFunction();\n       }\n     };\n \n--- a/src/com/google/javascript/jscomp/CallGraph.java\n+++ b/src/com/google/javascript/jscomp/CallGraph.java\n    * AST Token.FUNCTION node, or null if no such object exists.\n    */\n   public Function getFunctionForAstNode(Node functionNode) {\n-    Preconditions.checkArgument(NodeUtil.isFunction(functionNode));\n+    Preconditions.checkArgument(functionNode.isFunction());\n \n     return functionsByNode.get(functionNode);\n   }\n \n           connectCallsiteToTargets(callsite, provider);\n \n-        } else if (NodeUtil.isFunction(n)) {\n+        } else if (n.isFunction()) {\n           if (!functionsByNode.containsKey(n)) {\n             createFunction(n);\n           }\n         } else {\n           Node target = definition.getRValue();\n \n-          if (target != null && NodeUtil.isFunction(target)) {\n+          if (target != null && target.isFunction()) {\n             Function targetFunction = functionsByNode.get(target);\n \n             if (targetFunction == null) {\n       // GET{PROP,ELEM} don't count as aliases\n       // but we have to check for using them in .call and .apply.\n \n-      if (NodeUtil.isGetProp(useParent)) {\n+      if (useParent.isGetProp()) {\n         Node gramps = useParent.getParent();\n         if (NodeUtil.isFunctionObjectApply(gramps) ||\n             NodeUtil.isFunctionObjectCall(gramps)) {\n     if (definition != null && !definition.isExtern()) {\n       Node rValue = definition.getRValue();\n \n-      if (rValue != null && NodeUtil.isFunction(rValue)) {\n+      if (rValue != null && rValue.isFunction()) {\n         Function function = functionsByNode.get(rValue);\n         Preconditions.checkNotNull(function);\n \n     // NameReferenceGraph throws an exception unless the node is\n     // a GETPROP or a NAME\n     if (!useNameReferenceGraph\n-        || (NodeUtil.isGetProp(targetExpression)\n-        ||  NodeUtil.isName(targetExpression))) {\n+        || (targetExpression.isGetProp()\n+        ||  targetExpression.isName())) {\n \n       Collection<Definition> definitions =\n         definitionProvider.getDefinitionsReferencedAt(targetExpression);\n--- a/src/com/google/javascript/jscomp/CheckPropertyOrder.java\n+++ b/src/com/google/javascript/jscomp/CheckPropertyOrder.java\n     // qualified names.\n     Node func = null;\n     String funcName = null;\n-    if (NodeUtil.isFunction(n) && isConstructor(n)) {\n+    if (n.isFunction() && isConstructor(n)) {\n       func = n;\n       funcName = n.getFirstChild().getString();\n-    } else if (NodeUtil.isAssign(n)\n-               && NodeUtil.isFunction(n.getFirstChild().getNext())\n+    } else if (n.isAssign()\n+               && n.getFirstChild().getNext().isFunction()\n                && isConstructor(n)) {\n       func = n.getFirstChild().getNext();\n       funcName = n.getFirstChild().getQualifiedName();\n   @SuppressWarnings(\"unchecked\")\n   private void checkConstructor(Node func, ObjectType objType,\n                                 String sourceName, String funcName) {\n-    Preconditions.checkArgument(NodeUtil.isFunction(func));\n+    Preconditions.checkArgument(func.isFunction());\n \n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false);\n     cfa.process(null, func.getFirstChild().getNext().getNext());\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n \n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (colorings.isEmpty() || !NodeUtil.isName(n) ||\n-        NodeUtil.isFunction(parent)) {\n+    if (colorings.isEmpty() || !n.isName() ||\n+        parent.isFunction()) {\n       // Don't rename named functions.\n       return;\n     }\n       n.setString(coalescedVar.name);\n       compiler.reportCodeChange();\n \n-      if (NodeUtil.isVar(parent)) {\n+      if (parent.isVar()) {\n         removeVarDeclaration(n);\n       }\n     } else {\n       n.setString(pseudoName);\n       compiler.reportCodeChange();\n \n-      if (!vNode.getValue().equals(coalescedVar) && NodeUtil.isVar(parent)) {\n+      if (!vNode.getValue().equals(coalescedVar) && parent.isVar()) {\n         removeVarDeclaration(n);\n       }\n     }\n         // and unzipped size increase after this. We are not totally sure why\n         // that is but, for now, we will respect the dead functions and not play\n         // around with it.\n-        if (!NodeUtil.isFunction(v.getParentNode())) {\n+        if (!v.getParentNode().isFunction()) {\n           interferenceGraph.createNode(v);\n         }\n       }\n      * @return Whether any LiveRangeChecker would be interested in the node.\n      */\n     public static boolean shouldVisit(Node n) {\n-      return (NodeUtil.isName(n)\n-        || (n.hasChildren() && NodeUtil.isName(n.getFirstChild())));\n+      return (n.isName()\n+        || (n.hasChildren() && n.getFirstChild().isName()));\n     }\n \n     @Override\n     }\n \n     private static boolean isAssignTo(Var var, Node n, Node parent) {\n-      if (NodeUtil.isName(n) && var.getName().equals(n.getString()) &&\n+      if (n.isName() && var.getName().equals(n.getString()) &&\n           parent != null) {\n         if (parent.getType() == Token.LP) {\n           // In a function declaration, the formal parameters are assigned.\n           return true;\n-        } else if (NodeUtil.isVar(parent)) {\n+        } else if (parent.isVar()) {\n           // If this is a VAR declaration, if the name node has a child, we are\n           // assigning to that name.\n           return n.hasChildren();\n       } else {\n         // Lastly, any assignmentOP is also an assign.\n         Node name = n.getFirstChild();\n-        return name != null && NodeUtil.isName(name) &&\n+        return name != null && name.isName() &&\n           var.getName().equals(name.getString()) &&\n           NodeUtil.isAssignmentOp(n);\n       }\n     }\n \n     private static boolean isReadFrom(Var var, Node name) {\n-      return name != null && NodeUtil.isName(name) &&\n+      return name != null && name.isName() &&\n           var.getName().equals(name.getString()) &&\n           !NodeUtil.isVarOrSimpleAssignLhs(name, name.getParent());\n     }\n--- a/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n+++ b/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n       while (n != null &&\n           (n.getType() == Token.VAR || canBeRedeclared(n, t.getScope()))) {\n \n-        if (NodeUtil.isVar(n)) {\n+        if (n.isVar()) {\n           blacklistStubVars(t, n);\n           hasVar = true;\n         }\n       Node assign = n.getFirstChild();\n       Node lhs = assign.getFirstChild();\n \n-      if (!NodeUtil.isName(lhs)) {\n+      if (!lhs.isName()) {\n         return false;\n       }\n \n         Preconditions.checkState(var.getNext() == n);\n         collapse.parent.removeChildAfter(var);\n \n-        if (NodeUtil.isVar(n)) {\n+        if (n.isVar()) {\n           while(n.hasChildren()) {\n             var.addChildToBack(n.removeFirstChild());\n           }\n         } else {\n           Node assign = n.getFirstChild();\n           Node lhs = assign.getFirstChild();\n-          Preconditions.checkState(NodeUtil.isName(lhs));\n+          Preconditions.checkState(lhs.isName());\n           Node rhs = assign.getLastChild();\n           lhs.addChildToBack(rhs.detachFromParent());\n           var.addChildToBack(lhs.detachFromParent());\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n     Node lastJump = null;\n     for (Iterator<Node> iter = exceptionHandler.iterator(); iter.hasNext();) {\n       Node curHandler = iter.next();\n-      if (NodeUtil.isFunction(curHandler)) {\n+      if (curHandler.isFunction()) {\n         break;\n       }\n       if (NodeUtil.hasFinally(curHandler)) {\n     if (mayThrowException(target) && !exceptionHandler.isEmpty()) {\n       Node lastJump = cfgNode;\n       for (Node handler : exceptionHandler) {\n-        if (NodeUtil.isFunction(handler)) {\n+        if (handler.isFunction()) {\n           return;\n         }\n         Preconditions.checkState(handler.getType() == Token.TRY);\n--- a/src/com/google/javascript/jscomp/DataFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/DataFlowAnalysis.java\n     AbstractPostOrderCallback finder = new AbstractPostOrderCallback() {\n       @Override\n       public void visit(NodeTraversal t, Node n, Node parent) {\n-        if (jsScope == t.getScope() || !NodeUtil.isName(n)\n-            || NodeUtil.isFunction(parent)) {\n+        if (jsScope == t.getScope() || !n.isName()\n+            || parent.isFunction()) {\n           return;\n         }\n         String name = n.getString();\n--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n       }\n \n       Scope scope = t.getScope();\n-      if (!NodeUtil.isName(lhs)) {\n+      if (!lhs.isName()) {\n         return; // Not a local variable assignment.\n       }\n       String name = lhs.getString();\n       // regardless of what the liveness results because it\n       // does not change the result afterward.\n       if (rhs != null &&\n-          NodeUtil.isName(rhs) &&\n+          rhs.isName() &&\n           rhs.getString().equals(var.name) &&\n-          NodeUtil.isAssign(n)) {\n+          n.isAssign()) {\n         n.removeChild(rhs);\n         n.getParent().replaceChild(n, rhs);\n         compiler.reportCodeChange();\n         return;\n       }\n \n-      if (NodeUtil.isAssign(n)) {\n+      if (n.isAssign()) {\n         n.removeChild(rhs);\n         n.getParent().replaceChild(n, rhs);\n       } else if (NodeUtil.isAssignmentOp(n)) {\n       return VariableLiveness.MAYBE_LIVE;\n     }\n \n-    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n+    if (n.isName() && variable.equals(n.getString())) {\n       if (NodeUtil.isVarOrSimpleAssignLhs(n, n.getParent())) {\n         Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n         // The expression to which the assignment is made is evaluated before\n--- a/src/com/google/javascript/jscomp/DefinitionsRemover.java\n+++ b/src/com/google/javascript/jscomp/DefinitionsRemover.java\n \n     if (NodeUtil.isVarDeclaration(n) && n.hasChildren()) {\n       return new VarDefinition(n, isExtern);\n-    } else if (NodeUtil.isFunction(parent) && parent.getFirstChild() == n) {\n+    } else if (parent.isFunction() && parent.getFirstChild() == n) {\n       if (!NodeUtil.isFunctionExpression(parent)) {\n         return new NamedFunctionDefinition(parent, isExtern);\n       } else if (!n.getString().equals(\"\")) {\n         return new FunctionExpressionDefinition(parent, isExtern);\n       }\n-    } else if (NodeUtil.isAssign(parent) && parent.getFirstChild() == n) {\n+    } else if (parent.isAssign() && parent.getFirstChild() == n) {\n       return new AssignmentDefinition(parent, isExtern);\n     } else if (NodeUtil.isObjectLitKey(n, parent)) {\n       return new ObjectLiteralPropertyDefinition(parent, n, n.getFirstChild(),\n \n     if (NodeUtil.isVarDeclaration(n) && n.hasChildren()) {\n       return true;\n-    } else if (NodeUtil.isFunction(parent) && parent.getFirstChild() == n) {\n+    } else if (parent.isFunction() && parent.getFirstChild() == n) {\n       if (!NodeUtil.isFunctionExpression(parent)) {\n         return true;\n       } else if (!n.getString().equals(\"\")) {\n         return true;\n       }\n-    } else if (NodeUtil.isAssign(parent) && parent.getFirstChild() == n) {\n+    } else if (parent.isAssign() && parent.getFirstChild() == n) {\n       return true;\n     } else if (NodeUtil.isObjectLitKey(n, parent)) {\n       return true;\n         Node argumentName,\n         boolean inExterns) {\n       super(argumentName, inExterns);\n-      Preconditions.checkArgument(NodeUtil.isFunction(function));\n-      Preconditions.checkArgument(NodeUtil.isName(argumentName));\n+      Preconditions.checkArgument(function.isFunction());\n+      Preconditions.checkArgument(argumentName.isName());\n     }\n \n     @Override\n \n     FunctionDefinition(Node node, boolean inExterns) {\n       super(inExterns);\n-      Preconditions.checkArgument(NodeUtil.isFunction(node));\n+      Preconditions.checkArgument(node.isFunction());\n       function = node;\n     }\n \n \n     AssignmentDefinition(Node node, boolean inExterns) {\n       super(inExterns);\n-      Preconditions.checkArgument(NodeUtil.isAssign(node));\n+      Preconditions.checkArgument(node.isAssign());\n       assignment = node;\n     }\n \n--- a/src/com/google/javascript/jscomp/Denormalize.java\n+++ b/src/com/google/javascript/jscomp/Denormalize.java\n     }\n \n     // Is the current node something that can be in a for loop initializer?\n-    if (!NodeUtil.isExpressionNode(n) && !NodeUtil.isVar(n)) {\n+    if (!NodeUtil.isExpressionNode(n) && !n.isVar()) {\n       return;\n     }\n \n     } else if (NodeUtil.isForIn(nextSibling)) {\n       Node forNode = nextSibling;\n       Node forVar = forNode.getFirstChild();\n-      if (NodeUtil.isName(forVar)\n-          && NodeUtil.isVar(n) && n.hasOneChild()) {\n+      if (forVar.isName()\n+          && n.isVar() && n.hasOneChild()) {\n         Node name = n.getFirstChild();\n         if (!name.hasChildren()\n             && forVar.getString().equals(name.getString())) {\n       parent.removeChild(n);\n \n       Node newInitializer;\n-      if (NodeUtil.isVar(n)) {\n+      if (n.isVar()) {\n         newInitializer = n;\n       } else {\n         // Extract the expression from EXPR_RESULT node.\n--- a/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n+++ b/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n   private static boolean isCall(UseSite site) {\n     Node node = site.node;\n     Node parent = node.getParent();\n-    return (parent.getFirstChild() == node) && NodeUtil.isCall(parent);\n+    return (parent.getFirstChild() == node) && parent.isCall();\n   }\n \n   /**\n     }\n \n     Node functionNode = parent.getLastChild();\n-    if ((functionNode == null) || !NodeUtil.isFunction(functionNode)) {\n-      return false;\n-    }\n-\n-    if (!NodeUtil.isGetProp(node)) {\n+    if ((functionNode == null) || !functionNode.isFunction()) {\n+      return false;\n+    }\n+\n+    if (!node.isGetProp()) {\n       return false;\n     }\n \n     Node nameNode = node.getFirstChild();\n-    return NodeUtil.isGetProp(nameNode) &&\n+    return nameNode.isGetProp() &&\n         nameNode.getLastChild().getString().equals(\"prototype\");\n \n   }\n     // rewrite changes the structure of this object.\n     Node rValue = definition.getRValue();\n     if (rValue == null ||\n-        !NodeUtil.isFunction(rValue) ||\n+        !rValue.isFunction() ||\n         NodeUtil.isVarArgsFunction(rValue)) {\n       return false;\n     }\n     // Exporting a method prevents rewrite.\n     Node lValue = definition.getLValue();\n     if ((lValue == null) ||\n-        !NodeUtil.isGetProp(lValue)) {\n+        !lValue.isGetProp()) {\n       return false;\n     }\n     CodingConvention codingConvention = compiler.getCodingConvention();\n    * traverse function boundaries.\n    */\n   private void replaceReferencesToThis(Node node, String name) {\n-    if (NodeUtil.isFunction(node)) {\n+    if (node.isFunction()) {\n       return;\n     }\n \n     for (Node child : node.children()) {\n-      if (NodeUtil.isThis(child)) {\n+      if (child.isThis()) {\n         Node newName = Node.newString(Token.NAME, name);\n         newName.setJSType(child.getJSType());\n         node.replaceChild(child, newName);\n--- a/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n+++ b/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n \n   private boolean isConstantName(Node n, Set<String> knownConstants) {\n     // Non-constant names values may have been changed.\n-    return NodeUtil.isName(n) && (NodeUtil.isConstantName(n)\n+    return n.isName() && (NodeUtil.isConstantName(n)\n         || knownConstants.contains(n.getString()));\n   }\n \n     Node parent = expr.getParent();\n \n     boolean isLhsOfAssignOp = NodeUtil.isAssignmentOp(parent)\n-        && !NodeUtil.isAssign(parent)\n+        && !parent.isAssign()\n         && parent.getFirstChild() == expr;\n \n     Node firstExtractedNode = null;\n     // If it is ASSIGN_XXX, keep the assignment in place and extract the\n     // original value of the LHS operand.\n     if (isLhsOfAssignOp) {\n-      Preconditions.checkState(NodeUtil.isName(expr) || NodeUtil.isGet(expr));\n+      Preconditions.checkState(expr.isName() || NodeUtil.isGet(expr));\n       // Transform \"x += 2\" into \"x = temp + 2\"\n       Node opNode = new Node(NodeUtil.getOpFromAssignmentOp(parent))\n           .copyInformationFrom(parent);\n--- a/src/com/google/javascript/jscomp/ExternExportsPass.java\n+++ b/src/com/google/javascript/jscomp/ExternExportsPass.java\n      * or return type is unknown.\n      */\n     private void checkForFunctionsWithUnknownTypes(Node function) {\n-      Preconditions.checkArgument(NodeUtil.isFunction(function));\n+      Preconditions.checkArgument(function.isFunction());\n \n       FunctionType functionType =\n           JSType.toMaybeFunctionType(function.getJSType());\n--- a/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n+++ b/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n         // the control flow. In fact, they are lifted to the beginning of the\n         // block. This happens a lot when devirtualization breaks the whole\n         // chain.\n-        if (NodeUtil.isFunction(cur)) {\n+        if (cur.isFunction()) {\n           continue;\n         }\n \n--- a/src/com/google/javascript/jscomp/FieldCleanupPass.java\n+++ b/src/com/google/javascript/jscomp/FieldCleanupPass.java\n     @Override\n     public void visit(NodeTraversal t, Node n, Node p) {\n       // We are a root GetProp\n-      if (NodeUtil.isGetProp(n) && !NodeUtil.isGetProp(p)) {\n+      if (n.isGetProp() && !p.isGetProp()) {\n         String propName = getFieldName(n);\n         JSType type = n.getFirstChild().getJSType();\n         if (type == null || type.toObjectType() == null) {\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n         // TODO(user): We only care about calls to functions that\n         // passes one of the dependent variable to a non-sideeffect free\n         // function.\n-        if (NodeUtil.isCall(n) && NodeUtil.functionCallHasSideEffects(n)) {\n+        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n           return true;\n         }\n \n-        if (NodeUtil.isNew(n) && NodeUtil.constructorCallHasSideEffects(n)) {\n+        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n           return true;\n         }\n \n     // Compute the forward reaching definition.\n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n     // Process the body of the function.\n-    Preconditions.checkState(NodeUtil.isFunction(t.getScopeRoot()));\n+    Preconditions.checkState(t.getScopeRoot().isFunction());\n     cfa.process(null, t.getScopeRoot().getLastChild());\n     cfg = cfa.getCfg();\n     reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (NodeUtil.isName(n)) {\n+          if (n.isName()) {\n \n             // Make sure that the name node is purely a read.\n             if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n-                || NodeUtil.isVar(parent) || parent.getType() == Token.INC ||\n+                || parent.isVar() || parent.getType() == Token.INC ||\n                 parent.getType() == Token.DEC || parent.getType() == Token.LP ||\n                 parent.getType() == Token.CATCH) {\n               return;\n     private int numUseWithinUseCfgNode;\n \n     Candidate(String varName, Node defCfgNode, Node use, Node useCfgNode) {\n-      Preconditions.checkArgument(NodeUtil.isName(use));\n+      Preconditions.checkArgument(use.isName());\n       this.varName = varName;\n       this.defCfgNode = defCfgNode;\n       this.use = use;\n     private boolean canInline() {\n \n       // Cannot inline a parameter.\n-      if (NodeUtil.isFunction(defCfgNode)) {\n+      if (defCfgNode.isFunction()) {\n         return false;\n       }\n \n \n       // Check that the assignment isn't used as a R-Value.\n       // TODO(user): Certain cases we can still inline.\n-      if (NodeUtil.isAssign(def) && !NodeUtil.isExprAssign(def.getParent())) {\n+      if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n         return false;\n       }\n \n               @Override\n               public boolean apply(Node input) {\n                 // Recurse if the node is not a function.\n-                return !NodeUtil.isFunction(input);\n+                return !input.isFunction();\n               }\n           })) {\n         return false;\n     private void inlineVariable() {\n       Node defParent = def.getParent();\n       Node useParent = use.getParent();\n-      if (NodeUtil.isAssign(def)) {\n+      if (def.isAssign()) {\n         Node rhs = def.getLastChild();\n         rhs.detachFromParent();\n         // Oh yes! I have grandparent to remove this.\n         }\n         defParent.detachFromParent();\n         useParent.replaceChild(use, rhs);\n-      } else if (NodeUtil.isVar(defParent)) {\n+      } else if (defParent.isVar()) {\n         Node rhs = def.getLastChild();\n         def.removeChild(rhs);\n         useParent.replaceChild(use, rhs);\n \n             case Token.ASSIGN:\n               Node lhs = n.getFirstChild();\n-              if (NodeUtil.isName(lhs) && lhs.getString().equals(varName)) {\n+              if (lhs.isName() && lhs.getString().equals(varName)) {\n                 def = n;\n               }\n               return;\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (NodeUtil.isName(n) && n.getString().equals(varName) &&\n+          if (n.isName() && n.getString().equals(varName) &&\n               // do not count in if it is left child of an assignment operator\n-              !(NodeUtil.isAssign(parent) &&\n+              !(parent.isAssign() &&\n                (parent.getFirstChild() == n))) {\n             numUseWithinUseCfgNode++;\n           }\n--- a/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n      * @return Whether node is a reference to locally declared name.\n      */\n     private boolean isLocalName(Node node) {\n-      if (NodeUtil.isName(node)) {\n+      if (node.isName()) {\n         String name = node.getString();\n         return locals.contains(name);\n       }\n--- a/src/com/google/javascript/jscomp/FunctionRewriter.java\n+++ b/src/com/google/javascript/jscomp/FunctionRewriter.java\n \n       Node value = maybeGetSingleReturnRValue(functionNode);\n       if (value != null &&\n-          NodeUtil.isName(value) &&\n+          value.isName() &&\n           value.getString().equals(paramNode.getString())) {\n         return true;\n       }\n     private Node getGetPropertyName(Node functionNode) {\n       Node value = maybeGetSingleReturnRValue(functionNode);\n       if (value != null &&\n-          NodeUtil.isGetProp(value) &&\n-          NodeUtil.isThis(value.getFirstChild())) {\n+          value.isGetProp() &&\n+          value.getFirstChild().isThis()) {\n         return value.getLastChild();\n       }\n       return null;\n \n       Node assign = statement.getFirstChild();\n       Node lhs = assign.getFirstChild();\n-      if (NodeUtil.isGetProp(lhs) && NodeUtil.isThis(lhs.getFirstChild())) {\n+      if (lhs.isGetProp() && lhs.getFirstChild().isThis()) {\n         Node rhs = assign.getLastChild();\n-        if (NodeUtil.isName(rhs) &&\n+        if (rhs.isName() &&\n             rhs.getString().equals(paramNode.getString())) {\n           Node propertyName = lhs.getLastChild();\n           return propertyName;\n--- a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n+++ b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n     }\n \n     // For all VARs\n-    if (NodeUtil.isVar(n)) {\n+    if (n.isVar()) {\n       Node name = n.getFirstChild();\n       // It isn't initialized.\n       if (!name.hasChildren()) {\n--- a/src/com/google/javascript/jscomp/GatherSideEffectSubexpressionsCallback.java\n+++ b/src/com/google/javascript/jscomp/GatherSideEffectSubexpressionsCallback.java\n     // Calls to functions that are known to be \"pure\" have no side\n     // effects.\n     Node functionName = node.getFirstChild();\n-    if (NodeUtil.isName(functionName) || NodeUtil.isGetProp(functionName)) {\n+    if (functionName.isName() || functionName.isGetProp()) {\n       if (!accumulator.classDefiningCallsHaveSideEffects() &&\n           isClassDefiningCall(node)) {\n         return true;\n--- a/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n+++ b/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n           // for(x in y) {...}\n           Node lhs = n.getFirstChild();\n           Node rhs = lhs.getNext();\n-          if (NodeUtil.isVar(lhs)) {\n+          if (lhs.isVar()) {\n             // for(var x in y) {...}\n             lhs = lhs.getLastChild();\n           }\n-          if (NodeUtil.isName(lhs)) {\n+          if (lhs.isName()) {\n             addToSetIfLocal(lhs, kill);\n             addToSetIfLocal(lhs, gen);\n           } else {\n         return;\n \n       default:\n-        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\n+        if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {\n           Node lhs = n.getFirstChild();\n           if (!conditional) {\n             addToSetIfLocal(lhs, kill);\n           }\n-          if (!NodeUtil.isAssign(n)) {\n+          if (!n.isAssign()) {\n             // assignments such as a += 1 reads a.\n             addToSetIfLocal(lhs, gen);\n           }\n   }\n \n   private void addToSetIfLocal(Node node, BitSet set) {\n-    Preconditions.checkState(NodeUtil.isName(node));\n+    Preconditions.checkState(node.isName());\n     String name = node.getString();\n     if (!jsScope.isDeclared(name, false)) {\n       return;\n--- a/src/com/google/javascript/jscomp/MarkNoSideEffectCalls.java\n+++ b/src/com/google/javascript/jscomp/MarkNoSideEffectCalls.java\n         traversal.report(node, INVALID_NO_SIDE_EFFECT_ANNOTATION);\n       }\n \n-      if (NodeUtil.isGetProp(node)) {\n+      if (node.isGetProp()) {\n         if (NodeUtil.isExpressionNode(parent) &&\n             hasNoSideEffectsAnnotation(node)) {\n           noSideEffectFunctionNames.add(node);\n         }\n-      } else if (NodeUtil.isFunction(node)) {\n+      } else if (node.isFunction()) {\n \n         // The annotation may attached to the function node, the\n         // variable declaration or assignment expression.\n \n         Node nameNode = null;\n \n-        if (NodeUtil.isName(parent)) {\n+        if (parent.isName()) {\n           Node gramp = parent.getParent();\n-          if (NodeUtil.isVar(gramp) &&\n+          if (gramp.isVar() &&\n               gramp.hasOneChild() &&\n               hasNoSideEffectsAnnotation(gramp)) {\n             hasAnnotation = true;\n           }\n \n           nameNodes.add(parent);\n-        } else if (NodeUtil.isAssign(parent)) {\n+        } else if (parent.isAssign()) {\n           if (hasNoSideEffectsAnnotation(parent)) {\n             hasAnnotation = true;\n           }\n \n     @Override\n     public void visit(NodeTraversal traversal, Node node, Node parent) {\n-      if (!NodeUtil.isCall(node) && !NodeUtil.isNew(node)) {\n+      if (!node.isCall() && !node.isNew()) {\n         return;\n       }\n \n--- a/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java\n+++ b/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java\n           // for(x in y) {...}\n           Node lhs = n.getFirstChild();\n           Node rhs = lhs.getNext();\n-          if (NodeUtil.isVar(lhs)) {\n+          if (lhs.isVar()) {\n             lhs = lhs.getLastChild(); // for(var x in y) {...}\n           }\n-          if (NodeUtil.isName(lhs) && !conditional) {\n+          if (lhs.isName() && !conditional) {\n             removeFromUseIfLocal(lhs.getString(), output);\n           }\n           computeMayUse(rhs, cfgNode, output, conditional);\n         return;\n \n       default:\n-        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\n+        if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {\n           Node name = n.getFirstChild();\n           if (!conditional) {\n             removeFromUseIfLocal(name.getString(), output);\n           }\n \n           // In case of a += \"Hello\". There is a read of a.\n-          if (!NodeUtil.isAssign(n)) {\n+          if (!n.isAssign()) {\n             addToUseIfLocal(name.getString(), cfgNode, output);\n           }\n \n--- a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n+++ b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n           // for(x in y) {...}\n           Node lhs = n.getFirstChild();\n           Node rhs = lhs.getNext();\n-          if (NodeUtil.isVar(lhs)) {\n+          if (lhs.isVar()) {\n             lhs = lhs.getLastChild(); // for(var x in y) {...}\n           }\n-          if (NodeUtil.isName(lhs)) {\n+          if (lhs.isName()) {\n             addToDefIfLocal(lhs.getString(), cfgNode, rhs, output);\n           }\n         }\n \n       default:\n         if (NodeUtil.isAssignmentOp(n)) {\n-          if (NodeUtil.isName(n.getFirstChild())) {\n+          if (n.getFirstChild().isName()) {\n             Node name = n.getFirstChild();\n             computeMustDef(name.getNext(), cfgNode, output, conditional);\n             addToDefIfLocal(name.getString(), conditional ? null : cfgNode,\n             // Treat all assignments to arguments as redefining the\n             // parameters itself.\n             Node obj = n.getFirstChild().getFirstChild();\n-            if (NodeUtil.isName(obj) && \"arguments\".equals(obj.getString())) {\n+            if (obj.isName() && \"arguments\".equals(obj.getString())) {\n               // TODO(user): More accuracy can be introduced\n               // ie: We know exactly what arguments[x] is if x is a constant\n               // number.\n           }\n         }\n \n-        if (NodeUtil.isName(n) && \"arguments\".equals(n.getString())) {\n+        if (n.isName() && \"arguments\".equals(n.getString())) {\n           escapeParameters(output);\n         }\n \n         // DEC and INC actually defines the variable.\n         if (n.getType() == Token.DEC || n.getType() == Token.INC) {\n           Node target = n.getFirstChild();\n-          if (NodeUtil.isName(target)) {\n+          if (target.isName()) {\n             addToDefIfLocal(target.getString(),\n                 conditional ? null : cfgNode, null, output);\n             return;\n         new AbstractCfgNodeTraversalCallback() {\n       @Override\n       public void visit(NodeTraversal t, Node n, Node parent) {\n-        if (NodeUtil.isName(n) && jsScope.isDeclared(n.getString(), true)) {\n+        if (n.isName() && jsScope.isDeclared(n.getString(), true)) {\n           def.depends.add(jsScope.getVar(n.getString()));\n         }\n       }\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (!(NodeUtil.isName(n) ||\n-            NodeUtil.isGet(n) && !NodeUtil.isGetProp(parent))) {\n+      if (!(n.isName() ||\n+            NodeUtil.isGet(n) && !parent.isGetProp())) {\n         // This is not a simple or qualified name.\n         return;\n       }\n         // protect this node by creating a reference to WINDOW.\n         for (Node ancestor : n.getAncestors()) {\n           if (NodeUtil.isAssignmentOp(ancestor) ||\n-              NodeUtil.isFunction(ancestor)) {\n+              ancestor.isFunction()) {\n             recordReference(WINDOW, name, RefType.REGULAR);\n             break;\n           }\n \n     // Check whether this is a class-defining call. Classes may only be defined\n     // in the global scope.\n-    if (NodeUtil.isCall(parent) && t.inGlobalScope()) {\n+    if (parent.isCall() && t.inGlobalScope()) {\n       CodingConvention convention = compiler.getCodingConvention();\n       SubclassRelationship classes = convention.getClassesDefinedByCall(parent);\n       if (classes != null) {\n--- a/src/com/google/javascript/jscomp/NameReferenceGraph.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraph.java\n    */\n   public List<Name> getReferencesAt(Node site) {\n     Preconditions.checkArgument(\n-        NodeUtil.isGetProp(site) || NodeUtil.isName(site));\n+        site.isGetProp() || site.isName());\n     List<Name> result = new ArrayList<Name>();\n     for (Name target : referenceMap.get(site)) {\n       result.add(target);\n     }\n \n     boolean isCall() {\n-      return NodeUtil.isCall(site);\n+      return site.isCall();\n     }\n \n     /**\n--- a/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n \n         Node gParent = parent.getParent();\n         Node ggParent = gParent.getParent();\n-        if (NodeUtil.isAssign(parent) &&\n+        if (parent.isAssign() &&\n             NodeUtil.isPrototypeProperty(parent.getFirstChild())) {\n           pushContainingFunction(\n               recordPrototypePropDefinition(t, parent.getFirstChild(), type,\n       switch (n.getType()) {\n         case Token.NAME:\n         case Token.GETPROP:\n-          if (NodeUtil.isGetProp(parent)) {\n+          if (parent.isGetProp()) {\n             // We will resolve this when we visit parent later in the traversal.\n             return;\n-          } else if (NodeUtil.isFunction(parent)) {\n+          } else if (parent.isFunction()) {\n             // Function declarations have been taken care of in enterScope();\n             return;\n-          } else if (NodeUtil.isAssign(parent)) {\n+          } else if (parent.isAssign()) {\n             // Handled below.\n             return;\n           }\n         case Token.ASSIGN:\n           Node lhs = n.getFirstChild();\n           Node rhs = n.getLastChild();\n-          if (NodeUtil.isFunction(rhs)) {\n+          if (rhs.isFunction()) {\n             // These are recorded when entering the scope.\n             return;\n           }\n-          if (NodeUtil.isName(lhs) ||\n-              NodeUtil.isGetProp(lhs) ||\n-              NodeUtil.isGetProp(rhs)) {\n+          if (lhs.isName() ||\n+              lhs.isGetProp() ||\n+              rhs.isGetProp()) {\n             if (NodeUtil.isPrototypeProperty(lhs)) {\n               Name name = recordPrototypePropDefinition(\n                   t, lhs, getType(rhs), n, parent, parent.getParent());\n           // We need to alias every name that is passed as a parameter because\n           // they have different names inside the function's scope.\n           while ((param = param.getNext()) != null) {\n-            if (NodeUtil.isName(param) || NodeUtil.isGetProp(param)) {\n+            if (param.isName() || param.isGetProp()) {\n               safeAlias(param);\n             }\n           }\n      * @param n node to alias\n      */\n     private void safeAlias(Node n) {\n-      if (NodeUtil.isName(n) || NodeUtil.isGetProp(n)) {\n+      if (n.isName() || n.isGetProp()) {\n         String name = n.getQualifiedName();\n         // getQualifiedName can return null in cases like bar[0].baz\n         if (name != null) {\n         }\n       }\n \n-      if (NodeUtil.isGetProp(n)) {\n+      if (n.isGetProp()) {\n         // var foo = bar[0].baz;\n         defineAndAlias(n.getLastChild().getString());\n-      } else if (NodeUtil.isAssign(n)) {\n+      } else if (n.isAssign()) {\n         // In case of nested assignment, we only consider the name of the\n         // immediate neighbor.\n         safeAlias(n.getFirstChild());\n     }\n \n     private void maybeAliasNamesOnAssign(Node lhs, Node rhs) {\n-      if ((NodeUtil.isName(lhs) || NodeUtil.isGetProp(lhs)) &&\n+      if ((lhs.isName() || lhs.isGetProp()) &&\n           containsName(rhs) &&\n-          !NodeUtil.isFunction(rhs) &&\n-          !NodeUtil.isNew(rhs)) {\n+          !rhs.isFunction() &&\n+          !rhs.isNew()) {\n         safeAlias(lhs);\n         safeAlias(rhs);\n       }\n     }\n \n     private void maybeRecordExport(Node call) {\n-      Preconditions.checkArgument(NodeUtil.isCall(call));\n+      Preconditions.checkArgument(call.isCall());\n       Node getProp = call.getFirstChild();\n-      if (!NodeUtil.isGetProp(getProp)) {\n+      if (!getProp.isGetProp()) {\n         return;\n       }\n \n       }\n \n       Node symbol = getProp.getNext();\n-      if (!NodeUtil.isString(symbol)) {\n+      if (!symbol.isString()) {\n         return;\n       }\n \n     private boolean isLocalNameReference(NodeTraversal t, Node n) {\n       // TODO(user): What happen if it is a reference to an outer local\n       // variable (closures)?\n-      if (NodeUtil.isName(n)) {\n+      if (n.isName()) {\n         Var v = t.getScope().getVar(n.getString());\n         return v != null && v.isLocal();\n       }\n      * @return true if n MUST be a static name reference.\n      */\n     private boolean isStaticNameReference(Node n, Scope scope) {\n-      Preconditions.checkArgument(NodeUtil.isName(n) || NodeUtil.isGetProp(n));\n-      if (NodeUtil.isName(n)) {\n+      Preconditions.checkArgument(n.isName() || n.isGetProp());\n+      if (n.isName()) {\n         return true;\n       }\n       String qName = n.getQualifiedName();\n      * @return true if n MUST be a prototype name reference.\n      */\n     private boolean isPrototypeNameReference(Node n) {\n-      if (!NodeUtil.isGetProp(n)) {\n+      if (!n.isGetProp()) {\n         return false;\n       }\n       JSType type = getType(n.getFirstChild());\n       } else {\n         Name symbol = graph.defineNameIfNotExists(name, isExtern);\n         symbol.setType(type);\n-        if (NodeUtil.isAssign(n)) {\n+        if (n.isAssign()) {\n           symbol.addAssignmentDeclaration(n);\n         } else {\n           symbol.addFunctionDeclaration(n);\n \n     private void recordPrototypePropUse(\n         NodeTraversal t, Node n, Node parent) {\n-      Preconditions.checkArgument(NodeUtil.isGetProp(n));\n+      Preconditions.checkArgument(n.isGetProp());\n       Node instance = n.getFirstChild();\n       JSType instanceType = getType(instance);\n       JSType boxedType = instanceType.autoboxesTo();\n         // Don't count reference in extern as a use.\n         return;\n       } else {\n-        Preconditions.checkArgument(NodeUtil.isGetProp(n));\n+        Preconditions.checkArgument(n.isGetProp());\n         Reference ref = new Reference(n, parent);\n         ref.setUnknown(true);\n         unknownNameUse.put(n.getLastChild().getString(),\n       if (rhs != null) {\n         // TODO(user): record the definition.\n         symbol.setType(getType(rhs));\n-        if (NodeUtil.isAssign(n)) {\n+        if (n.isAssign()) {\n           symbol.addAssignmentDeclaration(n);\n         } else {\n           symbol.addFunctionDeclaration(n);\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n \n         if (isAssignmentOp(n)) {\n           Node assignTarget = n.getFirstChild();\n-          if (isName(assignTarget)) {\n+          if (assignTarget.isName()) {\n             return true;\n           }\n \n     return false;\n   }\n \n-  static boolean isNull(Node n) {\n-    return n.isNull();\n-  }\n-\n   static boolean isNullOrUndefined(Node n) {\n-    return isNull(n) || isUndefined(n);\n+    return n.isNull() || isUndefined(n);\n   }\n \n   static class MayBeStringResultPredicate implements Predicate<Node> {\n \n   static boolean mayBeStringHelper(Node n) {\n     return !isNumericResult(n) && !isBooleanResult(n)\n-        && !isUndefined(n) && !isNull(n);\n+        && !isUndefined(n) && !n.isNull();\n   }\n \n   /**\n    * Returns true if the shallow scope contains references to 'this' keyword\n    */\n   static boolean referencesThis(Node n) {\n-    Node start = (isFunction(n)) ? n.getLastChild() : n;\n+    Node start = (n.isFunction()) ? n.getLastChild() : n;\n     return containsType(start, Token.THIS, MATCH_NOT_FUNCTION);\n   }\n \n    */\n   static boolean isGet(Node n) {\n     return n.isGetProp() || n.isGetElem();\n-  }\n-\n-  /**\n-   * Is this a GETPROP node?\n-   */\n-  static boolean isGetProp(Node n) {\n-    return n.isGetProp();\n-  }\n-\n-  /**\n-   * Is this a NAME node?\n-   */\n-  static boolean isName(Node n) {\n-    return n.isName();\n-  }\n-\n-  /**\n-   * Is this a NEW node?\n-   */\n-  static boolean isNew(Node n) {\n-    return n.isNew();\n-  }\n-\n-  /**\n-   * Is this a VAR node?\n-   */\n-  static boolean isVar(Node n) {\n-    return n.isVar();\n   }\n \n   /**\n    * @return The value node representing the new value.\n    */\n   static Node getAssignedValue(Node n) {\n-    Preconditions.checkState(isName(n));\n+    Preconditions.checkState(n.isName());\n     Node parent = n.getParent();\n-    if (isVar(parent)) {\n+    if (parent.isVar()) {\n       return n.getFirstChild();\n-    } else if (isAssign(parent) && parent.getFirstChild() == n) {\n+    } else if (parent.isAssign() && parent.getFirstChild() == n) {\n       return n.getNext();\n     } else {\n       return null;\n   }\n \n   /**\n-   * Is this a STRING node?\n-   */\n-  static boolean isString(Node n) {\n-    return n.isString();\n-  }\n-\n-  /**\n    * Is this node an assignment expression statement?\n    *\n    * @param n The node\n   static boolean isExprAssign(Node n) {\n     return n.isExprResult()\n         && n.getFirstChild().isAssign();\n-  }\n-\n-  /**\n-   * Is this an ASSIGN node?\n-   */\n-  static boolean isAssign(Node n) {\n-    return n.isAssign();\n   }\n \n   /**\n         return true;\n       }\n \n-      if (NodeUtil.isFunction(parent)) {\n+      if (parent.isFunction()) {\n         break;\n       }\n     }\n    *       function parameter (not a label or a empty function expression name).\n    */\n   static boolean isReferenceName(Node n) {\n-    return isName(n) && !n.getString().isEmpty();\n-  }\n-\n-  /** @return Whether the node is a label name. */\n-  static boolean isLabelName(Node n) {\n-    return (n != null && n.isLabelName());\n+    return n.isName() && !n.getString().isEmpty();\n   }\n \n   /** Whether the child node is the FINALLY block of a try. */\n   }\n \n   /**\n-   * Is this a CALL node?\n-   */\n-  static boolean isCall(Node n) {\n-    return n.isCall();\n-  }\n-\n-  /**\n    * @param node A node\n    * @return Whether the call is a NEW or CALL node.\n    */\n   static boolean isCallOrNew(Node node) {\n-    return NodeUtil.isCall(node) || NodeUtil.isNew(node);\n-  }\n-\n-  /**\n-   * Is this a FUNCTION node?\n-   */\n-  static boolean isFunction(Node n) {\n-    return n.isFunction();\n+    return node.isCall() || node.isNew();\n   }\n \n   /**\n    * Return a BLOCK node for the given FUNCTION node.\n    */\n   static Node getFunctionBody(Node fn) {\n-    Preconditions.checkArgument(isFunction(fn));\n+    Preconditions.checkArgument(fn.isFunction());\n     return fn.getLastChild();\n-  }\n-\n-  /**\n-   * Is this a THIS node?\n-   */\n-  static boolean isThis(Node node) {\n-    return node.isThis();\n-  }\n-\n-\n-  /**\n-   * Is this an ARRAYLIT node\n-   */\n-  static boolean isArrayLiteral(Node node) {\n-    return node.isArrayLit();\n   }\n \n   /**\n    * looking for references to the \"arguments\" var_args object.\n    */\n   static boolean isVarArgsFunction(Node function) {\n-    Preconditions.checkArgument(isFunction(function));\n+    Preconditions.checkArgument(function.isFunction());\n     return isNameReferenced(\n         function.getLastChild(),\n         \"arguments\",\n    */\n   static Node getPrototypeClassName(Node qName) {\n     Node cur = qName;\n-    while (isGetProp(cur)) {\n+    while (cur.isGetProp()) {\n       if (cur.getLastChild().getString().equals(\"prototype\")) {\n         return cur.getFirstChild();\n       } else {\n   private static class MatchNotFunction implements Predicate<Node>{\n     @Override\n     public boolean apply(Node n) {\n-      return !isFunction(n);\n+      return !n.isFunction();\n     }\n   }\n \n     public boolean apply(Node n) {\n       Node parent = n.getParent();\n       return n.isBlock()\n-          || (!isFunction(n) && (parent == null\n+          || (!n.isFunction() && (parent == null\n               || isControlStructure(parent)\n               || isStatementBlock(parent)));\n     }\n    * argument or null if no such parameter exists.\n    */\n   static Node getArgumentForFunction(Node function, int index) {\n-    Preconditions.checkState(isFunction(function));\n+    Preconditions.checkState(function.isFunction());\n     return getNthSibling(\n         function.getFirstChild().getNext().getFirstChild(), index);\n   }\n     Node getNode = call.getFirstChild();\n     if (isGet(getNode)) {\n       Node propNode = getNode.getLastChild();\n-      return isString(propNode) && \"toString\".equals(propNode.getString());\n+      return propNode.isString() && \"toString\".equals(propNode.getString());\n     }\n     return false;\n   }\n--- a/src/com/google/javascript/jscomp/OperaCompoundAssignFix.java\n+++ b/src/com/google/javascript/jscomp/OperaCompoundAssignFix.java\n \n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (!NodeUtil.isName(n)) {\n+    if (!n.isName()) {\n       return;\n     }\n \n \n     while (!(NodeUtil.isExpressionNode(parent) ||\n              NodeUtil.isStatementBlock(parent))) {\n-      if (NodeUtil.isAssign(parent) &&\n-          NodeUtil.isName(parent.getFirstChild()) &&\n+      if (parent.isAssign() &&\n+          parent.getFirstChild().isName() &&\n           parent.getFirstChild().getString().equals(n.getString()) &&\n           nested) {\n         reassign = true;\n \n   private void applyWorkAround(Node assign, NodeTraversal t) {\n //System.out.println(\"applyWorkAround: \" + assign.toStringTree());\n-    Preconditions.checkArgument(NodeUtil.isAssign(assign));\n+    Preconditions.checkArgument(assign.isAssign());\n     Node parent = assign.getParent();\n     Node comma = new Node(Token.COMMA);\n     comma.copyInformationFrom(assign);\n--- a/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java\n+++ b/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java\n     // This optimization is valid only within a function so we are going to\n     // skip over the initial entry to the global scope.\n     Node function = traversal.getScopeRoot();\n-    if (!NodeUtil.isFunction(function)) {\n+    if (!function.isFunction()) {\n       return;\n     }\n \n \n     // Otherwise, we are in a function scope and we should record if the current\n     // name is referring to the implicit arguments array.\n-    if (NodeUtil.isName(node) && ARGUMENTS.equals(node.getString())) {\n+    if (node.isName() && ARGUMENTS.equals(node.getString())) {\n       currentArgumentsAccess.add(node);\n     }\n   }\n       Node getElemParent = getElem.getParent();\n       // When we have argument[0](), replacing it with a() is semantically\n       // different if argument[0] is a function call that refers to 'this'\n-      if (NodeUtil.isCall(getElemParent) &&\n+      if (getElemParent.isCall() &&\n           getElemParent.getFirstChild() == getElem) {\n         // TODO(user): We can consider using .call() if aliasing that\n         // argument allows shorter alias for other arguments.\n--- a/src/com/google/javascript/jscomp/OptimizeParameters.java\n+++ b/src/com/google/javascript/jscomp/OptimizeParameters.java\n     // rewrite changes the structure of this object.\n     Node rValue = definition.getRValue();\n     if (rValue == null ||\n-        !NodeUtil.isFunction(rValue) ||\n+        !rValue.isFunction() ||\n         NodeUtil.isVarArgsFunction(rValue)) {\n       return false;\n     }\n     // Remove the constant parameters in the definitions and add it as a local\n     // variable.\n     Node function = definition.getRValue();\n-    if (NodeUtil.isFunction(function)) {\n+    if (function.isFunction()) {\n       optimizeFunctionDefinition(parameters, function);\n     }\n   }\n    * @param value The initial value of the variable.\n    */\n   private void addVariableToFunction(Node function, Node varName, Node value) {\n-    Preconditions.checkArgument(NodeUtil.isFunction(function),\n+    Preconditions.checkArgument(function.isFunction(),\n         \"Node must be a function.\");\n \n     Node block = function.getLastChild();\n    * @return The Node of the argument removed.\n    */\n   private Node eliminateFunctionParamAt(Node function, int argIndex) {\n-    Preconditions.checkArgument(NodeUtil.isFunction(function),\n+    Preconditions.checkArgument(function.isFunction(),\n         \"Node must be a function.\");\n \n     Node formalArgPtr = NodeUtil.getArgumentForFunction(\n--- a/src/com/google/javascript/jscomp/OptimizeReturns.java\n+++ b/src/com/google/javascript/jscomp/OptimizeReturns.java\n \n     // Assume non-function definitions results are used.\n     Node rValue = definition.getRValue();\n-    if (rValue == null || !NodeUtil.isFunction(rValue)) {\n+    if (rValue == null || !rValue.isFunction()) {\n       return true;\n     }\n \n       } else {\n         // Allow a standalone name reference.\n         //     var a;\n-        if (!NodeUtil.isVar(useNodeParent)) {\n+        if (!useNodeParent.isVar()) {\n           return true;\n         }\n       }\n    */\n   private void rewriteReturns(\n       final SimpleDefinitionFinder defFinder, Node fnNode) {\n-    Preconditions.checkState(NodeUtil.isFunction(fnNode));\n+    Preconditions.checkState(fnNode.isFunction());\n     NodeUtil.visitPostOrder(\n       fnNode.getLastChild(),\n       new NodeUtil.Visitor() {\n   private static boolean isCall(UseSite site) {\n     Node node = site.node;\n     Node parent = node.getParent();\n-    return (parent.getFirstChild() == node) && NodeUtil.isCall(parent);\n+    return (parent.getFirstChild() == node) && parent.isCall();\n   }\n }\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n     boolean result;\n \n     boolean undefinedRight = NodeUtil.isUndefined(right) && rightLiteral;\n-    boolean nullRight = NodeUtil.isNull(right);\n+    boolean nullRight = right.isNull();\n     int lhType = getNormalizedNodeType(left);\n     int rhType = getNormalizedNodeType(right);\n     switch (lhType) {\n--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n       Node lhsAssign = getSimpleAssignmentName(n);\n \n       Node condition = getConditionalStatementCondition(next);\n-      if (NodeUtil.isName(lhsAssign) && NodeUtil.isName(condition)\n+      if (lhsAssign.isName() && condition.isName()\n           && lhsAssign.getString().equals(condition.getString())) {\n         Node rhsAssign = getSimpleAssignmentValue(n);\n         TernaryValue value = NodeUtil.getImpureBooleanValue(rhsAssign);\n     // For our purposes we define a simple assignment to be a assignment\n     // to a NAME node, or a VAR declaration with one child and a initializer.\n     if (NodeUtil.isExprAssign(n)\n-        && NodeUtil.isName(n.getFirstChild().getFirstChild())) {\n+        && n.getFirstChild().getFirstChild().isName()) {\n       return true;\n     } else if (n.getType() == Token.VAR && n.hasOneChild() &&\n         n.getFirstChild().getFirstChild() != null) {\n--- a/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n+++ b/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n \n   @Override\n   Node optimizeSubtree(Node subtree) {\n-    if (NodeUtil.isCall(subtree) ){\n+    if (subtree.isCall() ){\n       return tryFoldKnownMethods(subtree);\n     }\n     return subtree;\n       // then dispatch to specific folding method.\n       Node callTarget = subtree.getFirstChild();\n \n-      if (!NodeUtil.isName(callTarget)) {\n+      if (!callTarget.isName()) {\n         return subtree;\n       }\n \n   private Node tryFoldArrayJoin(Node n) {\n     Node callTarget = n.getFirstChild();\n \n-    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n+    if (callTarget == null || !callTarget.isGetProp()) {\n       return n;\n     }\n \n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n     Node breakTarget = n;\n     for (;!ControlFlowAnalysis.isBreakTarget(breakTarget, null /* no label */);\n         breakTarget = breakTarget.getParent()) {\n-      if (NodeUtil.isFunction(breakTarget) ||\n-          breakTarget.getType() == Token.SCRIPT) {\n+      if (breakTarget.isFunction() || breakTarget.isScript()) {\n         // No break target.\n         return n;\n       }\n \n     // if(x)var y=1;else y=2  ->  var y=x?1:2\n     if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n-        NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) {\n+        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n \n       Node var = getBlockVar(thenBranch);\n       Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n \n     // if(x)y=1;else var y=2  ->  var y=x?1:2\n     } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n-        NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) {\n+        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n \n       Node var = getBlockVar(elseBranch);\n       Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n     }\n     Preconditions.checkArgument(n.getType() == Token.NEW);\n     Node date = n.getFirstChild();\n-    if (!NodeUtil.isName(date) || !\"Date\".equals(date.getString())) {\n+    if (!date.isName() || !\"Date\".equals(date.getString())) {\n       return;\n     }\n     Node callGoogNow = date.getNext();\n-    if (callGoogNow == null || !NodeUtil.isCall(callGoogNow) ||\n+    if (callGoogNow == null || !callGoogNow.isCall() ||\n         callGoogNow.getNext() != null) {\n       return;\n     }\n      */\n     void addDefinition(Node node, JSModule module) {\n       Preconditions.checkArgument(NodeUtil.isExpressionNode(node) || // assign\n-                                  NodeUtil.isFunction(node) ||\n-                                  NodeUtil.isVar(node));\n+                                  node.isFunction() ||\n+                                  node.isVar());\n       Preconditions.checkArgument(explicitNode != node);\n       if ((candidateDefinition == null) || !NodeUtil.isExpressionNode(node)) {\n         candidateDefinition = node;\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n    */\n   private static Collection<Definition> getCallableDefinitions(\n       DefinitionProvider definitionProvider, Node name) {\n-    if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {\n+    if (name.isGetProp() || name.isName()) {\n       List<Definition> result = Lists.newArrayList();\n \n       Collection<Definition> decls =\n \n       for (Definition current : decls) {\n         Node rValue = current.getRValue();\n-        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n+        if ((rValue != null) && rValue.isFunction()) {\n           result.add(current);\n         } else {\n           return null;\n             flags.setThrows();\n           }\n \n-          if (!NodeUtil.isNew(callNode)) {\n+          if (!callNode.isNew()) {\n             if (functionInfo.taintsThis) {\n               flags.setMutatesThis();\n             }\n       }\n \n       // Handle special cases (Math, RegEx)\n-      if (NodeUtil.isCall(callNode)) {\n+      if (callNode.isCall()) {\n         Preconditions.checkState(compiler != null);\n         if (!NodeUtil.functionCallHasSideEffects(callNode, compiler)) {\n           flags.clearSideEffectFlags();\n         }\n-      } else if (NodeUtil.isNew(callNode)) {\n+      } else if (callNode.isNew()) {\n         // Handle known cases now (Object, Date, RegExp, etc)\n         if (!NodeUtil.constructorCallHasSideEffects(callNode)) {\n           flags.clearSideEffectFlags();\n       // entry for the enclosing function exists in the\n       // FunctionInformation map when processing assignments and calls\n       // inside visit.\n-      if (NodeUtil.isFunction(node)) {\n+      if (node.isFunction()) {\n         Node gramp = parent.getParent();\n         visitFunction(traversal, node, parent, gramp);\n       }\n         return;\n       }\n \n-      if (NodeUtil.isCall(node) || NodeUtil.isNew(node)) {\n+      if (node.isCall() || node.isNew()) {\n         allFunctionCalls.add(node);\n       }\n \n     private void visitAssignmentOrUnaryOperator(\n         FunctionInformation sideEffectInfo,\n         Scope scope, Node op, Node lhs, Node rhs) {\n-      if (NodeUtil.isName(lhs)) {\n+      if (lhs.isName()) {\n         Var var = scope.getVar(lhs.getString());\n         if (var == null || var.scope != scope) {\n           sideEffectInfo.setTaintsGlobalState();\n               NodeUtil.isAssignmentOp(op)\n               || isIncDec(op) || op.getType() == Token.DELPROP);\n           if (rhs != null\n-              && NodeUtil.isAssign(op)\n+              && op.isAssign()\n               && !NodeUtil.evaluatesToLocalValue(rhs)) {\n             sideEffectInfo.blacklistLocal(var);\n           }\n         }\n       } else if (NodeUtil.isGet(lhs)) {\n-        if (NodeUtil.isThis(lhs.getFirstChild())) {\n+        if (lhs.getFirstChild().isThis()) {\n           sideEffectInfo.setTaintsThis();\n         } else {\n           Var var = null;\n           Node objectNode = lhs.getFirstChild();\n-          if (NodeUtil.isName(objectNode)) {\n+          if (objectNode.isName()) {\n             var = scope.getVar(objectNode.getString());\n           }\n           if (var == null || var.scope != scope) {\n      */\n     private void visitCall(FunctionInformation sideEffectInfo, Node node) {\n       // Handle special cases (Math, RegEx)\n-      if (NodeUtil.isCall(node)\n+      if (node.isCall()\n           && !NodeUtil.functionCallHasSideEffects(node, compiler)) {\n         return;\n       }\n \n       // Handle known cases now (Object, Date, RegExp, etc)\n-      if (NodeUtil.isNew(node)\n+      if (node.isNew()\n           && !NodeUtil.constructorCallHasSideEffects(node)) {\n         return;\n       }\n       JSDocInfo info = node.getJSDocInfo();\n       if (info != null) {\n         return info;\n-      } else if (NodeUtil.isName(parent)) {\n+      } else if (parent.isName()) {\n         return gramp.hasOneChild() ? gramp.getJSDocInfo() : null;\n-      } else if (NodeUtil.isAssign(parent)) {\n+      } else if (parent.isAssign()) {\n         return parent.getJSDocInfo();\n       } else {\n         return null;\n         // Calling a constructor that modifies \"this\" has no side effects.\n         if (callSite.getType() != Token.NEW) {\n           Node objectNode = getCallThisObject(callSite);\n-          if (objectNode != null && NodeUtil.isName(objectNode)\n+          if (objectNode != null && objectNode.isName()\n               && !isCallOrApply(callSite)) {\n             // Exclude \".call\" and \".apply\" as the value may still be may be\n             // null or undefined. We don't need to worry about this with a\n                 changed = true;\n               }\n             //}\n-          } else if (objectNode != null && NodeUtil.isThis(objectNode)) {\n+          } else if (objectNode != null && objectNode.isThis()) {\n             if (!caller.mutatesThis()) {\n               caller.setTaintsThis();\n               changed = true;\n--- a/src/com/google/javascript/jscomp/RemoveUnusedPrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedPrototypeProperties.java\n       specializableFunction = ((GlobalFunction) symbol).getFunctionNode();\n     } else if (symbol instanceof AssignmentProperty) {\n       Node propertyValue = ((AssignmentProperty) symbol).getValue();\n-      if (NodeUtil.isFunction(propertyValue)) {\n+      if (propertyValue.isFunction()) {\n         specializableFunction = propertyValue;\n       }\n     } else if (symbol instanceof LiteralProperty) {\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n         }\n \n         // Ignore references within goog.inherits calls.\n-        if (NodeUtil.isCall(parent) &&\n+        if (parent.isCall() &&\n             convention.getClassesDefinedByCall(parent) != null) {\n           continue;\n         }\n \n         // Accessing the property directly prevents rewrite.\n         if (!SimpleDefinitionFinder.isCallOrNewSite(site)) {\n-          if (!(NodeUtil.isGetProp(parent) &&\n+          if (!(parent.isGetProp() &&\n               NodeUtil.isFunctionObjectCall(parent.getParent()))) {\n             return false;\n           }\n--- a/src/com/google/javascript/jscomp/ReplaceIdGenerators.java\n+++ b/src/com/google/javascript/jscomp/ReplaceIdGenerators.java\n       }\n \n       String name = null;\n-      if (NodeUtil.isAssign(n)) {\n+      if (n.isAssign()) {\n         name = n.getFirstChild().getQualifiedName();\n-      } else if (NodeUtil.isVar(n)) {\n+      } else if (n.isVar()) {\n         name = n.getFirstChild().getString();\n-      } else if (NodeUtil.isFunction(n)){\n+      } else if (n.isFunction()){\n         name = n.getFirstChild().getString();\n         if (name.isEmpty()) {\n           return;\n       Node id = n.getFirstChild().getNext();\n \n       // TODO(user): Error on id not a string literal.\n-      if (!NodeUtil.isString(id)) {\n+      if (!id.isString()) {\n         return;\n       }\n \n--- a/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n+++ b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (NodeUtil.isFunction(n)) {\n+      if (n.isFunction()) {\n         visitFunction(t, n);\n       }\n     }\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (NodeUtil.isFunction(n)) {\n+      if (n.isFunction()) {\n         visitFunction(t, n);\n       } else if (n.getType() == Token.RETURN) {\n         visitReturn(t, n);\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n         report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS);\n       } else {\n         Node anonymousFnNode = n.getChildAtIndex(1);\n-        if (!NodeUtil.isFunction(anonymousFnNode) ||\n+        if (!anonymousFnNode.isFunction() ||\n             NodeUtil.getFunctionName(anonymousFnNode) != null ||\n             NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {\n           report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS);\n--- a/src/com/google/javascript/jscomp/ShadowVariables.java\n+++ b/src/com/google/javascript/jscomp/ShadowVariables.java\n         Node cur = n;\n         while(cur != s.getRootNode()) {\n           cur = cur.getParent();\n-          if (NodeUtil.isFunction(cur)) {\n+          if (cur.isFunction()) {\n             scopeUpRefMap.put(cur, toShadow.oldName);\n           }\n         }\n--- a/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n+++ b/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n       new Predicate<Node>() {\n     @Override\n     public boolean apply(Node input) {\n-      return !NodeUtil.isFunction(input);\n+      return !input.isFunction();\n     }\n   };\n \n     return NodeUtil.has(node, new Predicate<Node>() {\n       @Override\n       public boolean apply(Node input) {\n-        return NodeUtil.isCall(input) || NodeUtil.isNew(input);\n+        return input.isCall() || input.isNew();\n       }},\n       NOT_FUNCTION_PREDICATE);\n   }\n       for (Node reference : findStorageLocationReferences(node)) {\n         int effectMask;\n \n-        if (NodeUtil.isName(reference)) {\n+        if (reference.isName()) {\n           // Variable access\n           effectMask = effectMaskForVariableReference(reference);\n          } else {\n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n           if (NodeUtil.isGet(n)\n-              || (NodeUtil.isName(n) && !NodeUtil.isFunction(parent))) {\n+              || (n.isName() && !parent.isFunction())) {\n             references.add(n);\n           }\n         }\n      * Calculates the effect mask for a variable reference.\n      */\n     private int effectMaskForVariableReference(Node variableReference) {\n-      Preconditions.checkArgument(NodeUtil.isName(variableReference));\n+      Preconditions.checkArgument(variableReference.isName());\n \n       int effectMask = VISIBILITY_LOCATION_NONE;\n \n      * Only NAMEs, GETPROPs, and GETELEMs are storage nodes.\n      */\n     private static boolean isStorageNode(Node node) {\n-      return NodeUtil.isName(node) || NodeUtil.isGet(node);\n+      return node.isName() || NodeUtil.isGet(node);\n     }\n \n     /**\n      * or {@code null} otherwise.\n      */\n     public Node findDeclaringNameNodeForUse(Node usingNameNode) {\n-      Preconditions.checkArgument(NodeUtil.isName(usingNameNode));\n+      Preconditions.checkArgument(usingNameNode.isName());\n \n       return referencesByNameNode.get(usingNameNode);\n     }\n--- a/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n+++ b/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n   }\n \n   DefinitionSite getDefinitionForFunction(Node function) {\n-    Preconditions.checkState(NodeUtil.isFunction(function));\n+    Preconditions.checkState(function.isFunction());\n     return getDefinitionAt(getNameNodeFromFunctionNode(function));\n   }\n \n       return null;\n     }\n \n-    if (NodeUtil.isGetProp(useSite)) {\n+    if (useSite.isGetProp()) {\n       String propName = useSite.getLastChild().getString();\n       if (propName.equals(\"apply\") || propName.equals(\"call\")) {\n         useSite = useSite.getFirstChild();\n    * much if this pass runs after \"collapsing properties\".\n    */\n   private static String getSimplifiedName(Node node) {\n-    if (NodeUtil.isName(node)) {\n+    if (node.isName()) {\n       String name = node.getString();\n       if (name != null && !name.isEmpty()) {\n         return name;\n       } else {\n         return null;\n       }\n-    } else if (NodeUtil.isGetProp(node)) {\n+    } else if (node.isGetProp()) {\n       return \"this.\" + node.getLastChild().getString();\n     }\n     return null;\n       // Arguments of external functions should not count as name\n       // definitions.  They are placeholder names for documentation\n       // purposes only which are not reachable from anywhere.\n-      if (inExterns && NodeUtil.isName(node) && parent.getType() == Token.LP) {\n+      if (inExterns && node.isName() && parent.getType() == Token.LP) {\n         return;\n       }\n \n           Node rValue = def.getRValue();\n           if ((rValue != null) &&\n               !NodeUtil.isImmutableValue(rValue) &&\n-              !NodeUtil.isFunction(rValue)) {\n+              !rValue.isFunction()) {\n \n             // Unhandled complex expression\n             Definition unknownDef =\n     }\n \n     String partialName;\n-    if (NodeUtil.isGetProp(lValue)) {\n+    if (lValue.isGetProp()) {\n       partialName = lValue.getLastChild().getString();\n-    } else if (NodeUtil.isName(lValue)) {\n+    } else if (lValue.isName()) {\n       partialName = lValue.getString();\n     } else {\n       // GETELEM is assumed to be an export or other expression are unknown\n     // rather than simply having an extern definition.  Don't mess with it.\n     Node nameNode = SimpleDefinitionFinder.getNameNodeFromFunctionNode(fn);\n     if (nameNode != null\n-        && NodeUtil.isName(nameNode)) {\n+        && nameNode.isName()) {\n       String name = nameNode.getString();\n       if (name.equals(NodeUtil.JSC_PROPERTY_NAME_FN) ||\n              name.equals(\n     // example: a = function(){};\n     // example: var a = function(){};\n     if (fn.getFirstChild().getString().isEmpty()\n-        && (NodeUtil.isExprAssign(gramps) || NodeUtil.isName(parent))) {\n+        && (NodeUtil.isExprAssign(gramps) || parent.isName())) {\n       return true;\n     }\n \n    * @return the node defining the name for this function (if any).\n    */\n   static Node getNameNodeFromFunctionNode(Node function) {\n-    Preconditions.checkState(NodeUtil.isFunction(function));\n+    Preconditions.checkState(function.isFunction());\n     if (NodeUtil.isFunctionDeclaration(function)) {\n       return function.getFirstChild();\n     } else {\n       Node parent = function.getParent();\n       if (NodeUtil.isVarDeclaration(parent)) {\n         return parent;\n-      } else if (NodeUtil.isAssign(parent)) {\n+      } else if (parent.isAssign()) {\n         return parent.getFirstChild();\n       } else if (NodeUtil.isObjectLitKey(parent, parent.getParent())) {\n         return parent;\n       }\n     } else {\n       Node useSite = node;\n-      if (NodeUtil.isGetProp(useSite)) {\n+      if (useSite.isGetProp()) {\n         String propName = useSite.getLastChild().getString();\n         if (propName.equals(\"apply\") || propName.equals(\"call\")) {\n           useSite = useSite.getFirstChild();\n--- a/src/com/google/javascript/jscomp/SimpleFunctionAliasAnalysis.java\n+++ b/src/com/google/javascript/jscomp/SimpleFunctionAliasAnalysis.java\n    */\n   public boolean isAliased(Node functionNode) {\n     Preconditions.checkNotNull(aliasedFunctions);\n-    Preconditions.checkArgument(NodeUtil.isFunction(functionNode));\n+    Preconditions.checkArgument(functionNode.isFunction());\n \n     return aliasedFunctions.contains(functionNode);\n   }\n    */\n   public boolean isExposedToCallOrApply(Node functionNode) {\n     Preconditions.checkNotNull(functionsExposedToCallOrApply);\n-    Preconditions.checkArgument(NodeUtil.isFunction(functionNode));\n+    Preconditions.checkArgument(functionNode.isFunction());\n \n     return functionsExposedToCallOrApply.contains(functionNode);\n   }\n       if (!definition.isExtern()) {\n         Node rValue = definition.getRValue();\n \n-        if (rValue != null && NodeUtil.isFunction(rValue)) {\n+        if (rValue != null && rValue.isFunction()) {\n           // rValue is a Token.FUNCTION from a definition\n \n           for (UseSite useSite : finder.getUseSites(definition)) {\n       // GET{PROP,ELEM} don't count as aliases\n       // but we have to check for using them in .call and .apply.\n \n-      if (NodeUtil.isGetProp(useParent)) {\n+      if (useParent.isGetProp()) {\n         Node gramps = useParent.getParent();\n         if (NodeUtil.isFunctionObjectApply(gramps) ||\n             NodeUtil.isFunctionObjectCall(gramps)) {\n--- a/src/com/google/javascript/jscomp/SourceMap.java\n+++ b/src/com/google/javascript/jscomp/SourceMap.java\n     // detail is not needed.\n     SYMBOLS {\n       @Override public boolean apply(Node node) {\n-        return NodeUtil.isCall(node)\n-            || NodeUtil.isNew(node)\n-            || NodeUtil.isFunction(node)\n-            || NodeUtil.isName(node)\n+        return node.isCall()\n+            || node.isNew()\n+            || node.isFunction()\n+            || node.isName()\n             || NodeUtil.isGet(node)\n             || NodeUtil.isObjectLitKey(node, node.getParent())\n-            || (NodeUtil.isString(node) && NodeUtil.isGet(node.getParent()));\n+            || (node.isString() && NodeUtil.isGet(node.getParent()));\n       }\n     };\n   }\n--- a/src/com/google/javascript/jscomp/SpecializeModule.java\n+++ b/src/com/google/javascript/jscomp/SpecializeModule.java\n     new NodeMatcher() {\n       @Override\n       public void reportMatch(Node original, Node specialized) {\n-        if (NodeUtil.isFunction(original)) {\n+        if (original.isFunction()) {\n           OriginalFunctionInformation functionInfo =\n               new OriginalFunctionInformation(original);\n \n \n       @Override\n       public boolean shouldTraverse(Node n1, Node n2) {\n-        return !NodeUtil.isFunction(n1);\n+        return !n1.isFunction();\n       }\n     }.match(original, toBeSpecialized);\n   }\n \n       Node originalParent = originalFunction.getParent();\n \n-      isAssignFunction = NodeUtil.isAssign(originalParent) ||\n-          NodeUtil.isName(originalParent);\n+      isAssignFunction = originalParent.isAssign() ||\n+          originalParent.isName();\n \n       assignHasVar =\n-          isAssignFunction && NodeUtil.isVar(originalParent.getParent());\n+          isAssignFunction && originalParent.getParent().isVar();\n     }\n \n     private Node copiedOriginalFunction() {\n      * however we do not currently support this.\n      */\n     public boolean canFixupFunction(Node functionNode) {\n-      Preconditions.checkArgument(NodeUtil.isFunction(functionNode));\n+      Preconditions.checkArgument(functionNode.isFunction());\n \n       if (!nodeIsInGlobalScope(functionNode) ||\n           initialModuleAliasAnalysis.isAliased(functionNode)) {\n       Node parent = functionNode.getParent();\n       Node gramps = parent.getParent();\n \n-      if (NodeUtil.isName(parent) && NodeUtil.isVar(gramps)) {\n+      if (parent.isName() && gramps.isVar()) {\n         // var f = function() {}\n         return true;\n       }\n      */\n     private Node containingFunction(Node node) {\n       for (Node ancestor : node.getAncestors()) {\n-        if (NodeUtil.isFunction(ancestor)) {\n+        if (ancestor.isFunction()) {\n           return ancestor;\n         }\n       }\n--- a/src/com/google/javascript/jscomp/StatementFusion.java\n+++ b/src/com/google/javascript/jscomp/StatementFusion.java\n   @Override\n   Node optimizeSubtree(Node n) {\n     // The block of a function body always need { }.\n-    if (!NodeUtil.isFunction(n.getParent()) && canFuseIntoOneStatement(n)) {\n+    if (!n.getParent().isFunction() && canFuseIntoOneStatement(n)) {\n       fuseIntoOneStatement(n);\n       reportCodeChange();\n     }\n--- a/src/com/google/javascript/jscomp/SuppressDocWarningsGuard.java\n+++ b/src/com/google/javascript/jscomp/SuppressDocWarningsGuard.java\n           info = current.getJSDocInfo();\n         } else if (type == Token.ASSIGN) {\n           Node rhs = current.getLastChild();\n-          if (NodeUtil.isFunction(rhs)) {\n+          if (rhs.isFunction()) {\n             info = NodeUtil.getFunctionJSDocInfo(rhs);\n           }\n         }\n--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n     }\n \n \n-    if (NodeUtil.isVar(n) && !n.getFirstChild().hasChildren()) {\n+    if (n.isVar() && !n.getFirstChild().hasChildren()) {\n       // Very Edge case, Consider this:\n       // File 1: {throw 1}\n       // File 2: {var x}\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n \n     // Only a function can have an empty name.\n     if (varName.isEmpty()) {\n-      Preconditions.checkState(NodeUtil.isFunction(parent));\n+      Preconditions.checkState(parent.isFunction());\n \n       // A function declaration with an empty name passes Rhino,\n       // but is supposed to be a syntax error according to the spec.\n--- a/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java\n+++ b/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java\n   public VariableVisibility getVariableVisibility(Node declaringNameNode) {\n     Node parent = declaringNameNode.getParent();\n \n-    Preconditions.checkArgument(NodeUtil.isVar(parent)\n-        || NodeUtil.isFunction(parent)\n+    Preconditions.checkArgument(parent.isVar()\n+        || parent.isFunction()\n         || parent.getType() == Token.LP);\n \n     return visibilityByDeclaringNameNode.get(declaringNameNode);\n--- a/test/com/google/javascript/jscomp/DevirtualizePrototypeMethodsTest.java\n+++ b/test/com/google/javascript/jscomp/DevirtualizePrototypeMethodsTest.java\n       @Override\n       public void visit(NodeTraversal traversal, Node node, Node parent) {\n         Node nameNode = null;\n-        if (NodeUtil.isFunction(node)) {\n-          if (NodeUtil.isName(parent)) {\n+        if (node.isFunction()) {\n+          if (parent.isName()) {\n             nameNode = parent;\n-          } else if (NodeUtil.isAssign(parent)) {\n+          } else if (parent.isAssign()) {\n             nameNode = parent.getFirstChild();\n           } else {\n             nameNode = node.getFirstChild();\n           }\n-        } else if (NodeUtil.isCall(node) || NodeUtil.isNew(node)) {\n+        } else if (node.isCall() || node.isNew()) {\n           nameNode = node.getFirstChild();\n         }\n \n                         (type != null) ? type.toString() : \"null\"));\n         }\n \n-        if (NodeUtil.isGetProp(node)) {\n+        if (node.isGetProp()) {\n           Node child = node.getFirstChild();\n-          if (NodeUtil.isName(child) && child.getString().endsWith(\"$self\")) {\n+          if (child.isName() && child.getString().endsWith(\"$self\")) {\n             JSType type = child.getJSType();\n             typeInformation.add(\n                 Joiner.on(\"\").join(\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n     Node StatementNode = root.getFirstChild();\n     assertTrue(NodeUtil.isExpressionNode(StatementNode));\n     Node functionNode = StatementNode.getFirstChild();\n-    assertTrue(NodeUtil.isFunction(functionNode));\n+    assertTrue(functionNode.isFunction());\n     assertTrue(NodeUtil.isFunctionExpression(functionNode));\n   }\n \n   public void testIsFunctionExpression2() {\n     Node root = parse(\"function foo() {}\");\n     Node functionNode = root.getFirstChild();\n-    assertTrue(NodeUtil.isFunction(functionNode));\n+    assertTrue(functionNode.isFunction());\n     assertFalse(NodeUtil.isFunctionExpression(functionNode));\n   }\n \n     Node parent = new Node(Token.BLOCK, n);\n     parent.putProp(Node.SOURCENAME_PROP, \"foo\");\n     assertEquals(\"foo\", NodeUtil.getSourceName(n));\n-  }\n-\n-  public void testIsLabelName() {\n-    Compiler compiler = new Compiler();\n-\n-    // Test removing the initializer.\n-    String code = \"a:while(1) {a; continue a; break a; break;}\";\n-    Node actual = parse(code);\n-\n-    Node labelNode = actual.getFirstChild();\n-    assertTrue(labelNode.getType() == Token.LABEL);\n-    assertTrue(NodeUtil.isLabelName(labelNode.getFirstChild()));\n-    assertFalse(NodeUtil.isLabelName(labelNode.getLastChild()));\n-\n-    Node whileNode = labelNode.getLastChild();\n-    assertTrue(whileNode.getType() == Token.WHILE);\n-    Node whileBlock = whileNode.getLastChild();\n-    assertTrue(whileBlock.getType() == Token.BLOCK);\n-    assertFalse(NodeUtil.isLabelName(whileBlock));\n-\n-    Node firstStatement = whileBlock.getFirstChild();\n-    assertTrue(firstStatement.getType() == Token.EXPR_RESULT);\n-    Node variableReference = firstStatement.getFirstChild();\n-    assertTrue(variableReference.getType() == Token.NAME);\n-    assertFalse(NodeUtil.isLabelName(variableReference));\n-\n-    Node continueStatement = firstStatement.getNext();\n-    assertTrue(continueStatement.getType() == Token.CONTINUE);\n-    assertTrue(NodeUtil.isLabelName(continueStatement.getFirstChild()));\n-\n-    Node firstBreak = continueStatement.getNext();\n-    assertTrue(firstBreak.getType() == Token.BREAK);\n-    assertTrue(NodeUtil.isLabelName(firstBreak.getFirstChild()));\n-\n-    Node secondBreak = firstBreak.getNext();\n-    assertTrue(secondBreak.getType() == Token.BREAK);\n-    assertFalse(secondBreak.hasChildren());\n-    assertFalse(NodeUtil.isLabelName(secondBreak.getFirstChild()));\n   }\n \n   public void testLocalValue1() throws Exception {\n--- a/test/com/google/javascript/jscomp/ParallelCompilerPassTest.java\n+++ b/test/com/google/javascript/jscomp/ParallelCompilerPassTest.java\n           new AbstractPostOrderCallback() {\n             @Override\n             public void visit(NodeTraversal t, Node n, Node parent) {\n-              if ((NodeUtil.isString(n) || NodeUtil.isName(n))\n+              if ((n.isString() || n.isName())\n                   && n.getString().equals(\"foo\")) {\n                 n.setString(\"bar\");\n               }\n--- a/test/com/google/javascript/jscomp/SimpleFunctionAliasAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/SimpleFunctionAliasAnalysisTest.java\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (NodeUtil.isFunction(n)\n+      if (n.isFunction()\n           && target.equals(NodeUtil.getFunctionName(n))) {\n         found = n;\n       }\n--- a/test/com/google/javascript/jscomp/SpecializeModuleTest.java\n+++ b/test/com/google/javascript/jscomp/SpecializeModuleTest.java\n \n       @Override\n       public void visit(NodeTraversal t, Node n, Node parent) {\n-        if (NodeUtil.isFunction(n)\n+        if (n.isFunction()\n             && target.equals(NodeUtil.getFunctionName(n))) {\n           found = n;\n         }\n--- a/test/com/google/javascript/jscomp/VarCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VarCheckTest.java\n           new AbstractPostOrderCallback() {\n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (NodeUtil.isName(n) && !NodeUtil.isFunction(parent)\n+          if (n.isName() && !parent.isFunction()\n               && parent.getType() != Token.LABEL) {\n             assertTrue(\"Variable \" + n.getString() + \" should have be declared\",\n                 t.getScope().isDeclared(n.getString(), true));\n--- a/test/com/google/javascript/jscomp/VariableVisibilityAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/VariableVisibilityAnalysisTest.java\n       VariableVisibility visibility) {\n     Node labeledVariable = searchLabel(label);\n \n-    Preconditions.checkState(NodeUtil.isVar(labeledVariable));\n+    Preconditions.checkState(labeledVariable.isVar());\n \n     // VAR\n     //   NAME\n \n       @Override\n       public void visit(NodeTraversal t, Node n, Node parent) {\n-        if (NodeUtil.isFunction(n)\n+        if (n.isFunction()\n             && functionName.equals(NodeUtil.getFunctionName(n))) {\n           foundNode[0] = n;\n         }", "timestamp": 1320875504, "metainfo": ""}