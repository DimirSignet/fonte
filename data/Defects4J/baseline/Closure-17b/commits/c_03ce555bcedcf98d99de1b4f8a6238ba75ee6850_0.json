{"sha": "03ce555bcedcf98d99de1b4f8a6238ba75ee6850", "log": "Simplify the type system a bit by pulling extern info off the nodes  R=johnlenz DELTA=171  (4 added, 42 deleted, 125 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2500   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n       FunctionType childCtor, SubclassType type) {\n     if (type == SubclassType.INHERITS) {\n       childCtor.defineDeclaredProperty(\"superClass_\",\n-          parentCtor.getPrototype(), false, parentCtor.getSource());\n+          parentCtor.getPrototype(), parentCtor.getSource());\n       childCtor.getPrototype().defineDeclaredProperty(\"constructor\",\n-          childCtor, false, parentCtor.getSource());\n+          childCtor, parentCtor.getSource());\n     }\n   }\n \n   @Override\n   public void applySingletonGetter(FunctionType functionType,\n       FunctionType getterType, ObjectType objectType) {\n-    functionType.defineDeclaredProperty(\"getInstance\", getterType, false,\n+    functionType.defineDeclaredProperty(\"getInstance\", getterType,\n         functionType.getSource());\n-    functionType.defineDeclaredProperty(\"instance_\", objectType, false,\n+    functionType.defineDeclaredProperty(\"instance_\", objectType,\n         functionType.getSource());\n   }\n \n--- a/src/com/google/javascript/jscomp/InferJSDocInfo.java\n+++ b/src/com/google/javascript/jscomp/InferJSDocInfo.java\n               // Put the JSDoc in the property slot, if there is one.\n               String propName = n.getLastChild().getString();\n               if (lhsType.hasOwnProperty(propName)) {\n-                lhsType.setPropertyJSDocInfo(propName, docInfo, inExterns);\n+                lhsType.setPropertyJSDocInfo(propName, docInfo);\n               }\n \n               // Put the JSDoc in any constructors or function shapes as well.\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n             !objectType.isInstanceType()) {\n           if (\"prototype\".equals(propName)) {\n             objectType.defineDeclaredProperty(\n-                propName, rightType, false, getprop);\n+                propName, rightType, getprop);\n           } else {\n             objectType.defineInferredProperty(\n-                propName, rightType, false, getprop);\n+                propName, rightType, getprop);\n           }\n         } else {\n           if (getprop.getFirstChild().getType() == Token.THIS &&\n               getJSType(syntacticScope.getRootNode()).isConstructor()) {\n             objectType.defineInferredProperty(\n-                propName, rightType, false, getprop);\n+                propName, rightType, getprop);\n           } else {\n             registry.registerPropertyOnType(propName, objectType);\n           }\n              (!objectType.isInstanceType() ||\n                  (var.isExtern() && !objectType.isNativeObjectType())))) {\n           return objectType.defineDeclaredProperty(\n-              propName, var.getType(), var.isExtern(), getprop);\n+              propName, var.getType(), getprop);\n         }\n       }\n     }\n         if (valueType == null) {\n           valueType = getNativeType(UNKNOWN_TYPE);\n         }\n-        objectType.defineInferredProperty(memberName, valueType, false, name);\n+        objectType.defineInferredProperty(memberName, valueType, name);\n       } else {\n         n.setJSType(getNativeType(UNKNOWN_TYPE));\n       }\n               typeToInfer =\n                   getNativeType(VOID_TYPE).getLeastSupertype(propType);\n             }\n-            objType.defineInferredProperty(prop, typeToInfer, false, null);\n+            objType.defineInferredProperty(prop, typeToInfer, null);\n           }\n         }\n       }\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n             // Declare this property on its object literal.\n             boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n             objLitType.defineDeclaredProperty(\n-                memberName, keyType, isExtern, keyNode);\n+                memberName, keyType, keyNode);\n           }\n         }\n       }\n                 type == null ?\n                     getNativeType(JSTypeNative.NO_TYPE) :\n                     type,\n-                isExtern, n);\n+                 n);\n           } else {\n-            globalThis.defineDeclaredProperty(variableName, type, isExtern, n);\n+            globalThis.defineDeclaredProperty(variableName, type, n);\n           }\n         }\n \n               ((isExtern && !ownerType.isNativeObjectType()) ||\n                !ownerType.isInstanceType())) {\n             // If the property is undeclared or inferred, declare it now.\n-            ownerType.defineDeclaredProperty(propName, valueType, isExtern, n);\n+            ownerType.defineDeclaredProperty(propName, valueType, n);\n           }\n         }\n \n           // If this is a stub for a prototype, just declare it\n           // as an unknown type. These are seen often in externs.\n           ownerType.defineInferredProperty(\n-              propName, unknownType, isExtern, n);\n+              propName, unknownType, n);\n         } else {\n           typeRegistry.registerPropertyOnType(\n               propName, ownerType == null ? unknownType : ownerType);\n           thisType.defineDeclaredProperty(\n               name.getString(),\n               jsType,\n-              false /* functions with implementations are not in externs */,\n               member);\n         }\n       }\n--- a/src/com/google/javascript/rhino/jstype/EnumElementType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumElementType.java\n \n   @Override\n   boolean defineProperty(String propertyName, JSType type,\n-      boolean inferred, boolean inExterns, Node propertyNode) {\n+      boolean inferred, Node propertyNode) {\n     // nothing\n     return true;\n   }\n--- a/src/com/google/javascript/rhino/jstype/EnumType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumType.java\n    */\n   public boolean defineElement(String name, Node definingNode) {\n     elements.add(name);\n-    return defineDeclaredProperty(name, elementsType, false, definingNode);\n+    return defineDeclaredProperty(name, elementsType, definingNode);\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n                 new FunctionBuilder(registry)\n                     .withReturnType(getReturnType())\n                     .build(),\n-                false, source);\n+                source);\n           } else {\n             params = params.cloneTree();\n             Node thisTypeNode = Node.newString(Token.NAME, \"thisType\");\n                     .withParamsNode(params)\n                     .withReturnType(getReturnType())\n                     .build(),\n-                false, source);\n+                source);\n           }\n         } else if (\"apply\".equals(name)) {\n           // Define the \"apply\" function lazily.\n                   .withParams(builder)\n                   .withReturnType(getReturnType())\n                   .build(),\n-              false, source);\n+              source);\n         }\n       }\n \n \n   @Override\n   boolean defineProperty(String name, JSType type,\n-      boolean inferred, boolean inExterns, Node propertyNode) {\n+      boolean inferred, Node propertyNode) {\n     if (\"prototype\".equals(name)) {\n       ObjectType objType = type.toObjectType();\n       if (objType != null) {\n         return false;\n       }\n     }\n-    return super.defineProperty(name, type, inferred, inExterns, propertyNode);\n+    return super.defineProperty(name, type, inferred, propertyNode);\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n \n   @Override\n   boolean defineProperty(String name, JSType type, boolean inferred,\n-      boolean inExterns, Node propertyNode) {\n+      Node propertyNode) {\n     ObjectType proto = getImplicitPrototype();\n     if (proto != null && proto.hasOwnDeclaredProperty(name)) {\n       return false;\n     }\n-    return super.defineProperty(name, type, inferred, inExterns, propertyNode);\n+    return super.defineProperty(name, type, inferred, propertyNode);\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n             createArrowType(createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE),\n             null, null, true, true);\n     OBJECT_FUNCTION_TYPE.defineDeclaredProperty(\n-        \"prototype\", TOP_LEVEL_PROTOTYPE, true, null);\n+        \"prototype\", TOP_LEVEL_PROTOTYPE, null);\n     registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE, OBJECT_FUNCTION_TYPE);\n \n     ObjectType OBJECT_PROTOTYPE = OBJECT_FUNCTION_TYPE.getPrototype();\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n \n   @Override\n   boolean defineProperty(String propertyName, JSType type,\n-      boolean inferred, boolean inExterns, Node propertyNode) {\n+      boolean inferred, Node propertyNode) {\n     if (!isResolved()) {\n       // If this is an unresolved object type, we need to save all its\n       // properties and define them when it is resolved.\n       }\n       propertyContinuations.add(\n           new PropertyContinuation(\n-              propertyName, type, inferred, inExterns, propertyNode));\n+              propertyName, type, inferred, propertyNode));\n       return true;\n     } else {\n       return super.defineProperty(\n-          propertyName, type, inferred, inExterns, propertyNode);\n+          propertyName, type, inferred, propertyNode);\n     }\n   }\n \n     private final String propertyName;\n     private final JSType type;\n     private final boolean inferred;\n-    private final boolean inExterns;\n     private final Node propertyNode;\n \n     private PropertyContinuation(\n         String propertyName,\n         JSType type,\n         boolean inferred,\n-        boolean inExterns,\n         Node propertyNode) {\n       this.propertyName = propertyName;\n       this.type = type;\n       this.inferred = inferred;\n-      this.inExterns = inExterns;\n       this.propertyNode = propertyNode;\n     }\n \n     void commit(ObjectType target) {\n       target.defineProperty(\n-          propertyName, type, inferred, inExterns, propertyNode);\n+          propertyName, type, inferred, propertyNode);\n     }\n   }\n }\n--- a/src/com/google/javascript/rhino/jstype/NoObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/NoObjectType.java\n \n   @Override\n   boolean defineProperty(String propertyName, JSType type,\n-      boolean inferred, boolean inExterns, Node propertyNode) {\n+      boolean inferred, Node propertyNode) {\n     // nothing, all properties are defined\n     return true;\n   }\n   }\n \n   @Override\n-  public void setPropertyJSDocInfo(String propertyName, JSDocInfo info,\n-      boolean inExterns) {\n+  public void setPropertyJSDocInfo(String propertyName, JSDocInfo info) {\n     // Do nothing, specific properties do not have JSDocInfo.\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n    * Defines a property whose type is synthesized (i.e. not inferred).\n    * @param propertyName the property's name\n    * @param type the type\n-   * @param inExterns {@code true} if this property was defined in an externs\n-   *        file. TightenTypes assumes that any function passed to an externs\n-   *        property could be called, so setting this incorrectly could result\n-   *        in live code being removed.\n    * @param propertyNode the node corresponding to the declaration of property\n    *        which might later be accessed using {@code getPropertyNode}.\n    */\n   public final boolean defineDeclaredProperty(String propertyName,\n-      JSType type, boolean inExterns, Node propertyNode) {\n-    boolean result = defineProperty(propertyName, type, false, inExterns,\n+      JSType type, Node propertyNode) {\n+    boolean result = defineProperty(propertyName, type, false,\n         propertyNode);\n \n     // All property definitions go through this method\n    * Defines a property whose type is inferred.\n    * @param propertyName the property's name\n    * @param type the type\n-   * @param inExterns {@code true} if this property was defined in an externs\n-   *        file. TightenTypes assumes that any function passed to an externs\n-   *        property could be called, so setting this incorrectly could result\n-   *        in live code being removed.\n    * @param propertyNode the node corresponding to the inferred definition of\n    *        property that might later be accessed using {@code getPropertyNode}.\n    */\n   public final boolean defineInferredProperty(String propertyName,\n-      JSType type, boolean inExterns, Node propertyNode) {\n+      JSType type, Node propertyNode) {\n     if (hasProperty(propertyName)) {\n       JSType originalType = getPropertyType(propertyName);\n       type = originalType == null ? type :\n           originalType.getLeastSupertype(type);\n     }\n \n-    boolean result = defineProperty(propertyName, type, true, inExterns,\n+    boolean result = defineProperty(propertyName, type, true,\n         propertyNode);\n \n     // All property definitions go through this method\n    * @param propertyName the property's name\n    * @param type the type\n    * @param inferred {@code true} if this property's type is inferred\n-   * @param inExterns {@code true} if this property was defined in an externs\n-   *        file. TightenTypes assumes that any function passed to an externs\n-   *        property could be called, so setting this incorrectly could result\n-   *        in live code being removed.\n    * @param propertyNode the node that represents the definition of property.\n    *        Depending on the actual sub-type the node type might be different.\n    *        The general idea is to have an estimate of where in the source code\n    *        conflicts with a previous property type declaration.\n    */\n   abstract boolean defineProperty(String propertyName, JSType type,\n-      boolean inferred, boolean inExterns, Node propertyNode);\n+      boolean inferred, Node propertyNode);\n \n   /**\n    * Gets the node corresponding to the definition of the specified property.\n    * {@link JSDocInfo} on its definition.\n    * @param info {@code JSDocInfo} for the property definition. May be\n    *        {@code null}.\n-   * @param inExterns {@code true} if this property was defined in an externs\n-   *        file. TightenTypes assumes that any function passed to an externs\n-   *        property could be called, so setting this incorrectly could result\n-   *        in live code being removed.\n-   */\n-  public void setPropertyJSDocInfo(String propertyName, JSDocInfo info,\n-                                   boolean inExterns) {\n+   */\n+  public void setPropertyJSDocInfo(String propertyName, JSDocInfo info) {\n     // by default, do nothing\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n   public boolean isPropertyInExterns(String propertyName) {\n     Property p = properties.get(propertyName);\n     if (p != null) {\n-      return p.inExterns;\n+      return p.isFromExterns();\n     }\n     ObjectType implicitPrototype = getImplicitPrototype();\n     if (implicitPrototype != null) {\n \n   @Override\n   boolean defineProperty(String name, JSType type, boolean inferred,\n-      boolean inExterns, Node propertyNode) {\n+      Node propertyNode) {\n     if (hasOwnDeclaredProperty(name)) {\n       return false;\n     }\n     Property newProp = new Property(\n-        name, type, inferred, inExterns, propertyNode);\n+        name, type, inferred, propertyNode);\n     Property oldProp = properties.get(name);\n     if (oldProp != null) {\n       // This is to keep previously inferred jsdoc info, e.g., in a\n   }\n \n   @Override\n-  public void setPropertyJSDocInfo(String propertyName, JSDocInfo info,\n-      boolean inExterns) {\n+  public void setPropertyJSDocInfo(String propertyName, JSDocInfo info) {\n     if (info != null) {\n       if (!properties.containsKey(propertyName)) {\n         // If docInfo was attached, but the type of the property\n         // was not defined anywhere, then we consider this an explicit\n         // declaration of the property.\n         defineInferredProperty(propertyName, getPropertyType(propertyName),\n-            inExterns, null);\n+            null);\n       }\n \n       // The prototype property is not represented as a normal Property.\n     private final boolean inferred;\n \n     /**\n-     * Whether the property is defined in the externs.\n-     */\n-    private final boolean inExterns;\n-\n-    /**\n      * The node corresponding to this property, e.g., a GETPROP node that\n      * declares this property.\n      */\n     private JSDocInfo docInfo = null;\n \n     private Property(String name, JSType type, boolean inferred,\n-        boolean inExterns, Node propertyNode) {\n+        Node propertyNode) {\n       this.name = name;\n       this.type = type;\n       this.inferred = inferred;\n-      this.inExterns = inExterns;\n       this.propertyNode = propertyNode;\n     }\n \n     @Override\n     public boolean isTypeInferred() {\n       return inferred;\n+    }\n+\n+    boolean isFromExterns() {\n+      return propertyNode == null ? false : propertyNode.isFromExterns();\n     }\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n \n   @Override\n   boolean defineProperty(String propertyName, JSType type,\n-      boolean inferred, boolean inExterns, Node propertyNode) {\n+      boolean inferred, Node propertyNode) {\n     return referencedObjType == null ? true :\n         referencedObjType.defineProperty(\n-            propertyName, type, inferred, inExterns, propertyNode);\n+            propertyName, type, inferred, propertyNode);\n   }\n \n   @Override\n   }\n \n   @Override\n-  public void setPropertyJSDocInfo(String propertyName, JSDocInfo info,\n-      boolean inExterns) {\n+  public void setPropertyJSDocInfo(String propertyName, JSDocInfo info) {\n     if (referencedObjType != null) {\n-      referencedObjType.setPropertyJSDocInfo(propertyName, info, inExterns);\n+      referencedObjType.setPropertyJSDocInfo(propertyName, info);\n     }\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n         throw new IllegalStateException(\n             \"RecordProperty associated with a property should not be null!\");\n       }\n-      defineDeclaredProperty(property, prop.getType(), false, prop.getPropertyNode());\n+      defineDeclaredProperty(property, prop.getType(), prop.getPropertyNode());\n     }\n \n     // Freeze the record type.\n \n   @Override\n   boolean defineProperty(String propertyName, JSType type,\n-      boolean inferred, boolean inExterns, Node propertyNode) {\n+      boolean inferred, Node propertyNode) {\n     if (isFrozen) {\n       return false;\n     }\n       properties.put(propertyName, type);\n     }\n \n-    return super.defineProperty(propertyName, type, inferred, inExterns,\n+    return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/UnknownType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnknownType.java\n \n   @Override\n   boolean defineProperty(String propertyName, JSType type,\n-      boolean inferred, boolean inExterns, Node propertyNode) {\n+      boolean inferred, Node propertyNode) {\n     // nothing to define\n     return true;\n   }\n--- a/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n+++ b/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n     addMethod(registry, arrayPrototype, \"sort\", arrayType);\n     addMethod(registry, arrayPrototype, \"splice\", arrayType);\n     addMethod(registry, arrayPrototype, \"unshift\", numberType);\n-    arrayType.defineDeclaredProperty(\"length\", numberType, true, null);\n+    arrayType.defineDeclaredProperty(\"length\", numberType, null);\n \n     ObjectType booleanPrototype = registry\n         .getNativeFunctionType(JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE)\n         registry.createNullableType(arrayType));\n     addMethod(registry, regexpPrototype, \"test\", booleanType);\n     addMethod(registry, regexpPrototype, \"toString\", stringType);\n-    regexpType.defineDeclaredProperty(\"source\", stringType, true, null);\n-    regexpType.defineDeclaredProperty(\"global\", booleanType, true, null);\n-    regexpType.defineDeclaredProperty(\"ignoreCase\", booleanType, true, null);\n-    regexpType.defineDeclaredProperty(\"multiline\", booleanType, true, null);\n-    regexpType.defineDeclaredProperty(\"lastIndex\", numberType, true, null);\n+    regexpType.defineDeclaredProperty(\"source\", stringType, null);\n+    regexpType.defineDeclaredProperty(\"global\", booleanType, null);\n+    regexpType.defineDeclaredProperty(\"ignoreCase\", booleanType, null);\n+    regexpType.defineDeclaredProperty(\"multiline\", booleanType, null);\n+    regexpType.defineDeclaredProperty(\"lastIndex\", numberType, null);\n \n     ObjectType stringPrototype = registry\n         .getNativeFunctionType(JSTypeNative.STRING_OBJECT_FUNCTION_TYPE)\n     addMethod(registry, stringPrototype, \"toLocaleLowerCase\", stringType);\n     addMethod(registry, stringPrototype, \"toUpperCase\", stringType);\n     addMethod(registry, stringPrototype, \"toLocaleUpperCase\", stringType);\n-    stringObjectType.defineDeclaredProperty(\"length\", numberType, true, null);\n+    stringObjectType.defineDeclaredProperty(\"length\", numberType, null);\n   }\n \n   private static void addMethod(\n       JSType returnType) {\n     receivingType.defineDeclaredProperty(methodName,\n         new FunctionBuilder(registry).withReturnType(returnType).build(),\n-        true, null);\n+        null);\n   }\n \n   protected JSType createUnionType(JSType... variants) {\n--- a/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n+++ b/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n     ObjectType objType = typeRegistry.createObjectType(name, null,\n         typeRegistry.createObjectType(name + \".prototype\", null, null));\n     for (int i = 0; i < propNames.length; ++i) {\n-      objType.defineDeclaredProperty(propNames[i], unknownType, false, null);\n+      objType.defineDeclaredProperty(propNames[i], unknownType, null);\n     }\n     return new ConcreteInstanceType(factory, objType);\n   }\n--- a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n     FunctionType ctor = registry.createConstructorType(\n         \"Foo\", null, null, null);\n     assertFalse(ctor.getInstanceType().isUnknownType());\n-    ctor.defineDeclaredProperty(\"prototype\", UNKNOWN_TYPE, false, null);\n+    ctor.defineDeclaredProperty(\"prototype\", UNKNOWN_TYPE, null);\n     assertTrue(ctor.getInstanceType().isUnknownType());\n   }\n \n   public void testInterfacePrototypeChain2() {\n     FunctionType iface = registry.createInterfaceType(\"I\", null);\n     iface.getPrototype().defineDeclaredProperty(\n-        \"numberProp\", NUMBER_TYPE, false, null);\n+        \"numberProp\", NUMBER_TYPE, null);\n \n     FunctionType subIface = registry.createInterfaceType(\"SubI\", null);\n     subIface.setExtendedInterfaces(\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n     subInterfaceInstType = subInterfaceType.getInstanceType();\n \n     googBar = registry.createConstructorType(\"goog.Bar\", null, null, null);\n-    googBar.getPrototype().defineDeclaredProperty(\"date\", DATE_TYPE, true,\n+    googBar.getPrototype().defineDeclaredProperty(\"date\", DATE_TYPE,\n         null);\n     googBar.setImplementedInterfaces(\n         Lists.<ObjectType>newArrayList(interfaceInstType));\n     googSubSubBarInst = googSubSubBar.getInstanceType();\n \n     final ObjectType googObject = registry.createAnonymousObjectType();\n-    googObject.defineDeclaredProperty(\"Bar\", googBar, false, null);\n+    googObject.defineDeclaredProperty(\"Bar\", googBar, null);\n \n     namedGoogBar.resolve(null, new StaticScope<JSType>() {\n           public StaticSlot<JSType> getSlot(String name) {\n     JSType record = builder.build();\n \n     ObjectType subtypeProp = registry.createAnonymousObjectType();\n-    subtypeProp.defineInferredProperty(\"a\", googSubSubBarInst, false, null);\n+    subtypeProp.defineInferredProperty(\"a\", googSubSubBarInst, null);\n     assertTrue(subtypeProp.isSubtype(record));\n     assertFalse(record.isSubtype(subtypeProp));\n \n     ObjectType supertypeProp = registry.createAnonymousObjectType();\n-    supertypeProp.defineInferredProperty(\"a\", googBarInst, false, null);\n+    supertypeProp.defineInferredProperty(\"a\", googBarInst, null);\n     assertFalse(supertypeProp.isSubtype(record));\n     assertFalse(record.isSubtype(supertypeProp));\n \n     ObjectType declaredSubtypeProp = registry.createAnonymousObjectType();\n     declaredSubtypeProp.defineDeclaredProperty(\"a\", googSubSubBarInst,\n-        false, null);\n+        null);\n     assertFalse(declaredSubtypeProp.isSubtype(record));\n     assertFalse(record.isSubtype(declaredSubtypeProp));\n   }\n \n     // if Function is given a property \"a\" of type \"string\", then it's\n     // a subtype of the record type {a: string}.\n-    U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty(\"a\", STRING_TYPE, false, null);\n+    U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty(\"a\", STRING_TYPE, null);\n     assertTypeEquals(U2U_CONSTRUCTOR_TYPE,\n                  recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n     assertTypeEquals(U2U_CONSTRUCTOR_TYPE,\n \n     // if Function is given a property \"x\" of type \"string\", then it's\n     // also a subtype of the record type {x: ?}.\n-    U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty(\"x\", STRING_TYPE, false, null);\n+    U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty(\"x\", STRING_TYPE, null);\n     assertTypeEquals(U2U_CONSTRUCTOR_TYPE,\n                  recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n     assertTypeEquals(U2U_CONSTRUCTOR_TYPE,\n \n     // if Function is given a property \"x\" of type \"string\", then it's\n     // not a subtype of the record type {x: number}.\n-    U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty(\"x\", STRING_TYPE, false, null);\n+    U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty(\"x\", STRING_TYPE, null);\n     assertTypeEquals(NO_OBJECT_TYPE,\n                  recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n   }\n \n     // if goog.Bar is given a property \"xyz\" of type \"string\", then it's\n     // also a subtype of the record type {x: ?}.\n-    googBar.defineDeclaredProperty(\"xyz\", STRING_TYPE, false, null);\n+    googBar.defineDeclaredProperty(\"xyz\", STRING_TYPE, null);\n \n     assertTypeEquals(googBar,\n                  recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n     // adding one property on the prototype\n     ObjectType prototype =\n         (ObjectType) constructor.getPropertyType(\"prototype\");\n-    prototype.defineDeclaredProperty(\"foo\", DATE_TYPE, false, null);\n+    prototype.defineDeclaredProperty(\"foo\", DATE_TYPE, null);\n \n     assertEquals(NATIVE_PROPERTIES_COUNT + 1, instance.getPropertiesCount());\n   }\n \n     // replacing the prototype\n     ObjectType prototype = registry.createAnonymousObjectType();\n-    prototype.defineDeclaredProperty(\"foo\", DATE_TYPE, false, null);\n-    constructor.defineDeclaredProperty(\"prototype\", prototype, true, null);\n+    prototype.defineDeclaredProperty(\"foo\", DATE_TYPE, null);\n+    constructor.defineDeclaredProperty(\"prototype\", prototype, null);\n \n     assertEquals(NATIVE_PROPERTIES_COUNT + 1, instance.getPropertiesCount());\n   }\n \n   /** Tests assigning jsdoc on a prototype property. */\n   public void testJSDocOnPrototypeProperty() throws Exception {\n-    subclassCtor.setPropertyJSDocInfo(\"prototype\", new JSDocInfo(), true);\n+    subclassCtor.setPropertyJSDocInfo(\"prototype\", new JSDocInfo());\n     assertNull(subclassCtor.getOwnPropertyJSDocInfo(\"prototype\"));\n   }\n \n     ObjectType sup = registry.createAnonymousObjectType();\n     int nativeProperties = sup.getPropertiesCount();\n \n-    sup.defineDeclaredProperty(\"a\", DATE_TYPE, false, null);\n+    sup.defineDeclaredProperty(\"a\", DATE_TYPE, null);\n     assertEquals(nativeProperties + 1, sup.getPropertiesCount());\n \n-    sup.defineDeclaredProperty(\"b\", DATE_TYPE, false, null);\n+    sup.defineDeclaredProperty(\"b\", DATE_TYPE, null);\n     assertEquals(nativeProperties + 2, sup.getPropertiesCount());\n \n     ObjectType sub = registry.createObjectType(sup);\n \n     // Test declarations.\n     assertTrue(\n-        prototype.defineDeclaredProperty(\"declared\", NUMBER_TYPE, false, null));\n+        prototype.defineDeclaredProperty(\"declared\", NUMBER_TYPE, null));\n     assertFalse(\n-        prototype.defineDeclaredProperty(\"declared\", NUMBER_TYPE, false, null));\n+        prototype.defineDeclaredProperty(\"declared\", NUMBER_TYPE, null));\n     assertFalse(\n-        instance.defineDeclaredProperty(\"declared\", NUMBER_TYPE, false, null));\n+        instance.defineDeclaredProperty(\"declared\", NUMBER_TYPE, null));\n     assertTypeEquals(NUMBER_TYPE, instance.getPropertyType(\"declared\"));\n \n     // Test inferring different types.\n     assertTrue(prototype.defineInferredProperty(\"inferred1\", STRING_TYPE,\n-        false, null));\n+        null));\n     assertTrue(prototype.defineInferredProperty(\"inferred1\", NUMBER_TYPE,\n-        false, null));\n+        null));\n     assertTypeEquals(\n         createUnionType(NUMBER_TYPE, STRING_TYPE),\n         instance.getPropertyType(\"inferred1\"));\n \n     // Test inferring different types on different objects.\n     assertTrue(prototype.defineInferredProperty(\"inferred2\", STRING_TYPE,\n-        false, null));\n+        null));\n     assertTrue(instance.defineInferredProperty(\"inferred2\", NUMBER_TYPE,\n-        false, null));\n+        null));\n     assertTypeEquals(\n         createUnionType(NUMBER_TYPE, STRING_TYPE),\n         instance.getPropertyType(\"inferred2\"));\n \n     // Test inferring on the supertype and declaring on the subtype.\n     assertTrue(\n-        prototype.defineInferredProperty(\"prop\", STRING_TYPE, false, null));\n+        prototype.defineInferredProperty(\"prop\", STRING_TYPE, null));\n     assertTrue(\n-        instance.defineDeclaredProperty(\"prop\", NUMBER_TYPE, false, null));\n+        instance.defineDeclaredProperty(\"prop\", NUMBER_TYPE, null));\n     assertTypeEquals(NUMBER_TYPE, instance.getPropertyType(\"prop\"));\n     assertTypeEquals(STRING_TYPE, prototype.getPropertyType(\"prop\"));\n   }\n     ObjectType sup = registry.createAnonymousObjectType();\n     int nativeProperties = sup.getPropertiesCount();\n \n-    sup.defineDeclaredProperty(\"a\", OBJECT_TYPE, false, null);\n+    sup.defineDeclaredProperty(\"a\", OBJECT_TYPE, null);\n     assertEquals(nativeProperties + 1, sup.getPropertiesCount());\n \n     ObjectType sub = registry.createObjectType(sup);\n-    sub.defineDeclaredProperty(\"a\", OBJECT_TYPE, false, null);\n+    sub.defineDeclaredProperty(\"a\", OBJECT_TYPE, null);\n     assertEquals(nativeProperties + 1, sub.getPropertiesCount());\n-  }\n-\n-  public void testObjectTypeIsPropertyInExterns() {\n-    ObjectType sup =\n-        registry.createObjectType(registry.createAnonymousObjectType());\n-    ObjectType sub = registry.createObjectType(sup);\n-\n-    sup.defineProperty(\"externProp\", null, false, /* inExterns */ true, null);\n-    sub.defineProperty(\"externProp\", null, false, /* inExterns */ false, null);\n-\n-    assertTrue(sup.isPropertyInExterns(\"externProp\"));\n-    assertFalse(sub.isPropertyInExterns(\"externProp\"));\n   }\n \n   /**\n       if (type instanceof ObjectType) {\n \n         ObjectType objType = (ObjectType) type;\n-        objType.defineDeclaredProperty(propName, UNKNOWN_TYPE, false, null);\n-        objType.defineDeclaredProperty(\"allHaz\", UNKNOWN_TYPE, false, null);\n+        objType.defineDeclaredProperty(propName, UNKNOWN_TYPE, null);\n+        objType.defineDeclaredProperty(\"allHaz\", UNKNOWN_TYPE, null);\n \n         assertTypeEquals(type,\n             registry.getGreatestSubtypeWithProperty(type, propName));\n     ObjectType derived1 = registry.createObjectType(\"d1\", null, namedGoogBar);\n     ObjectType derived2 = registry.createObjectType(\"d2\", null, namedGoogBar);\n \n-    derived1.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, false, null);\n+    derived1.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, null);\n \n     assertTypeEquals(derived1,\n         registry.getGreatestSubtypeWithProperty(derived1, \"propz\"));\n     assertTypeEquals(NO_OBJECT_TYPE,\n         registry.getGreatestSubtypeWithProperty(derived2, \"propz\"));\n \n-    derived2.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, false, null);\n+    derived2.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, null);\n \n     assertTypeEquals(derived1,\n         registry.getGreatestSubtypeWithProperty(derived1, \"propz\"));\n     ObjectType foo = registry.createObjectType(\"foo\", null, OBJECT_TYPE);\n     ObjectType bar = registry.createObjectType(\"bar\", null, namedGoogBar);\n \n-    foo.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, false, null);\n-    bar.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, false, null);\n+    foo.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, null);\n+    bar.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, null);\n \n     assertTypeEquals(bar,\n         registry.getGreatestSubtypeWithProperty(namedGoogBar, \"propz\"));\n     // anonymous\n     ObjectType anonymous = registry.createAnonymousObjectType();\n     anonymous.defineDeclaredProperty(\n-        \"a\", NUMBER_TYPE, false, null);\n+        \"a\", NUMBER_TYPE, null);\n     anonymous.defineDeclaredProperty(\n-        \"b\", NUMBER_TYPE, false, null);\n+        \"b\", NUMBER_TYPE, null);\n     anonymous.defineDeclaredProperty(\n-        \"c\", NUMBER_TYPE, false, null);\n+        \"c\", NUMBER_TYPE, null);\n     anonymous.defineDeclaredProperty(\n-        \"d\", NUMBER_TYPE, false, null);\n+        \"d\", NUMBER_TYPE, null);\n     anonymous.defineDeclaredProperty(\n-        \"e\", NUMBER_TYPE, false, null);\n+        \"e\", NUMBER_TYPE, null);\n     anonymous.defineDeclaredProperty(\n-        \"f\", NUMBER_TYPE, false, null);\n+        \"f\", NUMBER_TYPE, null);\n     assertEquals(\"{a: number, b: number, c: number, d: number, ...}\",\n         anonymous.toString());\n   }\n         registry.createObjectType(registry.createAnonymousObjectType());\n     ObjectType sub = registry.createObjectType(sup);\n \n-    sup.defineProperty(\"base\", null, false, false, null);\n-    sub.defineProperty(\"sub\", null, false, false, null);\n+    sup.defineProperty(\"base\", null, false, null);\n+    sub.defineProperty(\"sub\", null, false, null);\n \n     assertTrue(sup.hasProperty(\"base\"));\n     assertFalse(sup.hasProperty(\"sub\"));\n \n   public void testNamedTypeHasOwnProperty() throws Exception {\n     namedGoogBar.getImplicitPrototype().defineProperty(\"base\", null, false,\n-        false, null);\n-    namedGoogBar.defineProperty(\"sub\", null, false, false, null);\n+        null);\n+    namedGoogBar.defineProperty(\"sub\", null, false, null);\n \n     assertFalse(namedGoogBar.hasOwnProperty(\"base\"));\n     assertTrue(namedGoogBar.hasProperty(\"base\"));\n   }\n \n   public void testInterfaceHasOwnProperty() throws Exception {\n-    interfaceInstType.defineProperty(\"base\", null, false, false, null);\n-    subInterfaceInstType.defineProperty(\"sub\", null, false, false, null);\n+    interfaceInstType.defineProperty(\"base\", null, false, null);\n+    subInterfaceInstType.defineProperty(\"sub\", null, false, null);\n \n     assertTrue(interfaceInstType.hasProperty(\"base\"));\n     assertFalse(interfaceInstType.hasProperty(\"sub\"));\n         registry.createObjectType(registry.createAnonymousObjectType());\n     ObjectType sub = registry.createObjectType(sup);\n \n-    sup.defineProperty(\"base\", null, false, false, null);\n-    sub.defineProperty(\"sub\", null, false, false, null);\n+    sup.defineProperty(\"base\", null, false, null);\n+    sub.defineProperty(\"sub\", null, false, null);\n \n     assertEquals(Sets.newHashSet(\"isPrototypeOf\", \"toLocaleString\",\n           \"propertyIsEnumerable\", \"toString\", \"valueOf\", \"hasOwnProperty\",\n     info.setDeprecated(true);\n \n     assertNull(namedGoogBar.getOwnPropertyJSDocInfo(\"X\"));\n-    namedGoogBar.setPropertyJSDocInfo(\"X\", info, false);\n+    namedGoogBar.setPropertyJSDocInfo(\"X\", info);\n     assertTrue(namedGoogBar.getOwnPropertyJSDocInfo(\"X\").isDeprecated());\n     assertPropertyTypeInferred(namedGoogBar, \"X\");\n     assertTypeEquals(UNKNOWN_TYPE, namedGoogBar.getPropertyType(\"X\"));\n     JSDocInfo privateInfo = new JSDocInfo();\n     privateInfo.setVisibility(Visibility.PRIVATE);\n \n-    sup.defineProperty(\"X\", NUMBER_TYPE, false, false, null);\n-    sup.setPropertyJSDocInfo(\"X\", privateInfo, false);\n-\n-    sub.setPropertyJSDocInfo(\"X\", deprecated, false);\n+    sup.defineProperty(\"X\", NUMBER_TYPE, false, null);\n+    sup.setPropertyJSDocInfo(\"X\", privateInfo);\n+\n+    sub.setPropertyJSDocInfo(\"X\", deprecated);\n \n     assertFalse(sup.getOwnPropertyJSDocInfo(\"X\").isDeprecated());\n     assertEquals(Visibility.PRIVATE,\n     JSDocInfo deprecated = new JSDocInfo();\n     deprecated.setDeprecated(true);\n \n-    NO_TYPE.setPropertyJSDocInfo(\"X\", deprecated, false);\n+    NO_TYPE.setPropertyJSDocInfo(\"X\", deprecated);\n     assertNull(NO_TYPE.getOwnPropertyJSDocInfo(\"X\"));\n   }\n \n--- a/test/com/google/javascript/rhino/jstype/NamedTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/NamedTypeTest.java\n         \"TypeA\", null, null, null);\n     ObjectType typeA = ctorA.getInstanceType();\n \n-    namedA.defineDeclaredProperty(\"foo\", NUMBER_TYPE, false, null);\n+    namedA.defineDeclaredProperty(\"foo\", NUMBER_TYPE, null);\n     namedA.resolve(\n         null,\n         new MapBasedScope(", "timestamp": 1309554040, "metainfo": ""}