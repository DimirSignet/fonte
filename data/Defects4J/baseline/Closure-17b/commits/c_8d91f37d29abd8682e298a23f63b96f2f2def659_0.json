{"sha": "8d91f37d29abd8682e298a23f63b96f2f2def659", "log": "Improve inference for functions defined in constructors  Fixes issue 765  R=acleung DELTA=132  (88 added, 20 deleted, 24 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5093   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n \n   private JSType getPropertyType(JSType objType, String propName,\n       Node n, FlowScope scope) {\n+    // We often have a couple of different types to choose from for the\n+    // property. Ordered by accuracy, we have\n+    // 1) A locally inferred qualified name (which is in the FlowScope)\n+    // 2) A globally declared qualified name (which is in the FlowScope)\n+    // 3) A property on the owner type (which is on objType)\n+    // 4) A name in the type registry (as a last resort)\n+    JSType unknownType = getNativeType(UNKNOWN_TYPE);\n+    JSType propertyType = null;\n+    boolean isLocallyInferred = false;\n+\n     // Scopes sometimes contain inferred type info about qualified names.\n     String qualifiedName = n.getQualifiedName();\n     StaticSlot<JSType> var = scope.getSlot(qualifiedName);\n     if (var != null) {\n       JSType varType = var.getType();\n       if (varType != null) {\n-        if (varType.equals(getNativeType(UNKNOWN_TYPE)) &&\n-            var != syntacticScope.getSlot(qualifiedName)) {\n-          // If the type of this qualified name has been checked in this scope,\n-          // then use CHECKED_UNKNOWN_TYPE instead to indicate that.\n-          return getNativeType(CHECKED_UNKNOWN_TYPE);\n-        } else {\n-          return varType;\n-        }\n-      }\n-    }\n-\n-    JSType propertyType = null;\n-    if (objType != null) {\n-      propertyType = objType.findPropertyType(propName);\n-    }\n-\n-    if ((propertyType == null || propertyType.isUnknownType()) &&\n-        qualifiedName != null) {\n+        boolean isDeclared = !var.isTypeInferred();\n+        isLocallyInferred = (var != syntacticScope.getSlot(qualifiedName));\n+        if (isDeclared || isLocallyInferred) {\n+          propertyType = varType;\n+        }\n+      }\n+    }\n+\n+    if (propertyType == null && objType != null) {\n+      JSType foundType = objType.findPropertyType(propName);\n+      if (foundType != null) {\n+        propertyType = foundType;\n+      }\n+    }\n+\n+    if ((propertyType == null || propertyType.isUnknownType())\n+        && qualifiedName != null) {\n       // If we find this node in the registry, then we can infer its type.\n       ObjectType regType = ObjectType.cast(registry.getType(qualifiedName));\n       if (regType != null) {\n       }\n     }\n \n-    return propertyType;\n+    if (propertyType == null) {\n+      return getNativeType(UNKNOWN_TYPE);\n+    } else if (propertyType.equals(unknownType) && isLocallyInferred) {\n+      // If the type has been checked in this scope,\n+      // then use CHECKED_UNKNOWN_TYPE instead to indicate that.\n+      return getNativeType(CHECKED_UNKNOWN_TYPE);\n+    } else {\n+      return propertyType;\n+    }\n   }\n \n   private BooleanOutcomePair traverseOr(Node n, FlowScope scope) {\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n                 info, ownerType.getOwnerFunction().getInstanceType());\n             searchedForThisType = true;\n           } else if (ownerNode != null && ownerNode.isThis()) {\n-            builder.inferThisType(info, ownerNode.getJSType());\n+            // If 'this' has a type, use that instead.\n+            // This is a hack, necessary because CollectProperties (below)\n+            // doesn't run with the scope that it's building,\n+            // so scope.getTypeOfThis() will be wrong.\n+            JSType injectedThisType = ownerNode.getJSType();\n+            builder.inferThisType(\n+                info,\n+                injectedThisType == null ?\n+                scope.getTypeOfThis() : injectedThisType);\n             searchedForThisType = true;\n           }\n \n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"Property name2 never defined on rec\");\n   }\n \n+  public void testIssue765() throws Exception {\n+    testTypes(\n+        \"/** @constructor */\" +\n+        \"var AnotherType = function (parent) {\" +\n+        \"    /** @param {string} stringParameter Description... */\" +\n+        \"    this.doSomething = function (stringParameter) {};\" +\n+        \"};\" +\n+        \"/** @constructor */\" +\n+        \"var YetAnotherType = function () {\" +\n+        \"    this.field = new AnotherType(self);\" +\n+        \"    this.testfun=function(stringdata) {\" +\n+        \"        this.field.doSomething(null);\" +\n+        \"    };\" +\n+        \"};\",\n+        \"actual parameter 1 of AnotherType.doSomething \" +\n+        \"does not match formal parameter\\n\" +\n+        \"found   : null\\n\" +\n+        \"required: string\");\n+  }\n+\n   /**\n    * Tests that the || operator is type checked correctly, that is of\n    * the type of the first argument or of the second argument. See\n--- a/test/com/google/javascript/jscomp/TypeInferenceTest.java\n+++ b/test/com/google/javascript/jscomp/TypeInferenceTest.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.ALL_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.CHECKED_UNKNOWN_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_INSTANCE_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_OBJECT_TYPE;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n+import com.google.javascript.rhino.jstype.ObjectType;\n import com.google.javascript.rhino.jstype.StaticSlot;\n import com.google.javascript.rhino.testing.Asserts;\n \n \n   private Compiler compiler;\n   private JSTypeRegistry registry;\n-  private Map<String,JSType> assumptions;\n+  private Map<String, JSType> assumptions;\n+  private JSType assumedThisType;\n   private FlowScope returnScope;\n   private static final Map<String, AssertionFunctionSpec>\n       ASSERTION_FUNCTION_MAP = Maps.newHashMap();\n     returnScope = null;\n   }\n \n+  private void assumingThisType(JSType type) {\n+    assumedThisType = type;\n+  }\n+\n   private void assuming(String name, JSType type) {\n     assumptions.put(name, type);\n   }\n \n   private void inFunction(String js) {\n     // Parse the body of the function.\n-    Node root = compiler.parseTestCode(\"(function() {\" + js + \"});\");\n+    String thisBlock = assumedThisType == null\n+        ? \"\"\n+        : \"/** @this {\" + assumedThisType + \"} */\";\n+    Node root = compiler.parseTestCode(\n+        \"(\" + thisBlock + \" function() {\" + js + \"});\");\n     assertEquals(\"parsing error: \" +\n         Joiner.on(\", \").join(compiler.getErrors()),\n         0, compiler.getErrorCount());\n     Scope assumedScope = scopeCreator.createScope(\n         n, scopeCreator.createScope(root, null));\n     for (Map.Entry<String,JSType> entry : assumptions.entrySet()) {\n-      assumedScope.declare(entry.getKey(), null, entry.getValue(), null);\n+      assumedScope.declare(entry.getKey(), null, entry.getValue(), null, false);\n     }\n     // Create the control graph.\n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false);\n     assuming(\"x\", createNullableType(OBJECT_TYPE));\n     inFunction(\"var y = 1; if (x) { y = x; }\");\n     verify(\"y\", createUnionType(OBJECT_TYPE, NUMBER_TYPE));\n+  }\n+\n+  public void testPropertyInference1() {\n+    ObjectType thisType = registry.createAnonymousObjectType();\n+    thisType.defineDeclaredProperty(\"foo\",\n+        createUndefinableType(STRING_TYPE), null);\n+    assumingThisType(thisType);\n+    inFunction(\"var y = 1; if (this.foo) { y = this.foo; }\");\n+    verify(\"y\", createUnionType(NUMBER_TYPE, STRING_TYPE));\n+  }\n+\n+  public void testPropertyInference2() {\n+    ObjectType thisType = registry.createAnonymousObjectType();\n+    thisType.defineDeclaredProperty(\"foo\",\n+        createUndefinableType(STRING_TYPE), null);\n+    assumingThisType(thisType);\n+    inFunction(\"var y = 1; this.foo = 'x'; y = this.foo;\");\n+    verify(\"y\", STRING_TYPE);\n+  }\n+\n+  public void testPropertyInference3() {\n+    ObjectType thisType = registry.createAnonymousObjectType();\n+    thisType.defineDeclaredProperty(\"foo\",\n+        createUndefinableType(STRING_TYPE), null);\n+    assumingThisType(thisType);\n+    inFunction(\"var y = 1; this.foo = x; y = this.foo;\");\n+    verify(\"y\", CHECKED_UNKNOWN_TYPE);\n   }\n \n   public void testAssert1() {", "timestamp": 1340837825, "metainfo": ""}