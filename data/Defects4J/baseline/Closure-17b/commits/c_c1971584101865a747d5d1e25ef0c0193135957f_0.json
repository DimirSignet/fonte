{"sha": "c1971584101865a747d5d1e25ef0c0193135957f", "log": "Update NodeUtil.removeChild to only safe handle try/catch/finally nodes. Update UnreachableCodeElminination to reflect the changes and removed peephole removal of unneeded TRY/FINALLY statements as that is now handled by the PeepholeRemoveDeadCode pass.  R=nicksantos DELTA=154  (88 added, 33 deleted, 33 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=219   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n         && child == parent.getLastChild();\n   }\n \n+  /** Whether the node is a CATCH container BLOCK. */\n+  static boolean isTryCatchNodeContainer(Node n) {\n+    Node parent = n.getParent();\n+    return parent.getType() == Token.TRY\n+        && parent.getFirstChild().getNext() == n;\n+  }\n+\n   /** Safely remove children while maintaining a valid node structure. */\n   static void removeChild(Node parent, Node node) {\n-    if (isTryFinallyNode(parent, node)) { // A BLOCK node used as a \"finally\"\n-      // A finally node can simply be removed.\n-      parent.removeChild(node);\n+    if (isTryFinallyNode(parent, node)) {\n+      if (NodeUtil.hasCatchHandler(getCatchBlock(parent))) {\n+        // A finally can only be removed if there is a catch.\n+        parent.removeChild(node);\n+      } else {\n+        // Otherwise only its children can be removed.\n+        node.detachChildren();\n+      }\n+    } else if (node.getType() == Token.CATCH) {\n+      // The CATCH can can only be removed if there is a finally clause.\n+      Node tryNode = node.getParent().getParent();\n+      Preconditions.checkState(NodeUtil.hasFinally(tryNode));\n+      node.detachFromParent();\n+    } else if (isTryCatchNodeContainer(node)) {\n+      // The container node itself can't be removed, but the contained CATCH\n+      // can if there is a 'finally' clause\n+      Node tryNode = node.getParent();\n+      Preconditions.checkState(NodeUtil.hasFinally(tryNode));\n+      node.detachChildren();\n     } else if (node.getType() == Token.BLOCK) {\n       // Simply empty the block.  This maintains source location and\n       // \"synthetic\"-ness.\n     } else {\n       throw new IllegalStateException(\"Invalid attempt to remove node: \" +\n           node.toString() + \" of \"+ parent.toString());\n+    }\n+  }\n+\n+  /**\n+   * Add a finally block if one does not exist.\n+   */\n+  static void maybeAddFinally(Node tryNode) {\n+    Preconditions.checkState(tryNode.getType() == Token.TRY);\n+    if (!NodeUtil.hasFinally(tryNode)) {\n+      tryNode.addChildrenToBack(new Node(Token.BLOCK)\n+          .copyInformationFrom(tryNode));\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n     if (n.getType() == Token.FUNCTION || n.getType() == Token.SCRIPT) {\n       return;\n     }\n-    // Removes TRYs that had its CATCH removed and/or empty FINALLY.\n-    // TODO(dcc): Move the parts of this that don't require a control flow\n-    // graph to PeepholeRemoveDeadCode\n-    if (n.getType() == Token.TRY) {\n-      Node body = n.getFirstChild();\n-      Node catchOrFinallyBlock = body.getNext();\n-      Node finallyBlock = catchOrFinallyBlock.getNext();\n-\n-      if (!catchOrFinallyBlock.hasChildren() &&\n-          (finallyBlock == null || !finallyBlock.hasChildren())) {\n-        n.removeChild(body);\n-        parent.replaceChild(n, body);\n-        compiler.reportCodeChange();\n-        n = body;\n-      }\n-    }\n+\n     DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);\n     if (gNode == null) { // Not in CFG.\n       return;\n             removeDeadExprStatementSafely(n);\n             return fallThrough;\n           }\n-\n         }\n     }\n     return n;\n   }\n \n   private void removeDeadExprStatementSafely(Node n) {\n+    Node parent = n.getParent();\n     if (n.getType() == Token.EMPTY ||\n         (n.getType() == Token.BLOCK && !n.hasChildren())) {\n       // Not always trivial to remove, let FoldContants work its magic later.\n       return;\n     }\n-    // Removing an unreachable DO node is messy because it means we still have\n-    // to execute one iteration. If the DO's body has breaks in the middle, it\n-    // can get even more trickier and code size might actually increase.\n+\n     switch (n.getType()) {\n+      // Removing an unreachable DO node is messy because it means we still have\n+      // to execute one iteration. If the DO's body has breaks in the middle, it\n+      // can get even more trickier and code size might actually increase.\n       case Token.DO:\n-      case Token.TRY:\n+        return;\n+\n+      case Token.BLOCK:\n+        // BLOCKs are used in several ways including wrapping CATCH blocks in TRYs\n+        if (parent.getType() == Token.TRY) {\n+          if (NodeUtil.isTryCatchNodeContainer(n)) {\n+            return;\n+          }\n+        }\n+        break;\n+\n       case Token.CATCH:\n-      case Token.FINALLY:\n-        return;\n+        Node tryNode = parent.getParent();\n+        NodeUtil.maybeAddFinally(tryNode);\n+        break;\n     }\n \n     NodeUtil.redeclareVarsInsideBranch(n);\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n   }\n \n   public void testIsControlStructureCodeBlock() {\n-    Compiler compiler = new Compiler();\n-\n     Node root = parse(\"if (x) foo(); else boo();\");\n     Node ifNode = root.getFirstChild();\n \n   }\n \n   public void testIsFunctionExpression1() {\n-    Compiler compiler = new Compiler();\n-\n     Node root = parse(\"(function foo() {})\");\n     Node StatementNode = root.getFirstChild();\n     assertTrue(NodeUtil.isExpressionNode(StatementNode));\n   }\n \n   public void testIsFunctionExpression2() {\n-    Compiler compiler = new Compiler();\n-\n     Node root = parse(\"function foo() {}\");\n     Node functionNode = root.getFirstChild();\n     assertTrue(NodeUtil.isFunction(functionNode));\n   }\n \n   public void testRemoveChildBlock() {\n-    Compiler compiler = new Compiler();\n-\n-    Node root = parse(\"{{x()}}\");\n-\n     // Test removing the inner block.\n-    Node actual = root.cloneTree();\n+    Node actual = parse(\"{{x()}}\");\n \n     Node outerBlockNode = actual.getFirstChild();\n     Node innerBlockNode = outerBlockNode.getFirstChild();\n     if (difference != null) {\n       assertTrue(\"Nodes do not match:\\n\" + difference, false);\n     }\n-  }  \n-\n-  public void testRemoveTryChild() {\n-    Compiler compiler = new Compiler();\n-\n-    Node root = parse(\"try {foo()} catch(e) {} finally {}\");\n-\n+  }\n+\n+  public void testRemoveTryChild1() {\n     // Test removing the finally clause.\n-    Node actual = root.cloneTree();\n+    Node actual = parse(\"try {foo()} catch(e) {} finally {}\");\n \n     Node tryNode = actual.getFirstChild();\n     Node tryBlock = tryNode.getFirstChild();\n     if (difference != null) {\n       assertTrue(\"Nodes do not match:\\n\" + difference, false);\n     }\n-\n+  }\n+\n+  public void testRemoveTryChild2() {\n     // Test removing the try clause.\n-    actual = root.cloneTree();\n-\n-    tryNode = actual.getFirstChild();\n-    tryBlock = tryNode.getFirstChild();\n-    catchBlocks = tryNode.getFirstChild().getNext();\n-    finallyBlock = tryNode.getLastChild();\n+    Node actual = parse(\"try {foo()} catch(e) {} finally {}\");\n+\n+    Node tryNode = actual.getFirstChild();\n+    Node tryBlock = tryNode.getFirstChild();\n+    Node catchBlocks = tryNode.getFirstChild().getNext();\n \n     NodeUtil.removeChild(tryNode, tryBlock);\n-    expected = \"try {} catch(e) {} finally {}\";\n-    difference = parse(expected).checkTreeEquals(actual);\n+    String expected = \"try {} catch(e) {} finally {}\";\n+    String difference = parse(expected).checkTreeEquals(actual);\n     if (difference != null) {\n       assertTrue(\"Nodes do not match:\\n\" + difference, false);\n     }\n-\n+  }\n+\n+  public void testRemoveTryChild3() {\n     // Test removing the catch clause.\n-    actual = root.cloneTree();\n-\n-    tryNode = actual.getFirstChild();\n-    tryBlock = tryNode.getFirstChild();\n-    catchBlocks = tryNode.getFirstChild().getNext();\n+    Node actual = parse(\"try {foo()} catch(e) {} finally {}\");\n+\n+    Node tryNode = actual.getFirstChild();\n+    Node tryBlock = tryNode.getFirstChild();\n+    Node catchBlocks = tryNode.getFirstChild().getNext();\n     Node catchBlock = catchBlocks.getFirstChild();\n-    finallyBlock = tryNode.getLastChild();\n+    Node finallyBlock = tryNode.getLastChild();\n \n     NodeUtil.removeChild(catchBlocks, catchBlock);\n-    expected = \"try {foo()} finally {}\";\n-    difference = parse(expected).checkTreeEquals(actual);\n+    String expected = \"try {foo()} finally {}\";\n+    String difference = parse(expected).checkTreeEquals(actual);\n+    if (difference != null) {\n+      assertTrue(\"Nodes do not match:\\n\" + difference, false);\n+    }\n+  }\n+\n+  public void testRemoveTryChild4() {\n+    // Test removing the catch clause without a finally.\n+    Node actual = parse(\"try {foo()} catch(e) {} finally {}\");\n+\n+    Node tryNode = actual.getFirstChild();\n+    Node tryBlock = tryNode.getFirstChild();\n+    Node catchBlocks = tryNode.getFirstChild().getNext();\n+    Node catchBlock = catchBlocks.getFirstChild();\n+    Node finallyBlock = tryNode.getLastChild();\n+\n+    NodeUtil.removeChild(tryNode, catchBlocks);\n+    String expected = \"try {foo()} finally {}\";\n+    String difference = parse(expected).checkTreeEquals(actual);\n+    if (difference != null) {\n+      assertTrue(\"Nodes do not match:\\n\" + difference, false);\n+    }\n+  }\n+\n+  public void testRemoveTryChild5() {\n+    Node actual = parse(\"try {foo()} catch(e) {} finally {}\");\n+\n+    Node tryNode = actual.getFirstChild();\n+    Node tryBlock = tryNode.getFirstChild();\n+    Node catchBlocks = tryNode.getFirstChild().getNext();\n+    Node catchBlock = catchBlocks.getFirstChild();\n+    Node finallyBlock = tryNode.getLastChild();\n+\n+    NodeUtil.removeChild(catchBlocks, catchBlock);\n+    String expected = \"try {foo()} finally {}\";\n+    String difference = parse(expected).checkTreeEquals(actual);\n     if (difference != null) {\n       assertTrue(\"Nodes do not match:\\n\" + difference, false);\n     }\n     assertFalse(NodeUtil.evaluatesToLocalValue(callExpr));\n     assertFalse(NodeUtil.functionCallHasSideEffects(callExpr));\n     assertFalse(NodeUtil.mayHaveSideEffects(callExpr));\n-    \n+\n     // No modifications, non-local result\n     flags.clearAllFlags();\n     newExpr.setSideEffectFlags(flags.valueOf());\n--- a/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java\n+++ b/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java\n   public void testTryCatchFinally() {\n     testSame(\"try {foo()} catch (e) {bar()}\");\n     testSame(\"try { try {foo()} catch (e) {bar()}} catch (x) {bar()}\");\n-    test(\"try {var x = 1} catch (e) {e()}\", \"{var x = 1}\");\n+    test(\"try {var x = 1} catch (e) {e()}\", \"try {var x = 1} finally {}\");\n     test(\"try {var x = 1} catch (e) {e()} finally {x()}\",\n         \" try {var x = 1}                 finally {x()}\");\n     test(\"try {var x = 1} catch (e) {e()} finally {}\",\n-        \"     {var x = 1}\");\n+        \"try {var x = 1} finally {}\");\n     testSame(\"try {var x = 1} finally {x()}\");\n-    test(\"try {var x = 1} finally {}\", \"{var x = 1}\");\n-    test(\"function f() { return; try{var x = 1}catch(e){} }\",\n-        \"function f() { var x; return; {}}\");\n+    testSame(\"try {var x = 1} finally {}\");\n+    test(\"function f() {return; try{var x = 1}catch(e){} }\",\n+         \"function f() {var x;}\");\n   }\n \n   public void testRemovalRequiresRedeclaration() {", "timestamp": 1294363198, "metainfo": ""}