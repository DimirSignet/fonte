{"sha": "6e3eb4f7619179ba6c23db2af7549ef02f588c35", "log": "Change on 2010/04/15 by john          Maintain source information in OverloadedMethodResolution.          R=andrew         DELTA=8  (5 added, 1 deleted, 2 changed)  Change on 2010/04/15 by john          Maintain source information during function inlining.          R=alan         DELTA=104  (73 added, 2 deleted, 29 changed)  Change on 2010/04/15 by john          Improve LineNumberCheck error message.          R=nick         DELTA=4  (3 added, 0 deleted, 1 changed)  Change on 2010/04/15 by john          Maintain source information in smart name removal.         Enabled Normalize during tests, simplified VAR handling.          R=antonio         DELTA=71  (12 added, 48 deleted, 11 changed)  Change on 2010/04/15 by john          Maintain source information in InlineGetters.          R=alan         DELTA=8  (7 added, 0 deleted, 1 changed)  Change on 2010/04/15 by alan          Stops the post data from printing multiple times.          R=john         DELTA=4  (1 added, 0 deleted, 3 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=huwaud   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AstChangeProxy.java\n+++ b/src/com/google/javascript/jscomp/AstChangeProxy.java\n     if (parentType == Token.LABEL && size != 1) {\n       Node block = new Node(Token.BLOCK);\n       for (Node newChild : replacements) {\n+        newChild.copyInformationFrom(node);\n         Node oldParent = newChild.getParent();\n         block.addChildToBack(newChild);\n       }\n \n     } else {\n       for (Node newChild : replacements) {\n+        newChild.copyInformationFrom(node);\n         Node oldParent = newChild.getParent();\n         parent.addChildBefore(newChild, node);\n       }\n--- a/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n+++ b/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n   /**\n    *\n    * @param expr The conditional expression to extract.\n-   * @param injectionPoint The before which extracted expression, whould be\n+   * @param injectionPoint The before which extracted expression, would be\n    *     injected.\n    * @param needResult  Whether the result of the expression is required.\n    * @return The node that contains the logic of the expression after\n \n     // Transform the conditional to an IF statement.\n     Node cond = null;\n-    Node trueExpr = new Node(Token.BLOCK);\n-    Node falseExpr = new Node(Token.BLOCK);\n+    Node trueExpr = new Node(Token.BLOCK).copyInformationFrom(expr);\n+    Node falseExpr = new Node(Token.BLOCK).copyInformationFrom(expr);\n     switch (expr.getType()) {\n       case Token.HOOK:\n         // a = x?y:z --> if (x) {a=y} else {a=z}\n         cond = first;\n-        trueExpr.addChildToFront(new Node(Token.EXPR_RESULT,\n+        trueExpr.addChildToFront(NodeUtil.newExpr(\n             buildResultExpression(second, needResult, tempName)));\n-        falseExpr.addChildToFront(new Node(Token.EXPR_RESULT,\n+        falseExpr.addChildToFront(NodeUtil.newExpr(\n             buildResultExpression(last, needResult, tempName)));\n         break;\n       case Token.AND:\n         // a = x&&y --> if (a=x) {a=y} else {}\n         cond = buildResultExpression(first, needResult, tempName);\n-        trueExpr.addChildToFront(new Node(Token.EXPR_RESULT,\n+        trueExpr.addChildToFront(NodeUtil.newExpr(\n             buildResultExpression(last, needResult, tempName)));\n         break;\n       case Token.OR:\n         // a = x||y --> if (a=x) {} else {a=y}\n         cond = buildResultExpression(first, needResult, tempName);\n-        falseExpr.addChildToFront(new Node(Token.EXPR_RESULT,\n+        falseExpr.addChildToFront(NodeUtil.newExpr(\n             buildResultExpression(last, needResult, tempName)));\n         break;\n       default:\n     } else {\n       ifNode = new Node(Token.IF, cond, trueExpr);\n     }\n+    ifNode.copyInformationFrom(expr);\n \n     if (needResult) {\n-      Node tempVarNode = new Node(Token.VAR,\n-          Node.newString(Token.NAME, tempName));\n+      Node tempVarNode = NodeUtil.newVarNode(tempName, null)\n+          .copyInformationFromForTree(expr);\n       Node injectionPointParent = injectionPoint.getParent();\n       injectionPointParent.addChildBefore(tempVarNode, injectionPoint);\n       injectionPointParent.addChildAfter(ifNode, tempVarNode);\n     if (needResult) {\n       return new Node(Token.ASSIGN,\n           Node.newString(Token.NAME, tempName),\n-          expr);\n+          expr).copyInformationFromForTree(expr);\n     } else {\n       return expr;\n     }\n \n     // The temp is known to be constant.\n     String tempName = getTempConstantValueName();\n-    Node replacementValueNode = Node.newString(Token.NAME, tempName);\n+    Node replacementValueNode = Node.newString(Token.NAME, tempName)\n+        .copyInformationFrom(expr);\n \n     Node tempNameValue;\n \n     }\n \n     // Re-add the expression in the declaration of the temporary name.\n-    Node tempNameNode = Node.newString(Token.NAME, tempName);\n-    tempNameNode.addChildToBack(tempNameValue);\n-    Node tempVarNode = new Node(Token.VAR, tempNameNode);\n+    Node tempVarNode = NodeUtil.newVarNode(tempName, tempNameValue);\n \n     Node injectionPointParent = injectionPoint.getParent();\n     injectionPointParent.addChildBefore(tempVarNode, injectionPoint);\n--- a/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n         argMap.put(fnArg.getString(), cArg);\n         cArg = cArg.getNext();\n       } else {\n-        argMap.put(fnArg.getString(), NodeUtil.newUndefinedNode());\n+        Node srcLocation = callNode;\n+        argMap.put(fnArg.getString(), NodeUtil.newUndefinedNode(srcLocation));\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n \n     Node newExpression;\n     if (!block.hasChildren()) {\n-      newExpression = NodeUtil.newUndefinedNode();\n+      Node srcLocation = block;\n+      newExpression = NodeUtil.newUndefinedNode(srcLocation);\n     } else {\n       Node returnNode = block.getFirstChild();\n       Preconditions.checkArgument(returnNode.getType() == Token.RETURN);\n             NodeUtil.isStatementBlock(injectionPointParent));\n \n         // Declare the intermediate result name.\n-        newBlock.addChildrenToFront(NodeUtil.newVarNode(resultName, null));\n+        newBlock.addChildrenToFront(\n+            NodeUtil.newVarNode(resultName, null)\n+                 .copyInformationFromForTree(callNode));\n         // Inline the function before the selected injection point (before\n         // the call).\n         injectionPointParent.addChildBefore(newBlock, injectionPoint);\n       if (fnParam != null) {\n         if (cArg != null) {\n           // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a \n+          // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n           if (NodeUtil.mayEffectMutableState(cArg)\n               && NodeUtil.getNameReferenceCount(\n--- a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n+++ b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n       Node name = n.getFirstChild();\n       // It isn't initialized.\n       if (!name.hasChildren()) {\n-        name.addChildToBack(NodeUtil.newUndefinedNode());\n+        Node srcLocation = name;\n+        name.addChildToBack(NodeUtil.newUndefinedNode(srcLocation));\n       }\n       return;\n     }\n         String name = entry.getKey();\n         if (namesToAlias.contains(name)) {\n           Node newValue = entry.getValue().cloneTree();\n-          Node newNode = NodeUtil.newVarNode(name, newValue);\n+          Node newNode = NodeUtil.newVarNode(name, newValue)\n+              .copyInformationFromForTree(newValue);\n           newVars.add(0, newNode);\n           // Remove the parameter from the list to replace.\n           newArgMap.remove(name);\n         replaceReturnWithBreak(block, null, resultName, labelName);\n \n         // Add label\n-        Node label = new Node(Token.LABEL);\n-        Node name = Node.newString(Token.LABEL_NAME, labelName);\n+        Node label = new Node(Token.LABEL).copyInformationFrom(block);\n+        Node name = Node.newString(Token.LABEL_NAME, labelName)\n+            .copyInformationFrom(block);\n         label.addChildToFront(name);\n         label.addChildToBack(block);\n \n-        Node newRoot = new Node(Token.BLOCK);\n+        Node newRoot = new Node(Token.BLOCK).copyInformationFrom(block);\n         newRoot.addChildrenToBack(label);\n+        \n \n         // The label is now the root.\n         root = newRoot;\n     Preconditions.checkArgument(node.getType() == Token.BLOCK);\n \n     // A result is needed create a dummy value.\n-    Node retVal = NodeUtil.newUndefinedNode();\n+    Node srcLocation = node;\n+    Node retVal = NodeUtil.newUndefinedNode(srcLocation);\n     Node resultNode = createAssignStatementNode(resultName, retVal);\n+    resultNode.copyInformationFromForTree(node);\n \n     node.addChildrenToBack(resultNode);\n   }\n     if (resultNode == null) {\n       block.removeChild(ret);\n     } else {\n+      resultNode.copyInformationFromForTree(ret);\n       block.replaceChild(ret, resultNode);\n     }\n   }\n     } else {\n       if (retVal == null) {\n         // A result is needed create a dummy value.\n-        retVal = NodeUtil.newUndefinedNode();\n+        Node srcLocation = node;\n+        retVal = NodeUtil.newUndefinedNode(srcLocation);\n       }\n       // Create a \"resultName = retVal;\" statement.\n       resultNode = createAssignStatementNode(resultName, retVal);\n       Node breakNode = new Node(Token.BREAK, name);\n \n       // Replace the node in parent, and reset current to the first new child.\n+      breakNode.copyInformationFromForTree(current);\n       parent.replaceChild(current, breakNode);\n       if (resultNode != null) {\n+        resultNode.copyInformationFromForTree(current);\n         parent.addChildBefore(resultNode, breakNode);\n       }\n       current = breakNode;\n--- a/src/com/google/javascript/jscomp/InlineGetters.java\n+++ b/src/com/google/javascript/jscomp/InlineGetters.java\n     if (NodeUtil.isExprCall(parent)) {\n       parent.getParent().replaceChild(parent, new Node(Token.EMPTY));\n     } else {\n-      parent.replaceChild(call, new Node(Token.VOID, Node.newNumber(0)));\n+      Node srcLocation = call;\n+      parent.replaceChild(call, NodeUtil.newUndefinedNode(srcLocation));\n     }\n     compiler.reportCodeChange();\n   }\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n           value = init.getAssignedValue();\n         } else {\n           // Create a new node for variable that is never initialized.\n-          value = NodeUtil.newUndefinedNode()\n-              .copyInformationFromForTree(declaration.getNameNode());\n+          Node srcLocation = declaration.getNameNode();\n+          value = NodeUtil.newUndefinedNode(srcLocation);\n         }\n         Preconditions.checkNotNull(value);\n         inlineWellDefinedVariable(v, value, referenceInfo.references);\n--- a/src/com/google/javascript/jscomp/LineNumberCheck.java\n+++ b/src/com/google/javascript/jscomp/LineNumberCheck.java\n \n   static final DiagnosticType MISSING_LINE_INFO = DiagnosticType.error(\n       \"JSC_MISSING_LINE_INFO\",\n-      \"No source line associated with {0}\");\n+      \"No source location information associated with {0}.\\n\" +\n+      \"Most likely a Node has been created with settings the source file \" +\n+      \"and line/column location.  Usually this is done using \" +\n+      \"Node.copyInformationFrom and supplying a Node from the source AST.\");\n \n   private final AbstractCompiler compiler;\n   private boolean requiresLineNumbers = false;\n \n   LineNumberCheck(AbstractCompiler compiler) {\n     this.compiler = compiler;\n+  }\n+\n+  public void setCheckSubTree(Node root) {\n+    requiresLineNumbers = true;\n+\n+    NodeTraversal.traverse(compiler, root, this);\n   }\n \n   public void process(Node externs, Node root) {\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.DiGraph;\n+import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;\n+import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n-import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;\n import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;\n-import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n       Node containingNode = parent.getParent();\n       switch (parent.getType()) {\n         case Token.VAR:\n-          if (parent.getFirstChild() ==\n-              parent.getLastChild()) {\n-            replaceWithRhs(containingNode, parent);\n-          } else {\n-            // Break up var expression into the parts before the\n-            // current declaration and the ones after.  Replace\n-            // the current declaration with its RHS, after\n-            // removing subexpressions with no side effects.\n-            // Replacement nodes should end up between the two\n-            // sets of variable declarations.\n-            List<Node> earlyChildren = Lists.newArrayList();\n-            List<Node> lateChildren = Lists.newArrayList();\n-            boolean seen = false;\n-            for (Node child : parent.children()) {\n-              if (child == node) {\n-                seen = true;\n-                continue;\n-              }\n-\n-              if (seen) {\n-                lateChildren.add(child);\n-              } else {\n-                earlyChildren.add(child);\n-              }\n-            }\n-\n-            if (!earlyChildren.isEmpty() && !lateChildren.isEmpty()) {\n-              Node earlyDecls = new Node(Token.VAR);\n-              for (Node child : earlyChildren) {\n-                parent.removeChild(child);\n-                earlyDecls.addChildToBack(child);\n-              }\n-              containingNode.addChildBefore(earlyDecls, parent);\n-            }\n-\n-            Node currDecl = new Node(Token.VAR);\n-            parent.removeChild(node);\n-            currDecl.addChildToBack(node);\n-            if (earlyChildren.isEmpty() || !lateChildren.isEmpty()) {\n-              containingNode.addChildBefore(currDecl, parent);\n-            } else {\n-              containingNode.addChildAfter(currDecl, parent);\n-            }\n-            replaceWithRhs(containingNode, currDecl);\n-          }\n+          Preconditions.checkState(parent.hasOneChild());\n+          replaceWithRhs(containingNode, parent);\n           break;\n         case Token.FUNCTION:\n           replaceWithRhs(containingNode, parent);\n     List<Node> replacements =\n         Lists.newArrayListWithExpectedSize(subexpressions.size());\n     for (Node subexpression : subexpressions) {\n-      replacements.add(new Node(Token.EXPR_RESULT, subexpression));\n+      replacements.add(NodeUtil.newExpr(subexpression));\n     }\n     return replacements;\n   }\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    * Create a node for an empty result expression:\n    *   \"void 0\"\n    */\n-  static Node newUndefinedNode() {\n+  static Node newUndefinedNode(Node srcReferenceNode) {\n     // TODO(johnlenz): Why this instead of the more common \"undefined\"?\n-    return new Node(Token.VOID, Node.newNumber(0));\n+    Node node = new Node(Token.VOID, Node.newNumber(0));\n+    if (srcReferenceNode != null) {\n+        node.copyInformationFromForTree(srcReferenceNode);\n+    }\n+    return node;\n   }\n \n   /**\n   static Node newVarNode(String name, Node value) {\n     Node nodeName = Node.newString(Token.NAME, name);\n     if (value != null) {\n-      nodeName.addChildrenToBack(value);\n-    }\n-    Node var = new Node(Token.VAR, nodeName);\n+      Preconditions.checkState(value.getNext() == null);\n+      nodeName.addChildToBack(value);\n+      nodeName.copyInformationFrom(value);\n+    }\n+    Node var = new Node(Token.VAR, nodeName)\n+        .copyInformationFrom(nodeName);\n \n     return var;\n   }\n--- a/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java\n+++ b/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java\n       ) {\n     helperExposeExpression(\n         code, fnName, expectedResult, null);\n+  }\n+\n+  private void validateSourceInfo(Compiler compiler, Node subtree) {\n+    (new LineNumberCheck(compiler)).setCheckSubTree(subtree);\n+    // Source information problems are reported as compiler errors.\n+    if (compiler.getErrorCount() != 0) {\n+      String msg = \"Error encountered: \";\n+      for (JSError err : compiler.getErrors()) {\n+        msg += err.toString() + \"\\n\";\n+      }\n+      assertTrue(msg, compiler.getErrorCount() == 0);\n+    }\n   }\n \n   private void helperExposeExpression(\n \n     compiler.resetUniqueNameId();\n     decomposer.exposeExpression(callSite);\n+    validateSourceInfo(compiler, tree);\n     String explanation = expectedRoot.checkTreeEquals(tree);\n     assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n         \"\\nResult: \" + compiler.toSource(tree) +\n \n     compiler.resetUniqueNameId();\n     decomposer.moveExpression(callSite);\n+    validateSourceInfo(compiler, tree);\n     String explanation = expectedRoot.checkTreeEquals(tree);\n     assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n         \"\\nResult: \" + compiler.toSource(tree) +\n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n         code, expectedResult, fnName, mode, false);\n   }\n \n+  private void validateSourceInfo(Compiler compiler, Node subtree) {\n+    (new LineNumberCheck(compiler)).setCheckSubTree(subtree);\n+    // Source information problems are reported as compiler errors.\n+    if (compiler.getErrorCount() != 0) {\n+      String msg = \"Error encountered: \";\n+      for (JSError err : compiler.getErrors()) {\n+        msg += err.toString() + \"\\n\";\n+      }\n+      assertTrue(msg, compiler.getErrorCount() == 0);\n+    }\n+  }\n+\n   public void helperInlineReferenceToFunction(\n       String code, final String expectedResult,\n       final String fnName, final InliningMode mode,\n \n         Node result = injector.inline(\n             t, n, fnName, fnNode, mode);\n+        validateSourceInfo(compiler, result);\n         String explanation = expectedRoot.checkTreeEquals(tree.getFirstChild());\n         assertNull(\"\\nExpected: \" + toSource(expectedRoot) +\n             \"\\nResult: \" + toSource(tree.getFirstChild()) +\n--- a/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n         \"}\",\n         \"foo\", null);\n   }\n-  \n+\n   public void testMutateCallInLoopVars1() {\n     // baseline: outside a loop, the constant remains constant.\n     boolean callInLoop = false;\n         \"function foo(a){var B = bar(); a;}; foo(1);\",\n         \"{var B$$inline_3 = bar(); 1;}\",\n         \"foo\", null, false, callInLoop);\n-  }  \n+  }\n \n \n   public void helperMutate(\n       String code, final String expectedResult, final String fnName,\n       final String resultName) {\n     helperMutate(code, expectedResult, fnName, resultName, false, false);\n+  }\n+\n+  private void validateSourceInfo(Compiler compiler, Node subtree) {\n+    (new LineNumberCheck(compiler)).setCheckSubTree(subtree);\n+    // Source information problems are reported as compiler errors.\n+    if (compiler.getErrorCount() != 0) {\n+      String msg = \"Error encountered: \";\n+      for (JSError err : compiler.getErrors()) {\n+        msg += err.toString() + \"\\n\";\n+      }\n+      assertTrue(msg, compiler.getErrorCount() == 0);\n+    }\n   }\n \n   public void helperMutate(\n     final FunctionToBlockMutator mutator = new FunctionToBlockMutator(\n         compiler, compiler.getUniqueNameIdSupplier());\n     Node expectedRoot = parse(compiler, expectedResult);\n+    Preconditions.checkState(compiler.getErrorCount() == 0);\n     final Node expected = expectedRoot.getFirstChild();\n     final Node tree = parse(compiler, code);\n+    Preconditions.checkState(compiler.getErrorCount() == 0);\n \n     Node externsRoot = new Node(Token.EMPTY);\n     Node mainRoot = tree;\n         Node result = mutator.mutate(\n             fnName, fnNode, n, resultName,\n             needsDefaultResult, isCallInLoop);\n+        validateSourceInfo(compiler, result);\n         String explanation = expected.checkTreeEquals(result);\n         assertNull(\"\\nExpected: \" + compiler.toSource(expected) +\n             \"\\nResult: \" + compiler.toSource(result) +\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n   @Override\n   protected void setUp() throws Exception {\n     super.setUp();\n+    super.enableLineNumberCheck(true);\n     allowBlockInlining = true;\n   }\n \n--- a/test/com/google/javascript/jscomp/InlineGettersTest.java\n+++ b/test/com/google/javascript/jscomp/InlineGettersTest.java\n   }\n \n   @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    super.enableLineNumberCheck(true);\n+  }\n+\n+  @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n     return new InlineGetters(compiler);\n   }\n   public void testIssue2508576_2() {\n     // Anonymous object definition with a side-effect should be left alone.\n     testSame(\"({a:function(){},b:x()}).a(\\\"a\\\")\");\n-  }  \n+  }\n \n   public void testIssue2508576_3() {\n     // Anonymous object definition without side-effect should be removed.\n     test(\"({a:function(){},b:alert}).a(\\\"a\\\")\", \"\");\n-  }  \n+  }\n }\n--- a/test/com/google/javascript/jscomp/NameAnalyzerTest.java\n+++ b/test/com/google/javascript/jscomp/NameAnalyzerTest.java\n   }\n \n   @Override\n+  protected void setUp() {\n+    super.enableNormalize();\n+    super.enableLineNumberCheck(true);\n+  }\n+\n+  @Override\n   protected int getNumRepetitions() {\n     // pass reaches steady state after 1 iteration.\n     return 1;\n \n   public void testAssignmentToUnknownPrototype() {\n     testSame(\n-        \"var window;\" +\n+        \"/** @suppress {duplicate} */ var window;\" +\n         \"window['a'].prototype = {};\");\n   }\n \n   public void testBug2099540() {\n     testSame(\n-        \"var document,window,klass;\" +\n+        \"/** @suppress {duplicate} */ var document;\\n\" +\n+        \"/** @suppress {duplicate} */ var window;\\n\" +\n+        \"var klass;\\n\" +\n         \"window[klass].prototype = \" +\n             \"document.createElement(tagName)['__proto__'];\");\n   }\n \n   public void testSetterInForStruct3() {\n     test(\"var j = 0; for (var i = 1 + f() + g() + h(); i = 0; j++);\",\n-         \"var j = 0; for (f(), g(), h(); 0; j++);\");\n+         \"var j = 0; f(); g(); h(); for (; 0; j++);\");\n   }\n \n   public void testSetterInForStruct4() {\n     test(\"var i = 0;var j = 0; for (i = 1 + f() + g() + h(); i = 0; j++);\",\n-         \"var j = 0; for (f(), g(), h(); 0; j++);\");\n+         \"var j = 0; f(); g(); h(); for (; 0; j++);\");\n   }\n \n   public void testSetterInForStruct5() {\n   }\n \n   public void testSetterInWhilePredicate() {\n-    // TODO(user) Make NameAnalyzer smarter so it can remove \"Class\".\n-    testSame(\"var a = 1;\" +\n-             \"var Class = function() {}; \" +\n-             \"while (Class.property_ = a);\");\n+    test(\"var a = 1;\" +\n+         \"var Class = function() {}; \" +\n+         \"while (Class.property_ = a);\",\n+         \"var a = 1; for (;a;) {}\");\n   }\n \n   public void testSetterInDoWhilePredicate() {", "timestamp": 1271438431, "metainfo": ""}