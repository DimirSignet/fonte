{"sha": "f02faf9d0650270eeb430d368240401d0f465597", "log": "Augment instrumentation to handle increment, decrement, and compound assignment operators by unfolding them to simple assignments  R=johnlenz DELTA=314  (296 added, 0 deleted, 18 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=104005   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/UnfoldCompoundAssignments.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.jscomp.NodeTraversal.Callback;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+/**\n+ * Transforms compound assignments into simple ones.\n+ * <p>\n+ * {@code x++} and {@code x--} are unfolded to {@code x = +x + 1} and {@code x =\n+ * x - 1}, and assignments such as {@code x += y} are expanded to {@code x = x +\n+ * y}.\n+ * <p>\n+ * Notice the prefix '+' when unfolding ++. This is needed because the operand\n+ * is implicitly converted to a number.\n+ *\n+ * @author elnatan@google.com (Elnatan Reisner)\n+ */\n+class UnfoldCompoundAssignments implements Callback, CompilerPass {\n+  private final AbstractCompiler compiler;\n+\n+  public UnfoldCompoundAssignments(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see Callback#shouldTraverse(NodeTraversal, Node, Node)\n+   */\n+  @Override\n+  public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n+      Node parent) {\n+    return true;\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see Callback#visit(NodeTraversal, Node, Node)\n+   */\n+  @Override\n+  public void visit(NodeTraversal t, Node node, Node parent) {\n+    switch (node.getType()) {\n+      case Token.INC:\n+      case Token.DEC:\n+        unfoldIncrDecr(node, node.getType() == Token.INC);\n+        break;\n+      case Token.ASSIGN_BITOR:  // |=\n+      case Token.ASSIGN_BITXOR: // ^=\n+      case Token.ASSIGN_BITAND: // &=\n+      case Token.ASSIGN_LSH:    // <<=\n+      case Token.ASSIGN_RSH:    // >>=\n+      case Token.ASSIGN_URSH:   // >>>=\n+      case Token.ASSIGN_ADD:    // +=\n+      case Token.ASSIGN_SUB:    // -=\n+      case Token.ASSIGN_MUL:    // *=\n+      case Token.ASSIGN_DIV:    // /=\n+      case Token.ASSIGN_MOD:    // %=\n+        unfoldCompoundAssignment(node);\n+        break;\n+    }\n+  }\n+\n+  /**\n+   * Unfolds ++ and -- operators into {@code x = +x + 1} and {@code x = x - 1}.\n+   * <p>\n+   * The operand gets a prefix {@code +} when unfolding an increment because\n+   * {@code ++} converts its operand to a number but binary {@code +} does not.\n+   * ({@code -} <em>does</em> convert its operands to numbers, so we don't need\n+   * to add a prefix {@code +} when unfolding {@code --}.)\n+   *\n+   * @param node an increment or decrement node\n+   * @param isIncrement true if the operator is ++; false if it is --\n+   * @throws RuntimeException if node is a postfix expression whose value is\n+   *         used (that is, node is <em>not</em> used only for its side-effect)\n+   */\n+  private void unfoldIncrDecr(Node node, boolean isIncrement) {\n+    Preconditions.checkArgument(\n+        isPrefix(node) || valueIsDiscarded(node),\n+        \"Unfolding postfix ++/-- requires that the result be ignored.\");\n+    Node lhs = node.getFirstChild().cloneTree();\n+    // TODO(elnatan): We might want to use type information to only add this '+'\n+    // when lhs isn't already a number.\n+    if (isIncrement) {\n+      lhs = new Node(Token.POS, lhs);\n+    }\n+    node.setType(Token.ASSIGN);\n+    Node rhs = new Node(isIncrement ? Token.ADD : Token.SUB,\n+        lhs, Node.newNumber(1));\n+    rhs.copyInformationFromForTree(node);\n+    node.addChildToBack(rhs);\n+    compiler.reportCodeChange();\n+  }\n+\n+  /**\n+   * Returns true if the node's value is discarded.\n+   * <p>\n+   * The value is discarded if node is\n+   * <ul>\n+   * <li>the child of an EXPR_RESULT,\n+   * <li>the first child of a COMMA, or\n+   * <li>the increment of a FOR loop.\n+   * </ul>\n+   */\n+  private boolean valueIsDiscarded(Node node) {\n+    Node parent = node.getParent();\n+    switch (parent.getType()) {\n+      case Token.EXPR_RESULT:\n+        return true;\n+      case Token.COMMA:\n+        return parent.getFirstChild() == node;\n+      case Token.FOR:\n+        Preconditions.checkArgument(!NodeUtil.isForIn(parent),\n+            \"Error: the child of a FOR-IN cannot be an INC or DEC\");\n+        return parent.getChildAtIndex(2) == node;\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * @param node an INC or DEC node\n+   * @return true if the increment/decrement is prefix; false if postfix\n+   */\n+  private boolean isPrefix(Node node) {\n+    Preconditions.checkArgument(\n+        node.getType() == Token.INC || node.getType() == Token.DEC,\n+        \"isPrefix can only be called on INC and DEC nodes\");\n+    // According to CodeGenerator:\n+    // A non-zero post-prop value indicates a post inc/dec, default of zero is a\n+    // pre-inc/dec.\n+    return node.getIntProp(Node.INCRDECR_PROP) == 0;\n+  }\n+\n+  /**\n+   * Unfolds a compound assignment node {@code lhs op= rhs} to {@code lhs = lhs\n+   * op rhs}.\n+   *\n+   * @param node a compound assignment node\n+   */\n+  private void unfoldCompoundAssignment(Node node) {\n+    Node newRhs = node.cloneTree();\n+    newRhs.setType(NodeUtil.getOpFromAssignmentOp(node));\n+    Node lhs = node.getFirstChild();\n+    node.replaceChildAfter(lhs, newRhs);\n+    node.setType(Token.ASSIGN);\n+    compiler.reportCodeChange();\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see CompilerPass#process(Node, Node)\n+   */\n+  @Override\n+  public void process(Node externs, Node root) {\n+    Preconditions.checkState(compiler.isNormalized(),\n+        \"UnfoldCompoundAssignments requires a normalized AST\");\n+    NodeTraversal.traverse(compiler, root, this);\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/UnfoldCompoundAssignmentsTest.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * @author elnatan@google.com (Elnatan Reisner)\n+ *\n+ */\n+public class UnfoldCompoundAssignmentsTest extends CompilerTestCase {\n+  public UnfoldCompoundAssignmentsTest() {\n+    enableNormalize();\n+  }\n+\n+  /* (non-Javadoc)\n+   * @see CompilerTestCase#getProcessor(Compiler)\n+   */\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    return new UnfoldCompoundAssignments(compiler);\n+  }\n+\n+  public void testIncrement() {\n+    test(\"x++;\", \"x = +x + 1;\");\n+    test(\"var x = 0; ++x;\", \"var x = 0; x = +x + 1;\");\n+  }\n+\n+  public void testDecrement() {\n+    test(\"x--;\", \"x = x - 1;\");\n+    test(\"var x = 0; --x;\", \"var x = 0; x = x - 1;\");\n+  }\n+\n+  public void testCompoundAssignment() {\n+    test(\"x <<= y;\", \"x = x << y;\");\n+  }\n+\n+  public void testPostfixInForLoop0() {\n+    test(\"for (x++;;) {}\", \"for (x = +x + 1;;) {}\");\n+  }\n+\n+  public void testPostfixInForLoop1() {\n+    try {\n+      testSame(\"for (;x++;) {}\");\n+      fail(\"Should raise an exception\");\n+    } catch (RuntimeException e) {\n+    }\n+  }\n+\n+  public void testPostfixInForLoop2() {\n+    test(\"for (;;x++) {}\", \"for (;;x = +x + 1) {}\");\n+  }\n+\n+  public void testPrefixWithinLargerExpression() {\n+    test(\"--x + 7;\", \"(x = x - 1) + 7;\");\n+  }\n+\n+  public void testPostfixInComma() {\n+    test(\"z++, z==8;\", \"z = +z + 1, z==8;\");\n+  }\n+\n+  public void testPostfixUsedValue0() {\n+    try {\n+      testSame(\"z==8, z++;\");\n+      fail(\"Should raise an exception\");\n+    } catch (RuntimeException e) {\n+    }\n+  }\n+\n+  public void testPostfixUsedValue1() {\n+    try {\n+      testSame(\"x-- + 7;\");\n+      fail(\"Should raise an Exception\");\n+    } catch (RuntimeException e) {\n+    }\n+  }\n+\n+  public void testMultiple() {\n+    test(\"x++, 5; for (a.x++;0;x++) {}; x++;\",\n+        \"x = +x + 1, 5; for (a.x = +a.x + 1; 0; x = +x + 1) {}; x = +x + 1;\");\n+  }\n+}", "timestamp": 1281653027, "metainfo": ""}