{"sha": "45f2bdf91ad3c2f2ac901c72efe9e26148b08d2b", "log": "Fix a bunch of passes to preserve more type information.  Fix goog.provide/goog.require handling to work in the presence of modules.  Improve a bunch of type annotations in gecko_dom.  Make NameAnalyzer use the Graph package.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n    * Note: non-private to enable test cases that require the Normalize pass.\n    */\n   abstract void setUnnormalized();\n+\n+  /**\n+   * Are the nodes equal for the purpose of inlining?\n+   * If type aware optimizations are on, type equality is checked.\n+   */\n+  abstract boolean areNodesEqualForInlining(Node n1, Node n2);\n }\n--- a/src/com/google/javascript/jscomp/ChainCalls.java\n+++ b/src/com/google/javascript/jscomp/ChainCalls.java\n       }\n \n       Node nextGetPropFirstChildNode = nextGetPropNode.getFirstChild();\n-      if (!nextGetPropFirstChildNode.checkTreeEqualsSilent(\n-          getPropFirstChildNode)) {\n+      if (!compiler.areNodesEqualForInlining(\n+              nextGetPropFirstChildNode, getPropFirstChildNode)) {\n         return;\n       }\n \n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     return normalized;\n   }\n \n+  @Override\n+  boolean areNodesEqualForInlining(Node n1, Node n2) {\n+    if (options_.ambiguateProperties ||\n+        options_.disambiguateProperties) {\n+      // The type based optimizations require that type information is preserved\n+      // during other optimizations.\n+      return n1.checkTreeTypeAwareEqualsSilent(n2);\n+    } else {\n+      return n1.checkTreeEqualsSilent(n2);\n+    }\n+  }\n+\n   //------------------------------------------------------------------------\n   // Inputs\n   //------------------------------------------------------------------------\n--- a/src/com/google/javascript/jscomp/FoldConstants.java\n+++ b/src/com/google/javascript/jscomp/FoldConstants.java\n     }\n \n     Node leftChild = right.getFirstChild();\n-    if (!left.checkTreeEqualsSilent(leftChild)) {\n+    if (!compiler.areNodesEqualForInlining(left, leftChild)) {\n       return;\n     }\n \n         // if(x)a=1;else a=2; -> a=x?1:2;\n         if (NodeUtil.isAssignmentOp(thenOp)) {\n           Node lhs = thenOp.getFirstChild();\n-          if (lhs.checkTreeEqualsSilent(elseOp.getFirstChild()) &&\n+          if (compiler.areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n       Node lastTrue = trueBranch.getLastChild();\n       Node lastFalse = falseBranch.getLastChild();\n       if (lastTrue == null || lastFalse == null\n-          || !lastTrue.checkTreeEqualsSilent(lastFalse)) {\n+          || !compiler.areNodesEqualForInlining(lastTrue, lastFalse)) {\n         break;\n       }\n       lastTrue.detachFromParent();\n--- a/src/com/google/javascript/jscomp/InlineGetters.java\n+++ b/src/com/google/javascript/jscomp/InlineGetters.java\n   /**\n    * Given a set of method definitions, verify they are the same.\n    */\n-  private static boolean allDefinitionsEquivalent(\n+  private boolean allDefinitionsEquivalent(\n       Collection<Node> definitions) {\n     List<Node> list = Lists.newArrayList();\n     list.addAll(definitions);\n     Node node0 = list.get(0);\n     for (int i = 1; i < list.size(); i++) {\n-      if (!list.get(i).checkTreeEqualsSilent(node0)) {\n+      if (!compiler.areNodesEqualForInlining(list.get(i), node0)) {\n         return false;\n       }\n     }\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.jscomp.graph.DiGraph;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n+import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;\n+import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;\n+\n+import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n   /** Map of all JS names found */\n   private final Map<String, JsName> allNames = Maps.newTreeMap();\n \n+  /** Reference dependency graph */\n+  private DiGraph<JsName, RefType> referenceGraph =\n+      new LinkedDirectedGraph<JsName, RefType>();\n+\n   /**\n    * Map of name scopes - all children of the Node key have a dependency on the\n    * name value.\n    * will not get executed unless name is referenced via a get operation\n    */\n   private final Map<Node, NameInformation> scopes = Maps.newHashMap();\n-\n-  /**\n-   * List of names referenced in successive generations of finding referenced\n-   * nodes\n-   */\n-  private final List<Set<JsName>> generations = Lists.newArrayList();\n \n   /** Used to parse prototype names */\n   private static final String PROTOTYPE_SUBSTRING = \".prototype.\";\n   private final List<RefNode> refNodes = Lists.newArrayList();\n \n   /**\n+   * Relationship between the two names.\n+   * Currently only two different reference types exists:\n+   * goog.inherits class relations and all other references.\n+   */\n+  private static enum RefType {\n+    REGULAR,\n+    INHERITANCE,\n+  }\n+\n+  /**\n+   * Callback that propagates side effect information across call sites.\n+   */\n+  private static class ReferencePropagationCallback\n+      implements EdgeCallback<JsName, RefType> {\n+    public boolean traverseEdge(JsName from,\n+                                RefType callSite,\n+                                JsName to) {\n+      if (from.referenced && !to.referenced) {\n+        to.referenced = true;\n+        return true;\n+      } else {\n+        return false;\n+      }\n+    }\n+  }\n+\n+  /**\n    * Class to hold information that can be determined from a node tree about a\n    * given name\n    */\n     /** Fully qualified name */\n     String name;\n \n-    /** Names referred to by this name */\n-    Set<String> refersTo = Sets.newHashSet();\n-\n-    /** Names that refer to this name */\n-    Set<String> referencedBy = Sets.newHashSet();\n-\n     /** Name of prototype functions attached to this name */\n     List<String> prototypeNames = Lists.newArrayList();\n \n \n     /** Whether this node is referenced */\n     boolean referenced = false;\n-\n-    /** First generation this node was referenced */\n-    int generation = 0;\n \n     /**\n      * Output the node as a string\n         }\n       }\n \n-      if (refersTo.size() > 0) {\n-        out.append(\"\\n - REFERS TO: \");\n-        out.append(Joiner.on(\", \").join(refersTo));\n-      }\n-\n-      if (referencedBy.size() > 0) {\n-        out.append(\"\\n - REFERENCED BY: \");\n-        out.append(Joiner.on(\", \").join(referencedBy));\n-      }\n       return out.toString();\n     }\n \n       }\n \n       if (nameInfo.onlyAffectsClassDef) {\n-        recordReference(nameInfo.name, nameInfo.superclass);\n+        recordReference(nameInfo.name,\n+                        nameInfo.superclass,\n+                        RefType.INHERITANCE);\n \n         // Make sure that we record a reference to the function that does\n         // the inheritance, so that the inherits() function itself does\n         // not get stripped.\n         String nodeName = n.getQualifiedName();\n         if (nodeName != null) {\n-          recordReference(nameInfo.name, nodeName);\n+          recordReference(nameInfo.name,\n+                          nodeName,\n+                          RefType.REGULAR);\n         }\n \n         return;\n       // reference to it from the global scope (a.k.a. window).\n       String name = nameInfo.name;\n       if (nameInfo.isExternallyReferenceable) {\n-        recordReference(WINDOW, name);\n+        recordReference(WINDOW, name,\n+                        RefType.REGULAR);\n         return;\n       }\n \n       // For example, foo references bar in: function foo() {bar=5}.\n       if (NodeUtil.isLhs(n, parent)) {\n         if (referring != null) {\n-          recordReference(referringName, name);\n+          recordReference(referringName, name, RefType.REGULAR);\n         }\n         return;\n       }\n       if (nodesToKeep.contains(n)) {\n         NameInformation functionScope = getEnclosingFunctionDependencyScope(t);\n         if (functionScope != null) {\n-          recordReference(functionScope.name, name);\n+          recordReference(functionScope.name, name, RefType.REGULAR);\n         } else {\n-          recordReference(WINDOW, name);\n+          recordReference(WINDOW, name, RefType.REGULAR);\n         }\n       } else if (referring != null) {\n-        recordReference(referringName, name);\n+        recordReference(referringName, name, RefType.REGULAR);\n       } else {\n         // No named dependency scope found.  Unfortunately that might\n         // mean that the expression is a child of an anonymous\n         for (Node ancestor : n.getAncestors()) {\n           if (NodeUtil.isAssignmentOp(ancestor) ||\n               NodeUtil.isFunction(ancestor)) {\n-            recordReference(WINDOW, name);\n+            recordReference(WINDOW, name, RefType.REGULAR);\n             break;\n           }\n         }\n       }\n-    }\n-\n-    /**\n-     * Records a reference from one name to another name.\n-     */\n-    private void recordReference(String fromName, String toName) {\n-      JsName from = getName(fromName, true);\n-      JsName to = getName(toName, true);\n-      from.refersTo.add(toName);\n-      to.referencedBy.add(fromName);\n     }\n \n     /**\n   }\n \n   /**\n+   * Records a reference from one name to another name.\n+   */\n+  private void recordReference(String fromName, String toName,\n+                               RefType depType) {\n+    JsName from = getName(fromName, true);\n+    JsName to = getName(toName, true);\n+    referenceGraph.createNode(from);\n+    referenceGraph.createNode(to);\n+    if (!referenceGraph.isConnectedInDirection(from, to)) {\n+      referenceGraph.connect(from, depType, to);\n+    }\n+  }\n+\n+  /**\n    * Removes all unreferenced variables.\n    */\n   void removeUnreferenced() {\n     }\n \n     changeProxy.unregisterListener(listener);\n-  }\n-\n-  /**\n-   * Generates a report\n-   *\n-   * @return The report\n-   */\n-  String getStringReport() {\n-    StringBuilder sb = new StringBuilder();\n-    sb.append(\"TOTAL NAMES: \" + countOf(TriState.BOTH, TriState.BOTH) + \"\\n\");\n-    sb.append(\"TOTAL CLASSES: \" + countOf(TriState.TRUE, TriState.BOTH) + \"\\n\");\n-    sb.append(\"TOTAL STATIC FUNCTIONS: \"\n-        + countOf(TriState.FALSE, TriState.BOTH) + \"\\n\");\n-    sb.append(\"REFERENCED NAMES: \" + countOf(TriState.BOTH, TriState.TRUE)\n-        + \"\\n\");\n-    sb.append(\"REFERENCED CLASSES: \" + countOf(TriState.TRUE, TriState.TRUE)\n-        + \"\\n\");\n-    sb.append(\"REFERENCED STATIC FUNCTIONS: \"\n-        + countOf(TriState.FALSE, TriState.TRUE) + \"\\n\");\n-\n-\n-    for (int i = 0; i < generations.size(); i++) {\n-      Set<JsName> gen = generations.get(i);\n-      sb.append(\"GENERATION \" + i + \": \" + gen.size() + \" names\\n\");\n-      for (JsName jsName : gen) {\n-        sb.append(\" - \" + jsName.name + \"\\n\");\n-      }\n-    }\n-\n-    sb.append(\"ALL NAMES\\n\");\n-    for (JsName node : allNames.values()) {\n-      sb.append(node + \"\\n\");\n-    }\n-\n-    return sb.toString();\n   }\n \n   /**\n         + countOf(TriState.FALSE, TriState.TRUE));\n     sb.append(\"</ul>\");\n \n-\n-    for (int i = 0; i < generations.size(); i++) {\n-      Set<JsName> gen = generations.get(i);\n-      sb.append(\"GENERATION \" + i + \": \" + gen.size() + \" names\\n<ul>\");\n-      for (JsName jsName : gen) {\n-        appendListItem(sb, nameLink(jsName.name));\n-      }\n-      sb.append(\"</ul>\");\n-    }\n-\n     sb.append(\"ALL NAMES<ul>\\n\");\n     for (JsName node : allNames.values()) {\n       sb.append(\"<li>\" + nameAnchor(node.name) + \"<ul>\");\n           }\n         }\n       }\n-      if (node.refersTo.size() > 0) {\n-        sb.append(\"<li>REFERS TO: \");\n-        Iterator<String> toIter = node.refersTo.iterator();\n-        while (toIter.hasNext()) {\n-          sb.append(nameLink(toIter.next()));\n-          if (toIter.hasNext()) {\n-            sb.append(\", \");\n+\n+      if (referenceGraph.hasNode(node)) {\n+        List<DiGraphEdge<JsName, RefType>> refersTo =\n+            referenceGraph.getOutEdges(node);\n+        if (refersTo.size() > 0) {\n+          sb.append(\"<li>REFERS TO: \");\n+          Iterator<DiGraphEdge<JsName, RefType>> toIter = refersTo.iterator();\n+          while (toIter.hasNext()) {\n+            sb.append(nameLink(toIter.next().getDestination().getValue().name));\n+            if (toIter.hasNext()) {\n+              sb.append(\", \");\n+            }\n           }\n         }\n-      }\n-      if (node.referencedBy.size() > 0) {\n-        sb.append(\"<li>REFERENCED BY: \");\n-        Iterator<String> fromIter = node.referencedBy.iterator();\n-        while (fromIter.hasNext()) {\n-          sb.append(nameLink(fromIter.next()));\n-          if (fromIter.hasNext()) {\n-            sb.append(\", \");\n+\n+        List<DiGraphEdge<JsName, RefType>> referencedBy =\n+            referenceGraph.getInEdges(node);\n+        if (referencedBy.size() > 0) {\n+          sb.append(\"<li>REFERENCED BY: \");\n+          Iterator<DiGraphEdge<JsName, RefType>> fromIter = refersTo.iterator();\n+          while (fromIter.hasNext()) {\n+            sb.append(\n+                nameLink(fromIter.next().getDestination().getValue().name));\n+            if (fromIter.hasNext()) {\n+              sb.append(\", \");\n+            }\n           }\n         }\n       }\n       while (curName.indexOf('.') != -1) {\n         String parentName = curName.substring(0, curName.lastIndexOf('.'));\n         if (!globalNames.contains(parentName)) {\n+\n           JsName parentJsName = getName(parentName, true);\n \n-          curJsName.refersTo.add(parentName);\n-          parentJsName.referencedBy.add(curName);\n-\n-          parentJsName.refersTo.add(curName);\n-          curJsName.referencedBy.add(parentName);\n+          recordReference(curJsName.name, parentJsName.name, RefType.REGULAR);\n+          recordReference(parentJsName.name, curJsName.name, RefType.REGULAR);\n \n           curJsName = parentJsName;\n         }\n   }\n \n   /**\n-   * Calculates all of the references. The results will be stored in the\n-   * generations member variable.\n+   * Propagate \"referenced\" property down the graph.\n    */\n   private void calculateReferences() {\n-    // Starting point is window + all externally defined names\n-\n-    Set<JsName> curGeneration = Sets.newHashSet();\n-\n     JsName window = getName(WINDOW, true);\n-    window.generation = 0;\n     window.referenced = true;\n-    curGeneration.add(window);\n     JsName function = getName(FUNCTION, true);\n-    function.generation = 0;\n     function.referenced = true;\n-    curGeneration.add(function);\n-\n-    for (String s : externalNames) {\n-      JsName jsn = getName(s, true);\n-      if (jsn.refersTo.size() > 0) {\n-        jsn.generation = 0;\n-        jsn.referenced = true;\n-        curGeneration.add(jsn);\n-      }\n-    }\n-    generations.add(curGeneration);\n-\n-    // Iterate through, adding more referenced nodes\n-    // capped at 100 for safety\n-    int iters = 0;\n-    while (curGeneration.size() > 0 && iters < 100) {\n-      curGeneration = referenceMore(curGeneration);\n-      generations.add(curGeneration);\n-      iters++;\n-    }\n-  }\n-\n-\n-  /**\n-   * Takes a set of JsNode and finds all of the nodes that they reference that\n-   * haven't already been marked as referenced. Marks the new nodes as\n-   * referenced and returns the newly marked nodes\n-   *\n-   * @param lastGen Starting nodes\n-   * @return Newly marked nodes\n-   */\n-  private Set<JsName> referenceMore(Set<JsName> lastGen) {\n-    Set<JsName> referenced = Sets.newTreeSet();\n-    for (JsName src : lastGen) {\n-      for (String s : src.refersTo) {\n-        JsName target = allNames.get(s);\n-        if (target != null && !target.referenced) {\n-          target.referenced = true;\n-          target.generation = src.generation + 1;\n-          referenced.add(target);\n-        }\n-      }\n-    }\n-    return referenced;\n-  }\n+\n+    // Propagate \"referenced\" property to a fixed point.\n+    FixedPointGraphTraversal.newTraversal(new ReferencePropagationCallback())\n+        .computeFixedPoint(referenceGraph);\n+  }\n+\n \n   /**\n    * Enum for saying a value can be true, false, or either (cleaner than using a\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n   static final String GOOG = \"goog\";\n \n   private final AbstractCompiler compiler;\n+  private final JSModuleGraph moduleGraph;\n \n   // The goog.provides must be processed in a deterministic order.\n   private final Map<String, ProvidedName> providedNames =\n-      Maps.newLinkedHashMap();\n+      Maps.newTreeMap();\n \n   private final List<UnrecognizedRequire> unrecognizedRequires =\n       Lists.newArrayList();\n                            CheckLevel requiresLevel,\n                            boolean rewriteNewDateGoogNow) {\n     this.compiler = compiler;\n+    this.moduleGraph = compiler.getModuleGraph();\n     this.requiresLevel = requiresLevel;\n     this.rewriteNewDateGoogNow = rewriteNewDateGoogNow;\n \n    * {@inheritDoc}\n    */\n   public void visit(NodeTraversal t, Node n, Node parent) {\n-    // TODO(nicksantos): Clean this method up.\n     switch (n.getType()) {\n       case Token.CALL:\n         boolean isExpr = parent.getType() == Token.EXPR_RESULT;\n               // All other methods must be called in an EXPR.\n               break;\n             } else if (\"require\".equals(methodName)) {\n-              Node arg = left.getNext();\n-              if (verifyArgument(t, left, arg)) {\n-                String ns = arg.getString();\n-                ProvidedName provided = providedNames.get(ns);\n-                if (provided == null || !provided.isExplicitlyProvided()) {\n-                  unrecognizedRequires.add(\n-                      new UnrecognizedRequire(n, ns, t.getSourceName()));\n-                } else {\n-                  JSModule module = t.getModule();\n-                  if (module != provided.firstModule /* covers null case */ &&\n-                      !compiler.getModuleGraph().dependsOn(module,\n-                          provided.firstModule)) {\n-                    compiler.report(\n-                        JSError.make(t, n, XMODULE_REQUIRE_ERROR, ns,\n-                            provided.firstModule.getName(),\n-                            module.getName()));\n-                  }\n-                }\n-\n-                // Requires should be removed before runtime.  The one\n-                // exception is if the type has not been provided yet and\n-                // errors for broken requires are turned off, in which case,\n-                // we will be doing a later pass that may error, so we can\n-                // leave this here this time and let it error next time if it\n-                // is still not provided.\n-                if (provided != null || requiresLevel.isOn()) {\n-                  parent.getParent().removeChild(parent);\n-                  compiler.reportCodeChange();\n-                }\n-              }\n+              processRequireCall(t, n, parent);\n             } else if (\"provide\".equals(methodName)) {\n-              Node arg = left.getNext();\n-              if (verifyProvide(t, left, arg)) {\n-                String ns = arg.getString();\n-                if (providedNames.containsKey(ns)) {\n-                  ProvidedName previouslyProvided = providedNames.get(ns);\n-                  if (!previouslyProvided.isExplicitlyProvided()) {\n-                    previouslyProvided.addProvide(parent, t.getModule(), true);\n-                  } else {\n-                    compiler.report(\n-                        JSError.make(t, n, DUPLICATE_NAMESPACE_ERROR, ns));\n-                  }\n-                } else {\n-                  registerAnyProvidedPrefixes(ns, parent, t.getModule());\n-                  providedNames.put(\n-                      ns, new ProvidedName(ns, parent, t.getModule(), true));\n-                }\n-              }\n+              processProvideCall(t, n, parent);\n             } else if (\"exportSymbol\".equals(methodName)) {\n               Node arg = left.getNext();\n               if (arg.getType() == Token.STRING) {\n         }\n         break;\n       case Token.ASSIGN:\n+      case Token.NAME:\n         // If this is an assignment to a provided name, remove the provided\n         // object.\n-        if (t.inGlobalScope() &&\n-            parent.getType() == Token.EXPR_RESULT) {\n-          Node nameNode = n.getFirstChild();\n-          String name = nameNode.getQualifiedName();\n-          if (name != null) {\n-            if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n-              processProvideFromPreviousPass(t, name, parent);\n-            } else {\n-              ProvidedName pn = providedNames.get(name);\n-              if (pn != null) {\n-                pn.addDefinition(parent);\n-              }\n-            }\n-          }\n-        }\n-        break;\n-      case Token.NAME:\n-        // If this is a declaration of a provided variable, remove the provided\n-        // object.\n-        if (t.inGlobalScope() &&\n-            parent.getType() == Token.VAR) {\n-          String name = n.getString();\n-          if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n-            processProvideFromPreviousPass(t, name, parent);\n-          } else {\n-            ProvidedName pn = providedNames.get(name);\n-            if (pn != null) {\n-              pn.addDefinition(parent);\n-            }\n-          }\n-        }\n+        handleCandidateProvideDefinition(t, n, parent);\n         break;\n       case Token.FUNCTION:\n         // If this is a declaration of a provided named function, this is an\n           reportBadBaseClassUse(t, n, \"May only be called directly.\");\n         }\n         break;\n+    }\n+  }\n+\n+  /**\n+   * Handles a goog.require call.\n+   */\n+  private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n+    Node left = n.getFirstChild();\n+    Node arg = left.getNext();\n+    if (verifyArgument(t, left, arg)) {\n+      String ns = arg.getString();\n+      ProvidedName provided = providedNames.get(ns);\n+      if (provided == null || !provided.isExplicitlyProvided()) {\n+        unrecognizedRequires.add(\n+            new UnrecognizedRequire(n, ns, t.getSourceName()));\n+      } else {\n+        JSModule module = t.getModule();\n+        if (module != provided.firstModule /* covers null case */ &&\n+            !compiler.getModuleGraph().dependsOn(module,\n+                provided.firstModule)) {\n+          compiler.report(\n+              JSError.make(t, n, XMODULE_REQUIRE_ERROR, ns,\n+                  provided.firstModule.getName(),\n+                  module.getName()));\n+        }\n+      }\n+\n+      // Requires should be removed before runtime.  The one\n+      // exception is if the type has not been provided yet and\n+      // errors for broken requires are turned off, in which case,\n+      // we will be doing a later pass that may error, so we can\n+      // leave this here this time and let it error next time if it\n+      // is still not provided.\n+      if (provided != null || requiresLevel.isOn()) {\n+        parent.detachFromParent();\n+        compiler.reportCodeChange();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Handles a goog.provide call.\n+   */\n+  private void processProvideCall(NodeTraversal t, Node n, Node parent) {\n+    Node left = n.getFirstChild();\n+    Node arg = left.getNext();\n+    if (verifyProvide(t, left, arg)) {\n+      String ns = arg.getString();\n+      if (providedNames.containsKey(ns)) {\n+        ProvidedName previouslyProvided = providedNames.get(ns);\n+        if (!previouslyProvided.isExplicitlyProvided()) {\n+          previouslyProvided.addProvide(parent, t.getModule(), true);\n+        } else {\n+          compiler.report(\n+              JSError.make(t, n, DUPLICATE_NAMESPACE_ERROR, ns));\n+        }\n+      } else {\n+        registerAnyProvidedPrefixes(ns, parent, t.getModule());\n+        providedNames.put(\n+            ns, new ProvidedName(ns, parent, t.getModule(), true));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Handles a candidate definition for a goog.provided name.\n+   */\n+  private void handleCandidateProvideDefinition(\n+      NodeTraversal t, Node n, Node parent) {\n+    if (t.inGlobalScope()) {\n+      String name = null;\n+      if (n.getType() == Token.NAME && parent.getType() == Token.VAR) {\n+        name = n.getString();\n+      } else if (n.getType() == Token.ASSIGN &&\n+          parent.getType() == Token.EXPR_RESULT) {\n+        name = n.getFirstChild().getQualifiedName();\n+      }\n+\n+      if (name != null) {\n+        if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n+          processProvideFromPreviousPass(t, name, parent);\n+        } else {\n+          ProvidedName pn = providedNames.get(name);\n+          if (pn != null) {\n+            pn.addDefinition(parent, t.getModule());\n+          }\n+        }\n+      }\n     }\n   }\n \n       parent.getParent().addChildBefore(expr, parent);\n       compiler.reportCodeChange();\n \n-      registerAnyProvidedPrefixes(name, expr, t.getModule());\n-\n-      ProvidedName provided = new ProvidedName(name, expr, t.getModule(), true);\n+      JSModule module = t.getModule();\n+      registerAnyProvidedPrefixes(name, expr, module);\n+\n+      ProvidedName provided = new ProvidedName(name, expr, module, true);\n       providedNames.put(name, provided);\n-      provided.addDefinition(parent);\n+      provided.addDefinition(parent, module);\n     } else {\n       // Remove this provide if it came from a previous pass since we have an\n       // replacement already.\n \n     // The candidate definition.\n     private Node candidateDefinition = null;\n+    private JSModule candidateModule = null;\n+\n+    // The minimum module where the provide must appear.\n+    private JSModule minimumModule = null;\n+\n+    // The replacement declaration.\n+    private Node replacementNode = null;\n \n     ProvidedName(String namespace, Node node, JSModule module,\n         boolean explicit) {\n      * Add an implicit or explicit provide.\n      */\n     void addProvide(Node node, JSModule module, boolean explicit) {\n-      // TODO(nicksantos): Fixing this pass in the presence of modules\n-      // will require the module parameter.\n       if (explicit) {\n         Preconditions.checkState(explicitNode == null);\n         Preconditions.checkArgument(NodeUtil.isExpressionNode(node));\n         explicitNode = node;\n       }\n+      updateMinimumModule(module);\n     }\n \n     boolean isExplicitlyProvided() {\n      * declarations; if no declation exists record a reference to an\n      * assignment so it repurposed later.\n      */\n-    void addDefinition(Node node) {\n+    void addDefinition(Node node, JSModule module) {\n       Preconditions.checkArgument(NodeUtil.isExpressionNode(node) || // assign\n                                   NodeUtil.isFunction(node) ||\n                                   NodeUtil.isVar(node));\n       Preconditions.checkArgument(explicitNode != node);\n       if ((candidateDefinition == null) || !NodeUtil.isExpressionNode(node)) {\n         candidateDefinition = node;\n+        candidateModule = module;\n+        updateMinimumModule(module);\n+      }\n+    }\n+\n+    private void updateMinimumModule(JSModule newModule) {\n+      if (moduleGraph != null) {\n+        if (minimumModule == null) {\n+          minimumModule = newModule;\n+        } else {\n+          minimumModule = moduleGraph.getDeepestCommonDependencyInclusive(\n+              minimumModule, newModule);\n+        }\n       }\n     }\n \n     void replace() {\n       if (firstNode == null) {\n         // Don't touch the base case ('goog').\n+        replacementNode = candidateDefinition;\n         return;\n       }\n \n         compiler.reportCodeChange();\n \n         // Does this need a VAR keyword?\n+        replacementNode = candidateDefinition;\n         if (NodeUtil.isExpressionNode(candidateDefinition)) {\n           candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n           Node assignNode = candidateDefinition.getFirstChild();\n                 candidateDefinition, varNode);\n             nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n             compiler.reportCodeChange();\n+            replacementNode = varNode;\n           }\n         }\n       } else {\n         // Handle the case where there's not a duplicate definition.\n-        Node declaration = createDeclarationNode();\n-\n-        // The node was implicitly provided, so insert it before\n-        // the explicit provide.\n-        if (explicitNode != firstNode) {\n-          firstNode.getParent().addChildBefore(declaration, firstNode);\n-          if (explicitNode != null) {\n-            explicitNode.detachFromParent();\n+        replacementNode = createDeclarationNode();\n+        if (firstModule == minimumModule) {\n+          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n+        } else {\n+          // In this case, the name was implicitly provided by two independent\n+          // modules. We need to move this code up to a common module.\n+          int indexOfDot = namespace.indexOf('.');\n+          if (indexOfDot == -1) {\n+            // Any old place is fine.\n+            compiler.getNodeForCodeInsertion(minimumModule)\n+                .addChildToBack(replacementNode);\n+          } else {\n+            // Add it after the parent namespace.\n+            ProvidedName parentName =\n+                providedNames.get(namespace.substring(0, indexOfDot));\n+            Preconditions.checkNotNull(parentName);\n+            Preconditions.checkNotNull(parentName.replacementNode);\n+            parentName.replacementNode.getParent().addChildAfter(\n+                replacementNode, parentName.replacementNode);\n           }\n-        } else {\n-          Preconditions.checkNotNull(explicitNode);\n-          explicitNode.getParent().replaceChild(explicitNode, declaration);\n+        }\n+        if (explicitNode != null) {\n+          explicitNode.detachFromParent();\n         }\n         compiler.reportCodeChange();\n       }\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n              res == null && n != null;\n              n = n.next, n2 = n2.next) {\n             res = n.checkTreeEqualsImpl(n2);\n+            if (res != null) {\n+              return res;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /**\n+     * Checks if the subtree under this node is the same as another subtree\n+     * including types. Returns null if it's equal, or a message describing the\n+     * differences.\n+     */\n+    public boolean checkTreeTypeAwareEqualsSilent(Node node2) {\n+      return checkTreeTypeAwareEqualsImpl(node2) == null;\n+    }\n+\n+    /**\n+     * Compare this node to node2 recursively and return the first pair\n+     * of nodes that differs doing a preorder depth-first traversal.\n+     * Package private for testing. Returns null if the nodes are equivalent.\n+     */\n+    NodeMismatch checkTreeTypeAwareEqualsImpl(Node node2) {\n+        boolean eq = false;\n+\n+        if (type == node2.getType() &&\n+            getChildCount() == node2.getChildCount() &&\n+            getClass() == node2.getClass() &&\n+            Objects.equal(jsType, node2.getJSType())) {\n+\n+            eq = this.isEquivalentTo(node2);\n+        }\n+\n+        if (!eq) {\n+            return new NodeMismatch(this, node2);\n+        }\n+\n+        NodeMismatch res = null;\n+        Node n, n2;\n+        for (n = first, n2 = node2.first;\n+             res == null && n != null;\n+             n = n.next, n2 = n2.next) {\n+            res = n.checkTreeTypeAwareEqualsImpl(n2);\n             if (res != null) {\n               return res;\n             }\n--- a/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n          \"goog.provide('goog.foo.bar'); goog.provide('goog.foo');\",\n          \"var goog = {}; goog.foo = {}; goog.foo.bar = {};\");\n   }\n+\n+  public void testImplicitProvideInIndependentModules() {\n+    test(\n+        createModuleStar(\n+            \"\",\n+            \"goog.provide('apps.A');\",\n+            \"goog.provide('apps.B');\"),\n+        new String[] {\n+            \"var apps = {};\",\n+            \"apps.A = {};\",\n+            \"apps.B = {};\",\n+        });\n+  }\n+\n+  public void testImplicitProvideInIndependentModules2() {\n+    test(\n+        createModuleStar(\n+            \"goog.provide('apps');\",\n+            \"goog.provide('apps.foo.A');\",\n+            \"goog.provide('apps.foo.B');\"),\n+        new String[] {\n+            \"var apps = {}; apps.foo = {};\",\n+            \"apps.foo.A = {};\",\n+            \"apps.foo.B = {};\",\n+        });\n+  }\n+\n+  public void testImplicitProvideInIndependentModules3() {\n+    test(\n+        createModuleStar(\n+            \"var goog = {};\",\n+            \"goog.provide('goog.foo.A');\",\n+            \"goog.provide('goog.foo.B');\"),\n+        new String[] {\n+            \"var goog = {}; goog.foo = {};\",\n+            \"goog.foo.A = {};\",\n+            \"goog.foo.B = {};\",\n+        });\n+  }\n+\n+  public void testProvideInIndependentModules1() {\n+    test(\n+        createModuleStar(\n+            \"goog.provide('apps');\",\n+            \"goog.provide('apps.foo');\",\n+            \"goog.provide('apps.foo.B');\"),\n+        new String[] {\n+            \"var apps = {}; apps.foo = {};\",\n+            \"\",\n+            \"apps.foo.B = {};\",\n+        });\n+  }\n+\n+  public void testProvideInIndependentModules2() {\n+    // TODO(nicksantos): Make this an error.\n+    test(\n+        createModuleStar(\n+            \"goog.provide('apps');\",\n+            \"goog.provide('apps.foo'); apps.foo = {};\",\n+            \"goog.provide('apps.foo.B');\"),\n+        new String[] {\n+            \"var apps = {};\",\n+            \"apps.foo = {};\",\n+            \"apps.foo.B = {};\",\n+        });\n+  }\n }\n--- a/test/com/google/javascript/rhino/NodeTest.java\n+++ b/test/com/google/javascript/rhino/NodeTest.java\n package com.google.javascript.rhino;\n \n import com.google.javascript.rhino.Node.NodeMismatch;\n+import com.google.javascript.rhino.jstype.JSTypeNative;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.testing.TestErrorReporter;\n \n import junit.framework.TestCase;\n     node1.putIntProp(Node.INCRDECR_PROP, 1);\n     Node node2 = new Node(Token.INC);\n     assertNotNull(node1.checkTreeEqualsImpl(node2));\n+  }\n+\n+  public void testCheckTreeTypeAwareEqualsSame() {\n+    TestErrorReporter testErrorReporter = new TestErrorReporter(null, null);\n+    JSTypeRegistry registry = new JSTypeRegistry(testErrorReporter);\n+    Node node1 = Node.newString(Token.NAME, \"f\");\n+    node1.setJSType(registry.getNativeType(JSTypeNative.NUMBER_TYPE));\n+    Node node2 = Node.newString(Token.NAME, \"f\");\n+    node2.setJSType(registry.getNativeType(JSTypeNative.NUMBER_TYPE));\n+    assertTrue(node1.checkTreeTypeAwareEqualsSilent(node2));\n+  }\n+\n+  public void testCheckTreeTypeAwareEqualsSameNull() {\n+    TestErrorReporter testErrorReporter = new TestErrorReporter(null, null);\n+    JSTypeRegistry registry = new JSTypeRegistry(testErrorReporter);\n+    Node node1 = Node.newString(Token.NAME, \"f\");\n+    Node node2 = Node.newString(Token.NAME, \"f\");\n+    assertTrue(node1.checkTreeTypeAwareEqualsSilent(node2));\n+  }\n+\n+  public void testCheckTreeTypeAwareEqualsDifferent() {\n+    TestErrorReporter testErrorReporter = new TestErrorReporter(null, null);\n+    JSTypeRegistry registry = new JSTypeRegistry(testErrorReporter);\n+    Node node1 = Node.newString(Token.NAME, \"f\");\n+    node1.setJSType(registry.getNativeType(JSTypeNative.NUMBER_TYPE));\n+    Node node2 = Node.newString(Token.NAME, \"f\");\n+    node2.setJSType(registry.getNativeType(JSTypeNative.STRING_TYPE));\n+    assertFalse(node1.checkTreeTypeAwareEqualsSilent(node2));\n+  }\n+\n+  public void testCheckTreeTypeAwareEqualsDifferentNull() {\n+    TestErrorReporter testErrorReporter = new TestErrorReporter(null, null);\n+    JSTypeRegistry registry = new JSTypeRegistry(testErrorReporter);\n+    Node node1 = Node.newString(Token.NAME, \"f\");\n+    node1.setJSType(registry.getNativeType(JSTypeNative.NUMBER_TYPE));\n+    Node node2 = Node.newString(Token.NAME, \"f\");\n+    assertFalse(node1.checkTreeTypeAwareEqualsSilent(node2));\n   }\n \n   public void testVarArgs1() {", "timestamp": 1265657455, "metainfo": ""}