{"sha": "75aa5f653b08995428743f6951a99ad101e73e37", "log": "Cleanup obsolete handling of NUMBER keys of OBJECTLIT.  R=nicksantos DELTA=109  (3 added, 48 deleted, 58 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1253   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AmbiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/AmbiguateProperties.java\n           for (Node child = n.getFirstChild();\n                child != null;\n                child = child.getNext()) {\n-            if (child.getType() != Token.NUMBER) {\n-              // Everything else are names: STRING, GET, SET\n-              externedNames.add(child.getString());\n-            }\n+            // names: STRING, GET, SET\n+            externedNames.add(child.getString());\n           }\n           break;\n       }\n           // are the children of the keys.\n           for (Node key = n.getFirstChild(); key != null;\n                key = key.getNext()) {\n-            // We only want keys that are strings (not numbers), and only keys\n-            // that were unquoted.\n-            if (key.getType() != Token.NUMBER) {\n-              // Everything else are names: STRING, GET, SET\n-              if (!key.isQuotedString()) {\n-                JSType jstype = getJSType(n.getFirstChild());\n-                maybeMarkCandidate(key, jstype, t);\n-              } else {\n-                // Ensure that we never rename some other property in a way\n-                // that could conflict with this quoted key.\n-                quotedNames.add(key.getString());\n-              }\n+            // We only want keys that were unquoted.\n+            // Keys are STRING, GET, SET\n+            if (!key.isQuotedString()) {\n+              JSType jstype = getJSType(n.getFirstChild());\n+              maybeMarkCandidate(key, jstype, t);\n+            } else {\n+              // Ensure that we never rename some other property in a way\n+              // that could conflict with this quoted key.\n+              quotedNames.add(key.getString());\n             }\n           }\n           break;\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n         // should count as a use of property a and b.\n         for (Node propNameNode = n.getFirstChild(); propNameNode != null;\n              propNameNode = propNameNode.getNext()) {\n-          // May be NUMBER, STRING, GET, or SET, but NUMBER isn't interesting.\n-          if (propNameNode.getType() != Token.NUMBER &&\n-              !propNameNode.isQuotedString()) {\n+          // May be STRING, GET, or SET, but NUMBER isn't interesting.\n+          if (!propNameNode.isQuotedString()) {\n             addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n           }\n         }\n           if (map.getType() == Token.OBJECTLIT) {\n             for (Node key = map.getFirstChild();\n                  key != null; key = key.getNext()) {\n-              // May be NUMBER, STRING, GET, or SET,\n-              // but NUMBER isn't interesting.\n-              if (key.getType() != Token.NUMBER) {\n-                String name = key.getString();\n-                Property prop = new LiteralProperty(\n-                    key, key.getFirstChild(), map, n, t.getModule());\n-                getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n-              }\n+              // May be STRING, GET, or SET,\n+              String name = key.getString();\n+              Property prop = new LiteralProperty(\n+                  key, key.getFirstChild(), map, n, t.getModule());\n+              getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n             }\n           }\n           break;\n--- a/src/com/google/javascript/jscomp/AnonymousFunctionNamingCallback.java\n+++ b/src/com/google/javascript/jscomp/AnonymousFunctionNamingCallback.java\n          keyNode = keyNode.getNext()) {\n       Node valueNode = keyNode.getFirstChild();\n \n-      // Object literal keys may be STRING, GET, SET or NUMBER.  Numbers are\n-      // skipped because name tokens may not start with a number. Get and Set\n+      // Object literal keys may be STRING, GET, SET. Get and Set\n       // are skipped because they can not be named.\n       if (keyNode.getType() == Token.STRING) {\n         // concatenate the context and key name to get a new qualified name.\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n             pType == Token.ASSIGN ||\n \n             // object literal keys\n-            pType == Token.STRING ||\n-            pType == Token.NUMBER)) {\n+            pType == Token.STRING)) {\n         return false;\n       }\n \n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n         break;\n \n       case Token.NUMBER:\n-        Preconditions.checkState(\n-            childCount ==\n-            ((n.getParent() != null &&\n-              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));\n+        Preconditions.checkState(childCount == 0);\n         cc.addNumber(n.getDouble());\n         break;\n \n--- a/src/com/google/javascript/jscomp/ConvertToDottedProperties.java\n+++ b/src/com/google/javascript/jscomp/ConvertToDottedProperties.java\n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     switch (n.getType()) {\n+      case Token.GET:\n+      case Token.SET:\n       case Token.STRING:\n         if (NodeUtil.isObjectLitKey(n, parent)) {\n           n.putBooleanProp(Node.QUOTED_PROP, false);\n--- a/src/com/google/javascript/jscomp/DefinitionsRemover.java\n+++ b/src/com/google/javascript/jscomp/DefinitionsRemover.java\n           return new Node(Token.GETPROP,\n             new Node(Token.OBJECTLIT),\n             name.cloneNode());\n-        case Token.NUMBER:\n-          return new Node(Token.GETELEM,\n-            new Node(Token.OBJECTLIT),\n-            name.cloneNode());\n         default:\n           throw new IllegalStateException(\"unexpected\");\n       }\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n     private void handleObjectLit(NodeTraversal t, Node n) {\n       Node child = n.getFirstChild();\n       while (child != null) {\n-        // Maybe STRING, NUMBER, GET, SET\n-        if (child.getType() != Token.NUMBER) {\n-          // We should never see a mix of numbers and strings.\n-          String name = child.getString();\n-          T type = typeSystem.getType(getScope(), n, name);\n-\n-          Property prop = getProperty(name);\n-          if (!prop.scheduleRenaming(child,\n-                                     processProperty(t, prop, type, null))) {\n-            if (showInvalidationWarnings) {\n-              compiler.report(JSError.make(\n-                  t.getSourceName(), child, Warnings.INVALIDATION, name,\n-                  (type == null ? \"null\" : type.toString()), n.toString()));\n-            }\n+        // Maybe STRING, GET, SET\n+\n+        // We should never see a mix of numbers and strings.\n+        String name = child.getString();\n+        T type = typeSystem.getType(getScope(), n, name);\n+\n+        Property prop = getProperty(name);\n+        if (!prop.scheduleRenaming(child,\n+                                   processProperty(t, prop, type, null))) {\n+          if (showInvalidationWarnings) {\n+            compiler.report(JSError.make(\n+                t.getSourceName(), child, Warnings.INVALIDATION, name,\n+                (type == null ? \"null\" : type.toString()), n.toString()));\n           }\n         }\n \n--- a/src/com/google/javascript/jscomp/MethodCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/MethodCompilerPass.java\n \n         case Token.OBJECTLIT: {\n           for (Node key = n.getFirstChild(); key != null; key = key.getNext()) {\n-            if (key.getType() != Token.NUMBER) {\n-              Node value = key.getFirstChild();\n-              String name = key.getString();\n-              if (key.getType() == Token.STRING\n-                  && value.getType() == Token.FUNCTION) {\n-                addSignature(name, value, t.getSourceName());\n-              } else {\n-                getSignatureStore().removeSignature(name);\n-                externMethodsWithoutSignatures.add(name);\n-              }\n-              externMethods.add(name);\n+            Node value = key.getFirstChild();\n+            String name = key.getString();\n+            if (key.getType() == Token.STRING\n+                && value.getType() == Token.FUNCTION) {\n+              addSignature(name, value, t.getSourceName());\n+            } else {\n+              getSignatureStore().removeSignature(name);\n+              externMethodsWithoutSignatures.add(name);\n             }\n+            externMethods.add(name);\n           }\n         } break;\n       }\n               case Token.SET:\n               case Token.GET:\n                 nonMethodProperties.add(key.getString());\n-                break;\n-              case Token.NUMBER:\n-                // Ignore numberic keys.\n                 break;\n               default:\n                 throw new IllegalStateException(\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    */\n   static boolean isObjectLitKey(Node node, Node parent) {\n     switch (node.getType()) {\n-      case Token.NUMBER:\n       case Token.STRING:\n         return parent.getType() == Token.OBJECTLIT;\n       case Token.GET:\n    */\n   static String getObjectLitKeyName(Node key) {\n     switch (key.getType()) {\n-      case Token.NUMBER:\n-        return NodeUtil.getStringValue(key);\n       case Token.STRING:\n       case Token.GET:\n       case Token.SET:\n--- a/src/com/google/javascript/jscomp/RenameProperties.java\n+++ b/src/com/google/javascript/jscomp/RenameProperties.java\n           for (Node child = n.getFirstChild();\n                child != null;\n                child = child.getNext()) {\n-            if (child.getType() != Token.NUMBER) { // expect STRING, GET, SET\n-              externedNames.add(child.getString());\n-            }\n+            externedNames.add(child.getString());\n           }\n           break;\n       }\n           break;\n         case Token.OBJECTLIT:\n           for (Node key = n.getFirstChild(); key != null; key = key.getNext()) {\n-            // We only want keys that are strings (not numbers), and only keys\n-            // that were unquoted.\n-            if (key.getType() != Token.NUMBER) {\n-              if (!key.isQuotedString()) {\n-                maybeMarkCandidate(key);\n-              } else {\n-                // Ensure that we never rename some other property in a way\n-                // that could conflict with this quoted key.\n-                quotedNames.add(key.getString());\n-              }\n+            if (!key.isQuotedString()) {\n+              maybeMarkCandidate(key);\n+            } else {\n+              // Ensure that we never rename some other property in a way\n+              // that could conflict with this quoted key.\n+              quotedNames.add(key.getString());\n             }\n           }\n           break;\n--- a/src/com/google/javascript/jscomp/SourceInformationAnnotator.java\n+++ b/src/com/google/javascript/jscomp/SourceInformationAnnotator.java\n       case Token.OBJECTLIT:\n         for (Node key = n.getFirstChild(); key != null;\n              key = key.getNext()) {\n-           // We only want keys that are strings (not numbers), and only keys\n-           // that were unquoted.\n-           if (key.getType() != Token.NUMBER) {\n-             if (!key.isQuotedString()) {\n-               key.putProp(Node.ORIGINALNAME_PROP, key.getString());\n-             }\n+           // We only want keys were unquoted.\n+           if (!key.isQuotedString()) {\n+             key.putProp(Node.ORIGINALNAME_PROP, key.getString());\n            }\n          }\n         break;\n--- a/src/com/google/javascript/jscomp/StrictModeCheck.java\n+++ b/src/com/google/javascript/jscomp/StrictModeCheck.java\n       for (Node key = n.getFirstChild();\n            key != null;\n            key = key.getNext()) {\n-        if (key.getType() != Token.NUMBER && key.getString().endsWith(\"__\")) {\n+        if (key.getString().endsWith(\"__\")) {\n           t.report(key, ILLEGAL_NAME);\n         }\n       }\n--- a/src/com/google/javascript/jscomp/StripCode.java\n+++ b/src/com/google/javascript/jscomp/StripCode.java\n       //   ...\n       Node key = n.getFirstChild();\n       while (key != null) {\n-        if (key.getType() != Token.NUMBER\n-            && isStripName(key.getString())) {\n+        if (isStripName(key.getString())) {\n           Node value = key.getFirstChild();\n           Node next = key.getNext();\n           n.removeChild(key);\n--- a/src/com/google/javascript/jscomp/SuspiciousPropertiesCheck.java\n+++ b/src/com/google/javascript/jscomp/SuspiciousPropertiesCheck.java\n           for (Node child = n.getFirstChild();\n                child != null;\n                child = child.getNext()) {\n-            if (child.getType() != Token.NUMBER) {\n-              externPropertyNames.add(child.getString());\n-            }\n+            externPropertyNames.add(child.getString());\n           }\n           break;\n         case Token.NAME:\n           for (Node child = n.getFirstChild();\n                child != null;\n                child = child.getNext()) {\n-            if (child.getType() != Token.NUMBER) {\n-              addWrite(child, t, true);\n-            }\n+            addWrite(child, t, true);\n           }\n           break;\n         case Token.CALL:\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n         break;\n \n       case Token.NUMBER:\n-        // Object literal keys are handled with OBJECTLIT\n-        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n-          ensureTyped(t, n, NUMBER_TYPE);\n-        }\n+        ensureTyped(t, n, NUMBER_TYPE);\n         break;\n \n       case Token.STRING:\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n           break;\n \n         case Token.NUMBER:\n-          // Defer keys to the Token.OBJECTLIT case\n-          if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n-            n.setJSType(getNativeType(NUMBER_TYPE));\n-          }\n+          n.setJSType(getNativeType(NUMBER_TYPE));\n           break;\n \n         case Token.TRUE:", "timestamp": 1301953254, "metainfo": ""}