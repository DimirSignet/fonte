{"sha": "828828472848b88b6d3b1e847fa8be5dde78e2da", "log": "Make sure that the compiler doesn't crash when you have function f(undefined) {} and you left out the default externs. I blame this on a poorly-named function  R=johnlenz DELTA=70  (53 added, 7 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1920   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n-      if (n != null && NodeUtil.isLhs(n, assign) &&\n+      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) &&\n           n.getType() == Token.GETPROP) {\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n \n           if (dest.getType() == Token.STRING &&\n               NodeUtil.isExprAssign(grandParent) &&\n-              NodeUtil.isLhs(n, parent)) {\n+              NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n             String name = dest.getString();\n             Property prop = new AssignmentProperty(grandParent, t.getModule());\n             getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n     private static boolean isReadFrom(Var var, Node name) {\n       return name != null && NodeUtil.isName(name) &&\n           var.getName().equals(name.getString()) &&\n-          !NodeUtil.isLhs(name, name.getParent());\n+          !NodeUtil.isVarOrSimpleAssignLhs(name, name.getParent());\n     }\n   }\n }\n--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n     }\n \n     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n-      if (NodeUtil.isLhs(n, n.getParent())) {\n+      if (NodeUtil.isVarOrSimpleAssignLhs(n, n.getParent())) {\n         Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n         // The expression to which the assignment is made is evaluated before\n         // the RHS is evaluated (normal left to right evaluation) but the KILL\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n       // This is a simple call?  Example: \"foo();\".\n       return CallSiteType.SIMPLE_CALL;\n     } else if (NodeUtil.isExprAssign(grandParent)\n-        && !NodeUtil.isLhs(callNode, parent)\n+        && !NodeUtil.isVarOrSimpleAssignLhs(callNode, parent)\n         && parent.getFirstChild().getType() == Token.NAME\n         && !NodeUtil.isConstantName(parent.getFirstChild())) {\n       // This is a simple assignment.  Example: \"x = foo();\"\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n \n       // An assignment implies a reference from the enclosing dependency scope.\n       // For example, foo references bar in: function foo() {bar=5}.\n-      if (NodeUtil.isLhs(n, parent)) {\n+      if (NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n         if (referring != null) {\n           recordReference(referringName, name, RefType.REGULAR);\n         }\n      */\n     private boolean maybeHiddenAlias(String name, Node n) {\n       Node parent = n.getParent();\n-      if (NodeUtil.isLhs(n, parent)) {\n+      if (NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n         Node rhs = (parent.getType() == Token.VAR)\n             ? n.getFirstChild() : parent.getLastChild();\n         return (rhs != null && !NodeUtil.evaluatesToLocalValue(\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    * @param parent Parent of the node\n    * @return True if n is the left hand of an assign\n    */\n-  static boolean isLhs(Node n, Node parent) {\n+  static boolean isVarOrSimpleAssignLhs(Node n, Node parent) {\n     return (parent.getType() == Token.ASSIGN && parent.getFirstChild() == n) ||\n            parent.getType() == Token.VAR;\n+  }\n+\n+  /**\n+   * Determines whether this node is used as an L-value. Notice that sometimes\n+   * names are used as both L-values and R-values.\n+   *\n+   * We treat \"var x;\" as a pseudo-L-value, which kind of makes sense if you\n+   * treat it as \"assignment to 'undefined' at the top of the scope\". But if\n+   * we're honest with ourselves, it doesn't make sense, and we only do this\n+   * because it makes sense to treat this as synactically similar to\n+   * \"var x = 0;\".\n+   *\n+   * @param node The node\n+   * @return True if n is an L-value.\n+   */\n+  static boolean isLValue(Node node) {\n+    int nType = node.getType();\n+    Preconditions.checkArgument(nType == Token.NAME || nType == Token.GETPROP ||\n+        nType == Token.GETELEM);\n+    Node parent = node.getParent();\n+    return (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == node)\n+        || (NodeUtil.isForIn(parent) && parent.getFirstChild() == node)\n+        || NodeUtil.isVar(parent)\n+        || (parent.getType() == Token.FUNCTION &&\n+            parent.getFirstChild() == node)\n+        || parent.getType() == Token.DEC\n+        || parent.getType() == Token.INC\n+        || parent.getType() == Token.LP\n+        || parent.getType() == Token.CATCH;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n     // TODO(johnlenz): consider doing this as a normalization.\n     if (isASTNormalized()\n         && NodeUtil.isUndefined(n)\n-        && !NodeUtil.isLhs(n, n.getParent())) {\n+        && !NodeUtil.isLValue(n)) {\n       Node replacement = NodeUtil.newUndefinedNode(n);\n       n.getParent().replaceChild(n, replacement);\n       reportCodeChange();\n--- a/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n+++ b/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n      */\n     private static boolean storageNodeIsLValue(Node node) {\n       Preconditions.checkArgument(isStorageNode(node));\n-\n-      Node parent = node.getParent();\n-\n-      return (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == node)\n-          || (NodeUtil.isForIn(parent) && parent.getFirstChild() == node)\n-          || NodeUtil.isVar(parent)\n-          || parent.getType() == Token.DEC\n-          || parent.getType() == Token.INC;\n+      return NodeUtil.isLValue(node);\n     }\n \n     /**\n--- a/test/com/google/javascript/jscomp/CompilerTest.java\n+++ b/test/com/google/javascript/jscomp/CompilerTest.java\n     assertEquals(compiler.externAndJsRoot, compiler.externsRoot.getParent());\n     assertNotNull(compiler.externAndJsRoot);\n   }\n+\n+  public void testLocalUndefined() throws Exception {\n+    // Some javascript libraries like to create a local instance of \"undefined\",\n+    // to ensure that other libraries don't try to overwrite it.\n+    //\n+    // Most of the time, this is ok, because normalization will rename\n+    // that variable to undefined$$1. But this won't happen if they don't\n+    // include the default externs.\n+    //\n+    // This test is just to make sure that the compiler doesn't crash.\n+    CompilerOptions options = new CompilerOptions();\n+    CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(\n+        options);\n+    Compiler compiler = new Compiler();\n+    JSSourceFile externs = JSSourceFile.fromCode(\"externs.js\", \"\");\n+    JSSourceFile input = JSSourceFile.fromCode(\"input.js\",\n+        \"(function (undefined) { alert(undefined); })();\");\n+    compiler.compile(externs, input, options);\n+  }\n }\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n     foldSame(\n         \"var undefined = 1;\" +\n         \"function f() {var undefined=2;var x = undefined;}\");\n+    foldSame(\"function f(undefined) {}\");\n+    foldSame(\"try {} catch(undefined) {}\");\n+    foldSame(\"for (undefined in {}) {}\");\n+    foldSame(\"undefined++;\");\n+    fold(\"undefined += undefined;\", \"undefined += void 0;\");\n   }\n \n   public void testSplitCommaExpressions() {", "timestamp": 1305583279, "metainfo": ""}