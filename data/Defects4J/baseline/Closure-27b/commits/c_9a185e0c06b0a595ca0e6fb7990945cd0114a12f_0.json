{"sha": "9a185e0c06b0a595ca0e6fb7990945cd0114a12f", "log": "Run cross module code motion before and after devirtualization. (Alan)  Making ErrorPass package-private. (Brad)  Improve strict equality comparisons. (John)  Update comments and minor cleanup of Normalize. (John)  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ErrorPass.java\n+++ b/src/com/google/javascript/jscomp/ErrorPass.java\n *\n  */\n \n-public class ErrorPass implements CompilerPass {\n-    private final AbstractCompiler compiler;\n-    private final JSError error;\n-    \n-    public ErrorPass(AbstractCompiler compiler, DiagnosticType error) {\n-      this(compiler, JSError.make(error));\n-    }\n+class ErrorPass implements CompilerPass {\n+  private final AbstractCompiler compiler;\n+  private final JSError error;\n \n-    public ErrorPass(AbstractCompiler compiler, JSError error) {\n-      this.compiler = compiler;\n-      this.error = error;\n-    }\n+  ErrorPass(AbstractCompiler compiler, DiagnosticType error) {\n+    this(compiler, JSError.make(error));\n+  }\n \n-    @Override\n-    public void process(Node externs, Node root) {\n-      compiler.report(error);\n-    }\n+  ErrorPass(AbstractCompiler compiler, JSError error) {\n+    this.compiler = compiler;\n+    this.error = error;\n   }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    compiler.report(error);\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/FoldConstants.java\n+++ b/src/com/google/javascript/jscomp/FoldConstants.java\n             tt != Token.NULL)\n           return;\n         switch (op) {\n+          case Token.SHEQ:\n           case Token.EQ:\n             result = left.getType() == right.getType();\n             break;\n \n+          case Token.SHNE:            \n           case Token.NE:\n             result = left.getType() != right.getType();\n             break;\n           return;  // Only eval if they are the same type\n         }\n         switch (op) {\n+          case Token.SHEQ:\n           case Token.EQ:\n             result = left.getString().equals(right.getString());\n             break;\n \n+          case Token.SHNE:\n           case Token.NE:\n             result = !left.getString().equals(right.getString());\n             break;\n         double rv = right.getDouble();\n \n         switch (op) {\n+          case Token.SHEQ:\n           case Token.EQ: result = lv == rv; break;\n+          case Token.SHNE:\n           case Token.NE: result = lv != rv; break;\n           case Token.LE: result = lv <= rv; break;\n           case Token.LT: result = lv <  rv; break;\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n  * all is said and done.\n  *\n  * This pass currently does the following:\n- * 1) Splits var statements contains multiple declarations into individual\n- * statements.\n- * 2) Splits chained assign statements such as \"a = b = c = 0\" into individual\n- * statements.  These are split as follows \"c = 0; b = c; a = b\". Unfortunately,\n- * not all such statements can be broken up, for instance:\n- *   \"a[next()] = a[next()] = 0\"\n- * can not be made into\n- *   \"a[next()] = 0; a[next()] = a[next()];\n- * 3) init expressions in FOR statements are extracted and placed before the\n- * statement. For example: \"for(var a=0;;);\" becomes \"var a=0;for(;;);\"\n- * 4) WHILE statements are converted to FOR statements. For example:\n- * \"while(true);\" becomes \"for(;true;);\"\n- * 5) Renames constant variables, as marked with an IS_CONSTANT_NAME annotation,\n- *   to include a suffix of NodeUtil.CONSTANT_MARKER which is used by constant\n- *   inlining.\n+ * 1) Simplifies the AST by splitting var statements, moving initializiers\n+ *    out of for loops, and converting whiles to fors.\n+ * 2) Makes all variable names globally unique (extern or otherwise) so that\n+ *    no value is ever shadowed (note: \"arguments\" may require special\n+ *    handling).\n+ * 3) Removes duplicate variable declarations.\n+ * 4) Marks constants with the IS_CONSTANT_NAME annotation.\n  *\n *\n  */\n // public for ReplaceDebugStringsTest\n-class Normalize implements CompilerPass, Callback {\n+class Normalize implements CompilerPass {\n \n   private final AbstractCompiler compiler;\n   private final boolean assertOnChange;\n \n   @Override\n   public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, this);\n+    NodeTraversal.traverse(compiler, root,\n+        new NormalizeStatements(compiler, assertOnChange));\n     removeDuplicateDeclarations(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n     }\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n-  }\n-\n-  @Override\n-  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    doStatementNormalizations(t, n, parent);\n-\n-    return true;\n   }\n \n   public static class PropogateConstantAnnotations\n     }\n   }\n \n-  @Override\n-  public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch (n.getType()) {\n-      case Token.WHILE:\n-        if (CONVERT_WHILE_TO_FOR) {\n-          Node expr = n.getFirstChild();\n-          n.setType(Token.FOR);\n-          n.addChildBefore(new Node(Token.EMPTY), expr);\n-          n.addChildAfter(new Node(Token.EMPTY), expr);\n-          reportCodeChange(\"WHILE node\");\n-        }\n-        break;\n-    }\n-  }\n-\n   /**\n-   * Do normalizations that introduce new siblings or parents.\n+   * Simplify the AST:\n+   *   - VAR declarations split, so they represent exactly one child\n+   *     declaration.\n+   *   - WHILEs are converted to FORs\n+   *   - FOR loop are initializers are moved out of the FOR structure\n+   *   - LABEL node of children other than LABEL, BLOCK, WHILE, FOR, or DO are\n+   *     moved into a block.\n    */\n-  private void doStatementNormalizations(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.LABEL) {\n-      normalizeLabels(n);\n-    }\n-\n-    // Only inspect the children of SCRIPTs, BLOCKs and LABELs, as all these\n-    // are the only legal place for VARs and FOR statements.\n-    if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {\n-      extractForInitializer(n, null, null);\n-    }\n-\n-    // Only inspect the children of SCRIPTs, BLOCKs, as all these\n-    // are the only legal place for VARs.\n-    if (NodeUtil.isStatementBlock(n)) {\n-      splitVarDeclarations(n);\n-    }\n-\n-    if (n.getType() == Token.FUNCTION) {\n-      moveNamedFunctions(n.getLastChild());\n-    }\n-  }\n-\n-  // TODO(johnlenz): Move this to NodeTypeNormalizer once the unit tests are\n-  // fixed.\n-  /**\n-   * Limit the number of special cases where LABELs need to be handled. Only\n-   * BLOCK and loops are allowed to be labeled.  Loop labels must remain in\n-   * place as the named continues are not allowed for labeled blocks.\n-   */\n-  private void normalizeLabels(Node n) {\n-    Preconditions.checkArgument(n.getType() == Token.LABEL);\n-\n-    Node last = n.getLastChild();\n-    switch (last.getType()) {\n-      case Token.LABEL:\n-      case Token.BLOCK:\n-      case Token.FOR:\n-      case Token.WHILE:\n-      case Token.DO:\n-        return;\n-      default:\n-        Node block = new Node(Token.BLOCK);\n-        n.replaceChild(last, block);\n-        block.addChildToFront(last);\n-        reportCodeChange(\"LABEL normalization\");\n-        return;\n-    }\n-  }\n-\n-  /**\n-   * Bring the initializers out of FOR loops.  These need to be placed\n-   * before any associated LABEL nodes. This needs to be done from the top\n-   * level label first so this is called as a pre-order callback (from\n-   * shouldTraverse).\n-   *\n-   * @param n The node to inspect.\n-   * @param before The node to insert the initializer before.\n-   * @param beforeParent The parent of the node before which the initializer\n-   *     will be inserted.\n-   */\n-  private void extractForInitializer(\n-      Node n, Node before, Node beforeParent) {\n-\n-    for (Node next, c = n.getFirstChild(); c != null; c = next) {\n-      next = c.getNext();\n-      Node insertBefore = (before == null) ? c : before;\n-      Node insertBeforeParent = (before == null) ? n : beforeParent;\n-      switch (c.getType()) {\n+  static class NormalizeStatements implements Callback {\n+    private final AbstractCompiler compiler;\n+    private final boolean assertOnChange;\n+\n+    NormalizeStatements(AbstractCompiler compiler, boolean assertOnChange) {\n+      this.compiler = compiler;\n+      this.assertOnChange = assertOnChange;\n+    }\n+\n+    private void reportCodeChange(String changeDescription) {\n+      if (assertOnChange) {\n+        throw new IllegalStateException(\n+            \"Normalize constraints violated:\\n\" + changeDescription);\n+      }\n+      compiler.reportCodeChange();\n+    }\n+\n+    @Override\n+    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n+      doStatementNormalizations(t, n, parent);\n+\n+      return true;\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      switch (n.getType()) {\n+        case Token.WHILE:\n+          if (CONVERT_WHILE_TO_FOR) {\n+            Node expr = n.getFirstChild();\n+            n.setType(Token.FOR);\n+            n.addChildBefore(new Node(Token.EMPTY), expr);\n+            n.addChildAfter(new Node(Token.EMPTY), expr);\n+            reportCodeChange(\"WHILE node\");\n+          }\n+          break;\n+      }\n+    }\n+\n+    /**\n+     * Do normalizations that introduce new siblings or parents.\n+     */\n+    private void doStatementNormalizations(\n+        NodeTraversal t, Node n, Node parent) {\n+      if (n.getType() == Token.LABEL) {\n+        normalizeLabels(n);\n+      }\n+\n+      // Only inspect the children of SCRIPTs, BLOCKs and LABELs, as all these\n+      // are the only legal place for VARs and FOR statements.\n+      if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {\n+        extractForInitializer(n, null, null);\n+      }\n+\n+      // Only inspect the children of SCRIPTs, BLOCKs, as all these\n+      // are the only legal place for VARs.\n+      if (NodeUtil.isStatementBlock(n)) {\n+        splitVarDeclarations(n);\n+      }\n+\n+      if (n.getType() == Token.FUNCTION) {\n+        moveNamedFunctions(n.getLastChild());\n+      }\n+    }\n+\n+    // TODO(johnlenz): Move this to NodeTypeNormalizer once the unit tests are\n+    // fixed.\n+    /**\n+     * Limit the number of special cases where LABELs need to be handled. Only\n+     * BLOCK and loops are allowed to be labeled.  Loop labels must remain in\n+     * place as the named continues are not allowed for labeled blocks.\n+     */\n+    private void normalizeLabels(Node n) {\n+      Preconditions.checkArgument(n.getType() == Token.LABEL);\n+\n+      Node last = n.getLastChild();\n+      switch (last.getType()) {\n         case Token.LABEL:\n-          extractForInitializer(c, insertBefore, insertBeforeParent);\n-          break;\n+        case Token.BLOCK:\n         case Token.FOR:\n-          if (!NodeUtil.isForIn(c)\n-              && c.getFirstChild().getType() != Token.EMPTY) {\n-            Node init = c.getFirstChild();\n-            c.replaceChild(init, new Node(Token.EMPTY));\n-\n-            Node newStatement;\n-            // Only VAR statements, and expressions are allowed,\n-            // but are handled differently.\n-            if (init.getType() == Token.VAR) {\n-              newStatement = init;\n-            } else {\n-              newStatement = NodeUtil.newExpr(init);\n+        case Token.WHILE:\n+        case Token.DO:\n+          return;\n+        default:\n+          Node block = new Node(Token.BLOCK);\n+          n.replaceChild(last, block);\n+          block.addChildToFront(last);\n+          reportCodeChange(\"LABEL normalization\");\n+          return;\n+      }\n+    }\n+\n+    /**\n+     * Bring the initializers out of FOR loops.  These need to be placed\n+     * before any associated LABEL nodes. This needs to be done from the top\n+     * level label first so this is called as a pre-order callback (from\n+     * shouldTraverse).\n+     *\n+     * @param n The node to inspect.\n+     * @param before The node to insert the initializer before.\n+     * @param beforeParent The parent of the node before which the initializer\n+     *     will be inserted.\n+     */\n+    private void extractForInitializer(\n+        Node n, Node before, Node beforeParent) {\n+\n+      for (Node next, c = n.getFirstChild(); c != null; c = next) {\n+        next = c.getNext();\n+        Node insertBefore = (before == null) ? c : before;\n+        Node insertBeforeParent = (before == null) ? n : beforeParent;\n+        switch (c.getType()) {\n+          case Token.LABEL:\n+            extractForInitializer(c, insertBefore, insertBeforeParent);\n+            break;\n+          case Token.FOR:\n+            if (!NodeUtil.isForIn(c)\n+                && c.getFirstChild().getType() != Token.EMPTY) {\n+              Node init = c.getFirstChild();\n+              c.replaceChild(init, new Node(Token.EMPTY));\n+\n+              Node newStatement;\n+              // Only VAR statements, and expressions are allowed,\n+              // but are handled differently.\n+              if (init.getType() == Token.VAR) {\n+                newStatement = init;\n+              } else {\n+                newStatement = NodeUtil.newExpr(init);\n+              }\n+\n+              insertBeforeParent.addChildBefore(newStatement, insertBefore);\n+              reportCodeChange(\"FOR initializer\");\n             }\n-\n-            insertBeforeParent.addChildBefore(newStatement, insertBefore);\n-            reportCodeChange(\"FOR initializer\");\n-          }\n-          break;\n-      }\n-    }\n-  }\n-\n-\n-  /**\n-   * Split a var node such as:\n-   *   var a, b;\n-   * into individual statements:\n-   *   var a;\n-   *   var b;\n-   * @param n The whose children we should inspect.\n-   */\n-  private void splitVarDeclarations(Node n) {\n-    for (Node next, c = n.getFirstChild(); c != null; c = next) {\n-      next = c.getNext();\n-      if (c.getType() == Token.VAR) {\n-        if (assertOnChange && !c.hasChildren()) {\n-          throw new IllegalStateException(\"Empty VAR node.\");\n-        }\n-\n-        while (c.getFirstChild() != c.getLastChild()) {\n-          Node name = c.getFirstChild();\n-          c.removeChild(name);\n-          Node newVar = new Node(Token.VAR, name, n.getLineno(), n.getCharno());\n-          n.addChildBefore(newVar, c);\n-          reportCodeChange(\"VAR with multiple children\");\n-        }\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Move all the functions that are valid at the execution of the first\n-   * statement of the function to the beginning of the function definition.\n-   */\n-  private void moveNamedFunctions(Node functionBody) {\n-    Preconditions.checkState(\n-        functionBody.getParent().getType() == Token.FUNCTION);\n-    Node previous = null;\n-    Node current = functionBody.getFirstChild();\n-    // Skip any declarations at the beginning of the function body, they\n-    // are already in the right place.\n-    while (current != null && NodeUtil.isFunctionDeclaration(current)) {\n-      previous = current;\n-      current = current.getNext();\n-    }\n-\n-    // Find any remaining declarations and move them.\n-    Node insertAfter = previous;\n-    while (current != null) {\n-      // Save off the next node as the current node maybe removed.\n-      Node next = current.getNext();\n-      if (NodeUtil.isFunctionDeclaration(current)) {\n-        // Remove the declaration from the body.\n-        Preconditions.checkNotNull(previous);\n-        functionBody.removeChildAfter(previous);\n-\n-        // Readd the function at the top of the function body (after any\n-        // previous declarations).\n-        insertAfter = addToFront(functionBody, current, insertAfter);\n-        compiler.reportCodeChange();\n+            break;\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Split a var node such as:\n+     *   var a, b;\n+     * into individual statements:\n+     *   var a;\n+     *   var b;\n+     * @param n The whose children we should inspect.\n+     */\n+    private void splitVarDeclarations(Node n) {\n+      for (Node next, c = n.getFirstChild(); c != null; c = next) {\n+        next = c.getNext();\n+        if (c.getType() == Token.VAR) {\n+          if (assertOnChange && !c.hasChildren()) {\n+            throw new IllegalStateException(\"Empty VAR node.\");\n+          }\n+\n+          while (c.getFirstChild() != c.getLastChild()) {\n+            Node name = c.getFirstChild();\n+            c.removeChild(name);\n+            Node newVar = new Node(\n+                Token.VAR, name, n.getLineno(), n.getCharno());\n+            n.addChildBefore(newVar, c);\n+            reportCodeChange(\"VAR with multiple children\");\n+          }\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Move all the functions that are valid at the execution of the first\n+     * statement of the function to the beginning of the function definition.\n+     */\n+    private void moveNamedFunctions(Node functionBody) {\n+      Preconditions.checkState(\n+          functionBody.getParent().getType() == Token.FUNCTION);\n+      Node previous = null;\n+      Node current = functionBody.getFirstChild();\n+      // Skip any declarations at the beginning of the function body, they\n+      // are already in the right place.\n+      while (current != null && NodeUtil.isFunctionDeclaration(current)) {\n+        previous = current;\n+        current = current.getNext();\n+      }\n+\n+      // Find any remaining declarations and move them.\n+      Node insertAfter = previous;\n+      while (current != null) {\n+        // Save off the next node as the current node maybe removed.\n+        Node next = current.getNext();\n+        if (NodeUtil.isFunctionDeclaration(current)) {\n+          // Remove the declaration from the body.\n+          Preconditions.checkNotNull(previous);\n+          functionBody.removeChildAfter(previous);\n+\n+          // Readd the function at the top of the function body (after any\n+          // previous declarations).\n+          insertAfter = addToFront(functionBody, current, insertAfter);\n+          reportCodeChange(\"Move function declaration not at top of function\");\n+        } else {\n+          // Update the previous only if the current node hasn't been moved.\n+          previous = current;\n+        }\n+        current = next;\n+      }\n+    }\n+\n+    /**\n+     * @param after The child node to insert the newChild after, or null if\n+     *     newChild should be added to the front of parent's child list.\n+     * @return The inserted child node.\n+     */\n+    private Node addToFront(Node parent, Node newChild, Node after) {\n+      if (after == null) {\n+        parent.addChildToFront(newChild);\n       } else {\n-        // Update the previous only if the current node hasn't been moved.\n-        previous = current;\n-      }\n-      current = next;\n-    }\n-  }\n-\n-  /**\n-   * @param after The child node to insert the newChild after, or null if\n-   *     newChild should be added to the front of parent's child list.\n-   * @return The inserted child node.\n-   */\n-  private Node addToFront(Node parent, Node newChild, Node after) {\n-    if (after == null) {\n-      parent.addChildToFront(newChild);\n-    } else {\n-      parent.addChildAfter(newChild, after);\n-    }\n-    return newChild;\n+        parent.addChildAfter(newChild, after);\n+      }\n+      return newChild;\n+    }\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/DenormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/DenormalizeTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.javascript.jscomp.Normalize.NormalizeStatements;\n import com.google.javascript.rhino.Node;\n \n /**\n     // Any other expression.\n     test(\"init(); for(; a < 2 ; a++) foo()\",\n          \"for(init(); a < 2 ; a++) foo();\");\n-    \n+\n     // Other statements are left as is.\n     test(\"function(){ var a; for(; a < 2 ; a++) foo() }\",\n          \"function(){ for(var a; a < 2 ; a++) foo() }\");\n     // Make sure Normalize yanks the variable initializer out, and\n     // Denormalize doesn't put it back.\n     test(\"function(){var b,a=0; for (var i=(\\\"length\\\" in b);a<2; a++) foo()}\",\n-        \"function(){var b; var a=0;var i=(\\\"length\\\" in b);for (;a<2;a++) foo()}\");\n-\n+         \"function(){var b; var a=0;var i=(\\\"length\\\" in b);\" +\n+         \"for (;a<2;a++) foo()}\");\n   }\n \n   /**\n    */\n   public class NormalizeAndDenormalizePass implements CompilerPass {\n     Denormalize denormalizePass;\n-    Normalize normalizePass;\n+    NormalizeStatements normalizePass;\n     AbstractCompiler compiler;\n \n     public NormalizeAndDenormalizePass(AbstractCompiler compiler) {\n       this.compiler = compiler;\n       denormalizePass = new Denormalize(compiler);\n-      normalizePass = new Normalize(compiler, false);\n+      normalizePass = new NormalizeStatements(compiler, false);\n     }\n \n     public void process(Node externs, Node root) {\n--- a/test/com/google/javascript/jscomp/FoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/FoldConstantsTest.java\n     // Only optimize if it's a size win.\n     fold(\"x = ['a', '5', 'c'].join('a very very very long chain')\",\n          \"x = [\\\"a\\\",\\\"5\\\",\\\"c\\\"].join(\\\"a very very very long chain\\\")\");\n-    \n+\n     // TODO(user): Its possible to fold this better.\n     foldSame(\"x = ['', foo].join(',')\");\n     foldSame(\"x = ['', foo, ''].join(',')\");\n-    \n+\n     fold(\"x = ['', '', foo, ''].join(',')\", \"x = [',', foo, ''].join(',')\");\n     fold(\"x = ['', '', foo, '', ''].join(',')\",\n          \"x = [',', foo, ','].join(',')\");\n-    \n+\n     fold(\"x = ['', '', foo, '', '', bar].join(',')\",\n          \"x = [',', foo, ',', bar].join(',')\");\n-    \n+\n     fold(\"x = [1,2,3].join('abcdef')\",\n          \"x = '1abcdef2abcdef3'\");\n   }\n-  \n+\n   public void testStringJoinAdd_b1992789() {\n     fold(\"x = ['a'].join('')\", \"x = \\\"a\\\"\");\n     fold(\"x = [foo()].join('')\", \"x = '' + foo()\");\n     fold(\"-1 >= 9\", \"0\");\n \n     fold(\"true == true\", \"1\");\n-    fold(\"true == true\", \"1\");\n     fold(\"false == null\", \"0\");\n     fold(\"false == true\", \"0\");\n     fold(\"true == null\", \"0\");\n+  }\n+\n+  // ===, !== comparison tests\n+  public void testFoldComparison2() {\n+    fold(\"x = 0 === 0\", \"x = true\");\n+    fold(\"x = 1 === 2\", \"x = false\");\n+    fold(\"x = 'abc' === 'def'\", \"x = false\");\n+    fold(\"x = 'abc' === 'abc'\", \"x = true\");\n+    fold(\"x = \\\"\\\" === ''\", \"x = true\");\n+    fold(\"x = foo() === bar()\", \"x = foo()===bar()\");\n+\n+    fold(\"x = 1 !== 0\", \"x = true\");\n+    fold(\"x = 'abc' !== 'def'\", \"x = true\");\n+    fold(\"x = 'a' !== 'a'\", \"x = false\");\n+\n+    fold(\"x = y === y\", \"x = y===y\");\n+\n+    fold(\"x = true === true\", \"x = true\");\n+    fold(\"x = true === true\", \"x = true\");\n+    fold(\"x = false === null\", \"x = false\");\n+    fold(\"x = false === true\", \"x = false\");\n+    fold(\"x = true === null\", \"x = false\");\n+\n+    fold(\"0 === 0\", \"1\");\n+    fold(\"1 === 2\", \"0\");\n+    fold(\"'abc' === 'def'\", \"0\");\n+    fold(\"'abc' === 'abc'\", \"1\");\n+    fold(\"\\\"\\\" === ''\", \"1\");\n+    fold(\"foo() === bar()\", \"foo()===bar()\");\n+\n+    // TODO(johnlenz): It would be nice to handle these cases as well. \n+    foldSame(\"1 === '1'\");\n+    foldSame(\"1 === true\");\n+    foldSame(\"1 !== '1'\");\n+    foldSame(\"1 !== true\");\n+    \n+    fold(\"1 !== 0\", \"1\");\n+    fold(\"'abc' !== 'def'\", \"1\");\n+    fold(\"'a' !== 'a'\", \"0\");\n+\n+    fold(\"x === x\", \"x===x\");\n+\n+    fold(\"true === true\", \"1\");\n+    fold(\"false === null\", \"0\");\n+    fold(\"false === true\", \"0\");\n+    fold(\"true === null\", \"0\");\n   }\n \n   public void testFoldNot() {", "timestamp": 1268286566, "metainfo": ""}