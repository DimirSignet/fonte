{"sha": "30994e27ebfa34e4820df650cd15f9f34d10238f", "log": "Make StripType work with ctors.  R=johnlenz DELTA=137  (73 added, 52 deleted, 12 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=206870   ", "commit": "\n--- a/src/com/google/javascript/jscomp/StripCode.java\n+++ b/src/com/google/javascript/jscomp/StripCode.java\n           break;\n \n         case Token.CALL:\n+        case Token.NEW:\n           maybeRemoveCall(t, n, parent);\n           break;\n \n           //   NAME\n           //   NUMBER|STRING|NAME|...\n           if (parent.getFirstChild() == n && isReferenceToRemovedVar(t, n)) {\n-            // Use a while loop to get up out of any nested property/element\n-            // accesses and/or calls. For example, if we have just detected\n-            // that we need to remove the a.b access in a.b[c].d(), we'll have\n-            // to remove all of the accesses, and it will take a few iterations\n-            // through this loop to get up to the call above d.\n-            Node ancestor = parent.getParent();\n-            Node ancestorChild = parent;\n-            while (true) {\n-              if (NodeUtil.isExpressionNode(ancestor)) {\n-                // Remove the entire expression statement.\n-                Node ancParent = ancestor.getParent();\n-                replaceWithEmpty(ancestor, ancParent);\n-                break;\n-              }\n-              int type = ancestor.getType();\n-              if (type != Token.GETPROP &&\n-                  type != Token.GETELEM &&\n-                  type != Token.CALL) {\n-                replaceWithNull(ancestorChild, ancestor);\n-                break;\n-              }\n-              ancestorChild = ancestor;\n-              ancestor = ancestor.getParent();\n-            }\n-            compiler.reportCodeChange();\n+            replaceHighestNestedCallWithNull(parent, parent.getParent());\n           }\n           break;\n \n     }\n \n     /**\n+     * Use a while loop to get up out of any nested calls. For example,\n+     * if we have just detected that we need to remove the a.b() call\n+     * in a.b().c().d(), we'll have to remove all of the calls, and it\n+     * will take a few iterations through this loop to get up to d().\n+     */\n+    void replaceHighestNestedCallWithNull(Node node, Node parent) {\n+      Node ancestor = parent;\n+      Node ancestorChild = node;\n+      while (true) {\n+        if (ancestor.getFirstChild() != ancestorChild) {\n+          replaceWithNull(ancestorChild, ancestor);\n+          break;\n+        }\n+        if (NodeUtil.isExpressionNode(ancestor)) {\n+          // Remove the entire expression statement.\n+          Node ancParent = ancestor.getParent();\n+          replaceWithEmpty(ancestor, ancParent);\n+          break;\n+        }\n+        int type = ancestor.getType();\n+        if (type != Token.GETPROP &&\n+            type != Token.GETELEM &&\n+            type != Token.CALL) {\n+          replaceWithNull(ancestorChild, ancestor);\n+          break;\n+        }\n+        ancestorChild = ancestor;\n+        ancestor = ancestor.getParent();\n+      }\n+      compiler.reportCodeChange();\n+    }\n+\n+    /**\n      * Eliminates an assignment if the lvalue is:\n      *  - A field name that's a strip name\n      *  - A qualified name that begins with a strip type\n     }\n \n     /**\n-     * Removes a method call if {@link #isMethodCallThatTriggersRemoval}\n+     * Removes a method call if {@link #isMethodOrCtorCallThatTriggersRemoval}\n      * indicates that it should be removed.\n      *\n      * @param t The traversal\n      * @param parent {@code n}'s parent\n      */\n     void maybeRemoveCall(NodeTraversal t, Node n, Node parent) {\n-      // CALL\n+      // CALL/NEW\n       //   function\n       //   arguments\n-      if (isMethodCallThatTriggersRemoval(t, n, parent)) {\n-        // Use a while loop to get up out of any nested calls. For example,\n-        // if we have just detected that we need to remove the a.b() call\n-        // in a.b().c().d(), we'll have to remove all of the calls, and it\n-        // will take a few iterations through this loop to get up to d().\n-        Node ancestor = parent;\n-        Node ancestorChild = n;\n-        int ancestorLevel = 1;\n-        while (true) {\n-          if (ancestor.getFirstChild() != ancestorChild) {\n-            replaceWithNull(ancestorChild, ancestor);\n-            break;\n-          }\n-          if (NodeUtil.isExpressionNode(ancestor)) {\n-            // Remove the entire expression statement.\n-            Node ancParent = ancestor.getParent();\n-            replaceWithEmpty(ancestor, ancParent);\n-            break;\n-          }\n-          int type = ancestor.getType();\n-          if (type != Token.GETPROP &&\n-              type != Token.GETELEM &&\n-              type != Token.CALL) {\n-            replaceWithNull(ancestorChild, ancestor);\n-            break;\n-          }\n-          ancestorChild = ancestor;\n-          ancestor = ancestor.getParent();\n-        }\n-        compiler.reportCodeChange();\n+      if (isMethodOrCtorCallThatTriggersRemoval(t, n, parent)) {\n+        replaceHighestNestedCallWithNull(n, parent);\n       }\n     }\n \n      * @return Whether the call's return value should be stripped\n      */\n     boolean isCallWhoseReturnValueShouldBeStripped(@Nullable Node n) {\n-      return n != null && n.getType() == Token.CALL && n.hasChildren()\n-          && (qualifiedNameBeginsWithStripType(n.getFirstChild()) ||\n+      return n != null &&\n+          (n.getType() == Token.CALL ||\n+           n.getType() == Token.NEW) &&\n+          n.hasChildren() &&\n+          (qualifiedNameBeginsWithStripType(n.getFirstChild()) ||\n               nameEndsWithFieldNameToStrip(n.getFirstChild()));\n     }\n \n      * @param n A CALL node\n      * @return Whether the node triggers statement removal\n      */\n-    boolean isMethodCallThatTriggersRemoval(NodeTraversal t, Node n,\n-                                            Node parent) {\n-      // CALL\n+    boolean isMethodOrCtorCallThatTriggersRemoval(\n+        NodeTraversal t, Node n, Node parent) {\n+      // CALL/NEW\n       //   GETPROP (function)         <-- we're interested in this, the function\n       //     GETPROP (callee object)  <-- or the object on which it is called\n       //       ...\n       Node callee = function.getFirstChild();\n       return nameEndsWithFieldNameToStrip(callee) ||\n           nameEndsWithFieldNameToStrip(function) ||\n-          qualifiedNameBeginsWithStripType(callee) ||\n+          qualifiedNameBeginsWithStripType(function) ||\n           actsOnStripType(t, n);\n     }\n \n--- a/test/com/google/javascript/jscomp/StripCodeTest.java\n+++ b/test/com/google/javascript/jscomp/StripCodeTest.java\n   private static final String EXTERNS = \"\";\n \n   public StripCodeTest() {\n-    super(EXTERNS, false);\n+    super(EXTERNS, true);\n   }\n \n   /**\n          \"(GA_GoogleDebugger.foo = 7) + 8\",\n          StripCode.STRIP_ASSIGNMENT_ERROR);\n   }\n+\n+  public void testNewOperatior1() {\n+    test(\"function foo() {} foo.bar = new goog.debug.Logger();\",\n+         \"function foo() {} foo.bar = null;\");\n+  }\n+\n+  public void testNewOperatior2() {\n+    test(\"function foo() {} foo.bar = (new goog.debug.Logger()).foo();\",\n+         \"function foo() {} foo.bar = null;\");\n+  }\n+\n+  public void testCrazyNesting1() {\n+    test(\"var x = {}; x[new goog.debug.Logger()] = 3;\",\n+         \"var x = {}; x[null] = 3;\");\n+  }\n+\n+  public void testCrazyNesting2() {\n+    test(\"var x = {}; x[goog.debug.Logger.getLogger()] = 3;\",\n+         \"var x = {}; x[null] = 3;\");\n+  }\n+\n+  public void testCrazyNesting3() {\n+    test(\"var x = function() {}; x(new goog.debug.Logger());\",\n+         \"var x = function() {}; x(null);\");\n+  }\n+\n+  public void testCrazyNesting4() {\n+    test(\"var x = function() {}; x(goog.debug.Logger.getLogger());\",\n+         \"var x = function() {}; x(null);\");\n+  }\n+\n+  public void testCrazyNesting5() {\n+    test(\"var x = function() {}; var y = {}; \" +\n+         \"var z = goog.debug.Logger.getLogger(); x(y[z['foo']]);\",\n+         \"var x = function() {}; var y = {}; x(y[null]);\");\n+  }\n }", "timestamp": 1283916272, "metainfo": ""}