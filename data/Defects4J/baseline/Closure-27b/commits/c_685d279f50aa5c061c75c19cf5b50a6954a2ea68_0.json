{"sha": "685d279f50aa5c061c75c19cf5b50a6954a2ea68", "log": "CompilerPass for JSCompiler that changes all references to global symbols to be property lookups on a single \"global\" symbol.  This guarantees that code leaks no symbols into global scope unless this is somehow explicitly implemented (in the browser by assigning to window).  R=acleung,johnlenz DELTA=417  (416 added, 0 deleted, 1 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3591   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n \n   /** Specifies a prefix for all globals */\n   public String renamePrefix;\n+\n+  /**\n+   * Specifies the name of an object that will be used to store all non-extern\n+   * globals.\n+   */\n+  public String renamePrefixNamespace;\n \n   /** Aliases true, false, and null to variables with shorter names. */\n   public boolean aliasKeywords;\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       DiagnosticType.error(\"JSC_NAME_REF_REPORT_FILE_ERROR\",\n           \"Error \\\"{1}\\\" writing name reference report to \\\"{0}\\\".\");\n \n+  private static final java.util.regex.Pattern GLOBAL_SYMBOL_NAMESPACE_PATTERN =\n+    java.util.regex.Pattern.compile(\"^[a-zA-Z0-9$_]+$\");\n+\n   /**\n    * A global namespace to share across checking passes.\n    */\n     }\n \n     // Move functions before extracting prototype member declarations.\n-    if (options.moveFunctionDeclarations) {\n+    if (options.moveFunctionDeclarations ||\n+        // renamePrefixNamescape relies on moveFunctionDeclarations\n+        // to preserve semantics.\n+        options.renamePrefixNamespace != null) {\n       passes.add(moveFunctionDeclarations);\n     }\n \n       passes.add(nameUnmappedAnonymousFunctions);\n     }\n \n+    if (options.renamePrefixNamespace != null) {\n+      if (!GLOBAL_SYMBOL_NAMESPACE_PATTERN.matcher(\n+          options.renamePrefixNamespace).matches()) {\n+        throw new IllegalArgumentException(\n+            \"Illegal character in renamePrefixNamespace name: \"\n+            + options.renamePrefixNamespace);\n+      }\n+      passes.add(rescopeGlobalSymbols);\n+    }\n+\n     if (options.operaCompoundAssignFix) {\n       passes.add(operaCompoundAssignFix);\n     }\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n       return new ClosureOptimizePrimitives(compiler);\n+    }\n+  };\n+\n+  /** Puts global symbols into a single object. */\n+  final PassFactory rescopeGlobalSymbols =\n+      new PassFactory(\"rescopeGlobalSymbols\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new RescopeGlobalSymbols(compiler, options.renamePrefixNamespace);\n     }\n   };\n \n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/RescopeGlobalSymbols.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractShallowStatementCallback;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Finds all references to global symbols and rewrites them to be property\n+ * accesses to a special object with the same name as the global symbol.\n+ *\n+ * Given the name of the global object is NS\n+ * <pre> var a = 1; function b() { return a }</pre>\n+ * becomes\n+ * <pre> NS.a = 1; NS.b = function b() { return NS.a }</pre>\n+ *\n+ * This allows splitting code into modules that depend on each other's\n+ * global symbols, without using polluting JavaScript's global scope with those\n+ * symbols.\n+ *\n+ * <p>This compile step requires moveFunctionDeclarations to be turned on\n+ * to guarantee semantics.\n+ *\n+ * <p>For lots of examples, see the unit test.\n+ *\n+ *\n+ */\n+class RescopeGlobalSymbols implements CompilerPass {\n+\n+  private final AbstractCompiler compiler;\n+  private final String globalSymbolNamespace;\n+  private final boolean addExtern;\n+\n+  RescopeGlobalSymbols(AbstractCompiler compiler, String globalSymbolNamespace,\n+      boolean addExtern) {\n+    this.compiler = compiler;\n+    this.globalSymbolNamespace = globalSymbolNamespace;\n+    this.addExtern = addExtern;\n+  }\n+\n+  RescopeGlobalSymbols(AbstractCompiler compiler,\n+      String globalSymbolNamespace) {\n+    this(compiler, globalSymbolNamespace, true);\n+  }\n+\n+  private void addExternForGlobalSymbolNamespace() {\n+    Node nameNode = Node.newString(Token.NAME, globalSymbolNamespace);\n+    Node varNode = new Node(Token.VAR);\n+    varNode.addChildToBack(nameNode);\n+    CompilerInput input = compiler.newExternInput(\n+        \"{RescopeGlobalSymbolsNamespaceVar}\");\n+    input.getAstRoot(compiler).addChildrenToBack(varNode);\n+    compiler.reportCodeChange();\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    // Make the name of the globalSymbolNamespace an extern.\n+    if (addExtern) {\n+      addExternForGlobalSymbolNamespace();\n+    }\n+    // Rewrite all references to global symbols to properties of a\n+    // single symbol by:\n+    // (If necessary the 3 traversals could be combined. They are left\n+    // separate for readability reasons.)\n+    // 1. turning global named function statements into var assigments.\n+    NodeTraversal.traverse(compiler, root,\n+        new RewriteGlobalFunctionStatementsToVarAssignmentsCallback());\n+    // 2. rewriting all references to be property accesses of the single symbol.\n+    NodeTraversal.traverse(compiler, root, new RewriteScopeCallback());\n+    // 3. removing the var from every statement in global scope.\n+    NodeTraversal.traverse(compiler, root, new RemoveGlobalVarCallback());\n+  }\n+\n+  /**\n+   * Rewrites function statements to var statements + assignment.\n+   *\n+   * <pre>function test(){}</pre>\n+   * becomes\n+   * <pre>var test = function (){}</pre>\n+   *\n+   * After this traversal, the special case of global function statements\n+   * can be ignored.\n+   */\n+  private class RewriteGlobalFunctionStatementsToVarAssignmentsCallback\n+      extends AbstractShallowStatementCallback {\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (NodeUtil.isFunctionDeclaration(n)) {\n+        String name = NodeUtil.getFunctionName(n);\n+        n.getFirstChild().setString(\"\");\n+        Node prev = parent.getChildBefore(n);\n+        n.detachFromParent();\n+        Node var = NodeUtil.newVarNode(name, n);\n+        if (prev == null) {\n+          parent.addChildToFront(var);\n+        } else {\n+          parent.addChildAfter(var, prev);\n+        }\n+        compiler.reportCodeChange();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Visits each NAME token and checks whether it refers to a global variable.\n+   * If yes, rewrites the name to be a property access on the\n+   * \"globalSymbolNamespace\".\n+   *\n+   * <pre>var a = 1, b = 2, c = 3;</pre>\n+   * becomes\n+   * <pre>var NS.a = 1, NS.b = 2, NS.c = 4</pre>\n+   * (The var token is removed in a later traversal.)\n+   *\n+   * <pre>a + b</pre>\n+   * becomes\n+   * <pre>NS.a + NS.b</pre>\n+   *\n+   * <pre>a()</pre>\n+   * becomes\n+   * <pre>(0,NS.a)()</pre>\n+   * Notice the special syntax here to preserve the *this* semantics in the\n+   * function call.\n+   */\n+  private class RewriteScopeCallback extends AbstractPostOrderCallback {\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.getType() != Token.NAME) {\n+        return;\n+      }\n+      String name = n.getString();\n+      // Ignore anonymous functions\n+      if (parent.getType() == Token.FUNCTION && name.length() == 0) {\n+        return;\n+      }\n+      Scope.Var var = t.getScope().getVar(name);\n+      // We only care about global vars that are not extern.\n+      if (var == null || !var.isGlobal() || var.isExtern()) {\n+        return;\n+      }\n+      Node nameNode = var.getNameNode();\n+      // The exception variable (e in try{}catch(e){}) should not be rewritten.\n+      if (nameNode != null && nameNode.getParent() != null &&\n+          nameNode.getParent().getType() == Token.CATCH) {\n+        return;\n+      }\n+      replaceSymbol(n, name);\n+    }\n+\n+    private void replaceSymbol(Node node, String name) {\n+      Node parent = node.getParent();\n+      Node replacement = new Node(Token.GETPROP,\n+          Node.newString(Token.NAME, globalSymbolNamespace)\n+              .copyInformationFrom(node),\n+          Node.newString(name).copyInformationFrom(node));\n+      replacement.copyInformationFrom(node);\n+      if (node.hasChildren()) {\n+        // var declaration list: var a = 1, b = 2;\n+        Node assign = new Node(Token.ASSIGN, replacement,\n+            node.removeFirstChild());\n+        parent.replaceChild(node, assign);\n+      } else {\n+        parent.replaceChild(node, replacement);\n+      }\n+      compiler.reportCodeChange();\n+    }\n+  }\n+\n+  /**\n+   * Removes every occurence of var that declares a global variable.\n+   *\n+   * <pre>var NS.a = 1, NS.b = 2;</pre>\n+   * becomes\n+   * <pre>NS.a = 1; NS.b = 2;</pre>\n+   *\n+   * <pre>for (var a = 0, b = 0;;)</pre>\n+   * becomes\n+   * <pre>for (NS.a = 0, NS.b = 0;;)</pre>\n+   *\n+   * Declarations without assignments are optimized away:\n+   * <pre>var a = 1, b;</pre>\n+   * becomes\n+   * <pre>NS.a = 1</pre>\n+   */\n+  private class RemoveGlobalVarCallback extends\n+      AbstractShallowStatementCallback {\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.getType() != Token.VAR) {\n+        return;\n+      }\n+      List<Node> commas = new ArrayList<Node>();\n+      List<Node> interestingChildren = new ArrayList<Node>();\n+      // Filter out declarations without assignments.\n+      // As opposed to regular var nodes, there are always assignments\n+      // because the previous traversal in RewriteScopeCallback creates\n+      // them.\n+      for (Node c : n.children()) {\n+        if (c.getType() == Token.ASSIGN ||\n+            parent.getType() == Token.FOR) {\n+          interestingChildren.add(c);\n+        }\n+      }\n+      for (Node c : interestingChildren) {\n+        if (parent.getType() == Token.FOR && parent.getFirstChild() == n) {\n+          commas.add(c.cloneTree());\n+        } else {\n+          // Var statement outside of for-loop.\n+          Node expr = new Node(Token.EXPR_RESULT);\n+          expr.copyInformationFrom(c);\n+          expr.addChildToBack(c.cloneTree());\n+          parent.addChildBefore(expr, n);\n+        }\n+      }\n+      if (commas.size() > 0) {\n+        Node comma = joinOnComma(commas, n);\n+        parent.addChildBefore(comma, n);\n+      }\n+      // Remove the var node.\n+      parent.removeChild(n);\n+      compiler.reportCodeChange();\n+    }\n+\n+    private Node joinOnComma(List<Node> commas, Node source) {\n+      Node comma = commas.get(0);\n+      for (int i = 1; i < commas.size(); i++) {\n+        Node nextComma = new Node(Token.COMMA, comma, commas.get(i));\n+        nextComma.copyInformationFrom(source);\n+        comma = nextComma;\n+      }\n+      return comma;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/RescopeGlobalSymbolsTest.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Unit tests for {@link RescopeGlobalSymbols}\n+ *\n+ */\n+public class RescopeGlobalSymbolsTest extends CompilerTestCase {\n+\n+  private final String namespace = \"_\";\n+\n+  public RescopeGlobalSymbolsTest() {\n+  }\n+\n+  @Override protected CompilerPass getProcessor(Compiler compiler) {\n+    return new RescopeGlobalSymbols(compiler, namespace, false);\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    return 1;\n+  }\n+\n+  public void testVarDeclarations() {\n+    test(\"var a = 1;\", \"_.a = 1;\");\n+    test(\"var a = 1, b = 2, c = 3;\", \"_.a = 1; _.b = 2; _.c = 3;\");\n+    test(\"var a = 'str', b = 1, c = { foo: 'bar' }, d = function() {};\",\n+        \"_.a = 'str'; _.b = 1; _.c = { foo: 'bar' }; _.d = function() {};\");\n+    test(\"if(1){var x = 1;}\", \"if(1){_.x = 1;}\");\n+    test(\"var x;\", \"\");\n+    test(\"var a, b = 1;\", \"_.b = 1\");\n+  }\n+\n+  public void testForLoops() {\n+    test(\"for (var i = 0; i < 1000; i++);\",\n+        \"for (_.i = 0; _.i < 1000; _.i++);\");\n+    test(\"for (var i = 0, c = 2; i < 1000; i++);\",\n+        \"for (_.i = 0, _.c = 2; _.i < 1000; _.i++);\");\n+    test(\"for (var i = 0, c = 2, d = 3; i < 1000; i++);\",\n+        \"for (_.i = 0, _.c = 2, _.d = 3; _.i < 1000; _.i++);\");\n+    test(\"for (var i = 0, c = 2, d = 3, e = 4; i < 1000; i++);\",\n+        \"for (_.i = 0, _.c = 2, _.d = 3, _.e = 4; _.i < 1000; _.i++);\");\n+    test(\"for (var i = 0; i < 1000;)i++;\",\n+        \"for (_.i = 0; _.i < 1000;)_.i++;\");\n+    test(\"for (var i = 0,b; i < 1000;)i++;b++\",\n+        \"for (_.i = 0,_.b; _.i < 1000;)_.i++;_.b++\");\n+    test(\"var o={};for (var i in o)i++;\",\n+        \"_.o={};for (_.i in _.o)_.i++;\");\n+  }\n+\n+  public void testFunctionStatements() {\n+    test(\"function test(){}\",\n+        \"_.test=function (){}\");\n+    test(\"if(1)function test(){}\",\n+        \"if(1)_.test=function (){}\");\n+    new StringCompare().testFreeCallSemantics();\n+  }\n+\n+  public void testDeeperScopes() {\n+    test(\"var a = function(b){return b}\",\n+        \"_.a = function(b){return b}\");\n+    test(\"var a = function(b){var a; return a+b}\",\n+        \"_.a = function(b){var a; return a+b}\");\n+    test(\"var a = function(a,b){return a+b}\",\n+        \"_.a = function(a,b){return a+b}\");\n+    test(\"var x=1,a = function(b){var a; return a+b+x}\",\n+        \"_.x=1;_.a = function(b){var a; return a+b+_.x}\");\n+    test(\"var x=1,a = function(b){return function(){var a;return a+b+x}}\",\n+        \"_.x=1;_.a = function(b){return function(){var a; return a+b+_.x}}\");\n+  }\n+\n+  public void testTryCatch() {\n+    test(\"try{var a = 1}catch(e){throw e}\",\n+        \"try{_.a = 1}catch(e){throw e}\");\n+  }\n+\n+  private class StringCompare extends CompilerTestCase {\n+\n+    StringCompare() {\n+      super(\"\", false);\n+    }\n+\n+    @Override protected CompilerPass getProcessor(Compiler compiler) {\n+      return new RescopeGlobalSymbols(compiler, namespace, false);\n+    }\n+\n+    public void testFreeCallSemantics() {\n+      test(\"function x(){};var y=function(){var val=x()||{}}\",\n+          \"_.x=function(){};_.y=function(){var val=(0,_.x)()||{}}\");\n+      test(\"function x(){x()}\",\n+          \"_.x=function(){(0,_.x)()}\");\n+    }\n+  }\n+}", "timestamp": 1320095387, "metainfo": ""}