{"sha": "9320feca198878ca9464aae089399a8891c314d7", "log": "Make StaticSourceFile a property of Node  R=johnlenz DELTA=183  (102 added, 25 deleted, 56 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2496   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AstParallelizer.java\n+++ b/src/com/google/javascript/jscomp/AstParallelizer.java\n     Predicate<Node> shouldSplit = new Predicate<Node>() {\n       @Override\n       public boolean apply(Node input) {\n-        String sourceName = (String) input.getProp(Node.SOURCENAME_PROP);\n-        return sourceName != null;\n+        return input.getSourceFileName() != null;\n       }\n     };\n \n--- a/src/com/google/javascript/jscomp/AstValidator.java\n+++ b/src/com/google/javascript/jscomp/AstValidator.java\n   }\n \n   private void validateHasSourceName(Node n) {\n-    String sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n+    String sourceName = n.getSourceFileName();\n     if (sourceName == null || sourceName.isEmpty()) {\n       violation(\"Missing 'source name' annotation.\", n);\n     }\n--- a/src/com/google/javascript/jscomp/CodePrinter.java\n+++ b/src/com/google/javascript/jscomp/CodePrinter.java\n       Preconditions.checkState(sourceMapDetailLevel != null);\n       Preconditions.checkState(node != null);\n       if (createSrcMap\n-          && node.getProp(Node.SOURCENAME_PROP) != null\n+          && node.getSourceFileName() != null\n           && node.getLineno() > 0\n           && sourceMapDetailLevel.apply(node)) {\n         int line = getCurrentLineIndex();\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n \n           String delimiter = options.inputDelimiter;\n \n-          String sourceName = (String)root.getProp(Node.SOURCENAME_PROP);\n+          String sourceName = root.getSourceFileName();\n           Preconditions.checkState(sourceName != null);\n           Preconditions.checkState(!sourceName.isEmpty());\n \n--- a/src/com/google/javascript/jscomp/CompilerInput.java\n+++ b/src/com/google/javascript/jscomp/CompilerInput.java\n \n   // Info about where the file lives.\n   private JSModule module;\n-  private boolean isExtern;\n   final private String name;\n \n   // The AST.\n   public CompilerInput(SourceAst ast, String inputName, boolean isExtern) {\n     this.ast = ast;\n     this.name = inputName;\n-    this.isExtern = isExtern;\n+\n+    // TODO(nicksantos): Add a precondition check here. People are passing\n+    // in null, but they should not be.\n+    if (ast != null && ast.getSourceFile() != null) {\n+      ast.getSourceFile().setIsExtern(isExtern);\n+    }\n   }\n \n   public CompilerInput(JSSourceFile file) {\n   }\n \n   public CompilerInput(JSSourceFile file, boolean isExtern) {\n-    this.ast = new JsAst(file);\n-    this.name = file.getName();\n-    this.isExtern = isExtern;\n+    this(new JsAst(file), file.getName(), isExtern);\n   }\n \n   /** Returns a name for this input. Must be unique across all inputs. */\n \n   @Override\n   public boolean isExtern() {\n-    return isExtern;\n+    if (ast == null || ast.getSourceFile() == null) {\n+      return false;\n+    }\n+    return ast.getSourceFile().isExtern();\n   }\n \n   void setIsExtern(boolean isExtern) {\n-    this.isExtern = isExtern;\n+    if (ast == null || ast.getSourceFile() == null) {\n+      return;\n+    }\n+    ast.getSourceFile().setIsExtern(isExtern);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/ControlStructureCheck.java\n+++ b/src/com/google/javascript/jscomp/ControlStructureCheck.java\n class ControlStructureCheck implements HotSwapCompilerPass {\n \n   private final AbstractCompiler compiler;\n-\n-  private String sourceName = null;\n \n   static final DiagnosticType USE_OF_WITH = DiagnosticType.warning(\n       \"JSC_USE_OF_WITH\",\n           report(node, USE_OF_WITH);\n         }\n         break;\n-\n-      case Token.SCRIPT:\n-        // Remember the source file name in case we need to report an error.\n-        sourceName = (String) node.getProp(Node.SOURCENAME_PROP);\n-        break;\n     }\n \n     for (Node bChild = node.getFirstChild(); bChild != null;) {\n   }\n \n   private void report(Node n, DiagnosticType error) {\n-    compiler.report(JSError.make(sourceName, n, error));\n+    compiler.report(JSError.make(n.getSourceFileName(), n, error));\n   }\n }\n--- a/src/com/google/javascript/jscomp/JSSourceFile.java\n+++ b/src/com/google/javascript/jscomp/JSSourceFile.java\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.Serializable;\n import java.nio.charset.Charset;\n-\n \n /**\n  * An abstract representation of a JavaScript source file, as input to\n  * @author nicksantos@google.com (Nick Santos)\n  * @author moedinger@google.com (Andrew Moedinger)\n  */\n-public class JSSourceFile extends SourceFile {\n+public class JSSourceFile extends SourceFile implements Serializable {\n+  private static final long serialVersionUID = 1L;\n \n   public static JSSourceFile fromFile(String fileName, Charset charSet) {\n     return new JSSourceFile(SourceFile.fromFile(fileName, charSet));\n--- a/src/com/google/javascript/jscomp/JsAst.java\n+++ b/src/com/google/javascript/jscomp/JsAst.java\n   @Override\n   public Node getAstRoot(AbstractCompiler compiler) {\n     if (root == null) {\n-      createAst(compiler);\n+      parse(compiler);\n     }\n     return root;\n   }\n     sourceFile = file;\n   }\n \n-  private void createAst(AbstractCompiler compiler) {\n+  private void parse(AbstractCompiler compiler) {\n     try {\n-      parse(compiler, sourceFile.getName(), sourceFile.getCode());\n-    } catch (IOException e) {\n-      compiler.report(\n-          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n-    }\n-  }\n-\n-  private void parse(AbstractCompiler compiler, String sourceName,\n-      String sourceStr) {\n-    try {\n-      logger_.fine(\"Parsing: \" + sourceName);\n-      root = ParserRunner.parse(sourceName, sourceStr,\n+      logger_.fine(\"Parsing: \" + sourceFile.getName());\n+      root = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n           compiler.getParserConfig(),\n           compiler.getDefaultErrorReporter(),\n           logger_);\n     } catch (IOException e) {\n-      compiler.report(JSError.make(AbstractCompiler.READ_ERROR, sourceName));\n+      compiler.report(\n+          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n     }\n \n     if (root == null || compiler.hasHaltingErrors()) {\n \n     // Set the source name so that the compiler passes can track\n     // the source file and module.\n-    root.putProp(Node.SOURCENAME_PROP, sourceName);\n+    root.setStaticSourceFile(sourceFile);\n   }\n }\n--- a/src/com/google/javascript/jscomp/NameReferenceGraphReport.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraphReport.java\n    *     cannot be identified.\n    */\n   private String getSourceFile(Node node) {\n-    String filename = (String) node.getProp(Node.SOURCENAME_PROP);\n+    String filename = node.getSourceFileName();\n     if (filename == null) {\n       return \"\";\n     }\n--- a/src/com/google/javascript/jscomp/NodeTraversal.java\n+++ b/src/com/google/javascript/jscomp/NodeTraversal.java\n   }\n \n   private static String getSourceName(Node n) {\n-    String name = (String) n.getProp(Node.SOURCENAME_PROP);\n+    String name = n.getSourceFileName();\n     return name == null ? \"\" : name;\n   }\n \n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n   public static String getSourceName(Node n) {\n     String sourceName = null;\n     while (sourceName == null && n != null) {\n-      sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n+      sourceName = n.getSourceFileName();\n       n = n.getParent();\n     }\n     return sourceName;\n--- a/src/com/google/javascript/jscomp/ReplaceStrings.java\n+++ b/src/com/google/javascript/jscomp/ReplaceStrings.java\n \n     void addLocation(Node n) {\n       replacementLocations.add(new Location(\n-          (String)n.getProp(Node.SOURCENAME_PROP),\n+          n.getSourceFileName(),\n           n.getLineno(), n.getCharno()));\n     }\n   }\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n       Node n = t.getCurrentNode().getParent();\n       if (n != null && isCallToScopeMethod(n)) {\n         transformation = transformationHandler.logAliasTransformation(\n-            n.getProp(Node.SOURCENAME_PROP).toString(), getSourceRegion(n));\n+            n.getSourceFileName(), getSourceRegion(n));\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/SourceFile.java\n+++ b/src/com/google/javascript/jscomp/SourceFile.java\n import com.google.common.base.Charsets;\n import com.google.common.io.CharStreams;\n import com.google.common.io.Files;\n+import com.google.javascript.rhino.jstype.StaticSourceFile;\n \n import java.io.File;\n import java.io.FileReader;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.Reader;\n+import java.io.Serializable;\n import java.io.StringReader;\n import java.nio.charset.Charset;\n \n  *\n  * @author nicksantos@google.com (Nick Santos)\n  */\n-public abstract class SourceFile {\n+public class SourceFile implements StaticSourceFile, Serializable {\n+  private static final long serialVersionUID = 1L;\n \n   /** A JavaScript source code provider.  The value should\n    * be cached so that the source text stays consistent throughout a single\n   private static final int SOURCE_EXCERPT_REGION_LENGTH = 5;\n \n   private final String fileName;\n+  private boolean isExternFile = false;\n \n   // The fileName may not always identify the original file - for example,\n   // supersourced Java inputs, or Java inputs that come from Jar files. This\n    *     need to correspond to a real path. But it should be unique. Will\n    *     appear in warning messages emitted by the compiler.\n    */\n-  SourceFile(String fileName) {\n+  public SourceFile(String fileName) {\n     if (fileName == null || fileName.isEmpty()) {\n       throw new IllegalArgumentException(\"a source must have a name\");\n     }\n   }\n \n   /** Returns a unique name for the source file. */\n+  @Override\n   public String getName() {\n     return fileName;\n+  }\n+\n+  /** Returns whether this is an extern. */\n+  @Override\n+  public boolean isExtern() {\n+    return isExternFile;\n+  }\n+\n+  /** Sets that this is an extern. */\n+  void setIsExtern(boolean newVal) {\n+    isExternFile = newVal;\n   }\n \n   /**\n    * A source file where the code has been preloaded.\n    */\n   static class Preloaded extends SourceFile {\n+    private static final long serialVersionUID = 1L;\n \n     Preloaded(String fileName, String code) {\n       this(fileName, fileName, code);\n    * from the injected interface.\n    */\n   static class Generated extends SourceFile {\n+    private static final long serialVersionUID = 1L;\n     private final Generator generator;\n \n     // Not private, so that LazyInput can extend it.\n    * possible.\n    */\n   static class OnDisk extends SourceFile {\n+    private static final long serialVersionUID = 1L;\n     private final File file;\n \n     // This is stored as a String, but passed in and out as a Charset so that\n--- a/src/com/google/javascript/jscomp/SourceInformationAnnotator.java\n+++ b/src/com/google/javascript/jscomp/SourceInformationAnnotator.java\n     // Verify the source file is annotated.\n     if (doSanityChecks && sourceFile != null) {\n       Preconditions.checkState(sourceFile.equals(\n-          n.getProp(Node.SOURCENAME_PROP)));\n+          n.getSourceFileName()));\n     }\n \n     // Annotate the original name.\n--- a/src/com/google/javascript/jscomp/SourceMap.java\n+++ b/src/com/google/javascript/jscomp/SourceMap.java\n       Node node,\n       FilePosition outputStartPosition,\n       FilePosition outputEndPosition) {\n-    String sourceFile = (String) node.getProp(Node.SOURCENAME_PROP);\n+    String sourceFile = node.getSourceFileName();\n     // If the node does not have an associated source file or\n     // its line number is -1, then the node does not have sufficient\n     // information for a mapping to be useful.\n--- a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n \n   private void scanRoot(Node n, Scope parent) {\n     if (n.getType() == Token.FUNCTION) {\n-      sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n+      sourceName = n.getSourceFileName();\n \n       final Node fnNameNode = n.getFirstChild();\n       final Node args = fnNameNode.getNext();\n         return;  // only one child to scan\n \n       case Token.SCRIPT:\n-        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n+        sourceName = n.getSourceFileName();\n         break;\n     }\n \n--- a/src/com/google/javascript/jscomp/SyntheticAst.java\n+++ b/src/com/google/javascript/jscomp/SyntheticAst.java\n  *\n  * @author nicksantos@google.com (Nick Santos)\n  */\n-class SyntheticAst implements SourceAst {\n+public class SyntheticAst implements SourceAst {\n   private static final long serialVersionUID = 1L;\n \n-  private final String sourceName;\n+  private final SourceFile sourceFile;\n \n   private Node root;\n \n   SyntheticAst(String sourceName) {\n-    this.sourceName = sourceName;\n+    this.sourceFile = new SourceFile(sourceName);\n     clearAst();\n   }\n \n   public void clearAst() {\n     root = new Node(Token.SCRIPT);\n     root.setIsSyntheticBlock(true);\n-    root.putProp(Node.SOURCENAME_PROP, sourceName);\n+    root.setStaticSourceFile(sourceFile);\n   }\n \n   @Override\n   public SourceFile getSourceFile() {\n-    return null;\n+    return sourceFile;\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n       ObjectType instance, ObjectType implementedInterface, String prop) {\n     if (!instance.hasProperty(prop)) {\n       // Not implemented\n-      String sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n+      String sourceName = n.getSourceFileName();\n       sourceName = sourceName == null ? \"\" : sourceName;\n       if (shouldReport) {\n         compiler.report(JSError.make(sourceName, n,\n--- a/src/com/google/javascript/jscomp/jsonml/JsonMLAst.java\n+++ b/src/com/google/javascript/jscomp/jsonml/JsonMLAst.java\n    */\n   private Node root;\n \n+  private final SourceFile sourceFile;\n+\n   public JsonMLAst(JsonML jsonml) {\n     this.jsonml = jsonml;\n+    this.sourceFile = new SourceFile(getSourceName());\n   }\n \n   @Override\n     translator.setRootElement(jsonml);\n     try {\n       root = translator.parse(compiler);\n-      root.putProp(Node.SOURCENAME_PROP, getSourceName());\n+      root.setStaticSourceFile(sourceFile);\n       new AstValidator().validateScript(root);\n     } catch (JsonMLException e) {\n       // compiler should already have JSErrors\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.StaticSourceFile;\n \n import java.util.Set;\n \n  * IRFactory transforms the new AST to the old AST.\n  *\n  */\n-public class IRFactory {\n+class IRFactory {\n \n   static final String SUSPICIOUS_COMMENT_WARNING =\n       \"Non-JSDoc comment has annotations. \" +\n       \"Did you mean to start it with '/**'?\";\n \n   private final String sourceString;\n+  private final StaticSourceFile sourceFile;\n   private final String sourceName;\n   private final Config config;\n   private final ErrorReporter errorReporter;\n   // TODO(johnlenz): Consider creating a template pool for ORIGINALNAME_PROP.\n \n   private IRFactory(String sourceString,\n-                    String sourceName,\n+                    StaticSourceFile sourceFile,\n                     Config config,\n                     ErrorReporter errorReporter) {\n     this.sourceString = sourceString;\n-    this.sourceName = sourceName;\n+    this.sourceFile = sourceFile;\n+\n+    // Sometimes this will be null in tests.\n+    this.sourceName = sourceFile == null ? null : sourceFile.getName();\n+\n     this.config = config;\n     this.errorReporter = errorReporter;\n     this.transformDispatcher = new TransformDispatcher();\n   private Node createTemplateNode() {\n     // The Node type choice is arbitrary.\n     Node templateNode = new Node(Token.SCRIPT);\n-    templateNode.putProp(Node.SOURCENAME_PROP, sourceName);\n+    templateNode.setStaticSourceFile(sourceFile);\n     return templateNode;\n   }\n \n   public static Node transformTree(AstRoot node,\n+                                   StaticSourceFile sourceFile,\n                                    String sourceString,\n                                    Config config,\n                                    ErrorReporter errorReporter) {\n-    IRFactory irFactory = new IRFactory(sourceString, node.getSourceName(),\n+    IRFactory irFactory = new IRFactory(sourceString, sourceFile,\n         config, errorReporter);\n     Node irNode = irFactory.transform(node);\n \n                                lineno,\n                                position2charno(position) + numOpeningChars),\n           node,\n-          sourceName,\n+          sourceFile,\n           config,\n           errorReporter);\n     jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n import com.google.javascript.jscomp.mozilla.rhino.ast.Comment;\n import com.google.javascript.jscomp.parsing.Config.LanguageMode;\n import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.JSDocInfo.Visibility;\n import com.google.javascript.rhino.JSDocInfoBuilder;\n import com.google.javascript.rhino.JSTypeExpression;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.ScriptRuntime;\n import com.google.javascript.rhino.Token;\n-import com.google.javascript.rhino.JSDocInfo.Visibility;\n+import com.google.javascript.rhino.jstype.SimpleSourceFile;\n+import com.google.javascript.rhino.jstype.StaticSourceFile;\n \n import java.util.HashSet;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-import java.util.List;\n \n /**\n  * A parser for JSDoc comments.\n \n   private final JsDocTokenStream stream;\n   private final JSDocInfoBuilder jsdocBuilder;\n+  private final StaticSourceFile sourceFile;\n   private final String sourceName;\n   private final ErrorReporter errorReporter;\n   private final ErrorReporterParser parser = new ErrorReporterParser();\n \n   JsDocInfoParser(JsDocTokenStream stream,\n                   Comment commentNode,\n-                  String sourceName,\n+                  StaticSourceFile sourceFile,\n                   Config config,\n                   ErrorReporter errorReporter) {\n     this.stream = stream;\n-    this.sourceName = sourceName;\n+    this.sourceFile = sourceFile;\n+\n+    // Sometimes this will be null in tests.\n+    this.sourceName = sourceFile == null ? null : sourceFile.getName();\n+\n     this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);\n     if (commentNode != null) {\n       this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue());\n     JsDocInfoParser parser = new JsDocInfoParser(\n         new JsDocTokenStream(typeString),\n         null,\n-        \"typeparsing\",\n+        new SimpleSourceFile(\"typeparsing\", false),\n         config,\n         NullErrorReporter.forNewRhino());\n \n   private Node createTemplateNode() {\n     // The Node type choice is arbitrary.\n     Node templateNode = new Node(Token.SCRIPT);\n-    templateNode.putProp(Node.SOURCENAME_PROP, sourceName);\n+    templateNode.setStaticSourceFile(sourceFile);\n     return templateNode;\n   }\n \n--- a/src/com/google/javascript/jscomp/parsing/ParserRunner.java\n+++ b/src/com/google/javascript/jscomp/parsing/ParserRunner.java\n import com.google.javascript.jscomp.mozilla.rhino.ast.AstRoot;\n import com.google.javascript.jscomp.parsing.Config.LanguageMode;\n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.jstype.StaticSourceFile;\n \n import java.io.IOException;\n import java.util.ResourceBundle;\n    * @return The AST of the given text.\n    * @throws IOException\n    */\n-  public static Node parse(String sourceName,\n+  public static Node parse(StaticSourceFile sourceFile,\n                            String sourceString,\n                            Config config,\n                            ErrorReporter errorReporter,\n     Parser p = new Parser(compilerEnv, errorReporter);\n     AstRoot astRoot = null;\n     try {\n-      astRoot = p.parse(sourceString, sourceName, 1);\n+      astRoot = p.parse(sourceString, sourceFile.getName(), 1);\n     } catch (EvaluatorException e) {\n-      logger.info(\"Error parsing \" + sourceName + \": \" + e.getMessage());\n+      logger.info(\n+          \"Error parsing \" + sourceFile.getName() + \": \" + e.getMessage());\n     } finally {\n       Context.exit();\n     }\n     Node root = null;\n     if (astRoot != null) {\n       root = IRFactory.transformTree(\n-          astRoot, sourceString, config, errorReporter);\n+          astRoot, sourceFile, sourceString, config, errorReporter);\n       root.setIsSyntheticBlock(true);\n     }\n     return root;\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n import com.google.common.base.Objects;\n import com.google.common.base.Preconditions;\n import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.SimpleSourceFile;\n+import com.google.javascript.rhino.jstype.StaticSourceFile;\n \n import java.io.IOException;\n import java.io.Serializable;\n       CASES_PROP        = 13,\n       DEFAULT_PROP      = 14,\n       CASEARRAY_PROP    = 15,\n+\n+      // TODO(nicksantos): Remove this prop.\n       SOURCENAME_PROP   = 16,\n+\n       TYPE_PROP         = 17,\n       SPECIAL_PROP_PROP = 18,\n       LABEL_PROP        = 19,\n       DIRECT_EVAL        = 49,    // ES5 distinguishes between direct and\n                                   // indirect calls to eval.\n       FREE_CALL          = 50,    // A CALL without an explicit \"this\" value.\n-      LAST_PROP          = 50;\n+      STATIC_SOURCE_FILE = 51,    // A StaticSourceFile indicating the file\n+                                  // where this node lives.\n+      LAST_PROP          = 51;\n \n   // values of ISNUMBER_PROP to specify\n   // which of the children are Number types\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n         case FREE_CALL:          return \"free_call\";\n+        case STATIC_SOURCE_FILE:    return \"source_file\";\n         default:\n           Kit.codeBug();\n       }\n   }\n \n   public Object getProp(int propType) {\n+    if (propType == SOURCENAME_PROP) {\n+      return getSourceFileName();\n+    }\n+\n     PropListItem item = lookupProperty(propType);\n     if (item == null) {\n       return null;\n   }\n \n   public void putProp(int propType, Object value) {\n+    if (propType == SOURCENAME_PROP) {\n+      putProp(\n+          STATIC_SOURCE_FILE, new SimpleSourceFile((String) value, false));\n+      return;\n+    }\n+\n     removeProp(propType);\n     if (value != null) {\n       propListHead = createProp(propType, value, propListHead);\n \n   //==========================================================================\n   // Source position management\n+\n+  public void setStaticSourceFile(StaticSourceFile file) {\n+    this.putProp(STATIC_SOURCE_FILE, file);\n+  }\n+\n+  public String getSourceFileName() {\n+    StaticSourceFile file =\n+        ((StaticSourceFile) this.getProp(STATIC_SOURCE_FILE));\n+    return file == null ? null : file.getName();\n+  }\n+\n+  public boolean isFromExterns() {\n+    StaticSourceFile file =\n+        ((StaticSourceFile) this.getProp(STATIC_SOURCE_FILE));\n+    return file == null ? false : file.isExtern();\n+  }\n \n   public void setLineno(int lineno) {\n       int charno = getCharno();\n     }\n \n     if (getProp(SOURCENAME_PROP) == null) {\n-        putProp(SOURCENAME_PROP, other.getProp(SOURCENAME_PROP));\n+      putProp(SOURCENAME_PROP, other.getProp(SOURCENAME_PROP));\n       sourcePosition = other.sourcePosition;\n+    }\n+\n+    if (getProp(STATIC_SOURCE_FILE) == null) {\n+      putProp(STATIC_SOURCE_FILE, other.getProp(STATIC_SOURCE_FILE));\n     }\n \n     return this;\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n     AstRoot script = p.parse(string, null, 0);\n \n     Config config = ParserRunner.createConfig(true, mode, false);\n-    Node root = IRFactory.transformTree(script, string, config, errorReporter);\n+    Node root = IRFactory.transformTree(\n+        script, null, string, config, errorReporter);\n \n     return root;\n   }\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.SimpleSourceFile;\n+import com.google.javascript.rhino.jstype.StaticSourceFile;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n \n import java.util.Collection;\n     Config config =\n         new Config(extraAnnotations, extraSuppressions,\n             true, LanguageMode.ECMASCRIPT3, false);\n+    StaticSourceFile file = new SimpleSourceFile(script.getSourceName(), false);\n     for (Comment comment : script.getComments()) {\n       JsDocInfoParser jsdocParser =\n         new JsDocInfoParser(\n             new JsDocTokenStream(comment.getValue().substring(3),\n                 comment.getLineno()),\n             comment,\n-            script.getSourceName(),\n+            file,\n             config,\n             testErrorReporter);\n       jsdocParser.parse();\n \n     Config config = new Config(extraAnnotations, extraSuppressions,\n         parseDocumentation, LanguageMode.ECMASCRIPT3, false);\n+    StaticSourceFile file = new SimpleSourceFile(\"testcode\", false);\n     JsDocInfoParser jsdocParser = new JsDocInfoParser(\n         stream(comment),\n         new Comment(0, 0, CommentType.JSDOC, comment),\n-        \"testcode\", config, errorReporter);\n+        file, config, errorReporter);\n \n     if (fileLevelJsDocBuilder != null) {\n       jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.SimpleSourceFile;\n+import com.google.javascript.rhino.jstype.StaticSourceFile;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n \n import java.io.IOException;\n+import java.util.List;\n import java.util.logging.Logger;\n-import java.util.List;\n-\n \n public class ParserTest extends BaseJSTypeTestCase {\n   private static final String SUSPICIOUS_COMMENT_WARNING =\n     TestErrorReporter testErrorReporter = new TestErrorReporter(errors, null);\n     Node script = null;\n     try {\n+\n+      StaticSourceFile file = new SimpleSourceFile(\"input\", false);\n       script = ParserRunner.parse(\n-          \"input\", string, ParserRunner.createConfig(isIdeMode, mode, false),\n+          file, string, ParserRunner.createConfig(isIdeMode, mode, false),\n           testErrorReporter, Logger.getAnonymousLogger());\n     } catch (IOException e) {\n       throw new RuntimeException(e);\n     TestErrorReporter testErrorReporter = new TestErrorReporter(null, warnings);\n     Node script = null;\n     try {\n+      StaticSourceFile file = new SimpleSourceFile(\"input\", false);\n       script = ParserRunner.parse(\n-          \"input\", string, ParserRunner.createConfig(true, mode, false),\n+          file, string, ParserRunner.createConfig(true, mode, false),\n           testErrorReporter, Logger.getAnonymousLogger());\n     } catch (IOException e) {\n       throw new RuntimeException(e);", "timestamp": 1309465531, "metainfo": ""}