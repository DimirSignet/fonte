{"sha": "1f4bd3b278d61f9c26ee617cd0a5d041e4e24887", "log": "Add parseInt and parseFloat support to PeepholeFoldConstants.  MOE re-sync of r1137  Revision created by MOE tool push_codebase.  R=acleung DELTA=242  (237 added, 0 deleted, 5 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2077   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n   }\n \n   private Node tryFoldKnownMethods(Node subtree) {\n-    // For now we only support .join(),\n+    // For now we only support string methods .join(),\n     // .indexOf(), .substring() and .substr()\n+    // and numeric methods parseInt() and parseFloat().\n \n     subtree = tryFoldArrayJoin(subtree);\n \n     if (subtree.getType() == Token.CALL) {\n-      subtree = tryFoldKnownStringMethods(subtree);\n+      Node callTarget = subtree.getFirstChild();\n+      if (callTarget == null) {\n+        return subtree;\n+      }\n+\n+      if (NodeUtil.isGet(callTarget)) {\n+        subtree = tryFoldKnownStringMethods(subtree);\n+      } else {\n+        subtree = tryFoldKnownNumericMethods(subtree);\n+      }\n     }\n \n     return subtree;\n   }\n \n   /**\n-   * Try to eveluate known String methods\n+   * Try to evaluate known String methods\n    *    .indexOf(), .substr(), .substring()\n    */\n   private Node tryFoldKnownStringMethods(Node subtree) {\n     Node stringNode = callTarget.getFirstChild();\n     Node functionName = stringNode.getNext();\n \n-    if ((stringNode.getType() != Token.STRING) || (\n-        (functionName.getType() != Token.STRING))) {\n+    if ((stringNode.getType() != Token.STRING) ||\n+        (functionName.getType() != Token.STRING)) {\n       return subtree;\n     }\n \n   }\n \n   /**\n+   * Try to evaluate known Numeric methods\n+   *    .parseInt(), parseFloat()\n+   */\n+  private Node tryFoldKnownNumericMethods(Node subtree) {\n+    Preconditions.checkArgument(subtree.getType() == Token.CALL);\n+\n+    if (isASTNormalized()) {\n+      // check if this is a call on a string method\n+      // then dispatch to specific folding method.\n+      Node callTarget = subtree.getFirstChild();\n+\n+      if (!NodeUtil.isName(callTarget)) {\n+        return subtree;\n+      }\n+\n+      String functionNameString = callTarget.getString();\n+      Node firstArgument = callTarget.getNext();\n+      if ((firstArgument != null) &&\n+          (firstArgument.getType() == Token.STRING ||\n+           firstArgument.getType() == Token.NUMBER)) {\n+        if (functionNameString.equals(\"parseInt\") ||\n+            functionNameString.equals(\"parseFloat\")) {\n+          subtree = tryFoldParseNumber(subtree, functionNameString,\n+              firstArgument);\n+        }\n+      }\n+    }\n+    return subtree;\n+  }\n+\n+  /**\n    * @return The lowered string Node.\n    */\n   private Node tryFoldStringToLowerCase(Node subtree, Node stringNode) {\n     subtree.getParent().replaceChild(subtree, replacement);\n     reportCodeChange();\n     return replacement;\n+  }\n+\n+  /**\n+   * @param input string representation of a number\n+   * @return string with leading and trailing zeros removed\n+   */\n+  private String normalizeNumericString(String input) {\n+    if (input == null || input.length() == 0) {\n+      return input;\n+    }\n+\n+    int startIndex = 0, endIndex = input.length() - 1;\n+    while (startIndex < input.length() && input.charAt(startIndex) == '0') {\n+      startIndex++;\n+    }\n+    while (endIndex >= 0 && input.charAt(endIndex) == '0') {\n+      endIndex--;\n+    }\n+    if (startIndex >= endIndex) {\n+      return input;\n+    }\n+\n+    return input.substring(startIndex, endIndex + 1);\n+  }\n+\n+  /**\n+   * Try to evaluate parseInt, parseFloat:\n+   *     parseInt(\"1\") -> 1\n+   *     parseInt(\"1\", 10) -> 1\n+   *     parseFloat(\"1.11\") -> 1.11\n+   */\n+  private Node tryFoldParseNumber(\n+      Node n, String functionName, Node firstArg) {\n+    Preconditions.checkArgument(n.getType() == Token.CALL);\n+\n+    boolean isParseInt = functionName.equals(\"parseInt\");\n+    Node secondArg = firstArg.getNext();\n+\n+    // Second argument is only used as the radix for parseInt\n+    int radix = 0;\n+    if (secondArg != null) {\n+      if (!isParseInt) {\n+        return n;\n+      }\n+\n+      // Third-argument and non-numeric second arg are problematic. Discard.\n+      if ((secondArg.getNext() != null) ||\n+          (secondArg.getType() != Token.NUMBER)) {\n+        return n;\n+      } else {\n+        double tmpRadix = secondArg.getDouble();\n+        if (tmpRadix != (int)tmpRadix)\n+          return n;\n+        radix = (int)tmpRadix;\n+        if (radix < 0 || radix == 1 || radix > 36) {\n+          return n;\n+        }\n+      }\n+    }\n+\n+    // stringVal must be a valid string.\n+    String stringVal = null;\n+    Double checkVal;\n+    if (firstArg.getType() == Token.NUMBER) {\n+      checkVal = NodeUtil.getNumberValue(firstArg);\n+      if (!(radix == 0 || radix == 10) && isParseInt) {\n+        //Convert a numeric first argument to a different base\n+        stringVal = String.valueOf(checkVal.intValue());\n+      } else {\n+        // If parseFloat is called with a numeric argument,\n+        // replace it with just the number.\n+        // If parseInt is called with a numeric first argument and the radix\n+        // is 10 or omitted, just replace it with the number\n+        Node numericNode;\n+        if (isParseInt) {\n+          numericNode = Node.newNumber(checkVal.intValue());\n+        } else {\n+          numericNode = Node.newNumber(checkVal);\n+        }\n+        n.getParent().replaceChild(n, numericNode);\n+        reportCodeChange();\n+        return numericNode;\n+      }\n+    } else {\n+      stringVal = NodeUtil.getStringValue(firstArg);\n+      if (stringVal == null) {\n+        return n;\n+      }\n+\n+      //Check that the string is in a format we can recognize\n+      checkVal = NodeUtil.getStringNumberValue(stringVal);\n+      if (checkVal == null || checkVal == Double.NaN) {\n+        return n;\n+      }\n+\n+      stringVal = NodeUtil.trimJsWhiteSpace(stringVal);\n+    }\n+\n+    Node newNode;\n+    if (isParseInt) {\n+      if (radix == 0 || radix == 16) {\n+        if (stringVal.length() > 1 &&\n+            stringVal.substring(0, 2).equalsIgnoreCase(\"0x\")) {\n+          radix = 16;\n+          stringVal = stringVal.substring(2);\n+        } else if (radix == 0) {\n+          // if a radix is not specified or is 0 and the most\n+          // significant digit is \"0\", the string will parse\n+          // with a radix of 8 on some browsers, so leave\n+          // this case alone. This check does not apply in\n+          // script mode ECMA5 or greater\n+          if (!isEcmaScript5OrGreater() &&\n+              stringVal.substring(0, 1).equals(\"0\")) {\n+            return n;\n+          }\n+\n+          radix = 10;\n+        }\n+      }\n+      int newVal = 0;\n+      try {\n+        newVal = Integer.parseInt(stringVal, radix);\n+      } catch (NumberFormatException e) {\n+        return n;\n+      }\n+\n+      newNode = Node.newNumber(newVal);\n+    } else {\n+      String normalizedNewVal = \"0\";\n+      try {\n+        double newVal = Double.parseDouble(stringVal);\n+        newNode = Node.newNumber(newVal);\n+        normalizedNewVal = normalizeNumericString(String.valueOf(newVal));\n+      }\n+      catch(NumberFormatException e) {\n+        return n;\n+      }\n+      // Make sure that the parsed number matches the original string\n+      // This prevents rounding differences between the java implementation\n+      // and native script.\n+      if (!normalizeNumericString(stringVal).equals(normalizedNewVal)) {\n+        return n;\n+      }\n+    }\n+\n+    n.getParent().replaceChild(n, newNode);\n+\n+    reportCodeChange();\n+\n+    return newNode;\n   }\n \n   /**\n     reportCodeChange();\n     return n;\n   }\n-}\n+}\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     test(\"(![1])\", \"false\");\n     test(\"(![a])\", \"false\");\n     testSame(\"(![foo()])\");\n+  }\n+\n+  public void testFoldParseNumbers() {\n+    enableNormalize();\n+    enableEcmaScript5(true);\n+\n+    fold(\"x = parseInt('123')\", \"x = 123\");\n+    fold(\"x = parseInt(' 123')\", \"x = 123\");\n+    fold(\"x = parseInt('123', 10)\", \"x = 123\");\n+    fold(\"x = parseInt('0xA')\", \"x = 10\");\n+    fold(\"x = parseInt('0xA', 16)\", \"x = 10\");\n+    fold(\"x = parseInt('07', 8)\", \"x = 7\");\n+    fold(\"x = parseInt('08')\", \"x = 8\");\n+    fold(\"x = parseFloat('1.23')\", \"x = 1.23\");\n+    fold(\"x = parseFloat('1.2300')\", \"x = 1.23\");\n+    fold(\"x = parseFloat(' 0.3333')\", \"x = 0.3333\");\n+\n+    //Mozilla Dev Center test cases\n+    fold(\"x = parseInt(' 0xF', 16)\", \"x = 15\");\n+    fold(\"x = parseInt(' F', 16)\", \"x = 15\");\n+    fold(\"x = parseInt('17', 8)\", \"x = 15\");\n+    fold(\"x = parseInt('015', 10)\", \"x = 15\");\n+    fold(\"x = parseInt('1111', 2)\", \"x = 15\");\n+    fold(\"x = parseInt('12', 13)\", \"x = 15\");\n+    fold(\"x = parseInt(021, 8)\", \"x = 15\");\n+    fold(\"x = parseInt(15.99, 10)\", \"x = 15\");\n+    fold(\"x = parseFloat('3.14')\", \"x = 3.14\");\n+    fold(\"x = parseFloat(3.14)\", \"x = 3.14\");\n+\n+    //Valid calls - unable to fold\n+    foldSame(\"x = parseInt('FXX123', 16)\");\n+    foldSame(\"x = parseInt('15*3', 10)\");\n+    foldSame(\"x = parseInt('15e2', 10)\");\n+    foldSame(\"x = parseInt('15px', 10)\");\n+    foldSame(\"x = parseInt('-0x08')\");\n+    foldSame(\"x = parseInt('1', -1)\");\n+    foldSame(\"x = parseFloat('3.14more non-digit characters')\");\n+    foldSame(\"x = parseFloat('314e-2')\");\n+    foldSame(\"x = parseFloat('0.0314E+2')\");\n+    foldSame(\"x = parseFloat('3.333333333333333333333333')\");\n+\n+    //Invalid calls\n+    foldSame(\"x = parseInt('0xa', 10)\");\n+\n+    enableEcmaScript5(false);\n+    foldSame(\"x = parseInt('08')\");\n   }\n \n   public void testFoldObjectLiteralRef() {", "timestamp": 1306520335, "metainfo": ""}