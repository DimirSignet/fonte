{"sha": "5f8b6f54294ce8b454f78165f5230b3759d11e37", "log": "Inline NodeUtil.isExpressionNode  R=nicksantos DELTA=37  (0 added, 4 deleted, 33 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4037   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ChainCalls.java\n+++ b/src/com/google/javascript/jscomp/ChainCalls.java\n      */\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (!NodeUtil.isExpressionNode(n)) {\n+      if (!n.isExprResult()) {\n         return;\n       }\n \n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n         // This no-op statement was there so that JSDoc information could\n         // be attached to the name. This check should not complain about it.\n         return;\n-      } else if (NodeUtil.isExpressionNode(n)) {\n+      } else if (n.isExprResult()) {\n         // we already reported the problem when we visited the child.\n         return;\n       }\n--- a/src/com/google/javascript/jscomp/ClosureCodeRemoval.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodeRemoval.java\n       Node rhs = node.getNext();\n       Node last = parent;\n       for (Node ancestor : assignAncestors) {\n-        if (NodeUtil.isExpressionNode(ancestor)) {\n+        if (ancestor.isExprResult()) {\n           lastAncestor.removeChild(ancestor);\n         } else {\n           rhs.detachFromParent();\n     for (Node call : assertionCalls) {\n       // If the assertion is an expression, just strip the whole thing.\n       Node parent = call.getParent();\n-      if (NodeUtil.isExpressionNode(parent)) {\n+      if (parent.isExprResult()) {\n         parent.getParent().removeChild(parent);\n       } else {\n         // Otherwise, replace the assertion with its first argument,\n--- a/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n           } else if (current.isAssign() &&\n                      current.getFirstChild() == child) {\n             Node currentParent = current.getParent();\n-            if (NodeUtil.isExpressionNode(currentParent) &&\n+            if (currentParent.isExprResult() &&\n                 canMoveValue(current.getLastChild())) {\n               return info.addDeclaration(\n                   new Declaration(t.getModule(), current, currentParent,\n--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n         Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs);\n         parent.replaceChild(n, op);\n       } else if (n.isInc() || n.isDec()) {\n-        if (NodeUtil.isExpressionNode(parent)) {\n+        if (parent.isExprResult()) {\n           parent.replaceChild(n,\n               IR.voidNode(IR.number(0).srcref(n)));\n         } else if(n.isComma() && n != parent.getLastChild()) {\n--- a/src/com/google/javascript/jscomp/Denormalize.java\n+++ b/src/com/google/javascript/jscomp/Denormalize.java\n     }\n \n     // Is the current node something that can be in a for loop initializer?\n-    if (!NodeUtil.isExpressionNode(n) && !n.isVar()) {\n+    if (!n.isExprResult() && !n.isVar()) {\n       return;\n     }\n \n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n         Node rhs = def.getLastChild();\n         rhs.detachFromParent();\n         // Oh yes! I have grandparent to remove this.\n-        Preconditions.checkState(NodeUtil.isExpressionNode(defParent));\n+        Preconditions.checkState(defParent.isExprResult());\n         while (defParent.getParent().isLabel()) {\n           defParent = defParent.getParent();\n         }\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n       case SIMPLE_ASSIGNMENT:\n         // The assignment is now part of the inline function so\n         // replace it completely.\n-        Preconditions.checkState(NodeUtil.isExpressionNode(grandParent));\n+        Preconditions.checkState(grandParent.isExprResult());\n         greatGrandParent.replaceChild(grandParent, newBlock);\n         break;\n \n       case SIMPLE_CALL:\n         // If nothing is looking at the result just replace the call.\n-        Preconditions.checkState(NodeUtil.isExpressionNode(parent));\n+        Preconditions.checkState(parent.isExprResult());\n         grandParent.replaceChild(parent, newBlock);\n         break;\n \n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n      */\n     boolean isNestedAssign(Node parent) {\n       return parent.isAssign() &&\n-             !NodeUtil.isExpressionNode(parent.getParent());\n+             !parent.getParent().isExprResult();\n     }\n \n     /**\n--- a/src/com/google/javascript/jscomp/InferJSDocInfo.java\n+++ b/src/com/google/javascript/jscomp/InferJSDocInfo.java\n         // 2)\n         // /** @deprecated */\n         // obj.prop;\n-        if (NodeUtil.isExpressionNode(parent) ||\n+        if (parent.isExprResult() ||\n             (parent.isAssign() &&\n              parent.getFirstChild() == n)) {\n           docInfo = n.getJSDocInfo();\n--- a/src/com/google/javascript/jscomp/MarkNoSideEffectCalls.java\n+++ b/src/com/google/javascript/jscomp/MarkNoSideEffectCalls.java\n       }\n \n       if (node.isGetProp()) {\n-        if (NodeUtil.isExpressionNode(parent) &&\n+        if (parent.isExprResult() &&\n             hasNoSideEffectsAnnotation(node)) {\n           noSideEffectFunctionNames.add(node);\n         }\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n           replaceWithRhs(containingNode, parent);\n           break;\n         case Token.ASSIGN:\n-          if (NodeUtil.isExpressionNode(containingNode)) {\n+          if (containingNode.isExprResult()) {\n             replaceWithRhs(containingNode.getParent(), containingNode);\n           } else {\n             replaceWithRhs(containingNode, parent);\n \n     @Override public void remove() {\n       Node gramps = parent.getParent();\n-      if (NodeUtil.isExpressionNode(gramps)) {\n+      if (gramps.isExprResult()) {\n         // name.prototype.foo = function() { ... };\n         changeProxy.removeChild(gramps.getParent(), gramps);\n       } else {\n     @Override\n     public void remove() {\n       Preconditions.checkState(node.isCall());\n-      if (NodeUtil.isExpressionNode(parent)) {\n+      if (parent.isExprResult()) {\n         changeProxy.removeChild(gramps, parent);\n       } else {\n         changeProxy.replaceWith(parent, node, IR.voidNode(IR.number(0)));\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n     throw new IllegalArgumentException(\"Not an assignment op:\" + n);\n   }\n \n-  static boolean isExpressionNode(Node n) {\n-    return n.isExprResult();\n-  }\n-\n   /**\n    * Determines if the given node contains a function statement or function\n    * expression.\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n         boolean explicit) {\n       Preconditions.checkArgument(\n           node == null /* The base case */ ||\n-          NodeUtil.isExpressionNode(node));\n+          node.isExprResult());\n       this.namespace = namespace;\n       this.firstNode = node;\n       this.firstModule = module;\n     void addProvide(Node node, JSModule module, boolean explicit) {\n       if (explicit) {\n         Preconditions.checkState(explicitNode == null);\n-        Preconditions.checkArgument(NodeUtil.isExpressionNode(node));\n+        Preconditions.checkArgument(node.isExprResult());\n         explicitNode = node;\n         explicitModule = module;\n       }\n      * assignment so it repurposed later.\n      */\n     void addDefinition(Node node, JSModule module) {\n-      Preconditions.checkArgument(NodeUtil.isExpressionNode(node) || // assign\n+      Preconditions.checkArgument(node.isExprResult() || // assign\n                                   node.isFunction() ||\n                                   node.isVar());\n       Preconditions.checkArgument(explicitNode != node);\n-      if ((candidateDefinition == null) || !NodeUtil.isExpressionNode(node)) {\n+      if ((candidateDefinition == null) || !node.isExprResult()) {\n         candidateDefinition = node;\n         updateMinimumModule(module);\n       }\n \n         // Does this need a VAR keyword?\n         replacementNode = candidateDefinition;\n-        if (NodeUtil.isExpressionNode(candidateDefinition) &&\n+        if (candidateDefinition.isExprResult() &&\n             !candidateDefinition.getFirstChild().isQualifiedName()) {\n           candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n           Node assignNode = candidateDefinition.getFirstChild();\n--- a/src/com/google/javascript/jscomp/RenameProperties.java\n+++ b/src/com/google/javascript/jscomp/RenameProperties.java\n           if (NodeUtil.isFunctionDeclaration(n)) {\n             String name = n.getFirstChild().getString();\n             if (RENAME_PROPERTY_FUNCTION_NAME.equals(name)) {\n-              if (NodeUtil.isExpressionNode(parent)) {\n+              if (parent.isExprResult()) {\n                 parent.detachFromParent();\n               } else {\n                 parent.removeChild(n);\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n       if (preprocessorSymbolTable != null) {\n         preprocessorSymbolTable.addReference(n.getFirstChild());\n       }\n-      if (!NodeUtil.isExpressionNode(parent)) {\n+      if (!parent.isExprResult()) {\n         report(t, n, GOOG_SCOPE_USED_IMPROPERLY);\n       }\n       if (n.getChildCount() != 2) {\n--- a/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n+++ b/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n         }\n       }\n \n-      if (inExterns && (parent != null) && NodeUtil.isExpressionNode(parent)) {\n+      if (inExterns && (parent != null) && parent.isExprResult()) {\n         String name = getSimplifiedName(node);\n         if (name != null) {\n \n--- a/src/com/google/javascript/jscomp/StatementFusion.java\n+++ b/src/com/google/javascript/jscomp/StatementFusion.java\n     Node last = block.getLastChild();\n \n     for (Node c = block.getFirstChild(); c != null; c = c.getNext()) {\n-      if (!NodeUtil.isExpressionNode(c) && c != last) {\n+      if (!c.isExprResult() && c != last) {\n         return false;\n       }\n     }\n--- a/src/com/google/javascript/jscomp/StripCode.java\n+++ b/src/com/google/javascript/jscomp/StripCode.java\n           if (isReferenceToRemovedVar(t, n)) {\n             if (parent.getFirstChild() == n) {\n               Node gramps = parent.getParent();\n-              if (NodeUtil.isExpressionNode(gramps)) {\n+              if (gramps.isExprResult()) {\n                 // Remove the assignment.\n                 Node greatGramps = gramps.getParent();\n                 replaceWithEmpty(gramps, greatGramps);\n           replaceWithNull(ancestorChild, ancestor);\n           break;\n         }\n-        if (NodeUtil.isExpressionNode(ancestor)) {\n+        if (ancestor.isExprResult()) {\n           // Remove the entire expression statement.\n           Node ancParent = ancestor.getParent();\n           replaceWithEmpty(ancestor, ancParent);\n         // Limit to EXPR_RESULT because it is not\n         // safe to eliminate assignment in complex expressions,\n         // e.g. in ((x = 7) + 8)\n-        if (NodeUtil.isExpressionNode(parent)) {\n+        if (parent.isExprResult()) {\n           Node gramps = parent.getParent();\n           replaceWithEmpty(parent, gramps);\n           compiler.reportCodeChange();\n       Node expression = n.getFirstChild();\n       if (nameEndsWithFieldNameToStrip(expression) ||\n           qualifiedNameBeginsWithStripType(expression)) {\n-        if (NodeUtil.isExpressionNode(parent)) {\n+        if (parent.isExprResult()) {\n           Node gramps = parent.getParent();\n           replaceWithEmpty(parent, gramps);\n         } else {\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n \n       case Token.CALL:\n         visitCall(t, n);\n-        typeable = !NodeUtil.isExpressionNode(parent);\n+        typeable = !parent.isExprResult();\n         break;\n \n       case Token.RETURN:\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n \n   public void testIsFunctionExpression1() {\n     Node root = parse(\"(function foo() {})\");\n-    Node StatementNode = root.getFirstChild();\n-    assertTrue(NodeUtil.isExpressionNode(StatementNode));\n-    Node functionNode = StatementNode.getFirstChild();\n+    Node statementNode = root.getFirstChild();\n+    assertTrue(statementNode.isExprResult());\n+    Node functionNode = statementNode.getFirstChild();\n     assertTrue(functionNode.isFunction());\n     assertTrue(NodeUtil.isFunctionExpression(functionNode));\n   }", "timestamp": 1325706835, "metainfo": ""}