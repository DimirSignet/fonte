{"sha": "833cd72a268c1161194038faf0d98ec6b1f203eb", "log": "Make RemoveUnusedVars a lot smarter about dead assigns. Granted, it's still nowhere near as smart as the real dead-assignment pass, so maybe it'd be better to say that this makes the pass less dumb.  R=acleung DELTA=251  (222 added, 15 deleted, 14 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=52002   ", "commit": "\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n \n import java.util.*;\n import java.util.logging.Logger;\n-\n \n /**\n  * Garbage collection for variable and function definitions. Basically performs\n \n   private final AbstractCompiler compiler;\n \n-  /** Keeps track of the number of variables removed per instance. */\n-  private int numRemoved = 0;\n-\n   private final boolean removeGlobals;\n \n   private boolean preserveFunctionExpressionNames;\n    * Keep track of variables that we've referenced.\n    */\n   private final Set<Var> referenced = Sets.newHashSet();\n+\n+  /**\n+   * Keep track of assigns to variables that we haven't referenced.\n+   */\n+  private final Multimap<Var, Assign> assigns = ArrayListMultimap.create();\n \n   RemoveUnusedVars(\n       AbstractCompiler compiler,\n    * may occur to ensure all unused variables are removed.\n    */\n   public void process(Node externs, Node root) {\n-    numRemoved = 0;\n-    referenced.clear();\n-\n     traverseAndRemoveUnusedReferences(root);\n-\n-    if (numRemoved > 0) {\n-      compiler.reportCodeChange();\n-    }\n   }\n \n   /**\n     traverseNode(root, null, scope);\n \n     if (removeGlobals) {\n+      interpretAssigns(scope);\n       removeUnreferencedVars(scope);\n     }\n   }\n \n       case Token.NAME:\n         if (parent.getType() != Token.VAR) {\n-          // All non-var declarations are references to other vars\n+          // All name references that aren't declarations or assigns\n+          // are references to other vars. If that var hasn't already been\n+          // marked referenced, then start tracking it.\n           Var var = scope.getVar(n.getString());\n-          if (var != null) {\n-            markReferencedVar(var);\n+          if (var != null && !referenced.contains(var)) {\n+            Assign maybeAssign = Assign.maybeCreateAssign(n);\n+            if (maybeAssign == null) {\n+              markReferencedVar(var);\n+            } else {\n+              // Put this in the assign map. It might count as a reference,\n+              // but we won't know that until we have an index of all assigns.\n+              assigns.put(var, maybeAssign);\n+            }\n           }\n         }\n         break;\n     Scope fnScope = new SyntacticScopeCreator(compiler).createScope(n, scope);\n     traverseNode(body, n, fnScope);\n \n+    interpretAssigns(fnScope);\n     removeUnreferencedFunctionArgs(n, fnScope);\n     removeUnreferencedVars(fnScope);\n   }\n         }\n         argList.removeChild(lastArg);\n         fnScope.undeclare(var);\n-        numRemoved++;\n+        finishRemove(var);\n       } else {\n         break;\n       }\n   }\n \n   /**\n+   * Look at all the property assigns to all variables in the given\n+   * scope. These may or may not count as references. For example,\n+   *\n+   * <code>\n+   * var x = {};\n+   * x.foo = 3; // not a reference.\n+   * var y = foo();\n+   * y.foo = 3; // is a reference.\n+   * </code>\n+   */\n+  private void interpretAssigns(Scope scope) {\n+    for (Iterator<Var> it = scope.getVars(); it.hasNext(); ) {\n+      Var var = it.next();\n+      if (!referenced.contains(var)) {\n+        boolean assignedToUnknownValue = false;\n+        boolean hasPropertyAssign = false;\n+\n+        if (var.getParentNode().getType() == Token.VAR) {\n+          Node value = var.getInitialValue();\n+          assignedToUnknownValue = value != null &&\n+              !NodeUtil.isLiteralValue(value);\n+        } else {\n+          // This was initialized to a function arg or a catch param.\n+          assignedToUnknownValue = true;\n+        }\n+\n+        for (Assign assign : assigns.get(var)) {\n+          if (assign.isPropertyAssign) {\n+            hasPropertyAssign = true;\n+          } else if (!NodeUtil.isLiteralValue(\n+              assign.assignNode.getLastChild())) {\n+            assignedToUnknownValue = true;\n+          }\n+        }\n+\n+        if (assignedToUnknownValue && hasPropertyAssign) {\n+          markReferencedVar(var);\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  /**\n+   * Finishes removal of a var by removing all assigns to it and reporting\n+   * a code change.\n+   */\n+  private void finishRemove(Var var) {\n+    for (Assign assign : assigns.get(var)) {\n+      assign.remove();\n+    }\n+    compiler.reportCodeChange();\n+  }\n+\n+  /**\n    * Marks a var as referenced, recursing into any functions.\n    */\n   private void markReferencedVar(Var var) {\n-    if (referenced.contains(var)) {\n-      // Already marked\n-      return;\n-    }\n     referenced.add(var);\n \n     Node parent = var.getParentNode();\n         } else if (NodeUtil.isFunctionExpression(toRemove)) {\n           if (!preserveFunctionExpressionNames) {\n             toRemove.getFirstChild().setString(\"\");\n-            compiler.reportCodeChange();\n+            finishRemove(var);\n           }\n           // Don't remove bleeding functions.\n         } else if (parent != null &&\n           if (toRemove.getChildCount() == 1) {\n             parent.replaceChild(toRemove,\n                 new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n-            numRemoved++;\n+            finishRemove(var);\n           }\n         } else if (toRemove.getType() == Token.VAR &&\n                    toRemove.getChildCount() > 1) {\n           // For var declarations with multiple names (i.e. var a, b, c),\n           // only remove the unreferenced name\n           toRemove.removeChild(nameNode);\n-          numRemoved++;\n+          finishRemove(var);\n         } else if (parent != null) {\n           NodeUtil.removeChild(parent, toRemove);\n-          numRemoved++;\n-        }\n-      }\n+          finishRemove(var);\n+        }\n+      }\n+    }\n+  }\n+\n+  private static class Assign {\n+\n+    final Node assignNode;\n+\n+    // If false, then this is an assign to the normal variable. Otherwise,\n+    // this is an assign to a property of that variable.\n+    final boolean isPropertyAssign;\n+\n+    Assign(Node assignNode, boolean isPropertyAssign) {\n+      Preconditions.checkState(NodeUtil.isAssignmentOp(assignNode));\n+      this.assignNode = assignNode;\n+      this.isPropertyAssign = isPropertyAssign;\n+    }\n+\n+    /**\n+     * If this is an assign to the given name, return that name.\n+     * Otherwise, return null.\n+     */\n+    static Assign maybeCreateAssign(Node name) {\n+      Preconditions.checkState(name.getType() == Token.NAME);\n+\n+      // Skip any GETPROPs or GETELEMs\n+      boolean isPropAssign = false;\n+      Node previous = name;\n+      Node current = name.getParent();\n+      while (previous == current.getFirstChild() &&\n+          NodeUtil.isGet(current)) {\n+        previous = current;\n+        current = current.getParent();\n+        isPropAssign = true;\n+      }\n+\n+      if (previous == current.getFirstChild() &&\n+          NodeUtil.isAssignmentOp(current)) {\n+        return new Assign(current, isPropAssign);\n+      }\n+      return null;\n+    }\n+\n+    /**\n+     * Replace the current assign with its right hand side.\n+     */\n+    void remove() {\n+      Node replacement = assignNode.getLastChild().detachFromParent();\n+\n+      // Aggregate any expressions in GETELEMs.\n+      for (Node current = assignNode.getFirstChild();\n+           current.getType() != Token.NAME;\n+           current = current.getFirstChild()) {\n+        if (current.getType() == Token.GETELEM) {\n+          replacement = new Node(Token.COMMA,\n+              current.getLastChild().detachFromParent(), replacement);\n+          replacement.copyInformationFrom(current);\n+        }\n+      }\n+\n+      assignNode.getParent().replaceChild(\n+          assignNode, replacement);\n     }\n   }\n }\n--- a/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n          \"return function(){print(f)}}B()\");\n \n     // Test exported names\n-    test(\"var a,b=1; function _A1() {a=1}\",\n-         \"var a;function _A1(){a=1}\");\n+    test(\"var a,b=1; function _A1() {this.foo(a)}\",\n+         \"var a;function _A1(){this.foo(a)}\");\n \n     // Test undefined (i.e. externally defined) names\n     test(\"undefinedVar = 1\", \"undefinedVar=1\");\n     test(createModules(\n              \"var unreferenced=1; function x() { foo(); }\" +\n              \"function uncalled() { var x; return 2; }\",\n-             \"var a,b; function foo() { a=1; } x()\"),\n+             \"var a,b; function foo() { this.foo(a); } x()\"),\n          new String[] {\n            \"function x(){foo()}\",\n-           \"var a;function foo(){a=1}x()\"\n+           \"var a;function foo(){this.foo(a)}x()\"\n          });\n   }\n \n          \"function b(){a()}\");\n   }\n \n+  public void testUnusedAssign1() {\n+    test(\"var x = 3; x = 5;\", \"5\");\n+  }\n+\n+  public void testUnusedAssign2() {\n+    test(\"function f(a) { a = 3; } this.x = f;\",\n+        \"function f(){3}this.x=f\");\n+  }\n+\n+  public void testUnusedAssign3() {\n+    // e can't be removed, so we don't try to remove the dead assign.\n+    // We might be able to improve on this case.\n+    test(\"try { throw ''; } catch (e) { e = 3; }\",\n+        \"try{throw\\\"\\\";}catch(e){e=3}\");\n+  }\n+\n+  public void testUnusedAssign4() {\n+    // b can't be removed, so a can't be removed either. We might be able\n+    // to improve on this case.\n+    test(\"function f(a, b) { this.foo(b); a = 3; } this.x = f;\",\n+        \"function f(a,b){this.foo(b);a=3}this.x=f\");\n+  }\n+\n+  public void testUnusedAssign5() {\n+    test(\"var z = function f() { f = 3; }; z();\",\n+         \"var z=function(){3};z()\");\n+  }\n+\n+  public void testUnusedAssign6() {\n+    test(\"var z; z = 3;\", \"3\");\n+  }\n+\n+  public void testUnusedPropAssign1() {\n+    test(\"var x = {}; x.foo = 3;\", \"3\");\n+  }\n+\n+  public void testUnusedPropAssign2() {\n+    test(\"var x = {}; x['foo'] = 3;\", \"\\\"foo\\\",3\");\n+  }\n+\n+  public void testUnusedPropAssign3() {\n+    test(\"var x = {}; x['foo'] = {}; x['foo'].baz['bar'] = 3\",\n+        \"\\\"foo\\\",{};\\\"foo\\\",\\\"bar\\\",3\");\n+  }\n+\n+  public void testUnusedPropAssign4() {\n+    test(\"var x = {foo: 3}; x['foo'] = 5;\", \"\\\"foo\\\",5\");\n+  }\n+\n+  public void testUnusedPropAssign5() {\n+    // Because bar() has a side-effect, the whole variable stays in. We might\n+    // be able to improve on this case.\n+    test(\"var x = {foo: bar()}; x['foo'] = 5;\",\n+         \"var x={foo:bar()};x[\\\"foo\\\"]=5\");\n+  }\n+\n+  public void testUsedPropAssign1() {\n+    test(\"function f(x) { x.bar = 3; } f({});\",\n+         \"function f(x){x.bar=3}f({})\");\n+  }\n+\n+  public void testUsedPropAssign2() {\n+    test(\"try { throw z; } catch (e) { e.bar = 3; }\",\n+         \"try{throw z;}catch(e){e.bar=3}\");\n+  }\n+\n+  public void testUsedPropAssign3() {\n+    // This pass does not do flow analysis.\n+    test(\"var x = {}; x.foo = 3; x = bar();\",\n+         \"var x={};x.foo=3;x=bar()\");\n+  }\n+\n+  public void testUsedPropAssign4() {\n+    test(\"var y = foo(); var x = {}; x.foo = 3; y[x.foo] = 5;\",\n+         \"var y=foo();var x={};x.foo=3;y[x.foo]=5\");\n+  }\n+\n+  public void testUsedPropAssign5() {\n+    test(\"var y = foo(); var x = 3; y[x] = 5;\",\n+         \"var y=foo();var x=3;y[x]=5\");\n+  }\n+\n+  public void testUsedPropAssign6() {\n+    test(\"var x = newNodeInDom(doc); x.innerHTML = 'new text';\",\n+         \"var x=newNodeInDom(doc);x.innerHTML=\\\"new text\\\"\");\n+  }\n }", "timestamp": 1279227727, "metainfo": ""}