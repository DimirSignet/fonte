{"sha": "2dbbe0784ee3e549eb0cc4d679aeddaac1243145", "log": "Change on 2010/04/09 by nick          Make it possible to explicitly specify unknown parameter and         return types.          R=nada         DELTA=77  (74 added, 0 deleted, 3 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=wjzzsm   ", "commit": "\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n  * A parser for JSDoc comments.\n  *\n *\n+ * @author nicksantos@google.com (Nick Santos)\n  */\n // TODO(nicksantos): Unify all the JSDocInfo stuff into one package, instead of\n // spreading it across mutliple packages.\n    *     | '!' BasicTypeExpression\n    *     | BasicTypeExpression '?'\n    *     | BasicTypeExpression '!'\n+   *     | '?'\n    */\n   private Node parseTypeExpression(JsDocToken token) {\n     if (token == JsDocToken.QMARK) {\n-      return wrapNode(Token.QMARK, parseBasicTypeExpression(next()));\n+      // A QMARK could mean that a type is nullable, or that it's unknown.\n+      // We use look-ahead 1 to determine whether it's unknown. Otherwise,\n+      // we assume it means nullable. There are 5 cases:\n+      // {?} - right curly\n+      // {?=} - equals\n+      // {function(?, number)} - comma\n+      // {function(number, ?)} - right paren\n+      // {function(): ?|number} - pipe\n+      // I'm not a big fan of using look-ahead for this, but it makes\n+      // the type language a lot nicer.\n+      token = next();\n+      if (token == JsDocToken.COMMA ||\n+          token == JsDocToken.EQUALS ||\n+          token == JsDocToken.RC ||\n+          token == JsDocToken.RP ||\n+          token == JsDocToken.PIPE) {\n+        restoreLookAhead(token);\n+        return newNode(Token.QMARK);\n+      }\n+\n+      return wrapNode(Token.QMARK, parseBasicTypeExpression(token));\n     } else if (token == JsDocToken.BANG) {\n       return wrapNode(Token.BANG, parseBasicTypeExpression(next()));\n     } else {\n    */\n   private JsDocToken unreadToken = NO_UNREAD_TOKEN;\n \n+  /** Restores the lookahead token to the token stream */\n+  private void restoreLookAhead(JsDocToken token) {\n+    unreadToken = token;\n+  }\n+\n   /**\n    * Tests whether the next symbol of the token stream matches the specific\n    * token.\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n         return createFromTypeNodes(n.getFirstChild(), sourceName, scope)\n             .restrictByNotNullOrUndefined();\n \n-      case Token.QMARK: // Nullable\n+      case Token.QMARK: // Nullable or unknown\n+        Node firstChild = n.getFirstChild();\n+        if (firstChild == null) {\n+          return getNativeType(UNKNOWN_TYPE);\n+        }\n         return createNullableType(\n-            createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n+            createFromTypeNodes(firstChild, sourceName, scope));\n \n       case Token.EQUALS: // Optional\n         return createOptionalType(\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n         \"type not recognized due to syntax error\");\n   }\n \n+  public void testParseUnknownType1() throws Exception {\n+    testParseType(\"?\");\n+  }\n+\n+  public void testParseUnknownType2() throws Exception {\n+    testParseType(\"(?|number)\", \"?\");\n+  }\n+\n+  public void testParseUnknownType3() throws Exception {\n+    testParseType(\"(number|?)\", \"?\");\n+  }\n+\n   public void testParseFunctionalType1() throws Exception {\n     testParseType(\"function (): number\");\n   }\n \n   public void testParseFunctionalType14() throws Exception {\n     testParseType(\"function (*, string, number): boolean\");\n+  }\n+\n+  public void testParseFunctionalType15() throws Exception {\n+    testParseType(\"function (?, string): boolean\");\n+  }\n+\n+  public void testParseFunctionalType16() throws Exception {\n+    testParseType(\"function (string, ?): ?\");\n+  }\n+\n+  public void testParseFunctionalType17() throws Exception {\n+    testParseType(\"(function (?): ?|number)\");\n+  }\n+\n+  public void testParseFunctionalType18() throws Exception {\n+    testParseType(\"function (?): (?|number)\", \"function (?): ?\");\n   }\n \n   public void testBug1419535() throws Exception {\n     assertTypeEquals(\n         registry.createOptionalType(UNKNOWN_TYPE),\n         info.getParameterType(\"index\"));\n+    assertTrue(info.getParameterType(\"index\").isVarArgs());\n+  }\n+\n+  public void testParseParam20() throws Exception {\n+    JSDocInfo info = parse(\"@param {?=} index */\");\n+    assertEquals(1, info.getParameterCount());\n+    assertTypeEquals(\n+        UNKNOWN_TYPE, info.getParameterType(\"index\"));\n+  }\n+\n+  public void testParseParam21() throws Exception {\n+    JSDocInfo info = parse(\"@param {...?} index */\");\n+    assertEquals(1, info.getParameterCount());\n+    assertTypeEquals(\n+        UNKNOWN_TYPE, info.getParameterType(\"index\"));\n     assertTrue(info.getParameterType(\"index\").isVarArgs());\n   }\n ", "timestamp": 1270836449, "metainfo": ""}