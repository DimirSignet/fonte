{"sha": "869c65d5c43d96526d90c7ea9a186df9edd67eb0", "log": "Automated g4 rollback.  *** Reason for rollback ***  Be less aggressive about inlining functions contains inner function (go back to limiting this to global scope). From the the original change:  Tweaks to function inlining: - an unnamed function expression containing a inner unnamed function expression should not be disallow because the names are the same. - a caller that contains the function definition to be inlined should not consider the candidate to be a capturing function. - allow inlining a function containing an inner function that references arguments. - disallow inlining a function into a function containing eval if intoducing names. - when inlining a function containing a function declaration, rewrite it a var declarations and function expressions to avoid introducing function declaraions into contexts disallowed by ES5 strict.  *** Original change description ***  Automated g4 rollback of changelist 23059472.  *** Reason for rollback ***  Breaks things  R=acleung DELTA=149  (127 added, 0 deleted, 22 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3079   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n     final String fnRecursionName = fnNode.getFirstChild().getString();\n     Preconditions.checkState(fnRecursionName != null);\n \n+    // If the function references \"arguments\" directly in the function\n+    boolean referencesArguments = NodeUtil.isNameReferenced(\n+        block, \"arguments\", NodeUtil.MATCH_NOT_FUNCTION);\n+\n+    // or it references \"eval\" or one of its names anywhere.\n     Predicate<Node> p = new Predicate<Node>(){\n       @Override\n       public boolean apply(Node n) {\n         if (n.getType() == Token.NAME) {\n-          return n.getString().equals(\"arguments\")\n-            || n.getString().equals(\"eval\")\n-            || n.getString().equals(fnName)\n+          return n.getString().equals(\"eval\")\n+            || (!fnName.isEmpty()\n+                && n.getString().equals(fnName))\n             || (!fnRecursionName.isEmpty()\n                 && n.getString().equals(fnRecursionName));\n         }\n       }\n     };\n \n-    return !NodeUtil.has(block, p, Predicates.<Node>alwaysTrue());\n+    return !referencesArguments\n+        && !NodeUtil.has(block, p, Predicates.<Node>alwaysTrue());\n   }\n \n   /**\n    * inlining would introduce new globals.\n    */\n   private boolean callMeetsBlockInliningRequirements(\n-      NodeTraversal t, Node callNode, Node fnNode, Set<String> namesToAlias) {\n+      NodeTraversal t, Node callNode, final Node fnNode,\n+      Set<String> namesToAlias) {\n     // Note: functions that contain function definitions are filtered out\n     // in isCanidateFunction.\n \n         NodeUtil.getFunctionBody(fnNode),\n         new NodeUtil.MatchDeclaration(),\n         new NodeUtil.MatchShallowStatement());\n-    boolean callerContainsFunction = false;\n+    boolean forbidTemps = false;\n     if (!t.inGlobalScope()) {\n       Node fnCaller = t.getScopeRoot();\n       Node fnCallerBody = fnCaller.getLastChild();\n \n-      callerContainsFunction = NodeUtil.containsFunction(fnCallerBody);\n-    }\n-\n-    if (fnContainsVars && callerContainsFunction) {\n+      // Don't allow any new vars into a scope that contains eval or one\n+      // that contains functions (excluding the function being inlined).\n+      Predicate<Node> match = new Predicate<Node>(){\n+        @Override\n+        public boolean apply(Node n) {\n+          if (n.getType() == Token.NAME) {\n+            return n.getString().equals(\"eval\");\n+          }\n+          if (n.getType() == Token.FUNCTION) {\n+            return n != fnNode;\n+          }\n+          return false;\n+        }\n+      };\n+      forbidTemps = NodeUtil.has(fnCallerBody,\n+          match, NodeUtil.MATCH_NOT_FUNCTION);\n+    }\n+\n+    if (fnContainsVars && forbidTemps) {\n       return false;\n     }\n \n-    // If the caller contains functions, verify we aren't adding any\n+    // If the caller contains functions or evals, verify we aren't adding any\n     // additional VAR declarations because aliasing is needed.\n-    if (callerContainsFunction) {\n+    if (forbidTemps) {\n       Map<String, Node> args =\n           FunctionArgumentInjector.getFunctionCallParameterMap(\n               fnNode, callNode, this.safeNameIdSupplier);\n--- a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n+++ b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n     // without causing conflicts.\n     makeLocalNamesUnique(newFnNode, isCallInLoop);\n \n+    // Function declarations must be rewritten as function expressions as\n+    // they will be within a block and normalization prevents function\n+    // declarations within block as browser implementations vary.\n+    rewriteFunctionDeclarations(newFnNode.getLastChild());\n+\n     // TODO(johnlenz): Mark NAME nodes constant for parameters that are not\n     // modified.\n     Set<String> namesToAlias =\n     return injectableBlock;\n   }\n \n+\n+  /**\n+   * @param n The node to inspect\n+   */\n+  private void rewriteFunctionDeclarations(Node n) {\n+    if (n.getType() == Token.FUNCTION) {\n+      if (NodeUtil.isFunctionDeclaration(n)) {\n+        // Rewrite: function f() {} ==> var f = function() {}\n+        Node fnNameNode = n.getFirstChild();\n+\n+        Node var = new Node(Token.VAR).copyInformationFrom(n);\n+        Node name = Node.newString(Token.NAME, fnNameNode.getString())\n+            .copyInformationFrom(fnNameNode);\n+\n+        fnNameNode.setString(\"\");\n+        // Add the VAR, remove the FUNCTION\n+        n.getParent().replaceChild(n, var);\n+        var.addChildToFront(name);\n+        // readd the function as a function expression\n+        name.addChildToFront(n);\n+      }\n+      return;\n+    }\n+\n+    for (Node c = n.getFirstChild(), next; c != null; c = next) {\n+      next = c.getNext(); // We may rewrite \"c\"\n+      rewriteFunctionDeclarations(c);\n+    }\n+  }\n \n   /**\n    *  For all VAR node with uninitialized declarations, set\n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n     helperInlineReferenceToFunction(\n         \"function foo(){function x() {var a; return true;} return x}; foo();\",\n         \"function foo(){function x(){var a;return true}return x};\" +\n-            \"{function x$$inline_1(){var a$$inline_2;return true}x$$inline_1}\",\n+            \"{var x$$inline_1 = function(){\" +\n+            \"var a$$inline_2;return true};x$$inline_1}\",\n         \"foo\", INLINE_BLOCK);\n   }\n \n \n   private static Node parseExpected(Compiler compiler, String js) {\n     Node n = compiler.parseTestCode(js);\n-    assertEquals(0, compiler.getErrorCount());\n+    String message = \"Unexpected errors: \";\n+    JSError[] errs = compiler.getErrors();\n+    for (int i = 0; i < errs.length; i++){\n+      message += \"\\n\" + errs[i].toString();\n+    }\n+    assertEquals(message, 0, compiler.getErrorCount());\n     return n;\n   }\n \n--- a/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java\n         \"foo\", null, false, callInLoop);\n   }\n \n+  public void testMutateFunctionDefinition() {\n+     // function declarations are rewritten as function\n+     // expressions\n+     helperMutate(\n+        \"function foo(a){function g(){}}; foo(1);\",\n+        \"{var g$$inline_3=function(){};}\",\n+        \"foo\", null);\n+  }\n \n   public void helperMutate(\n       String code, final String expectedResult, final String fnName) {\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n   }\n \n   public void testInlineFunctions15b() {\n-    // closure factories: don't inline closure with locals.\n+    // closure factories: don't inline closure with locals in global scope.\n     test(\"function foo(){var x;return function(a){return a+1}}\" +\n          \"var b=function(){return c};\" +\n          \"var d=b()+foo()\",\n          \"function _x(){ var d=c+foo() }\");\n   }\n \n-  public void testInlineFunctions16() {\n-    // watch out for closures that are deeper in the function\n+  public void testInlineFunctions15d() {\n+    // closure factories: don't inline functions with vars.\n+    test(\"function foo(){var x; return function(a){return a+1}}\" +\n+         \"var b=function(){return c};\" +\n+         \"function _x(){ var d=b()+foo() }\",\n+\n+         \"function foo(){var x; return function(a){return a+1}}\" +\n+         \"function _x(){ var d=c+foo() }\");\n+  }\n+\n+  public void testInlineFunctions16a() {\n     testSame(\"function foo(b){return window.bar(function(){c(b)})}\" +\n-             \"var d=foo(e)\");\n+         \"var d=foo(e)\");\n+  }\n+\n+  public void testInlineFunctions16b() {\n+    test(\"function foo(){return window.bar(function(){c()})}\" +\n+         \"var d=foo(e)\",\n+         \"var d=window.bar(function(){c()})\");\n   }\n \n   public void testInlineFunctions17() {\n   }\n \n   public void testComplexFunctionWithFunctionDefinition2() {\n-    // Don't inline if local names might need to be captured.\n+    // Don't inline if local names might be captured.\n     testSame(\"function f(a){call(function(){return})}f()\");\n+  }\n+\n+  public void testComplexFunctionWithFunctionDefinition2a() {\n+    // Don't inline if local names might be captured.\n+    testSame(\"(function(){\" +\n+        \"var f = function(a){call(function(){return})};f()})()\");\n   }\n \n   public void testComplexFunctionWithFunctionDefinition3() {\n   }\n \n   public void testFunctionExpressionCallInlining11c() {\n-    // Can't inline functions that return inner functions into non-global scope.\n+    // TODO(johnlenz): Can inline, not temps needed.\n     testSame(\"function _x() {\" +\n-                \"((function(){return function(){foo()}})())();\" +\n-                \"}\");\n+         \"  ((function(){return function(){foo()}})())();\" +\n+         \"}\");\n+  }\n+\n+  public void testFunctionExpressionCallInlining11d() {\n+    // TODO(johnlenz): Can inline into a function containing eval, if\n+    // no names are introduced.\n+    testSame(\"function _x() {\" +\n+         \"  eval();\" +\n+         \"  ((function(){return function(){foo()}})())();\" +\n+         \"}\");\n+  }\n+\n+  public void testFunctionExpressionCallInlining11e() {\n+    // No, don't inline into a function containing eval,\n+    // if no temps are introduced.\n+    testSame(\"function _x() {\" +\n+         \"  eval();\" +\n+         \"  ((function(a){return function(){foo()}})())();\" +\n+         \"}\");\n   }\n \n   public void testFunctionExpressionCallInlining12() {\n         \"})(jQuery)\");\n   }\n \n+  public void testAnonymous1() {\n+    test(\"(function(){var a=10;(function(){var b=a;a++;alert(b)})()})();\",\n+         \"{var a$$inline_2=10;\" +\n+         \"{var b$$inline_3=a$$inline_2;\" +\n+         \"a$$inline_2++;alert(b$$inline_3)}}\");\n+  }\n+\n+  public void testAnonymous2() {\n+    testSame(\"(function(){eval();(function(){var b=a;a++;alert(b)})()})();\");\n+  }\n+\n+  public void testAnonymous3() {\n+    // Introducing a new value into is tricky\n+    testSame(\"(function(){var a=10;(function(){arguments;})()})();\");\n+    test(\"(function(){(function(){arguments;})()})();\",\n+        \"{(function(){arguments;})()}\");\n+  }\n+\n   // Inline a single reference function into deeper modules\n   public void testCrossModuleInlining1() {\n     test(createModuleChain(", "timestamp": 1313779059, "metainfo": ""}