{"sha": "b4bf1efe7524c85fd931c9a2b49ec1aab90261a8", "log": "Defer building of error messages for Preconditions.check(State|NotNull|Argument) calls.  Two types of calls are considered. Preconditions.checkState(foo.isBar(), \"The foo \" + foo + \" is not a bar\"); Preconditions.checkState(foo.isBar(), String.format(\"The foo %s is not a bar\", foo));  Both get converted to: Preconditions.checkState(foo.isBar(), \"The foo %s is not a bar\", foo);  This is MUCH faster in the overwhelmingly common case where foo actually is a bar because we don't need to build (and garbage-collect) a new string each time.  A couple of examples will have been missed: * In some cases, the tool wasn't able to automatically reduce the line length to under 100 (about 60-70 examples). These will be submitted in a separate, smaller CL which may require some manual effort or a smarter tool. * For simplicity, merge conflicts are resolved by overwriting our version and using the version in the depot. This is safe but means some files will be missed in this iteration. I will mop these up in a later CL.  R=cpovirk,jmourits   Revision created by MOE tool push_codebase. MOE_MIGRATION=3581   ", "commit": "\n--- a/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java\n     }\n \n     int index = search(entries, column, 0, entries.size() - 1);\n-    Preconditions.checkState(index >= 0, \"unexpected:\" + index);\n+    Preconditions.checkState(index >= 0, \"unexpected:%s\", index);\n     return getOriginalMappingForEntry(entries.get(index));\n   }\n \n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     if (input == null) {\n       return;\n     }\n-    Preconditions.checkState(input.isExtern(), \"Not an extern input: \"\n-        + input.getName());\n+    Preconditions.checkState(input.isExtern(), \"Not an extern input: %s\", input.getName());\n     inputsById.remove(id);\n     externs.remove(input);\n     Node root = input.getAstRoot(this);\n   /** Add a source input dynamically. Intended for incremental compilation. */\n   void addIncrementalSourceAst(JsAst ast) {\n     InputId id = ast.getInputId();\n-    Preconditions.checkState(\n-        getInput(id) == null,\n-        \"Duplicate input \" + id.getIdName());\n+    Preconditions.checkState(getInput(id) == null, \"Duplicate input %s\", id.getIdName());\n     inputsById.put(id, new CompilerInput(ast));\n   }\n \n    */\n   boolean replaceIncrementalSourceAst(JsAst ast) {\n     CompilerInput oldInput = getInput(ast.getInputId());\n-    Preconditions.checkNotNull(\n-        oldInput,\n-        \"No input to replace: \" + ast.getInputId().getIdName());\n+    Preconditions.checkNotNull(oldInput, \"No input to replace: %s\", ast.getInputId().getIdName());\n     Node newRoot = ast.getAstRoot(this);\n     if (newRoot == null) {\n       return false;\n--- a/src/com/google/javascript/jscomp/DefinitionsRemover.java\n+++ b/src/com/google/javascript/jscomp/DefinitionsRemover.java\n     IncompleteDefinition(Node lValue, boolean inExterns) {\n       super(inExterns);\n       Preconditions.checkNotNull(lValue);\n-      Preconditions.checkArgument(\n-          ALLOWED_TYPES.contains(lValue.getType()),\n-          \"Unexpected lValue type \" + Token.name(lValue.getType()));\n+      Preconditions.checkArgument(ALLOWED_TYPES.contains(lValue.getType()),\n+          \"Unexpected lValue type %s\", Token.name(lValue.getType()));\n       this.lValue = lValue;\n     }\n \n       super(inExterns);\n       Preconditions.checkArgument(NodeUtil.isVarDeclaration(node));\n       Preconditions.checkArgument(node.hasChildren(),\n-          \"VAR Declaration of \" + node.getString() +\n-          \"should be assigned a value.\");\n+          \"VAR Declaration of %sshould be assigned a value.\", node.getString());\n       name = node;\n     }\n \n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n   void setWarningLevel(CompilerOptions options,\n       String name, CheckLevel level) {\n     DiagnosticGroup group = forName(name);\n-    Preconditions.checkNotNull(group, \"No warning class for name: \" + name);\n+    Preconditions.checkNotNull(group, \"No warning class for name: %s\", name);\n     options.setWarningLevel(group, level);\n   }\n }\n--- a/src/com/google/javascript/jscomp/GatherSideEffectSubexpressionsCallback.java\n+++ b/src/com/google/javascript/jscomp/GatherSideEffectSubexpressionsCallback.java\n     public void keepSimplifiedShortCircuitExpression(Node original) {\n       Preconditions.checkArgument(\n           (original.getType() == Token.AND) || (original.getType() == Token.OR),\n-          \"Expected: AND or OR, Got: \" + Token.name(original.getType()));\n+          \"Expected: AND or OR, Got: %s\", Token.name(original.getType()));\n       Node left = original.getFirstChild();\n       Node right = left.getNext();\n       Node simplifiedRight = simplifyShortCircuitBranch(right);\n     public void keepSimplifiedHookExpression(Node hook,\n                                              boolean thenHasSideEffects,\n                                              boolean elseHasSideEffects) {\n-      Preconditions.checkArgument(\n-          hook.getType() == Token.HOOK,\n-          \"Expected: HOOK, Got: \" + Token.name(hook.getType()));\n+      Preconditions.checkArgument(hook.getType() == Token.HOOK,\n+          \"Expected: HOOK, Got: %s\", Token.name(hook.getType()));\n       Node condition = hook.getFirstChild();\n       Node thenBranch = condition.getNext();\n       Node elseBranch = thenBranch.getNext();\n   boolean processShortCircuitExpression(Node node) {\n     Preconditions.checkArgument(\n         (node.getType() == Token.AND) || (node.getType() == Token.OR),\n-        \"Expected: AND or OR, Got: \" + Token.name(node.getType()));\n+        \"Expected: AND or OR, Got: %s\", Token.name(node.getType()));\n \n     // keep whole expression if rhs of the branching expression\n     // contains a call.\n    * @return true to continue traversal, false otherwise\n    */\n   boolean processHook(Node node) {\n-    Preconditions.checkArgument(\n-        node.getType() == Token.HOOK,\n-        \"Expected: HOOK, Got: \" + Token.name(node.getType()));\n+    Preconditions.checkArgument(node.getType() == Token.HOOK,\n+        \"Expected: HOOK, Got: %s\", Token.name(node.getType()));\n \n     Node condition = node.getFirstChild();\n     Node ifBranch = condition.getNext();\n    * @return true to continue traversal, false otherwise\n    */\n   boolean processFunctionCall(Node node) {\n-    Preconditions.checkArgument(\n-        node.getType() == Token.CALL,\n-        \"Expected: CALL, Got: \" + Token.name(node.getType()));\n+    Preconditions.checkArgument(node.getType() == Token.CALL,\n+        \"Expected: CALL, Got: %s\", Token.name(node.getType()));\n \n     // Calls to functions that are known to be \"pure\" have no side\n     // effects.\n    * @return true to continue traversal, false otherwise\n    */\n   boolean processConstructorCall(Node node) {\n-    Preconditions.checkArgument(\n-        node.getType() == Token.NEW,\n-        \"Expected: NEW, Got: \" + Token.name(node.getType()));\n+    Preconditions.checkArgument(node.getType() == Token.NEW,\n+        \"Expected: NEW, Got: %s\", Token.name(node.getType()));\n \n     // Calls to constructors that are known to be \"pure\" have no\n     // side effects.\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n       case Token.VAR:\n         break;\n       case Token.ASSIGN:\n-        Preconditions.checkArgument(\n-            parent.getType() == Token.FOR,\n-            \"Unsupported assignment in replaceWithRhs. parent: \" +\n-            Token.name(parent.getType()));\n+        Preconditions.checkArgument(parent.getType() == Token.FOR,\n+            \"Unsupported assignment in replaceWithRhs. parent: %s\", Token.name(parent.getType()));\n         break;\n       default:\n         throw new IllegalArgumentException(\n--- a/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n       String qNameStr = className + \".prototype.\" +\n           NodeUtil.getPrototypePropertyName(qName);\n       Name prototypeProp = graph.defineNameIfNotExists(qNameStr, isExtern);\n-      Preconditions.checkNotNull(\n-          prototypeProp, qNameStr + \" should be in the name graph as a node.\");\n+      Preconditions.checkNotNull(prototypeProp,\n+          \"%s should be in the name graph as a node.\", qNameStr);\n       if (assign != null) {\n         prototypeProp.addAssignmentDeclaration(assign);\n       }\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n \n           if (expectedConst) {\n             Preconditions.checkState(expectedConst == isConst,\n-                \"The name \" + name + \" is not annotated as constant.\");\n+                \"The name %s is not annotated as constant.\", name);\n           } else {\n             Preconditions.checkState(expectedConst == isConst,\n-                \"The name \" + name + \" should not be annotated as constant.\");\n+                \"The name %s should not be annotated as constant.\", name);\n           }\n         }\n \n           constantMap.put(name, isConst);\n         } else {\n           Preconditions.checkState(value.booleanValue() == isConst,\n-              \"The name \" + name + \" is not consistently annotated as \" +\n-              \"constant.\");\n+              \"The name %s is not consistently annotated as constant.\", name);\n         }\n       }\n     }\n--- a/src/com/google/javascript/jscomp/PassFactory.java\n+++ b/src/com/google/javascript/jscomp/PassFactory.java\n    */\n   final CompilerPass create(AbstractCompiler compiler) {\n     Preconditions.checkState(!isCreated || !isOneTimePass,\n-        \"One-time passes cannot be run multiple times: \" + name);\n+        \"One-time passes cannot be run multiple times: %s\", name);\n     isCreated = true;\n     return createInternal(compiler);\n   }\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n     @Override\n     void addLoopedPass(PassFactory factory) {\n       String name = factory.getName();\n-      Preconditions.checkArgument(\n-          !myNames.contains(name),\n-          \"Already a pass with name '\" + name + \"' in this loop\");\n+      Preconditions.checkArgument(!myNames.contains(name),\n+          \"Already a pass with name '%s' in this loop\", name);\n       myNames.add(factory.getName());\n       myPasses.add(new PassFactoryDelegate(compiler, factory));\n     }\n--- a/src/com/google/javascript/jscomp/graph/LinkedUndirectedGraph.java\n+++ b/src/com/google/javascript/jscomp/graph/LinkedUndirectedGraph.java\n   @Override\n   public Iterator<GraphNode<N, E>> getNeighborNodesIterator(N value) {\n     UndiGraphNode<N, E> uNode = getUndirectedGraphNode(value);\n-    Preconditions.checkNotNull(uNode, value + \" should be in the graph.\");\n+    Preconditions.checkNotNull(uNode, \"%s should be in the graph.\", value);\n     return ((LinkedUndirectedGraphNode<N, E>) uNode).neighborIterator();\n   }\n ", "timestamp": 1320062369, "metainfo": ""}