{"sha": "32c0f8b8b23713431c3866ab5769e735abe3a429", "log": "get rid of old typedef code  R=acleung   Revision created by MOE tool push_codebase. MOE_MIGRATION=2141   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n \n   private static final long serialVersionUID = 1L;\n \n-  private static final String TYPEDEF_NAME = \"goog.typedef\";\n-\n   static final DiagnosticType OBJECTLIT_EXPECTED = DiagnosticType.warning(\n       \"JSC_REFLECT_OBJECTLIT_EXPECTED\",\n       \"Object literal expected as second argument\");\n         return typeNames;\n       }\n     }\n-    return null;\n-  }\n-\n-  @Override\n-  public String identifyTypeDefAssign(Node n) {\n-    Node firstChild = n.getFirstChild();\n-    int type = n.getType();\n-    if (type == Token.ASSIGN) {\n-      if (TYPEDEF_NAME.equals(n.getLastChild().getQualifiedName())) {\n-        return firstChild.getQualifiedName();\n-      }\n-    } else if (type == Token.VAR && firstChild.hasChildren()) {\n-      if (TYPEDEF_NAME.equals(\n-              firstChild.getFirstChild().getQualifiedName())) {\n-        return firstChild.getString();\n-      }\n-    }\n-\n     return null;\n   }\n \n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n   public List<String> identifyTypeDeclarationCall(Node n);\n \n   /**\n-   * Checks if the given ASSIGN node is a typedef, and returns the\n-   * name of the type if it is.\n-   */\n-  public String identifyTypeDefAssign(Node n);\n-\n-  /**\n    * In many JS libraries, the function that produces inheritance also\n    * adds properties to the superclass and/or subclass.\n    */\n--- a/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n   }\n \n   @Override\n-  public String identifyTypeDefAssign(Node n) {\n-    return null;\n-  }\n-\n-  @Override\n   public void applySubclassRelationship(FunctionType parentCtor,\n       FunctionType childCtor, SubclassType type) {\n     // do nothing\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n   static final String DELEGATE_PROXY_SUFFIX =\n       ObjectType.createDelegateSuffix(\"Proxy\");\n \n-  private static final String LEGACY_TYPEDEF = \"goog.typedef\";\n-\n   static final DiagnosticType MALFORMED_TYPEDEF =\n       DiagnosticType.warning(\n           \"JSC_MALFORMED_TYPEDEF\",\n     declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE);\n     declareNativeValueType(s, \"undefined\", VOID_TYPE);\n \n-    // The typedef construct needs the any type, so that it can be assigned\n-    // to anything. This is kind of a hack, and an artifact of the typedef\n-    // syntax we've chosen.\n-    declareNativeValueType(s, LEGACY_TYPEDEF, NO_TYPE);\n-\n     // ActiveXObject is unqiuely special, because it can be used to construct\n     // any type (the type that it creates is related to the arguments you\n     // pass to it).\n           } else if (info.hasTypedefType()) {\n             registry.identifyNonNullableName(nameNode.getQualifiedName());\n           }\n-        }\n-\n-        if (valueNode != null &&\n-            LEGACY_TYPEDEF.equals(valueNode.getQualifiedName())) {\n-          registry.identifyNonNullableName(nameNode.getQualifiedName());\n         }\n       }\n     }\n \n       switch (n.getType()) {\n \n-        case Token.ASSIGN:\n-          // Handle typedefs.\n-          checkForOldStyleTypedef(t, n);\n-          break;\n-\n         case Token.VAR:\n           // Handle typedefs.\n           if (n.hasOneChild()) {\n-            checkForOldStyleTypedef(t, n);\n             checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());\n           }\n           break;\n       if (candidate.getType() == Token.GETPROP) {\n         defineSlot(candidate, candidate.getParent(),\n             getNativeType(NO_TYPE), false);\n-      }\n-    }\n-\n-    /**\n-     * Handle typedefs.\n-     * @param t The current traversal.\n-     * @param candidate An ASSIGN or VAR node.\n-     */\n-    // TODO(nicksantos): Kill this.\n-    private void checkForOldStyleTypedef(NodeTraversal t, Node candidate) {\n-      // old-style typedefs\n-      String typedef = codingConvention.identifyTypeDefAssign(candidate);\n-      if (typedef != null) {\n-        // TODO(nicksantos|user): This is a terrible, terrible hack\n-        // to bail out on recusive typedefs. We'll eventually need\n-        // to handle these properly.\n-        typeRegistry.declareType(typedef, getNativeType(UNKNOWN_TYPE));\n-\n-        JSDocInfo info = candidate.getJSDocInfo();\n-        JSType realType = null;\n-        if (info != null && info.getType() != null) {\n-          realType = info.getType().evaluate(scope, typeRegistry);\n-        }\n-\n-        if (realType == null) {\n-          compiler.report(\n-              JSError.make(\n-                  t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n-        }\n-\n-        typeRegistry.overwriteDeclaredType(typedef, realType);\n-\n-        // Duplicate typedefs get handled when we try to register\n-        // this typedef in the scope.\n       }\n     }\n   } // end GlobalScopeBuilder\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n         \"required: (MyType|null|undefined)\");\n   }\n \n-  public void testMalformedOldTypeDef() throws Exception {\n-    testTypes(\n-        \"var goog = {}; goog.typedef = true;\" +\n-        \"goog.Bar = goog.typedef\",\n-        \"Typedef for goog.Bar does not have any type information\");\n-  }\n-\n-  public void testMalformedOldTypeDef2() throws Exception {\n-    testTypes(\n-        \"var goog = {}; goog.typedef = true;\" +\n-        \"/** @typedef {boolean} */ goog.Bar = goog.typedef\",\n-        \"Typedef for goog.Bar does not have any type information\");\n-  }\n-\n-  public void testDuplicateOldTypeDef() throws Exception {\n-    testTypes(\n-        \"var goog = {}; goog.typedef = true;\" +\n-        \"/** @constructor */ goog.Bar = function() {};\" +\n-        \"/** @type {number} */ goog.Bar = goog.typedef\",\n-        \"variable goog.Bar redefined with type number, \" +\n-        \"original definition at [testcode]:1 \" +\n-        \"with type function (new:goog.Bar): undefined\");\n-  }\n-\n-  public void testOldTypeDef1() throws Exception {\n-    testTypes(\n-        \"var goog = {}; goog.typedef = true;\" +\n-        \"/** @type {number} */ goog.Bar = goog.typedef;\" +\n-        \"/** @param {goog.Bar} x */ function f(x) {}\" +\n-        \"f(3);\");\n-  }\n-\n-  public void testOldTypeDef2() throws Exception {\n-    testTypes(\n-        \"var goog = {}; goog.typedef = true;\" +\n-        \"/** @type {number} */ goog.Bar = goog.typedef;\" +\n-        \"/** @param {goog.Bar} x */ function f(x) {}\" +\n-        \"f('3');\",\n-        \"actual parameter 1 of f does not match formal parameter\\n\" +\n-        \"found   : string\\n\" +\n-        \"required: number\");\n-  }\n-\n-  public void testOldTypeDef3() throws Exception {\n-    testTypes(\n-        \"var goog = {}; goog.typedef = true;\" +\n-        \"/** @type {number} */ var Bar = goog.typedef;\" +\n-        \"/** @param {Bar} x */ function f(x) {}\" +\n-        \"f('3');\",\n-        \"actual parameter 1 of f does not match formal parameter\\n\" +\n-        \"found   : string\\n\" +\n-        \"required: number\");\n-  }\n-\n-  public void testCircularOldTypeDef() throws Exception {\n-    testTypes(\n-        \"var goog = {}; goog.typedef = true;\" +\n-        \"/** @type {number|Array.<goog.Bar>} */ goog.Bar = goog.typedef;\" +\n-        \"/** @param {goog.Bar} x */ function f(x) {}\" +\n-        \"f(3); f([3]); f([[3]]);\");\n-  }\n-\n   public void testDuplicateTypeDef() throws Exception {\n     testTypes(\n         \"var goog = {};\" +\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n     testTypes(\n         \"/** @return {MyTypedef} */ function f() { return null; }\" +\n         \"/** @typedef {string} */ var MyTypedef;\",\n-        \"inconsistent return type\\n\" +\n-        \"found   : null\\n\" +\n-        \"required: string\");\n-  }\n-\n-  public void testBackwardsTypedefUse5() throws Exception {\n-    testTypes(\n-        \"/** @return {MyTypedef} */ function f() { return null; }\" +\n-        \"/** @type {string} */ var MyTypedef = goog.typedef;\",\n         \"inconsistent return type\\n\" +\n         \"found   : null\\n\" +\n         \"required: string\");\n         \"required: (MyType|null|number)\");\n   }\n \n-  public void testMalformedOldTypeDef() throws Exception {\n-    testTypes(\n-        \"var goog = {}; goog.typedef = true;\" +\n-        \"goog.Bar = goog.typedef\",\n-        \"Typedef for goog.Bar does not have any type information\");\n-  }\n-\n-  public void testMalformedOldTypeDef2() throws Exception {\n-    testTypes(\n-        \"var goog = {}; goog.typedef = true;\" +\n-        \"/** @typedef {boolean} */ goog.Bar = goog.typedef\",\n-        \"Typedef for goog.Bar does not have any type information\");\n-  }\n-\n-  public void testDuplicateOldTypeDef() throws Exception {\n-    testTypes(\n-        \"var goog = {}; goog.typedef = true;\" +\n-        \"/** @constructor */ goog.Bar = function() {};\" +\n-        \"/** @type {number} */ goog.Bar = goog.typedef\",\n-        \"variable goog.Bar redefined with type number, \" +\n-        \"original definition at [testcode]:1 \" +\n-        \"with type function (new:goog.Bar): undefined\");\n-  }\n-\n-  public void testOldTypeDef1() throws Exception {\n-    testTypes(\n-        \"var goog = {}; goog.typedef = true;\" +\n-        \"/** @type {number} */ goog.Bar = goog.typedef;\" +\n-        \"/** @param {goog.Bar} x */ function f(x) {}\" +\n-        \"f(3);\");\n-  }\n-\n-  public void testOldTypeDef2() throws Exception {\n-    testTypes(\n-        \"var goog = {}; goog.typedef = true;\" +\n-        \"/** @type {number} */ goog.Bar = goog.typedef;\" +\n-        \"/** @param {goog.Bar} x */ function f(x) {}\" +\n-        \"f('3');\",\n-        \"actual parameter 1 of f does not match formal parameter\\n\" +\n-        \"found   : string\\n\" +\n-        \"required: number\");\n-  }\n-\n-  public void testOldTypeDef3() throws Exception {\n-    testTypes(\n-        \"var goog = {}; goog.typedef = true;\" +\n-        \"/** @type {number} */ var Bar = goog.typedef;\" +\n-        \"/** @param {Bar} x */ function f(x) {}\" +\n-        \"f('3');\",\n-        \"actual parameter 1 of f does not match formal parameter\\n\" +\n-        \"found   : string\\n\" +\n-        \"required: number\");\n-  }\n-\n-  public void testCircularOldTypeDef() throws Exception {\n-    testTypes(\n-        \"var goog = {}; goog.typedef = true;\" +\n-        \"/** @type {number|Array.<goog.Bar>} */ goog.Bar = goog.typedef;\" +\n-        \"/** @param {goog.Bar} x */ function f(x) {}\" +\n-        \"f(3); f([3]); f([[3]]);\");\n-  }\n-\n   public void testDuplicateTypeDef() throws Exception {\n     testTypes(\n         \"var goog = {};\" +", "timestamp": 1306960878, "metainfo": ""}