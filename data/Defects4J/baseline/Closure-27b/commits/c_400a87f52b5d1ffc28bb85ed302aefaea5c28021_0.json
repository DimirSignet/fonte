{"sha": "400a87f52b5d1ffc28bb85ed302aefaea5c28021", "log": "Make sure that a function and its prototype are declared in the same place  R=johnlenz DELTA=56  (30 added, 2 deleted, 24 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3693   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n-import com.google.javascript.rhino.jstype.StaticSlot;\n \n import java.util.Iterator;\n import java.util.List;\n               !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n             // Declare var.prototype in the scope chain.\n             FunctionType superClassCtor = fnType.getSuperClassConstructor();\n-            StaticSlot<JSType> prototypeSlot = fnType.getSlot(\"prototype\");\n+            ObjectType.Property prototypeSlot = fnType.getSlot(\"prototype\");\n \n             String prototypeName = variableName + \".prototype\";\n \n             // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n             // Fortunately, other warnings will complain if this happens.\n             if (scopeToDeclareIn.getOwnSlot(prototypeName) == null) {\n-              // It's not really important what node we declare the prototype\n-              // at. It's more important that the Var node is consistent with\n-              // the node that the type system uses internally.\n-              Node prototypeNode = n;\n-              if (prototypeSlot.getDeclaration() != null) {\n-                prototypeNode = prototypeSlot.getDeclaration().getNode();\n-              }\n+              // When we declare the function prototype implicitly, we\n+              // want to make sure that the function and its prototype\n+              // are declared at the same node. We also want to make sure\n+              // that the if a symbol has both a Var and a JSType, they have\n+              // the same node.\n+              //\n+              // This consistency is helpful to users of SymbolTable,\n+              // because everything gets declared at the same place.\n+              prototypeSlot.setNode(n);\n \n               scopeToDeclareIn.declare(prototypeName,\n-                  prototypeNode, prototypeSlot.getType(), input,\n+                  n, prototypeSlot.getType(), input,\n                   /* declared iff there's an explicit supertype */\n                   superClassCtor == null ||\n                   superClassCtor.getInstanceType().equals(\n--- a/src/com/google/javascript/rhino/jstype/EnumElementType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumElementType.java\n   }\n \n   @Override\n-  public StaticSlot<JSType> getSlot(String name) {\n+  public Property getSlot(String name) {\n     if (primitiveObjectType != null) {\n       return primitiveObjectType.getSlot(name);\n     }\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n   }\n \n   @Override\n-  public StaticSlot<JSType> getSlot(String name) {\n+  public Property getSlot(String name) {\n     if (\"prototype\".equals(name)) {\n       // Lazy initialization of the prototype field.\n       getPrototype();\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n   }\n \n   @Override\n-  public abstract StaticSlot<JSType> getSlot(String name);\n-\n-  @Override\n-  public StaticSlot<JSType> getOwnSlot(String name) {\n+  public abstract Property getSlot(String name);\n+\n+  @Override\n+  public Property getOwnSlot(String name) {\n     if (hasOwnProperty(name)) {\n       return getSlot(name);\n     }\n     return ImmutableSet.of();\n   }\n \n-  static final class Property\n+  public static final class Property\n       implements Serializable, StaticSlot<JSType>, StaticReference<JSType> {\n     private static final long serialVersionUID = 1L;\n \n      * The node corresponding to this property, e.g., a GETPROP node that\n      * declares this property.\n      */\n-    private final Node propertyNode;\n+    private Node propertyNode;\n \n     /**  The JSDocInfo for this property. */\n     private JSDocInfo docInfo = null;\n     void setJSDocInfo(JSDocInfo info) {\n       this.docInfo = info;\n     }\n+\n+    public void setNode(Node n) {\n+      this.propertyNode = n;\n+    }\n   }\n }\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n   }\n \n   @Override\n-  public StaticSlot<JSType> getSlot(String name) {\n+  public Property getSlot(String name) {\n     if (properties.containsKey(name)) {\n       return properties.get(name);\n     }\n     ObjectType implicitPrototype = getImplicitPrototype();\n     if (implicitPrototype != null) {\n-      StaticSlot<JSType> prop = implicitPrototype.getSlot(name);\n+      Property prop = implicitPrototype.getSlot(name);\n       if (prop != null) {\n         return prop;\n       }\n     }\n     for (ObjectType interfaceType : getCtorExtendedInterfaces()) {\n-      StaticSlot<JSType> prop = interfaceType.getSlot(name);\n+      Property prop = interfaceType.getSlot(name);\n       if (prop != null) {\n         return prop;\n       }\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n   }\n \n   @Override\n-  public StaticSlot<JSType> getSlot(String name) {\n+  public Property getSlot(String name) {\n     if (referencedObjType != null) {\n       return referencedObjType.getSlot(name);\n     }\n--- a/src/com/google/javascript/rhino/jstype/UnknownType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnknownType.java\n   }\n \n   @Override\n-  public StaticSlot<JSType> getSlot(String name) {\n+  public Property getSlot(String name) {\n     return null;\n   }\n \n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     Symbol fooPrototype = getGlobalVar(table, \"Foo.prototype\");\n     assertNotNull(fooPrototype);\n \n-    List<Reference> refs = Lists.newArrayList(\n-        table.getReferences(fooPrototype));\n+    List<Reference> refs = table.getReferenceList(fooPrototype);\n     assertEquals(1, refs.size());\n-    assertEquals(Token.FUNCTION, refs.get(0).getNode().getType());\n+    assertEquals(Token.NAME, refs.get(0).getNode().getType());\n+\n+    // Make sure that the ctor and its prototype are declared at the\n+    // same node.\n+    assertEquals(\n+        refs.get(0).getNode(),\n+        table.getReferenceList(getGlobalVar(table, \"Foo\")).get(0).getNode());\n   }\n \n   public void testPrototypeReferences4() throws Exception {\n     assertEquals(1, refs.size());\n     assertEquals(Token.GETPROP, refs.get(0).getNode().getType());\n     assertEquals(\"Foo.prototype\", refs.get(0).getNode().getQualifiedName());\n+  }\n+\n+  public void testPrototypeReferences5() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"var goog = {}; /** @constructor */ goog.Foo = function() {};\");\n+    Symbol fooPrototype = getGlobalVar(table, \"goog.Foo.prototype\");\n+    assertNotNull(fooPrototype);\n+\n+    List<Reference> refs = table.getReferenceList(fooPrototype);\n+    assertEquals(1, refs.size());\n+    assertEquals(Token.GETPROP, refs.get(0).getNode().getType());\n+\n+    // Make sure that the ctor and its prototype are declared at the\n+    // same node.\n+    assertEquals(\n+        refs.get(0).getNode(),\n+        table.getReferenceList(\n+            getGlobalVar(table, \"goog.Foo\")).get(0).getNode());\n   }\n \n   public void testReferencesInJSDocType() {", "timestamp": 1321034077, "metainfo": ""}