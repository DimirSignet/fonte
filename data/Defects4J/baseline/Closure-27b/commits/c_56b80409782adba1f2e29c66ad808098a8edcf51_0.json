{"sha": "56b80409782adba1f2e29c66ad808098a8edcf51", "log": "Make sure that all scopes are always declared in the symbol table.  R=acleung DELTA=57  (51 added, 6 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3613   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     if (typedScopeCreator != null) {\n       symbolTable.addScopes(typedScopeCreator.getAllMemoizedScopes());\n       symbolTable.addSymbolsFrom(typedScopeCreator);\n+    } else {\n+      symbolTable.findScopes(this, externsRoot, jsRoot);\n     }\n \n     GlobalNamespace globalNamespace =\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n     }\n   }\n \n+  /** Finds all the scopes and adds them to this symbol table. */\n+  void findScopes(AbstractCompiler compiler, Node externs, Node root) {\n+    NodeTraversal.traverseRoots(\n+        compiler,\n+        Lists.newArrayList(externs, root),\n+        new NodeTraversal.AbstractScopedCallback() {\n+          @Override\n+          public void enterScope(NodeTraversal t) {\n+            createScopeFrom(t.getScope());\n+          }\n+\n+          @Override\n+          public void visit(NodeTraversal t, Node n, Node p) {}\n+        });\n+  }\n+\n   /** Gets all the scopes in this symbol table. */\n   public Collection<SymbolScope> getAllScopes() {\n     return Collections.unmodifiableCollection(scopes.values());\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n \n   private static final String EXTERNS = CompilerTypeTestCase.DEFAULT_EXTERNS +\n       \"\\nfunction customExternFn(customExternArg) {}\";\n+\n+  private CompilerOptions options;\n+\n+  public void setUp() throws Exception {\n+    super.setUp();\n+\n+    options = new CompilerOptions();\n+    options.setCodingConvention(new ClosureCodingConvention());\n+    CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(\n+        options);\n+    WarningLevel.VERBOSE.setOptionsForWarningLevel(options);\n+    options.ideMode = true;\n+  }\n \n   public void testGlobalVar() throws Exception {\n     SymbolTable table = createSymbolTable(\n     assertEquals(1, table.getReferenceList(sym).size());\n   }\n \n+  public void testTypeCheckingOff() {\n+    options = new CompilerOptions();\n+\n+    // Turning type-checking off is even worse than not annotating anything.\n+    SymbolTable table = createSymbolTable(\n+        \"/** @contstructor */\" +\n+        \"function F() {\" +\n+        \"  this.field1 = 3;\" +\n+        \"}\" +\n+        \"F.prototype.method1 = function() {\" +\n+        \"  this.field1 = 5;\" +\n+        \"};\" +\n+        \"(new F()).method1();\");\n+    assertNull(getGlobalVar(table, \"F.prototype.field1\"));\n+    assertNull(getGlobalVar(table, \"F.prototype.method1\"));\n+\n+    Symbol sym = getGlobalVar(table, \"F\");\n+    assertEquals(3, table.getReferenceList(sym).size());\n+  }\n+\n   private void assertSymmetricOrdering(\n       Ordering<Symbol> ordering, Symbol first, Symbol second) {\n     assertTrue(ordering.compare(first, first) == 0);\n         JSSourceFile.fromCode(\"in1\", input));\n     List<JSSourceFile> externs = Lists.newArrayList(\n         JSSourceFile.fromCode(\"externs1\", EXTERNS));\n-    CompilerOptions options = new CompilerOptions();\n-    options.setCodingConvention(new ClosureCodingConvention());\n-    CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(\n-        options);\n-    WarningLevel.VERBOSE.setOptionsForWarningLevel(options);\n-    options.ideMode = true;\n \n     Compiler compiler = new Compiler();\n     compiler.compile(externs, inputs, options);", "timestamp": 1320335326, "metainfo": ""}