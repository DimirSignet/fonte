{"sha": "e829dafb9b3365bda6b6bb80f5fa97783752d143", "log": "Change on 2010/06/17 by nicksantos          don't use Sets to build union types.          R=johnlenz         DELTA=76  (52 added, 6 deleted, 18 changed)  Change on 2010/06/17 by nicksantos          fix a couple bugs in goog.scope processing          R=robbyw         DELTA=54  (42 added, 11 deleted, 1 changed)   Change on 2010/06/17 by acleung          Disables function argument check with @notypecheck is on for the whole file.          R=johnlenz         DELTA=8  (5 added, 1 deleted, 2 changed)  Change on 2010/06/17 by dcc          Fix NPE in ExportExternsPass with --check_types=false.          R=acleung         DELTA=72  (66 added, 4 deleted, 2 changed)  Change on 2010/06/17 by johnlenz          Change stub method parameters to allow sanity checks to pass with         CrossModuleMethodMotion.          R=nicksantos         DELTA=7  (3 added, 0 deleted, 4 changed)  Change on 2010/06/18 by johnlenz          Modify AliasKeywords so passes the sanity checks: don't create coding         convention constants without annotation them so that the tests pass         when the sanity checks are on.          R=nicksantos         DELTA=18  (5 added, 0 deleted, 13 changed)  Change on 2010/06/18 by johnlenz          Fix source maps when run with sanity checks.          R=nicksantos         DELTA=10  (7 added, 0 deleted, 3 changed)  Change on 2010/06/18 by johnlenz          Changes to PrepareAst to make it valid to run during SanityChecks.          R=nicksantos         DELTA=18  (5 added, 0 deleted, 13 changed)  Change on 2010/06/18 by nicksantos          fix constant annotations in CollapseProperties.          R=johnlenz         DELTA=61  (49 added, 1 deleted, 11 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=30002   ", "commit": "\n--- a/gen/com/google/javascript/jscomp/FunctionInformationMap.java\n+++ b/gen/com/google/javascript/jscomp/FunctionInformationMap.java\n public  final class FunctionInformationMap extends\n     com.google.protobuf.GeneratedMessage {\n   // Use FunctionInformationMap.newBuilder() to construct.\n-  private FunctionInformationMap() {\n-    initFields();\n+  private FunctionInformationMap(Builder builder) {\n+    super(builder);\n   }\n   private FunctionInformationMap(boolean noInit) {}\n   \n   public static final class Entry extends\n       com.google.protobuf.GeneratedMessage {\n     // Use Entry.newBuilder() to construct.\n-    private Entry() {\n-      initFields();\n+    private Entry(Builder builder) {\n+      super(builder);\n     }\n     private Entry(boolean noInit) {}\n     \n     // required int32 id = 2;\n     public static final int ID_FIELD_NUMBER = 2;\n     private boolean hasId;\n-    private int id_ = 0;\n+    private int id_;\n     public boolean hasId() {\n       return hasId;\n     }\n     // required string source_name = 3;\n     public static final int SOURCE_NAME_FIELD_NUMBER = 3;\n     private boolean hasSourceName;\n-    private java.lang.String sourceName_ = \"\";\n+    private java.lang.String sourceName_;\n     public boolean hasSourceName() {\n       return hasSourceName;\n     }\n     // required int32 line_number = 4;\n     public static final int LINE_NUMBER_FIELD_NUMBER = 4;\n     private boolean hasLineNumber;\n-    private int lineNumber_ = 0;\n+    private int lineNumber_;\n     public boolean hasLineNumber() {\n       return hasLineNumber;\n     }\n     // required string module_name = 5;\n     public static final int MODULE_NAME_FIELD_NUMBER = 5;\n     private boolean hasModuleName;\n-    private java.lang.String moduleName_ = \"\";\n+    private java.lang.String moduleName_;\n     public boolean hasModuleName() {\n       return hasModuleName;\n     }\n     // required int32 size = 6;\n     public static final int SIZE_FIELD_NUMBER = 6;\n     private boolean hasSize;\n-    private int size_ = 0;\n+    private int size_;\n     public boolean hasSize() {\n       return hasSize;\n     }\n     // required string name = 7;\n     public static final int NAME_FIELD_NUMBER = 7;\n     private boolean hasName;\n-    private java.lang.String name_ = \"\";\n+    private java.lang.String name_;\n     public boolean hasName() {\n       return hasName;\n     }\n     // required string compiled_source = 8;\n     public static final int COMPILED_SOURCE_FIELD_NUMBER = 8;\n     private boolean hasCompiledSource;\n-    private java.lang.String compiledSource_ = \"\";\n+    private java.lang.String compiledSource_;\n     public boolean hasCompiledSource() {\n       return hasCompiledSource;\n     }\n     }\n     \n     private void initFields() {\n+      id_ = 0;\n+      sourceName_ = \"\";\n+      lineNumber_ = 0;\n+      moduleName_ = \"\";\n+      size_ = 0;\n+      name_ = \"\";\n+      compiledSource_ = \"\";\n     }\n     public final boolean isInitialized() {\n       if (!hasId) return false;\n     \n     public static final class Builder extends\n         com.google.protobuf.GeneratedMessage.Builder<Builder> {\n-      private com.google.javascript.jscomp.FunctionInformationMap.Entry result;\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return com.google.javascript.jscomp.FunctionInfo.internal_static_jscomp_FunctionInformationMap_Entry_descriptor;\n+      }\n+      \n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return com.google.javascript.jscomp.FunctionInfo.internal_static_jscomp_FunctionInformationMap_Entry_fieldAccessorTable;\n+      }\n       \n       // Construct using com.google.javascript.jscomp.FunctionInformationMap.Entry.newBuilder()\n-      private Builder() {}\n+      private Builder() {\n+      }\n       \n       private static Builder create() {\n-        Builder builder = new Builder();\n-        builder.result = new com.google.javascript.jscomp.FunctionInformationMap.Entry();\n-        return builder;\n-      }\n-      \n-      protected com.google.javascript.jscomp.FunctionInformationMap.Entry internalGetResult() {\n-        return result;\n+        return new Builder();\n       }\n       \n       public Builder clear() {\n-        if (result == null) {\n-          throw new IllegalStateException(\n-            \"Cannot call clear() after build().\");\n-        }\n-        result = new com.google.javascript.jscomp.FunctionInformationMap.Entry();\n+        super.clear();\n+        id_ = 0;\n+        hasId = false;\n+        sourceName_ = \"\";\n+        hasSourceName = false;\n+        lineNumber_ = 0;\n+        hasLineNumber = false;\n+        moduleName_ = \"\";\n+        hasModuleName = false;\n+        size_ = 0;\n+        hasSize = false;\n+        name_ = \"\";\n+        hasName = false;\n+        compiledSource_ = \"\";\n+        hasCompiledSource = false;\n         return this;\n       }\n       \n       public Builder clone() {\n-        return create().mergeFrom(result);\n+        return create().mergeFrom(buildPartial());\n       }\n       \n       public com.google.protobuf.Descriptors.Descriptor\n         return com.google.javascript.jscomp.FunctionInformationMap.Entry.getDefaultInstance();\n       }\n       \n-      public boolean isInitialized() {\n-        return result.isInitialized();\n-      }\n       public com.google.javascript.jscomp.FunctionInformationMap.Entry build() {\n-        if (result != null && !isInitialized()) {\n+        com.google.javascript.jscomp.FunctionInformationMap.Entry result = buildPartial();\n+        if (!result.isInitialized()) {\n           throw newUninitializedMessageException(result);\n         }\n-        return buildPartial();\n+        return result;\n       }\n       \n       private com.google.javascript.jscomp.FunctionInformationMap.Entry buildParsed()\n           throws com.google.protobuf.InvalidProtocolBufferException {\n-        if (!isInitialized()) {\n+        com.google.javascript.jscomp.FunctionInformationMap.Entry result = buildPartial();\n+        if (!result.isInitialized()) {\n           throw newUninitializedMessageException(\n             result).asInvalidProtocolBufferException();\n         }\n-        return buildPartial();\n+        return result;\n       }\n       \n       public com.google.javascript.jscomp.FunctionInformationMap.Entry buildPartial() {\n-        if (result == null) {\n-          throw new IllegalStateException(\n-            \"build() has already been called on this Builder.\");\n-        }\n-        com.google.javascript.jscomp.FunctionInformationMap.Entry returnMe = result;\n-        result = null;\n-        return returnMe;\n+        com.google.javascript.jscomp.FunctionInformationMap.Entry result = new com.google.javascript.jscomp.FunctionInformationMap.Entry(this);\n+        result.hasId = hasId;\n+        result.id_ = id_;\n+        result.hasSourceName = hasSourceName;\n+        result.sourceName_ = sourceName_;\n+        result.hasLineNumber = hasLineNumber;\n+        result.lineNumber_ = lineNumber_;\n+        result.hasModuleName = hasModuleName;\n+        result.moduleName_ = moduleName_;\n+        result.hasSize = hasSize;\n+        result.size_ = size_;\n+        result.hasName = hasName;\n+        result.name_ = name_;\n+        result.hasCompiledSource = hasCompiledSource;\n+        result.compiledSource_ = compiledSource_;\n+        return result;\n       }\n       \n       public Builder mergeFrom(com.google.protobuf.Message other) {\n         }\n         this.mergeUnknownFields(other.getUnknownFields());\n         return this;\n+      }\n+      \n+      public final boolean isInitialized() {\n+        if (!hasId) return false;\n+        if (!hasSourceName) return false;\n+        if (!hasLineNumber) return false;\n+        if (!hasModuleName) return false;\n+        if (!hasSize) return false;\n+        if (!hasName) return false;\n+        if (!hasCompiledSource) return false;\n+        return true;\n       }\n       \n       public Builder mergeFrom(\n       \n       \n       // required int32 id = 2;\n+      private boolean hasId;\n+      private int id_ ;\n       public boolean hasId() {\n-        return result.hasId();\n+        return hasId;\n       }\n       public int getId() {\n-        return result.getId();\n+        return id_;\n       }\n       public Builder setId(int value) {\n-        result.hasId = true;\n-        result.id_ = value;\n+        hasId = true;\n+        id_ = value;\n         return this;\n       }\n       public Builder clearId() {\n-        result.hasId = false;\n-        result.id_ = 0;\n+        hasId = false;\n+        id_ = 0;\n         return this;\n       }\n       \n       // required string source_name = 3;\n+      private boolean hasSourceName;\n+      private java.lang.String sourceName_ = \"\";\n       public boolean hasSourceName() {\n-        return result.hasSourceName();\n+        return hasSourceName;\n       }\n       public java.lang.String getSourceName() {\n-        return result.getSourceName();\n+        return sourceName_;\n       }\n       public Builder setSourceName(java.lang.String value) {\n         if (value == null) {\n     throw new NullPointerException();\n   }\n-  result.hasSourceName = true;\n-        result.sourceName_ = value;\n+  hasSourceName = true;\n+        sourceName_ = value;\n         return this;\n       }\n       public Builder clearSourceName() {\n-        result.hasSourceName = false;\n-        result.sourceName_ = getDefaultInstance().getSourceName();\n+        hasSourceName = false;\n+        sourceName_ = getDefaultInstance().getSourceName();\n         return this;\n       }\n       \n       // required int32 line_number = 4;\n+      private boolean hasLineNumber;\n+      private int lineNumber_ ;\n       public boolean hasLineNumber() {\n-        return result.hasLineNumber();\n+        return hasLineNumber;\n       }\n       public int getLineNumber() {\n-        return result.getLineNumber();\n+        return lineNumber_;\n       }\n       public Builder setLineNumber(int value) {\n-        result.hasLineNumber = true;\n-        result.lineNumber_ = value;\n+        hasLineNumber = true;\n+        lineNumber_ = value;\n         return this;\n       }\n       public Builder clearLineNumber() {\n-        result.hasLineNumber = false;\n-        result.lineNumber_ = 0;\n+        hasLineNumber = false;\n+        lineNumber_ = 0;\n         return this;\n       }\n       \n       // required string module_name = 5;\n+      private boolean hasModuleName;\n+      private java.lang.String moduleName_ = \"\";\n       public boolean hasModuleName() {\n-        return result.hasModuleName();\n+        return hasModuleName;\n       }\n       public java.lang.String getModuleName() {\n-        return result.getModuleName();\n+        return moduleName_;\n       }\n       public Builder setModuleName(java.lang.String value) {\n         if (value == null) {\n     throw new NullPointerException();\n   }\n-  result.hasModuleName = true;\n-        result.moduleName_ = value;\n+  hasModuleName = true;\n+        moduleName_ = value;\n         return this;\n       }\n       public Builder clearModuleName() {\n-        result.hasModuleName = false;\n-        result.moduleName_ = getDefaultInstance().getModuleName();\n+        hasModuleName = false;\n+        moduleName_ = getDefaultInstance().getModuleName();\n         return this;\n       }\n       \n       // required int32 size = 6;\n+      private boolean hasSize;\n+      private int size_ ;\n       public boolean hasSize() {\n-        return result.hasSize();\n+        return hasSize;\n       }\n       public int getSize() {\n-        return result.getSize();\n+        return size_;\n       }\n       public Builder setSize(int value) {\n-        result.hasSize = true;\n-        result.size_ = value;\n+        hasSize = true;\n+        size_ = value;\n         return this;\n       }\n       public Builder clearSize() {\n-        result.hasSize = false;\n-        result.size_ = 0;\n+        hasSize = false;\n+        size_ = 0;\n         return this;\n       }\n       \n       // required string name = 7;\n+      private boolean hasName;\n+      private java.lang.String name_ = \"\";\n       public boolean hasName() {\n-        return result.hasName();\n+        return hasName;\n       }\n       public java.lang.String getName() {\n-        return result.getName();\n+        return name_;\n       }\n       public Builder setName(java.lang.String value) {\n         if (value == null) {\n     throw new NullPointerException();\n   }\n-  result.hasName = true;\n-        result.name_ = value;\n+  hasName = true;\n+        name_ = value;\n         return this;\n       }\n       public Builder clearName() {\n-        result.hasName = false;\n-        result.name_ = getDefaultInstance().getName();\n+        hasName = false;\n+        name_ = getDefaultInstance().getName();\n         return this;\n       }\n       \n       // required string compiled_source = 8;\n+      private boolean hasCompiledSource;\n+      private java.lang.String compiledSource_ = \"\";\n       public boolean hasCompiledSource() {\n-        return result.hasCompiledSource();\n+        return hasCompiledSource;\n       }\n       public java.lang.String getCompiledSource() {\n-        return result.getCompiledSource();\n+        return compiledSource_;\n       }\n       public Builder setCompiledSource(java.lang.String value) {\n         if (value == null) {\n     throw new NullPointerException();\n   }\n-  result.hasCompiledSource = true;\n-        result.compiledSource_ = value;\n+  hasCompiledSource = true;\n+        compiledSource_ = value;\n         return this;\n       }\n       public Builder clearCompiledSource() {\n-        result.hasCompiledSource = false;\n-        result.compiledSource_ = getDefaultInstance().getCompiledSource();\n+        hasCompiledSource = false;\n+        compiledSource_ = getDefaultInstance().getCompiledSource();\n         return this;\n       }\n       \n   public static final class Module extends\n       com.google.protobuf.GeneratedMessage {\n     // Use Module.newBuilder() to construct.\n-    private Module() {\n-      initFields();\n+    private Module(Builder builder) {\n+      super(builder);\n     }\n     private Module(boolean noInit) {}\n     \n     // required string name = 102;\n     public static final int NAME_FIELD_NUMBER = 102;\n     private boolean hasName;\n-    private java.lang.String name_ = \"\";\n+    private java.lang.String name_;\n     public boolean hasName() {\n       return hasName;\n     }\n     // required string compiled_source = 103;\n     public static final int COMPILED_SOURCE_FIELD_NUMBER = 103;\n     private boolean hasCompiledSource;\n-    private java.lang.String compiledSource_ = \"\";\n+    private java.lang.String compiledSource_;\n     public boolean hasCompiledSource() {\n       return hasCompiledSource;\n     }\n     }\n     \n     private void initFields() {\n+      name_ = \"\";\n+      compiledSource_ = \"\";\n     }\n     public final boolean isInitialized() {\n       if (!hasName) return false;\n     \n     public static final class Builder extends\n         com.google.protobuf.GeneratedMessage.Builder<Builder> {\n-      private com.google.javascript.jscomp.FunctionInformationMap.Module result;\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return com.google.javascript.jscomp.FunctionInfo.internal_static_jscomp_FunctionInformationMap_Module_descriptor;\n+      }\n+      \n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return com.google.javascript.jscomp.FunctionInfo.internal_static_jscomp_FunctionInformationMap_Module_fieldAccessorTable;\n+      }\n       \n       // Construct using com.google.javascript.jscomp.FunctionInformationMap.Module.newBuilder()\n-      private Builder() {}\n+      private Builder() {\n+      }\n       \n       private static Builder create() {\n-        Builder builder = new Builder();\n-        builder.result = new com.google.javascript.jscomp.FunctionInformationMap.Module();\n-        return builder;\n-      }\n-      \n-      protected com.google.javascript.jscomp.FunctionInformationMap.Module internalGetResult() {\n-        return result;\n+        return new Builder();\n       }\n       \n       public Builder clear() {\n-        if (result == null) {\n-          throw new IllegalStateException(\n-            \"Cannot call clear() after build().\");\n-        }\n-        result = new com.google.javascript.jscomp.FunctionInformationMap.Module();\n+        super.clear();\n+        name_ = \"\";\n+        hasName = false;\n+        compiledSource_ = \"\";\n+        hasCompiledSource = false;\n         return this;\n       }\n       \n       public Builder clone() {\n-        return create().mergeFrom(result);\n+        return create().mergeFrom(buildPartial());\n       }\n       \n       public com.google.protobuf.Descriptors.Descriptor\n         return com.google.javascript.jscomp.FunctionInformationMap.Module.getDefaultInstance();\n       }\n       \n-      public boolean isInitialized() {\n-        return result.isInitialized();\n-      }\n       public com.google.javascript.jscomp.FunctionInformationMap.Module build() {\n-        if (result != null && !isInitialized()) {\n+        com.google.javascript.jscomp.FunctionInformationMap.Module result = buildPartial();\n+        if (!result.isInitialized()) {\n           throw newUninitializedMessageException(result);\n         }\n-        return buildPartial();\n+        return result;\n       }\n       \n       private com.google.javascript.jscomp.FunctionInformationMap.Module buildParsed()\n           throws com.google.protobuf.InvalidProtocolBufferException {\n-        if (!isInitialized()) {\n+        com.google.javascript.jscomp.FunctionInformationMap.Module result = buildPartial();\n+        if (!result.isInitialized()) {\n           throw newUninitializedMessageException(\n             result).asInvalidProtocolBufferException();\n         }\n-        return buildPartial();\n+        return result;\n       }\n       \n       public com.google.javascript.jscomp.FunctionInformationMap.Module buildPartial() {\n-        if (result == null) {\n-          throw new IllegalStateException(\n-            \"build() has already been called on this Builder.\");\n-        }\n-        com.google.javascript.jscomp.FunctionInformationMap.Module returnMe = result;\n-        result = null;\n-        return returnMe;\n+        com.google.javascript.jscomp.FunctionInformationMap.Module result = new com.google.javascript.jscomp.FunctionInformationMap.Module(this);\n+        result.hasName = hasName;\n+        result.name_ = name_;\n+        result.hasCompiledSource = hasCompiledSource;\n+        result.compiledSource_ = compiledSource_;\n+        return result;\n       }\n       \n       public Builder mergeFrom(com.google.protobuf.Message other) {\n         }\n         this.mergeUnknownFields(other.getUnknownFields());\n         return this;\n+      }\n+      \n+      public final boolean isInitialized() {\n+        if (!hasName) return false;\n+        if (!hasCompiledSource) return false;\n+        return true;\n       }\n       \n       public Builder mergeFrom(\n       \n       \n       // required string name = 102;\n+      private boolean hasName;\n+      private java.lang.String name_ = \"\";\n       public boolean hasName() {\n-        return result.hasName();\n+        return hasName;\n       }\n       public java.lang.String getName() {\n-        return result.getName();\n+        return name_;\n       }\n       public Builder setName(java.lang.String value) {\n         if (value == null) {\n     throw new NullPointerException();\n   }\n-  result.hasName = true;\n-        result.name_ = value;\n+  hasName = true;\n+        name_ = value;\n         return this;\n       }\n       public Builder clearName() {\n-        result.hasName = false;\n-        result.name_ = getDefaultInstance().getName();\n+        hasName = false;\n+        name_ = getDefaultInstance().getName();\n         return this;\n       }\n       \n       // required string compiled_source = 103;\n+      private boolean hasCompiledSource;\n+      private java.lang.String compiledSource_ = \"\";\n       public boolean hasCompiledSource() {\n-        return result.hasCompiledSource();\n+        return hasCompiledSource;\n       }\n       public java.lang.String getCompiledSource() {\n-        return result.getCompiledSource();\n+        return compiledSource_;\n       }\n       public Builder setCompiledSource(java.lang.String value) {\n         if (value == null) {\n     throw new NullPointerException();\n   }\n-  result.hasCompiledSource = true;\n-        result.compiledSource_ = value;\n+  hasCompiledSource = true;\n+        compiledSource_ = value;\n         return this;\n       }\n       public Builder clearCompiledSource() {\n-        result.hasCompiledSource = false;\n-        result.compiledSource_ = getDefaultInstance().getCompiledSource();\n+        hasCompiledSource = false;\n+        compiledSource_ = getDefaultInstance().getCompiledSource();\n         return this;\n       }\n       \n   \n   // repeated group Entry = 1 {\n   public static final int ENTRY_FIELD_NUMBER = 1;\n-  private java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Entry> entry_ =\n-    java.util.Collections.emptyList();\n+  private java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Entry> entry_;\n   public java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Entry> getEntryList() {\n     return entry_;\n   }\n   \n   // repeated group Module = 101 {\n   public static final int MODULE_FIELD_NUMBER = 101;\n-  private java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Module> module_ =\n-    java.util.Collections.emptyList();\n+  private java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Module> module_;\n   public java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Module> getModuleList() {\n     return module_;\n   }\n   }\n   \n   private void initFields() {\n+    entry_ = java.util.Collections.emptyList();\n+    module_ = java.util.Collections.emptyList();\n   }\n   public final boolean isInitialized() {\n     for (com.google.javascript.jscomp.FunctionInformationMap.Entry element : getEntryList()) {\n   \n   public static final class Builder extends\n       com.google.protobuf.GeneratedMessage.Builder<Builder> {\n-    private com.google.javascript.jscomp.FunctionInformationMap result;\n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return com.google.javascript.jscomp.FunctionInfo.internal_static_jscomp_FunctionInformationMap_descriptor;\n+    }\n+    \n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return com.google.javascript.jscomp.FunctionInfo.internal_static_jscomp_FunctionInformationMap_fieldAccessorTable;\n+    }\n     \n     // Construct using com.google.javascript.jscomp.FunctionInformationMap.newBuilder()\n-    private Builder() {}\n+    private Builder() {\n+    }\n     \n     private static Builder create() {\n-      Builder builder = new Builder();\n-      builder.result = new com.google.javascript.jscomp.FunctionInformationMap();\n-      return builder;\n-    }\n-    \n-    protected com.google.javascript.jscomp.FunctionInformationMap internalGetResult() {\n-      return result;\n+      return new Builder();\n     }\n     \n     public Builder clear() {\n-      if (result == null) {\n-        throw new IllegalStateException(\n-          \"Cannot call clear() after build().\");\n-      }\n-      result = new com.google.javascript.jscomp.FunctionInformationMap();\n+      super.clear();\n+      entry_ = java.util.Collections.emptyList();\n+      isEntryMutable = false;\n+      module_ = java.util.Collections.emptyList();\n+      isModuleMutable = false;\n       return this;\n     }\n     \n     public Builder clone() {\n-      return create().mergeFrom(result);\n+      return create().mergeFrom(buildPartial());\n     }\n     \n     public com.google.protobuf.Descriptors.Descriptor\n       return com.google.javascript.jscomp.FunctionInformationMap.getDefaultInstance();\n     }\n     \n-    public boolean isInitialized() {\n-      return result.isInitialized();\n-    }\n     public com.google.javascript.jscomp.FunctionInformationMap build() {\n-      if (result != null && !isInitialized()) {\n+      com.google.javascript.jscomp.FunctionInformationMap result = buildPartial();\n+      if (!result.isInitialized()) {\n         throw newUninitializedMessageException(result);\n       }\n-      return buildPartial();\n+      return result;\n     }\n     \n     private com.google.javascript.jscomp.FunctionInformationMap buildParsed()\n         throws com.google.protobuf.InvalidProtocolBufferException {\n-      if (!isInitialized()) {\n+      com.google.javascript.jscomp.FunctionInformationMap result = buildPartial();\n+      if (!result.isInitialized()) {\n         throw newUninitializedMessageException(\n           result).asInvalidProtocolBufferException();\n       }\n-      return buildPartial();\n+      return result;\n     }\n     \n     public com.google.javascript.jscomp.FunctionInformationMap buildPartial() {\n-      if (result == null) {\n-        throw new IllegalStateException(\n-          \"build() has already been called on this Builder.\");\n-      }\n-      if (result.entry_ != java.util.Collections.EMPTY_LIST) {\n-        result.entry_ =\n-          java.util.Collections.unmodifiableList(result.entry_);\n-      }\n-      if (result.module_ != java.util.Collections.EMPTY_LIST) {\n-        result.module_ =\n-          java.util.Collections.unmodifiableList(result.module_);\n-      }\n-      com.google.javascript.jscomp.FunctionInformationMap returnMe = result;\n-      result = null;\n-      return returnMe;\n+      com.google.javascript.jscomp.FunctionInformationMap result = new com.google.javascript.jscomp.FunctionInformationMap(this);\n+      if (isEntryMutable) {\n+        entry_ = java.util.Collections.unmodifiableList(entry_);\n+        isEntryMutable = false;\n+      }\n+      result.entry_ = entry_;\n+      if (isModuleMutable) {\n+        module_ = java.util.Collections.unmodifiableList(module_);\n+        isModuleMutable = false;\n+      }\n+      result.module_ = module_;\n+      return result;\n     }\n     \n     public Builder mergeFrom(com.google.protobuf.Message other) {\n     public Builder mergeFrom(com.google.javascript.jscomp.FunctionInformationMap other) {\n       if (other == com.google.javascript.jscomp.FunctionInformationMap.getDefaultInstance()) return this;\n       if (!other.entry_.isEmpty()) {\n-        if (result.entry_.isEmpty()) {\n-          result.entry_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Entry>();\n-        }\n-        result.entry_.addAll(other.entry_);\n+        if (entry_.isEmpty()) {\n+          entry_ = other.entry_;\n+          isEntryMutable = false;\n+        } else {\n+          ensureEntryIsMutable();\n+          entry_.addAll(other.entry_);\n+        }\n       }\n       if (!other.module_.isEmpty()) {\n-        if (result.module_.isEmpty()) {\n-          result.module_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Module>();\n-        }\n-        result.module_.addAll(other.module_);\n+        if (module_.isEmpty()) {\n+          module_ = other.module_;\n+          isModuleMutable = false;\n+        } else {\n+          ensureModuleIsMutable();\n+          module_.addAll(other.module_);\n+        }\n       }\n       this.mergeUnknownFields(other.getUnknownFields());\n       return this;\n+    }\n+    \n+    public final boolean isInitialized() {\n+      for (com.google.javascript.jscomp.FunctionInformationMap.Entry element : getEntryList()) {\n+        if (!element.isInitialized()) return false;\n+      }\n+      for (com.google.javascript.jscomp.FunctionInformationMap.Module element : getModuleList()) {\n+        if (!element.isInitialized()) return false;\n+      }\n+      return true;\n     }\n     \n     public Builder mergeFrom(\n     \n     \n     // repeated group Entry = 1 {\n+    private java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Entry> entry_ =\n+      java.util.Collections.emptyList();\n+    private boolean isEntryMutable;\n+    private void ensureEntryIsMutable() {\n+      if (!isEntryMutable) {\n+        entry_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Entry>(entry_);\n+        isEntryMutable = true;\n+       }\n+    }\n     public java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Entry> getEntryList() {\n-      return java.util.Collections.unmodifiableList(result.entry_);\n+      return java.util.Collections.unmodifiableList(entry_);\n     }\n     public int getEntryCount() {\n-      return result.getEntryCount();\n+      return entry_.size();\n     }\n     public com.google.javascript.jscomp.FunctionInformationMap.Entry getEntry(int index) {\n-      return result.getEntry(index);\n+      return entry_.get(index);\n     }\n     public Builder setEntry(\n         int index, com.google.javascript.jscomp.FunctionInformationMap.Entry value) {\n       if (value == null) {\n         throw new NullPointerException();\n       }\n-      result.entry_.set(index, value);\n+      ensureEntryIsMutable();\n+      entry_.set(index, value);\n       return this;\n     }\n     public Builder setEntry(\n         int index, com.google.javascript.jscomp.FunctionInformationMap.Entry.Builder builderForValue) {\n-      result.entry_.set(index, builderForValue.build());\n+      ensureEntryIsMutable();\n+      entry_.set(index, builderForValue.build());\n       return this;\n     }\n     public Builder addEntry(com.google.javascript.jscomp.FunctionInformationMap.Entry value) {\n       if (value == null) {\n         throw new NullPointerException();\n       }\n-      if (result.entry_.isEmpty()) {\n-        result.entry_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Entry>();\n-      }\n-      result.entry_.add(value);\n+      ensureEntryIsMutable();\n+      entry_.add(value);\n       return this;\n     }\n     public Builder addEntry(\n         com.google.javascript.jscomp.FunctionInformationMap.Entry.Builder builderForValue) {\n-      if (result.entry_.isEmpty()) {\n-        result.entry_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Entry>();\n-      }\n-      result.entry_.add(builderForValue.build());\n+      ensureEntryIsMutable();\n+      entry_.add(builderForValue.build());\n       return this;\n     }\n     public Builder addAllEntry(\n         java.lang.Iterable<? extends com.google.javascript.jscomp.FunctionInformationMap.Entry> values) {\n-      if (result.entry_.isEmpty()) {\n-        result.entry_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Entry>();\n-      }\n-      super.addAll(values, result.entry_);\n+      ensureEntryIsMutable();\n+      super.addAll(values, entry_);\n       return this;\n     }\n     public Builder clearEntry() {\n-      result.entry_ = java.util.Collections.emptyList();\n+      entry_ = java.util.Collections.emptyList();\n+      isEntryMutable = false;\n       return this;\n     }\n     \n     // repeated group Module = 101 {\n+    private java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Module> module_ =\n+      java.util.Collections.emptyList();\n+    private boolean isModuleMutable;\n+    private void ensureModuleIsMutable() {\n+      if (!isModuleMutable) {\n+        module_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Module>(module_);\n+        isModuleMutable = true;\n+       }\n+    }\n     public java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Module> getModuleList() {\n-      return java.util.Collections.unmodifiableList(result.module_);\n+      return java.util.Collections.unmodifiableList(module_);\n     }\n     public int getModuleCount() {\n-      return result.getModuleCount();\n+      return module_.size();\n     }\n     public com.google.javascript.jscomp.FunctionInformationMap.Module getModule(int index) {\n-      return result.getModule(index);\n+      return module_.get(index);\n     }\n     public Builder setModule(\n         int index, com.google.javascript.jscomp.FunctionInformationMap.Module value) {\n       if (value == null) {\n         throw new NullPointerException();\n       }\n-      result.module_.set(index, value);\n+      ensureModuleIsMutable();\n+      module_.set(index, value);\n       return this;\n     }\n     public Builder setModule(\n         int index, com.google.javascript.jscomp.FunctionInformationMap.Module.Builder builderForValue) {\n-      result.module_.set(index, builderForValue.build());\n+      ensureModuleIsMutable();\n+      module_.set(index, builderForValue.build());\n       return this;\n     }\n     public Builder addModule(com.google.javascript.jscomp.FunctionInformationMap.Module value) {\n       if (value == null) {\n         throw new NullPointerException();\n       }\n-      if (result.module_.isEmpty()) {\n-        result.module_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Module>();\n-      }\n-      result.module_.add(value);\n+      ensureModuleIsMutable();\n+      module_.add(value);\n       return this;\n     }\n     public Builder addModule(\n         com.google.javascript.jscomp.FunctionInformationMap.Module.Builder builderForValue) {\n-      if (result.module_.isEmpty()) {\n-        result.module_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Module>();\n-      }\n-      result.module_.add(builderForValue.build());\n+      ensureModuleIsMutable();\n+      module_.add(builderForValue.build());\n       return this;\n     }\n     public Builder addAllModule(\n         java.lang.Iterable<? extends com.google.javascript.jscomp.FunctionInformationMap.Module> values) {\n-      if (result.module_.isEmpty()) {\n-        result.module_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Module>();\n-      }\n-      super.addAll(values, result.module_);\n+      ensureModuleIsMutable();\n+      super.addAll(values, module_);\n       return this;\n     }\n     public Builder clearModule() {\n-      result.module_ = java.util.Collections.emptyList();\n+      module_ = java.util.Collections.emptyList();\n+      isModuleMutable = false;\n       return this;\n     }\n     \n--- a/gen/com/google/javascript/jscomp/Instrumentation.java\n+++ b/gen/com/google/javascript/jscomp/Instrumentation.java\n public  final class Instrumentation extends\n     com.google.protobuf.GeneratedMessage {\n   // Use Instrumentation.newBuilder() to construct.\n-  private Instrumentation() {\n-    initFields();\n+  private Instrumentation(Builder builder) {\n+    super(builder);\n   }\n   private Instrumentation(boolean noInit) {}\n   \n   // optional string report_defined = 1;\n   public static final int REPORT_DEFINED_FIELD_NUMBER = 1;\n   private boolean hasReportDefined;\n-  private java.lang.String reportDefined_ = \"\";\n+  private java.lang.String reportDefined_;\n   public boolean hasReportDefined() {\n     return hasReportDefined;\n   }\n   // optional string report_call = 2;\n   public static final int REPORT_CALL_FIELD_NUMBER = 2;\n   private boolean hasReportCall;\n-  private java.lang.String reportCall_ = \"\";\n+  private java.lang.String reportCall_;\n   public boolean hasReportCall() {\n     return hasReportCall;\n   }\n   // optional string report_exit = 6;\n   public static final int REPORT_EXIT_FIELD_NUMBER = 6;\n   private boolean hasReportExit;\n-  private java.lang.String reportExit_ = \"\";\n+  private java.lang.String reportExit_;\n   public boolean hasReportExit() {\n     return hasReportExit;\n   }\n   \n   // repeated string declaration_to_remove = 3;\n   public static final int DECLARATION_TO_REMOVE_FIELD_NUMBER = 3;\n-  private java.util.List<java.lang.String> declarationToRemove_ =\n-    java.util.Collections.emptyList();\n+  private java.util.List<java.lang.String> declarationToRemove_;\n   public java.util.List<java.lang.String>\n       getDeclarationToRemoveList() {\n     return declarationToRemove_;\n   \n   // repeated string init = 4;\n   public static final int INIT_FIELD_NUMBER = 4;\n-  private java.util.List<java.lang.String> init_ =\n-    java.util.Collections.emptyList();\n+  private java.util.List<java.lang.String> init_;\n   public java.util.List<java.lang.String>\n       getInitList() {\n     return init_;\n   // optional string app_name_setter = 5;\n   public static final int APP_NAME_SETTER_FIELD_NUMBER = 5;\n   private boolean hasAppNameSetter;\n-  private java.lang.String appNameSetter_ = \"\";\n+  private java.lang.String appNameSetter_;\n   public boolean hasAppNameSetter() {\n     return hasAppNameSetter;\n   }\n   }\n   \n   private void initFields() {\n+    reportDefined_ = \"\";\n+    reportCall_ = \"\";\n+    reportExit_ = \"\";\n+    declarationToRemove_ = java.util.Collections.emptyList();\n+    init_ = java.util.Collections.emptyList();\n+    appNameSetter_ = \"\";\n   }\n   public final boolean isInitialized() {\n     return true;\n   \n   public static final class Builder extends\n       com.google.protobuf.GeneratedMessage.Builder<Builder> {\n-    private com.google.javascript.jscomp.Instrumentation result;\n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return com.google.javascript.jscomp.InstrumentationTemplate.internal_static_jscomp_Instrumentation_descriptor;\n+    }\n+    \n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return com.google.javascript.jscomp.InstrumentationTemplate.internal_static_jscomp_Instrumentation_fieldAccessorTable;\n+    }\n     \n     // Construct using com.google.javascript.jscomp.Instrumentation.newBuilder()\n-    private Builder() {}\n+    private Builder() {\n+    }\n     \n     private static Builder create() {\n-      Builder builder = new Builder();\n-      builder.result = new com.google.javascript.jscomp.Instrumentation();\n-      return builder;\n-    }\n-    \n-    protected com.google.javascript.jscomp.Instrumentation internalGetResult() {\n-      return result;\n+      return new Builder();\n     }\n     \n     public Builder clear() {\n-      if (result == null) {\n-        throw new IllegalStateException(\n-          \"Cannot call clear() after build().\");\n-      }\n-      result = new com.google.javascript.jscomp.Instrumentation();\n+      super.clear();\n+      reportDefined_ = \"\";\n+      hasReportDefined = false;\n+      reportCall_ = \"\";\n+      hasReportCall = false;\n+      reportExit_ = \"\";\n+      hasReportExit = false;\n+      declarationToRemove_ = java.util.Collections.emptyList();\n+      isDeclarationToRemoveMutable = false;\n+      init_ = java.util.Collections.emptyList();\n+      isInitMutable = false;\n+      appNameSetter_ = \"\";\n+      hasAppNameSetter = false;\n       return this;\n     }\n     \n     public Builder clone() {\n-      return create().mergeFrom(result);\n+      return create().mergeFrom(buildPartial());\n     }\n     \n     public com.google.protobuf.Descriptors.Descriptor\n       return com.google.javascript.jscomp.Instrumentation.getDefaultInstance();\n     }\n     \n-    public boolean isInitialized() {\n-      return result.isInitialized();\n-    }\n     public com.google.javascript.jscomp.Instrumentation build() {\n-      if (result != null && !isInitialized()) {\n+      com.google.javascript.jscomp.Instrumentation result = buildPartial();\n+      if (!result.isInitialized()) {\n         throw newUninitializedMessageException(result);\n       }\n-      return buildPartial();\n+      return result;\n     }\n     \n     private com.google.javascript.jscomp.Instrumentation buildParsed()\n         throws com.google.protobuf.InvalidProtocolBufferException {\n-      if (!isInitialized()) {\n+      com.google.javascript.jscomp.Instrumentation result = buildPartial();\n+      if (!result.isInitialized()) {\n         throw newUninitializedMessageException(\n           result).asInvalidProtocolBufferException();\n       }\n-      return buildPartial();\n+      return result;\n     }\n     \n     public com.google.javascript.jscomp.Instrumentation buildPartial() {\n-      if (result == null) {\n-        throw new IllegalStateException(\n-          \"build() has already been called on this Builder.\");\n-      }\n-      if (result.declarationToRemove_ != java.util.Collections.EMPTY_LIST) {\n-        result.declarationToRemove_ =\n-          java.util.Collections.unmodifiableList(result.declarationToRemove_);\n-      }\n-      if (result.init_ != java.util.Collections.EMPTY_LIST) {\n-        result.init_ =\n-          java.util.Collections.unmodifiableList(result.init_);\n-      }\n-      com.google.javascript.jscomp.Instrumentation returnMe = result;\n-      result = null;\n-      return returnMe;\n+      com.google.javascript.jscomp.Instrumentation result = new com.google.javascript.jscomp.Instrumentation(this);\n+      result.hasReportDefined = hasReportDefined;\n+      result.reportDefined_ = reportDefined_;\n+      result.hasReportCall = hasReportCall;\n+      result.reportCall_ = reportCall_;\n+      result.hasReportExit = hasReportExit;\n+      result.reportExit_ = reportExit_;\n+      if (isDeclarationToRemoveMutable) {\n+        declarationToRemove_ = java.util.Collections.unmodifiableList(declarationToRemove_);\n+        isDeclarationToRemoveMutable = false;\n+      }\n+      result.declarationToRemove_ = declarationToRemove_;\n+      if (isInitMutable) {\n+        init_ = java.util.Collections.unmodifiableList(init_);\n+        isInitMutable = false;\n+      }\n+      result.init_ = init_;\n+      result.hasAppNameSetter = hasAppNameSetter;\n+      result.appNameSetter_ = appNameSetter_;\n+      return result;\n     }\n     \n     public Builder mergeFrom(com.google.protobuf.Message other) {\n         setReportExit(other.getReportExit());\n       }\n       if (!other.declarationToRemove_.isEmpty()) {\n-        if (result.declarationToRemove_.isEmpty()) {\n-          result.declarationToRemove_ = new java.util.ArrayList<java.lang.String>();\n+        if (declarationToRemove_.isEmpty()) {\n+          declarationToRemove_ = other.declarationToRemove_;\n+          isDeclarationToRemoveMutable = false;\n+        } else {\n+          ensureDeclarationToRemoveIsMutable();\n+          declarationToRemove_.addAll(other.declarationToRemove_);\n         }\n-        result.declarationToRemove_.addAll(other.declarationToRemove_);\n       }\n       if (!other.init_.isEmpty()) {\n-        if (result.init_.isEmpty()) {\n-          result.init_ = new java.util.ArrayList<java.lang.String>();\n+        if (init_.isEmpty()) {\n+          init_ = other.init_;\n+          isInitMutable = false;\n+        } else {\n+          ensureInitIsMutable();\n+          init_.addAll(other.init_);\n         }\n-        result.init_.addAll(other.init_);\n       }\n       if (other.hasAppNameSetter()) {\n         setAppNameSetter(other.getAppNameSetter());\n       }\n       this.mergeUnknownFields(other.getUnknownFields());\n       return this;\n+    }\n+    \n+    public final boolean isInitialized() {\n+      return true;\n     }\n     \n     public Builder mergeFrom(\n     \n     \n     // optional string report_defined = 1;\n+    private boolean hasReportDefined;\n+    private java.lang.String reportDefined_ = \"\";\n     public boolean hasReportDefined() {\n-      return result.hasReportDefined();\n+      return hasReportDefined;\n     }\n     public java.lang.String getReportDefined() {\n-      return result.getReportDefined();\n+      return reportDefined_;\n     }\n     public Builder setReportDefined(java.lang.String value) {\n       if (value == null) {\n     throw new NullPointerException();\n   }\n-  result.hasReportDefined = true;\n-      result.reportDefined_ = value;\n+  hasReportDefined = true;\n+      reportDefined_ = value;\n       return this;\n     }\n     public Builder clearReportDefined() {\n-      result.hasReportDefined = false;\n-      result.reportDefined_ = getDefaultInstance().getReportDefined();\n+      hasReportDefined = false;\n+      reportDefined_ = getDefaultInstance().getReportDefined();\n       return this;\n     }\n     \n     // optional string report_call = 2;\n+    private boolean hasReportCall;\n+    private java.lang.String reportCall_ = \"\";\n     public boolean hasReportCall() {\n-      return result.hasReportCall();\n+      return hasReportCall;\n     }\n     public java.lang.String getReportCall() {\n-      return result.getReportCall();\n+      return reportCall_;\n     }\n     public Builder setReportCall(java.lang.String value) {\n       if (value == null) {\n     throw new NullPointerException();\n   }\n-  result.hasReportCall = true;\n-      result.reportCall_ = value;\n+  hasReportCall = true;\n+      reportCall_ = value;\n       return this;\n     }\n     public Builder clearReportCall() {\n-      result.hasReportCall = false;\n-      result.reportCall_ = getDefaultInstance().getReportCall();\n+      hasReportCall = false;\n+      reportCall_ = getDefaultInstance().getReportCall();\n       return this;\n     }\n     \n     // optional string report_exit = 6;\n+    private boolean hasReportExit;\n+    private java.lang.String reportExit_ = \"\";\n     public boolean hasReportExit() {\n-      return result.hasReportExit();\n+      return hasReportExit;\n     }\n     public java.lang.String getReportExit() {\n-      return result.getReportExit();\n+      return reportExit_;\n     }\n     public Builder setReportExit(java.lang.String value) {\n       if (value == null) {\n     throw new NullPointerException();\n   }\n-  result.hasReportExit = true;\n-      result.reportExit_ = value;\n+  hasReportExit = true;\n+      reportExit_ = value;\n       return this;\n     }\n     public Builder clearReportExit() {\n-      result.hasReportExit = false;\n-      result.reportExit_ = getDefaultInstance().getReportExit();\n+      hasReportExit = false;\n+      reportExit_ = getDefaultInstance().getReportExit();\n       return this;\n     }\n     \n     // repeated string declaration_to_remove = 3;\n+    private java.util.List<java.lang.String> declarationToRemove_ =\n+      java.util.Collections.emptyList();\n+    private boolean isDeclarationToRemoveMutable;\n+    private void ensureDeclarationToRemoveIsMutable() {\n+      if (!isDeclarationToRemoveMutable) {\n+        declarationToRemove_ = new java.util.ArrayList<java.lang.String>(declarationToRemove_);\n+        isDeclarationToRemoveMutable = true;\n+       }\n+    }\n     public java.util.List<java.lang.String>\n         getDeclarationToRemoveList() {\n-      return java.util.Collections.unmodifiableList(result.declarationToRemove_);\n+      return java.util.Collections.unmodifiableList(declarationToRemove_);\n     }\n     public int getDeclarationToRemoveCount() {\n-      return result.getDeclarationToRemoveCount();\n+      return declarationToRemove_.size();\n     }\n     public java.lang.String getDeclarationToRemove(int index) {\n-      return result.getDeclarationToRemove(index);\n+      return declarationToRemove_.get(index);\n     }\n     public Builder setDeclarationToRemove(\n         int index, java.lang.String value) {\n       if (value == null) {\n     throw new NullPointerException();\n   }\n-  result.declarationToRemove_.set(index, value);\n+  ensureDeclarationToRemoveIsMutable();\n+      declarationToRemove_.set(index, value);\n       return this;\n     }\n     public Builder addDeclarationToRemove(java.lang.String value) {\n       if (value == null) {\n     throw new NullPointerException();\n   }\n-  if (result.declarationToRemove_.isEmpty()) {\n-        result.declarationToRemove_ = new java.util.ArrayList<java.lang.String>();\n-      }\n-      result.declarationToRemove_.add(value);\n+  ensureDeclarationToRemoveIsMutable();\n+      declarationToRemove_.add(value);\n       return this;\n     }\n     public Builder addAllDeclarationToRemove(\n         java.lang.Iterable<? extends java.lang.String> values) {\n-      if (result.declarationToRemove_.isEmpty()) {\n-        result.declarationToRemove_ = new java.util.ArrayList<java.lang.String>();\n-      }\n-      super.addAll(values, result.declarationToRemove_);\n+      ensureDeclarationToRemoveIsMutable();\n+      super.addAll(values, declarationToRemove_);\n       return this;\n     }\n     public Builder clearDeclarationToRemove() {\n-      result.declarationToRemove_ = java.util.Collections.emptyList();\n+      declarationToRemove_ = java.util.Collections.emptyList();\n+      isDeclarationToRemoveMutable = false;\n       return this;\n     }\n     \n     // repeated string init = 4;\n+    private java.util.List<java.lang.String> init_ =\n+      java.util.Collections.emptyList();\n+    private boolean isInitMutable;\n+    private void ensureInitIsMutable() {\n+      if (!isInitMutable) {\n+        init_ = new java.util.ArrayList<java.lang.String>(init_);\n+        isInitMutable = true;\n+       }\n+    }\n     public java.util.List<java.lang.String>\n         getInitList() {\n-      return java.util.Collections.unmodifiableList(result.init_);\n+      return java.util.Collections.unmodifiableList(init_);\n     }\n     public int getInitCount() {\n-      return result.getInitCount();\n+      return init_.size();\n     }\n     public java.lang.String getInit(int index) {\n-      return result.getInit(index);\n+      return init_.get(index);\n     }\n     public Builder setInit(\n         int index, java.lang.String value) {\n       if (value == null) {\n     throw new NullPointerException();\n   }\n-  result.init_.set(index, value);\n+  ensureInitIsMutable();\n+      init_.set(index, value);\n       return this;\n     }\n     public Builder addInit(java.lang.String value) {\n       if (value == null) {\n     throw new NullPointerException();\n   }\n-  if (result.init_.isEmpty()) {\n-        result.init_ = new java.util.ArrayList<java.lang.String>();\n-      }\n-      result.init_.add(value);\n+  ensureInitIsMutable();\n+      init_.add(value);\n       return this;\n     }\n     public Builder addAllInit(\n         java.lang.Iterable<? extends java.lang.String> values) {\n-      if (result.init_.isEmpty()) {\n-        result.init_ = new java.util.ArrayList<java.lang.String>();\n-      }\n-      super.addAll(values, result.init_);\n+      ensureInitIsMutable();\n+      super.addAll(values, init_);\n       return this;\n     }\n     public Builder clearInit() {\n-      result.init_ = java.util.Collections.emptyList();\n+      init_ = java.util.Collections.emptyList();\n+      isInitMutable = false;\n       return this;\n     }\n     \n     // optional string app_name_setter = 5;\n+    private boolean hasAppNameSetter;\n+    private java.lang.String appNameSetter_ = \"\";\n     public boolean hasAppNameSetter() {\n-      return result.hasAppNameSetter();\n+      return hasAppNameSetter;\n     }\n     public java.lang.String getAppNameSetter() {\n-      return result.getAppNameSetter();\n+      return appNameSetter_;\n     }\n     public Builder setAppNameSetter(java.lang.String value) {\n       if (value == null) {\n     throw new NullPointerException();\n   }\n-  result.hasAppNameSetter = true;\n-      result.appNameSetter_ = value;\n+  hasAppNameSetter = true;\n+      appNameSetter_ = value;\n       return this;\n     }\n     public Builder clearAppNameSetter() {\n-      result.hasAppNameSetter = false;\n-      result.appNameSetter_ = getDefaultInstance().getAppNameSetter();\n+      hasAppNameSetter = false;\n+      appNameSetter_ = getDefaultInstance().getAppNameSetter();\n       return this;\n     }\n     \n--- a/src/com/google/javascript/jscomp/AliasKeywords.java\n+++ b/src/com/google/javascript/jscomp/AliasKeywords.java\n     }\n   }\n \n-  static final String ALIAS_NULL = \"$$ALIAS_NULL\";\n-  static final String ALIAS_TRUE = \"$$ALIAS_TRUE\";\n-  static final String ALIAS_FALSE = \"$$ALIAS_FALSE\";\n-  static final String ALIAS_THROW = \"$$ALIAS_THROW\";\n+  static final String ALIAS_NULL = \"JSCompiler_alias_NULL\";\n+  static final String ALIAS_TRUE = \"JSCompiler_alias_TRUE\";\n+  static final String ALIAS_FALSE = \"JSCompiler_alias_FALSE\";\n+  static final String ALIAS_THROW = \"JSCompiler_alias_THROW\";\n \n   /**\n    * Don't alias a keyword unless it's referenced at least\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n   public boolean isConstant(String variableName);\n \n   /**\n+   * This checks whether a given key of an object literal, such as a\n+   * name in all-caps should be treated as if it had the @const\n+   * annotation.\n+   */\n+  public boolean isConstantKey(String keyName);\n+  \n+  /**\n    * This checks that a given {@code key} may be used as a key for an enum.\n    *\n    * @param key the potential key to an enum\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n               cb.getLineIndex(), cb.getColumnIndex());\n         }\n \n-        String code = toSource(root);\n+        String code = toSource(root, sourceMap);\n         if (!code.isEmpty()) {\n           cb.append(code);\n           if (!code.endsWith(\";\")) {\n   }\n \n   /**\n-   * Generates JavaScript source code for an AST.\n+   * Generates JavaScript source code for an AST, doesn't generate source\n+   * map info.\n    */\n   @Override\n   String toSource(Node n) {\n     initCompilerOptionsIfTesting();\n-\n+    return toSource(n, null);\n+  }\n+\n+  /**\n+   * Generates JavaScript source code for an AST.\n+   */\n+  private String toSource(Node n, SourceMap sourceMap) {\n     CodePrinter.Builder builder = new CodePrinter.Builder(n);\n     builder.setPrettyPrint(options.prettyPrint);\n     builder.setLineBreak(options.lineBreak);\n--- a/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n   // Visible for testing\n   static final String STUB_DECLARATIONS =\n       \"var JSCompiler_stubMap = [];\" +\n-      \"function JSCompiler_stubMethod(id) {\" +\n+      \"function JSCompiler_stubMethod(JSCompiler_stubMethod_id) {\" +\n       \"  return function() {\" +\n-      \"    return JSCompiler_stubMap[id].apply(this, arguments);\" +\n+      \"    return JSCompiler_stubMap[JSCompiler_stubMethod_id].apply(\" +\n+      \"        this, arguments);\" +\n       \"  };\" +\n       \"}\" +\n-      \"function JSCompiler_unstubMethod(id, body) {\" +\n-      \"  return JSCompiler_stubMap[id] = body;\" +\n+      \"function JSCompiler_unstubMethod(\" +\n+      \"    JSCompiler_unstubMethod_id, JSCompiler_unstubMethod_body) {\" +\n+      \"  return JSCompiler_stubMap[JSCompiler_unstubMethod_id] = \" +\n+      \"      JSCompiler_unstubMethod_body;\" +\n       \"}\";\n \n   /**\n--- a/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n \n   @Override\n   public boolean isConstant(String variableName) {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean isConstantKey(String variableName) {\n     return false;\n   }\n \n--- a/src/com/google/javascript/jscomp/ExternExportsPass.java\n+++ b/src/com/google/javascript/jscomp/ExternExportsPass.java\n      * We create a warning here if the the function to export is missing\n      * parameter or return types.\n      */\n-    private Node createExternFunction(Node exportedFunction) {   \n-      checkForFunctionsWithUnknownTypes(exportedFunction);\n-      \n+    private Node createExternFunction(Node exportedFunction) {\n       List<Node> externParameters = Lists.newLinkedList();\n       Node actualParameterIterator = NodeUtil.getFnParameters(exportedFunction)\n         .getFirstChild();\n       }\n       \n       Node externFunction = NodeUtil.newFunctionNode(\"\", externParameters, \n-          new Node(Token.BLOCK), -1, -1);      \n+          new Node(Token.BLOCK), -1, -1);\n+      \n+      checkForFunctionsWithUnknownTypes(exportedFunction);    \n       externFunction.setJSType(exportedFunction.getJSType());\n       \n       return externFunction;\n     private void checkForFunctionsWithUnknownTypes(Node function) {\n       Preconditions.checkArgument(NodeUtil.isFunction(function));\n       \n+      FunctionType functionType = (FunctionType) function.getJSType();\n+      \n+      if (functionType == null) {\n+        // No type information is available (CheckTypes was probably not run)\n+        // so just bail.\n+        return;\n+      }\n+      \n       /* We must get the JSDocInfo from the function's type since the function\n        * itself does not have an associated JSDocInfo node.\n        */\n-      JSDocInfo functionJSDocInfo = function.getJSType().getJSDocInfo();\n-      \n-      FunctionType functionType = (FunctionType) function.getJSType();\n-      \n+      JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n+        \n       JSType returnType = functionType.getReturnType();\n       \n       /* It is OK if a constructor doesn't have a return type */\n--- a/src/com/google/javascript/jscomp/GoogleCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/GoogleCodingConvention.java\n       }\n     }\n \n-    if (!Character.isUpperCase(name.charAt(0))) {\n+    return isConstantKey(name);\n+  }\n+\n+  @Override\n+  public boolean isConstantKey(String name) {\n+    if (name.isEmpty() || !Character.isUpperCase(name.charAt(0))) {\n       return false;\n     }\n \n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n     return node.getBooleanProp(Node.IS_CONSTANT_NAME);\n   }\n \n+  /** Whether the given name is constant by coding convention. */\n+  static boolean isConstantByConvention(\n+      CodingConvention convention, Node node, Node parent) {\n+    String name = node.getString();\n+    if (parent.getType() == Token.GETPROP &&\n+        node == parent.getLastChild()) {\n+      return convention.isConstantKey(name);\n+    } else if (isObjectLitKey(node, parent)) {\n+      return convention.isConstantKey(name);\n+    } else {\n+      return convention.isConstant(name);\n+    }\n+  }\n+\n   /**\n    * @param nameNode A name node\n    * @return The JSDocInfo for the name node\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n         boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n         if (checkUserDeclarations) {\n           boolean expectedConst = false;\n+          CodingConvention convention = compiler.getCodingConvention();\n           if (NodeUtil.isConstantName(n)\n-              || compiler.getCodingConvention().isConstant(n.getString())) {\n+              || NodeUtil.isConstantByConvention(convention, n, parent)) {\n             expectedConst = true;\n           } else {\n             expectedConst = false;\n--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n class PrepareAst implements CompilerPass {\n \n   private final AbstractCompiler compiler;\n-  private final boolean assertOnChange;\n+  private final boolean checkOnly;\n \n   PrepareAst(AbstractCompiler compiler) {\n     this(compiler, false);\n   }\n \n-  PrepareAst(AbstractCompiler compiler, boolean forbidChanges) {\n+  PrepareAst(AbstractCompiler compiler, boolean checkOnly) {\n     this.compiler = compiler;\n-    this.assertOnChange = forbidChanges;\n+    this.checkOnly = checkOnly;\n   }\n \n   private void reportChange() {\n-    if (assertOnChange) {\n+    if (checkOnly) {\n       Preconditions.checkState(false, \"normalizeNodeType constraints violated\");\n     }\n   }\n \n   @Override\n   public void process(Node externs, Node root) {\n-    if (assertOnChange) {\n+    if (checkOnly) {\n       normalizeNodeTypes(root);\n-    }\n-    if (externs != null) {\n-      NodeTraversal.traverse(\n-          compiler, externs, new PrepareAnnotations(compiler));\n-    }\n-    if (root != null) {\n-      NodeTraversal.traverse(\n-          compiler, root, new PrepareAnnotations(compiler));\n+    } else {\n+      // Don't perform \"PrepareAnnoations\" when doing checks as\n+      // they currently aren't valid during sanity checks.  In particular,\n+      // they DIRECT_EVAL shouldn't be applied after inlining has been\n+      // performed.\n+      if (externs != null) {\n+        NodeTraversal.traverse(\n+            compiler, externs, new PrepareAnnotations(compiler));\n+      }\n+      if (root != null) {\n+        NodeTraversal.traverse(\n+            compiler, root, new PrepareAnnotations(compiler));\n+      }\n     }\n   }\n \n      * But in few narrow cases (in particular, function literals), it's\n      * a lot easier for us if the doc is attached to the value.\n      */\n+    @SuppressWarnings(\"fallthrough\")\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       int nType = n.getType();\n       switch (nType) {\n+        case Token.STRING:\n+          // There are only two cases where a string token\n+          // may be a variable reference: The right side of a GETPROP\n+          // or an OBJECTLIT key.\n+          if (parent.getType() != Token.OBJECTLIT &&\n+              parent.getType() != Token.GETPROP) {\n+            break;\n+          }\n+          // fall-through\n+\n         case Token.NAME:\n-        case Token.STRING:\n           String nString = n.getString();\n           if (nType == Token.NAME &&\n               n.getParent().getType() == Token.CALL &&\n               \"eval\".equals(nString)) {\n             n.putBooleanProp(Node.DIRECT_EVAL, true);\n           }\n-          if (convention.isConstant(nString)) {\n+          if (NodeUtil.isConstantByConvention(convention, n, parent)) {\n             n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n           }\n           break;\n--- a/src/com/google/javascript/jscomp/SanityCheck.java\n+++ b/src/com/google/javascript/jscomp/SanityCheck.java\n     String source2 = compiler.toSource(root2);\n     if (!source.equals(source2)) {\n       compiler.report(JSError.make(GENERATED_BAD_CODE,\n-              Strings.truncateAtMaxLength(source, 100, true),\n-              Strings.truncateAtMaxLength(source2, 100, true)));\n+              Strings.truncateAtMaxLength(source, 1000, true),\n+              Strings.truncateAtMaxLength(source2, 1000, true)));\n     }\n \n     return root2;\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n   static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error(\n       \"JSC_GOOG_SCOPE_USES_RETURN\",\n       \"The body of a goog.scope function cannot use 'return'.\");\n+\n+  static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error(\n+      \"JSC_GOOG_SCOPE_USES_THROW\",\n+      \"The body of a goog.scope function cannot use 'throw'.\");\n \n   static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error(\n       \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\",\n       }\n \n       if (t.getScopeDepth() == 2) {\n-        if (n.getType() == Token.NAME && parent.getType() == Token.VAR) {\n+        int type = n.getType();\n+        if (type == Token.NAME && parent.getType() == Token.VAR) {\n           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n             aliases.put(n.getString(), n.getFirstChild());\n             aliasDefinitions.add(n);\n             report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n           }\n         }\n+\n+        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent)) {\n+          report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+        }\n+\n+        if (type == Token.RETURN) {\n+          report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+          report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+          report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n       }\n \n       if (t.getScopeDepth() >= 2) {\n         if (n.getType() == Token.NAME) {\n-          if (NodeUtil.isAssignmentOp(parent)) {\n-            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-          }\n           Node aliasedNode = aliases.get(n.getString());\n           // The variable should not exist since we undeclared it when we found\n           // it.  If it does exist, it's because it's been overridden.\n           }\n         }\n \n-        if (n.getType() == Token.RETURN) {\n-          report(t, n, GOOG_SCOPE_USES_RETURN);\n-        }\n-\n-        if (n.getType() == Token.THIS) {\n-          report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        }\n-\n         JSDocInfo info = n.getJSDocInfo();\n         if (info != null) {\n           for (Node node : info.getTypeNodes()) {\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n     int minArgs = functionType.getMinArguments();\n     int maxArgs = functionType.getMaxArguments();\n     if (minArgs > numArgs || maxArgs < numArgs) {\n-      t.getCompiler().report(\n-          t.makeError(call, WRONG_ARGUMENT_COUNT,\n+      report(t, call, WRONG_ARGUMENT_COUNT,\n               validator.getReadableJSTypeName(call.getFirstChild(), false),\n               String.valueOf(numArgs), String.valueOf(minArgs),\n               maxArgs != Integer.MAX_VALUE ?\n-              \" and no more than \" + maxArgs + \" argument(s)\" : \"\"));\n+              \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n     }\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n \n import com.google.common.base.Joiner;\n import com.google.common.base.Preconditions;\n-import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.javascript.rhino.ErrorReporter;\n \n   public boolean isEquivalentTo(JSType object) {\n     if (object instanceof UnionType) {\n       UnionType that = (UnionType) object;\n-      return this.isSubtype(that) && that.isSubtype(this);\n+      if (alternates.size() != that.alternates.size()) {\n+        return false;\n+      }\n+      for (JSType alternate : that.alternates) {\n+        if (!hasAlternate(alternate)) {\n+          return false;\n+        }\n+      }\n+      return true;\n     } else {\n       return false;\n     }\n+  }\n+\n+  private boolean hasAlternate(JSType type) {\n+    for (JSType alternate : alternates) {\n+      if (alternate.isEquivalentTo(type)) {\n+        return true;\n+      }\n+    }\n+    return false;\n   }\n \n   @Override\n     setResolvedTypeInternal(this); // for circularly defined types.\n \n     boolean changed = false;\n-    ImmutableSet.Builder<JSType> resolvedTypes = ImmutableSet.builder();\n+    ImmutableList.Builder<JSType> resolvedTypes = ImmutableList.builder();\n     for (JSType alternate : alternates) {\n       JSType newAlternate = alternate.resolve(t, scope);\n       changed |= (alternate != newAlternate);\n     }\n     if (changed) {\n       Collection<JSType> newAlternates = resolvedTypes.build();\n-      Preconditions.checkState(newAlternates.hashCode() == this.hashcode);\n+      Preconditions.checkState(\n+          newAlternates.hashCode() == this.hashcode);\n       alternates = newAlternates;\n     }\n     return this;\n--- a/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n-\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Lists;\n-import com.google.javascript.rhino.jstype.UnionType;\n \n import static com.google.javascript.rhino.jstype.JSTypeNative.ALL_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.CHECKED_UNKNOWN_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n \n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import com.google.javascript.rhino.jstype.UnionType;\n+\n import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n import java.util.Iterator;\n import java.util.List;\n-import java.util.Set;\n \n /**\n  * A builder for union types.\n           addAlternate(unionAlt);\n         }\n       } else {\n-        if (!alternate.isUnknownType()) {\n-          Iterator<JSType> it = alternates.iterator();\n-          while (it.hasNext()) {\n-            JSType current = it.next();\n-            if (!current.isUnknownType()) {\n-              if (alternate.isSubtype(current)) {\n-                // Alternate is unnecessary.\n-                return this;\n-              } else if (current.isSubtype(alternate)) {\n-                // Alternate makes current obsolete\n-                it.remove();\n-              }\n+        if (alternates.size() > MAX_UNION_SIZE) {\n+          return this;\n+        }\n+\n+        // Look through the alternates we've got so far,\n+        // and check if any of them are duplicates of\n+        // one another.\n+        Iterator<JSType> it = alternates.iterator();\n+        while (it.hasNext()) {\n+          JSType current = it.next();\n+          if (alternate.isUnknownType() ||\n+              current.isUnknownType()) {\n+            if (alternate.isEquivalentTo(current)) {\n+              // Alternate is unnecessary.\n+              return this;\n+            }\n+          } else {\n+            if (alternate.isSubtype(current)) {\n+              // Alternate is unnecessary.\n+              return this;\n+            } else if (current.isSubtype(alternate)) {\n+              // Alternate makes current obsolete\n+              it.remove();\n             }\n           }\n         }\n           result = registry.getNativeType(UNKNOWN_TYPE);\n         }\n       } else {\n-        Set<JSType> alternateSet = ImmutableSet.copyOf(alternates);\n-        int size = alternateSet.size();\n+        int size = alternates.size();\n         if (size > MAX_UNION_SIZE) {\n           result = registry.getNativeType(UNKNOWN_TYPE);\n         } else {\n           if (size > 1) {\n-            result = new UnionType(registry, alternateSet);\n+            result = new UnionType(registry, getAlternateListCopy());\n           } else if (size == 1) {\n             result = alternates.iterator().next();\n           } else {\n     }\n     return result;\n   }\n+\n+  private static final Comparator<JSType> typeSorter =\n+      new Comparator<JSType>() {\n+    @Override public int compare(JSType a, JSType b) {\n+      return b.hashCode() - a.hashCode();\n+    }\n+  };\n+\n+  private Collection<JSType> getAlternateListCopy() {\n+    // TODO(nicksantos): Until we're at a place where we're no longer\n+    // using java's built-in equals to test type equivalence, we need\n+    // hash codes to be the same. So the alternates need to be sorted.\n+    Collections.sort(alternates, typeSorter);\n+\n+    return ImmutableList.copyOf(alternates);\n+  }\n }\n--- a/test/com/google/javascript/jscomp/AliasKeywordsTest.java\n+++ b/test/com/google/javascript/jscomp/AliasKeywordsTest.java\n   public void testAlias() {\n     test(generateCode(\"true\", ENOUGH_TO_ALIAS_LITERAL),\n          generateCode(AliasKeywords.ALIAS_TRUE, ENOUGH_TO_ALIAS_LITERAL,\n-                      \"var $$ALIAS_TRUE=true;\"));\n+                      \"var JSCompiler_alias_TRUE=true;\"));\n \n     test(generateCode(\"false\", ENOUGH_TO_ALIAS_LITERAL),\n          generateCode(AliasKeywords.ALIAS_FALSE, ENOUGH_TO_ALIAS_LITERAL,\n-                      \"var $$ALIAS_FALSE=false;\"));\n+                      \"var JSCompiler_alias_FALSE=false;\"));\n \n     test(generateCode(\"null\", ENOUGH_TO_ALIAS_LITERAL),\n          generateCode(AliasKeywords.ALIAS_NULL, ENOUGH_TO_ALIAS_LITERAL,\n-                      \"var $$ALIAS_NULL=null;\"));\n+                      \"var JSCompiler_alias_NULL=null;\"));\n     test(generatePreProcessThrowCode(ENOUGH_TO_ALIAS_THROW, \"1\"),\n          generatePostProcessThrowCode(ENOUGH_TO_ALIAS_THROW, \"\", \"1\"));\n   }\n \n     StringBuffer expected = new StringBuffer();\n     expected.append(\n-        \"var $$ALIAS_TRUE=true;var $$ALIAS_NULL=null;var $$ALIAS_FALSE=false;\");\n+        \"var JSCompiler_alias_TRUE=true;\" +\n+        \"var JSCompiler_alias_NULL=null;\" +\n+        \"var JSCompiler_alias_FALSE=false;\");\n     expected.append(\n         generateCode(AliasKeywords.ALIAS_TRUE, ENOUGH_TO_ALIAS_LITERAL));\n     expected.append(\n   public void testAliasThrowKeywordLiteral() {\n     int repitions = Math.max(ENOUGH_TO_ALIAS_THROW, ENOUGH_TO_ALIAS_LITERAL);\n     String afterCode = generatePostProcessThrowCode(\n-          repitions, \"var $$ALIAS_TRUE=true;\", AliasKeywords.ALIAS_TRUE);\n+          repitions, \"var JSCompiler_alias_TRUE=true;\",\n+          AliasKeywords.ALIAS_TRUE);\n     test(generatePreProcessThrowCode(repitions, \"true\"), afterCode);\n   }\n \n   public void testExistingAliasDefinitionFails() {\n     try {\n-      testSame(\"var $$ALIAS_TRUE='foo';\");\n+      testSame(\"var JSCompiler_alias_TRUE='foo';\");\n       fail();\n     } catch (RuntimeException expected) {\n       assertTrue(-1 != expected.getMessage().indexOf(\n--- a/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n \n   @Override\n   public void setUp() {\n-    super.enableLineNumberCheck(true);\n+    enableLineNumberCheck(true);\n+    enableNormalize(true);\n   }\n \n   @Override public int getNumRepetitions() {\n \n   public void testObjLitDeclarationWithDuplicateKeys() {\n     test(\"var a = {b: 0, b: 1}; var c = a.b;\",\n-         \"var a$b = 0; var a$b = 1; var c = a$b;\");\n+         \"var a$b = 0; var a$b = 1; var c = a$b;\",\n+         SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR);\n   }\n \n   public void testObjLitAssignmentDepth1() {\n   }\n \n   public void testReferenceInAnonymousObject3() {\n-    test(\"function CreateClass(a) {}\" +\n+    test(\"function CreateClass(a$$1) {}\" +\n          \"var a = {};\" +\n          \"a.b = function(){};\" +\n          \"a.b.prototype.c = function(){};\" +\n          \"a.d = CreateClass({c: a.b.prototype.c});\",\n-         \"function CreateClass(a) {}\" +\n+         \"function CreateClass(a$$1) {}\" +\n          \"var a$b = function(){};\" +\n          \"a$b.prototype.c = function(){};\" +\n          \"var a$d = CreateClass({c: a$b.prototype.c});\");\n          \"var a = {};\" +\n          \"a.b = CreateClass({c: function() {}});\" +\n          \"a.d = CreateClass({c: a.b.c});\",\n-         \"function CreateClass(a) {}\" +\n+         \"function CreateClass(a$$1) {}\" +\n          \"var a$b = CreateClass({c: function() {}});\" +\n          \"var a$d = CreateClass({c: a$b.c});\");\n   }\n          \"var a = {};\" +\n          \"a.b = CreateClass({c: function() {}});\" +\n          \"a.d = CreateClass({c: a.b.prototype.c});\",\n-         \"function CreateClass(a) {}\" +\n+         \"function CreateClass(a$$1) {}\" +\n          \"var a$b = CreateClass({c: function() {}});\" +\n          \"var a$d = CreateClass({c: a$b.prototype.c});\");\n   }\n     test(\"var a = {b: {$0c: true}, b$0c: false};\",\n          \"var a$b$$00c = true; var a$b$00c = false;\");\n   }\n+\n+  public void testConstKey() {\n+    test(\"var foo = {A: 3};\", \"var foo$A = 3;\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/ExternExportsPassTest.java\n+++ b/test/com/google/javascript/jscomp/ExternExportsPassTest.java\n  */\n public class ExternExportsPassTest extends TestCase {\n \n+  private boolean runCheckTypes = true;\n+\n+  /**\n+   * ExternExportsPass relies on type information to emit JSDoc annotations for\n+   * exported externs. However, the user can disable typechecking and still\n+   * ask for externs to be exported. Set this flag to enable or disable checking\n+   * of types during a test.\n+   */\n+  private void setRunCheckTypes(boolean shouldRunCheckTypes) {\n+    runCheckTypes = shouldRunCheckTypes;\n+  }\n+  \n+  @Override\n+  public void setUp() throws Exception {\n+    super.setUp();\n+    \n+    setRunCheckTypes(true);\n+  }\n+  \n   public void testExportSymbol() throws Exception {\n     compileAndCheck(\"var a = {}; a.b = {}; a.b.c = function(d, e, f) {};\" +\n                     \"goog.exportSymbol('foobar', a.b.c)\",\n                     \"var externalName = function(param1, param2) {\\n}\");\n   }\n \n+  public void testExportSymbolWithoutTypeCheck() {\n+    // ExternExportsPass should not emit annotations\n+    // if there is no type information available.\n+    setRunCheckTypes(false);\n+    \n+    compileAndCheck(\"var internalName;\\n\" +\n+                    \"/**\\n\" +\n+                    \" * @param {string} param1\\n\" +\n+                    \" * @param {number} param2\\n\" +\n+                    \" * @return {string}\\n\" +\n+                    \" */\\n\" +  \n+                    \"internalName = function(param1, param2) {\" +\n+                      \"return param1 + param2;\" +\n+                    \"};\" +\n+                    \"goog.exportSymbol('externalName', internalName)\",\n+                    \"var externalName = function(param1, param2) {\\n}\");\n+  }\n+  \n   public void testExportSymbolWithConstructor() {\n     compileAndCheck(\"var internalName;\\n\" +\n                     \"/**\\n\" +\n                     \"/**\\n\" +\n                     \" * @constructor\\n\" +\n                     \" */\\n\" + \n+                    \"var externalName = function() {\\n}\");\n+  }\n+  \n+  public void testExportSymbolWithConstructorWithoutTypeCheck() {\n+    // For now, skipping type checking should prevent generating\n+    // annotations of any kind, so, e.g., @constructor is not preserved.\n+    // This is probably not ideal, but since JSDocInfo for functions is attached\n+    // to JSTypes and not Nodes (and no JSTypes are created when checkTypes\n+    // is false), we don't really have a choice.\n+    \n+    setRunCheckTypes(false);\n+    \n+    compileAndCheck(\"var internalName;\\n\" +\n+                    \"/**\\n\" +\n+                    \" * @constructor\\n\" +\n+                    \" */\\n\" +  \n+                    \"internalName = function() {\" +\n+                    \"};\" +\n+                    \"goog.exportSymbol('externalName', internalName)\",\n                     \"var externalName = function() {\\n}\");\n   }\n   \n      * type information.\n      */  \n     options.checkSymbols = true;\n-    options.checkTypes = true;\n+    options.checkTypes = runCheckTypes;\n     \n     JSSourceFile[] inputs = {\n       JSSourceFile.fromCode(\"testcode\",\n--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n         \"goog.method();g.method();\");\n   }\n \n+  public void testScopedFunctionReturnThis() {\n+    test(\"goog.scope(function() { \" +\n+         \"  var g = goog; g.f = function() { return this; };\" +\n+         \"});\",\n+         \"goog.f = function() { return this; };\");\n+  }\n+\n+  public void testScopedFunctionAssignsToVar() {\n+    test(\"goog.scope(function() { \" +\n+         \"  var g = goog; g.f = function(x) { x = 3; return x; };\" +\n+         \"});\",\n+         \"goog.f = function(x) { x = 3; return x; };\");\n+  }\n+\n+  public void testScopedFunctionThrows() {\n+    test(\"goog.scope(function() { \" +\n+         \"  var g = goog; g.f = function() { throw 'error'; };\" +\n+         \"});\",\n+         \"goog.f = function() { throw 'error'; };\");\n+  }\n+\n   public void testPropertiesNotChanged() {\n     testScopedNoChanges(\"var x = goog.dom;\", \"y.x();\");\n   }\n     testScopedFailure(\"return;\", ScopedAliases.GOOG_SCOPE_USES_RETURN);\n     testScopedFailure(\"var x = goog.dom; return;\",\n         ScopedAliases.GOOG_SCOPE_USES_RETURN);\n+  }\n+\n+  public void testScopedThrow() {\n+    testScopedFailure(\"throw 'error';\", ScopedAliases.GOOG_SCOPE_USES_THROW);\n   }\n \n   public void testUsedImproperly() {\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"found   : number\\n\" +\n         \"required: string\"\n         );\n+  }\n+\n+  public void testNoTypeCheck14() throws Exception {\n+    testTypes(\"/** @fileoverview \\n * @notypecheck */ function g() { }\" +\n+        \"g(1,2,3)\");\n   }\n \n   public void testImplicitCast() throws Exception {", "timestamp": 1276906739, "metainfo": ""}