{"sha": "fe58a5d1750bab2c5d1d0ef16102c1000e761bd8", "log": "Add version numbers to closure compiler.  Fixes issue 74.  R=johnlenz DELTA=56  (54 added, 0 deleted, 2 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=229045   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n import java.io.PrintStream;\n import java.util.List;\n import java.util.Map;\n+import java.util.ResourceBundle;\n import java.util.Set;\n import java.util.logging.Level;\n import java.util.regex.Matcher;\n         + \"a manifest for each module.\")\n     private String output_manifest = \"\";\n \n+    @Option(name = \"--version\",\n+        usage = \"Prints the compiler version to stderr.\")\n+    private boolean version = false;\n+\n     // Our own option parser to be backwards-compatible.\n     // It needs to be public because of the crazy reflection that args4j does.\n     public static class BooleanOptionHandler extends OptionHandler<Boolean> {\n \n   private final Flags flags = new Flags();\n \n+  private static final String configResource =\n+      \"com.google.javascript.jscomp.parsing.ParserConfig\";\n+\n   private boolean isConfigValid = false;\n \n   /**\n     } catch (CmdLineException e) {\n       err.println(e.getMessage());\n       isConfigValid = false;\n+    }\n+\n+    if (flags.version) {\n+      ResourceBundle config = ResourceBundle.getBundle(configResource);\n+      err.println(\n+          \"Closure Compiler (http://code.google.com/p/closure/compiler)\\n\" +\n+          \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" +\n+          \"Built on: \" + config.getString(\"compiler.date\"));\n+      err.flush();\n     }\n \n     if (!isConfigValid || flags.display_help) {\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n \n import junit.framework.TestCase;\n \n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n import java.util.List;\n \n /**\n   private Compiler lastCompiler = null;\n   private CommandLineRunner lastCommandLineRunner = null;\n   private List<Integer> exitCodes = null;\n+  private ByteArrayOutputStream outReader = null;\n+  private ByteArrayOutputStream errReader = null;\n \n   // If set to true, uses comparison by string instead of by AST.\n   private boolean useStringComparison = false;\n   public void setUp() throws Exception {\n     super.setUp();\n     lastCompiler = null;\n+    outReader = new ByteArrayOutputStream();\n+    errReader = new ByteArrayOutputStream();\n     useStringComparison = false;\n     useModules = ModulePattern.NONE;\n     args.clear();\n         builder.toString());\n   }\n \n+  public void testVersionFlag() {\n+    args.add(\"--version\");\n+    testSame(\"\");\n+    assertEquals(\n+        0,\n+        new String(errReader.toByteArray()).indexOf(\n+            \"Closure Compiler (http://code.google.com/p/closure/compiler)\\n\" +\n+            \"Version: HEAD\\n\" +\n+            \"Built on:\"));\n+  }\n+\n   /* Helper functions */\n \n   private void testSame(String original) {\n     }\n \n     String[] argStrings = args.toArray(new String[] {});\n-    return new CommandLineRunner(argStrings);\n+    return new CommandLineRunner(\n+        argStrings,\n+        new PrintStream(outReader),\n+        new PrintStream(errReader));\n   }\n \n   private Compiler compile(String[] original) {", "timestamp": 1284753380, "metainfo": ""}