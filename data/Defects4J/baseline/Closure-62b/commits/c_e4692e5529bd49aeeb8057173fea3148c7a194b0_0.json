{"sha": "e4692e5529bd49aeeb8057173fea3148c7a194b0", "log": "Drop extern declarations that are simply placeholders.  R=avd,dcc DELTA=165  (155 added, 0 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=54003   ", "commit": "\n--- a/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n+++ b/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n import com.google.javascript.rhino.Token;\n \n import java.util.Collection;\n+import java.util.List;\n import java.util.Map;\n \n /**\n             def = unknownDef;\n           }\n \n+          // TODO(johnlenz) : remove this stub dropping code if it becomes\n+          // illegal to have untyped stubs in the externs definitions.\n+          if (inExterns) {\n+            // We need special handling of untyped externs stubs here:\n+            //    the stub should be dropped if the name is provided elsewhere.\n+\n+            List<Definition> stubsToRemove = Lists.newArrayList();\n+            String qualifiedName = node.getQualifiedName();\n+            for (Definition prevDef : nameDefinitionMultimap.get(name)) {\n+              if (prevDef instanceof ExternalNameOnlyDefinition\n+                  && node.getJSDocInfo() == null) {\n+                String prevName = prevDef.getLValue().getQualifiedName();\n+                if (qualifiedName.equals(prevName)) {\n+                  // Drop this stub, there is a real definition.\n+                  stubsToRemove.add(prevDef);\n+                }\n+              }\n+            }\n+\n+            for (Definition prevDef : stubsToRemove) {\n+              nameDefinitionMultimap.remove(name, prevDef);\n+            }\n+          }\n+\n           nameDefinitionMultimap.put(name, def);\n           definitionSiteMap.put(node,\n                                 new DefinitionSite(node,\n         String name = getSimplifiedName(node);\n         if (name != null) {\n \n-          // Incomplete definition\n-          Definition definition = new ExternalNameOnlyDefinition(node);\n-          nameDefinitionMultimap.put(name, definition);\n-          definitionSiteMap.put(node,\n-                                new DefinitionSite(node,\n-                                                   definition,\n-                                                   traversal.getModule(),\n-                                                   traversal.inGlobalScope(),\n-                                                   inExterns));\n+          // TODO(johnlenz) : remove this code if it becomes illegal to have\n+          // stubs in the externs definitions.\n+\n+          // We need special handling of untyped externs stubs here:\n+          //    the stub should be dropped if the name is provided elsewhere.\n+          // We can't just drop the stub now as it needs to be used as the\n+          //    externs definition if no other definition is provided.\n+\n+          boolean dropStub = false;\n+          if (node.getJSDocInfo() == null) {\n+            String qualifiedName = node.getQualifiedName();\n+            for (Definition prevDef : nameDefinitionMultimap.get(name)) {\n+              String prevName = prevDef.getLValue().getQualifiedName();\n+              if (qualifiedName.equals(prevName)) {\n+                dropStub = true;\n+                break;\n+              }\n+            }\n+          }\n+\n+          if (!dropStub) {\n+            // Incomplete definition\n+            Definition definition = new ExternalNameOnlyDefinition(node);\n+            nameDefinitionMultimap.put(name, definition);\n+            definitionSiteMap.put(node,\n+                                  new DefinitionSite(node,\n+                                                     definition,\n+                                                     traversal.getModule(),\n+                                                     traversal.inGlobalScope(),\n+                                                     inExterns));\n+          }\n         }\n       }\n     }\n--- a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n+++ b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n   private static String kExterns =\n       CompilerTypeTestCase.DEFAULT_EXTERNS +\n       \"/**@nosideeffects*/function Error(){}\" +\n+\n       \"function externSef1(){}\" +\n+\n       \"/**@nosideeffects*/function externNsef1(){}\" +\n+\n       \"var externSef2 = function(){};\" +\n+\n       \"/**@nosideeffects*/var externNsef2 = function(){};\" +\n+\n       \"var externNsef3 = /**@nosideeffects*/function(){};\" +\n \n       \"var externObj;\" +\n+\n       \"externObj.sef1 = function(){};\" +\n+\n       \"/**@nosideeffects*/externObj.nsef1 = function(){};\" +\n+\n       \"externObj.nsef2 = /**@nosideeffects*/function(){};\" +\n \n       \"externObj.partialFn;\" +\n+\n       \"externObj.partialSharedFn;\" +\n \n       \"var externObj2;\" +\n+\n       \"externObj2.partialSharedFn = /**@nosideeffects*/function(){};\" +\n \n       \"/**@constructor*/function externSefConstructor(){}\" +\n+\n       \"externSefConstructor.prototype.sefFnOfSefObj = function(){};\" +\n+\n       \"externSefConstructor.prototype.nsefFnOfSefObj = \" +\n       \"  /**@nosideeffects*/function(){};\" +\n+\n       \"externSefConstructor.prototype.externShared = function(){};\" +\n \n       \"/**@constructor\\n@nosideeffects*/function externNsefConstructor(){}\" +\n+\n       \"externNsefConstructor.prototype.sefFnOfNsefObj = function(){};\" +\n+\n       \"externNsefConstructor.prototype.nsefFnOfNsefObj = \" +\n       \"  /**@nosideeffects*/function(){};\" +\n+\n       \"externNsefConstructor.prototype.externShared = \" +\n       \"  /**@nosideeffects*/function(){};\" +\n \n       \"  /**@nosideeffects*/function(){};\" +\n \n       \"externNsefConstructor.prototype.sharedPartialSef;\" +\n-      \"/**@nosideeffects*/externNsefConstructor.prototype.sharedPartialNsef\";\n+      \"/**@nosideeffects*/externNsefConstructor.prototype.sharedPartialNsef;\" +\n+\n+      // An externs definition with a stub before.\n+\n+      \"/**@constructor*/function externObj3(){}\" +\n+\n+      \"externObj3.prototype.propWithStubBefore;\" +\n+\n+      \"/**\\n\" +\n+      \" * @param {string} s id.\\n\" +\n+      \" * @return {string}\\n\" +\n+      \" * @nosideeffects\\n\" +\n+      \" */\\n\" +\n+      \"externObj3.prototype.propWithStubBefore = function(s) {};\" +\n+\n+      // An externs definition with a stub after.\n+\n+      \"/**@constructor*/function externObj4(){}\" +\n+\n+      \"/**\\n\" +\n+      \" * @param {string} s id.\\n\" +\n+      \" * @return {string}\\n\" +\n+      \" * @nosideeffects\\n\" +\n+      \" */\\n\" +\n+      \"externObj4.prototype.propWithStubAfter = function(s) {};\" +\n+\n+      \"externObj4.prototype.propWithStubAfter;\";\n \n   public PureFunctionIdentifierTest() {\n     super(kExterns);\n     }\n   }\n \n+  public void testAnnotationInExternStubs1() throws Exception {\n+    checkMarkedCalls(\"o.propWithStubBefore('a');\",\n+        ImmutableList.<String>of(\"o.propWithStubBefore\"));\n+  }\n+\n+  public void testAnnotationInExternStubs2() throws Exception {\n+    checkMarkedCalls(\"o.propWithStubAfter('a');\",\n+        ImmutableList.<String>of(\"o.propWithStubAfter\"));\n+  }\n+\n+  public void testAnnotationInExternStubs3() throws Exception {\n+    checkMarkedCalls(\"propWithAnnotatedStubAfter('a');\",\n+        ImmutableList.<String>of());\n+  }\n+\n+  public void testAnnotationInExternStubs4() throws Exception {\n+    // An externs definition with a stub that differs from the declaration.\n+    // Verify our assumption is valid about this.\n+    String externs =\n+      \"/**@constructor*/function externObj5(){}\\n\" +\n+\n+      \"externObj5.prototype.propWithAnnotatedStubAfter = function(s) {};\\n\" +\n+\n+      \"/**\\n\" +\n+      \" * @param {string} s id.\\n\" +\n+      \" * @return {string}\\n\" +\n+      \" * @nosideeffects\\n\" +\n+      \" */\\n\" +\n+      \"externObj5.prototype.propWithAnnotatedStubAfter;\\n\";\n+\n+    List<String> expected = ImmutableList.<String>of();\n+    testSame(externs,\n+        \"o.prototype.propWithAnnotatedStubAfter\",\n+        TypeValidator.DUP_VAR_DECLARATION, false);\n+    assertEquals(expected, noSideEffectCalls);\n+    noSideEffectCalls.clear();\n+  }\n+\n+  public void testAnnotationInExternStubs5() throws Exception {\n+    // An externs definition with a stub that differs from the declaration.\n+    // Verify our assumption is valid about this.\n+    String externs =\n+      \"/**@constructor*/function externObj5(){}\\n\" +\n+\n+      \"/**\\n\" +\n+      \" * @param {string} s id.\\n\" +\n+      \" * @return {string}\\n\" +\n+      \" * @nosideeffects\\n\" +\n+      \" */\\n\" +\n+      \"externObj5.prototype.propWithAnnotatedStubAfter = function(s) {};\\n\" +\n+\n+      \"/**\\n\" +\n+      \" * @param {string} s id.\\n\" +\n+      \" * @return {string}\\n\" +\n+      \" */\\n\" +\n+      \"externObj5.prototype.propWithAnnotatedStubAfter;\\n\";\n+\n+    List<String> expected = ImmutableList.<String>of();\n+    testSame(externs,\n+        \"o.prototype.propWithAnnotatedStubAfter\",\n+        TypeValidator.DUP_VAR_DECLARATION, false);\n+    assertEquals(expected, noSideEffectCalls);\n+    noSideEffectCalls.clear();\n+  }\n+\n   public void testNoSideEffectsSimple() throws Exception {\n     String prefix = \"function f(){\";\n     String suffix = \"} f()\";", "timestamp": 1279582045, "metainfo": ""}