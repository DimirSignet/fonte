{"sha": "31628adfc829bdd7b1607f0d9d99c2290b1c28cd", "log": "Adding VarCheck to incremental-build. This is a preliminary implementation and needs more refactoring once other passes are added.  R=nicksantos,johnlenz DELTA=157  (136 added, 0 deleted, 21 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1525   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     return inputsByName.get(name);\n   }\n \n+  /**\n+   * Removes an input file from AST.\n+   * @param name The name of the file to be removed.\n+   */\n+  protected void removeInput(String name) {\n+    CompilerInput input = getInput(name);\n+    if (input == null) {\n+      return;\n+    }\n+    inputsByName.remove(name);\n+    Node root = input.getAstRoot(this);\n+    if (root != null) {\n+      root.detachFromParent();\n+    }\n+  }\n+\n   @Override\n   public CompilerInput newExternInput(String name) {\n     if (inputsByName.containsKey(name)) {\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n   };\n \n   /** Inlines simple methods, like getters */\n-  private PassFactory inlineSimpleMethods =\n+  private final PassFactory inlineSimpleMethods =\n       new PassFactory(\"inlineSimpleMethods\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Kills dead assignments. */\n-  private PassFactory deadAssignmentsElimination =\n+  private final PassFactory deadAssignmentsElimination =\n       new PassFactory(\"deadAssignmentsElimination\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Inlines function calls. */\n-  private PassFactory inlineFunctions =\n+  private final PassFactory inlineFunctions =\n       new PassFactory(\"inlineFunctions\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Removes variables that are never used. */\n-  private PassFactory removeUnusedVars =\n+  private final PassFactory removeUnusedVars =\n       new PassFactory(\"removeUnusedVars\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   /**\n    * Move global symbols to a deeper common module\n    */\n-  private PassFactory crossModuleCodeMotion =\n+  private final PassFactory crossModuleCodeMotion =\n       new PassFactory(\"crossModuleCodeMotion\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   /**\n    * Move methods to a deeper common module\n    */\n-  private PassFactory crossModuleMethodMotion =\n+  private final PassFactory crossModuleMethodMotion =\n       new PassFactory(\"crossModuleMethodMotion\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   /**\n    * Specialize the initial module at the cost of later modules\n    */\n-  private PassFactory specializeInitialModule =\n+  private final PassFactory specializeInitialModule =\n       new PassFactory(\"specializeInitialModule\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/HotSwapCompilerPass.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.rhino.Node;\n+\n+/**\n+ * Interface for compiler passes that can be used in a hot-swap fashion.\n+ *\n+ * <p>The only method is {@code hotSwapScript} which runs this pass on\n+ * a subtree of the AST. Each pass that is intended to support hot-swap\n+ * style should implement this interface.\n+ *\n+ * <p>It is assumed that {@code Node} argument of {@code hotSwapScript} is the\n+ * root of a sub-tree in AST that represents a js file and so is of type\n+ * {@code Token.SCRIPT}. Also the global-scope is supposed to be updated based\n+ * on new js file prior to this call.\n+ *\n+ * @author bashir@google.com (Bashir Sadjad)\n+ */\n+public interface HotSwapCompilerPass {\n+\n+  /**\n+   * Process the JS with root node root. This is supposed to be significantly\n+   * faster compared to corresponding full-compiler passes.\n+   * @param root Root node corresponding to the file that is modified, should be\n+   *     of type {@code Token.SCRIPT}.\n+   * @param globalScope The global scope which is not necessarily types.\n+   */\n+  void hotSwapScript(Node root, Scope globalScope);\n+\n+}\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n  * that cross module boundaries respect declared module dependencies.\n  *\n  */\n-class VarCheck extends AbstractPostOrderCallback implements CompilerPass {\n+class VarCheck extends AbstractPostOrderCallback implements CompilerPass,\n+    HotSwapCompilerPass {\n+\n+  /** Name of the synthetic script that holds undefined variables. */\n+  static final String SYNTHETIC_VARS_DECLAR = \"{SyntheticVarsDeclar}\";\n \n   static final DiagnosticType UNDEFINED_VAR_ERROR = DiagnosticType.error(\n       \"JSC_UNDEFINED_VARIABLE\",\n   // Vars that still need to be declared in externs. These will be declared\n   // at the end of the pass, or when we see the equivalent var declared\n   // in the normal code.\n-  private Set<String> varsToDeclareInExterns = Sets.newHashSet();\n+  private final Set<String> varsToDeclareInExterns = Sets.newHashSet();\n \n   private final AbstractCompiler compiler;\n \n   private final boolean sanityCheck;\n \n   // Whether extern checks emit error.\n-  private boolean strictExternCheck;\n+  private final boolean strictExternCheck;\n \n   VarCheck(AbstractCompiler compiler) {\n     this(compiler, false);\n     for (String varName : varsToDeclareInExterns) {\n       createSynthesizedExternVar(varName);\n     }\n+  }\n+\n+  @Override\n+  public void hotSwapScript(Node root, Scope globalScope) {\n+    Preconditions.checkState(root.getType() == Token.SCRIPT);\n+    NodeTraversal t = new NodeTraversal(compiler, this);\n+    // Note we use the global scope to prevent wrong \"undefined-var errors\" on\n+    // variables that are defined in other js files.\n+    t.traverseWithScope(root, globalScope);\n+    // TODO(bashir) Check if we need to createSynthesizedExternVar like process.\n   }\n \n   @Override\n   private CompilerInput getSynthesizedExternsInput() {\n     if (synthesizedExternsInput == null) {\n       synthesizedExternsInput =\n-          compiler.newExternInput(\"{SyntheticVarsDeclar}\");\n+          compiler.newExternInput(SYNTHETIC_VARS_DECLAR);\n     }\n     return synthesizedExternsInput;\n   }", "timestamp": 1303406699, "metainfo": ""}