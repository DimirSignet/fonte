{"sha": "68e00612bc6a04357b638958f380ea6d4072ccf1", "log": "Replace returns with breaks when possible.  R=johnlenz DELTA=188  (183 added, 0 deleted, 5 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=208289   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n      * are not known yet due to the way we traverse the nodes.\n      */\n     for (cur = node, lastJump = node;\n-        !isBreakTarget(cur, parent, label);\n+        !isBreakTarget(cur, label);\n         cur = parent, parent = parent.getParent()) {\n       if (cur.getType() == Token.TRY && NodeUtil.hasFinally(cur)) {\n         if (lastJump == node) {\n    * Checks if target is actually the break target of labeled continue. The\n    * label can be null if it is an unlabeled break.\n    */\n-  private static boolean isBreakTarget(\n-      Node target, Node parent, String label) {\n-    return isBreakStructure(target, label != null) && matchLabel(parent, label);\n+  public static boolean isBreakTarget(Node target, String label) {\n+    return isBreakStructure(target, label != null) &&\n+      matchLabel(target.getParent(), label);\n   }\n \n   /**\n   /**\n    * Determines if the subtree might throw an exception.\n    */\n-  private static boolean mayThrowException(Node n) {\n+  public static boolean mayThrowException(Node n) {\n     switch (n.getType()) {\n       case Token.CALL:\n       case Token.GETPROP:\n       default:\n         return false;\n     }\n+  }\n+\n+  /**\n+   * Get the TRY block with a CATCH that would be run if n throws an exception.\n+   * @return The CATCH node or null if it there isn't a CATCH before the\n+   *     the function terminates.\n+   */\n+  static Node getExceptionHandler(Node n) {\n+    for (Node cur = n;\n+        cur.getType() != Token.SCRIPT && cur.getType() != Token.FUNCTION;\n+        cur = cur.getParent()) {\n+      Node catchNode = getCatchHandlerForBlock(cur);\n+      if (catchNode != null) {\n+        return catchNode;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Locate the catch BLOCK given the first block in a TRY.\n+   * @return The CATCH node or null there is no catch handler.\n+   */\n+  static Node getCatchHandlerForBlock(Node block) {\n+    if (block.getType() == Token.BLOCK &&\n+        block.getParent().getType() == Token.TRY &&\n+        block.getParent().getFirstChild() == block) {\n+      for (Node s = block.getNext(); s != null; s = s.getNext()) {\n+        if (NodeUtil.hasCatchHandler(s)) {\n+          return s.getFirstChild();\n+        }\n+      }\n+    }\n+    return null;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n    */\n   private Node tryReduceReturn(Node n) {\n     Node result = n.getFirstChild();\n+\n+    boolean possibleException = result != null &&\n+        ControlFlowAnalysis.mayThrowException(result);\n+\n+    // Try to use a substitute that with a break because it is shorter.\n+\n+    // First lets pretend it is a break with no labels.\n+    Node breakTarget = n;\n+    boolean safe = true;\n+\n+    for (;!ControlFlowAnalysis.isBreakTarget(breakTarget, null /* no label */);\n+        breakTarget = breakTarget.getParent()) {\n+      if (NodeUtil.isFunction(breakTarget) ||\n+          breakTarget.getType() == Token.SCRIPT) {\n+\n+          // We can switch the return to a break if the return value has\n+          // side effect and it must encounter a finally.\n+\n+          // example: return alert('a') -> finally { alert('b') } ->\n+          //          return alert('a')\n+          // prints a then b. If the first return is a break,\n+          // it prints b then a.\n+        safe = false;\n+        break;\n+      }\n+    }\n+\n+    Node follow = ControlFlowAnalysis.computeFollowNode(breakTarget);\n+\n+    // Skip pass all the finally blocks because both the break and return will\n+    // also trigger all the finally blocks. However, the order of execution is\n+    // slightly changed. Consider:\n+    //\n+    // return a() -> finally { b() } -> return a()\n+    //\n+    // which would call a() first. However, changing the first return to a\n+    // break will result in calling b().\n+    while (follow != null &&\n+        NodeUtil.isTryFinallyNode(follow.getParent(), follow)) {\n+      if (result != null &&\n+          // TODO(user): Use the new side effects API for more accuracy.\n+          (NodeUtil.canBeSideEffected(result) ||\n+           NodeUtil.mayHaveSideEffects(result))) {\n+        safe = false;\n+        break;\n+      }\n+      follow = ControlFlowAnalysis.computeFollowNode(follow);\n+    }\n+\n+    if (safe) {\n+      if (follow == null) {\n+        // When follow is null, this mean the follow of a break target is the\n+        // end of a function. This means a break is same as return.\n+        if (result == null) {\n+          n.setType(Token.BREAK);\n+          reportCodeChange();\n+          return n;\n+        }\n+\n+      } else if (follow.getType() == Token.RETURN &&\n+          (result == follow.getFirstChild() ||\n+           (result != null && follow.hasChildren() &&\n+            result.checkTreeEqualsSilent(follow.getFirstChild())) &&\n+            ControlFlowAnalysis.getExceptionHandler(n) ==\n+            ControlFlowAnalysis.getExceptionHandler(follow)\n+           )) {\n+        // When the follow is a return, if both doesn't return anything\n+        // or both returns the same thing. This mean we can replace it with a\n+        // break.\n+        n.removeChildren();\n+        n.setType(Token.BREAK);\n+        reportCodeChange();\n+        return n;\n+      }\n+      // If any of the above is executed, we must return because n is no longer\n+      // a \"return\" node.\n+    }\n+\n+    // TODO(user): consider cases such as if (x) { return 1} return 1;\n+\n     if (result != null) {\n       switch (result.getType()) {\n         case Token.VOID:\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n     // don't touch cases where either side doesn't return a value\n     foldSame(\"function(){if(x)return;else return 2-x}\");\n     foldSame(\"function(){if(x)return x;else return}\");\n+\n+    foldSame(\"function(){for(var x in y) { return x.y; } return k}\");\n   }\n \n   /** Try to minimize assignments */\n     fold(\"var x = new Error('20')\", \"var x = Error(\\\"20\\\")\");\n     fold(\"var x = new Array(20)\", \"var x = Array(20)\");\n   }\n-}\n+\n+  public void testSubsituteReturn() {\n+\n+    fold(\"function f() { while(x) { return }}\",\n+         \"function f() { while(x) { break }}\");\n+\n+    foldSame(\"function f() { while(x) { return 5 } }\");\n+\n+    foldSame(\"function f() { a: { return 5 } }\");\n+\n+    fold(\"function f() { while(x) { return 5}  return 5}\",\n+         \"function f() { while(x) { break }    return 5}\");\n+\n+    fold(\"function f() { while(x) { return x}  return x}\",\n+         \"function f() { while(x) { break }    return x}\");\n+\n+    fold(\"function f() { while(x) { if (y) { return }}} \",\n+         \"function f() { while(x) { if (y) { break  }}} \");\n+\n+    fold(\"function f() { while(x) { if (y) { return }} return} \",\n+         \"function f() { while(x) { if (y) { break  }} return} \");\n+\n+    fold(\"function f() { while(x) { if (y) { return 5 }} return 5} \",\n+         \"function f() { while(x) { if (y) { break    }} return 5} \");\n+\n+    // It doesn't matter if x is changed between them. We are still returning\n+    // x at whatever x value current holds. The whole x = 1 is skipped.\n+    fold(\"function f() { while(x) { if (y) { return x } x = 1} return x} \",\n+         \"function f() { while(x) { if (y) { break    } x = 1} return x} \");\n+\n+    // RemoveUnreachableCode would take care of the useless breaks.\n+    fold(\"function f() { while(x) { if (y) { return x } return x} return x}\",\n+         \"function f() { while(x) { if (y) { break    } break   } return x}\");\n+\n+    // A break here only breaks out of the inner loop.\n+    foldSame(\"function f() { while(x) { while (y) { return } } }\");\n+\n+    foldSame(\"function f() { while(1) { return 7}  return 5}\");\n+\n+\n+    foldSame(\"function f() {\" +\n+             \"  try { while(x) {return f()}} catch (e) { } return f()}\");\n+\n+    foldSame(\"function f() {\" +\n+             \"  try { while(x) {return f()}} finally {alert(1)} return f()}\");\n+\n+\n+    // Both returns has the same handler\n+    fold(\"function f() {\" +\n+         \"  try { while(x) { return f() } return f() } catch (e) { } }\",\n+         \"function f() {\" +\n+         \"  try { while(x) { break } return f() } catch (e) { } }\");\n+\n+    // We can't fold this because it'll change the order of when foo is called.\n+    foldSame(\"function f() {\" +\n+             \"  try { while(x) { return foo() } } finally { alert(1) } \"  +\n+             \"  return foo()}\");\n+\n+    // This is fine, we have no side effect in the return value.\n+    fold(\"function f() {\" +\n+         \"  try { while(x) { return 1 } } finally { alert(1) } return 1}\",\n+         \"function f() {\" +\n+         \"  try { while(x) { break    } } finally { alert(1) } return 1}\"\n+         );\n+\n+    foldSame(\"function f() { try{ return a } finally { a = 2 } return a; }\");\n+  }\n+}", "timestamp": 1283752642, "metainfo": ""}