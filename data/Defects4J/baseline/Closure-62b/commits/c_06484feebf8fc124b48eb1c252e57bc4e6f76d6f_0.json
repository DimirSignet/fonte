{"sha": "06484feebf8fc124b48eb1c252e57bc4e6f76d6f", "log": "always do type inference on the values of an object literal, even if we decide to bail out early and leave the literal itself alone.  R=johnlenz DELTA=30  (28 added, 1 deleted, 1 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=377   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n     JSType type = n.getJSType();\n     Preconditions.checkNotNull(type);\n \n+    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n+      scope = traverse(name.getFirstChild(), scope);\n+    }\n+\n     // Object literals can be reflected on other types, or changed with\n     // type casts.\n     // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n     for (Node name = n.getFirstChild(); name != null;\n          name = name.getNext()) {\n       Node value = name.getFirstChild();\n-      scope = traverse(value, scope);\n       String memberName = NodeUtil.getObjectLitKeyName(name);\n       if (memberName != null) {\n         JSType rawValueType =  name.getFirstChild().getJSType();\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"function g(x) { return x.isVisible; }\");\n   }\n \n+  public void testReflectObject1() throws Exception {\n+    testClosureTypes(\n+        \"var goog = {}; goog.reflect = {}; \" +\n+        \"goog.reflect.object = function(x, y){};\" +\n+        \"/** @constructor */ function A() {}\" +\n+        \"goog.reflect.object(A, {x: 3});\",\n+        null);\n+  }\n+\n+  public void testReflectObject2() throws Exception {\n+    testClosureTypes(\n+        \"var goog = {}; goog.reflect = {}; \" +\n+        \"goog.reflect.object = function(x, y){};\" +\n+        \"/** @param {string} x */ function f(x) {}\" +\n+        \"/** @constructor */ function A() {}\" +\n+        \"goog.reflect.object(A, {x: f(1 + 1)});\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n   public void testLends1() throws Exception {\n     testTypes(\n         \"function extend(x, y) {}\" +\n           Joiner.on(\", \").join(compiler.getWarnings()),\n           0, compiler.getWarningCount());\n     } else {\n-      assertEquals(descriptions.size(), compiler.getWarningCount());\n+      assertEquals(\n+          \"unexpected warning(s) : \" +\n+          Joiner.on(\", \").join(compiler.getWarnings()),\n+          descriptions.size(), compiler.getWarningCount());\n       for (int i = 0; i < descriptions.size(); i++) {\n         assertEquals(descriptions.get(i),\n             compiler.getWarnings()[i].description);", "timestamp": 1296239086, "metainfo": ""}