{"sha": "ebb59a97610015bc41bda7f458dd1428a3a3e335", "log": "Change on 2010/04/22 by nick          fix the extern definition of Window.prototype.stop          R=siggy         DELTA=1  (0 added, 0 deleted, 1 changed)  Change on 2010/04/22 by john          \"Anonymous function\" is a confusing term for functions with names.         Properly we are usually distinguishing between functions statements         (function declarations) and function expressions.          R=alan         DELTA=172  (7 added, 14 deleted, 151 changed)  Change on 2010/04/22 by john          Standardize the definition of setTimeout/setInterval.         Fix for Issue 137          R=nick         DELTA=6  (2 added, 2 deleted, 2 changed)  Change on 2010/04/22 by mark          Various delegate fixes.          Give the delegate proxy a name unique from the delegate base so that         InstanceObjectType#equals distinguishes them. This is necessary for         AmbiguateProperties to work.          Fix the prototype of the delegate proxy. This makes         DisambiguateProperties continue to work.          Add superclass methods of the delegate base to the delegate proxy.           R=andrew,nada         DELTA=526  (383 added, 104 deleted, 39 changed)  Change on 2010/04/23 by john          Allow variable inlining of function statements. For simplicity  limited to functions defined before first use.          R=nick         DELTA=79  (49 added, 3 deleted, 27 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=hakjvx   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckRequiresForConstructors.java\n+++ b/src/com/google/javascript/jscomp/CheckRequiresForConstructors.java\n           }\n           break;\n         case Token.FUNCTION:\n-          if (NodeUtil.isFunctionAnonymous(n)) {\n+          if (NodeUtil.isFunctionExpression(n)) {\n             if (parent.getType() == Token.NAME) {\n               String functionName = parent.getString();\n               info = (JSDocInfo) parent.getProp(Node.JSDOC_INFO_PROP);\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n \n   /**\n    * Function name for abstract methods. An abstract method can be assigned to\n-   * an interface method instead of an anonymous function in order to avoid\n+   * an interface method instead of an function expression in order to avoid\n    * linter warnings produced by assigning a function without a return value\n    * where a return value is expected.\n    * @return function name.\n   /**\n    * Defines the delegate proxy properties. Their types depend on properties of\n    * the delegate base methods.\n+   *\n+   * @param delegateProxyMap Map from delegate proxy prototype to delegate base\n+   *     constructor.\n    */\n   public void defineDelegateProxyProperties(\n       JSTypeRegistry registry, Scope scope,\n-      Map<ObjectType, ObjectType> delegateProxyMap);\n+      Map<ObjectType, FunctionType> delegateProxyMap);\n \n   /**\n    * Gets the name of the global object.\n--- a/src/com/google/javascript/jscomp/CollapseAnonymousFunctions.java\n+++ b/src/com/google/javascript/jscomp/CollapseAnonymousFunctions.java\n import com.google.javascript.rhino.Token;\n \n /**\n- * Collapses anonymous function declarations into named function declarations,\n+ * Collapses anonymous function expressions into named function declarations,\n  * i.e. the following:\n  *\n  * <pre>\n--- a/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n   @Override\n   public void defineDelegateProxyProperties(\n       JSTypeRegistry registry, Scope scope,\n-      Map<ObjectType, ObjectType> delegateProxyMap) {\n+      Map<ObjectType, FunctionType> delegateProxyMap) {\n     // do nothing.\n   }\n \n--- a/src/com/google/javascript/jscomp/DefinitionsRemover.java\n+++ b/src/com/google/javascript/jscomp/DefinitionsRemover.java\n     if (NodeUtil.isVarDeclaration(n) && n.hasChildren()) {\n       return new VarDefinition(n);\n     } else if(NodeUtil.isFunction(parent) && parent.getFirstChild() == n) {\n-      if (!NodeUtil.isAnonymousFunction(parent)) {\n+      if (!NodeUtil.isFunctionExpression(parent)) {\n         return new NamedFunctionDefinition(parent);\n       } else if (!n.getString().equals(\"\")) {\n-        return new AnonymousFunctionDefinition(parent);\n+        return new FunctionExpressionDefinition(parent);\n       }\n     } else if (NodeUtil.isAssign(parent) && parent.getFirstChild() == n) {\n       return new AssignmentDefinition(parent);\n    * Represents a function expression that acts as a rhs.  The defined\n    * name is only reachable from within the function.\n    */\n-  static final class AnonymousFunctionDefinition extends FunctionDefinition {\n-    AnonymousFunctionDefinition(Node node) {\n+  static final class FunctionExpressionDefinition extends FunctionDefinition {\n+    FunctionExpressionDefinition(Node node) {\n       super(node);\n       Preconditions.checkArgument(\n-          NodeUtil.isAnonymousFunction(node));\n+          NodeUtil.isFunctionExpression(node));\n     }\n \n     @Override\n--- a/src/com/google/javascript/jscomp/FunctionNames.java\n+++ b/src/com/google/javascript/jscomp/FunctionNames.java\n   @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, functionListExtractor);\n-    AnonymousFunctionNamer namer = new AnonymousFunctionNamer(functionMap);\n+    FunctionExpressionNamer namer = new FunctionExpressionNamer(functionMap);\n     AnonymousFunctionNamingCallback namingCallback =\n         new AnonymousFunctionNamingCallback(namer);\n     NodeTraversal.traverse(compiler, root, namingCallback);\n     }\n   }\n \n-  private static class AnonymousFunctionNamer\n+  private static class FunctionExpressionNamer\n       implements AnonymousFunctionNamingCallback.FunctionNamer {\n     private static final char DELIMITER = '.';\n     private static final NodeNameExtractor extractor =\n         new NodeNameExtractor(DELIMITER);\n     private final Map<Node, FunctionRecord> functionMap;\n \n-    AnonymousFunctionNamer(Map<Node, FunctionRecord> functionMap) {\n+    FunctionExpressionNamer(Map<Node, FunctionRecord> functionMap) {\n       this.functionMap = functionMap;\n     }\n \n--- a/src/com/google/javascript/jscomp/FunctionRewriter.java\n+++ b/src/com/google/javascript/jscomp/FunctionRewriter.java\n \n     @Override\n     public Node reduce(Node node) {\n-      if (!NodeUtil.isAnonymousFunction(node)) {\n+      if (!NodeUtil.isFunctionExpression(node)) {\n         return node;\n       }\n \n \n     @Override\n     public Node reduce(Node node) {\n-      if (!NodeUtil.isAnonymousFunction(node)) {\n+      if (!NodeUtil.isFunctionExpression(node)) {\n         return node;\n       }\n \n \n     @Override\n     public Node reduce(Node node) {\n-      if (!NodeUtil.isAnonymousFunction(node)) {\n+      if (!NodeUtil.isFunctionExpression(node)) {\n         return node;\n       }\n \n \n     @Override\n     public Node reduce(Node node) {\n-      if (!NodeUtil.isAnonymousFunction(node)) {\n+      if (!NodeUtil.isFunctionExpression(node)) {\n         return node;\n       }\n \n \n     @Override\n     public Node reduce(Node node) {\n-      if (!NodeUtil.isAnonymousFunction(node)) {\n+      if (!NodeUtil.isFunctionExpression(node)) {\n         return node;\n       }\n \n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n               case Token.FUNCTION:\n                 Node gramps = parent.getParent();\n                 if (gramps == null ||\n-                    NodeUtil.isFunctionAnonymous(parent)) return;\n+                    NodeUtil.isFunctionExpression(parent)) return;\n                 isSet = true;\n                 type = Name.Type.FUNCTION;\n                 break;\n--- a/src/com/google/javascript/jscomp/InferJSDocInfo.java\n+++ b/src/com/google/javascript/jscomp/InferJSDocInfo.java\n  * Foo.prototype.bar = goog.abstractMethod;\n  * </code>\n  * the JSDocInfo will appear in two places in the type system: in the 'bar'\n- * slot of Foo.prototype, and on the anonymous function type created by\n+ * slot of Foo.prototype, and on the function expression type created by\n  * this expression.\n  *\n  * @author nicksantos@google.com (Nick Santos)\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n   private final FunctionInjector injector;\n \n   private final boolean blockFunctionInliningEnabled;\n-  private final boolean inlineAnonymousFunctionExpressions;\n+  private final boolean inlineFunctionExpressions;\n   private final boolean inlineGlobalFunctions;\n   private final boolean inlineLocalFunctions;\n \n       Supplier<String> safeNameIdSupplier,\n       boolean inlineGlobalFunctions,\n       boolean inlineLocalFunctions,\n-      boolean inlineAnonymousFunctionExpressions,\n+      boolean inlineFunctionExpressions,\n       boolean blockFunctionInliningEnabled,\n       boolean enableExpressionDecomposition) {\n     Preconditions.checkArgument(compiler != null);\n \n     this.inlineGlobalFunctions = inlineGlobalFunctions;\n     this.inlineLocalFunctions = inlineLocalFunctions;\n-    this.inlineAnonymousFunctionExpressions =\n-      inlineAnonymousFunctionExpressions;\n+    this.inlineFunctionExpressions =\n+      inlineFunctionExpressions;\n     this.blockFunctionInliningEnabled = blockFunctionInliningEnabled;\n \n     this.injector = new FunctionInjector(\n         NodeTraversal nodeTraversal, Node n, Node parent) {\n       // Don't traverse into function bodies\n       // if we aren't inlining local functions.\n-      return inlineLocalFunctions || inlineAnonymousFunctionExpressions\n+      return inlineLocalFunctions || inlineFunctionExpressions\n          || parent == null || NodeUtil.isControlStructure(parent)\n          || NodeUtil.isStatementBlock(parent);\n     }\n           || (!t.inGlobalScope() && inlineLocalFunctions)) {\n         findNamedFunctions(t, n, parent);\n \n-        if (inlineAnonymousFunctionExpressions) {\n-          findAnonymousFunctionExpressions(t, n);\n+        if (inlineFunctionExpressions) {\n+          findFunctionExpressions(t, n);\n         }\n       }\n     }\n       }\n \n       switch (n.getType()) {\n-        // Anonymous functions in the form of:\n+        // Functions expressions in the form of:\n         //   var fooFn = function(x) { return ... }\n         case Token.VAR:\n           // TODO(johnlenz): Make this a Preconditions check.\n         case Token.FUNCTION:\n           Preconditions.checkState(NodeUtil.isStatementBlock(parent)\n               || parent.getType() == Token.LABEL);\n-          if (!NodeUtil.isFunctionAnonymous(n)) {\n+          if (!NodeUtil.isFunctionExpression(n)) {\n             Function fn = new NamedFunction(n);\n             maybeAddFunction(fn, t.getModule());\n           }\n     }\n \n     /**\n-     * Find anonymous functions that are called directly in the form of\n+     * Find function expressions that are called directly in the form of\n      *   (function(a,b,...){...})(a,b,...)\n      * or\n      *   (function(a,b,...){...}).call(this,a,b, ...)\n      */\n-    public void findAnonymousFunctionExpressions(NodeTraversal t, Node n) {\n+    public void findFunctionExpressions(NodeTraversal t, Node n) {\n       switch (n.getType()) {\n-        // Anonymous functions in the form of:\n+        // Functions expressions in the form of:\n         //   (function(){})();\n         case Token.CALL:\n           Node fnNode = null;\n \n           // If a interesting function was discovered, add it.\n           if (fnNode != null) {\n-            Function fn = new AnonymousFunction(fnNode, callsSeen++);\n+            Function fn = new FunctionExpression(fnNode, callsSeen++);\n             maybeAddFunction(fn, t.getModule());\n             anonFns.put(fnNode, fn.getName());\n           }\n     }\n   }\n \n-  /** Interface for dealing with named and anonymous functions equally */\n+  /** \n+   * Interface for dealing with function declarations and function \n+   * expressions equally \n+   */\n   private static interface Function {\n     /** Gets the name of the function */\n     public String getName();\n     }\n   }\n \n-  /** AnonymousFunction implementation of the Function interface */\n-  private static class AnonymousFunction implements Function {\n+  /** FunctionExpression implementation of the Function interface */\n+  private static class FunctionExpression implements Function {\n     private final Node fn;\n     private final String fakeName;\n \n-    public AnonymousFunction(Node fn, int index) {\n+    public FunctionExpression(Node fn, int index) {\n       this.fn = fn;\n       // A number is not a valid function javascript indentifier\n       // so we don't need to worry about collisions.\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n                         Reference init, Reference reference) {\n       Node value = init.getAssignedValue();\n       Preconditions.checkState(value != null);\n+      // Check for function declarations before the value is moved in the AST.\n+      boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(value);\n \n       inlineValue(v, reference, value.detachFromParent());\n       if (declaration != init) {\n         Preconditions.checkState(expressRoot.getType() == Token.EXPR_RESULT);\n         NodeUtil.removeChild(expressRoot.getParent(), expressRoot);\n       }\n-      removeDeclaration(declaration);\n+\n+      // Function declarations have already been removed.\n+      if (!isFunctionDeclaration) {\n+        removeDeclaration(declaration);\n+      } else {\n+        compiler.reportCodeChange();\n+      }\n     }\n \n     /**\n       Node value = init.getAssignedValue();\n       if (value == null) {\n         // This constant is either externally defined or initialized indirectly\n-        // (e.g. in an anonymous function used to hide\n+        // (e.g. in an function expression used to hide\n         // temporary variables), so the constant is ineligible for inlining.\n         return false;\n       }\n      * If the value is a literal, we can cross more boundaries to inline it.\n      */\n     private boolean canMoveAggressively(Node value) {\n-      // Anonymous functions and other mutable objects can move within\n+      // Function expressions and other mutable objects can move within\n       // the same basic block.\n       return NodeUtil.isLiteralValue(value)\n           || value.getType() == Token.FUNCTION;\n     }\n \n     /**\n-     * @return true if the reference is a normal VAR declaration (only normal\n-     * VARs can be inlined).\n+     * @return true if the reference is a normal VAR or FUNCTION declaration.\n      */\n     private boolean isValidDeclaration(Reference declaration) {\n-      return declaration.getParent().getType() == Token.VAR\n-          && declaration.getGrandparent().getType() != Token.FOR;\n-    }\n-\n-    /**\n-     * @return Whether\n+      return (declaration.getParent().getType() == Token.VAR\n+          && declaration.getGrandparent().getType() != Token.FOR)\n+          || NodeUtil.isFunctionDeclaration(declaration.getParent());\n+    }\n+\n+    /**\n+     * @return Whether there is a initial value.\n      */\n     private boolean isValidInitialization(Reference initialization) {\n       if (initialization == null) {\n         return false;\n       } else if (initialization.isDeclaration()) {\n-        // The reference is a normal VAR declaration with\n-        return initialization.getNameNode().getFirstChild() != null;\n+        // The reference is a FUNCTION declaration or normal VAR declaration\n+        // with a value.\n+        return NodeUtil.isFunctionDeclaration(initialization.getParent())\n+            || initialization.getNameNode().getFirstChild() != null;\n       } else {\n         Node parent = initialization.getParent();\n         Preconditions.checkState(\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n         }\n       } else {\n         // No named dependency scope found.  Unfortunately that might\n-        // mean that the expression is a child of an anonymous\n-        // function or assignment with a complex lhs.  In those cases,\n+        // mean that the expression is a child of an function expression\n+        // or assignment with a complex lhs.  In those cases,\n         // protect this node by creating a reference to WINDOW.\n         for (Node ancestor : n.getAncestors()) {\n           if (NodeUtil.isAssignmentOp(ancestor) ||\n \n   /**\n    * Get dependency scope defined by the enclosing function, or null.\n-   * If enclosing function is anonymous, determine scope based on its\n-   * parent if the parent node is a variable declaration or\n+   * If enclosing function is a function expression, determine scope based on\n+   * its parent if the parent node is a variable declaration or\n    * assignment.\n    */\n   private NameInformation getEnclosingFunctionDependencyScope(NodeTraversal t) {\n       return ref;\n     }\n \n-    // anonymous function.  try to get a name from the parent var\n+    // Function expression.  try to get a name from the parent var\n     // declaration or assignment.\n     Node parent = function.getParent();\n     if (parent != null) {\n--- a/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n   }\n \n   /**\n-   * Find the first containing function that's not an anonymous\n+   * Find the first containing function that's not an function expression\n    * closure.\n    */\n   private Name getNamedContainingFunction() {\n--- a/src/com/google/javascript/jscomp/NodeTraversal.java\n+++ b/src/com/google/javascript/jscomp/NodeTraversal.java\n \n     final Node fnName = n.getFirstChild();\n \n-    boolean anonymous = parent != null && NodeUtil.isFunctionAnonymous(n);\n-\n-    if (!anonymous) {\n-      // Named functions are parent of the containing scope.\n+    boolean isFunctionExpression = (parent != null)\n+        && NodeUtil.isFunctionExpression(n);\n+\n+    if (!isFunctionExpression) {\n+      // Functions declarations are in the scope containing the declaration.\n       traverseBranch(fnName, n);\n     }\n \n     curNode = n;\n     pushScope(n);\n \n-    if (anonymous) {\n-      // Anonymous function names are parent of the contained scope.\n+    if (isFunctionExpression) {\n+      // Function expression names are only accessible within the function\n+      // scope.\n       traverseBranch(fnName, n);\n     }\n \n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    * <li>{@code var name2 = function name1() ...}</li>\n    * <li>{@code qualified.name2 = function name1() ...}</li>\n    * </ul>\n-   * In two last cases with named anonymous functions, the second name is\n+   * In two last cases with named function expressions, the second name is\n    * returned (the variable of qualified name).\n    *\n    * @param n a node whose type is {@link Token#FUNCTION}\n         break;\n \n       case Token.FUNCTION:\n-        // Anonymous functions don't have side-effects, but named ones\n-        // change the namespace. Therefore, we check if the function has\n-        // a name. Either way, we don't need to check the children, since\n-        // they aren't executed at declaration time.\n-        //\n-        return !isFunctionAnonymous(n);\n+        // Function expressions don't have side-effects, but function\n+        // declarations change the namespace. Either way, we don't need to\n+        // check the children, since they aren't executed at declaration time.\n+        return !isFunctionExpression(n);\n \n       case Token.NEW:\n         if (checkForNewObjects) {\n         return true;\n \n       case Token.FUNCTION:\n-        // Anonymous functions definitions are not changed by side-effects,\n-        // and named functions are not part of expressions.\n-        Preconditions.checkState(isAnonymousFunction(n));\n+        // Function expression are not changed by side-effects,\n+        // and function declarations are not part of expressions.\n+        Preconditions.checkState(isFunctionExpression(n));\n         return false;\n     }\n \n   static boolean isStatement(Node n) {\n     Node parent = n.getParent();\n     // It is not possible to determine definitely if a node is a statement\n-    // or not if it is not part of the AST.  A FUNCTION node, for instance,\n-    // is either part of an expression (as a anonymous function) or as\n-    // a statement.\n+    // or not if it is not part of the AST.  A FUNCTION node can be\n+    // either part of an expression or a statement.\n     Preconditions.checkState(parent != null);\n     switch (parent.getType()) {\n       case Token.SCRIPT:\n \n   /**\n    * @return Whether the name is a reference to a variable, function or\n-   *       function parameter (not a label or a empty anonymous function name).\n+   *       function parameter (not a label or a empty function expression name).\n    */\n   static boolean isReferenceName(Node n) {\n     return isName(n) && !n.getString().isEmpty();\n   /**\n    * Is this node a function declaration? A function declaration is a function\n    * that has a name that is added to the current scope (i.e. a function that\n-   * is not anonymous; see {@link #isFunctionAnonymous}).\n+   * is not part of a expression; see {@link #isFunctionExpression}).\n    */\n   static boolean isFunctionDeclaration(Node n) {\n-    return n.getType() == Token.FUNCTION && !isFunctionAnonymous(n);\n+    return n.getType() == Token.FUNCTION && isStatement(n);\n   }\n \n   /**\n             || n.getParent().getParent().getType() == Token.FUNCTION);\n   }\n \n-\n-  /**\n-   * Is this node an anonymous function? An anonymous function is one that has\n-   * either no name or a name that is not added to the current scope (see\n-   * {@link #isFunctionAnonymous}).\n-   */\n-  static boolean isAnonymousFunction(Node n) {\n-    return n.getType() == Token.FUNCTION && isFunctionAnonymous(n);\n-  }\n-\n-  /**\n-   * Is a FUNCTION node an anonymous function? An anonymous function is one that\n-   * has either no name or a name that is not added to the current scope.\n-   *\n-   * <p>Some examples of anonymous functions:\n+  /**\n+   * Is a FUNCTION node an function expression? An function expression is one\n+   * that has either no name or a name that is not added to the current scope.\n+   *\n+   * <p>Some examples of function expressions:\n    * <pre>\n-   * function () {}\n+   * (function () {})\n    * (function f() {})()\n    * [ function f() {} ]\n    * var f = function f() {};\n    * for (function f() {};;) {}\n    * </pre>\n    *\n-   * <p>Some examples of functions that are <em>not</em> anonymous:\n+   * <p>Some examples of functions that are <em>not</em> expressions:\n    * <pre>\n    * function f() {}\n    * if (x); else function f() {}\n    * for (;;) { function f() {} }\n    * </pre>\n    *\n-   * @param n A FUNCTION node\n-   * @return Whether n is an anonymous function\n-   */\n-  static boolean isFunctionAnonymous(Node n) {\n-    return !isStatement(n);\n+   * @param n A node\n+   * @return Whether n is an function used within an expression.\n+   */\n+  static boolean isFunctionExpression(Node n) {\n+    return n.getType() == Token.FUNCTION && !isStatement(n);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n      */\n     private void normalizeFunctionDeclaration(Node n) {\n       Preconditions.checkState(n.getType() == Token.FUNCTION);\n-      if (!NodeUtil.isFunctionAnonymous(n)\n+      if (!NodeUtil.isFunctionExpression(n)\n           && !NodeUtil.isHoistedFunctionDeclaration(n)) {\n         rewriteFunctionDeclaration(n);\n       }\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n         // If this is a declaration of a provided named function, this is an\n         // error. Hosited functions will explode if the're provided.\n         if (t.inGlobalScope() &&\n-            !NodeUtil.isFunctionAnonymous(n)) {\n+            !NodeUtil.isFunctionExpression(n)) {\n           String name = n.getFirstChild().getString();\n           ProvidedName pn = providedNames.get(name);\n           if (pn != null) {\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n     }\n \n    /**\n-    * @return For an assignment or variable declaration return the assigned\n-    * value, otherwise null.\n+    * @return For an assignment, variable declaration, or function declaration \n+    * return the assigned value, otherwise null.\n     */\n     Node getAssignedValue() {\n-      return NodeUtil.getAssignedValue(getNameNode());\n+      return (parent.getType() == Token.FUNCTION)\n+          ? parent : NodeUtil.getAssignedValue(getNameNode());\n     }\n \n     BasicBlock getBasicBlock() {\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n \n   private final boolean removeGlobals;\n \n-  private boolean preserveAnonymousFunctionNames;\n+  private boolean preserveFunctionExpressionNames;\n \n   /**\n    * Keeps track of what variables we've warned about, so that we don't do it\n   RemoveUnusedVars(\n       AbstractCompiler compiler,\n       boolean removeGlobals,\n-      boolean preserveAnonymousFunctionNames) {\n+      boolean preserveFunctionExpressionNames) {\n     compiler_ = compiler;\n     this.removeGlobals = removeGlobals;\n-    this.preserveAnonymousFunctionNames = preserveAnonymousFunctionNames;\n+    this.preserveFunctionExpressionNames = preserveFunctionExpressionNames;\n   }\n \n   /**\n       // Otherwise we traverse into the function only when we encounter\n       // a reference to it (see markReferencedVar())\n       case Token.FUNCTION:\n-        // If it's an exported function, or an anonymous function, assume\n+        // If it's an exported function, or an function expression, assume\n         // that it'll be called.\n-        if (NodeUtil.isFunctionAnonymous(n) ||\n+        if (NodeUtil.isFunctionExpression(n) ||\n             compiler_.getCodingConvention().isExported(\n                 n.getFirstChild().getString())) {\n           traverseFunction(n, scope);\n             parent.getType() == Token.FUNCTION) {\n           // Don't remove function arguments here. That's a special case\n           // that's taken care of in removeUnreferencedFunctionArgs.\n-        } else if (toRemove.getType() == Token.FUNCTION &&\n-            NodeUtil.isFunctionAnonymous(toRemove)) {\n-          if (!preserveAnonymousFunctionNames) {\n+        } else if (NodeUtil.isFunctionExpression(toRemove)) {\n+          if (!preserveFunctionExpressionNames) {\n             toRemove.getFirstChild().setString(\"\");\n             compiler_.reportCodeChange();\n           }\n--- a/src/com/google/javascript/jscomp/RenameVars.java\n+++ b/src/com/google/javascript/jscomp/RenameVars.java\n   private final boolean localRenamingOnly;\n \n   /**\n-   * Whether anonymous function names should be preserved. Typically, for\n+   * Whether function expression names should be preserved. Typically, for\n    * debugging purposes.\n    * @see NameAnonymousFunctions\n    */\n-  private boolean preserveAnonymousFunctionNames;\n+  private boolean preserveFunctionExpressionNames;\n \n   /** Generate pseudo names for variables for debugging purposes */\n   private boolean generatePseudoNames;\n   RenameVars(AbstractCompiler compiler,\n       String prefix,\n       boolean localRenamingOnly,\n-      boolean preserveAnonymousFunctionNames,\n+      boolean preserveFunctionExpressionNames,\n       boolean generatePseudoNames,\n       VariableMap prevUsedRenameMap,\n       @Nullable char[] reservedCharacters,\n     this.compiler = compiler;\n     this.prefix = prefix == null ? \"\" : prefix;\n     this.localRenamingOnly = localRenamingOnly;\n-    this.preserveAnonymousFunctionNames = preserveAnonymousFunctionNames;\n+    this.preserveFunctionExpressionNames = preserveFunctionExpressionNames;\n     this.generatePseudoNames = generatePseudoNames;\n     this.prevUsedRenameMap = prevUsedRenameMap;\n     this.reservedCharacters = reservedCharacters;\n         return;\n       }\n \n-      // Are we renaming anonymous function names?\n-      if (preserveAnonymousFunctionNames\n+      // Are we renaming function expression names?\n+      if (preserveFunctionExpressionNames\n           && var != null\n-          && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n+          && NodeUtil.isFunctionExpression(var.getParentNode())) {\n         reservedNames.add(name);\n         return;\n       }\n--- a/src/com/google/javascript/jscomp/SuspiciousPropertiesCheck.java\n+++ b/src/com/google/javascript/jscomp/SuspiciousPropertiesCheck.java\n           String name = n.getString();\n \n           // Avoid anonymous functions\n-          if (name.length() > 0) {\n+          if (!name.isEmpty()) {\n             // Only count globals\n             Scope.Var var = t.getScope().getVar(name);\n             if (var != null && !var.isLocal()) {\n--- a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n       // Bleed the function name into the scope, if it hasn't\n       // been declared in the outer scope.\n       String fnName = fnNameNode.getString();\n-      if (!fnName.isEmpty() && NodeUtil.isFunctionAnonymous(n)) {\n+      if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n         declareVar(fnName, fnNameNode, n, null, null, n);\n       }\n \n         return;\n \n       case Token.FUNCTION:\n-        if (NodeUtil.isFunctionAnonymous(n)) {\n+        if (NodeUtil.isFunctionExpression(n)) {\n           return;\n         }\n \n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n                 JSType jArgumentType = getJSType(jArgument);\n                 if (jArgument.getType() == Token.FUNCTION &&\n                     jArgumentType instanceof FunctionType) {\n-                  // If it's an anonymous function, update the type of this\n+                  // If it's an function expression, update the type of this\n                   // using the actual type of T.\n                   FunctionType jArgumentFnType =(FunctionType) jArgumentType;\n                   if (jArgumentFnType.getTypeOfThis().isUnknownType()) {\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n   private final TypeValidator validator;\n   private final CodingConvention codingConvention;\n   private final JSTypeRegistry typeRegistry;\n-  private Map<ObjectType, ObjectType> delegateProxyMap = Maps.newHashMap();\n+  private Map<ObjectType, FunctionType> delegateProxyMap = Maps.newHashMap();\n \n   /**\n    * Defer attachment of types to nodes until all type names\n           DelegateRelationship delegateRelationship =\n               codingConvention.getDelegateRelationship(n);\n           if (delegateRelationship != null) {\n-            ObjectType delegatorObject = ObjectType.cast(\n-                typeRegistry.getType(delegateRelationship.delegator));\n-            ObjectType delegateBaseObject = ObjectType.cast(\n-                typeRegistry.getType(delegateRelationship.delegateBase));\n-            ObjectType delegateSuperObject = ObjectType.cast(\n-                typeRegistry.getType(\n-                    codingConvention.getDelegateSuperclassName()));\n-            if (delegatorObject != null &&\n-                delegateBaseObject != null &&\n-                delegateSuperObject != null) {\n-              FunctionType delegatorCtor = delegatorObject.getConstructor();\n-              FunctionType delegateBaseCtor =\n-                  delegateBaseObject.getConstructor();\n-              FunctionType delegateSuperCtor =\n-                  delegateSuperObject.getConstructor();\n-\n-              if (delegatorCtor != null && delegateBaseCtor != null &&\n-                  delegateSuperCtor != null) {\n-                FunctionParamBuilder functionParamBuilder =\n-                    new FunctionParamBuilder(typeRegistry);\n-                functionParamBuilder.addRequiredParams(\n-                    typeRegistry.getNativeType(U2U_CONSTRUCTOR_TYPE));\n-                FunctionType findDelegate = typeRegistry.createFunctionType(\n-                    typeRegistry.createDefaultObjectUnion(\n-                        delegateBaseObject),\n-                    functionParamBuilder.build());\n-\n-                FunctionType delegateProxy =\n-                    typeRegistry.createConstructorType(\n-                        delegateBaseObject.getReferenceName(), null, null,\n-                        null);\n-                delegateProxy.setPrototypeBasedOn(delegateBaseCtor);\n-\n-                codingConvention.applyDelegateRelationship(\n-                    delegateSuperObject, delegateBaseObject, delegatorObject,\n-                    delegateProxy, findDelegate);\n-                delegateProxyMap.put(\n-                    delegateProxy.getPrototype(),\n-                    delegateBaseCtor.getPrototype());\n-              }\n-            }\n+            applyDelegateRelationship(delegateRelationship);\n           }\n \n           ObjectLiteralCast objectLiteralCast =\n             maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n           }\n           break;\n+      }\n+    }\n+\n+    private void applyDelegateRelationship(\n+        DelegateRelationship delegateRelationship) {\n+      ObjectType delegatorObject = ObjectType.cast(\n+          typeRegistry.getType(delegateRelationship.delegator));\n+      ObjectType delegateBaseObject = ObjectType.cast(\n+          typeRegistry.getType(delegateRelationship.delegateBase));\n+      ObjectType delegateSuperObject = ObjectType.cast(\n+          typeRegistry.getType(codingConvention.getDelegateSuperclassName()));\n+      if (delegatorObject != null &&\n+          delegateBaseObject != null &&\n+          delegateSuperObject != null) {\n+        FunctionType delegatorCtor = delegatorObject.getConstructor();\n+        FunctionType delegateBaseCtor = delegateBaseObject.getConstructor();\n+        FunctionType delegateSuperCtor = delegateSuperObject.getConstructor();\n+\n+        if (delegatorCtor != null && delegateBaseCtor != null &&\n+            delegateSuperCtor != null) {\n+          FunctionParamBuilder functionParamBuilder =\n+              new FunctionParamBuilder(typeRegistry);\n+          functionParamBuilder.addRequiredParams(\n+              typeRegistry.getNativeType(U2U_CONSTRUCTOR_TYPE));\n+          FunctionType findDelegate = typeRegistry.createFunctionType(\n+              typeRegistry.createDefaultObjectUnion(delegateBaseObject),\n+              functionParamBuilder.build());\n+\n+          // The suffix is necessary for the proxy to be distinguished from\n+          // the base.\n+          FunctionType delegateProxy = typeRegistry.createConstructorType(\n+              delegateBaseObject.getReferenceName() + \"(Proxy)\",\n+              null, null, null);\n+          delegateProxy.setPrototypeBasedOn(delegateBaseObject);\n+\n+          codingConvention.applyDelegateRelationship(\n+              delegateSuperObject, delegateBaseObject, delegatorObject,\n+              delegateProxy, findDelegate);\n+          delegateProxyMap.put(delegateProxy.getPrototype(), delegateBaseCtor);\n+        }\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n \n       // A function declaration with an empty name passes Rhino,\n       // but is supposed to be a syntax error according to the spec.\n-      if (!NodeUtil.isAnonymousFunction(parent)) {\n+      if (!NodeUtil.isFunctionExpression(parent)) {\n         t.report(n, INVALID_FUNCTION_DECL);\n       }\n       return;\n     Scope scope = t.getScope();\n     Scope.Var var = scope.getVar(varName);\n     if (var == null) {\n-      if (NodeUtil.isAnonymousFunction(parent)) {\n+      if (NodeUtil.isFunctionExpression(parent)) {\n         // e.g. [ function foo() {} ], it's okay if \"foo\" isn't defined in the\n         // current scope.\n       } else {\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n     assertPrint(\"typeof ({})\", \"typeof{}\");\n     assertPrint(\"f({})\", \"f({})\");\n \n-    // Anonymous functions.\n+    // Anonymous function expressions.\n     assertPrint(\"(function(){})\", \"(function(){})\");\n     assertPrint(\"(function(){})()\", \"(function(){})()\");\n     assertPrint(\"(function(){})instanceof Object\",\n     assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");\n     assertPrint(\"(function() {}), 2\", \"(function(){}),2\");\n \n-    // Named functions\n+    // Name functions expression.\n     assertPrint(\"(function f(){})\", \"(function f(){})\");\n+    \n+    // Function declaration.\n     assertPrint(\"function f(){}\", \"function f(){}\");\n \n     // Make sure we don't treat non-latin character escapes as raw strings.\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n     args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n     args.add(\"--warning_level=QUIET\");\n     args.add(\"--debug=false\");\n-    test(\"function Foo() {};\" +\n+    test(\"function Foo() {}\" +\n          \"Foo.x = 1;\" +\n          \"function f() {throw new Foo().x;} f();\",\n-         \"function a() {};\" +\n-         \"throw new a().a;\");\n+         \"throw (new function() {}).a;\");\n   }\n \n   public void testDebugFlag4() {\n     args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n     args.add(\"--warning_level=QUIET\");\n     args.add(\"--debug=true\");\n-    test(\"function Foo() {};\" +\n+    test(\"function Foo() {}\" +\n         \"Foo.x = 1;\" +\n         \"function f() {throw new Foo().x;} f();\",\n-        \"function $Foo$$() {};\" +\n-        \"throw new $Foo$$().$x$;\");\n+        \"throw (new function Foo() {}).$x$;\");\n   }\n \n   public void testHelpFlag() {\n--- a/test/com/google/javascript/jscomp/DefinitionsRemoverTest.java\n+++ b/test/com/google/javascript/jscomp/DefinitionsRemoverTest.java\n     test(\"foo({ 'one' : 1 , 'two' : 2 })\", \"foo({ })\");\n   }\n \n-  public void testRemoveAnonymousFunctionName() {\n+  public void testRemoveFunctionExpressionName() {\n     test(\"foo(function f(){})\", \"foo(function (){})\");\n   }\n \n--- a/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java\n+++ b/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java\n   }\n \n   public void testCanExposeExpression7() {\n-    // Verify calls to anonymous function are movable.\n-    helperCanExposeAnonymousFunctionExpression(\n+    // Verify calls to function expressions are movable.\n+    helperCanExposeFunctionExpression(\n         DecompositionType.MOVABLE,\n         \"(function(map){descriptions_=map})(\\n\" +\n             \"function(){\\n\" +\n     helperCanExposeExpression(expectedResult, code, fnName, null);\n   }\n \n-  private void helperCanExposeAnonymousFunctionExpression(\n+  private void helperCanExposeFunctionExpression(\n       DecompositionType expectedResult, String code, int call) {\n     Compiler compiler = new Compiler();\n     Set<String> knownConstants = Sets.newHashSet();\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n   boolean allowGlobalFunctionInlining = true;\n   boolean allowBlockInlining = true;\n   final boolean allowExpressionDecomposition = true;\n-  final boolean allowAnonymousFunctionExpressionInlining = true;\n+  final boolean allowFunctionExpressionInlining = true;\n   final boolean allowLocalFunctionInlining = true;\n \n   public InlineFunctionsTest() {\n         compiler.getUniqueNameIdSupplier(),\n         allowGlobalFunctionInlining,\n         allowLocalFunctionInlining,\n-        allowAnonymousFunctionExpressionInlining,\n+        allowFunctionExpressionInlining,\n         allowBlockInlining,\n         allowExpressionDecomposition);\n   }\n         \"x = JSCompiler_temp_const_0 + JSCompiler_inline_result_1;\");\n   }\n \n-  public void testDecomposeAnonymousInCall() {\n+  public void testDecomposeFunctionExpressionInCall() {\n     test(\n         \"(function(map){descriptions_=map})(\\n\" +\n            \"function(){\\n\" +\n          \"function _g() {var t; {x.call(this); t = void 0}}\");\n   }\n \n-  public void testAnonymousFunctionInlining1() {\n+  public void testFunctionExpressionInlining1() {\n     test(\"(function(){})()\",\n          \"void 0\");\n   }\n \n-  public void testAnonymousFunctionInlining2() {\n+  public void testFunctionExpressionInlining2() {\n     test(\"(function(){foo()})()\",\n          \"{foo()}\");\n   }\n \n-  public void testAnonymousFunctionInlining3() {\n+  public void testFunctionExpressionInlining3() {\n     test(\"var a = (function(){return foo()})()\",\n          \"var a = foo()\");\n   }\n \n-  public void testAnonymousFunctionInlining4() {\n+  public void testFunctionExpressionInlining4() {\n     test(\"var a; a = 1 + (function(){return foo()})()\",\n          \"var a; a = 1 + foo()\");\n   }\n \n-  public void testAnonymousFunctionCallInlining1() {\n+  public void testFunctionExpressionCallInlining1() {\n     test(\"(function(){}).call(this)\",\n          \"void 0\");\n   }\n \n-  public void testAnonymousFunctionCallInlining2() {\n+  public void testFunctionExpressionCallInlining2() {\n     test(\"(function(){foo(this)}).call(this)\",\n          \"{foo(this)}\");\n   }\n \n-  public void testAnonymousFunctionCallInlining3() {\n+  public void testFunctionExpressionCallInlining3() {\n     test(\"var a = (function(){return foo(this)}).call(this)\",\n          \"var a = foo(this)\");\n   }\n \n-  public void testAnonymousFunctionCallInlining4() {\n+  public void testFunctionExpressionCallInlining4() {\n     test(\"var a; a = 1 + (function(){return foo(this)}).call(this)\",\n          \"var a; a = 1 + foo(this)\");\n   }\n \n-  public void testAnonymousFunctionCallInlining5() {\n+  public void testFunctionExpressionCallInlining5() {\n     test(\"a:(function(){return foo()})()\",\n          \"a:foo()\");\n   }\n \n-  public void testAnonymousFunctionCallInlining6() {\n+  public void testFunctionExpressionCallInlining6() {\n     test(\"a:(function(){return foo()}).call(this)\",\n          \"a:foo()\");\n   }\n \n-  public void testAnonymousFunctionCallInlining7() {\n+  public void testFunctionExpressionCallInlining7() {\n     test(\"a:(function(){})()\",\n          \"a:void 0\");\n   }\n \n-  public void testAnonymousFunctionCallInlining8() {\n+  public void testFunctionExpressionCallInlining8() {\n     test(\"a:(function(){}).call(this)\",\n          \"a:void 0\");\n   }\n \n-  public void testAnonymousFunctionCallInlining9() {\n+  public void testFunctionExpressionCallInlining9() {\n     // ... with unused recursive name.\n     test(\"(function foo(){})()\",\n          \"void 0\");\n   }\n \n-  public void testAnonymousFunctionCallInlining10() {\n+  public void testFunctionExpressionCallInlining10() {\n     // ... with unused recursive name.\n     test(\"(function foo(){}).call(this)\",\n          \"void 0\");\n   }\n \n-  public void testAnonymousFunctionCallInlining11() {\n+  public void testFunctionExpressionCallInlining11() {\n     // Can't inline functions that return inner functions.\n     testSame(\"((function(){return function(){foo()}})())();\");\n   }\n \n-  public void testAnonymousFunctionCallInlining12() {\n+  public void testFunctionExpressionCallInlining12() {\n     // Can't inline functions that recurse.\n     testSame(\"(function foo(){foo()})()\");\n   }\n \n-  public void testAnonymousFunctionOmega() {\n+  public void testFunctionExpressionOmega() {\n     // ... with unused recursive name.\n     test(\"(function (f){f(f)})(function(f){f(f)})\",\n          \"{var f$$inline_1=function(f$$1){f$$1(f$$1)};\" +\n   }\n \n   // http://en.wikipedia.org/wiki/Fixed_point_combinator#Y_combinator\n-  public void testAnonymousFunctionYCombinator() {\n+  public void testFunctionExpressionYCombinator() {\n     testSame(\n         \"var factorial = ((function(M) {\\n\" +\n         \"      return ((function(f) {\\n\" +\n--- a/test/com/google/javascript/jscomp/InlineVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/InlineVariablesTest.java\n     testSame(\n         new String[] { \"var x = a;\", \"\",\n             \"(function() { a++; })(); var z = x;\"});\n-    testSame(\n+    test(\n         new String[] { \"var x = a;\", \"\",\n-            \"function cow() { a++; }; cow(); var z = x;\"});\n+            \"function cow() { a++; }; cow(); var z = x;\"}, \n+        new String[] { \"var x = a;\", \"\",\n+            \";(function cow(){ a++; })(); var z = x;\"});\n+    testSame(\n+        new String[] { \"var x = a;\", \"\",\n+            \"cow(); var z = x; function cow() { a++; };\"});\n   }\n \n   // Test movement of constant values\n     testSame(\"var x = 0; (function x() { return x ? x() : 3; })();\");\n   }\n \n+  public void testRecursiveFunction2() {\n+    testSame(\"function y() { return y(); }\");\n+  }\n+\n   public void testUnreferencedBleedingFunction() {\n     testSame(\"var x = function y() {}\");\n   }\n       );\n   }\n \n-  public void testInlineFunctionAlias1() {\n-    test(\n-      \"function f(x) {};\" +\n+  public void testInlineFunctionAlias1a() {\n+    test(\n+      \"function f(x) {}\" +\n       \"var y = f;\" +\n       \"g();\" +\n       \"y();y();\",\n+      \"var y = function f(x) {};\" +\n+      \"g();\" +\n+      \"y();y();\"\n+      );\n+  }\n+\n+  public void testInlineFunctionAlias1b() {\n+    test(\n       \"function f(x) {};\" +\n+      \"f;var y = f;\" +\n       \"g();\" +\n+      \"y();y();\",\n+      \"function f(x) {};\" +\n+      \"f;g();\" +\n       \"f();f();\"\n       );\n   }\n \n-  public void testInlineFunctionAlias2() {\n-    test(\n-      \"function f(x) {};\" +\n+  public void testInlineFunctionAlias2a() {\n+    test(\n+      \"function f(x) {}\" +\n       \"var y; y = f;\" +\n       \"g();\" +\n       \"y();y();\",\n+      \"var y; y = function f(x) {};\" +\n+      \"g();\" +\n+      \"y();y();\"\n+      );\n+  }\n+\n+  public void testInlineFunctionAlias2b() {\n+    test(\n       \"function f(x) {};\" +\n-      \"f;\" +\n+      \"f; var y; y = f;\" +\n+      \"g();\" +\n+      \"y();y();\",\n+      \"function f(x) {};\" +\n+      \"f; f;\" +\n       \"g();\" +\n       \"f();f();\"\n       );\n     testSame(\n         \"function f() { var a = this; var g = function() { a.y(); }; a.z(); }\");\n   }\n+\n+  public void testInlineNamedFunction() {\n+    test(\"function f() {} f();\", \"(function f(){})()\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java\n+++ b/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java\n          \"function foo(a){var b}\" +\n          \"function boo(a$$1){var b$$1}\");\n \n-    // Verify anonymous functions are renamed.\n+    // Verify functions expressions are renamed.\n     testWithInversion(\n         \"var a = function foo(){foo()};var b = function foo(){foo()};\",\n         \"var a = function foo(){foo()};var b = function foo$$1(){foo$$1()};\");\n          \"function foo$$unique_1(){var b$$unique_3;a$$unique_0}\" +\n          \"function boo$$unique_2(){var b$$unique_4;a$$unique_0}\");\n \n-    // Verify anonymous functions are renamed.\n+    // Verify function expressions are renamed.\n     test(\"var a = function foo(){foo()};\",\n          \"var a$$unique_0 = function foo$$unique_1(){foo$$unique_1()};\");\n \n--- a/test/com/google/javascript/jscomp/MoveFunctionDeclarationsTest.java\n+++ b/test/com/google/javascript/jscomp/MoveFunctionDeclarationsTest.java\n          new String[] { \"function f(){} function g(){} a\" });\n   }\n \n-  public void testAnonymousFunctions() {\n+  public void testFunctionsExpression() {\n     testSame(\"a; f = function(){}\");\n   }\n \n--- a/test/com/google/javascript/jscomp/NodeIteratorsTest.java\n+++ b/test/com/google/javascript/jscomp/NodeIteratorsTest.java\n         Token.VAR, Token.NAME, Token.VAR, Token.SCRIPT);\n   }\n \n-  public void testAnonymousFunction() {\n+  public void testFunctionExpression() {\n     testVarMotionWithCode(\"var X = 3, Y = function() {}; 3;\",\n         Token.NAME, Token.VAR, Token.NUMBER, Token.EXPR_RESULT, Token.SCRIPT);\n   }\n \n-  public void testAnonymousFunction2() {\n+  public void testFunctionExpression2() {\n     testVarMotionWithCode(\"var X = 3; var Y = function() {}; 3;\",\n         Token.VAR, Token.NAME, Token.VAR, Token.NUMBER,\n         Token.EXPR_RESULT, Token.SCRIPT);\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n   }\n \n \n-  public void testIsFunctionAnonymous() {\n+  public void testIsFunctionExpression() {\n     assertContainsAnonFunc(true, \"(function(){})\");\n     assertContainsAnonFunc(true, \"[function a(){}]\");\n     assertContainsAnonFunc(false, \"{x: function a(){}}\");\n     Node funcParent = findParentOfFuncDescendant(parse(js));\n     assertNotNull(\"Expected function node in parse tree of: \" + js, funcParent);\n     Node funcNode = getFuncChild(funcParent);\n-    assertEquals(expected, NodeUtil.isFunctionAnonymous(funcNode));\n+    assertEquals(expected, NodeUtil.isFunctionExpression(funcNode));\n   }\n \n   private Node findParentOfFuncDescendant(Node n) {\n     assertTrue(NodeUtil.isControlStructureCodeBlock(ifNode, elseCase));\n   }\n \n-  public void testIsAnonymousFunction1() {\n+  public void testIsFunctionExpression1() {\n     Compiler compiler = new Compiler();\n \n     Node root = parse(\"(function foo() {})\");\n     assertTrue(NodeUtil.isExpressionNode(StatementNode));\n     Node functionNode = StatementNode.getFirstChild();\n     assertTrue(NodeUtil.isFunction(functionNode));\n-    assertTrue(NodeUtil.isAnonymousFunction(functionNode));\n-  }\n-\n-  public void testIsAnonymousFunction2() {\n+    assertTrue(NodeUtil.isFunctionExpression(functionNode));\n+  }\n+\n+  public void testIsFunctionExpression2() {\n     Compiler compiler = new Compiler();\n \n     Node root = parse(\"function foo() {}\");\n     Node functionNode = root.getFirstChild();\n     assertTrue(NodeUtil.isFunction(functionNode));\n-    assertFalse(NodeUtil.isAnonymousFunction(functionNode));\n+    assertFalse(NodeUtil.isFunctionExpression(functionNode));\n   }\n \n   public void testRemoveTryChild() {\n--- a/test/com/google/javascript/jscomp/NormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/NormalizeTest.java\n          \"function foo(a){var b}\" +\n          \"function boo(a$$1){var b$$1}\");\n \n-    // Verify anonymous functions are renamed.\n+    // Verify function expressions are renamed.\n     test(\"var a = function foo(){foo()};var b = function foo(){foo()};\",\n          \"var a = function foo(){foo()};var b = function foo$$1(){foo$$1()};\");\n \n--- a/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n public class RemoveUnusedVarsTest extends CompilerTestCase {\n \n   private boolean removeGlobal = true;\n-  private boolean preserveAnonymousFunctionNames = false;\n+  private boolean preserveFunctionExpressionNames = false;\n   \n   public RemoveUnusedVarsTest() {\n     super(\"\", false);\n   @Override\n   public void setUp() {\n     removeGlobal = true;\n-    preserveAnonymousFunctionNames = false;\n+    preserveFunctionExpressionNames = false;\n   }\n   \n   @Override\n   protected CompilerPass getProcessor(final Compiler compiler) {\n     return new RemoveUnusedVars(\n-        compiler, removeGlobal, preserveAnonymousFunctionNames);\n+        compiler, removeGlobal, preserveFunctionExpressionNames);\n   }\n \n   public void testRemoveUnusedVars() {\n          \"var arg=\\\"foo\\\";if(arg.length>40)arg=arg.substr(0,40)+\\\"...\\\";\" +\n          \"x+=arg}\");\n \n-    // Test with anonymous functions in another function call\n+    // Test with function expressions in another function call\n     test(\"function A(){}\" +\n          \"if(0){function B(){}}win.setTimeout(function(){A()})\",\n          \"function A(){}\" +\n     test(\"var x=function f(){};x()\",\n          \"var x=function(){};x()\");\n \n-    preserveAnonymousFunctionNames = true;\n+    preserveFunctionExpressionNames = true;\n     testSame(\"var x=function f(){};x()\");\n   }\n \n     test(\"foo(function bar(){})\",\n          \"foo(function(){})\");\n \n-    preserveAnonymousFunctionNames = true;\n+    preserveFunctionExpressionNames = true;\n     testSame(\"foo(function bar(){})\");    \n   }\n   \n--- a/test/com/google/javascript/jscomp/RenameVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RenameVarsTest.java\n   private RenameVars renameVars;\n   private boolean withClosurePass = false;\n   private boolean localRenamingOnly = false;\n-  private boolean preserveAnonymousFunctionNames = false;\n+  private boolean preserveFunctionExpressionNames = false;\n   private boolean useGoogleCodingConvention = true;\n   private boolean generatePseudoNames = false;\n \n       return new ClosurePassAndRenameVars(compiler);\n     } else {\n       return renameVars = new RenameVars(compiler, prefix,\n-          localRenamingOnly, preserveAnonymousFunctionNames,\n+          localRenamingOnly, preserveFunctionExpressionNames,\n           generatePseudoNames,\n           previouslyUsedMap, null, null);\n     }\n     prefix = DEFAULT_PREFIX;\n     withClosurePass = false;\n     localRenamingOnly = false;\n-    preserveAnonymousFunctionNames = false;\n+    preserveFunctionExpressionNames = false;\n     generatePseudoNames = false;\n \n     // TODO(johnlenz): Enable Normalize during these tests.\n   }\n \n   public void testRecursiveFunctions2() {\n-    preserveAnonymousFunctionNames = true;\n+    preserveFunctionExpressionNames = true;\n \n     test(\"var walk = function walk(node, aFunction) {\" +\n          \"  walk(node, aFunction);\" +\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n   }\n \n   public void testScoping11() throws Exception {\n-    // named anonymous functions create a binding in their body only\n+    // named function expressions create a binding in their body only\n     // the return is wrong but the assignment is ok since the type of b is ?\n     testTypes(\n         \"/** @return number */var a = function b(){ return b };\",\n    * inferred and calling this variable is legal.\n    */\n   public void testBug911118() throws Exception {\n-    // verifying the type assigned to anonymous functions assigned variables\n+    // verifying the type assigned to function expressions assigned variables\n     Scope s = parseAndTypeCheckWithScope(\"var a = function(){};\").scope;\n     JSType type = s.getVar(\"a\").getType();\n     assertEquals(\"function (): ?\", type.toString());", "timestamp": 1272047508, "metainfo": ""}