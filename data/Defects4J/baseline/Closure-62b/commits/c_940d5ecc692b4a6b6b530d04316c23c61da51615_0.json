{"sha": "940d5ecc692b4a6b6b530d04316c23c61da51615", "log": "Use DefaultPassConfig to find hot-swap passes plus implementation of hot-swap for the following passes (i) closurePasss (ii) inferTypes (iii) checkTypes.  R=nicksantos,johnlenz,acleung DELTA=535  (330 added, 167 deleted, 38 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1750   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n       return this == NORMALIZED_OBFUSCATED;\n     }\n   }\n+\n+  /**\n+   * Runs a given compiler-pass by calling its {@code process()} method.\n+   * @param pass The pass to be run.\n+   */\n+  abstract void process(CompilerPass pass);\n+\n }\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     endPass();\n   }\n \n+  @Override\n   void process(CompilerPass p) {\n     p.process(externsRoot, jsRoot);\n   }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n \n   /** Closure pre-processing pass. */\n   @SuppressWarnings(\"deprecation\")\n-  final PassFactory closurePrimitives =\n-      new PassFactory(\"processProvidesAndRequires\", false) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  final HotSwapPassFactory closurePrimitives =\n+      new HotSwapPassFactory(\"processProvidesAndRequires\", false) {\n+    @Override\n+    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n       final ProcessClosurePrimitives pass = new ProcessClosurePrimitives(\n           compiler,\n           options.brokenClosureRequiresLevel,\n           options.rewriteNewDateGoogNow);\n \n-      return new CompilerPass() {\n+      return new HotSwapCompilerPass() {\n         @Override\n         public void process(Node externs, Node root) {\n           pass.process(externs, root);\n           exportedNames = pass.getExportedVariableNames();\n+        }\n+        @Override\n+        public void hotSwapScript(Node scriptRoot, Scope globalScope) {\n+          pass.hotSwapScript(scriptRoot, globalScope);\n         }\n       };\n     }\n   };\n \n   /** Checks that all variables are defined. */\n-  private final PassFactory checkVars =\n-      new PassFactory(\"checkVars\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  private final HotSwapPassFactory checkVars =\n+      new HotSwapPassFactory(\"checkVars\", true) {\n+    @Override\n+    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n       return new VarCheck(compiler);\n     }\n   };\n     }\n   };\n \n-  /** Run type inference. */\n-  final PassFactory inferTypes =\n-      new PassFactory(\"inferTypes\", false) {\n-    @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n-      return new CompilerPass() {\n+  /** Runs type inference. */\n+  final HotSwapPassFactory inferTypes =\n+      new HotSwapPassFactory(\"inferTypes\", false) {\n+    @Override\n+    protected HotSwapCompilerPass createInternal(final AbstractCompiler\n+        compiler) {\n+      return new HotSwapCompilerPass() {\n         @Override\n         public void process(Node externs, Node root) {\n           Preconditions.checkNotNull(topScope);\n           Preconditions.checkNotNull(getTypedScopeCreator());\n \n           makeTypeInference(compiler).process(externs, root);\n+        }\n+        @Override\n+        public void hotSwapScript(Node scriptRoot, Scope globalScope) {\n+          // TODO(bashir): Extra warnings about undefined types are reported\n+          // when doing inferTypes from scriptRoot. One solution is to do\n+          // inferTypes from the AST root instead of scriptRoot but that\n+          // approach is very slow!\n+          makeTypeInference(compiler).inferTypes(scriptRoot);\n         }\n       };\n     }\n };\n \n   /** Checks type usage */\n-  private final PassFactory checkTypes =\n-      new PassFactory(\"checkTypes\", false) {\n-    @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n-      return new CompilerPass() {\n+  private final HotSwapPassFactory checkTypes =\n+      new HotSwapPassFactory(\"checkTypes\", false) {\n+    @Override\n+    protected HotSwapCompilerPass createInternal(final AbstractCompiler\n+        compiler) {\n+      return new HotSwapCompilerPass() {\n         @Override\n         public void process(Node externs, Node root) {\n           Preconditions.checkNotNull(topScope);\n           TypeCheck check = makeTypeCheck(compiler);\n           check.process(externs, root);\n           compiler.getErrorManager().setTypedPercent(check.getTypedPercent());\n+        }\n+        @Override\n+        public void hotSwapScript(Node scriptRoot, Scope globalScope) {\n+          makeTypeCheck(compiler).check(scriptRoot, false);\n         }\n       };\n     }\n       };\n     }\n   };\n+\n+  /**\n+   * A pass-factory that is good for {@code HotSwapCompilerPass} passes.\n+   */\n+  abstract static class HotSwapPassFactory extends PassFactory {\n+\n+    HotSwapPassFactory(String name, boolean isOneTimePass) {\n+      super(name, isOneTimePass);\n+    }\n+\n+    @Override\n+    protected abstract HotSwapCompilerPass createInternal(AbstractCompiler\n+        compiler);\n+\n+    @Override\n+    HotSwapCompilerPass getHotSwapPass(AbstractCompiler compiler) {\n+      return this.createInternal(compiler);\n+    }\n+  }\n+\n }\n--- a/src/com/google/javascript/jscomp/HotSwapCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/HotSwapCompilerPass.java\n /**\n  * Interface for compiler passes that can be used in a hot-swap fashion.\n  *\n- * <p>The only method is {@code hotSwapScript} which runs this pass on\n+ * <p>The additional method is {@code hotSwapScript} which runs this pass on\n  * a subtree of the AST. Each pass that is intended to support hot-swap\n  * style should implement this interface.\n  *\n  *\n  * @author bashir@google.com (Bashir Sadjad)\n  */\n-public interface HotSwapCompilerPass {\n+public interface HotSwapCompilerPass extends CompilerPass {\n \n   /**\n    * Process the JS with root node root. This is supposed to be significantly\n    * faster compared to corresponding full-compiler passes.\n-   * @param root Root node corresponding to the file that is modified, should be\n-   *     of type {@code Token.SCRIPT}.\n+   * @param scriptRoot Root node corresponding to the file that is modified,\n+   *     should be of type {@code Token.SCRIPT}.\n    * @param globalScope The global scope which is not necessarily types.\n    */\n-  void hotSwapScript(Node root, Scope globalScope);\n+  void hotSwapScript(Node scriptRoot, Scope globalScope);\n \n }\n--- a/src/com/google/javascript/jscomp/PassFactory.java\n+++ b/src/com/google/javascript/jscomp/PassFactory.java\n       protected CompilerPass createInternal(AbstractCompiler compiler) {\n         return self.createInternal(compiler);\n       }\n+      @Override\n+      HotSwapCompilerPass getHotSwapPass(AbstractCompiler compiler) {\n+        return self.getHotSwapPass(compiler);\n+      }\n     };\n   }\n \n    * Creates a new compiler pass to be run.\n    */\n   abstract protected CompilerPass createInternal(AbstractCompiler compiler);\n+\n+  /**\n+   * Any factory whose CompilerPass has a corresponding hot-swap version should\n+   * override this.\n+   *\n+   * @param compiler The compiler that can has been used to do the full compile.\n+   */\n+  HotSwapCompilerPass getHotSwapPass(AbstractCompiler compiler) {\n+    // TODO(bashir): If in future most of PassFactory's in DefaultPassConfig\n+    // turns out to be DefaultPassConfig.HotSwapPassFactory, we should probably\n+    // change the implementaion here by the one in HotSwapPassFactory.\n+    return null;\n+  }\n }\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n  *\n  */\n class ProcessClosurePrimitives extends AbstractPostOrderCallback\n-    implements CompilerPass {\n+    implements HotSwapCompilerPass {\n \n   static final DiagnosticType NULL_ARGUMENT_ERROR = DiagnosticType.error(\n       \"JSC_NULL_ARGUMENT_ERROR\",\n             r.inputName, r.requireNode, requiresLevel, error, r.namespace));\n       }\n     }\n+  }\n+\n+  @Override\n+  public void hotSwapScript(Node scriptRoot, Scope globalScope) {\n+    // TODO(bashir): Implement a real hot-swap version instead and make it fully\n+    // consistent with the full version.\n+    this.compiler.process(this);\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n  * that cross module boundaries respect declared module dependencies.\n  *\n  */\n-class VarCheck extends AbstractPostOrderCallback implements CompilerPass,\n+class VarCheck extends AbstractPostOrderCallback implements\n     HotSwapCompilerPass {\n-\n   /** Name of the synthetic script that holds undefined variables. */\n   static final String SYNTHETIC_VARS_DECLAR = \"{SyntheticVarsDeclar}\";\n \n   }\n \n   @Override\n-  public void hotSwapScript(Node root, Scope globalScope) {\n-    Preconditions.checkState(root.getType() == Token.SCRIPT);\n+  public void hotSwapScript(Node scriptRoot, Scope globalScope) {\n+    Preconditions.checkState(scriptRoot.getType() == Token.SCRIPT);\n     NodeTraversal t = new NodeTraversal(compiler, this);\n     // Note we use the global scope to prevent wrong \"undefined-var errors\" on\n     // variables that are defined in other js files.\n-    t.traverseWithScope(root, globalScope);\n+    t.traverseWithScope(scriptRoot, globalScope);\n     // TODO(bashir) Check if we need to createSynthesizedExternVar like process.\n   }\n ", "timestamp": 1304460986, "metainfo": ""}