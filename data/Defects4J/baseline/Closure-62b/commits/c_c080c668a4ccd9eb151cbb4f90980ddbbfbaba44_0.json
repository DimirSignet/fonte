{"sha": "c080c668a4ccd9eb151cbb4f90980ddbbfbaba44", "log": "rolling back the EventTarget changes for a little bit  decouple command-line options from command-line parsing. (Nick)   Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n import com.google.common.base.Joiner;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.flags.DocLevel;\n import com.google.common.flags.Flag;\n abstract class AbstractCommandLineRunner<A extends Compiler,\n     B extends CompilerOptions> {\n \n-  @FlagSpec(help = \"Prints out the parse tree and exits\",\n-      docLevel = DocLevel.SECRET)\n-  static final Flag<Boolean> FLAG_print_tree = Flag.value(false);\n-\n-  @FlagSpec(help = \"Runs the compile job many times, then prints out the \" +\n-      \"best phase ordering from this run\",\n-      docLevel = DocLevel.SECRET)\n-  static final Flag<Boolean> FLAG_compute_phase_ordering =\n-      Flag.value(false);\n-\n-  @FlagSpec(help = \"Prints a dot file describing the internal abstract syntax\"\n-      + \" tree and exits\",\n-      docLevel = DocLevel.SECRET)\n-  static final Flag<Boolean> FLAG_print_ast = Flag.value(false);\n-\n-  @FlagSpec(help = \"Prints a dot file describing the passes that will get run\"\n-      + \" and exits\",\n-      docLevel = DocLevel.SECRET)\n-  static final Flag<Boolean> FLAG_print_pass_graph = Flag.value(false);\n-\n-  @FlagSpec(help = \"Turns on extra sanity checks\", altName = \"dev_mode\",\n-      docLevel = DocLevel.SECRET)\n-  static final Flag<CompilerOptions.DevMode> FLAG_jscomp_dev_mode =\n-      Flag.value(CompilerOptions.DevMode.OFF);\n-\n-  // TODO(nicksantos): Make the next 2 flags package-private.\n-  @FlagSpec(help = \"The logging level (standard java.util.logging.Level\"\n-      + \" values) for Compiler progress. Does not control errors or\"\n-      + \" warnings for the JavaScript code under compilation\",\n-      docLevel = DocLevel.SECRET)\n-  public static final Flag<String> FLAG_logging_level =\n-      Flag.value(Level.WARNING.getName());\n-\n-  @FlagSpec(help = \"The file containing javascript externs. You may specify\"\n-      + \" multiple\")\n-  public static final Flag<List<String>> FLAG_externs = Flag.stringCollector();\n-\n-  @FlagSpec(help = \"The javascript filename. You may specify multiple\")\n-  static final Flag<List<String>> FLAG_js = Flag.stringCollector();\n-\n-  @FlagSpec(help = \"Primary output filename. If not specified, output is \" +\n-            \"written to stdout\")\n-  static final Flag<String> FLAG_js_output_file = Flag.value(\"\");\n-\n-  @FlagSpec(help = \"A javascript module specification. The format is \"\n-      + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \"\n-      + \"unique. Each dep is the name of a module that this module \"\n-      + \"depends on. Modules must be listed in dependency order, and js \"\n-      + \"source files must be listed in the corresponding order. Where \"\n-      + \"--module flags occur in relation to --js flags is unimportant\")\n-  static final Flag<List<String>> FLAG_module = Flag.stringCollector();\n-\n-  @FlagSpec(help = \"File containing the serialized version of the variable \"\n-      + \"renaming map produced by a previous compilation\")\n-  static final Flag<String> FLAG_variable_map_input_file =\n-      Flag.value(\"\");\n-\n-  @FlagSpec(help = \"File containing the serialized version of the property \"\n-      + \"renaming map produced by a previous compilation\",\n-      docLevel = DocLevel.SECRET)\n-  static final Flag<String> FLAG_property_map_input_file =\n-      Flag.value(\"\");\n-\n-  @FlagSpec(help = \"File where the serialized version of the variable \"\n-      + \"renaming map produced should be saved\",\n-      docLevel = DocLevel.SECRET)\n-  static final Flag<String> FLAG_variable_map_output_file =\n-      Flag.value(\"\");\n-\n-  @FlagSpec(help = \"If true, variable renaming and property renaming map \"\n-      + \"files will be produced as {binary name}_vars_map.out and \"\n-      + \"{binary name}_props_map.out. Note that this flag cannot be used \"\n-      + \"in conjunction with either variable_map_output_file or \"\n-      + \"property_map_output_file\",\n-      docLevel = DocLevel.SECRET)\n-  static final Flag<Boolean> FLAG_create_name_map_files =\n-      Flag.value(false);\n-\n-  @FlagSpec(help = \"File where the serialized version of the property \"\n-      + \"renaming map produced should be saved\")\n-  static final Flag<String> FLAG_property_map_output_file =\n-      Flag.value(\"\");\n-\n-  @FlagSpec(help = \"Check source validity but do not enforce Closure style \"\n-      + \"rules and conventions\")\n-  static final Flag<Boolean> FLAG_third_party = Flag.value(false);\n-\n-\n-  @FlagSpec(help = \"Controls how detailed the compilation summary is. Values:\"\n-      + \" 0 (never print summary), 1 (print summary only if there are \"\n-      + \"errors or warnings), 2 (print summary if type checking is on, \"\n-      + \"see --check_types), 3 (always print summary). The default level \"\n-      + \"is 1\")\n-  static final Flag<Integer> FLAG_summary_detail_level = Flag.value(1);\n-\n-  @FlagSpec(help = \"Interpolate output into this string at the place denoted\"\n-      + \" by the marker token %output%. See --output_wrapper_marker\")\n-  static final Flag<String> FLAG_output_wrapper = Flag.value(\"\");\n-\n-  @FlagSpec(help = \"Use this token as output marker in the value of\"\n-      + \" --output_wrapper\")\n-  static final Flag<String> FLAG_output_wrapper_marker =\n-      Flag.value(\"%output%\");\n-\n-  @FlagSpec(help = \"An output wrapper for a javascript module (optional). \"\n-      + \"The format is <name>:<wrapper>. The module name must correspond \"\n-      + \"with a module specified using --module. The wrapper must \"\n-      + \"contain %s as the code placeholder\")\n-  static final Flag<List<String>> FLAG_module_wrapper =\n-      Flag.stringCollector();\n-\n-  @FlagSpec(help = \"Prefix for filenames of compiled js modules. \"\n-      + \"<module-name>.js will be appended to this prefix. Directories \"\n-      + \"will be created as needed. Use with --module\")\n-  static final Flag<String> FLAG_module_output_path_prefix =\n-      Flag.value(\"./\");\n-\n-  @FlagSpec(help = \"If specified, a source map file mapping the generated \" +\n-            \"source files back to the original source file will be \" +\n-            \"output to the specified path. The %outname% placeholder will \" +\n-            \"expand to the name of the output file that the source map \" +\n-            \"corresponds to.\")\n-  static final Flag<String> FLAG_create_source_map =\n-      Flag.value(\"\");\n-\n-  @FlagSpec(help = \"Make the named class of warnings an error. Options:\" +\n-      DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n-  static final Flag<List<String>> FLAG_jscomp_error =\n-      Flag.stringCollector();\n-\n-  @FlagSpec(help = \"Make the named class of warnings a normal warning. \" +\n-                \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n-  static final Flag<List<String>> FLAG_jscomp_warning =\n-      Flag.stringCollector();\n-\n-  @FlagSpec(help = \"Turn off the named class of warnings. Options:\" +\n-      DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n-  static final Flag<List<String>> FLAG_jscomp_off =\n-      Flag.stringCollector();\n-\n-  @FlagSpec(altName = \"D\",\n-      help = \"Override the value of a variable annotated @define. \" +\n-      \"The format is <name>[=<val>], where <name> is the name of a @define \" +\n-      \"variable and <val> is a boolean, number, or a single-quoted string \" +\n-      \"that contains no single quotes. If [=<val>] is omitted, \" +\n-      \"the variable is marked true\")\n-  static final Flag<List<String>> FLAG_define = Flag.stringCollector();\n-\n-  @FlagSpec(help = \"Input charset for all files.\")\n-  static final Flag<String> FLAG_charset = Flag.value(\"\");\n+  private final CommandLineConfig config;\n \n   private PrintStream out;\n   private final PrintStream err;\n \n   private final RunTimeStats runTimeStats = new RunTimeStats();\n \n-  AbstractCommandLineRunner(String[] args) {\n-    this(args, System.out, System.err);\n-  }\n-\n-  AbstractCommandLineRunner(String[] args, PrintStream out,\n-      PrintStream err) {\n-    // Flags are read when a compiler is instantiated, so we parse them first.\n-    Flags.parse(args);\n-\n+  AbstractCommandLineRunner(CommandLineConfig config) {\n+    this(config, System.out, System.err);\n+  }\n+\n+  AbstractCommandLineRunner(\n+      CommandLineConfig config, PrintStream out, PrintStream err) {\n+    this.config = config;\n     this.out = out;\n     this.err = err;\n   }\n     DiagnosticGroups diagnosticGroups = getDiagnoticGroups();\n \n     diagnosticGroups.setWarningLevels(\n-        options, AbstractCommandLineRunner.FLAG_jscomp_error.get(),\n-        CheckLevel.ERROR);\n+        options, config.jscompError, CheckLevel.ERROR);\n     diagnosticGroups.setWarningLevels(\n-        options, AbstractCommandLineRunner.FLAG_jscomp_warning.get(),\n-        CheckLevel.WARNING);\n+        options, config.jscompWarning, CheckLevel.WARNING);\n     diagnosticGroups.setWarningLevels(\n-        options, AbstractCommandLineRunner.FLAG_jscomp_off.get(),\n-        CheckLevel.OFF);\n-\n-    createDefineReplacements(FLAG_define.get(), options);\n+        options, config.jscompOff, CheckLevel.OFF);\n+\n+    createDefineReplacements(config.define, options);\n   }\n \n   final protected A getCompiler() {\n \n   final protected void setRunOptions(B options)\n       throws IOException, FlagUsageException {\n-    if (FLAG_js_output_file.get().length() > 0) {\n-      options.jsOutputFile = FLAG_js_output_file.get();\n-    }\n-\n-    if (FLAG_create_source_map.get().length() > 0) {\n-      options.sourceMapOutputPath = FLAG_create_source_map.get();\n-    }\n-\n-    if (!FLAG_variable_map_input_file.get().equals(\"\")) {\n+    if (config.jsOutputFile.length() > 0) {\n+      options.jsOutputFile = config.jsOutputFile;\n+    }\n+\n+    if (config.createSourceMap.length() > 0) {\n+      options.sourceMapOutputPath = config.createSourceMap;\n+    }\n+\n+    if (!config.variableMapInputFile.equals(\"\")) {\n       options.inputVariableMapSerialized =\n-          VariableMap.load(FLAG_variable_map_input_file.get()).toBytes();\n-    }\n-\n-    if (!FLAG_property_map_input_file.get().equals(\"\")) {\n+          VariableMap.load(config.variableMapInputFile).toBytes();\n+    }\n+\n+    if (!config.propertyMapInputFile.equals(\"\")) {\n       options.inputPropertyMapSerialized =\n-          VariableMap.load(FLAG_property_map_input_file.get()).toBytes();\n-    }\n-\n-    if (FLAG_third_party.get()) {\n+          VariableMap.load(config.propertyMapInputFile).toBytes();\n+    }\n+\n+    if (config.thirdParty) {\n       options.setCodingConvention(new DefaultCodingConvention());\n     }\n \n   final public void run() {\n     int result = 0;\n     int runs = 1;\n-    if (FLAG_compute_phase_ordering.get()) {\n+    if (config.computePhaseOrdering) {\n       runs = NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER;\n       PhaseOptimizer.randomizeLoops();\n     }\n       t.printStackTrace();\n       result = -2;\n     }\n-    if (FLAG_compute_phase_ordering.get()) {\n+    if (config.computePhaseOrdering) {\n       runTimeStats.outputBestPhaseOrdering();\n     }\n     System.exit(result);\n    * @return system exit status\n    */\n   protected int doRun() throws FlagUsageException, IOException {\n-    Compiler.setLoggingLevel(Level.parse(FLAG_logging_level.get()));\n+    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n \n     List<JSSourceFile> externsList = createExterns();\n     JSSourceFile[] externs = new JSSourceFile[externsList.size()];\n     }\n \n     ((PrintStreamErrorManager) compiler.getErrorManager())\n-        .setSummaryDetailLevel(FLAG_summary_detail_level.get());\n-\n-    List<String> jsFiles = FLAG_js.get();\n-    List<String> moduleSpecs = FLAG_module.get();\n+        .setSummaryDetailLevel(config.summaryDetailLevel);\n+\n+    List<String> jsFiles = config.js;\n+    List<String> moduleSpecs = config.module;\n     if (!moduleSpecs.isEmpty()) {\n       modules = createJsModules(moduleSpecs, jsFiles);\n       result = compiler.compile(externs, modules, options);\n    */\n   int processResults(Result result, JSModule[] modules, B options)\n        throws FlagUsageException, IOException {\n-    if (FLAG_compute_phase_ordering.get()) {\n+    if (config.computePhaseOrdering) {\n       return 0;\n     }\n \n-    if (FLAG_print_pass_graph.get()) {\n+    if (config.printPassGraph) {\n       if (compiler.getRoot() == null) {\n         return 1;\n       } else {\n       }\n     }\n \n-    if (FLAG_print_ast.get()) {\n+    if (config.printAst) {\n       if (compiler.getRoot() == null) {\n         return 1;\n       } else {\n       }\n     }\n \n-    if (FLAG_print_tree.get()) {\n+    if (config.printTree) {\n       if (compiler.getRoot() == null) {\n         out.println(\"Code contains errors; no tree was generated.\");\n         return 1;\n \n     if (result.success) {\n       if (modules == null) {\n-        writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper\n-            .get(), FLAG_output_wrapper_marker.get());\n+        writeOutput(out, compiler, compiler.toSource(), config.outputWrapper,\n+            config.outputWrapperMarker);\n \n         // Output the source map if requested.\n         outputSourceMap(options, options.jsOutputFile);\n       } else {\n-        String moduleFilePrefix = FLAG_module_output_path_prefix.get();\n+        String moduleFilePrefix = config.moduleOutputPathPrefix;\n         maybeCreateDirsForPath(moduleFilePrefix);\n         Map<String, String> moduleWrappers =\n-            parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n+            parseModuleWrappers(config.moduleWrapper, modules);\n \n         // If the source map path is in fact a pattern for each\n         // module, create a stream per-module. Otherwise, create\n \n   /**\n    * Query the flag for the charset, and return a Charset object representing\n-   * the selection.  Keep this in a separate function\n-   * so it can be called both in static and normal methods.\n+   * the selection.\n    *\n    * @return Charset to use when reading inputs\n    * @throws FlagUsageException if flag is not a valid Charset name.\n    */\n-  private static Charset getInputCharset() throws FlagUsageException {\n-    if (!FLAG_charset.get().isEmpty()) {\n-      if (!Charset.isSupported(FLAG_charset.get())) {\n-        throw new FlagUsageException(FLAG_charset.get() +\n+  private Charset getInputCharset() throws FlagUsageException {\n+    if (!config.charset.isEmpty()) {\n+      if (!Charset.isSupported(config.charset)) {\n+        throw new FlagUsageException(config.charset +\n             \" is not a valid charset name.\");\n       }\n-      return Charset.forName(FLAG_charset.get());\n+      return Charset.forName(config.charset);\n     }\n     return Charsets.UTF_8;\n   }\n \n   protected List<JSSourceFile> createExterns() throws FlagUsageException,\n       IOException {\n-    return createExternInputs(FLAG_externs.get());\n+    return createExternInputs(config.externs);\n   }\n \n   /**\n    *\n    * @return The path in which to place the generated map file(s).\n    */\n-  private static String getMapPath(String outputFile) {\n+  private String getMapPath(String outputFile) {\n     String basePath = \"\";\n \n     if (outputFile.equals(\"\")) {\n       // If we have a js_module_binary rule, output the maps\n       // at modulename_props_map.out, etc.\n-      if (!FLAG_module_output_path_prefix.get().equals(\"\")) {\n-        basePath = FLAG_module_output_path_prefix.get();\n+      if (!config.moduleOutputPathPrefix.equals(\"\")) {\n+        basePath = config.moduleOutputPathPrefix;\n       } else {\n         basePath = \"jscompiler\";\n       }\n     String functionInformationMapOutputPath = null;\n \n     // Check the create_name_map_files FLAG.\n-    if (FLAG_create_name_map_files.get()) {\n+    if (config.createNameMapFiles) {\n       String basePath = getMapPath(options.jsOutputFile);\n \n       propertyMapOutputPath = basePath + \"_props_map.out\";\n     }\n \n     // Check the individual FLAGS.\n-    if (!FLAG_variable_map_output_file.get().equals(\"\")) {\n+    if (!config.variableMapOutputFile.equals(\"\")) {\n       if (variableMapOutputPath != null) {\n         throw new FlagUsageException(\"The flags variable_map_output_file and \"\n             + \"create_name_map_files cannot both be used simultaniously.\");\n       }\n \n-      variableMapOutputPath = FLAG_variable_map_output_file.get();\n-    }\n-\n-    if (!FLAG_property_map_output_file.get().equals(\"\")) {\n+      variableMapOutputPath = config.variableMapOutputFile;\n+    }\n+\n+    if (!config.propertyMapOutputFile.equals(\"\")) {\n       if (propertyMapOutputPath != null) {\n         throw new FlagUsageException(\"The flags property_map_output_file and \"\n             + \"create_name_map_files cannot both be used simultaniously.\");\n       }\n \n-      propertyMapOutputPath = FLAG_property_map_output_file.get();\n+      propertyMapOutputPath = config.propertyMapOutputFile;\n     }\n \n     // Output the maps.\n       }\n     }\n   }\n+\n+  /**\n+   * Configurations for the command line configs. Designed for easy\n+   * building, so that we can decouple the flags-parsing library from\n+   * the actual configuration options.\n+   *\n+   * By design, these configurations must match one-to-one with\n+   * command-line flags.\n+   */\n+  static class CommandLineConfig {\n+    private boolean printTree = false;\n+\n+    /** Prints out the parse tree and exits */\n+    CommandLineConfig setPrintTree(boolean printTree) {\n+      this.printTree = printTree;\n+      return this;\n+    }\n+\n+    private boolean computePhaseOrdering = false;\n+\n+    /**\n+     * Runs the compile job many times, then prints out the best phase\n+     * ordering from this run\n+     */\n+    CommandLineConfig setComputePhaseOrdering(boolean computePhaseOrdering) {\n+      this.computePhaseOrdering = computePhaseOrdering;\n+      return this;\n+    }\n+\n+    private boolean printAst = false;\n+\n+    /**\n+     * Prints a dot file describing the internal abstract syntax tree\n+     * and exits\n+     */\n+    CommandLineConfig setPrintAst(boolean printAst) {\n+      this.printAst = printAst;\n+      return this;\n+    }\n+\n+    private boolean printPassGraph = false;\n+\n+    /** Prints a dot file describing the passes that will get run and exits */\n+    CommandLineConfig setPrintPassGraph(boolean printPassGraph) {\n+      this.printPassGraph = printPassGraph;\n+      return this;\n+    }\n+\n+    private CompilerOptions.DevMode jscompDevMode = CompilerOptions.DevMode.OFF;\n+\n+    /** Turns on extra sanity checks */\n+    CommandLineConfig setJscompDevMode(CompilerOptions.DevMode jscompDevMode) {\n+      this.jscompDevMode = jscompDevMode;\n+      return this;\n+    }\n+\n+    private String loggingLevel = Level.WARNING.getName();\n+\n+    /**\n+     * The logging level (standard java.util.logging.Level\n+     * values) for Compiler progress. Does not control errors or\n+     * warnings for the JavaScript code under compilation\n+     */\n+    CommandLineConfig setLoggingLevel(String loggingLevel) {\n+      this.loggingLevel = loggingLevel;\n+      return this;\n+    }\n+\n+    private final List<String> externs = Lists.newArrayList();\n+\n+    /**\n+     * The file containing javascript externs. You may specify multiple.\n+     */\n+    CommandLineConfig setExterns(List<String> externs) {\n+      this.externs.clear();\n+      this.externs.addAll(externs);\n+      return this;\n+    }\n+\n+    private final List<String> js = Lists.newArrayList();\n+\n+    /**\n+     * The javascript filename. You may specify multiple.\n+     */\n+    CommandLineConfig setJs(List<String> js) {\n+      this.js.clear();\n+      this.js.addAll(js);\n+      return this;\n+    }\n+\n+    private String jsOutputFile = \"\";\n+\n+    /**\n+     * Primary output filename. If not specified, output is written to stdout\n+     */\n+    CommandLineConfig setJsOutputFile(String jsOutputFile) {\n+      this.jsOutputFile = jsOutputFile;\n+      return this;\n+    }\n+\n+    private final List<String> module = Lists.newArrayList();\n+\n+    /**\n+     * A javascript module specification. The format is\n+     * <name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be\n+     * unique. Each dep is the name of a module that this module\n+     * depends on. Modules must be listed in dependency order, and js\n+     * source files must be listed in the corresponding order. Where\n+     * --module flags occur in relation to --js flags is unimportant\n+     */\n+    CommandLineConfig setModule(List<String> module) {\n+      this.module.clear();\n+      this.module.addAll(module);\n+      return this;\n+    }\n+\n+    private String variableMapInputFile = \"\";\n+\n+    /**\n+     * File containing the serialized version of the variable renaming\n+     * map produced by a previous compilation\n+     */\n+    CommandLineConfig setVariableMapInputFile(String variableMapInputFile) {\n+      this.variableMapInputFile = variableMapInputFile;\n+      return this;\n+    }\n+\n+    private String propertyMapInputFile = \"\";\n+\n+    /**\n+     * File containing the serialized version of the property renaming\n+     * map produced by a previous compilation\n+     */\n+    CommandLineConfig setPropertyMapInputFile(String propertyMapInputFile) {\n+      this.propertyMapInputFile = propertyMapInputFile;\n+      return this;\n+    }\n+\n+    private String variableMapOutputFile = \"\";\n+\n+    /**\n+     * File where the serialized version of the variable renaming map\n+     * produced should be saved\n+     */\n+    CommandLineConfig setVariableMapOutputFile(String variableMapOutputFile) {\n+      this.variableMapOutputFile = variableMapOutputFile;\n+      return this;\n+    }\n+\n+    private boolean createNameMapFiles = false;\n+\n+    /**\n+     * If true, variable renaming and property renaming map\n+     * files will be produced as {binary name}_vars_map.out and\n+     * {binary name}_props_map.out. Note that this flag cannot be used\n+     * in conjunction with either variable_map_output_file or\n+     * property_map_output_file\n+     */\n+    CommandLineConfig setCreateNameMapFiles(boolean createNameMapFiles) {\n+      this.createNameMapFiles = createNameMapFiles;\n+      return this;\n+    }\n+\n+    private String propertyMapOutputFile = \"\";\n+\n+    /**\n+     * File where the serialized version of the property renaming map\n+     * produced should be saved\n+     */\n+    CommandLineConfig setPropertyMapOutputFile(String propertyMapOutputFile) {\n+      this.propertyMapOutputFile = propertyMapOutputFile;\n+      return this;\n+    }\n+\n+    private boolean thirdParty = false;\n+\n+    /**\n+     * Check source validity but do not enforce Closure style rules and\n+     * conventions\n+     */\n+    CommandLineConfig setThirdParty(boolean thirdParty) {\n+      this.thirdParty = thirdParty;\n+      return this;\n+    }\n+\n+    private int summaryDetailLevel = 1;\n+\n+    /**\n+     * Controls how detailed the compilation summary is. Values:\n+     *  0 (never print summary), 1 (print summary only if there are\n+     * errors or warnings), 2 (print summary if type checking is on,\n+     * see --check_types), 3 (always print summary). The default level\n+     * is 1\n+     */\n+    CommandLineConfig setSummaryDetailLevel(int summaryDetailLevel) {\n+      this.summaryDetailLevel = summaryDetailLevel;\n+      return this;\n+    }\n+\n+    private String outputWrapper = \"\";\n+\n+    /**\n+     * Interpolate output into this string at the place denoted\n+     *  by the marker token %output%. See --output_wrapper_marker\n+     */\n+    CommandLineConfig setOutputWrapper(String outputWrapper) {\n+      this.outputWrapper = outputWrapper;\n+      return this;\n+    }\n+\n+    private String outputWrapperMarker = \"\";\n+\n+    /**\n+     * Use this token as output marker in the value of\n+     *  --output_wrapper\n+     */\n+    CommandLineConfig setOutputWrapperMarker(String outputWrapperMarker) {\n+      this.outputWrapperMarker = outputWrapperMarker;\n+      return this;\n+    }\n+\n+    private final List<String> moduleWrapper = Lists.newArrayList();\n+\n+    /**\n+     * An output wrapper for a javascript module (optional).\n+     * The format is <name>:<wrapper>. The module name must correspond\n+     * with a module specified using --module. The wrapper must\n+     * contain %s as the code placeholder\n+     */\n+    CommandLineConfig setModuleWrapper(List<String> moduleWrapper) {\n+      this.moduleWrapper.clear();\n+      this.moduleWrapper.addAll(moduleWrapper);\n+      return this;\n+    }\n+\n+    private String moduleOutputPathPrefix = \"\";\n+\n+    /**\n+     * Prefix for filenames of compiled js modules.\n+     * <module-name>.js will be appended to this prefix. Directories\n+     * will be created as needed. Use with --module\n+     */\n+    CommandLineConfig setModuleOutputPathPrefix(String moduleOutputPathPrefix) {\n+      this.moduleOutputPathPrefix = moduleOutputPathPrefix;\n+      return this;\n+    }\n+\n+    private String createSourceMap = \"\";\n+\n+    /**\n+     * If specified, a source map file mapping the generated\n+     * source files back to the original source file will be\n+     * output to the specified path. The %outname% placeholder will\n+     * expand to the name of the output file that the source map\n+     * corresponds to.\n+     */\n+    CommandLineConfig setCreateSourceMap(String createSourceMap) {\n+      this.createSourceMap = createSourceMap;\n+      return this;\n+    }\n+\n+    private final List<String> jscompError = Lists.newArrayList();\n+\n+    /**\n+     * Make the named class of warnings an error.\n+     */\n+    CommandLineConfig setJscompError(List<String> jscompError) {\n+      this.jscompError.clear();\n+      this.jscompError.addAll(jscompError);\n+      return this;\n+    }\n+\n+    private final List<String> jscompWarning = Lists.newArrayList();\n+\n+    /**\n+     * Make the named class of warnings a normal warning.\n+     */\n+    CommandLineConfig setJscompWarning(List<String> jscompWarning) {\n+      this.jscompWarning.clear();\n+      this.jscompWarning.addAll(jscompWarning);\n+      return this;\n+    }\n+\n+    private final List<String> jscompOff = Lists.newArrayList();\n+\n+    /**\n+     * Turn off the named class of warnings.\n+     */\n+    CommandLineConfig setJscompOff(List<String> jscompOff) {\n+      this.jscompOff.clear();\n+      this.jscompOff.addAll(jscompOff);\n+      return this;\n+    }\n+\n+    private final List<String> define = Lists.newArrayList();\n+\n+    /**\n+     * Override the value of a variable annotated @define.\n+     * The format is <name>[=<val>], where <name> is the name of a @define\n+     * variable and <val> is a boolean, number, or a single-quoted string\n+     * that contains no single quotes. If [=<val>] is omitted,\n+     * the variable is marked true\n+     */\n+    CommandLineConfig setDefine(List<String> define) {\n+      this.define.clear();\n+      this.define.addAll(define);\n+      return this;\n+    }\n+\n+    private String charset = \"\";\n+\n+    /**\n+     * Input charset for all files.\n+     */\n+    CommandLineConfig setCharset(String charset) {\n+      this.charset = charset;\n+      return this;\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.Lists;\n+import com.google.common.flags.DocLevel;\n import com.google.common.flags.Flag;\n import com.google.common.flags.FlagSpec;\n+import com.google.common.flags.Flags;\n import com.google.common.io.LimitInputStream;\n+import com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig;\n \n import java.io.IOException;\n import java.io.InputStream;\n import java.io.PrintStream;\n import java.util.List;\n+import java.util.logging.Level;\n import java.util.zip.ZipEntry;\n import java.util.zip.ZipInputStream;\n \n  */\n public class CommandLineRunner extends\n     AbstractCommandLineRunner<Compiler, CompilerOptions> {\n+\n+  @FlagSpec(help = \"Prints out the parse tree and exits\",\n+      docLevel = DocLevel.SECRET)\n+  static final Flag<Boolean> FLAG_print_tree = Flag.value(false);\n+\n+  @FlagSpec(help = \"Runs the compile job many times, then prints out the \" +\n+      \"best phase ordering from this run\",\n+      docLevel = DocLevel.SECRET)\n+  static final Flag<Boolean> FLAG_compute_phase_ordering =\n+      Flag.value(false);\n+\n+  @FlagSpec(help = \"Prints a dot file describing the internal abstract syntax\"\n+      + \" tree and exits\",\n+      docLevel = DocLevel.SECRET)\n+  static final Flag<Boolean> FLAG_print_ast = Flag.value(false);\n+\n+  @FlagSpec(help = \"Prints a dot file describing the passes that will get run\"\n+      + \" and exits\",\n+      docLevel = DocLevel.SECRET)\n+  static final Flag<Boolean> FLAG_print_pass_graph = Flag.value(false);\n+\n+  @FlagSpec(help = \"Turns on extra sanity checks\", altName = \"dev_mode\",\n+      docLevel = DocLevel.SECRET)\n+  static final Flag<CompilerOptions.DevMode> FLAG_jscomp_dev_mode =\n+      Flag.value(CompilerOptions.DevMode.OFF);\n+\n+  // TODO(nicksantos): Make the next 2 flags package-private.\n+  @FlagSpec(help = \"The logging level (standard java.util.logging.Level\"\n+      + \" values) for Compiler progress. Does not control errors or\"\n+      + \" warnings for the JavaScript code under compilation\",\n+      docLevel = DocLevel.SECRET)\n+  public static final Flag<String> FLAG_logging_level =\n+      Flag.value(Level.WARNING.getName());\n+\n+  @FlagSpec(help = \"The file containing javascript externs. You may specify\"\n+      + \" multiple\")\n+  public static final Flag<List<String>> FLAG_externs = Flag.stringCollector();\n+\n+  @FlagSpec(help = \"The javascript filename. You may specify multiple\")\n+  static final Flag<List<String>> FLAG_js = Flag.stringCollector();\n+\n+  @FlagSpec(help = \"Primary output filename. If not specified, output is \" +\n+            \"written to stdout\")\n+  static final Flag<String> FLAG_js_output_file = Flag.value(\"\");\n+\n+  @FlagSpec(help = \"A javascript module specification. The format is \"\n+      + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \"\n+      + \"unique. Each dep is the name of a module that this module \"\n+      + \"depends on. Modules must be listed in dependency order, and js \"\n+      + \"source files must be listed in the corresponding order. Where \"\n+      + \"--module flags occur in relation to --js flags is unimportant\")\n+  static final Flag<List<String>> FLAG_module = Flag.stringCollector();\n+\n+  @FlagSpec(help = \"File containing the serialized version of the variable \"\n+      + \"renaming map produced by a previous compilation\")\n+  static final Flag<String> FLAG_variable_map_input_file =\n+      Flag.value(\"\");\n+\n+  @FlagSpec(help = \"File containing the serialized version of the property \"\n+      + \"renaming map produced by a previous compilation\",\n+      docLevel = DocLevel.SECRET)\n+  static final Flag<String> FLAG_property_map_input_file =\n+      Flag.value(\"\");\n+\n+  @FlagSpec(help = \"File where the serialized version of the variable \"\n+      + \"renaming map produced should be saved\",\n+      docLevel = DocLevel.SECRET)\n+  static final Flag<String> FLAG_variable_map_output_file =\n+      Flag.value(\"\");\n+\n+  @FlagSpec(help = \"If true, variable renaming and property renaming map \"\n+      + \"files will be produced as {binary name}_vars_map.out and \"\n+      + \"{binary name}_props_map.out. Note that this flag cannot be used \"\n+      + \"in conjunction with either variable_map_output_file or \"\n+      + \"property_map_output_file\",\n+      docLevel = DocLevel.SECRET)\n+  static final Flag<Boolean> FLAG_create_name_map_files =\n+      Flag.value(false);\n+\n+  @FlagSpec(help = \"File where the serialized version of the property \"\n+      + \"renaming map produced should be saved\")\n+  static final Flag<String> FLAG_property_map_output_file =\n+      Flag.value(\"\");\n+\n+  @FlagSpec(help = \"Check source validity but do not enforce Closure style \"\n+      + \"rules and conventions\")\n+  static final Flag<Boolean> FLAG_third_party = Flag.value(false);\n+\n+\n+  @FlagSpec(help = \"Controls how detailed the compilation summary is. Values:\"\n+      + \" 0 (never print summary), 1 (print summary only if there are \"\n+      + \"errors or warnings), 2 (print summary if type checking is on, \"\n+      + \"see --check_types), 3 (always print summary). The default level \"\n+      + \"is 1\")\n+  static final Flag<Integer> FLAG_summary_detail_level = Flag.value(1);\n+\n+  @FlagSpec(help = \"Interpolate output into this string at the place denoted\"\n+      + \" by the marker token %output%. See --output_wrapper_marker\")\n+  static final Flag<String> FLAG_output_wrapper = Flag.value(\"\");\n+\n+  @FlagSpec(help = \"Use this token as output marker in the value of\"\n+      + \" --output_wrapper\")\n+  static final Flag<String> FLAG_output_wrapper_marker =\n+      Flag.value(\"%output%\");\n+\n+  @FlagSpec(help = \"An output wrapper for a javascript module (optional). \"\n+      + \"The format is <name>:<wrapper>. The module name must correspond \"\n+      + \"with a module specified using --module. The wrapper must \"\n+      + \"contain %s as the code placeholder\")\n+  static final Flag<List<String>> FLAG_module_wrapper =\n+      Flag.stringCollector();\n+\n+  @FlagSpec(help = \"Prefix for filenames of compiled js modules. \"\n+      + \"<module-name>.js will be appended to this prefix. Directories \"\n+      + \"will be created as needed. Use with --module\")\n+  static final Flag<String> FLAG_module_output_path_prefix =\n+      Flag.value(\"./\");\n+\n+  @FlagSpec(help = \"If specified, a source map file mapping the generated \" +\n+            \"source files back to the original source file will be \" +\n+            \"output to the specified path. The %outname% placeholder will \" +\n+            \"expand to the name of the output file that the source map \" +\n+            \"corresponds to.\")\n+  static final Flag<String> FLAG_create_source_map =\n+      Flag.value(\"\");\n+\n+  @FlagSpec(help = \"Make the named class of warnings an error. Options:\" +\n+      DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n+  static final Flag<List<String>> FLAG_jscomp_error =\n+      Flag.stringCollector();\n+\n+  @FlagSpec(help = \"Make the named class of warnings a normal warning. \" +\n+                \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n+  static final Flag<List<String>> FLAG_jscomp_warning =\n+      Flag.stringCollector();\n+\n+  @FlagSpec(help = \"Turn off the named class of warnings. Options:\" +\n+      DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n+  static final Flag<List<String>> FLAG_jscomp_off =\n+      Flag.stringCollector();\n+\n+  @FlagSpec(altName = \"D\",\n+      help = \"Override the value of a variable annotated @define. \" +\n+      \"The format is <name>[=<val>], where <name> is the name of a @define \" +\n+      \"variable and <val> is a boolean, number, or a single-quoted string \" +\n+      \"that contains no single quotes. If [=<val>] is omitted, \" +\n+      \"the variable is marked true\")\n+  static final Flag<List<String>> FLAG_define = Flag.stringCollector();\n+\n+  @FlagSpec(help = \"Input charset for all files.\")\n+  static final Flag<String> FLAG_charset = Flag.value(\"\");\n \n   @FlagSpec(help = \"Specifies the compilation level to use. Options: \" +\n             \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\")\n    * method should instantiate it.\n    */\n   protected CommandLineRunner(String[] args) {\n-    super(args);\n+    super(readConfigFromFlags(args));\n   }\n \n   protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) {\n-    super(args, out, err);\n+    super(readConfigFromFlags(args), out, err);\n+  }\n+\n+  private static CommandLineConfig readConfigFromFlags(String[] args) {\n+    Flags.parse(args);\n+    return new CommandLineConfig()\n+        .setPrintTree(FLAG_print_tree.get())\n+        .setComputePhaseOrdering(FLAG_compute_phase_ordering.get())\n+        .setPrintAst(FLAG_print_ast.get())\n+        .setPrintPassGraph(FLAG_print_pass_graph.get())\n+        .setJscompDevMode(FLAG_jscomp_dev_mode.get())\n+        .setLoggingLevel(FLAG_logging_level.get())\n+        .setExterns(FLAG_externs.get())\n+        .setJs(FLAG_js.get())\n+        .setJsOutputFile(FLAG_js_output_file.get())\n+        .setModule(FLAG_module.get())\n+        .setVariableMapInputFile(FLAG_variable_map_input_file.get())\n+        .setPropertyMapInputFile(FLAG_property_map_input_file.get())\n+        .setVariableMapOutputFile(FLAG_variable_map_output_file.get())\n+        .setCreateNameMapFiles(FLAG_create_name_map_files.get())\n+        .setPropertyMapOutputFile(FLAG_property_map_output_file.get())\n+        .setThirdParty(FLAG_third_party.get())\n+        .setSummaryDetailLevel(FLAG_summary_detail_level.get())\n+        .setOutputWrapper(FLAG_output_wrapper.get())\n+        .setOutputWrapperMarker(FLAG_output_wrapper_marker.get())\n+        .setModuleWrapper(FLAG_module_wrapper.get())\n+        .setModuleOutputPathPrefix(FLAG_module_output_path_prefix.get())\n+        .setCreateSourceMap(FLAG_create_source_map.get())\n+        .setJscompError(FLAG_jscomp_error.get())\n+        .setJscompWarning(FLAG_jscomp_warning.get())\n+        .setJscompOff(FLAG_jscomp_off.get())\n+        .setDefine(FLAG_define.get())\n+        .setCharset(FLAG_charset.get());\n   }\n \n   @Override\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n     Flags.resetAllFlagsForTest();\n \n     // NOTE(nicksantos): ANT needs this for some weird reason.\n-    AbstractCommandLineRunner.FLAG_define.resetForTest();\n-    AbstractCommandLineRunner.FLAG_jscomp_off.resetForTest();\n-    AbstractCommandLineRunner.FLAG_jscomp_warning.resetForTest();\n-    AbstractCommandLineRunner.FLAG_jscomp_error.resetForTest();\n+    CommandLineRunner.FLAG_define.resetForTest();\n+    CommandLineRunner.FLAG_jscomp_off.resetForTest();\n+    CommandLineRunner.FLAG_jscomp_warning.resetForTest();\n+    CommandLineRunner.FLAG_jscomp_error.resetForTest();\n \n     Flags.enableStateCheckingForTest();\n     super.tearDown();\n \n   public void testCheckSymbolsOverrideForVerbose() {\n     CommandLineRunner.FLAG_warning_level.setForTest(WarningLevel.VERBOSE);\n-    AbstractCommandLineRunner.FLAG_jscomp_off.setForTest(\n+    CommandLineRunner.FLAG_jscomp_off.setForTest(\n         Lists.newArrayList(\"undefinedVars\"));\n     testSame(\"x = 3;\");\n   }\n \n   public void testCheckUndefinedProperties() {\n     CommandLineRunner.FLAG_warning_level.setForTest(WarningLevel.VERBOSE);\n-    AbstractCommandLineRunner.FLAG_jscomp_error.setForTest(\n+    CommandLineRunner.FLAG_jscomp_error.setForTest(\n         Lists.newArrayList(\"missingProperties\"));\n     test(\"var x = {}; var y = x.bar;\", TypeCheck.INEXISTENT_PROPERTY);\n   }\n   }\n \n   public void testDefineFlag() {\n-    AbstractCommandLineRunner.FLAG_define.setForTest(\n+    CommandLineRunner.FLAG_define.setForTest(\n         Lists.newArrayList(\"FOO\", \"BAR=5\"));\n     test(\"/** @define {boolean} */ var FOO = false;\" +\n          \"/** @define {number} */ var BAR = 3;\",", "timestamp": 1267727625, "metainfo": ""}