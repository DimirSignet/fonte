{"sha": "a9757e8c7d85f9ee9622b3e5352955ba3429733d", "log": "Change on 2010/05/17 by robby          Check for non-alias locals in ScopedAliases.          R=nick         DELTA=26  (22 added, 3 deleted, 1 changed)  Change on 2010/05/18 by nick          Add inferred return types.         Make the inf/sup relationship for function types a bit richer.         Make sure that the [call] pointer can never be null.          R=andrew         DELTA=192  (134 added, 30 deleted, 28 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=4001   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n   static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error(\n       \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\",\n       \"The alias {0} is assigned a value more than once.\");\n+\n+  static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error(\n+      \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\",\n+      \"The local variable {0} is in a goog.scope and is not an alias.\");\n \n   ScopedAliases(AbstractCompiler compiler) {\n     this.compiler = compiler;\n \n       if (t.getScopeDepth() == 2) {\n         if (n.getType() == Token.NAME && parent.getType() == Token.VAR) {\n-          if (n.hasChildren() && n.isQualifiedName()) {\n-            // TODO(robbyw): What other checks go here?\n-            // TODO(robbyw): Emit errors about non-alias local variables.\n-\n+          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n             aliases.put(n.getString(), n.getFirstChild());\n             aliasDefinitions.add(n);\n \n \n             // If we found an alias, we are done.\n             return;\n+          } else {\n+            // TODO(robbyw): Support using locals for private variables.\n+            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n           }\n         }\n       }\n--- a/src/com/google/javascript/rhino/jstype/ArrowType.java\n+++ b/src/com/google/javascript/rhino/jstype/ArrowType.java\n   final Node parameters;\n   JSType returnType;\n \n+  // Whether the return type is inferred.\n+  final boolean returnTypeInferred;\n+\n   ArrowType(JSTypeRegistry registry, Node parameters,\n       JSType returnType) {\n+    this(registry, parameters, returnType, false);\n+  }\n+\n+  ArrowType(JSTypeRegistry registry, Node parameters,\n+      JSType returnType, boolean returnTypeInferred) {\n     super(registry);\n \n     this.parameters = parameters == null ?\n         parameters;\n     this.returnType = returnType == null ?\n         getNativeType(UNKNOWN_TYPE) : returnType;\n+    this.returnTypeInferred = returnTypeInferred;\n   }\n \n   @Override\n     return true;\n   }\n \n-  @Override\n-  public boolean equals(Object object) {\n-    // Please keep this method in sync with the hashCode() method below.\n-    if (!(object instanceof ArrowType)) {\n-      return false;\n-    }\n-    ArrowType that = (ArrowType) object;\n-    if (!returnType.equals(that.returnType)) {\n-      return false;\n-    }\n-\n+  /**\n+   * @return True if our parameter spec is equal to {@code that}'s parameter\n+   *     spec.\n+   */\n+  boolean hasEqualParameters(ArrowType that) {\n     Node thisParam = parameters.getFirstChild();\n     Node otherParam = that.parameters.getFirstChild();\n     while (thisParam != null && otherParam != null) {\n   }\n \n   @Override\n+  public boolean equals(Object object) {\n+    // Please keep this method in sync with the hashCode() method below.\n+    if (!(object instanceof ArrowType)) {\n+      return false;\n+    }\n+    ArrowType that = (ArrowType) object;\n+    if (!returnType.equals(that.returnType) ||\n+        returnTypeInferred != that.returnTypeInferred) {\n+      return false;\n+    }\n+    return hasEqualParameters(that);\n+  }\n+\n+  @Override\n   public int hashCode() {\n     int hashCode = 0;\n     if (returnType != null) {\n       hashCode += returnType.hashCode();\n+    }\n+    if (returnTypeInferred) {\n+      hashCode += 1;\n     }\n     if (parameters != null) {\n       Node param = parameters.getFirstChild();\n--- a/src/com/google/javascript/rhino/jstype/FunctionBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionBuilder.java\n   private JSType returnType = null;\n   private ObjectType typeOfThis = null;\n   private String templateTypeName = null;\n+  private boolean inferredReturnType = false;\n   private boolean isConstructor = false;\n   private boolean isNativeType = false;\n \n   /** Set the return type. */\n   public FunctionBuilder withReturnType(JSType returnType) {\n     this.returnType = returnType;\n+    return this;\n+  }\n+\n+  /** Sets an inferred return type. */\n+  public FunctionBuilder withInferredReturnType(JSType returnType) {\n+    this.returnType = returnType;\n+    this.inferredReturnType = true;\n     return this;\n   }\n \n   /** Construct a new function type. */\n   public FunctionType build() {\n     return new FunctionType(registry, name, sourceNode,\n-        registry.createArrowType(parametersNode, returnType),\n+        new ArrowType(registry, parametersNode, returnType, inferredReturnType),\n         typeOfThis, templateTypeName, isConstructor, isNativeType);\n   }\n }\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE;\n \n import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Objects;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n         nativeType);\n     Preconditions.checkArgument(source == null ||\n         Token.FUNCTION == source.getType());\n+    Preconditions.checkNotNull(arrowType);\n     this.source = source;\n     this.kind = isConstructor ? Kind.CONSTRUCTOR : Kind.ORDINARY;\n     if (isConstructor) {\n         Token.FUNCTION == source.getType());\n     Preconditions.checkArgument(name != null);\n     this.source = source;\n-    this.call = null;\n+    this.call = new ArrowType(registry, new Node(Token.LP), null);\n     this.kind = Kind.INTERFACE;\n     this.typeOfThis = new InstanceObjectType(registry, this);\n   }\n \n   /** Gets an LP node that contains all params. May be null. */\n   public Node getParametersNode() {\n-    return call == null ? null : call.parameters;\n+    return call.parameters;\n   }\n \n   /** Gets the minimum number of arguments that this function requires. */\n   }\n \n   public JSType getReturnType() {\n-    return call == null ? null : call.returnType;\n+    return call.returnType;\n+  }\n+\n+  public boolean isReturnTypeInferred() {\n+    return call.returnTypeInferred;\n   }\n \n   /** Gets the internal arrow type. For use by subclasses only. */\n \n   @Override\n   public JSType getLeastSupertype(JSType that) {\n+    return supAndInfHelper(that, true);\n+  }\n+\n+  @Override\n+  public JSType getGreatestSubtype(JSType that) {\n+    return supAndInfHelper(that, false);\n+  }\n+\n+  private JSType supAndInfHelper(JSType that, boolean leastSuper) {\n     // NOTE(nicksantos): When we remove the unknown type, the function types\n     // form a lattice with the universal constructor at the top of the lattice,\n     // and the NoObject type at the bottom of the lattice.\n         return this;\n       }\n \n+      // If this is a normal function, look to see if the arguments are equal.\n+      // If they are, we can just take the least supertype (or greatest\n+      // subtype) of the return types.\n+      if (isOrdinaryFunction() && that.isOrdinaryFunction() &&\n+          that instanceof FunctionType) {\n+        FunctionType other = (FunctionType) that;\n+        if (call.hasEqualParameters(other.call) &&\n+            Objects.equal(typeOfThis, other.typeOfThis)) {\n+          JSType newReturnType = leastSuper ?\n+              call.returnType.getLeastSupertype(other.call.returnType) :\n+              call.returnType.getGreatestSubtype(other.call.returnType);\n+          return new FunctionType(\n+              registry, null, null,\n+              new ArrowType(\n+                  registry, call.parameters, newReturnType,\n+                  call.returnTypeInferred ||\n+                  other.call.returnTypeInferred),\n+              typeOfThis, null, false, false);\n+        }\n+      }\n+\n       JSType functionInstance = registry.getNativeType(\n           JSTypeNative.FUNCTION_INSTANCE_TYPE);\n       if (functionInstance.equals(that)) {\n-        return that;\n+        return leastSuper ? that : this;\n       } else if (functionInstance.equals(this)) {\n-        return this;\n-      }\n-\n-      return registry.getNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);\n-    }\n-\n-    return super.getLeastSupertype(that);\n-  }\n-\n-  @Override\n-  public JSType getGreatestSubtype(JSType that) {\n-    if (isFunctionType() && that.isFunctionType()) {\n-      if (equals(that)) {\n-        return this;\n-      }\n-\n-      JSType functionInstance = registry.getNativeType(\n-          JSTypeNative.FUNCTION_INSTANCE_TYPE);\n-      if (functionInstance.equals(that)) {\n-        return this;\n-      } else if (functionInstance.equals(this)) {\n-        return that;\n-      }\n-\n-      return registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n-    }\n-\n-    return super.getGreatestSubtype(that);\n+        return leastSuper ? this : that;\n+      }\n+\n+      return leastSuper ?\n+          registry.getNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE) :\n+          registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n+    }\n+\n+    return leastSuper ?\n+        super.getLeastSupertype(that) :\n+        super.getGreatestSubtype(that);\n   }\n \n   /**\n \n     StringBuilder b = new StringBuilder(32);\n     b.append(\"function (\");\n-    int paramNum = (call == null || call.parameters == null) ?\n-        0 : call.parameters.getChildCount();\n+    int paramNum = call.parameters.getChildCount();\n     boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType();\n     if (hasKnownTypeOfThis) {\n       b.append(\"this:\");\n         p = p.getNext();\n       }\n     }\n-    b.append(\")\");\n-    if (call != null && call.returnType != null) {\n-      b.append(\": \");\n-      b.append(call.returnType);\n-    }\n+    b.append(\"): \");\n+    b.append(call.returnType);\n     return b.toString();\n   }\n \n \n     StringBuilder b = new StringBuilder(32);\n     b.append(\"function (\");\n-    int paramNum = (call == null || call.parameters == null) ?\n-        0 : call.parameters.getChildCount();\n+    int paramNum = call.parameters.getChildCount();\n     boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType();\n     if (hasKnownTypeOfThis) {\n       b.append(\"this:\");\n       }\n     }\n     b.append(\")\");\n-    if (call != null && call.returnType != null) {\n-      b.append(\": \");\n-      b.append(getDebugHashCodeStringOf(call.returnType));\n-    }\n+    b.append(\": \");\n+    b.append(getDebugHashCodeStringOf(call.returnType));\n     return b.toString();\n   }\n \n--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n         \"goog.dom.createElement(goog.dom.TagName.DIV);\");\n   }\n \n+  public void testTransitiveInSameVar() {\n+    testScoped(\"var d = goog.dom, DIV = d.TagName.DIV;d.createElement(DIV);\",\n+        \"goog.dom.createElement(goog.dom.TagName.DIV);\");\n+  }\n+\n   public void testMultipleTransitive() {\n     testScoped(\n         \"var g=goog;var d=g.dom;var t=d.TagName;var DIV=t.DIV;\" +\n         ScopedAliases.GOOG_SCOPE_HAS_BAD_PARAMETERS);\n     testFailure(\"goog.scope(function(a, b, c) {})\",\n         ScopedAliases.GOOG_SCOPE_HAS_BAD_PARAMETERS);\n+  }\n+\n+  public void testNonAliasLocal() {\n+    testScopedFailure(\"var x = 10\", ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n+    testScopedFailure(\"var x = goog.dom + 10\",\n+        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n+    testScopedFailure(\"var x = goog['dom']\",\n+        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n+    testScopedFailure(\"var x = goog.dom, y = 10\",\n+        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n   }\n \n   @Override\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n         \"I.prototype.baz = function(){};\");\n \n     Var i = globalScope.getVar(\"I\");\n-    assertEquals(\"function (this:I)\", i.getType().toString());\n+    assertEquals(\"function (this:I): ?\", i.getType().toString());\n     assertTrue(i.getType().isInterface());\n \n     ObjectType iPrototype = (ObjectType)\n--- a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n     FunctionType f = new FunctionBuilder(registry).build();\n     assertEquals(UNKNOWN_TYPE, f.getReturnType());\n   }\n+\n+  public void testSupAndInfOfReturnTypes() {\n+    FunctionType retString = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters())\n+        .withInferredReturnType(STRING_TYPE).build();\n+    FunctionType retNumber = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters())\n+        .withReturnType(NUMBER_TYPE).build();\n+\n+    assertLeastSupertype(\n+        \"function (): (number|string)\", retString, retNumber);\n+    assertGreatestSubtype(\n+        \"function (): None\", retString, retNumber);\n+\n+    assertTrue(retString.isReturnTypeInferred());\n+    assertFalse(retNumber.isReturnTypeInferred());\n+    assertTrue(\n+        ((FunctionType) retString.getLeastSupertype(retNumber))\n+        .isReturnTypeInferred());\n+    assertTrue(\n+        ((FunctionType) retString.getGreatestSubtype(retString))\n+        .isReturnTypeInferred());\n+  }\n+\n+  public void testSupAndInfWithDifferentParams() {\n+    FunctionType retString = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters(NUMBER_TYPE))\n+        .withReturnType(STRING_TYPE).build();\n+    FunctionType retNumber = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters(STRING_TYPE))\n+        .withReturnType(NUMBER_TYPE).build();\n+\n+    assertLeastSupertype(\n+        \"Function\", retString, retNumber);\n+    assertGreatestSubtype(\n+        \"NoObject\", retString, retNumber);\n+  }\n+\n+  public void testSupAndInfWithDifferentThisTypes() {\n+    FunctionType retString = new FunctionBuilder(registry)\n+        .withTypeOfThis(OBJECT_TYPE)\n+        .withReturnType(STRING_TYPE).build();\n+    FunctionType retNumber = new FunctionBuilder(registry)\n+        .withTypeOfThis(DATE_TYPE)\n+        .withReturnType(NUMBER_TYPE).build();\n+\n+    assertLeastSupertype(\n+        \"Function\", retString, retNumber);\n+    assertGreatestSubtype(\n+        \"NoObject\", retString, retNumber);\n+  }\n+\n+  private void assertLeastSupertype(String s, JSType t1, JSType t2) {\n+    assertEquals(s, t1.getLeastSupertype(t2).toString());\n+    assertEquals(s, t2.getLeastSupertype(t1).toString());\n+  }\n+\n+  private void assertGreatestSubtype(String s, JSType t1, JSType t2) {\n+    assertEquals(s, t1.getGreatestSubtype(t2).toString());\n+    assertEquals(s, t2.getGreatestSubtype(t1).toString());\n+  }\n }\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n    */\n   public void testFunctionTypeRelationships() {\n     FunctionType dateMethodEmpty = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters())\n         .withTypeOfThis(DATE_TYPE).build();\n     FunctionType dateMethodWithParam = new FunctionBuilder(registry)\n         .withParamsNode(registry.createParameters(NUMBER_TYPE))\n         .withReturnType(NUMBER_TYPE)\n         .withTypeOfThis(DATE_TYPE).build();\n     FunctionType stringMethodEmpty = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters())\n         .withTypeOfThis(STRING_OBJECT_TYPE).build();\n     FunctionType stringMethodWithParam = new FunctionBuilder(registry)\n         .withParamsNode(registry.createParameters(NUMBER_TYPE))\n     FunctionType googBarParamFn = new FunctionBuilder(registry)\n         .withParamsNode(registry.createParameters(googBar)).build();\n     FunctionType googBarReturnFn = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters())\n         .withReturnType(googBar).build();\n     FunctionType googSubBarMethod = new FunctionBuilder(registry)\n         .withTypeOfThis(googSubBar).build();", "timestamp": 1274202361, "metainfo": ""}