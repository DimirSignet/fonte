{"sha": "164dbb3842f3028ccdf89cdbe678d161518e9f05", "log": "Handle properties that are declared before the type resolves  R=johnlenz DELTA=368  (254 added, 97 deleted, 17 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=778   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n+import com.google.common.collect.Lists;\n import com.google.javascript.rhino.ErrorReporter;\n+import com.google.javascript.rhino.Node;\n+\n+import java.util.List;\n \n /**\n  * A {@code NamedType} is a named reference to some other type.  This provides\n   private boolean forgiving = false;\n \n   /**\n+   * Property-defining continuations.\n+   */\n+  private List<PropertyContinuation> propertyContinuations = null;\n+\n+  /**\n    * Create a named type based on the reference.\n    */\n   NamedType(JSTypeRegistry registry, String reference,\n   @Override\n   void forgiveUnknownNames() {\n     forgiving = true;\n+  }\n+\n+  @Override\n+  boolean defineProperty(String propertyName, JSType type,\n+      boolean inferred, boolean inExterns, Node propertyNode) {\n+    if (!isResolved()) {\n+      // If this is an unresolved object type, we need to save all its\n+      // properties and define them when it is resolved.\n+      if (propertyContinuations == null) {\n+        propertyContinuations = Lists.newArrayList();\n+      }\n+      propertyContinuations.add(\n+          new PropertyContinuation(\n+              propertyName, type, inferred, inExterns, propertyNode));\n+      return true;\n+    } else {\n+      return super.defineProperty(\n+          propertyName, type, inferred, inExterns, propertyNode);\n+    }\n+  }\n+\n+  private void finishPropertyContinuations() {\n+    ObjectType referencedObjType = getReferencedObjTypeInternal();\n+    if (referencedObjType != null && !referencedObjType.isUnknownType()) {\n+      if (propertyContinuations != null) {\n+        for (PropertyContinuation c : propertyContinuations) {\n+          c.commit(this);\n+        }\n+      }\n+    }\n+    propertyContinuations = null;\n   }\n \n   /** Returns the type to which this refers (which is unknown if unresolved). */\n \n     if (resolved) {\n       super.resolveInternal(t, enclosing);\n+      finishPropertyContinuations();\n       return registry.isLastGeneration() ?\n           getReferencedType() : this;\n     }\n     }\n \n     super.resolveInternal(t, enclosing);\n+    if (isResolved()) {\n+      finishPropertyContinuations();\n+    }\n     return registry.isLastGeneration() ?\n         getReferencedType() : this;\n   }\n       return true;\n     }\n   }\n+\n+  /** Store enough information to define a property at a later time. */\n+  private static final class PropertyContinuation {\n+    private final String propertyName;\n+    private final JSType type;\n+    private final boolean inferred;\n+    private final boolean inExterns;\n+    private final Node propertyNode;\n+\n+    private PropertyContinuation(\n+        String propertyName,\n+        JSType type,\n+        boolean inferred,\n+        boolean inExterns,\n+        Node propertyNode) {\n+      this.propertyName = propertyName;\n+      this.type = type;\n+      this.inferred = inferred;\n+      this.inExterns = inExterns;\n+      this.propertyNode = propertyNode;\n+    }\n+\n+    void commit(ObjectType target) {\n+      target.defineProperty(\n+          propertyName, type, inferred, inExterns, propertyNode);\n+    }\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n     return referencedType;\n   }\n \n+  ObjectType getReferencedObjTypeInternal() {\n+    return referencedObjType;\n+  }\n+\n   void setReferencedType(JSType referencedType) {\n     this.referencedType = referencedType;\n     if (referencedType instanceof ObjectType) {\n--- a/src/com/google/javascript/rhino/testing/Asserts.java\n+++ b/src/com/google/javascript/rhino/testing/Asserts.java\n \n   /** @return The resolved type */\n   public static JSType assertValidResolve(JSType type) {\n-    return assertValidResolve(type, new EmptyScope());\n+    return assertValidResolve(type, MapBasedScope.emptyScope());\n   }\n \n   /** @return The resolved type */\n--- a/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n+++ b/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.testing;\n \n import com.google.javascript.rhino.JSTypeExpression;\n       JSTypeRegistry registry, ObjectType receivingType, String methodName,\n       JSType returnType) {\n     receivingType.defineDeclaredProperty(methodName,\n-        new FunctionBuilder(registry).withReturnType(returnType).build(), true, null);\n+        new FunctionBuilder(registry).withReturnType(returnType).build(),\n+        true, null);\n   }\n \n   protected JSType createUnionType(JSType... variants) {\n       + \" * @constructor\\n\"\n       + \" */\\n\"\n       + \"function ActiveXObject(progId, opt_location) {}\\n\";\n+\n+  protected final void assertTypeEquals(JSType a, JSType b) {\n+    Asserts.assertTypeEquals(a, b);\n+  }\n+\n+  protected final void assertTypeEquals(String msg, JSType a, JSType b) {\n+    Asserts.assertTypeEquals(msg, a, b);\n+  }\n+\n+  protected final void assertTypeNotEquals(JSType a, JSType b) {\n+    Asserts.assertTypeNotEquals(a, b);\n+  }\n+\n+  protected final void assertTypeNotEquals(String msg, JSType a, JSType b) {\n+    Asserts.assertTypeNotEquals(msg, a, b);\n+  }\n }\n--- /dev/null\n+++ b/src/com/google/javascript/rhino/testing/MapBasedScope.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.testing;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.SimpleSlot;\n+import com.google.javascript.rhino.jstype.StaticScope;\n+import com.google.javascript.rhino.jstype.StaticSlot;\n+\n+import java.util.Map;\n+\n+/**\n+ * A scope based on a simple hashmap.\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public class MapBasedScope implements StaticScope<JSType> {\n+  private final Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n+\n+  public MapBasedScope(Map<String, ? extends JSType> namesToTypes) {\n+    for (Map.Entry<String, ? extends JSType> entry : namesToTypes.entrySet()) {\n+      slots.put(\n+          entry.getKey(),\n+          new SimpleSlot(entry.getKey(), entry.getValue(), false));\n+    }\n+  }\n+\n+  public static MapBasedScope emptyScope() {\n+    return new MapBasedScope(ImmutableMap.<String, JSType>of());\n+  }\n+\n+  @Override\n+  public StaticScope<JSType> getParentScope() {\n+    return null;\n+  }\n+\n+  @Override\n+  public StaticSlot<JSType> getSlot(String name) {\n+    return slots.get(name);\n+  }\n+\n+  @Override\n+  public StaticSlot<JSType> getOwnSlot(String name) {\n+    return slots.get(name);\n+  }\n+\n+  @Override\n+  public JSType getTypeOfThis() {\n+    return null;\n+  }\n+}\n--- a/test/com/google/javascript/rhino/jstype/FunctionParamBuilderTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionParamBuilderTest.java\n package com.google.javascript.rhino.jstype;\n \n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.testing.Asserts;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n \n \n     assertTrue(params.getFirstChild().getNext().isOptionalArg());\n     assertTrue(params.getLastChild().isVarArgs());\n   }\n-\n-  private void assertTypeEquals(JSType a, JSType b) {\n-    Asserts.assertTypeEquals(a, b);\n-  }\n }\n--- a/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode;\n import com.google.javascript.rhino.testing.Asserts;\n+import com.google.javascript.rhino.testing.MapBasedScope;\n \n import junit.framework.TestCase;\n \n     immediateRegistry.setResolveMode(ResolveMode.IMMEDIATE);\n \n     Node expr = new Node(Token.QMARK, Node.newString(\"foo\"));\n-    StaticScope<JSType> empty = new EmptyScope();\n+    StaticScope<JSType> empty = MapBasedScope.emptyScope();\n \n     JSType type = lazyExprRegistry.createFromTypeNodes(\n         expr, \"source.js\", empty);\n     lazyExprRegistry.setResolveMode(ResolveMode.LAZY_EXPRESSIONS);\n \n     Node expr = new Node(Token.QMARK, Node.newString(\"foo\"));\n-    StaticScope<JSType> empty = new EmptyScope();\n+    StaticScope<JSType> empty = MapBasedScope.emptyScope();\n \n     JSType type = lazyExprRegistry.createFromTypeNodes(\n         expr, \"source.js\", empty);\n \n     Node expr = new Node(Token.STAR);\n     JSType type = lazyExprRegistry.createFromTypeNodes(\n-        expr, \"source.js\", new EmptyScope());\n+        expr, \"source.js\", MapBasedScope.emptyScope());\n     assertTrue(type instanceof AllType);\n   }\n \n   private void assertTypeEquals(JSType a, JSType b) {\n     Asserts.assertTypeEquals(a, b);\n   }\n-\n-  private static class EmptyScope implements StaticScope<JSType> {\n-    public StaticSlot<JSType> getSlot(final String name) { return null; }\n-    public StaticSlot<JSType> getOwnSlot(String name) { return null; }\n-    public StaticScope<JSType> getParentScope() { return null; }\n-    public JSType getTypeOfThis() { return null; }\n-  }\n }\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n import com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordProperty;\n import com.google.javascript.rhino.testing.Asserts;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n-import com.google.javascript.rhino.testing.EmptyScope;\n+import com.google.javascript.rhino.testing.MapBasedScope;\n \n import java.util.HashMap;\n import java.util.List;\n   private EnumElementType elementsType;\n   private NamedType forwardDeclaredNamedType;\n \n-  private static final StaticScope<JSType> EMPTY_SCOPE = new EmptyScope();\n+  private static final StaticScope<JSType> EMPTY_SCOPE =\n+      MapBasedScope.emptyScope();\n \n   /**\n    * A non exhaustive list of representative types used to test simple\n     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, VOID_TYPE);\n \n     // canTestForShallowEqualityWith\n-    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NO_RESOLVED_TYPE));\n+    assertTrue(\n+        NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NO_RESOLVED_TYPE));\n     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));\n     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));\n-    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertTrue(\n+        NO_RESOLVED_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(DATE_TYPE));\n     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));\n     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(functionType));\n     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NULL_TYPE));\n     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));\n-    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(\n+        NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));\n     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));\n-    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n-    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertTrue(\n+        NO_RESOLVED_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertTrue(\n+        NO_RESOLVED_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));\n     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(STRING_TYPE));\n-    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n-    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertTrue(\n+        NO_RESOLVED_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(\n+        NO_RESOLVED_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ALL_TYPE));\n     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(VOID_TYPE));\n     assertFalse(NUMBER_OBJECT_TYPE.isNumberValueType());\n     assertTrue(NUMBER_OBJECT_TYPE.isObject());\n     assertFalse(NUMBER_OBJECT_TYPE.isFunctionPrototypeType());\n-    assertTrue(NUMBER_OBJECT_TYPE.getImplicitPrototype().isFunctionPrototypeType());\n+    assertTrue(\n+        NUMBER_OBJECT_TYPE.getImplicitPrototype().isFunctionPrototypeType());\n     assertFalse(NUMBER_OBJECT_TYPE.isRegexpType());\n     assertFalse(NUMBER_OBJECT_TYPE.isString());\n     assertFalse(NUMBER_OBJECT_TYPE.isStringObjectType());\n     assertFalse(STRING_OBJECT_TYPE.isNumberObjectType());\n     assertFalse(STRING_OBJECT_TYPE.isNumberValueType());\n     assertFalse(STRING_OBJECT_TYPE.isFunctionPrototypeType());\n-    assertTrue(STRING_OBJECT_TYPE.getImplicitPrototype().isFunctionPrototypeType());\n+    assertTrue(\n+        STRING_OBJECT_TYPE.getImplicitPrototype().isFunctionPrototypeType());\n     assertFalse(STRING_OBJECT_TYPE.isRegexpType());\n     assertTrue(STRING_OBJECT_TYPE.isString());\n     assertTrue(STRING_OBJECT_TYPE.isStringObjectType());\n    * {@link JSTypeRegistry#createRecordType}.\n    */\n   public void testCreateRecordType() throws Exception {\n-    Map<String, RecordProperty> properties = new HashMap<String, RecordProperty>();\n+    Map<String, RecordProperty> properties =\n+        new HashMap<String, RecordProperty>();\n     properties.put(\"hello\", new RecordProperty(NUMBER_TYPE, null));\n \n     JSType recordType = registry.createRecordType(properties);\n   private ArrowType createArrowType(Node params) {\n     return registry.createArrowType(params);\n   }\n-\n-  private void assertTypeEquals(JSType a, JSType b) {\n-    Asserts.assertTypeEquals(a, b);\n-  }\n-\n-  private void assertTypeEquals(String msg, JSType a, JSType b) {\n-    Asserts.assertTypeEquals(msg, a, b);\n-  }\n-\n-  private void assertTypeNotEquals(JSType a, JSType b) {\n-    Asserts.assertTypeNotEquals(a, b);\n-  }\n-\n-  private void assertTypeNotEquals(String msg, JSType a, JSType b) {\n-    Asserts.assertTypeNotEquals(msg, a, b);\n-  }\n }\n--- /dev/null\n+++ b/test/com/google/javascript/rhino/jstype/NamedTypeTest.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n+import com.google.javascript.rhino.testing.MapBasedScope;\n+\n+/**\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public class NamedTypeTest extends BaseJSTypeTestCase {\n+  public void testNamedTypeProperties() {\n+    NamedType namedA = new NamedType(registry, \"TypeA\", \"source\", 1, 0);\n+    FunctionType ctorA = registry.createConstructorType(\n+        \"TypeA\", null, null, null);\n+    ObjectType typeA = ctorA.getInstanceType();\n+\n+    namedA.defineDeclaredProperty(\"foo\", NUMBER_TYPE, false, null);\n+    namedA.resolve(\n+        null,\n+        new MapBasedScope(\n+            ImmutableMap.of(\"TypeA\", ctorA)));\n+    assertTypeEquals(NUMBER_TYPE, typeA.getPropertyType(\"foo\"));\n+  }\n+}", "timestamp": 1299523541, "metainfo": ""}