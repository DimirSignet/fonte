{"sha": "ce94280c73fbc6ce9331792e3003e75356ab6ba6", "log": "Enhance javadoc  ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n      * Appends another formatter.\n      *\n      * @param formatter  the formatter to add\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      * @throws IllegalArgumentException if formatter is null or of an invalid type\n      */\n     public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {\n      * built from this DateTimeFormatterBuilder.\n      *\n      * @param printer  the printer to add\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      * @throws IllegalArgumentException if printer is null or of an invalid type\n      */\n     public DateTimeFormatterBuilder append(DateTimePrinter printer) {\n      * built from this builder.\n      *\n      * @param parser  the parser to add\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      * @throws IllegalArgumentException if parser is null or of an invalid type\n      */\n     public DateTimeFormatterBuilder append(DateTimeParser parser) {\n      *\n      * @param printer  the printer to add\n      * @param parser  the parser to add\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      * @throws IllegalArgumentException if printer or parser is null or of an invalid type\n      */\n     public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) {\n      * chosen, and so on. If none of these parsers succeeds, then the failed\n      * position of the parser that made the greatest progress is returned.\n      * <p>\n-     * Only the printer is optional. In addtion, it is illegal for any but the\n+     * Only the printer is optional. In addition, it is illegal for any but the\n      * last of the parser array elements to be null. If the last element is\n      * null, this represents the empty parser. The presence of an empty parser\n      * indicates that the entire array of parse formats is optional.\n      *\n      * @param printer  the printer to add\n      * @param parsers  the parsers to add\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      * @throws IllegalArgumentException if any printer or parser is of an invalid type\n      * @throws IllegalArgumentException if any parser element but the last is null\n      */\n      * Appends just a parser element which is optional. With no matching\n      * printer, a printer cannot be built from this DateTimeFormatterBuilder.\n      *\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      * @throws IllegalArgumentException if parser is null or of an invalid type\n      */\n     public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {\n      * Instructs the printer to emit a specific character, and the parser to\n      * expect it. The parser is case-insensitive.\n      *\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendLiteral(char c) {\n         return append0(new CharacterLiteral(c));\n      * Instructs the printer to emit specific text, and the parser to expect\n      * it. The parser is case-insensitive.\n      *\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      * @throws IllegalArgumentException if text is null\n      */\n     public DateTimeFormatterBuilder appendLiteral(String text) {\n      * Instructs the printer to emit a field value as a decimal number, and the\n      * parser to expect an unsigned decimal number.\n      *\n-     * @param fieldType type of field to append\n-     * @param minDigits minumum number of digits to <i>print</i>\n-     * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n+     * @param fieldType  type of field to append\n+     * @param minDigits  minimum number of digits to <i>print</i>\n+     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      * @throws IllegalArgumentException if field type is null\n      */\n     public DateTimeFormatterBuilder appendDecimal(\n      * number (smaller numbers will be left-padded with zeros), and the parser\n      * to expect an unsigned decimal number with the same fixed width.\n      * \n-     * @param fieldType type of field to append\n-     * @param numDigits the exact number of digits to parse or print, except if\n+     * @param fieldType  type of field to append\n+     * @param numDigits  the exact number of digits to parse or print, except if\n      * printed value requires more digits\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>\n      * @since 1.5\n      */\n      * Instructs the printer to emit a field value as a decimal number, and the\n      * parser to expect a signed decimal number.\n      *\n-     * @param fieldType type of field to append\n-     * @param minDigits minumum number of digits to <i>print</i>\n-     * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n+     * @param fieldType  type of field to append\n+     * @param minDigits  minimum number of digits to <i>print</i>\n+     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      * @throws IllegalArgumentException if field type is null\n      */\n     public DateTimeFormatterBuilder appendSignedDecimal(\n      * number (smaller numbers will be left-padded with zeros), and the parser\n      * to expect an signed decimal number with the same fixed width.\n      * \n-     * @param fieldType type of field to append\n-     * @param numDigits the exact number of digits to parse or print, except if\n+     * @param fieldType  type of field to append\n+     * @param numDigits  the exact number of digits to parse or print, except if\n      * printed value requires more digits\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>\n      * @since 1.5\n      */\n      * Instructs the printer to emit a field value as text, and the\n      * parser to expect text.\n      *\n-     * @param fieldType type of field to append\n-     * @return this DateTimeFormatterBuilder\n+     * @param fieldType  type of field to append\n+     * @return this DateTimeFormatterBuilder, for chaining\n      * @throws IllegalArgumentException if field type is null\n      */\n     public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) {\n      * Instructs the printer to emit a field value as short text, and the\n      * parser to expect text.\n      *\n-     * @param fieldType type of field to append\n-     * @return this DateTimeFormatterBuilder\n+     * @param fieldType  type of field to append\n+     * @return this DateTimeFormatterBuilder, for chaining\n      * @throws IllegalArgumentException if field type is null\n      */\n     public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\n \n     /**\n      * Instructs the printer to emit a remainder of time as a decimal fraction,\n-     * sans decimal point. For example, if the field is specified as\n+     * without decimal point. For example, if the field is specified as\n      * minuteOfHour and the time is 12:30:45, the value printed is 75. A\n      * decimal point is implied, so the fraction is 0.75, or three-quarters of\n      * a minute.\n      *\n-     * @param fieldType type of field to append\n-     * @param minDigits minumum number of digits to print.\n-     * @param maxDigits maximum number of digits to print or parse.\n-     * @return this DateTimeFormatterBuilder\n+     * @param fieldType  type of field to append\n+     * @param minDigits  minimum number of digits to print.\n+     * @param maxDigits  maximum number of digits to print or parse.\n+     * @return this DateTimeFormatterBuilder, for chaining\n      * @throws IllegalArgumentException if field type is null\n      */\n     public DateTimeFormatterBuilder appendFraction(\n     }\n \n     /**\n-     * @param minDigits minumum number of digits to print\n-     * @param maxDigits maximum number of digits to print or parse\n-     * @return this DateTimeFormatterBuilder\n+     * Appends the print/parse of a fractional second.\n+     * <p>\n+     * This reliably handles the case where fractional digits are being handled\n+     * beyond a visible decimal point. The digits parsed will always be treated\n+     * as the most significant (numerically largest) digits.\n+     * Thus '23' will be parsed as 230 milliseconds.\n+     * Contrast this behaviour to {@link #appendMillisOfSecond}.\n+     * This method does not print or parse the decimal point itself.\n+     * \n+     * @param minDigits  minimum number of digits to print\n+     * @param maxDigits  maximum number of digits to print or parse\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\n         return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n     }\n \n     /**\n-     * @param minDigits minumum number of digits to print\n-     * @param maxDigits maximum number of digits to print or parse\n-     * @return this DateTimeFormatterBuilder\n+     * Appends the print/parse of a fractional minute.\n+     * <p>\n+     * This reliably handles the case where fractional digits are being handled\n+     * beyond a visible decimal point. The digits parsed will always be treated\n+     * as the most significant (numerically largest) digits.\n+     * Thus '23' will be parsed as 0.23 minutes (converted to milliseconds).\n+     * This method does not print or parse the decimal point itself.\n+     * \n+     * @param minDigits  minimum number of digits to print\n+     * @param maxDigits  maximum number of digits to print or parse\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) {\n         return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits);\n     }\n \n     /**\n-     * @param minDigits minumum number of digits to print\n-     * @param maxDigits maximum number of digits to print or parse\n-     * @return this DateTimeFormatterBuilder\n+     * Appends the print/parse of a fractional hour.\n+     * <p>\n+     * This reliably handles the case where fractional digits are being handled\n+     * beyond a visible decimal point. The digits parsed will always be treated\n+     * as the most significant (numerically largest) digits.\n+     * Thus '23' will be parsed as 0.23 hours (converted to milliseconds).\n+     * This method does not print or parse the decimal point itself.\n+     * \n+     * @param minDigits  minimum number of digits to print\n+     * @param maxDigits  maximum number of digits to print or parse\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) {\n         return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits);\n     }\n \n     /**\n-     * @param minDigits minumum number of digits to print\n-     * @param maxDigits maximum number of digits to print or parse\n-     * @return this DateTimeFormatterBuilder\n+     * Appends the print/parse of a fractional day.\n+     * <p>\n+     * This reliably handles the case where fractional digits are being handled\n+     * beyond a visible decimal point. The digits parsed will always be treated\n+     * as the most significant (numerically largest) digits.\n+     * Thus '23' will be parsed as 0.23 days (converted to milliseconds).\n+     * This method does not print or parse the decimal point itself.\n+     * \n+     * @param minDigits  minimum number of digits to print\n+     * @param maxDigits  maximum number of digits to print or parse\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) {\n         return appendFraction(DateTimeFieldType.dayOfYear(), minDigits, maxDigits);\n      * if you are using the field as a fraction. Instead, a fractional\n      * millisecond should be produced using {@link #appendFractionOfSecond}.\n      *\n-     * @param minDigits minumum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {\n         return appendDecimal(DateTimeFieldType.millisOfSecond(), minDigits, 3);\n     /**\n      * Instructs the printer to emit a numeric millisOfDay field.\n      *\n-     * @param minDigits minumum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {\n         return appendDecimal(DateTimeFieldType.millisOfDay(), minDigits, 8);\n     /**\n      * Instructs the printer to emit a numeric secondOfMinute field.\n      *\n-     * @param minDigits minumum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\n         return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n     /**\n      * Instructs the printer to emit a numeric secondOfDay field.\n      *\n-     * @param minDigits minumum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {\n         return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5);\n     /**\n      * Instructs the printer to emit a numeric minuteOfHour field.\n      *\n-     * @param minDigits minumum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\n         return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n     /**\n      * Instructs the printer to emit a numeric minuteOfDay field.\n      *\n-     * @param minDigits minumum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {\n         return appendDecimal(DateTimeFieldType.minuteOfDay(), minDigits, 4);\n     /**\n      * Instructs the printer to emit a numeric hourOfDay field.\n      *\n-     * @param minDigits minumum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\n         return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n     /**\n      * Instructs the printer to emit a numeric clockhourOfDay field.\n      *\n-     * @param minDigits minumum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @param minDigits minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {\n         return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2);\n     /**\n      * Instructs the printer to emit a numeric hourOfHalfday field.\n      *\n-     * @param minDigits minumum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {\n         return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2);\n     /**\n      * Instructs the printer to emit a numeric clockhourOfHalfday field.\n      *\n-     * @param minDigits minumum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {\n         return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2);\n     /**\n      * Instructs the printer to emit a numeric dayOfWeek field.\n      *\n-     * @param minDigits minumum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {\n         return appendDecimal(DateTimeFieldType.dayOfWeek(), minDigits, 1);\n     /**\n      * Instructs the printer to emit a numeric dayOfMonth field.\n      *\n-     * @param minDigits minumum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\n         return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n     /**\n      * Instructs the printer to emit a numeric dayOfYear field.\n      *\n-     * @param minDigits minumum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {\n         return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3);\n     /**\n      * Instructs the printer to emit a numeric weekOfWeekyear field.\n      *\n-     * @param minDigits minumum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\n         return appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);\n     /**\n      * Instructs the printer to emit a numeric weekyear field.\n      *\n-     * @param minDigits minumum number of digits to <i>print</i>\n-     * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n+     * @param minDigits  minimum number of digits to <i>print</i>\n+     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {\n         return appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits);\n     /**\n      * Instructs the printer to emit a numeric monthOfYear field.\n      *\n-     * @param minDigits minumum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\n         return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n     /**\n      * Instructs the printer to emit a numeric year field.\n      *\n-     * @param minDigits minumum number of digits to <i>print</i>\n-     * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n+     * @param minDigits  minimum number of digits to <i>print</i>\n+     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\n         return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n      * </pre>\n      *\n      * @param pivot  pivot year to use when parsing\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) {\n         return appendTwoDigitYear(pivot, false);\n      * @param pivot  pivot year to use when parsing\n      * @param lenientParse  when true, if digit count is not two, it is treated\n      * as an absolute year\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      * @since 1.1\n      */\n     public DateTimeFormatterBuilder appendTwoDigitYear(int pivot, boolean lenientParse) {\n      * </pre>\n      *\n      * @param pivot  pivot weekyear to use when parsing\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot) {\n         return appendTwoDigitWeekyear(pivot, false);\n      * @param pivot  pivot weekyear to use when parsing\n      * @param lenientParse  when true, if digit count is not two, it is treated\n      * as an absolute weekyear\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      * @since 1.1\n      */\n     public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot, boolean lenientParse) {\n     /**\n      * Instructs the printer to emit a numeric yearOfEra field.\n      *\n-     * @param minDigits minumum number of digits to <i>print</i>\n-     * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n+     * @param minDigits  minimum number of digits to <i>print</i>\n+     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {\n         return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits);\n     /**\n      * Instructs the printer to emit a numeric year of century field.\n      *\n-     * @param minDigits minumum number of digits to print\n-     * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n+     * @param minDigits  minimum number of digits to print\n+     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {\n         return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits);\n     /**\n      * Instructs the printer to emit a numeric century of era field.\n      *\n-     * @param minDigits minumum number of digits to print\n-     * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n+     * @param minDigits  minimum number of digits to print\n+     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) {\n         return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits);\n      * Instructs the printer to emit a locale-specific AM/PM text, and the\n      * parser to expect it. The parser is case-insensitive.\n      *\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendHalfdayOfDayText() {\n         return appendText(DateTimeFieldType.halfdayOfDay());\n      * Instructs the printer to emit a locale-specific dayOfWeek text. The\n      * parser will accept a long or short dayOfWeek text, case-insensitive.\n      *\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendDayOfWeekText() {\n         return appendText(DateTimeFieldType.dayOfWeek());\n      * text. The parser will accept a long or short dayOfWeek text,\n      * case-insensitive.\n      *\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendDayOfWeekShortText() {\n         return appendShortText(DateTimeFieldType.dayOfWeek());\n      * text. The parser will accept a long or short monthOfYear text,\n      * case-insensitive.\n      *\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendMonthOfYearText() { \n         return appendText(DateTimeFieldType.monthOfYear());\n      * Instructs the printer to emit a locale-specific monthOfYear text. The\n      * parser will accept a long or short monthOfYear text, case-insensitive.\n      *\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendMonthOfYearShortText() {\n         return appendShortText(DateTimeFieldType.monthOfYear());\n      * Instructs the printer to emit a locale-specific era text (BC/AD), and\n      * the parser to expect it. The parser is case-insensitive.\n      *\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendEraText() {\n         return appendText(DateTimeFieldType.era());\n      * parser cannot be created from this builder if a time zone name is\n      * appended.\n      *\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendTimeZoneName() {\n         return append0(new TimeZoneName(TimeZoneName.LONG_NAME), null);\n      * name. A parser cannot be created from this builder if time zone\n      * name is appended.\n      *\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendTimeZoneShortName() {\n         return append0(new TimeZoneName(TimeZoneName.SHORT_NAME), null);\n      * Instructs the printer to emit the identifier of the time zone.\n      * This field cannot currently be parsed.\n      *\n-     * @return this DateTimeFormatterBuilder\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendTimeZoneId() {\n         return append0(new TimeZoneName(TimeZoneName.ID), null);\n      * If zero offset text is supplied, then it will be printed when the zone is zero.\n      * During parsing, either the zero offset text, or the offset will be parsed.\n      *\n-     * @param zeroOffsetText Text to use if time zone offset is zero. If\n+     * @param zeroOffsetText  the text to use if time zone offset is zero. If\n      * null, offset is always shown.\n-     * @param showSeparators If true, prints ':' separator before minute and\n+     * @param showSeparators  if true, prints ':' separator before minute and\n      * second field and prints '.' separator before fraction field.\n-     * @param minFields minimum number of fields to print, stopping when no\n+     * @param minFields  minimum number of fields to print, stopping when no\n      * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction\n-     * @param maxFields maximum number of fields to print\n-     * @return this DateTimeFormatterBuilder\n+     * @param maxFields  maximum number of fields to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendTimeZoneOffset(\n             String zeroOffsetText, boolean showSeparators,\n      * If zero offset print text is supplied, then it will be printed when the zone is zero.\n      * If zero offset parse text is supplied, then either it or the offset will be parsed.\n      *\n-     * @param zeroOffsetPrintText Text to print if time zone offset is zero. If\n+     * @param zeroOffsetPrintText  the text to print if time zone offset is zero. If\n      * null, offset is always shown.\n-     * @param zeroOffsetParseText Text to optionally parse to indicate that the time\n+     * @param zeroOffsetParseText  the text to optionally parse to indicate that the time\n      * zone offset is zero. If null, then always use the offset.\n-     * @param showSeparators If true, prints ':' separator before minute and\n+     * @param showSeparators  if true, prints ':' separator before minute and\n      * second field and prints '.' separator before fraction field.\n-     * @param minFields minimum number of fields to print, stopping when no\n+     * @param minFields  minimum number of fields to print, stopping when no\n      * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction\n-     * @param maxFields maximum number of fields to print\n-     * @return this DateTimeFormatterBuilder\n+     * @param maxFields  maximum number of fields to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendTimeZoneOffset(\n             String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators,", "timestamp": 1257624433, "metainfo": ""}