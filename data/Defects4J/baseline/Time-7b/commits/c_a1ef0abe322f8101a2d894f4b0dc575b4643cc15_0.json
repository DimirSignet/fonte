{"sha": "a1ef0abe322f8101a2d894f4b0dc575b4643cc15", "log": "Move partial instants from dedicated package to main package   ", "commit": "\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/AbstractPartial.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.InstantConverter;\n+\n+/**\n+ * AbstractPartial provides a standard base implementation of most methods\n+ * in the ReadablePartial interface.\n+ * <p>\n+ * Calculations on are performed using a {@link Chronology}.\n+ * This chronology is set to be in the UTC time zone for all calculations.\n+ * <p>\n+ * AbstractPartial allows subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class AbstractPartial implements ReadablePartial, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2353678632973660L;\n+\n+    /** The chronology in use */\n+    protected Chronology iChronology;\n+    /** The values of each field in this partial */\n+    protected int[] iValues;\n+    /** The values of each field in this partial */\n+    protected transient DateTimeField[] iFields;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a AbstractPartial with the current time, using ISOChronology in\n+     * the default zone to extract the fields.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     */\n+    public AbstractPartial() {\n+        this(DateTimeUtils.currentTimeMillis(), null);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial with the current time, using the specified chronology\n+     * and zone to extract the fields.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public AbstractPartial(Chronology chronology) {\n+        this(DateTimeUtils.currentTimeMillis(), chronology);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial extracting the partial fields from the specified\n+     * milliseconds using the ISOChronology in the default zone.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public AbstractPartial(long instant) {\n+        this(instant, null);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial extracting the partial fields from the specified\n+     * milliseconds using the chronology provided.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public AbstractPartial(long instant, Chronology chronology) {\n+        super();\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        iChronology = chronology.withUTC();\n+        iFields = initFields(iChronology);\n+        iValues = initValues(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial from an Object that represents a time.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public AbstractPartial(Object instant) {\n+        super();\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        long millis = converter.getInstantMillis(instant);\n+        Chronology chronology = converter.getChronology(instant);\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        iChronology = chronology.withUTC();\n+        iFields = initFields(iChronology);\n+        iValues = initValues(millis, chronology);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial from an Object that represents a time, using the\n+     * specified chronology.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @param chronology  the chronology, null means ISOChronology\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public AbstractPartial(Object instant, Chronology chronology) {\n+        super();\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        long millis = converter.getInstantMillis(instant, chronology);\n+        chronology = converter.getChronology(instant, chronology);\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        iChronology = chronology.withUTC();\n+        iFields = initFields(iChronology);\n+        iValues = initValues(millis, chronology);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial with specified time field values and chronology.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param values  the new set of values\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public AbstractPartial(int[] values, Chronology chronology) {\n+        super();\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        iChronology = chronology.withUTC();\n+        iFields = initFields(iChronology);\n+        iValues = values;\n+        chronology.validate(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Recreates the state of this object after deserialization.\n+     * \n+     * @param in  the input stream\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        iFields = initFields(iChronology);\n+    }\n+\n+    /**\n+     * Initialize the array of fields.\n+     * The field and value arrays must match.\n+     * \n+     * @param chrono  the chronology to use\n+     */\n+    protected abstract DateTimeField[] initFields(Chronology chrono);\n+\n+    /**\n+     * Initialize the array of values.\n+     * The field and value arrays must match.\n+     * \n+     * @param instant  the instant to use\n+     * @param chrono  the chronology to use\n+     */\n+    protected abstract int[] initValues(long instant, Chronology chrono);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial.\n+     * \n+     * @return the field count\n+     */\n+    public int getFieldSize() {\n+        return iFields.length;\n+    }\n+\n+    /**\n+     * Gets the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @return the field\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeField getField(int index) {\n+        if (index < 0 || index >= iFields.length) {\n+            throw new IllegalArgumentException(Integer.toString(index));\n+        }\n+        return iFields[index];\n+    }\n+\n+    /**\n+     * Gets the value of the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @return the value\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public int getValue(int index) {\n+        if (index < 0 || index >= iValues.length) {\n+            throw new IllegalArgumentException(Integer.toString(index));\n+        }\n+        return iValues[index];\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an array of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n+     *\n+     * @return the fields supported (cloned), largest to smallest\n+     */\n+    public DateTimeField[] getFields() {\n+        return (DateTimeField[]) iFields.clone();\n+    }\n+\n+    /**\n+     * Gets an array of the value of each of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n+     * Each value corresponds to the same array index as <code>getFields()</code>\n+     *\n+     * @return the current values of each field (cloned), largest to smallest\n+     */\n+    public int[] getValues() {\n+        return (int[]) iValues.clone();\n+    }\n+\n+    /**\n+     * Gets the chronology of the partial which is never null.\n+     * <p>\n+     * The {@link Chronology} is the calculation engine behind the partial and\n+     * provides conversion and validation of the fields in a particular calendar system.\n+     * \n+     * @return the chronology\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value of one of the fields of a datetime.\n+     * <p>\n+     * The field specified must be one of those that is supported by the partial.\n+     *\n+     * @param field  a DateTimeField instance that is supported by this partial\n+     * @return the value of that field\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    public int get(DateTimeField field) {\n+        for (int i = 0; i < iFields.length; i++) {\n+            if (iFields[i] == field) {\n+                return iValues[i];\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Field '\" + field + \"' is not supported\");\n+    }\n+\n+    /**\n+     * Checks whether the field specified is supported by this partial.\n+     *\n+     * @param field  the field to check, may be null which returns false\n+     * @return true if the field is supported\n+     */\n+    public boolean isSupported(DateTimeField field) {\n+        for (int i = 0; i < iFields.length; i++) {\n+            if (iFields[i] == field) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Resolves this partial against another complete millisecond instant to\n+     * create a new full instant specifying the time zone to resolve with.\n+     * <p>\n+     * For example, if this partial represents a time, then the result of this\n+     * method will be the datetime from the specified base instant plus the\n+     * time from this partial set using the time zone specified.\n+     *\n+     * @param baseInstant  source of missing fields\n+     * @param zone  the time zone to use, null means default\n+     * @return the combined instant in milliseconds\n+     */\n+    public long resolve(long baseInstant, DateTimeZone zone) {\n+        Chronology chrono = iChronology.withZone(zone);\n+        return resolve(baseInstant, chrono);\n+    }\n+\n+    /**\n+     * Resolves this partial against another complete instant to create a new\n+     * full instant. The combination is performed using the chronology of the\n+     * specified instant.\n+     * <p>\n+     * For example, if this partial represents a time, then the result of this\n+     * method will be the datetime from the specified base instant plus the\n+     * time from this partial.\n+     *\n+     * @param baseInstant  the instant that provides the missing fields, null means now\n+     * @return the combined datetime\n+     */\n+    public DateTime resolveDateTime(ReadableInstant baseInstant) {\n+        long resolved;\n+        Chronology chrono;\n+        if (baseInstant == null) {\n+            chrono = ISOChronology.getInstance();\n+            resolved = resolve(DateTimeUtils.currentTimeMillis(), chrono);\n+        } else {\n+            chrono = baseInstant.getChronology();\n+            resolved = resolve(baseInstant.getMillis(), chrono);\n+        }\n+        return new DateTime(resolved, chrono);\n+    }\n+\n+    /**\n+     * Resolves this partial into another complete instant setting the relevant\n+     * fields on the writable instant. The combination is performed using the\n+     * chronology of the specified instant.\n+     * <p>\n+     * For example, if this partial represents a time, then the input writable\n+     * instant will be updated with the time from this partial.\n+     *\n+     * @param baseInstant  the instant to set into, must not be null\n+     * @throws IllegalArgumentException if the base instant is null\n+     */\n+    public void resolveInto(ReadWritableInstant baseInstant) {\n+        if (baseInstant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        Chronology chrono = baseInstant.getChronology();\n+        long resolved = resolve(baseInstant.getMillis(), chrono);\n+        baseInstant.setMillis(resolved);\n+    }\n+\n+    /**\n+     * Resolve this partial into the base millis using the specified chronology.\n+     * \n+     * @param baseInstant  the base millisecond instant\n+     * @param chrono  the chronology\n+     * @return the new resolved millis\n+     */\n+    protected long resolve(long baseInstant, Chronology chrono) {\n+        long millis = baseInstant;\n+        for (int i = 0; i < iFields.length; i++) {\n+            millis = iFields[i].set(millis, iValues[i]);\n+        }\n+        return millis;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this ReadablePartial with another returning true if the chronology,\n+     * fields and values are equal.\n+     *\n+     * @param partial  an object to check against\n+     * @return true if fields and values are equal\n+     */\n+    public boolean equals(Object partial) {\n+        if (partial instanceof AbstractPartial) {\n+            AbstractPartial other = (AbstractPartial) partial;\n+            return Arrays.equals(iValues, other.iValues) &&\n+                   Arrays.equals(iFields, other.iFields) &&\n+                   iChronology == other.iChronology;\n+        } else if (partial instanceof ReadablePartial) {\n+            ReadablePartial other = (ReadablePartial) partial;\n+            return Arrays.equals(iValues, other.getValues()) &&\n+                   Arrays.equals(iFields, other.getFields()) &&\n+                   iChronology == other.getChronology();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets a hash code for the ReadablePartial that is compatible with the \n+     * equals method.\n+     *\n+     * @return a suitable hash code\n+     */\n+    public int hashCode() {\n+        int total = 157;\n+        for (int i = 0; i < iFields.length; i++) {\n+            total = 23 * total + iValues[i];\n+            total = 23 * total + iFields[i].hashCode();\n+        }\n+        total += iChronology.hashCode();\n+        return total;\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/Chronology.java\n+++ b/JodaTime/src/java/org/joda/time/Chronology.java\n  * information on the Joda project, please see <http://www.joda.org/>.\n  */\n package org.joda.time;\n-\n-import org.joda.time.partial.ReadablePartial;\n \n /**\n  * Chronology provides access to the individual date time fields for a\n--- a/JodaTime/src/java/org/joda/time/DateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java\n \n import java.util.Locale;\n \n-import org.joda.time.partial.ReadablePartial;\n-\n /**\n  * Defines the calculation engine for date and time fields.\n  * The interface defines a set of methods that manipulate a millisecond datetime\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/ReadablePartial.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+\n+/**\n+ * Defines an partial time that does not support every datetime field.\n+ * <p>\n+ * A <code>ReadablePartial</code> supports a set of fields which be be a\n+ * subset of those on the chronology.\n+ * A <code>ReadablePartial</code> cannot be compared to a <code>ReadableInstant</code>.\n+ * <p>\n+ * A <code>ReadablePartial</code> can be converted to a <code>ReadableInstant</code>\n+ * using one of the <code>resolve</code> methods. These work by providing a full base\n+ * instant that can be used to 'fill in the gaps'.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public interface ReadablePartial {\n+\n+    /**\n+     * Gets the number of fields that this partial supports.\n+     *\n+     * @return the number of fields supported\n+     */\n+    int getFieldSize();\n+\n+    /**\n+     * Gets the field at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    DateTimeField getField(int index);\n+\n+    /**\n+     * Gets an array of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n+     *\n+     * @return the fields supported (cloned), largest to smallest\n+     */\n+    DateTimeField[] getFields();\n+\n+    /**\n+     * Gets the value at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the value of the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    int getValue(int index);\n+\n+    /**\n+     * Gets an array of the value of each of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n+     * Each value corresponds to the same array index as <code>getFields()</code>\n+     *\n+     * @return the current values of each field (cloned), largest to smallest\n+     */\n+    int[] getValues();\n+\n+    /**\n+     * Gets the chronology of the partial which is never null.\n+     * <p>\n+     * The {@link Chronology} is the calculation engine behind the partial and\n+     * provides conversion and validation of the fields in a particular calendar system.\n+     * \n+     * @return the chronology\n+     */\n+    Chronology getChronology();\n+\n+    /**\n+     * Get the value of one of the fields of a datetime.\n+     * <p>\n+     * The field specified must be one of those that is supported by the partial.\n+     *\n+     * @param field  a DateTimeField instance that is supported by this partial\n+     * @return the value of that field\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    int get(DateTimeField field);\n+\n+    /**\n+     * Checks whether the field specified is supported by this partial.\n+     *\n+     * @param field  the field to check, may be null which returns false\n+     * @return true if the field is supported\n+     */\n+    boolean isSupported(DateTimeField field);\n+\n+    /**\n+     * Resolves this partial against another complete millisecond instant to\n+     * create a new full instant specifying the time zone to resolve with.\n+     * <p>\n+     * For example, if this partial represents a time, then the result of this\n+     * method will be the datetime from the specified base instant plus the\n+     * time from this partial set using the time zone specified.\n+     *\n+     * @param baseInstant  source of missing fields\n+     * @param zone  the time zone to use, null means default\n+     * @return the combined instant in milliseconds\n+     */\n+    long resolve(long baseInstant, DateTimeZone zone);\n+\n+    /**\n+     * Resolves this partial against another complete instant to create a new\n+     * full instant. The combination is performed using the chronology of the\n+     * specified instant.\n+     * <p>\n+     * For example, if this partial represents a time, then the result of this\n+     * method will be the datetime from the specified base instant plus the\n+     * time from this partial.\n+     *\n+     * @param baseInstant  the instant that provides the missing fields, null means now\n+     * @return the combined datetime\n+     */\n+    DateTime resolveDateTime(ReadableInstant baseInstant);\n+\n+    /**\n+     * Resolves this partial into another complete instant setting the relevant\n+     * fields on the writable instant. The combination is performed using the\n+     * chronology of the specified instant.\n+     * <p>\n+     * For example, if this partial represents a time, then the input writable\n+     * instant will be updated with the time from this partial.\n+     *\n+     * @param baseInstant  the instant to set into, must not be null\n+     * @throws IllegalArgumentException if the base instant is null\n+     */\n+    void resolveInto(ReadWritableInstant baseInstant);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this partial with the specified object for equality based\n+     * on the supported fields, chronology and values.\n+     * <p>\n+     * Two instances of ReadablePartial are equal if they have the same\n+     * chronology, same fields in same order and same values.\n+     *\n+     * @param partial  the object to compare to\n+     * @return true if equal\n+     */\n+    boolean equals(Object partial);\n+\n+    /**\n+     * Gets a hash code for the partial that is compatible with the \n+     * equals method.\n+     * <p>\n+     * The formula used must be:\n+     * <pre>\n+     *  int total = 157;\n+     *  for (int i = 0; i < fields.length; i++) {\n+     *      total = 23 * total + values[i];\n+     *      total = 23 * total + fields[i].hashCode();\n+     *  }\n+     *  total += chronology.hashCode();\n+     *  return total;\n+     * </pre>\n+     *\n+     * @return a suitable hash code\n+     */\n+    int hashCode();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value as a String in a recognisable ISO8601 format, only\n+     * displaying supported fields.\n+     * <p>\n+     * The string output is in ISO8601 format to enable the String\n+     * constructor to correctly parse it.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    String toString();\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/TimeOfDay.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+import org.joda.time.format.ISODateTimeFormat;\n+import org.joda.time.property.AbstractPartialFieldProperty;\n+\n+/**\n+ * TimeOfDay is an immutable partial supporting the hour, minute, second\n+ * and millisecond fields.\n+ * <p>\n+ * Calculations on TimeOfDay are performed using a {@link Chronology}.\n+ * This chronology is set to be in the UTC time zone for all calculations.\n+ * <p>\n+ * Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getHourOfDay()</code>\n+ * <li><code>hourOfDay().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value - <code>hourOfDay().get()</code>\n+ * <li>text value - <code>hourOfDay().getAsText()</code>\n+ * <li>short text value - <code>hourOfDay().getAsShortText()</code>\n+ * <li>maximum/minimum values - <code>hourOfDay().getMaximumValue()</code>\n+ * <li>add/subtract - <code>hourOfDay().addToCopy()</code>\n+ * <li>set - <code>hourOfDay().setCopy()</code>\n+ * </ul>\n+ * <p>\n+ * TimeOfDay is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class TimeOfDay extends AbstractPartial implements ReadablePartial, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 3633353405803318660L;\n+\n+    /** The index of the hourOfDay field in the field array */\n+    public static final int HOUR_OF_DAY = 0;\n+    /** The index of the minuteOfHour field in the field array */\n+    public static final int MINUTE_OF_HOUR = 1;\n+    /** The index of the secondOfMinute field in the field array */\n+    public static final int SECOND_OF_MINUTE = 2;\n+    /** The index of the millisOfSecond field in the field array */\n+    public static final int MILLIS_OF_SECOND = 3;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a TimeOfDay with the current time, using ISOChronology in\n+     * the default zone to extract the fields.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     */\n+    public TimeOfDay() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with the current time, using the specified chronology\n+     * and zone to extract the fields.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public TimeOfDay(Chronology chronology) {\n+        super(chronology);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay extracting the partial fields from the specified\n+     * milliseconds using the ISOChronology in the default zone.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public TimeOfDay(long instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay extracting the partial fields from the specified\n+     * milliseconds using the chronology provided.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public TimeOfDay(long instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay from an Object that represents a time.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public TimeOfDay(Object instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay from an Object that represents a time, using the\n+     * specified chronology.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @param chronology  the chronology, null means ISOChronology\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public TimeOfDay(Object instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified hour and minute and zero seconds and milliseconds\n+     * using <code>ISOChronology</code> in the default zone.\n+     * <p>\n+     * The constructor uses the no time zone initialising the fields as provided.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     */\n+    public TimeOfDay(int hourOfDay, int minuteOfHour) {\n+        this(hourOfDay, minuteOfHour, 0, 0, null);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified hour and minute and zero seconds and milliseconds.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology) {\n+        this(hourOfDay, minuteOfHour, 0, 0, chronology);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified time field values and zero milliseconds\n+     * using <code>ISOChronology</code> in the default zone.\n+     * <p>\n+     * The constructor uses the no time zone initialising the fields as provided.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     */\n+    public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute) {\n+        this(hourOfDay, minuteOfHour, secondOfMinute, 0, null);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified time field values and zero milliseconds.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) {\n+        this(hourOfDay, minuteOfHour, secondOfMinute, 0, chronology);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified time field values using\n+     * <code>ISOChronology</code> in the default zone.\n+     * <p>\n+     * The constructor uses the no time zone initialising the fields as provided.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     */\n+    public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n+        this(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, null);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified time field values and chronology.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public TimeOfDay(int hourOfDay, int minuteOfHour,\n+            int secondOfMinute, int millisOfSecond, Chronology chronology) {\n+        super(new int[] {hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond}, chronology);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified fields, values and chronology.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param values  the new set of values\n+     */\n+    TimeOfDay(TimeOfDay partial, int[] values) {\n+        super();\n+        iChronology = partial.iChronology;\n+        iValues = values;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Initialize the array of fields.\n+     * \n+     * @param chrono  the chronology to use\n+     */\n+    protected DateTimeField[] initFields(Chronology chrono) {\n+        return new DateTimeField[] {\n+            chrono.hourOfDay(),\n+            chrono.minuteOfHour(),\n+            chrono.secondOfMinute(),\n+            chrono.millisOfSecond(),\n+        };\n+    }\n+\n+    /**\n+     * Initialize the array of values.\n+     * \n+     * @param instant  the instant to use\n+     * @param chrono  the chronology to use\n+     */\n+    protected int[] initValues(long instant, Chronology chrono) {\n+        return new int[] {\n+            chrono.hourOfDay().get(instant),\n+            chrono.minuteOfHour().get(instant),\n+            chrono.secondOfMinute().get(instant),\n+            chrono.millisOfSecond().get(instant),\n+        };\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day (0-23) field value.\n+     *\n+     * @return the hour of day\n+     */\n+    public int getHourOfDay() {\n+        return getValue(HOUR_OF_DAY);\n+    }\n+\n+    /**\n+     * Get the minute of hour field value.\n+     *\n+     * @return the minute of hour\n+     */\n+    public int getMinuteOfHour() {\n+        return getValue(MINUTE_OF_HOUR);\n+    }\n+\n+    /**\n+     * Get the second of minute field value.\n+     *\n+     * @return the second of minute\n+     */\n+    public int getSecondOfMinute() {\n+        return getValue(SECOND_OF_MINUTE);\n+    }\n+\n+    /**\n+     * Get the millis of second field value.\n+     *\n+     * @return the millis of second\n+     */\n+    public int getMillisOfSecond() {\n+        return getValue(MILLIS_OF_SECOND);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day (0-23) field property\n+     * \n+     * @return the hour of day property\n+     */\n+    public Property hourOfDay() {\n+        return new Property(this, HOUR_OF_DAY);\n+    }\n+\n+    /**\n+     * Get the minute of hour field property\n+     * \n+     * @return the minute of hour property\n+     */\n+    public Property minuteOfHour() {\n+        return new Property(this, MINUTE_OF_HOUR);\n+    }\n+\n+    /**\n+     * Get the second of minute field property\n+     * \n+     * @return the second of minute property\n+     */\n+    public Property secondOfMinute() {\n+        return new Property(this, SECOND_OF_MINUTE);\n+    }\n+\n+    /**\n+     * Get the millis of second property\n+     * \n+     * @return the millis of second property\n+     */\n+    public Property millisOfSecond() {\n+        return new Property(this, MILLIS_OF_SECOND);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the time in the ISO8601 format THH:mm:ss.SSS.\n+     * \n+     * @return ISO8601 formatted string\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.getInstanceUTC().tTime().print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The property class for <code>TimeOfDay</code>.\n+     * <p>\n+     * This class binds a <code>TimeOfDay</code> to a <code>DateTimeField</code>.\n+     * \n+     * @author Stephen Colebourne\n+     * @since 1.0\n+     */\n+    public static class Property extends AbstractPartialFieldProperty implements Serializable {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 5598459141741063833L;\n+\n+        /** The partial */\n+        private final TimeOfDay iTimeOfDay;\n+        /** The field index */\n+        private final int iFieldIndex;\n+\n+        /**\n+         * Constructs a property.\n+         * \n+         * @param partial  the partial instance\n+         * @param field  the field\n+         * @param fieldIndex  the index in the partial\n+         */\n+        Property(TimeOfDay partial, int fieldIndex) {\n+            super();\n+            iTimeOfDay = partial;\n+            iFieldIndex = fieldIndex;\n+        }\n+\n+        /**\n+         * Gets the field that this property uses.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iTimeOfDay.getField(iFieldIndex);\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        public ReadablePartial getReadablePartial() {\n+            return iTimeOfDay;\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        public TimeOfDay getTimeOfDay() {\n+            return iTimeOfDay;\n+        }\n+\n+        /**\n+         * Gets the value of this field.\n+         * \n+         * @return the field value\n+         */\n+        public int get() {\n+            return iTimeOfDay.getValue(iFieldIndex);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to the value of this field in a copy of this TimeOfDay.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it will affect larger fields.\n+         * Smaller fields are unaffected.\n+         * <p>\n+         * If the result would be too large, beyond 23:59:59:999, then an\n+         * IllegalArgumentException is thrown.\n+         * <p>\n+         * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the TimeOfDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public TimeOfDay addToCopy(int valueToAdd) {\n+            int[] newValues = iTimeOfDay.getValues();\n+            newValues = getField().add(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n+            return new TimeOfDay(iTimeOfDay, newValues);\n+        }\n+\n+        /**\n+         * Adds to the value of this field in a copy of this TimeOfDay wrapping\n+         * within this field if the maximum value is reached.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it wraps within this field.\n+         * Other fields are unaffected.\n+         * <p>\n+         * For example,\n+         * <code>12:59:37</code> addWrapField one minute returns <code>12:00:37</code>.\n+         * <p>\n+         * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the TimeOfDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public TimeOfDay addWrapFieldToCopy(int valueToAdd) {\n+            int[] newValues = iTimeOfDay.getValues();\n+            newValues = getField().addWrapField(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n+            return new TimeOfDay(iTimeOfDay, newValues);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the TimeOfDay.\n+         * <p>\n+         * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the TimeOfDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public TimeOfDay setCopy(int value) {\n+            int[] newValues = iTimeOfDay.getValues();\n+            newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, value);\n+            return new TimeOfDay(iTimeOfDay, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the TimeOfDay to a parsed text value.\n+         * <p>\n+         * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the TimeOfDay with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public TimeOfDay setCopy(String text, Locale locale) {\n+            int[] newValues = iTimeOfDay.getValues();\n+            newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, text, locale);\n+            return new TimeOfDay(iTimeOfDay, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the TimeOfDay to a parsed text value.\n+         * <p>\n+         * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @return a copy of the TimeOfDay with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public TimeOfDay setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/YearMonthDay.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+import org.joda.time.format.ISODateTimeFormat;\n+import org.joda.time.property.AbstractPartialFieldProperty;\n+\n+/**\n+ * YearMonthDay is an immutable partial supporting the year, monthOfYear\n+ * and dayOfMonth fields.\n+ * <p>\n+ * Calculations on YearMonthDay are performed using a {@link Chronology}.\n+ * This chronology is set to be in the UTC time zone for all calculations.\n+ * <p>\n+ * Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getMonthOfYear()</code>\n+ * <li><code>monthOfYear().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value - <code>monthOfYear().get()</code>\n+ * <li>text value - <code>monthOfYear().getAsText()</code>\n+ * <li>short text value - <code>monthOfYear().getAsShortText()</code>\n+ * <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code>\n+ * <li>add/subtract - <code>monthOfYear().addToCopy()</code>\n+ * <li>set - <code>monthOfYear().setCopy()</code>\n+ * </ul>\n+ * <p>\n+ * YearMonthDay is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public final class YearMonthDay extends AbstractPartial implements ReadablePartial, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 797544782896179L;\n+\n+    /** The index of the year field in the field array */\n+    public static final int YEAR = 0;\n+    /** The index of the monthOfYear field in the field array */\n+    public static final int MONTH_OF_YEAR = 1;\n+    /** The index of the dayOfMonth field in the field array */\n+    public static final int DAY_OF_MONTH = 2;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a YearMonthDay with the current time, using ISOChronology in\n+     * the default zone to extract the fields.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     */\n+    public YearMonthDay() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay with the current time, using the specified chronology\n+     * and zone to extract the fields.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public YearMonthDay(Chronology chronology) {\n+        super(chronology);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay extracting the partial fields from the specified\n+     * milliseconds using the ISOChronology in the default zone.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public YearMonthDay(long instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay extracting the partial fields from the specified\n+     * milliseconds using the chronology provided.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public YearMonthDay(long instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay from an Object that represents a time.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public YearMonthDay(Object instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay from an Object that represents a time, using the\n+     * specified chronology.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @param chronology  the chronology, null means ISOChronology\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public YearMonthDay(Object instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay with specified time field values\n+     * using <code>ISOChronology</code> in the default zone.\n+     * <p>\n+     * The constructor uses the no time zone initialising the fields as provided.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     */\n+    public YearMonthDay(int year, int monthOfYear, int dayOfMonth) {\n+        this(year, monthOfYear, dayOfMonth, null);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay with specified time field values.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology) {\n+        super(new int[] {year, monthOfYear, dayOfMonth}, chronology);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay with specified fields, values and chronology.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param values  the new set of values\n+     */\n+    YearMonthDay(YearMonthDay partial, int[] values) {\n+        super();\n+        iChronology = partial.iChronology;\n+        iValues = values;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Initialize the array of fields.\n+     * \n+     * @param chrono  the chronology to use\n+     */\n+    protected DateTimeField[] initFields(Chronology chrono) {\n+        return new DateTimeField[] {\n+            chrono.year(),\n+            chrono.monthOfYear(),\n+            chrono.dayOfMonth(),\n+        };\n+    }\n+\n+    /**\n+     * Initialize the array of values.\n+     * \n+     * @param instant  the instant to use\n+     * @param chrono  the chronology to use\n+     */\n+    protected int[] initValues(long instant, Chronology chrono) {\n+        return new int[] {\n+            chrono.year().get(instant),\n+            chrono.monthOfYear().get(instant),\n+            chrono.dayOfMonth().get(instant),\n+        };\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the year field value.\n+     *\n+     * @return the year\n+     */\n+    public int getYear() {\n+        return getValue(YEAR);\n+    }\n+\n+    /**\n+     * Get the month of year field value.\n+     *\n+     * @return the month of year\n+     */\n+    public int getMonthOfYear() {\n+        return getValue(MONTH_OF_YEAR);\n+    }\n+\n+    /**\n+     * Get the day of month field value.\n+     *\n+     * @return the day of month\n+     */\n+    public int getDayOfMonth() {\n+        return getValue(DAY_OF_MONTH);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the year field property\n+     * \n+     * @return the year property\n+     */\n+    public Property year() {\n+        return new Property(this, YEAR);\n+    }\n+\n+    /**\n+     * Get the month of year field property\n+     * \n+     * @return the month of year property\n+     */\n+    public Property monthOfYear() {\n+        return new Property(this, MONTH_OF_YEAR);\n+    }\n+\n+    /**\n+     * Get the day of month field property\n+     * \n+     * @return the day of month property\n+     */\n+    public Property dayOfMonth() {\n+        return new Property(this, DAY_OF_MONTH);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the time in the ISO8601 format YYYY-MM-DD.\n+     * \n+     * @return ISO8601 formatted string\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.getInstanceUTC().yearMonthDay().print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The property class for <code>YearMonthDay</code>.\n+     * <p>\n+     * This class binds a <code>YearMonthDay</code> to a <code>DateTimeField</code>.\n+     * \n+     * @author Stephen Colebourne\n+     * @since 1.0\n+     */\n+    public static class Property extends AbstractPartialFieldProperty implements Serializable {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 5727734012190224363L;\n+\n+        /** The partial */\n+        private final YearMonthDay iYearMonthDay;\n+        /** The field index */\n+        private final int iFieldIndex;\n+\n+        /**\n+         * Constructs a property.\n+         * \n+         * @param partial  the partial instance\n+         * @param field  the field\n+         * @param fieldIndex  the index in the partial\n+         */\n+        Property(YearMonthDay partial, int fieldIndex) {\n+            super();\n+            iYearMonthDay = partial;\n+            iFieldIndex = fieldIndex;\n+        }\n+\n+        /**\n+         * Gets the field that this property uses.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iYearMonthDay.getField(iFieldIndex);\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        public ReadablePartial getReadablePartial() {\n+            return iYearMonthDay;\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        public YearMonthDay getYearMonthDay() {\n+            return iYearMonthDay;\n+        }\n+\n+        /**\n+         * Gets the value of this field.\n+         * \n+         * @return the field value\n+         */\n+        public int get() {\n+            return iYearMonthDay.getValue(iFieldIndex);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to the value of this field in a copy of this YearMonthDay.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it will affect larger fields.\n+         * Smaller fields are unaffected.\n+         * <p>\n+         * If the result would be too large, beyond the maximum year, then an\n+         * IllegalArgumentException is thrown.\n+         * <p>\n+         * The YearMonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the YearMonthDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public YearMonthDay addToCopy(int valueToAdd) {\n+            int[] newValues = iYearMonthDay.getValues();\n+            newValues = getField().add(iYearMonthDay, iFieldIndex, newValues, valueToAdd);\n+            return new YearMonthDay(iYearMonthDay, newValues);\n+        }\n+\n+        /**\n+         * Adds to the value of this field in a copy of this YearMonthDay wrapping\n+         * within this field if the maximum value is reached.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it wraps within this field.\n+         * Other fields are unaffected.\n+         * <p>\n+         * For example,\n+         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.\n+         * <p>\n+         * The YearMonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the YearMonthDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public YearMonthDay addWrapFieldToCopy(int valueToAdd) {\n+            int[] newValues = iYearMonthDay.getValues();\n+            newValues = getField().addWrapField(iYearMonthDay, iFieldIndex, newValues, valueToAdd);\n+            return new YearMonthDay(iYearMonthDay, newValues);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the YearMonthDay.\n+         * <p>\n+         * The YearMonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the YearMonthDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public YearMonthDay setCopy(int value) {\n+            int[] newValues = iYearMonthDay.getValues();\n+            newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, value);\n+            return new YearMonthDay(iYearMonthDay, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the YearMonthDay to a parsed text value.\n+         * <p>\n+         * The YearMonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the YearMonthDay with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public YearMonthDay setCopy(String text, Locale locale) {\n+            int[] newValues = iYearMonthDay.getValues();\n+            newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, text, locale);\n+            return new YearMonthDay(iYearMonthDay, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the YearMonthDay to a parsed text value.\n+         * <p>\n+         * The YearMonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @return a copy of the YearMonthDay with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public YearMonthDay setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java\n import org.joda.time.DateTimeZone;\n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n+import org.joda.time.ReadablePartial;\n import org.joda.time.field.UnsupportedDateTimeField;\n import org.joda.time.field.UnsupportedDurationField;\n-import org.joda.time.partial.ReadablePartial;\n \n /**\n  * AbstractChronology provides a skeleton implementation for chronology\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java\n \n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n+import org.joda.time.ReadablePartial;\n import org.joda.time.field.PreciseDurationDateTimeField;\n-import org.joda.time.partial.ReadablePartial;\n \n /**\n  * Provides time calculations for the day of the month component of time.\n--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java\n \n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n+import org.joda.time.ReadablePartial;\n import org.joda.time.field.PreciseDurationDateTimeField;\n-import org.joda.time.partial.ReadablePartial;\n \n /**\n  * Provides time calculations for the day of the month component of time.\n--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java\n \n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n+import org.joda.time.ReadablePartial;\n import org.joda.time.field.PreciseDurationDateTimeField;\n-import org.joda.time.partial.ReadablePartial;\n \n /**\n  * Provides time calculations for the day of the year component of time.\n--- a/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n+import org.joda.time.ReadablePartial;\n import org.joda.time.field.PreciseDurationDateTimeField;\n-import org.joda.time.partial.ReadablePartial;\n \n /**\n  * Provides time calculations for the week of a week based year component of time.\n--- a/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java\n package org.joda.time.chrono;\n \n import org.joda.time.DateTimeField;\n+import org.joda.time.ReadablePartial;\n import org.joda.time.field.DecoratedDateTimeField;\n import org.joda.time.field.FieldUtils;\n-import org.joda.time.partial.ReadablePartial;\n \n /**\n  * Provides time calculations for the year of era component of time.\n--- a/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java\n package org.joda.time.chrono;\n \n import org.joda.time.DateTimeField;\n+import org.joda.time.ReadablePartial;\n import org.joda.time.field.DecoratedDateTimeField;\n import org.joda.time.field.FieldUtils;\n-import org.joda.time.partial.ReadablePartial;\n \n /**\n  * This field is not publicy exposed by ISOChronology, but rather it is used to\n--- a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java\n \n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n-import org.joda.time.partial.ReadablePartial;\n+import org.joda.time.ReadablePartial;\n \n /**\n  * BaseDateTimeField provides the common behaviour for DateTimeField\n--- a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java\n import java.util.Locale;\n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n-import org.joda.time.partial.ReadablePartial;\n+import org.joda.time.ReadablePartial;\n \n /**\n  * <code>DelegatedDateTimeField</code> delegates each method call to the\n--- a/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java\n \n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n-import org.joda.time.partial.ReadablePartial;\n+import org.joda.time.ReadablePartial;\n \n /**\n  * Wraps another field such that zero values are replaced with one more than\n--- a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java\n import java.util.Locale;\n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n-import org.joda.time.partial.ReadablePartial;\n+import org.joda.time.ReadablePartial;\n \n /**\n  * A placeholder implementation to use when a datetime field is not supported.\n--- a/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java\n+++ b/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java\n import org.joda.time.MutableDateTime;\n import org.joda.time.ReadWritableInstant;\n import org.joda.time.ReadableInstant;\n-import org.joda.time.partial.ReadablePartial;\n+import org.joda.time.ReadablePartial;\n \n /**\n  * Abstract base class for implementing {@link DateTimePrinter}s,\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n import org.joda.time.MutableDateTime;\n import org.joda.time.ReadWritableInstant;\n import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadablePartial;\n import org.joda.time.field.RemainderDateTimeField;\n-import org.joda.time.partial.ReadablePartial;\n import org.joda.time.chrono.ISOChronology;\n \n /**\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadablePartial;\n import org.joda.time.field.MillisDurationField;\n import org.joda.time.field.PreciseDateTimeField;\n-import org.joda.time.partial.ReadablePartial;\n import org.joda.time.chrono.ISOChronology;\n \n /**\n--- a/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n import org.joda.time.ReadableInstant;\n-import org.joda.time.partial.ReadablePartial;\n+import org.joda.time.ReadablePartial;\n \n /**\n  * Defines an interface for creating textual representations of datetimes.\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/property/AbstractPartialFieldProperty.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.property;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadablePartial;\n+\n+/**\n+ * AbstractPartialFieldProperty is a base class for binding a\n+ * ReadablePartial to a DateTimeField.\n+ * <p>\n+ * It allows the date and time manipulation code to be field based yet\n+ * still easy to use.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class AbstractPartialFieldProperty {\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractPartialFieldProperty() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field being used.\n+     * \n+     * @return the field\n+     */\n+    public abstract DateTimeField getField();\n+\n+    /**\n+     * Gets the name of the field.\n+     * \n+     * @return the field name\n+     */\n+    public String getName() {\n+        return getField().getName();\n+    }\n+\n+    /**\n+     * Gets the partial instant being used.\n+     * \n+     * @return the partial instant\n+     */\n+    public abstract ReadablePartial getReadablePartial();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a value from the partial instant.\n+     * \n+     * @return the current value\n+     */\n+    public abstract int get();\n+\n+    /**\n+     * Gets a text value from the partial instant.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the current text value\n+     * @see DateTimeField#getAsText\n+     */\n+    public String getAsText(Locale locale) {\n+        return getField().getAsText(getReadablePartial(), get(), locale);\n+    }\n+\n+    /**\n+     * Gets a text value from the partial instant.\n+     * \n+     * @return the current text value\n+     * @see DateTimeField#getAsText\n+     */\n+    public String getAsText() {\n+        return getAsText(null);\n+    }\n+\n+    /**\n+     * Gets a short text value from the partial instant.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the current text value\n+     * @see DateTimeField#getAsShortText\n+     */\n+    public String getAsShortText(Locale locale) {\n+        return getField().getAsShortText(getReadablePartial(), get(), locale);\n+    }\n+\n+    /**\n+     * Gets a short text value from the partial instant.\n+     * \n+     * @return the current text value\n+     * @see DateTimeField#getAsShortText\n+     */\n+    public String getAsShortText() {\n+        return getAsShortText(null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the duration per unit value of this field. For example, if this\n+     * field represents \"hour of day\", then the duration is an hour.\n+     *\n+     * @return the duration of this field, or UnsupportedDurationField\n+     */\n+    public DurationField getDurationField() {\n+        return getField().getDurationField();\n+    }\n+\n+    /**\n+     * Returns the range duration of this field. For example, if this field\n+     * represents \"hour of day\", then the range duration is a day.\n+     *\n+     * @return the range duration of this field, or null if field has no range\n+     */\n+    public DurationField getRangeDurationField() {\n+        return getField().getRangeDurationField();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the minimum value for the field ignoring the current time.\n+     * \n+     * @return the minimum value\n+     * @see DateTimeField#getMinimumValue\n+     */\n+    public int getMinimumValueOverall() {\n+        return getField().getMinimumValue();\n+    }\n+\n+    /**\n+     * Gets the minimum value for this field given the current field values.\n+     * \n+     * @return the minimum value\n+     * @see DateTimeField#getMinimumValue\n+     */\n+    public int getMinimumValue() {\n+        return getField().getMinimumValue(getReadablePartial());\n+    }\n+\n+    /**\n+     * Gets the maximum value for the field ignoring the current time.\n+     * \n+     * @return the maximum value\n+     * @see DateTimeField#getMaximumValue\n+     */\n+    public int getMaximumValueOverall() {\n+        return getField().getMaximumValue();\n+    }\n+\n+    /**\n+     * Gets the maximum value for this field given the current field values.\n+     * \n+     * @return the maximum value\n+     * @see DateTimeField#getMaximumValue\n+     */\n+    public int getMaximumValue() {\n+        return getField().getMaximumValue(getReadablePartial());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the maximum text length for the field.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the maximum length\n+     * @see DateTimeField#getMaximumTextLength\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        return getField().getMaximumTextLength(locale);\n+    }\n+\n+    /**\n+     * Gets the maximum short text length for the field.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the maximum length\n+     * @see DateTimeField#getMaximumShortTextLength\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return getField().getMaximumShortTextLength(locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compare this field to the same field on another instant.\n+     * <p>\n+     * The {@link #get()} method is used to obtain the value to compare for\n+     * this instant and the {@link ReadableInstant#get(DateTimeField)} method\n+     * is used for the specified instant.\n+     * \n+     * @param instant  the instant to compare to\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    public int compareTo(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        int thisValue = get();\n+        int otherValue = instant.get(getField());\n+        if (thisValue < otherValue) {\n+            return -1;\n+        } else if (thisValue > otherValue) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Compare this field to the same field on another partial instant.\n+     * <p>\n+     * The {@link #get()} method is used to obtain the value to compare for\n+     * this instant and the {@link ReadablePartial#get(DateTimeField)} method\n+     * is used for the specified instant.\n+     * \n+     * @param instant  the instant to compare to\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws IllegalArgumentException if the instant is null\n+     * @throws IllegalArgumentException if the field of this property cannot be queried\n+     *  on the specified instant\n+     */\n+    public int compareTo(ReadablePartial instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        int thisValue = get();\n+        int otherValue = instant.get(getField());\n+        if (thisValue < otherValue) {\n+            return -1;\n+        } else if (thisValue > otherValue) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output a debugging string.\n+     * \n+     * @return debugging string\n+     */\n+    public String toString() {\n+        return \"Property[\" + getName() + \"]\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/MockPartial.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadWritableInstant;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.ISOChronology;\n+\n+/**\n+ * A basic mock testing class for a PartialInstant that doesn't extend AbstractPartialInstant.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class MockPartial implements ReadablePartial {\n+    \n+    public static final ReadablePartial EMPTY_INSTANCE = new MockPartial();\n+    \n+    public Chronology getChronology() {\n+        return ISOChronology.getInstance();\n+    }\n+    public int getFieldSize() {\n+        return 0;\n+    }\n+    public DateTimeField getField(int index) {\n+        return null;\n+    }\n+    public int getValue(int index) {\n+        return 0;\n+    }\n+    public int get(DateTimeField field) {\n+        return 0;\n+    }\n+    public boolean isSupported(DateTimeField field) {\n+        return false;\n+    }\n+    public long resolve(long baseMillis, DateTimeZone tz) {\n+        return 0L;\n+    }\n+    public DateTime resolveDateTime(ReadableInstant base) {\n+        return null;\n+    }\n+    public void resolveInto(ReadWritableInstant base) {\n+    }\n+    public DateTimeField[] getFields() {\n+        return new DateTimeField[0];\n+    }\n+    public int[] getValues() {\n+        return new int[0];\n+    }\n+}\n--- a/JodaTime/src/test/org/joda/time/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/TestAll.java\n         suite.addTest(TestDateMidnight_Basics.suite());\n         suite.addTest(TestDateMidnight_Properties.suite());\n         \n+        suite.addTest(TestTimeOfDay.suite());\n+        suite.addTest(TestYearMonthDay.suite());\n+        \n         suite.addTest(TestDateTimeComparator.suite());\n         suite.addTest(TestDateTimeConstants.suite());\n         suite.addTest(TestDateTimeZone.suite());\n--- a/JodaTime/src/test/org/joda/time/TestAllPackages.java\n+++ b/JodaTime/src/test/org/joda/time/TestAllPackages.java\n         TestSuite suite = new TestSuite();\n         suite.addTest(org.joda.time.TestAll.suite());\n         suite.addTest(org.joda.time.chrono.gj.TestAll.suite());\n-        suite.addTest(org.joda.time.partial.TestAll.suite());\n         return suite;\n     }\n \n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestTimeOfDay.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.chrono.JulianChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.MockZeroNullIntegerConverter;\n+\n+/**\n+ * This class is a Junit unit test for TimeOfDay.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestTimeOfDay extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    \n+    private long TEST_TIME_NOW =\n+            10L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 20L * DateTimeConstants.MILLIS_PER_MINUTE\n+            + 30L * DateTimeConstants.MILLIS_PER_SECOND\n+            + 40L;\n+            \n+    private long TEST_TIME1 =\n+        1L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 2L * DateTimeConstants.MILLIS_PER_MINUTE\n+        + 3L * DateTimeConstants.MILLIS_PER_SECOND\n+        + 4L;\n+        \n+    private long TEST_TIME2 =\n+        1L * DateTimeConstants.MILLIS_PER_DAY\n+        + 5L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 6L * DateTimeConstants.MILLIS_PER_MINUTE\n+        + 7L * DateTimeConstants.MILLIS_PER_SECOND\n+        + 8L;\n+        \n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestTimeOfDay.class);\n+    }\n+\n+    public TestTimeOfDay(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(DateTimeZone.UTC);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor ()\n+     */\n+    public void testConstructor() throws Throwable {\n+        TimeOfDay test = new TimeOfDay();\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Chronology)\n+     */\n+    public void testConstructor_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Chronology=null)\n+     */\n+    public void testConstructor_nullChronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay((Chronology) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long1() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(TEST_TIME1);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(1, test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long2() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(TEST_TIME2);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(5, test.getHourOfDay());\n+        assertEquals(6, test.getMinuteOfHour());\n+        assertEquals(7, test.getSecondOfMinute());\n+        assertEquals(8, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology)\n+     */\n+    public void testConstructor_long1_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(TEST_TIME1, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstance(), test.getChronology());\n+        assertEquals(1, test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology)\n+     */\n+    public void testConstructor_long2_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(TEST_TIME2, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstance(), test.getChronology());\n+        assertEquals(5, test.getHourOfDay());\n+        assertEquals(6, test.getMinuteOfHour());\n+        assertEquals(7, test.getSecondOfMinute());\n+        assertEquals(8, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology=null)\n+     */\n+    public void testConstructor_long_nullChronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(TEST_TIME1, null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(1, test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (Object)\n+     */\n+    public void testConstructor_Object() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        TimeOfDay test = new TimeOfDay(date);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(1, test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_nullObject() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_badconverterObject() throws Throwable {\n+        try {\n+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+            TimeOfDay test = new TimeOfDay(new Integer(0));\n+            assertEquals(ISOChronology.getInstance(), test.getChronology());\n+            assertEquals(0, test.getHourOfDay());\n+            assertEquals(0, test.getMinuteOfHour());\n+            assertEquals(0, test.getSecondOfMinute());\n+            assertEquals(0, test.getMillisOfSecond());\n+        } finally {\n+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+        }\n+    }\n+\n+    /**\n+     * Test constructor (Object, Chronology)\n+     */\n+    public void testConstructor_Object_Chronology() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        TimeOfDay test = new TimeOfDay(date, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstance(), test.getChronology());\n+        assertEquals(1, test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, Chronology)\n+     */\n+    public void testConstructor_nullObject_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay((Object) null, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Object, Chronology=null)\n+     */\n+    public void testConstructor_Object_nullChronology() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        TimeOfDay test = new TimeOfDay(date, null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(1, test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, Chronology=null)\n+     */\n+    public void testConstructor_nullObject_nullChronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay((Object) null, null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_badconverterObject_Chronology() throws Throwable {\n+        try {\n+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+            TimeOfDay test = new TimeOfDay(new Integer(0), JulianChronology.getInstance());\n+            assertEquals(ISOChronology.getInstance(), test.getChronology());\n+            assertEquals(0, test.getHourOfDay());\n+            assertEquals(0, test.getMinuteOfHour());\n+            assertEquals(0, test.getSecondOfMinute());\n+            assertEquals(0, test.getMillisOfSecond());\n+        } finally {\n+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (int, int)\n+     */\n+    public void testConstructor_int_int() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(0, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+        try {\n+            new TimeOfDay(-1, 20);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(24, 20);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, -1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 60);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, Chronology)\n+     */\n+    public void testConstructor_int_int_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(0, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+        try {\n+            new TimeOfDay(-1, 20, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(24, 20, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, -1, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 60, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, Chronology=null)\n+     */\n+    public void testConstructor_int_int_nullChronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(0, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int)\n+     */\n+    public void testConstructor_int_int_int() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+        try {\n+            new TimeOfDay(-1, 20, 30);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(24, 20, 30);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, -1, 30);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 60, 30);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, -1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 60);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, Chronology)\n+     */\n+    public void testConstructor_int_int_int_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+        try {\n+            new TimeOfDay(-1, 20, 30, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(24, 20, 30, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, -1, 30, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 60, 30, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, -1, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 60, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, Chronology=null)\n+     */\n+    public void testConstructor_int_int_int_nullChronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, int)\n+     */\n+    public void testConstructor_int_int_int_int() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+        try {\n+            new TimeOfDay(-1, 20, 30, 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(24, 20, 30, 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, -1, 30, 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 60, 30, 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, -1, 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 60, 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 30, -1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 30, 1000);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, int, Chronology)\n+     */\n+    public void testConstructor_int_int_int_int_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+        try {\n+            new TimeOfDay(-1, 20, 30, 40, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(24, 20, 30, 40, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, -1, 30, 40, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 60, 30, 40, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, -1, 40, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 60, 40, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 30, -1, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 30, 1000, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, int, Chronology=null)\n+     */\n+    public void testConstructor_int_int_int_int_nullChronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGet() {\n+        TimeOfDay test = new TimeOfDay();\n+        assertEquals(10, test.get(ISOChronology.getInstance().hourOfDay()));\n+        assertEquals(20, test.get(ISOChronology.getInstance().minuteOfHour()));\n+        assertEquals(30, test.get(ISOChronology.getInstance().secondOfMinute()));\n+        assertEquals(40, test.get(ISOChronology.getInstance().millisOfSecond()));\n+        try {\n+            test.get(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.get(ISOChronology.getInstance().dayOfMonth());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.get(ISOChronology.getInstance(PARIS).hourOfDay());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        // TODO: Should this fail or suceed - by succeeding it exposes out implementation\n+//        try {\n+//            test.get(JulianChronology.getInstance().hourOfDay());\n+//            fail();\n+//        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testGetFieldSize() {\n+        TimeOfDay test = new TimeOfDay();\n+        assertEquals(4, test.getFieldSize());\n+    }\n+\n+    public void testGetField() {\n+        TimeOfDay test = new TimeOfDay();\n+        assertSame(ISOChronology.getInstance().hourOfDay(), test.getField(0));\n+        assertSame(ISOChronology.getInstance().minuteOfHour(), test.getField(1));\n+        assertSame(ISOChronology.getInstance().secondOfMinute(), test.getField(2));\n+        assertSame(ISOChronology.getInstance().millisOfSecond(), test.getField(3));\n+        try {\n+            test.getField(-1);\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.getField(5);\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testGetFields() {\n+        TimeOfDay test = new TimeOfDay();\n+        DateTimeField[] fields = test.getFields();\n+        assertSame(ISOChronology.getInstance().hourOfDay(), fields[0]);\n+        assertSame(ISOChronology.getInstance().minuteOfHour(), fields[1]);\n+        assertSame(ISOChronology.getInstance().secondOfMinute(), fields[2]);\n+        assertSame(ISOChronology.getInstance().millisOfSecond(), fields[3]);\n+    }\n+\n+    public void testGetValue() {\n+        TimeOfDay test = new TimeOfDay();\n+        assertEquals(10, test.getValue(0));\n+        assertEquals(20, test.getValue(1));\n+        assertEquals(30, test.getValue(2));\n+        assertEquals(40, test.getValue(3));\n+        try {\n+            test.getValue(-1);\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.getValue(5);\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testGetValues() {\n+        TimeOfDay test = new TimeOfDay();\n+        int[] values = test.getValues();\n+        assertEquals(10, values[0]);\n+        assertEquals(20, values[1]);\n+        assertEquals(30, values[2]);\n+        assertEquals(40, values[3]);\n+    }\n+\n+    public void testIsSupported() {\n+        TimeOfDay test = new TimeOfDay();\n+        assertEquals(true, test.isSupported(ISOChronology.getInstance().hourOfDay()));\n+        assertEquals(true, test.isSupported(ISOChronology.getInstance().minuteOfHour()));\n+        assertEquals(true, test.isSupported(ISOChronology.getInstance().secondOfMinute()));\n+        assertEquals(true, test.isSupported(ISOChronology.getInstance().millisOfSecond()));\n+        assertEquals(false, test.isSupported(ISOChronology.getInstance().dayOfMonth()));\n+        assertEquals(false, test.isSupported(ISOChronology.getInstance(PARIS).hourOfDay()));\n+    }\n+\n+    public void testEqualsHashCode() {\n+        TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay test2 = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(true, test1.equals(test2));\n+        assertEquals(true, test2.equals(test1));\n+        assertEquals(true, test1.equals(test1));\n+        assertEquals(true, test2.equals(test2));\n+        assertEquals(true, test1.hashCode() == test2.hashCode());\n+        assertEquals(true, test1.hashCode() == test1.hashCode());\n+        assertEquals(true, test2.hashCode() == test2.hashCode());\n+        \n+        TimeOfDay test3 = new TimeOfDay(11, 20, 30, 40);\n+        assertEquals(false, test1.equals(test3));\n+        assertEquals(false, test2.equals(test3));\n+        assertEquals(false, test3.equals(test1));\n+        assertEquals(false, test3.equals(test2));\n+        assertEquals(false, test1.hashCode() == test3.hashCode());\n+        assertEquals(false, test2.hashCode() == test3.hashCode());\n+        \n+        assertEquals(false, test1.equals(\"Hello\"));\n+        assertEquals(true, test1.equals(new MockInstant()));\n+        assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));\n+    }\n+    \n+    class MockInstant extends MockPartial {\n+        public DateTimeField[] getFields() {\n+            return new DateTimeField[] {\n+                ISOChronology.getInstance().hourOfDay(),\n+                ISOChronology.getInstance().minuteOfHour(),\n+                ISOChronology.getInstance().secondOfMinute(),\n+                ISOChronology.getInstance().millisOfSecond(),\n+            };\n+        }\n+        public int[] getValues() {\n+            return new int[] {10, 20, 30, 40};\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testResolve_long() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        DateTime dt = new DateTime(0L);\n+        assertEquals(\"1970-01-01T00:00:00.000Z\", dt.toString());\n+        \n+        DateTime result = new DateTime(test.resolve(dt.getMillis(), DateTimeZone.UTC));\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+        assertEquals(\"1970-01-01T00:00:00.000Z\", dt.toString());\n+        assertEquals(\"1970-01-01T10:20:30.040Z\", result.toString());\n+    }\n+\n+    public void testResolveDateTime_RI() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        DateTime dt = new DateTime(0L);\n+        assertEquals(\"1970-01-01T00:00:00.000Z\", dt.toString());\n+        \n+        DateTime result = test.resolveDateTime(dt);\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+        assertEquals(\"1970-01-01T00:00:00.000Z\", dt.toString());\n+        assertEquals(\"1970-01-01T10:20:30.040Z\", result.toString());\n+    }\n+\n+    public void testResolveDateTime_nullRI() {\n+        TimeOfDay test = new TimeOfDay(1, 2, 3, 4);\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);\n+        \n+        DateTime result = test.resolveDateTime(null);\n+        assertEquals(1, test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+        assertEquals(\"1970-01-02T01:02:03.004Z\", result.toString());\n+    }\n+\n+    public void testResolveInto_RWI() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        MutableDateTime mdt = new MutableDateTime(0L);\n+        assertEquals(\"1970-01-01T00:00:00.000Z\", mdt.toString());\n+        \n+        test.resolveInto(mdt);\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+        assertEquals(\"1970-01-01T10:20:30.040Z\", mdt.toString());\n+    }\n+\n+    public void testResolveInto_nullRWI() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        \n+        try {\n+            test.resolveInto(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        TimeOfDay result = (TimeOfDay) ois.readObject();\n+        ois.close();\n+        \n+        assertEquals(test, result);\n+        assertTrue(Arrays.equals(test.getValues(), result.getValues()));\n+        assertTrue(Arrays.equals(test.getFields(), result.getFields()));\n+        assertEquals(test.getChronology(), result.getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(\"T10:20:30.040\", test.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetHour() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());\n+        assertEquals(\"hourOfDay\", test.hourOfDay().getName());\n+        assertEquals(\"Property[hourOfDay]\", test.hourOfDay().toString());\n+        assertSame(test, test.hourOfDay().getReadablePartial());\n+        assertSame(test, test.hourOfDay().getTimeOfDay());\n+        assertEquals(10, test.hourOfDay().get());\n+        assertEquals(\"10\", test.hourOfDay().getAsText());\n+        assertEquals(\"10\", test.hourOfDay().getAsText(Locale.FRENCH));\n+        assertEquals(\"10\", test.hourOfDay().getAsShortText());\n+        assertEquals(\"10\", test.hourOfDay().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField());\n+        assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());\n+        assertEquals(2, test.hourOfDay().getMaximumTextLength(null));\n+        assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesHour() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(0, test.hourOfDay().getMinimumValue());\n+        assertEquals(0, test.hourOfDay().getMinimumValueOverall());\n+        assertEquals(23, test.hourOfDay().getMaximumValue());\n+        assertEquals(23, test.hourOfDay().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddHour() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.hourOfDay().addToCopy(9);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 19, 20, 30, 40);\n+        \n+        copy = test.hourOfDay().addToCopy(0);\n+        check(copy, 10, 20, 30, 40);\n+        \n+        copy = test.hourOfDay().addToCopy(13);\n+        check(copy, 23, 20, 30, 40);\n+        \n+        try {\n+            test.hourOfDay().addToCopy(14);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20, 30, 40);\n+        \n+        copy = test.hourOfDay().addToCopy(-10);\n+        check(copy, 0, 20, 30, 40);\n+        \n+        try {\n+            test.hourOfDay().addToCopy(-11);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20, 30, 40);\n+    }\n+\n+    public void testPropertyAddWrapFieldHour() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.hourOfDay().addWrapFieldToCopy(9);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 19, 20, 30, 40);\n+        \n+        copy = test.hourOfDay().addWrapFieldToCopy(0);\n+        check(copy, 10, 20, 30, 40);\n+        \n+        copy = test.hourOfDay().addWrapFieldToCopy(18);\n+        check(copy, 4, 20, 30, 40);\n+        \n+        copy = test.hourOfDay().addWrapFieldToCopy(-15);\n+        check(copy, 19, 20, 30, 40);\n+    }\n+\n+    public void testPropertySetHour() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.hourOfDay().setCopy(12);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 12, 20, 30, 40);\n+        \n+        try {\n+            test.hourOfDay().setCopy(24);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.hourOfDay().setCopy(-1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testPropertySetTextHour() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.hourOfDay().setCopy(\"12\");\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 12, 20, 30, 40);\n+    }\n+\n+    public void testPropertyCompareToHour() {\n+        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);\n+        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);\n+        assertEquals(true, test1.hourOfDay().compareTo(test2) < 0);\n+        assertEquals(true, test2.hourOfDay().compareTo(test1) > 0);\n+        assertEquals(true, test1.hourOfDay().compareTo(test1) == 0);\n+        try {\n+            test1.hourOfDay().compareTo((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.hourOfDay().compareTo(dt2) < 0);\n+        assertEquals(true, test2.hourOfDay().compareTo(dt1) > 0);\n+        assertEquals(true, test1.hourOfDay().compareTo(dt1) == 0);\n+        try {\n+            test1.hourOfDay().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetMinute() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());\n+        assertEquals(\"minuteOfHour\", test.minuteOfHour().getName());\n+        assertEquals(\"Property[minuteOfHour]\", test.minuteOfHour().toString());\n+        assertSame(test, test.minuteOfHour().getReadablePartial());\n+        assertSame(test, test.minuteOfHour().getTimeOfDay());\n+        assertEquals(20, test.minuteOfHour().get());\n+        assertEquals(\"20\", test.minuteOfHour().getAsText());\n+        assertEquals(\"20\", test.minuteOfHour().getAsText(Locale.FRENCH));\n+        assertEquals(\"20\", test.minuteOfHour().getAsShortText());\n+        assertEquals(\"20\", test.minuteOfHour().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField());\n+        assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField());\n+        assertEquals(2, test.minuteOfHour().getMaximumTextLength(null));\n+        assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesMinute() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(0, test.minuteOfHour().getMinimumValue());\n+        assertEquals(0, test.minuteOfHour().getMinimumValueOverall());\n+        assertEquals(59, test.minuteOfHour().getMaximumValue());\n+        assertEquals(59, test.minuteOfHour().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddMinute() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.minuteOfHour().addToCopy(9);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 29, 30, 40);\n+        \n+        copy = test.minuteOfHour().addToCopy(39);\n+        check(copy, 10, 59, 30, 40);\n+        \n+        copy = test.minuteOfHour().addToCopy(40);\n+        check(copy, 11, 0, 30, 40);\n+        \n+        copy = test.minuteOfHour().addToCopy(1 * 60 + 45);\n+        check(copy, 12, 5, 30, 40);\n+        \n+        copy = test.minuteOfHour().addToCopy(13 * 60 + 39);\n+        check(copy, 23, 59, 30, 40);\n+        \n+        try {\n+            test.minuteOfHour().addToCopy(13 * 60 + 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20, 30, 40);\n+        \n+        copy = test.minuteOfHour().addToCopy(-9);\n+        check(copy, 10, 11, 30, 40);\n+        \n+        copy = test.minuteOfHour().addToCopy(-19);\n+        check(copy, 10, 1, 30, 40);\n+        \n+        copy = test.minuteOfHour().addToCopy(-20);\n+        check(copy, 10, 0, 30, 40);\n+        \n+        copy = test.minuteOfHour().addToCopy(-21);\n+        check(copy, 9, 59, 30, 40);\n+        \n+        copy = test.minuteOfHour().addToCopy(-(10 * 60 + 20));\n+        check(copy, 0, 0, 30, 40);\n+        \n+        try {\n+            test.minuteOfHour().addToCopy(-(10 * 60 + 21));\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20, 30, 40);\n+    }\n+\n+    public void testPropertyAddWrapFieldMinute() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.minuteOfHour().addWrapFieldToCopy(9);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 29, 30, 40);\n+        \n+        copy = test.minuteOfHour().addWrapFieldToCopy(49);\n+        check(copy, 10, 9, 30, 40);\n+        \n+        copy = test.minuteOfHour().addWrapFieldToCopy(-47);\n+        check(copy, 10, 33, 30, 40);\n+    }\n+\n+    public void testPropertySetMinute() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.minuteOfHour().setCopy(12);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 12, 30, 40);\n+        \n+        try {\n+            test.minuteOfHour().setCopy(60);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.minuteOfHour().setCopy(-1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testPropertySetTextMinute() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.minuteOfHour().setCopy(\"12\");\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 12, 30, 40);\n+    }\n+\n+    public void testPropertyCompareToMinute() {\n+        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);\n+        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);\n+        assertEquals(true, test1.minuteOfHour().compareTo(test2) < 0);\n+        assertEquals(true, test2.minuteOfHour().compareTo(test1) > 0);\n+        assertEquals(true, test1.minuteOfHour().compareTo(test1) == 0);\n+        try {\n+            test1.minuteOfHour().compareTo((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.minuteOfHour().compareTo(dt2) < 0);\n+        assertEquals(true, test2.minuteOfHour().compareTo(dt1) > 0);\n+        assertEquals(true, test1.minuteOfHour().compareTo(dt1) == 0);\n+        try {\n+            test1.minuteOfHour().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetSecond() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());\n+        assertEquals(\"secondOfMinute\", test.secondOfMinute().getName());\n+        assertEquals(\"Property[secondOfMinute]\", test.secondOfMinute().toString());\n+        assertSame(test, test.secondOfMinute().getReadablePartial());\n+        assertSame(test, test.secondOfMinute().getTimeOfDay());\n+        assertEquals(30, test.secondOfMinute().get());\n+        assertEquals(\"30\", test.secondOfMinute().getAsText());\n+        assertEquals(\"30\", test.secondOfMinute().getAsText(Locale.FRENCH));\n+        assertEquals(\"30\", test.secondOfMinute().getAsShortText());\n+        assertEquals(\"30\", test.secondOfMinute().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField());\n+        assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField());\n+        assertEquals(2, test.secondOfMinute().getMaximumTextLength(null));\n+        assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesSecond() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(0, test.secondOfMinute().getMinimumValue());\n+        assertEquals(0, test.secondOfMinute().getMinimumValueOverall());\n+        assertEquals(59, test.secondOfMinute().getMaximumValue());\n+        assertEquals(59, test.secondOfMinute().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddSecond() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.secondOfMinute().addToCopy(9);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 20, 39, 40);\n+        \n+        copy = test.secondOfMinute().addToCopy(29);\n+        check(copy, 10, 20, 59, 40);\n+        \n+        copy = test.secondOfMinute().addToCopy(30);\n+        check(copy, 10, 21, 0, 40);\n+        \n+        copy = test.secondOfMinute().addToCopy(39 * 60 + 29);\n+        check(copy, 10, 59, 59, 40);\n+        \n+        copy = test.secondOfMinute().addToCopy(39 * 60 + 30);\n+        check(copy, 11, 0, 0, 40);\n+        \n+        try {\n+            test.secondOfMinute().addToCopy(13 * 60 * 60 + 39 * 60 + 30);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20, 30, 40);\n+        \n+        copy = test.secondOfMinute().addToCopy(-9);\n+        check(copy, 10, 20, 21, 40);\n+        \n+        copy = test.secondOfMinute().addToCopy(-30);\n+        check(copy, 10, 20, 0, 40);\n+        \n+        copy = test.secondOfMinute().addToCopy(-31);\n+        check(copy, 10, 19, 59, 40);\n+        \n+        copy = test.secondOfMinute().addToCopy(-(10 * 60 * 60 + 20 * 60 + 30));\n+        check(copy, 0, 0, 0, 40);\n+        \n+        try {\n+            test.secondOfMinute().addToCopy(-(10 * 60 * 60 + 20 * 60 + 31));\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20, 30, 40);\n+    }\n+\n+    public void testPropertyAddWrapFieldSecond() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.secondOfMinute().addWrapFieldToCopy(9);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 20, 39, 40);\n+        \n+        copy = test.secondOfMinute().addWrapFieldToCopy(49);\n+        check(copy, 10, 20, 19, 40);\n+        \n+        copy = test.secondOfMinute().addWrapFieldToCopy(-47);\n+        check(copy, 10, 20, 43, 40);\n+    }\n+\n+    public void testPropertySetSecond() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.secondOfMinute().setCopy(12);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 20, 12, 40);\n+        \n+        try {\n+            test.secondOfMinute().setCopy(60);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.secondOfMinute().setCopy(-1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testPropertySetTextSecond() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.secondOfMinute().setCopy(\"12\");\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 20, 12, 40);\n+    }\n+\n+    public void testPropertyCompareToSecond() {\n+        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);\n+        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);\n+        assertEquals(true, test1.secondOfMinute().compareTo(test2) < 0);\n+        assertEquals(true, test2.secondOfMinute().compareTo(test1) > 0);\n+        assertEquals(true, test1.secondOfMinute().compareTo(test1) == 0);\n+        try {\n+            test1.secondOfMinute().compareTo((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.secondOfMinute().compareTo(dt2) < 0);\n+        assertEquals(true, test2.secondOfMinute().compareTo(dt1) > 0);\n+        assertEquals(true, test1.secondOfMinute().compareTo(dt1) == 0);\n+        try {\n+            test1.secondOfMinute().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetMilli() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());\n+        assertEquals(\"millisOfSecond\", test.millisOfSecond().getName());\n+        assertEquals(\"Property[millisOfSecond]\", test.millisOfSecond().toString());\n+        assertSame(test, test.millisOfSecond().getReadablePartial());\n+        assertSame(test, test.millisOfSecond().getTimeOfDay());\n+        assertEquals(40, test.millisOfSecond().get());\n+        assertEquals(\"40\", test.millisOfSecond().getAsText());\n+        assertEquals(\"40\", test.millisOfSecond().getAsText(Locale.FRENCH));\n+        assertEquals(\"40\", test.millisOfSecond().getAsShortText());\n+        assertEquals(\"40\", test.millisOfSecond().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField());\n+        assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField());\n+        assertEquals(3, test.millisOfSecond().getMaximumTextLength(null));\n+        assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesMilli() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(0, test.millisOfSecond().getMinimumValue());\n+        assertEquals(0, test.millisOfSecond().getMinimumValueOverall());\n+        assertEquals(999, test.millisOfSecond().getMaximumValue());\n+        assertEquals(999, test.millisOfSecond().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddMilli() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.millisOfSecond().addToCopy(9);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 20, 30, 49);\n+        \n+        copy = test.millisOfSecond().addToCopy(959);\n+        check(copy, 10, 20, 30, 999);\n+        \n+        copy = test.millisOfSecond().addToCopy(960);\n+        check(copy, 10, 20, 31, 0);\n+        \n+        copy = test.millisOfSecond().addToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 959);\n+        check(copy, 23, 59, 59, 999);\n+        \n+        try {\n+            test.millisOfSecond().addToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 960);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20, 30, 40);\n+        \n+        copy = test.millisOfSecond().addToCopy(-9);\n+        check(copy, 10, 20, 30, 31);\n+        \n+        copy = test.millisOfSecond().addToCopy(-40);\n+        check(copy, 10, 20, 30, 0);\n+        \n+        copy = test.millisOfSecond().addToCopy(-41);\n+        check(copy, 10, 20, 29, 999);\n+        \n+        copy = test.millisOfSecond().addToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 40));\n+        check(copy, 0, 0, 0, 0);\n+        \n+        try {\n+            test.millisOfSecond().addToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 41));\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20, 30, 40);\n+    }\n+\n+    public void testPropertyAddWrapFieldMilli() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.millisOfSecond().addWrapFieldToCopy(9);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 20, 30, 49);\n+        \n+        copy = test.millisOfSecond().addWrapFieldToCopy(995);\n+        check(copy, 10, 20, 30, 35);\n+        \n+        copy = test.millisOfSecond().addWrapFieldToCopy(-47);\n+        check(copy, 10, 20, 30, 993);\n+    }\n+\n+    public void testPropertySetMilli() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.millisOfSecond().setCopy(12);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 20, 30, 12);\n+        \n+        try {\n+            test.millisOfSecond().setCopy(1000);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.millisOfSecond().setCopy(-1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testPropertySetTextMilli() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.millisOfSecond().setCopy(\"12\");\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 20, 30, 12);\n+    }\n+\n+    public void testPropertyCompareToMilli() {\n+        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);\n+        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);\n+        assertEquals(true, test1.millisOfSecond().compareTo(test2) < 0);\n+        assertEquals(true, test2.millisOfSecond().compareTo(test1) > 0);\n+        assertEquals(true, test1.millisOfSecond().compareTo(test1) == 0);\n+        try {\n+            test1.millisOfSecond().compareTo((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.millisOfSecond().compareTo(dt2) < 0);\n+        assertEquals(true, test2.millisOfSecond().compareTo(dt1) > 0);\n+        assertEquals(true, test1.millisOfSecond().compareTo(dt1) == 0);\n+        try {\n+            test1.millisOfSecond().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void check(TimeOfDay test, int hour, int min, int sec, int milli) {\n+        assertEquals(hour, test.getHourOfDay());\n+        assertEquals(min, test.getMinuteOfHour());\n+        assertEquals(sec, test.getSecondOfMinute());\n+        assertEquals(milli, test.getMillisOfSecond());\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestYearMonthDay.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.GregorianChronology;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.MockZeroNullIntegerConverter;\n+\n+/**\n+ * This class is a Junit unit test for YearMonthDay.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestYearMonthDay extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    \n+    private long TEST_TIME_NOW =\n+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    private long TEST_TIME1 =\n+        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private long TEST_TIME2 =\n+        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestYearMonthDay.class);\n+    }\n+\n+    public TestYearMonthDay(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(DateTimeZone.UTC);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor ()\n+     */\n+    public void testConstructor() throws Throwable {\n+        YearMonthDay test = new YearMonthDay();\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Chronology)\n+     */\n+    public void testConstructor_Chronology() throws Throwable {\n+        YearMonthDay test = new YearMonthDay(GregorianChronology.getInstance());\n+        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Chronology=null)\n+     */\n+    public void testConstructor_nullChronology() throws Throwable {\n+        YearMonthDay test = new YearMonthDay((Chronology) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long1() throws Throwable {\n+        YearMonthDay test = new YearMonthDay(TEST_TIME1);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long2() throws Throwable {\n+        YearMonthDay test = new YearMonthDay(TEST_TIME2);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(1971, test.getYear());\n+        assertEquals(5, test.getMonthOfYear());\n+        assertEquals(7, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology)\n+     */\n+    public void testConstructor_long1_Chronology() throws Throwable {\n+        YearMonthDay test = new YearMonthDay(TEST_TIME1, GregorianChronology.getInstance());\n+        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology)\n+     */\n+    public void testConstructor_long2_Chronology() throws Throwable {\n+        YearMonthDay test = new YearMonthDay(TEST_TIME2, GregorianChronology.getInstance());\n+        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n+        assertEquals(1971, test.getYear());\n+        assertEquals(5, test.getMonthOfYear());\n+        assertEquals(7, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology=null)\n+     */\n+    public void testConstructor_long_nullChronology() throws Throwable {\n+        YearMonthDay test = new YearMonthDay(TEST_TIME1, null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (Object)\n+     */\n+    public void testConstructor_Object() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        YearMonthDay test = new YearMonthDay(date);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_nullObject() throws Throwable {\n+        YearMonthDay test = new YearMonthDay(null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_badconverterObject() throws Throwable {\n+        try {\n+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+            YearMonthDay test = new YearMonthDay(new Integer(0));\n+            assertEquals(ISOChronology.getInstance(), test.getChronology());\n+            assertEquals(1970, test.getYear());\n+            assertEquals(1, test.getMonthOfYear());\n+            assertEquals(1, test.getDayOfMonth());\n+        } finally {\n+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+        }\n+    }\n+\n+    /**\n+     * Test constructor (Object, Chronology)\n+     */\n+    public void testConstructor_Object_Chronology() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        YearMonthDay test = new YearMonthDay(date, GregorianChronology.getInstance());\n+        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, Chronology)\n+     */\n+    public void testConstructor_nullObject_Chronology() throws Throwable {\n+        YearMonthDay test = new YearMonthDay((Object) null, GregorianChronology.getInstance());\n+        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Object, Chronology=null)\n+     */\n+    public void testConstructor_Object_nullChronology() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        YearMonthDay test = new YearMonthDay(date, null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, Chronology=null)\n+     */\n+    public void testConstructor_nullObject_nullChronology() throws Throwable {\n+        YearMonthDay test = new YearMonthDay((Object) null, null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_badconverterObject_Chronology() throws Throwable {\n+        try {\n+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+            YearMonthDay test = new YearMonthDay(new Integer(0), GregorianChronology.getInstance());\n+            assertEquals(ISOChronology.getInstance(), test.getChronology());\n+            assertEquals(1970, test.getYear());\n+            assertEquals(1, test.getMonthOfYear());\n+            assertEquals(1, test.getDayOfMonth());\n+        } finally {\n+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (int, int, int)\n+     */\n+    public void testConstructor_int_int_int() throws Throwable {\n+        YearMonthDay test = new YearMonthDay(1970, 6, 9);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+        try {\n+            new YearMonthDay(Integer.MIN_VALUE, 6, 9);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonthDay(Integer.MAX_VALUE, 6, 9);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonthDay(1970, 0, 9);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonthDay(1970, 13, 9);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonthDay(1970, 6, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonthDay(1970, 6, 31);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        new YearMonthDay(1970, 7, 31);\n+        try {\n+            new YearMonthDay(1970, 7, 32);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, Chronology)\n+     */\n+    public void testConstructor_int_int_int_Chronology() throws Throwable {\n+        YearMonthDay test = new YearMonthDay(1970, 6, 9, GregorianChronology.getInstance());\n+        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+        try {\n+            new YearMonthDay(Integer.MIN_VALUE, 6, 9, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonthDay(Integer.MAX_VALUE, 6, 9, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonthDay(1970, 0, 9, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonthDay(1970, 13, 9, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonthDay(1970, 6, 0, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonthDay(1970, 6, 31, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        new YearMonthDay(1970, 7, 31, GregorianChronology.getInstance());\n+        try {\n+            new YearMonthDay(1970, 7, 32, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, Chronology=null)\n+     */\n+    public void testConstructor_int_int_int_nullChronology() throws Throwable {\n+        YearMonthDay test = new YearMonthDay(1970, 6, 9, null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGet() {\n+        YearMonthDay test = new YearMonthDay();\n+        assertEquals(1970, test.get(ISOChronology.getInstance().year()));\n+        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));\n+        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));\n+        try {\n+            test.get(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.get(ISOChronology.getInstance().hourOfDay());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.get(ISOChronology.getInstance(PARIS).year());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        // TODO: Should this fail or suceed - by succeeding it exposes out implementation\n+//        try {\n+//            test.get(GregorianChronology.getInstance().year());\n+//            fail();\n+//        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testGetFieldSize() {\n+        YearMonthDay test = new YearMonthDay();\n+        assertEquals(3, test.getFieldSize());\n+    }\n+\n+    public void testGetField() {\n+        YearMonthDay test = new YearMonthDay();\n+        assertSame(ISOChronology.getInstance().year(), test.getField(0));\n+        assertSame(ISOChronology.getInstance().monthOfYear(), test.getField(1));\n+        assertSame(ISOChronology.getInstance().dayOfMonth(), test.getField(2));\n+        try {\n+            test.getField(-1);\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.getField(3);\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testGetFields() {\n+        YearMonthDay test = new YearMonthDay();\n+        DateTimeField[] fields = test.getFields();\n+        assertSame(ISOChronology.getInstance().year(), fields[0]);\n+        assertSame(ISOChronology.getInstance().monthOfYear(), fields[1]);\n+        assertSame(ISOChronology.getInstance().dayOfMonth(), fields[2]);\n+    }\n+\n+    public void testGetValue() {\n+        YearMonthDay test = new YearMonthDay();\n+        assertEquals(1970, test.getValue(0));\n+        assertEquals(6, test.getValue(1));\n+        assertEquals(9, test.getValue(2));\n+        try {\n+            test.getValue(-1);\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.getValue(3);\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testGetValues() {\n+        YearMonthDay test = new YearMonthDay();\n+        int[] values = test.getValues();\n+        assertEquals(1970, values[0]);\n+        assertEquals(6, values[1]);\n+        assertEquals(9, values[2]);\n+    }\n+\n+    public void testIsSupported() {\n+        YearMonthDay test = new YearMonthDay();\n+        assertEquals(true, test.isSupported(ISOChronology.getInstance().year()));\n+        assertEquals(true, test.isSupported(ISOChronology.getInstance().monthOfYear()));\n+        assertEquals(true, test.isSupported(ISOChronology.getInstance().dayOfMonth()));\n+        assertEquals(false, test.isSupported(ISOChronology.getInstance().hourOfDay()));\n+        assertEquals(false, test.isSupported(ISOChronology.getInstance(PARIS).year()));\n+    }\n+\n+    public void testEqualsHashCode() {\n+        YearMonthDay test1 = new YearMonthDay(1970, 6, 9);\n+        YearMonthDay test2 = new YearMonthDay(1970, 6, 9);\n+        assertEquals(true, test1.equals(test2));\n+        assertEquals(true, test2.equals(test1));\n+        assertEquals(true, test1.equals(test1));\n+        assertEquals(true, test2.equals(test2));\n+        assertEquals(true, test1.hashCode() == test2.hashCode());\n+        assertEquals(true, test1.hashCode() == test1.hashCode());\n+        assertEquals(true, test2.hashCode() == test2.hashCode());\n+        \n+        YearMonthDay test3 = new YearMonthDay(1971, 6, 9);\n+        assertEquals(false, test1.equals(test3));\n+        assertEquals(false, test2.equals(test3));\n+        assertEquals(false, test3.equals(test1));\n+        assertEquals(false, test3.equals(test2));\n+        assertEquals(false, test1.hashCode() == test3.hashCode());\n+        assertEquals(false, test2.hashCode() == test3.hashCode());\n+        \n+        assertEquals(false, test1.equals(\"Hello\"));\n+        assertEquals(true, test1.equals(new MockInstant()));\n+        assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));\n+    }\n+    \n+    class MockInstant extends MockPartial {\n+        public DateTimeField[] getFields() {\n+            return new DateTimeField[] {\n+                ISOChronology.getInstance().year(),\n+                ISOChronology.getInstance().monthOfYear(),\n+                ISOChronology.getInstance().dayOfMonth(),\n+            };\n+        }\n+        public int[] getValues() {\n+            return new int[] {1970, 6, 9};\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testResolve_long() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        DateTime dt = new DateTime(TEST_TIME1);\n+        assertEquals(\"1970-04-06T12:24:00.000Z\", dt.toString());\n+        \n+        DateTime result = new DateTime(test.resolve(dt.getMillis(), DateTimeZone.UTC));\n+        check(test, 1972, 6, 9);\n+        assertEquals(\"1970-04-06T12:24:00.000Z\", dt.toString());\n+        assertEquals(\"1972-06-09T12:24:00.000Z\", result.toString());\n+    }\n+\n+    public void testResolveDateTime_RI() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        DateTime dt = new DateTime(TEST_TIME1);\n+        assertEquals(\"1970-04-06T12:24:00.000Z\", dt.toString());\n+        \n+        DateTime result = test.resolveDateTime(dt);\n+        check(test, 1972, 6, 9);\n+        assertEquals(\"1970-04-06T12:24:00.000Z\", dt.toString());\n+        assertEquals(\"1972-06-09T12:24:00.000Z\", result.toString());\n+    }\n+\n+    public void testResolveDateTime_nullRI() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1);\n+        \n+        DateTime result = test.resolveDateTime(null);\n+        check(test, 1972, 6, 9);\n+        assertEquals(\"1972-06-09T12:24:00.000Z\", result.toString());\n+    }\n+\n+    public void testResolveInto_RWI() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        MutableDateTime mdt = new MutableDateTime(TEST_TIME1);\n+        assertEquals(\"1970-04-06T12:24:00.000Z\", mdt.toString());\n+        \n+        test.resolveInto(mdt);\n+        check(test, 1972, 6, 9);\n+        assertEquals(\"1972-06-09T12:24:00.000Z\", mdt.toString());\n+    }\n+\n+    public void testResolveInto_nullRWI() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        \n+        try {\n+            test.resolveInto(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        YearMonthDay result = (YearMonthDay) ois.readObject();\n+        ois.close();\n+        \n+        assertEquals(test, result);\n+        assertTrue(Arrays.equals(test.getValues(), result.getValues()));\n+        assertTrue(Arrays.equals(test.getFields(), result.getFields()));\n+        assertEquals(test.getChronology(), result.getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        assertEquals(\"1972-06-09\", test.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetYear() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        assertSame(test.getChronology().year(), test.year().getField());\n+        assertEquals(\"year\", test.year().getName());\n+        assertEquals(\"Property[year]\", test.year().toString());\n+        assertSame(test, test.year().getReadablePartial());\n+        assertSame(test, test.year().getYearMonthDay());\n+        assertEquals(1972, test.year().get());\n+        assertEquals(\"1972\", test.year().getAsText());\n+        assertEquals(\"1972\", test.year().getAsText(Locale.FRENCH));\n+        assertEquals(\"1972\", test.year().getAsShortText());\n+        assertEquals(\"1972\", test.year().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().years(), test.year().getDurationField());\n+        assertEquals(null, test.year().getRangeDurationField());\n+        assertEquals(9, test.year().getMaximumTextLength(null));\n+        assertEquals(9, test.year().getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesYear() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        assertEquals(-292275054, test.year().getMinimumValue());\n+        assertEquals(-292275054, test.year().getMinimumValueOverall());\n+        assertEquals(292277023, test.year().getMaximumValue());\n+        assertEquals(292277023, test.year().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddYear() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.year().addToCopy(9);\n+        check(test, 1972, 6, 9);\n+        check(copy, 1981, 6, 9);\n+        \n+        copy = test.year().addToCopy(0);\n+        check(copy, 1972, 6, 9);\n+        \n+        copy = test.year().addToCopy(292277023 - 1972);\n+        check(copy, 292277023, 6, 9);\n+        \n+        try {\n+            test.year().addToCopy(292277023 - 1972 + 1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 1972, 6, 9);\n+        \n+        copy = test.year().addToCopy(-1972);\n+        check(copy, 0, 6, 9);\n+        \n+        copy = test.year().addToCopy(-1973);\n+        check(copy, -1, 6, 9);\n+        \n+        try {\n+            test.year().addToCopy(-292275054 - 1972 - 1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 1972, 6, 9);\n+    }\n+\n+    public void testPropertyAddWrapFieldYear() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.year().addWrapFieldToCopy(9);\n+        check(test, 1972, 6, 9);\n+        check(copy, 1981, 6, 9);\n+        \n+        copy = test.year().addWrapFieldToCopy(0);\n+        check(copy, 1972, 6, 9);\n+        \n+        copy = test.year().addWrapFieldToCopy(292277023 - 1972 + 1);\n+        check(copy, -292275054, 6, 9);\n+        \n+        copy = test.year().addWrapFieldToCopy(-292275054 - 1972 - 1);\n+        check(copy, 292277023, 6, 9);\n+    }\n+\n+    public void testPropertySetYear() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.year().setCopy(12);\n+        check(test, 1972, 6, 9);\n+        check(copy, 12, 6, 9);\n+    }\n+\n+    public void testPropertySetTextYear() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.year().setCopy(\"12\");\n+        check(test, 1972, 6, 9);\n+        check(copy, 12, 6, 9);\n+    }\n+\n+    public void testPropertyCompareToYear() {\n+        YearMonthDay test1 = new YearMonthDay(TEST_TIME1);\n+        YearMonthDay test2 = new YearMonthDay(TEST_TIME2);\n+        assertEquals(true, test1.year().compareTo(test2) < 0);\n+        assertEquals(true, test2.year().compareTo(test1) > 0);\n+        assertEquals(true, test1.year().compareTo(test1) == 0);\n+        try {\n+            test1.year().compareTo((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.year().compareTo(dt2) < 0);\n+        assertEquals(true, test2.year().compareTo(dt1) > 0);\n+        assertEquals(true, test1.year().compareTo(dt1) == 0);\n+        try {\n+            test1.year().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetMonth() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());\n+        assertEquals(\"monthOfYear\", test.monthOfYear().getName());\n+        assertEquals(\"Property[monthOfYear]\", test.monthOfYear().toString());\n+        assertSame(test, test.monthOfYear().getReadablePartial());\n+        assertSame(test, test.monthOfYear().getYearMonthDay());\n+        assertEquals(6, test.monthOfYear().get());\n+        assertEquals(\"June\", test.monthOfYear().getAsText());\n+        assertEquals(\"juin\", test.monthOfYear().getAsText(Locale.FRENCH));\n+        assertEquals(\"Jun\", test.monthOfYear().getAsShortText());\n+        assertEquals(\"juin\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());\n+        assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());\n+        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));\n+        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));\n+        test = new YearMonthDay(1972, 7, 9);\n+        assertEquals(\"juillet\", test.monthOfYear().getAsText(Locale.FRENCH));\n+        assertEquals(\"juil.\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesMonth() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        assertEquals(1, test.monthOfYear().getMinimumValue());\n+        assertEquals(1, test.monthOfYear().getMinimumValueOverall());\n+        assertEquals(12, test.monthOfYear().getMaximumValue());\n+        assertEquals(12, test.monthOfYear().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddMonth() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.monthOfYear().addToCopy(6);\n+        check(test, 1972, 6, 9);\n+        check(copy, 1972, 12, 9);\n+        \n+        copy = test.monthOfYear().addToCopy(7);\n+        check(copy, 1973, 1, 9);\n+        \n+        copy = test.monthOfYear().addToCopy(-5);\n+        check(copy, 1972, 1, 9);\n+        \n+        copy = test.monthOfYear().addToCopy(-6);\n+        check(copy, 1971, 12, 9);\n+        \n+        test = new YearMonthDay(1972, 1, 31);\n+        copy = test.monthOfYear().addToCopy(1);\n+        check(copy, 1972, 2, 29);\n+        \n+        copy = test.monthOfYear().addToCopy(2);\n+        check(copy, 1972, 3, 31);\n+        \n+        copy = test.monthOfYear().addToCopy(3);\n+        check(copy, 1972, 4, 30);\n+        \n+        test = new YearMonthDay(1971, 1, 31);\n+        copy = test.monthOfYear().addToCopy(1);\n+        check(copy, 1971, 2, 28);\n+    }\n+\n+    public void testPropertyAddWrapFieldMonth() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.monthOfYear().addWrapFieldToCopy(4);\n+        check(test, 1972, 6, 9);\n+        check(copy, 1972, 10, 9);\n+        \n+        copy = test.monthOfYear().addWrapFieldToCopy(8);\n+        check(copy, 1972, 2, 9);\n+        \n+        copy = test.monthOfYear().addWrapFieldToCopy(-8);\n+        check(copy, 1972, 10, 9);\n+        \n+        test = new YearMonthDay(1972, 1, 31);\n+        copy = test.monthOfYear().addWrapFieldToCopy(1);\n+        check(copy, 1972, 2, 29);\n+        \n+        copy = test.monthOfYear().addWrapFieldToCopy(2);\n+        check(copy, 1972, 3, 31);\n+        \n+        copy = test.monthOfYear().addWrapFieldToCopy(3);\n+        check(copy, 1972, 4, 30);\n+        \n+        test = new YearMonthDay(1971, 1, 31);\n+        copy = test.monthOfYear().addWrapFieldToCopy(1);\n+        check(copy, 1971, 2, 28);\n+    }\n+\n+    public void testPropertySetMonth() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.monthOfYear().setCopy(12);\n+        check(test, 1972, 6, 9);\n+        check(copy, 1972, 12, 9);\n+        \n+        test = new YearMonthDay(1972, 1, 31);\n+        copy = test.monthOfYear().setCopy(2);\n+        check(copy, 1972, 2, 29);\n+        \n+        try {\n+            test.monthOfYear().setCopy(13);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.monthOfYear().setCopy(0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testPropertySetTextMonth() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.monthOfYear().setCopy(\"12\");\n+        check(test, 1972, 6, 9);\n+        check(copy, 1972, 12, 9);\n+        \n+        copy = test.monthOfYear().setCopy(\"December\");\n+        check(test, 1972, 6, 9);\n+        check(copy, 1972, 12, 9);\n+        \n+        copy = test.monthOfYear().setCopy(\"Dec\");\n+        check(test, 1972, 6, 9);\n+        check(copy, 1972, 12, 9);\n+    }\n+\n+    public void testPropertyCompareToMonth() {\n+        YearMonthDay test1 = new YearMonthDay(TEST_TIME1);\n+        YearMonthDay test2 = new YearMonthDay(TEST_TIME2);\n+        assertEquals(true, test1.monthOfYear().compareTo(test2) < 0);\n+        assertEquals(true, test2.monthOfYear().compareTo(test1) > 0);\n+        assertEquals(true, test1.monthOfYear().compareTo(test1) == 0);\n+        try {\n+            test1.monthOfYear().compareTo((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0);\n+        assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0);\n+        assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0);\n+        try {\n+            test1.monthOfYear().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetDay() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());\n+        assertEquals(\"dayOfMonth\", test.dayOfMonth().getName());\n+        assertEquals(\"Property[dayOfMonth]\", test.dayOfMonth().toString());\n+        assertSame(test, test.dayOfMonth().getReadablePartial());\n+        assertSame(test, test.dayOfMonth().getYearMonthDay());\n+        assertEquals(9, test.dayOfMonth().get());\n+        assertEquals(\"9\", test.dayOfMonth().getAsText());\n+        assertEquals(\"9\", test.dayOfMonth().getAsText(Locale.FRENCH));\n+        assertEquals(\"9\", test.dayOfMonth().getAsShortText());\n+        assertEquals(\"9\", test.dayOfMonth().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());\n+        assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());\n+        assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));\n+        assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesDay() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        assertEquals(1, test.dayOfMonth().getMinimumValue());\n+        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());\n+        assertEquals(30, test.dayOfMonth().getMaximumValue());\n+        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());\n+        test = new YearMonthDay(1972, 7, 9);\n+        assertEquals(31, test.dayOfMonth().getMaximumValue());\n+        test = new YearMonthDay(1972, 2, 9);\n+        assertEquals(29, test.dayOfMonth().getMaximumValue());\n+        test = new YearMonthDay(1971, 2, 9);\n+        assertEquals(28, test.dayOfMonth().getMaximumValue());\n+    }\n+\n+    public void testPropertyAddDay() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.dayOfMonth().addToCopy(9);\n+        check(test, 1972, 6, 9);\n+        check(copy, 1972, 6, 18);\n+        \n+        copy = test.dayOfMonth().addToCopy(21);\n+        check(copy, 1972, 6, 30);\n+        \n+        copy = test.dayOfMonth().addToCopy(22);\n+        check(copy, 1972, 7, 1);\n+        \n+        copy = test.dayOfMonth().addToCopy(22 + 30);\n+        check(copy, 1972, 7, 31);\n+        \n+        copy = test.dayOfMonth().addToCopy(22 + 31);\n+        check(copy, 1972, 8, 1);\n+\n+        copy = test.dayOfMonth().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);\n+        check(copy, 1972, 12, 31);\n+        \n+        copy = test.dayOfMonth().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);\n+        check(copy, 1973, 1, 1);\n+        \n+        copy = test.dayOfMonth().addToCopy(-8);\n+        check(copy, 1972, 6, 1);\n+        \n+        copy = test.dayOfMonth().addToCopy(-9);\n+        check(copy, 1972, 5, 31);\n+        \n+        copy = test.dayOfMonth().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);\n+        check(copy, 1972, 1, 1);\n+        \n+        copy = test.dayOfMonth().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);\n+        check(copy, 1971, 12, 31);\n+    }\n+\n+    public void testPropertyAddWrapFieldDay() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.dayOfMonth().addWrapFieldToCopy(21);\n+        check(test, 1972, 6, 9);\n+        check(copy, 1972, 6, 30);\n+        \n+        copy = test.dayOfMonth().addWrapFieldToCopy(22);\n+        check(copy, 1972, 6, 1);\n+        \n+        copy = test.dayOfMonth().addWrapFieldToCopy(-12);\n+        check(copy, 1972, 6, 27);\n+        \n+        test = new YearMonthDay(1972, 7, 9);\n+        copy = test.dayOfMonth().addWrapFieldToCopy(21);\n+        check(copy, 1972, 7, 30);\n+    \n+        copy = test.dayOfMonth().addWrapFieldToCopy(22);\n+        check(copy, 1972, 7, 31);\n+    \n+        copy = test.dayOfMonth().addWrapFieldToCopy(23);\n+        check(copy, 1972, 7, 1);\n+    \n+        copy = test.dayOfMonth().addWrapFieldToCopy(-12);\n+        check(copy, 1972, 7, 28);\n+    }\n+\n+    public void testPropertySetDay() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.dayOfMonth().setCopy(12);\n+        check(test, 1972, 6, 9);\n+        check(copy, 1972, 6, 12);\n+        \n+        try {\n+            test.dayOfMonth().setCopy(31);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.dayOfMonth().setCopy(0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testPropertySetTextDay() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.dayOfMonth().setCopy(\"12\");\n+        check(test, 1972, 6, 9);\n+        check(copy, 1972, 6, 12);\n+    }\n+\n+    public void testPropertyCompareToDay() {\n+        YearMonthDay test1 = new YearMonthDay(TEST_TIME1);\n+        YearMonthDay test2 = new YearMonthDay(TEST_TIME2);\n+        assertEquals(true, test1.dayOfMonth().compareTo(test2) < 0);\n+        assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0);\n+        assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0);\n+        try {\n+            test1.dayOfMonth().compareTo((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.dayOfMonth().compareTo(dt2) < 0);\n+        assertEquals(true, test2.dayOfMonth().compareTo(dt1) > 0);\n+        assertEquals(true, test1.dayOfMonth().compareTo(dt1) == 0);\n+        try {\n+            test1.dayOfMonth().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void check(YearMonthDay test, int hour, int min, int sec) {\n+        assertEquals(hour, test.getYear());\n+        assertEquals(min, test.getMonthOfYear());\n+        assertEquals(sec, test.getDayOfMonth());\n+    }\n+}", "timestamp": 1089934426, "metainfo": ""}