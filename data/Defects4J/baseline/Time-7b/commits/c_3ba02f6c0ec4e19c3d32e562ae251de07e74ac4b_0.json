{"sha": "3ba02f6c0ec4e19c3d32e562ae251de07e74ac4b", "log": "Add PersistentLocalDateTime  ", "commit": "\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalDateTime.java\n+/*\n+ *  Copyright 2001-2008 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.contrib.hibernate;\n+\n+import java.io.Serializable;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+import org.hibernate.Hibernate;\n+import org.hibernate.HibernateException;\n+import org.hibernate.usertype.EnhancedUserType;\n+import org.joda.time.LocalDateTime;\n+\n+/**\n+ * Persist {@link org.joda.time.LocalDateTime} via hibernate\n+ *\n+ * @author Mario Ivankovits (mario@ops.co.at)\n+ */\n+public class PersistentLocalDateTime implements EnhancedUserType\n+{\n+\tpublic final static PersistentLocalDateTime INSTANCE = new PersistentLocalDateTime();\n+\n+\tprivate static final int[] SQL_TYPES = new int[]\n+    {\n+        Types.TIMESTAMP,\n+    };\n+\n+    public int[] sqlTypes()\n+    {\n+        return SQL_TYPES;\n+    }\n+\n+    public Class returnedClass()\n+    {\n+        return LocalDateTime.class;\n+    }\n+\n+    public boolean equals(Object x, Object y) throws HibernateException\n+\t{\n+        if (x == y)\n+        {\n+            return true;\n+        }\n+        if (x == null || y == null)\n+        {\n+            return false;\n+        }\n+        LocalDateTime dtx = (LocalDateTime) x;\n+        LocalDateTime dty = (LocalDateTime) y;\n+\n+        return dtx.equals(dty);\n+    }\n+\n+    public int hashCode(Object object) throws HibernateException\n+    {\n+        return object.hashCode();\n+    }\n+\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n+\t{\n+\t\treturn nullSafeGet(resultSet, strings[0]);\n+\n+\t}\n+\n+\tpublic Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n+\t{\n+\t\tObject timestamp = Hibernate.TIMESTAMP.nullSafeGet(resultSet, string);\n+\t\tif (timestamp == null)\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new LocalDateTime(timestamp);\n+\t}\n+\n+\tpublic void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+\t{\n+\t\tif (value == null)\n+\t\t{\n+\t\t\tHibernate.TIMESTAMP.nullSafeSet(preparedStatement, null, index);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tHibernate.TIMESTAMP.nullSafeSet(preparedStatement, ((LocalDateTime) value).toDateTime().toDate(), index);\n+\t\t}\n+\t}\n+\n+    public Object deepCopy(Object value) throws HibernateException\n+    {\n+        if (value == null)\n+        {\n+            return null;\n+        }\n+\n+        return new LocalDateTime(value);\n+    }\n+\n+    public boolean isMutable()\n+    {\n+        return false;\n+    }\n+\n+    public Serializable disassemble(Object value) throws HibernateException\n+    {\n+        return (Serializable) value;\n+    }\n+\n+    public Object assemble(Serializable cached, Object value) throws HibernateException\n+    {\n+        return cached;\n+    }\n+\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException\n+    {\n+        return original;\n+    }\n+\n+\tpublic String objectToSQLString(Object object)\n+\t{\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic String toXMLString(Object object)\n+\t{\n+\t\treturn object.toString();\n+\t}\n+\n+\tpublic Object fromXMLString(String string)\n+\t{\n+\t\treturn new LocalDateTime(string);\n+\t}\n+}\n--- a/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/Event.java\n+++ b/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/Event.java\n /*\n- *  Copyright 2001-2007 Stephen Colebourne\n+ *  Copyright 2001-2008 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n \n import org.joda.time.DateTime;\n import org.joda.time.LocalDate;\n+import org.joda.time.LocalDateTime;\n import org.joda.time.LocalTime;\n \n /**\n \tprivate LocalTime localTime;\n \tprivate LocalTime localTime2;\n \tprivate LocalTime localTime3;\n+\tprivate LocalDateTime localDateTime;\n \n \tpublic Event()\n     {\n \t{\n \t\tthis.localTime3 = localTime3;\n \t}\n+\n+    public LocalDateTime getLocalDateTime()\n+    {\n+        return localDateTime;\n+    }\n+\n+    public void setLocalDateTime(LocalDateTime localDateTime)\n+    {\n+        this.localDateTime = localDateTime;\n+    }\n }\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/TestPersistentLocalDateTime.java\n+/*\n+ *  Copyright 2001-2008 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.contrib.hibernate;\n+\n+import java.io.File;\n+import java.sql.SQLException;\n+\n+import org.hibernate.Session;\n+import org.hibernate.SessionFactory;\n+import org.hibernate.cfg.Configuration;\n+import org.joda.time.LocalDateTime;\n+\n+public class TestPersistentLocalDateTime extends HibernateTestCase\n+{\n+    private LocalDateTime[] writeReadTimes = new LocalDateTime[]\n+    {\n+        new LocalDateTime(2004, 2, 25, 12, 11, 10),\n+        new LocalDateTime(1980, 3, 11, 13, 12, 11)\n+    };\n+\n+    public void testSimpleStore() throws SQLException\n+\t{\n+        SessionFactory factory = getSessionFactory();\n+\n+        Session session = factory.openSession();\n+\n+        for (int i = 0; i<writeReadTimes.length; i++)\n+        {\n+            LocalDateTime writeReadTime = writeReadTimes[i];\n+\n+            Event event = new Event();\n+            event.setId(i);\n+            event.setLocalDateTime(writeReadTime);\n+\n+            session.save(event);\n+        }\n+\n+        session.flush();\n+        session.connection().commit();\n+        session.close();\n+\n+        for (int i = 0; i<writeReadTimes.length; i++)\n+        {\n+            LocalDateTime writeReadTime = writeReadTimes[i];\n+\n+            session = factory.openSession();\n+            Event eventReread = (Event) session.get(Event.class, new Integer(i));\n+\n+            assertNotNull(\"get failed - event#'\" + i + \"'not found\", eventReread);\n+            assertNotNull(\"get failed - returned null\", eventReread.getLocalDateTime());\n+\n+            // we loose the timezone, so we have to normalize both to offset=0\n+            assertEquals(\"get failed - returned different time\",\n+                writeReadTime,\n+                eventReread.getLocalDateTime());\n+\n+            session.close();\n+        }\n+    }\n+\n+\tprotected void setupConfiguration(Configuration cfg)\n+\t{\n+\t\tcfg.addFile(new File(\"src/test/org/joda/time/contrib/hibernate/event.hbm.xml\"));\n+\t\tcfg.addFile(new File(\"src/test/org/joda/time/contrib/hibernate/eventTZ.hbm.xml\"));\n+\t}\n+}", "timestamp": 1223816872, "metainfo": ""}