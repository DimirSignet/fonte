{"sha": "14dcaf0e3931855913d79d0fbe8d1e6f1421b7a7", "log": "Re-organized chronology package and created new field package.   ", "commit": "\n--- a/JodaTime/src/example/org/joda/example/time/AgeCalculator.java\n+++ b/JodaTime/src/example/org/joda/example/time/AgeCalculator.java\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.DurationField;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * AgeCalculator is a small Swing application that computes age from a specific\n--- a/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java\n+++ b/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java\n \n import org.joda.time.DateTime;\n import org.joda.time.MutableDateTime;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GJChronology;\n \n /**\n  * DateTimePerformance provides various comparisons between the Java supplied\n--- a/JodaTime/src/java/org/joda/time/AbstractDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractDateTime.java\n import java.io.Serializable;\n import java.util.Locale;\n \n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n import org.joda.time.convert.InstantConverter;\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.format.DateTimeFormat;\n--- a/JodaTime/src/java/org/joda/time/AbstractInstant.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractInstant.java\n import java.util.Date;\n import java.util.GregorianCalendar;\n import java.util.Locale;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * AbstractInstant provides the common behaviour for instant classes.\n--- a/JodaTime/src/java/org/joda/time/AbstractInterval.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractInterval.java\n  */\n package org.joda.time;\n \n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.IntervalConverter;\n import org.joda.time.format.DateTimePrinter;\n--- a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java\n import java.io.Serializable;\n import java.util.Locale;\n \n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.InstantConverter;\n import org.joda.time.format.DateTimeFormat;\n--- a/JodaTime/src/java/org/joda/time/Chronology.java\n+++ b/JodaTime/src/java/org/joda/time/Chronology.java\n  */\n package org.joda.time;\n \n-import java.io.Serializable;\n-import org.joda.time.chrono.UnsupportedDateTimeField;\n-import org.joda.time.chrono.UnsupportedDurationField;\n-\n /**\n- * Chronology provides access to the individual date time fields for\n- * a chronological calendar system.\n- * Various chronologies are supported by subclasses including ISO and \n- * GregorianJulian. \n+ * Chronology provides access to the individual date time fields for a\n+ * chronological calendar system. Various chronologies are supported by\n+ * subclasses including ISO and GregorianJulian.\n  * <p>\n  * This class defines a number of fields with names from the ISO8601 standard.\n  * Chronology does not 'strongly' define these fields however, thus subclasses\n  * are free to interpret the field names as they wish. For example, a week\n  * could be defined as 10 days and a month as 40 days in a special\n- * WeirdChronology subclass. Clearly the GJ and ISO implementations provided\n- * use the field names as you would expect.\n- * <p>\n- * Chronology is thread-safe and immutable, and all subclasses must be as well.\n+ * WeirdChronology implementation. Clearly the GJ and ISO implementations\n+ * provided use the field names as you would expect.\n  * \n- * @see org.joda.time.chrono.iso.ISOChronology\n- * @see org.joda.time.chrono.gj.GJChronology\n+ * @see org.joda.time.chrono.ISOChronology\n+ * @see org.joda.time.chrono.GJChronology\n+ * @see org.joda.time.chrono.GregorianChronology\n+ * @see org.joda.time.chrono.JulianChronology\n+ * @see org.joda.time.chrono.CopticChronology\n+ * @see org.joda.time.chrono.BuddhistChronology\n  *\n  * @author Stephen Colebourne\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public abstract class Chronology implements Serializable {\n+public interface Chronology {\n     \n-    static final long serialVersionUID = -7310865996721419676L;\n-\n-    /**\n-     * Restricted constructor\n-     */\n-    protected Chronology() {\n-        super();\n-    }\n-\n     /**\n      * Returns the DateTimeZone that this Chronology operates in, or null if\n      * unspecified.\n      *\n      * @return DateTimeZone null if unspecified\n      */\n-    public abstract DateTimeZone getDateTimeZone();\n+    DateTimeZone getDateTimeZone();\n \n     /**\n      * Returns an instance of this Chronology that operates in the UTC time\n      *\n      * @return a version of this chronology that ignores time zones\n      */\n-    public abstract Chronology withUTC();\n+    Chronology withUTC();\n     \n     /**\n      * Returns an instance of this Chronology that operates in any time zone.\n      * @param zone to use, or default if null\n      * @see org.joda.time.chrono.ZonedChronology\n      */\n-    public abstract Chronology withDateTimeZone(DateTimeZone zone);\n+    Chronology withDateTimeZone(DateTimeZone zone);\n \n     /**\n      * Returns a date-only millisecond instant, by clearing the time fields\n      * @return millisecond instant from 1970-01-01T00:00:00Z with the time part\n      * cleared\n      */\n-    public long getDateOnlyMillis(long instant) {\n-        return dayOfYear().roundFloor(instant);\n-    }\n+    long getDateOnlyMillis(long instant);\n \n     /**\n      * Returns a date-only millisecond instant, formed from the given year,\n      * @return millisecond instant from 1970-01-01T00:00:00Z without any time\n      * part\n      */\n-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n-        throws IllegalArgumentException\n-    {\n-        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n-    }\n+    long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException;\n \n     /**\n      * Returns a time-only millisecond instant, by clearing the date fields\n      * @return millisecond instant from 1970-01-01T00:00:00Z with the date part\n      * cleared\n      */\n-    public long getTimeOnlyMillis(long instant) {\n-        return dayOfYear().remainder(instant);\n-    }\n+    long getTimeOnlyMillis(long instant);\n \n     /**\n      * Returns a time-only millisecond instant, formed from the given hour,\n      * @return millisecond instant from 1970-01-01T00:00:00Z without any date\n      * part\n      */\n-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        long instant = hourOfDay().set(0, hourOfDay);\n-        instant = minuteOfHour().set(instant, minuteOfHour);\n-        instant = secondOfMinute().set(instant, secondOfMinute);\n-        return millisOfSecond().set(instant, millisOfSecond);\n-    }\n+    long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n+                           int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException;\n \n     /**\n      * Returns a datetime millisecond instant, formed from the given year,\n      * @param millisOfDay millisecond to use\n      * @return millisecond instant from 1970-01-01T00:00:00Z\n      */\n-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n-                                  int millisOfDay)\n-        throws IllegalArgumentException\n-    {\n-        long instant = year().set(0, year);\n-        instant = monthOfYear().set(instant, monthOfYear);\n-        instant = dayOfMonth().set(instant, dayOfMonth);\n-        return millisOfDay().set(instant, millisOfDay);\n-    }\n+    long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay)\n+        throws IllegalArgumentException;\n \n     /**\n      * Returns a datetime millisecond instant, from from the given instant,\n      * @param millisOfSecond millisecond to use\n      * @return millisecond instant from 1970-01-01T00:00:00Z\n      */\n-    public long getDateTimeMillis(long instant,\n-                                  int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        instant = hourOfDay().set(instant, hourOfDay);\n-        instant = minuteOfHour().set(instant, minuteOfHour);\n-        instant = secondOfMinute().set(instant, secondOfMinute);\n-        return millisOfSecond().set(instant, millisOfSecond);\n-    }\n+    long getDateTimeMillis(long instant,\n+                           int hourOfDay, int minuteOfHour,\n+                           int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException;\n \n     /**\n      * Returns a datetime millisecond instant, formed from the given year,\n      * @param millisOfSecond millisecond to use\n      * @return millisecond instant from 1970-01-01T00:00:00Z\n      */\n-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n-                                  int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        long instant = year().set(0, year);\n-        instant = monthOfYear().set(instant, monthOfYear);\n-        instant = dayOfMonth().set(instant, dayOfMonth);\n-        instant = hourOfDay().set(instant, hourOfDay);\n-        instant = minuteOfHour().set(instant, minuteOfHour);\n-        instant = secondOfMinute().set(instant, secondOfMinute);\n-        return millisOfSecond().set(instant, millisOfSecond);\n-    }\n+    long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                           int hourOfDay, int minuteOfHour,\n+                           int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException;\n \n     // Millis\n     //-----------------------------------------------------------------------\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    public DurationField millis() {\n-        return UnsupportedDurationField.getInstance(\"millis\");\n-    }\n+    DurationField millis();\n \n     /**\n      * Get the millis of second field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField millisOfSecond() {\n-        return UnsupportedDateTimeField.getInstance(\"millisOfSecond\", millis());\n-    }\n+    DateTimeField millisOfSecond();\n \n     /**\n      * Get the millis of day field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField millisOfDay() {\n-        return UnsupportedDateTimeField.getInstance(\"millisOfDay\", millis());\n-    }\n+    DateTimeField millisOfDay();\n \n     // Second\n     //-----------------------------------------------------------------------\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    public DurationField seconds() {\n-        return UnsupportedDurationField.getInstance(\"seconds\");\n-    }\n+    DurationField seconds();\n \n     /**\n      * Get the second of minute field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField secondOfMinute() {\n-        return UnsupportedDateTimeField.getInstance(\"secondOfMinute\", seconds());\n-    }\n+    DateTimeField secondOfMinute();\n \n     /**\n      * Get the second of day field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField secondOfDay() {\n-        return UnsupportedDateTimeField.getInstance(\"secondOfDay\", seconds());\n-    }\n+    DateTimeField secondOfDay();\n \n     // Minute\n     //-----------------------------------------------------------------------\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    public DurationField minutes() {\n-        return UnsupportedDurationField.getInstance(\"minutes\");\n-    }\n+    DurationField minutes();\n \n     /**\n      * Get the minute of hour field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField minuteOfHour() {\n-        return UnsupportedDateTimeField.getInstance(\"minuteOfHour\", minutes());\n-    }\n+    DateTimeField minuteOfHour();\n \n     /**\n      * Get the minute of day field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField minuteOfDay() {\n-        return UnsupportedDateTimeField.getInstance(\"minuteOfDay\", minutes());\n-    }\n+    DateTimeField minuteOfDay();\n \n     // Hour\n     //-----------------------------------------------------------------------\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    public DurationField hours() {\n-        return UnsupportedDurationField.getInstance(\"hours\");\n-    }\n+    DurationField hours();\n \n     /**\n      * Get the hour of day (0-23) field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField hourOfDay() {\n-        return UnsupportedDateTimeField.getInstance(\"hourOfDay\", hours());\n-    }\n+    DateTimeField hourOfDay();\n \n     /**\n      * Get the hour of day (offset to 1-24) field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField clockhourOfDay() {\n-        return UnsupportedDateTimeField.getInstance(\"clockhourOfDay\", hours());\n-    }\n+    DateTimeField clockhourOfDay();\n \n     /**\n      * Get the hour of am/pm (0-11) field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField hourOfHalfday() {\n-        return UnsupportedDateTimeField.getInstance(\"hourOfHalfday\", hours());\n-    }\n+    DateTimeField hourOfHalfday();\n \n     /**\n      * Get the hour of am/pm (offset to 1-12) field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField clockhourOfHalfday() {\n-        return UnsupportedDateTimeField.getInstance(\"clockhourOfHalfday\", hours());\n-    }\n+    DateTimeField clockhourOfHalfday();\n \n     /**\n      * Get the AM(0) PM(1) field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField halfdayOfDay() {\n-        return UnsupportedDateTimeField.getInstance\n-            (\"halfdayOfDay\", UnsupportedDurationField.getInstance(\"halfdays\"));\n-    }\n+    DateTimeField halfdayOfDay();\n \n     // Day\n     //-----------------------------------------------------------------------\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    public DurationField days() {\n-        return UnsupportedDurationField.getInstance(\"days\");\n-    }\n+    DurationField days();\n \n     /**\n      * Get the day of week field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField dayOfWeek() {\n-        return UnsupportedDateTimeField.getInstance(\"dayOfWeek\", days());\n-    }\n+    DateTimeField dayOfWeek();\n \n     /**\n      * Get the day of month field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField dayOfMonth() {\n-        return UnsupportedDateTimeField.getInstance(\"dayOfMonth\", days());\n-    }\n+    DateTimeField dayOfMonth();\n \n     /**\n      * Get the day of year field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField dayOfYear() {\n-        return UnsupportedDateTimeField.getInstance(\"dayOfYear\", days());\n-    }\n+    DateTimeField dayOfYear();\n \n     // Week\n     //-----------------------------------------------------------------------\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    public DurationField weeks() {\n-        return UnsupportedDurationField.getInstance(\"weeks\");\n-    }\n+    DurationField weeks();\n \n     /**\n      * Get the week of a week based year field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField weekOfWeekyear() {\n-        return UnsupportedDateTimeField.getInstance(\"weekOfWeekyear\", weeks());\n-    }\n+    DateTimeField weekOfWeekyear();\n \n     /**\n      * Get the weekyears duration field for this chronology.\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    public DurationField weekyears() {\n-        return UnsupportedDurationField.getInstance(\"weekyears\");\n-    }\n+    DurationField weekyears();\n \n     /**\n      * Get the year of a week based year field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField weekyear() {\n-        return UnsupportedDateTimeField.getInstance(\"weekyear\", weekyears());\n-    }\n+    DateTimeField weekyear();\n \n     // Month\n     //-----------------------------------------------------------------------\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    public DurationField months() {\n-        return UnsupportedDurationField.getInstance(\"months\");\n-    }\n+    DurationField months();\n \n     /**\n      * Get the month of year field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField monthOfYear() {\n-        return UnsupportedDateTimeField.getInstance(\"monthOfYear\", months());\n-    }\n+    DateTimeField monthOfYear();\n \n     // Year\n     //-----------------------------------------------------------------------\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    public DurationField years() {\n-        return UnsupportedDurationField.getInstance(\"years\");\n-    }\n+    DurationField years();\n \n     /**\n      * Get the year field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField year() {\n-        return UnsupportedDateTimeField.getInstance(\"year\", years());\n-    }\n+    DateTimeField year();\n \n     /**\n      * Get the year of era field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField yearOfEra() {\n-        return UnsupportedDateTimeField.getInstance(\"yearOfEra\", years());\n-    }\n+    DateTimeField yearOfEra();\n \n     /**\n      * Get the year of century field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField yearOfCentury() {\n-        return UnsupportedDateTimeField.getInstance(\"yearOfCentury\", years());\n-    }\n+    DateTimeField yearOfCentury();\n \n     /**\n      * Get the centuries duration field for this chronology.\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    public DurationField centuries() {\n-        return UnsupportedDurationField.getInstance(\"centuries\");\n-    }\n+    DurationField centuries();\n \n     /**\n      * Get the century of era field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField centuryOfEra() {\n-        return UnsupportedDateTimeField.getInstance(\"centuryOfEra\", centuries());\n-    }\n+    DateTimeField centuryOfEra();\n \n     /**\n      * Get the eras duration field for this chronology.\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    public DurationField eras() {\n-        return UnsupportedDurationField.getInstance(\"eras\");\n-    }\n+    DurationField eras();\n \n     /**\n      * Get the era field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    public DateTimeField era() {\n-        return UnsupportedDateTimeField.getInstance(\"era\", eras());\n-    }\n+    DateTimeField era();\n \n     /**\n      * Gets a debugging toString.\n      * \n      * @return a debugging string\n      */\n-    public abstract String toString();\n+    String toString();\n \n }\n--- a/JodaTime/src/java/org/joda/time/DateOnly.java\n+++ b/JodaTime/src/java/org/joda/time/DateOnly.java\n \n import java.io.Serializable;\n \n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n // Import for @link support\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.format.ISODateTimeFormat;\n--- a/JodaTime/src/java/org/joda/time/DurationType.java\n+++ b/JodaTime/src/java/org/joda/time/DurationType.java\n package org.joda.time;\n \n import java.io.Serializable;\n-import org.joda.time.chrono.MillisDurationField;\n-import org.joda.time.chrono.PreciseDurationField;\n-import org.joda.time.chrono.ScaledDurationField;\n-import org.joda.time.chrono.UnsupportedDurationField;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.field.MillisDurationField;\n+import org.joda.time.field.PreciseDurationField;\n+import org.joda.time.field.ScaledDurationField;\n+import org.joda.time.field.UnsupportedDurationField;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * Controls a duration implementation by specifying which duration fields are to be used.\n--- a/JodaTime/src/java/org/joda/time/MutableDateOnly.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDateOnly.java\n \n import java.io.Serializable;\n \n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.DurationConverter;\n import org.joda.time.format.ISODateTimeFormat;\n--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java\n \n import java.io.Serializable;\n \n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.DurationConverter;\n import org.joda.time.convert.InstantConverter;\n--- a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java\n+++ b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java\n \n import java.io.Serializable;\n \n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.DurationConverter;\n import org.joda.time.format.ISODateTimeFormat;\n--- a/JodaTime/src/java/org/joda/time/TimeOnly.java\n+++ b/JodaTime/src/java/org/joda/time/TimeOnly.java\n \n import java.io.Serializable;\n \n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n // Import for @link support\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.format.ISODateTimeFormat;\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.Chronology;\n+// Import for @link support\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.UnsupportedDateTimeField;\n+import org.joda.time.field.UnsupportedDurationField;\n+\n+/**\n+ * AbstractChronology provides a skeleton implementation for chronology\n+ * classes. Many utility methods are defined, but all fields are unsupported.\n+ * <p>\n+ * AbstractChronology is thread-safe and immutable, and all subclasses must be\n+ * as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class AbstractChronology implements Chronology, Serializable {\n+    \n+    static final long serialVersionUID = -7310865996721419676L;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    protected AbstractChronology() {\n+        super();\n+    }\n+\n+    /**\n+     * Returns the DateTimeZone that this Chronology operates in, or null if\n+     * unspecified.\n+     *\n+     * @return DateTimeZone null if unspecified\n+     */\n+    public abstract DateTimeZone getDateTimeZone();\n+\n+    /**\n+     * Returns an instance of this Chronology that operates in the UTC time\n+     * zone. Chronologies that do not operate in a time zone or are already\n+     * UTC must return themself.\n+     *\n+     * @return a version of this chronology that ignores time zones\n+     */\n+    public abstract Chronology withUTC();\n+    \n+    /**\n+     * Returns an instance of this Chronology that operates in any time zone.\n+     *\n+     * @return a version of this chronology with a specific time zone\n+     * @param zone to use, or default if null\n+     * @see org.joda.time.chrono.ZonedChronology\n+     */\n+    public abstract Chronology withDateTimeZone(DateTimeZone zone);\n+\n+    /**\n+     * Returns a date-only millisecond instant, by clearing the time fields\n+     * from the given instant.\n+     * <p>\n+     * The default implementation simply returns\n+     * <code>dayOfYear().roundFloor(instant)</code>.\n+     * \n+     * @param instant the milliseconds from 1970-01-01T00:00:00Z\n+     * @return millisecond instant from 1970-01-01T00:00:00Z with the time part\n+     * cleared\n+     */\n+    public long getDateOnlyMillis(long instant) {\n+        return dayOfYear().roundFloor(instant);\n+    }\n+\n+    /**\n+     * Returns a date-only millisecond instant, formed from the given year,\n+     * month, and day values. The set of given values must refer to a valid\n+     * date, or else an IllegalArgumentException is thrown.\n+     * <p>\n+     * The default implementation simply returns\n+     * <code>getDateTimeMillis(year, monthOfYear, dayOfMonth, 0)</code>.\n+     *\n+     * @param year year to use\n+     * @param monthOfYear month to use\n+     * @param dayOfMonth day of month to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z without any time\n+     * part\n+     */\n+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException\n+    {\n+        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n+    }\n+\n+    /**\n+     * Returns a time-only millisecond instant, by clearing the date fields\n+     * from the given instant.\n+     * <p>\n+     * The default implementation simply returns\n+     * <code>dayOfYear().remainder(instant)</code>.\n+     * \n+     * @param instant the milliseconds from 1970-01-01T00:00:00Z\n+     * @return millisecond instant from 1970-01-01T00:00:00Z with the date part\n+     * cleared\n+     */\n+    public long getTimeOnlyMillis(long instant) {\n+        return dayOfYear().remainder(instant);\n+    }\n+\n+    /**\n+     * Returns a time-only millisecond instant, formed from the given hour,\n+     * minute, second, and millisecond values. The set of given values must\n+     * refer to a valid time, or else an IllegalArgumentException is thrown.\n+     * <p>\n+     * The default implementation calls upon separate DateTimeFields to\n+     * determine the result. Subclasses are encouraged to provide a more\n+     * efficient implementation.\n+     *\n+     * @param hourOfDay hour to use\n+     * @param minuteOfHour minute to use\n+     * @param secondOfMinute second to use\n+     * @param millisOfSecond millisecond to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z without any date\n+     * part\n+     */\n+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        long instant = hourOfDay().set(0, hourOfDay);\n+        instant = minuteOfHour().set(instant, minuteOfHour);\n+        instant = secondOfMinute().set(instant, secondOfMinute);\n+        return millisOfSecond().set(instant, millisOfSecond);\n+    }\n+\n+    /**\n+     * Returns a datetime millisecond instant, formed from the given year,\n+     * month, day, and millisecond values. The set of given values must refer\n+     * to a valid datetime, or else an IllegalArgumentException is thrown.\n+     * <p>\n+     * The default implementation calls upon separate DateTimeFields to\n+     * determine the result. Subclasses are encouraged to provide a more\n+     * efficient implementation.\n+     *\n+     * @param year year to use\n+     * @param monthOfYear month to use\n+     * @param dayOfMonth day of month to use\n+     * @param millisOfDay millisecond to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        long instant = year().set(0, year);\n+        instant = monthOfYear().set(instant, monthOfYear);\n+        instant = dayOfMonth().set(instant, dayOfMonth);\n+        return millisOfDay().set(instant, millisOfDay);\n+    }\n+\n+    /**\n+     * Returns a datetime millisecond instant, from from the given instant,\n+     * hour, minute, second, and millisecond values. The set of given values\n+     * must refer to a valid datetime, or else an IllegalArgumentException is\n+     * thrown.\n+     * <p>\n+     * The default implementation calls upon separate DateTimeFields to\n+     * determine the result. Subclasses are encouraged to provide a more\n+     * efficient implementation.\n+     *\n+     * @param instant instant to start from\n+     * @param hourOfDay hour to use\n+     * @param minuteOfHour minute to use\n+     * @param secondOfMinute second to use\n+     * @param millisOfSecond millisecond to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public long getDateTimeMillis(long instant,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        instant = hourOfDay().set(instant, hourOfDay);\n+        instant = minuteOfHour().set(instant, minuteOfHour);\n+        instant = secondOfMinute().set(instant, secondOfMinute);\n+        return millisOfSecond().set(instant, millisOfSecond);\n+    }\n+\n+    /**\n+     * Returns a datetime millisecond instant, formed from the given year,\n+     * month, day, hour, minute, second, and millisecond values. The set of\n+     * given values must refer to a valid datetime, or else an\n+     * IllegalArgumentException is thrown.\n+     * <p>\n+     * The default implementation calls upon separate DateTimeFields to\n+     * determine the result. Subclasses are encouraged to provide a more\n+     * efficient implementation.\n+     *\n+     * @param year year to use\n+     * @param monthOfYear month to use\n+     * @param dayOfMonth day of month to use\n+     * @param hourOfDay hour to use\n+     * @param minuteOfHour minute to use\n+     * @param secondOfMinute second to use\n+     * @param millisOfSecond millisecond to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        long instant = year().set(0, year);\n+        instant = monthOfYear().set(instant, monthOfYear);\n+        instant = dayOfMonth().set(instant, dayOfMonth);\n+        instant = hourOfDay().set(instant, hourOfDay);\n+        instant = minuteOfHour().set(instant, minuteOfHour);\n+        instant = secondOfMinute().set(instant, secondOfMinute);\n+        return millisOfSecond().set(instant, millisOfSecond);\n+    }\n+\n+    // Millis\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the millis duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField millis() {\n+        return UnsupportedDurationField.getInstance(\"millis\");\n+    }\n+\n+    /**\n+     * Get the millis of second field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField millisOfSecond() {\n+        return UnsupportedDateTimeField.getInstance(\"millisOfSecond\", millis());\n+    }\n+\n+    /**\n+     * Get the millis of day field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField millisOfDay() {\n+        return UnsupportedDateTimeField.getInstance(\"millisOfDay\", millis());\n+    }\n+\n+    // Second\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the seconds duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField seconds() {\n+        return UnsupportedDurationField.getInstance(\"seconds\");\n+    }\n+\n+    /**\n+     * Get the second of minute field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField secondOfMinute() {\n+        return UnsupportedDateTimeField.getInstance(\"secondOfMinute\", seconds());\n+    }\n+\n+    /**\n+     * Get the second of day field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField secondOfDay() {\n+        return UnsupportedDateTimeField.getInstance(\"secondOfDay\", seconds());\n+    }\n+\n+    // Minute\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the minutes duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField minutes() {\n+        return UnsupportedDurationField.getInstance(\"minutes\");\n+    }\n+\n+    /**\n+     * Get the minute of hour field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField minuteOfHour() {\n+        return UnsupportedDateTimeField.getInstance(\"minuteOfHour\", minutes());\n+    }\n+\n+    /**\n+     * Get the minute of day field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField minuteOfDay() {\n+        return UnsupportedDateTimeField.getInstance(\"minuteOfDay\", minutes());\n+    }\n+\n+    // Hour\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hours duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField hours() {\n+        return UnsupportedDurationField.getInstance(\"hours\");\n+    }\n+\n+    /**\n+     * Get the hour of day (0-23) field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField hourOfDay() {\n+        return UnsupportedDateTimeField.getInstance(\"hourOfDay\", hours());\n+    }\n+\n+    /**\n+     * Get the hour of day (offset to 1-24) field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField clockhourOfDay() {\n+        return UnsupportedDateTimeField.getInstance(\"clockhourOfDay\", hours());\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (0-11) field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField hourOfHalfday() {\n+        return UnsupportedDateTimeField.getInstance(\"hourOfHalfday\", hours());\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (offset to 1-12) field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField clockhourOfHalfday() {\n+        return UnsupportedDateTimeField.getInstance(\"clockhourOfHalfday\", hours());\n+    }\n+\n+    /**\n+     * Get the AM(0) PM(1) field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField halfdayOfDay() {\n+        return UnsupportedDateTimeField.getInstance\n+            (\"halfdayOfDay\", UnsupportedDurationField.getInstance(\"halfdays\"));\n+    }\n+\n+    // Day\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the days duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField days() {\n+        return UnsupportedDurationField.getInstance(\"days\");\n+    }\n+\n+    /**\n+     * Get the day of week field for this chronology.\n+     *\n+     * <p>DayOfWeek values are defined in {@link DateTimeConstants}.\n+     * They use the ISO definitions, where 1 is Monday and 7 is Sunday.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField dayOfWeek() {\n+        return UnsupportedDateTimeField.getInstance(\"dayOfWeek\", days());\n+    }\n+\n+    /**\n+     * Get the day of month field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField dayOfMonth() {\n+        return UnsupportedDateTimeField.getInstance(\"dayOfMonth\", days());\n+    }\n+\n+    /**\n+     * Get the day of year field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField dayOfYear() {\n+        return UnsupportedDateTimeField.getInstance(\"dayOfYear\", days());\n+    }\n+\n+    // Week\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the weeks duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField weeks() {\n+        return UnsupportedDurationField.getInstance(\"weeks\");\n+    }\n+\n+    /**\n+     * Get the week of a week based year field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField weekOfWeekyear() {\n+        return UnsupportedDateTimeField.getInstance(\"weekOfWeekyear\", weeks());\n+    }\n+\n+    /**\n+     * Get the weekyears duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField weekyears() {\n+        return UnsupportedDurationField.getInstance(\"weekyears\");\n+    }\n+\n+    /**\n+     * Get the year of a week based year field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField weekyear() {\n+        return UnsupportedDateTimeField.getInstance(\"weekyear\", weekyears());\n+    }\n+\n+    // Month\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the months duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField months() {\n+        return UnsupportedDurationField.getInstance(\"months\");\n+    }\n+\n+    /**\n+     * Get the month of year field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField monthOfYear() {\n+        return UnsupportedDateTimeField.getInstance(\"monthOfYear\", months());\n+    }\n+\n+    // Year\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the years duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField years() {\n+        return UnsupportedDurationField.getInstance(\"years\");\n+    }\n+\n+    /**\n+     * Get the year field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField year() {\n+        return UnsupportedDateTimeField.getInstance(\"year\", years());\n+    }\n+\n+    /**\n+     * Get the year of era field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField yearOfEra() {\n+        return UnsupportedDateTimeField.getInstance(\"yearOfEra\", years());\n+    }\n+\n+    /**\n+     * Get the year of century field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField yearOfCentury() {\n+        return UnsupportedDateTimeField.getInstance(\"yearOfCentury\", years());\n+    }\n+\n+    /**\n+     * Get the centuries duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField centuries() {\n+        return UnsupportedDurationField.getInstance(\"centuries\");\n+    }\n+\n+    /**\n+     * Get the century of era field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField centuryOfEra() {\n+        return UnsupportedDateTimeField.getInstance(\"centuryOfEra\", centuries());\n+    }\n+\n+    /**\n+     * Get the eras duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField eras() {\n+        return UnsupportedDurationField.getInstance(\"eras\");\n+    }\n+\n+    /**\n+     * Get the era field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField era() {\n+        return UnsupportedDateTimeField.getInstance(\"era\", eras());\n+    }\n+\n+    /**\n+     * Gets a debugging toString.\n+     * \n+     * @return a debugging string\n+     */\n+    public abstract String toString();\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.DividedDateTimeField;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.field.MillisDurationField;\n+import org.joda.time.field.NonZeroDateTimeField;\n+import org.joda.time.field.OffsetDateTimeField;\n+import org.joda.time.field.PreciseDateTimeField;\n+import org.joda.time.field.PreciseDurationField;\n+import org.joda.time.field.RemainderDateTimeField;\n+\n+/**\n+ *\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @author Guy Allard\n+ * @since 1.0\n+ */\n+public abstract class AbstractGJChronology extends AssembledChronology {\n+\n+    static final long serialVersionUID = 8283225332206808863L;\n+\n+    static final long MILLIS_1970_TO_2000 = 946684800000L;\n+\n+    // These arrays are NOT public. We trust ourselves not to alter the array.\n+    // They use zero-based array indexes so the that valid range of months is\n+    // automatically checked.\n+\n+    private static final int[] MIN_DAYS_PER_MONTH_ARRAY = {\n+        31,28,31,30,31,30,31,31,30,31,30,31\n+    };\n+\n+    private static final int[] MAX_DAYS_PER_MONTH_ARRAY = {\n+        31,29,31,30,31,30,31,31,30,31,30,31\n+    };\n+\n+    private static final long[] MIN_TOTAL_MILLIS_BY_MONTH_ARRAY;\n+    private static final long[] MAX_TOTAL_MILLIS_BY_MONTH_ARRAY;\n+\n+    private static final DurationField cMillisField;\n+    private static final DurationField cSecondsField;\n+    private static final DurationField cMinutesField;\n+    private static final DurationField cHoursField;\n+    private static final DurationField cHalfdaysField;\n+    private static final DurationField cDaysField;\n+    private static final DurationField cWeeksField;\n+\n+    private static final DateTimeField cMillisOfSecondField;\n+    private static final DateTimeField cMillisOfDayField;\n+    private static final DateTimeField cSecondOfMinuteField;\n+    private static final DateTimeField cSecondOfDayField;\n+    private static final DateTimeField cMinuteOfHourField;\n+    private static final DateTimeField cMinuteOfDayField;\n+    private static final DateTimeField cHourOfDayField;\n+    private static final DateTimeField cHourOfHalfdayField;\n+    private static final DateTimeField cClockhourOfDayField;\n+    private static final DateTimeField cClockhourOfHalfdayField;\n+    private static final DateTimeField cHalfdayOfDayField;\n+\n+    static {\n+        MIN_TOTAL_MILLIS_BY_MONTH_ARRAY = new long[12];\n+        MAX_TOTAL_MILLIS_BY_MONTH_ARRAY = new long[12];\n+\n+        long minSum = 0;\n+        long maxSum = 0;\n+        for (int i=0; i<12; i++) {\n+            long millis = MIN_DAYS_PER_MONTH_ARRAY[i]\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+            minSum += millis;\n+            MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[i] = minSum;\n+\n+            millis = MAX_DAYS_PER_MONTH_ARRAY[i]\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+            maxSum += millis;\n+            MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[i] = maxSum;\n+        }\n+\n+        cMillisField = MillisDurationField.INSTANCE;\n+        cSecondsField = new PreciseDurationField\n+            (\"seconds\", DateTimeConstants.MILLIS_PER_SECOND);\n+        cMinutesField = new PreciseDurationField\n+            (\"minutes\", DateTimeConstants.MILLIS_PER_MINUTE);\n+        cHoursField = new PreciseDurationField\n+            (\"hours\", DateTimeConstants.MILLIS_PER_HOUR);\n+        cHalfdaysField = new PreciseDurationField\n+            (\"halfdays\", DateTimeConstants.MILLIS_PER_DAY / 2);\n+        cDaysField = new PreciseDurationField\n+            (\"days\", DateTimeConstants.MILLIS_PER_DAY);\n+        cWeeksField = new PreciseDurationField\n+            (\"weeks\", DateTimeConstants.MILLIS_PER_WEEK);\n+\n+        cMillisOfSecondField = new PreciseDateTimeField\n+            (\"millisOfSecond\", cMillisField, cSecondsField);\n+\n+        cMillisOfDayField = new PreciseDateTimeField\n+            (\"millisOfDay\", cMillisField, cDaysField);\n+             \n+        cSecondOfMinuteField = new PreciseDateTimeField\n+            (\"secondOfMinute\", cSecondsField, cMinutesField);\n+\n+        cSecondOfDayField = new PreciseDateTimeField\n+            (\"secondOfDay\", cSecondsField, cDaysField);\n+\n+        cMinuteOfHourField = new PreciseDateTimeField\n+            (\"minuteOfHour\", cMinutesField, cHoursField);\n+\n+        cMinuteOfDayField = new PreciseDateTimeField\n+            (\"minuteOfDay\", cMinutesField, cDaysField);\n+\n+        cHourOfDayField = new PreciseDateTimeField\n+            (\"hourOfDay\", cHoursField, cDaysField);\n+\n+        cHourOfHalfdayField = new PreciseDateTimeField\n+            (\"hourOfHalfday\", cHoursField, cHalfdaysField);\n+\n+        cClockhourOfDayField = new NonZeroDateTimeField\n+            (cHourOfDayField, \"clockhourOfDay\");\n+\n+        cClockhourOfHalfdayField = new NonZeroDateTimeField\n+            (cHourOfHalfdayField, \"clockhourOfHalfday\");\n+\n+        cHalfdayOfDayField = new HalfdayField();\n+    }\n+\n+    private transient YearInfo[] iYearInfoCache;\n+    private transient int iYearInfoCacheMask;\n+\n+    private final int iMinDaysInFirstWeek;\n+\n+    AbstractGJChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n+        super(base, param);\n+\n+        if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) {\n+            throw new IllegalArgumentException\n+                (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n+        }\n+\n+        iMinDaysInFirstWeek = minDaysInFirstWeek;\n+\n+        Integer i;\n+        try {\n+            i = Integer.getInteger(getClass().getName().concat(\".yearInfoCacheSize\"));\n+        } catch (SecurityException e) {\n+            i = null;\n+        }\n+\n+        int cacheSize;\n+        if (i == null) {\n+            cacheSize = 1024; // (1 << 10)\n+        } else {\n+            cacheSize = i.intValue();\n+            // Ensure cache size is even power of 2.\n+            cacheSize--;\n+            int shift = 0;\n+            while (cacheSize > 0) {\n+                shift++;\n+                cacheSize >>= 1;\n+            }\n+            cacheSize = 1 << shift;\n+        }\n+\n+        iYearInfoCache = new YearInfo[cacheSize];\n+        iYearInfoCacheMask = cacheSize - 1;\n+    }\n+\n+    public DateTimeZone getDateTimeZone() {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getDateTimeZone();\n+        }\n+        return DateTimeZone.UTC;\n+    }\n+\n+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getDateOnlyMillis(year, monthOfYear, dayOfMonth);\n+        }\n+\n+        boolean isLeap = isLeapYear(year);\n+\n+        FieldUtils.verifyValueBounds(\"monthOfYear\", monthOfYear, 1, 12);\n+        FieldUtils.verifyValueBounds(\"dayOfMonth\", dayOfMonth, 1,\n+                                (isLeap ? MAX_DAYS_PER_MONTH_ARRAY : MIN_DAYS_PER_MONTH_ARRAY)\n+                                [monthOfYear - 1]);\n+\n+        long instant = getYearMillis(year);\n+\n+        if (monthOfYear > 1) {\n+            instant += \n+                (isLeap ? MAX_TOTAL_MILLIS_BY_MONTH_ARRAY : MIN_TOTAL_MILLIS_BY_MONTH_ARRAY)\n+                [monthOfYear - 2];\n+        }\n+\n+        if (dayOfMonth != 1) {\n+            instant += (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n+        }\n+\n+        return instant;\n+    }\n+\n+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        }\n+\n+        FieldUtils.verifyValueBounds(\"hourOfDay\", hourOfDay, 0, 23);\n+        FieldUtils.verifyValueBounds(\"minuteOfHour\", minuteOfHour, 0, 59);\n+        FieldUtils.verifyValueBounds(\"secondOfMinute\", secondOfMinute, 0, 59);\n+        FieldUtils.verifyValueBounds(\"millisOfSecond\", millisOfSecond, 0, 999);\n+\n+        return hourOfDay * DateTimeConstants.MILLIS_PER_HOUR\n+            + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE\n+            + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND\n+            + millisOfSecond;\n+    }\n+\n+    public final long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                        int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n+        }\n+        FieldUtils.verifyValueBounds(\"millisOfDay\", millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY);\n+        return getDateOnlyMillis(year, monthOfYear, dayOfMonth) + millisOfDay;\n+    }\n+\n+    public final long getDateTimeMillis(long instant,\n+                                        int hourOfDay, int minuteOfHour,\n+                                        int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getDateTimeMillis\n+                (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        }\n+        return getDateOnlyMillis(instant)\n+            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    public final long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                        int hourOfDay, int minuteOfHour,\n+                                        int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n+                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        }\n+        return getDateOnlyMillis(year, monthOfYear, dayOfMonth)\n+            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    public final int getMinimumDaysInFirstWeek() {\n+        return iMinDaysInFirstWeek;\n+    }\n+\n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging toString.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        StringBuffer sb = new StringBuffer(60);\n+        String name = getClass().getName();\n+        int index = name.lastIndexOf('.');\n+        if (index >= 0) {\n+            name = name.substring(index + 1);\n+        }\n+        sb.append(name);\n+        sb.append('[');\n+        DateTimeZone zone = getDateTimeZone();\n+        if (zone != null) {\n+            sb.append(zone.getID());\n+            sb.append(\", \");\n+        }\n+        sb.append(\"mdfw=\");\n+        sb.append(getMinimumDaysInFirstWeek());\n+        sb.append(']');\n+        return sb.toString();\n+    }\n+\n+    protected void assemble(Fields fields) {\n+        // First copy fields that are the same for all Gregorian and Julian\n+        // chronologies.\n+\n+        fields.millis = cMillisField;\n+        fields.seconds = cSecondsField;\n+        fields.minutes = cMinutesField;\n+        fields.hours = cHoursField;\n+        //fields.halfdays = cHalfdaysField;  Doesn't exist in public interface\n+        fields.days = cDaysField;\n+        fields.weeks = cWeeksField;\n+\n+        fields.millisOfSecond = cMillisOfSecondField;\n+        fields.millisOfDay = cMillisOfDayField;\n+        fields.secondOfMinute = cSecondOfMinuteField;\n+        fields.secondOfDay = cSecondOfDayField;\n+        fields.minuteOfHour = cMinuteOfHourField;\n+        fields.minuteOfDay = cMinuteOfDayField;\n+        fields.hourOfDay = cHourOfDayField;\n+        fields.hourOfHalfday = cHourOfHalfdayField;\n+        fields.clockhourOfDay = cClockhourOfDayField;\n+        fields.clockhourOfHalfday = cClockhourOfHalfdayField;\n+        fields.halfdayOfDay = cHalfdayOfDayField;\n+\n+        // Now create fields that have unique behavior for Gregorian and Julian\n+        // chronologies.\n+\n+        fields.year = new GJYearDateTimeField(this);\n+        fields.yearOfEra = new GJYearOfEraDateTimeField(fields.year, this);\n+\n+        // Define one-based centuryOfEra and yearOfCentury.\n+        DateTimeField field = new OffsetDateTimeField(fields.yearOfEra, \"\", 99);\n+        fields.centuryOfEra = new DividedDateTimeField\n+            (field, \"centuryOfEra\", \"centuries\", 100);\n+        \n+        field = new RemainderDateTimeField\n+            ((DividedDateTimeField)fields.centuryOfEra, \"\");\n+        fields.yearOfCentury = new OffsetDateTimeField(field, \"yearOfCentury\", 1);\n+\n+        fields.era = new GJEraDateTimeField(this);\n+        fields.dayOfWeek = new GJDayOfWeekDateTimeField(this, fields.days);\n+        fields.dayOfMonth = new GJDayOfMonthDateTimeField(this, fields.days);\n+        fields.dayOfYear = new GJDayOfYearDateTimeField(this, fields.days);\n+        fields.monthOfYear = new GJMonthOfYearDateTimeField(this);\n+        fields.weekyear = new GJWeekyearDateTimeField(this);\n+        fields.weekOfWeekyear = new GJWeekOfWeekyearDateTimeField(this, fields.weeks);\n+\n+        // The remaining (imprecise) durations are available from the newly\n+        // created datetime fields.\n+\n+        fields.years = fields.year.getDurationField();\n+        fields.centuries = fields.centuryOfEra.getDurationField();\n+        fields.months = fields.monthOfYear.getDurationField();\n+        fields.weekyears = fields.weekyear.getDurationField();\n+    }\n+\n+    /**\n+     * Get the number of days in the year.\n+     * @param year The year to use.\n+     * @return 366 if a leap year, otherwise 365.\n+     */\n+    final int getDaysInYear(int year) {\n+        return isLeapYear(year) ? 366 : 365;\n+    }\n+\n+    final int getDaysInYearMonth(int year, int month) {\n+        if (isLeapYear(year)) {\n+            return MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n+        } else {\n+            return MIN_DAYS_PER_MONTH_ARRAY[month - 1];\n+        }\n+    }\n+\n+    /**\n+     * Returns the total number of milliseconds elapsed in the year, by the end\n+     * of the month.\n+     */\n+    final long getTotalMillisByYearMonth(int year, int month) {\n+        if (isLeapYear(year)) {\n+            return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n+        } else {\n+            return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n+        }\n+    }\n+\n+    /**\n+     * Get the number of weeks in the year.\n+     * @param year  the year to use.\n+     * @return number of weeks in the year.\n+     */\n+    final int getWeeksInYear(int year) {\n+        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);\n+        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);\n+        return (int) ((firstWeekMillis2 - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK);\n+    }\n+\n+    /**\n+     * Get the millis for the first week of a year.\n+     * @param year  the year to use.\n+     * @return millis\n+     */\n+    final long getFirstWeekOfYearMillis(int year) {\n+        long jan1millis = getYearMillis(year);\n+        int jan1dayOfWeek = getDayOfWeek(jan1millis);\n+        \n+        if (jan1dayOfWeek > (8 - iMinDaysInFirstWeek)) {\n+            // First week is end of previous year because it doesn't have enough days.\n+            return jan1millis + (8 - jan1dayOfWeek)\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+        } else {\n+            // First week is start of this year because it has enough days.\n+            return jan1millis - (jan1dayOfWeek - 1)\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+        }\n+    }\n+\n+    /**\n+     * Get the milliseconds for the start of a year.\n+     *\n+     * @param year The year to use.\n+     * @return millis from 1970-01-01T00:00:00Z\n+     */\n+    final long getYearMillis(int year) {\n+        return getYearInfo(year).iFirstDayMillis;\n+        //return calculateFirstDayOfYearMillis(year);\n+    }\n+\n+    /**\n+     * Get the milliseconds for the start of a month.\n+     *\n+     * @param year The year to use.\n+     * @param month The month to use\n+     * @return millis from 1970-01-01T00:00:00Z\n+     */\n+    final long getYearMonthMillis(int year, int month) {\n+        long millis = getYearMillis(year);\n+        // month\n+        if (month > 1) {\n+            millis += getTotalMillisByYearMonth(year, month - 1);\n+        }\n+        return millis;\n+    }\n+\n+    /**\n+     * Get the milliseconds for a particular date.\n+     *\n+     * @param year The year to use.\n+     * @param month The month to use\n+     * @param dayOfMonth The day of the month to use\n+     * @return millis from 1970-01-01T00:00:00Z\n+     */\n+    final long getYearMonthDayMillis(int year, int month, int dayOfMonth) {\n+        long millis = getYearMillis(year);\n+        // month\n+        if (month > 1) {\n+            millis += getTotalMillisByYearMonth(year, month - 1);\n+        }\n+        // day\n+        return millis + (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+    \n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    final int getYear(long instant) {\n+        // Get an initial estimate of the year, and the millis value that\n+        // represents the start of that year. Then verify estimate and fix if\n+        // necessary.\n+\n+        long unitMillis = getAverageMillisPerYear();\n+        long i2 = instant + getApproxMillisAtEpoch();\n+        if (i2 < 0) {\n+            i2 = i2 - unitMillis + 1;\n+        }\n+        int year = (int) (i2 / unitMillis);\n+\n+        long yearStart = getYearMillis(year);\n+        long diff = instant - yearStart;\n+\n+        if (diff < 0) {\n+            if (diff < -DateTimeConstants.MILLIS_PER_DAY * 2L) {\n+                // Too much error, assume operation overflowed.\n+                return getYearOverflow(instant);\n+            }\n+            year--;\n+        } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {\n+            if (diff >= DateTimeConstants.MILLIS_PER_DAY * 367L) {\n+                // Too much error, assume operation overflowed.\n+                return getYearOverflow(instant);\n+            }\n+            // One year may need to be added to fix estimate.\n+            long oneYear;\n+            if (isLeapYear(year)) {\n+                oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;\n+            } else {\n+                oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;\n+            }\n+\n+            yearStart += oneYear;\n+\n+            if ((yearStart ^ instant) < 0) {\n+                // Sign mismatch, operation may have overflowed.\n+                if ((yearStart <  0 && (yearStart - oneYear) >= 0) ||\n+                    (yearStart >= 0 && (yearStart - oneYear) <  0)   ) {\n+                    // It overflowed.\n+                    return getYearOverflow(instant);\n+                }\n+            }\n+\n+            if (yearStart <= instant) {\n+                // Didn't go too far, so actually add one year.\n+                year++;\n+            }\n+        }\n+\n+        return year;\n+    }\n+\n+    private final int getYearOverflow(long instant) {\n+        if (instant > 0) {\n+            int year = getMaxYear();\n+            long yearStartMillis = getYearMillis(year);\n+            if (isLeapYear(year)) {\n+                yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 366L;\n+            } else {\n+                yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 365L;\n+            }\n+            long yearEndMillis = yearStartMillis - 1;\n+\n+            if (instant <= yearEndMillis) {\n+                return year;\n+            }\n+\n+            throw new IllegalArgumentException\n+                (\"Instant too large: \" + instant + \" > \" + yearEndMillis);\n+        } else {\n+            int year = getMinYear();\n+            long yearStartMillis = getYearMillis(year);\n+            if (instant >= yearStartMillis) {\n+                return year;\n+            }\n+\n+            throw new IllegalArgumentException\n+                (\"Instant too small: \" + instant + \" < \" + yearStartMillis);\n+        }\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    final long setYear(long instant, int year) {\n+        int thisYear = getYear(instant);\n+        int dayOfYear = getDayOfYear(instant, thisYear);\n+        int millisOfDay = getMillisOfDay(instant);\n+\n+        if (dayOfYear > (31 + 28)) { // after Feb 28\n+            if (isLeapYear(thisYear)) {\n+                // Current date is Feb 29 or later.\n+                if (!isLeapYear(year)) {\n+                    // Moving to a non-leap year, Feb 29 does not exist.\n+                    dayOfYear--;\n+                }\n+            } else {\n+                // Current date is Mar 01 or later.\n+                if (isLeapYear(year)) {\n+                    // Moving to a leap year, account for Feb 29.\n+                    dayOfYear++;\n+                }\n+            }\n+        }\n+\n+        instant = getYearMonthDayMillis(year, 1, dayOfYear);\n+        instant += millisOfDay;\n+\n+        return instant;\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     */\n+    final int getMonthOfYear(long millis) {\n+        return getMonthOfYear(millis, getYear(millis));\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     */\n+    final int getMonthOfYear(long millis, int year) {\n+        // Perform a binary search to get the month. To make it go even faster,\n+        // compare using ints instead of longs. The number of milliseconds per\n+        // year exceeds the limit of a 32-bit int's capacity, so divide by\n+        // 1024. No precision is lost (except time of day) since the number of\n+        // milliseconds per day contains 1024 as a factor. After the division,\n+        // the instant isn't measured in milliseconds, but in units of\n+        // (128/125)seconds.\n+\n+        int i = (int)((millis - getYearMillis(year)) >> 10);\n+\n+        // There are 86400000 milliseconds per day, but divided by 1024 is\n+        // 84375. There are 84375 (128/125)seconds per day.\n+\n+        return\n+            (isLeapYear(year))\n+            ? ((i < 182 * 84375)\n+               ? ((i < 91 * 84375)\n+                  ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3)\n+                  : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6))\n+               : ((i < 274 * 84375)\n+                  ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9)\n+                  : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12)))\n+            : ((i < 181 * 84375)\n+               ? ((i < 90 * 84375)\n+                  ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3)\n+                  : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6))\n+               : ((i < 273 * 84375)\n+                  ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9)\n+                  : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12)));\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     */\n+    final int getDayOfMonth(long millis) {\n+        int year = getYear(millis);\n+        int month = getMonthOfYear(millis, year);\n+        return getDayOfMonth(millis, year, month);\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     */\n+    final int getDayOfMonth(long millis, int year) {\n+        int month = getMonthOfYear(millis, year);\n+        return getDayOfMonth(millis, year, month);\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     * @param month precalculated month of millis\n+     */\n+    final int getDayOfMonth(long millis, int year, int month) {\n+        long dateMillis = getYearMillis(year);\n+        if (month > 1) {\n+            dateMillis += getTotalMillisByYearMonth(year, month - 1);\n+        }\n+        return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    final int getDayOfYear(long instant) {\n+        return getDayOfYear(instant, getYear(instant));\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     */\n+    final int getDayOfYear(long instant, int year) {\n+        long yearStart = getYearMillis(year);\n+        return (int) ((instant - yearStart) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    final int getWeekyear(long instant) {\n+        int year = getYear(instant);\n+        int week = getWeekOfWeekyear(instant, year);\n+        if (week == 1) {\n+            return getYear(instant + DateTimeConstants.MILLIS_PER_WEEK);\n+        } else if (week > 51) {\n+            return getYear(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK));\n+        } else {\n+            return year;\n+        }\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    final int getWeekOfWeekyear(long instant) {\n+        return getWeekOfWeekyear(instant, getYear(instant));\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     */\n+    final int getWeekOfWeekyear(long instant, int year) {\n+        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);\n+        if (instant < firstWeekMillis1) {\n+            return getWeeksInYear(year - 1);\n+        }\n+        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);\n+        if (instant >= firstWeekMillis2) {\n+            return 1;\n+        }\n+        return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    final int getDayOfWeek(long instant) {\n+        // 1970-01-01 is day of week 4, Thursday.\n+\n+        long daysSince19700101;\n+        if (instant >= 0) {\n+            daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY;\n+        } else {\n+            daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1))\n+                / DateTimeConstants.MILLIS_PER_DAY;\n+            if (daysSince19700101 < -3) {\n+                return 7 + (int) ((daysSince19700101 + 4) % 7);\n+            }\n+        }\n+\n+        return 1 + (int) ((daysSince19700101 + 3) % 7);\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    final int getMillisOfDay(long instant) {\n+        if (instant >= 0) {\n+            return (int) (instant % DateTimeConstants.MILLIS_PER_DAY);\n+        } else {\n+            return (DateTimeConstants.MILLIS_PER_DAY - 1)\n+                + (int) ((instant + 1) % DateTimeConstants.MILLIS_PER_DAY);\n+        }\n+    }\n+\n+    abstract boolean isLeapYear(int year);\n+\n+    abstract long calculateFirstDayOfYearMillis(int year);\n+\n+    abstract int getMinYear();\n+\n+    abstract int getMaxYear();\n+\n+    abstract long getAverageMillisPerYear();\n+\n+    abstract long getAverageMillisPerMonth();\n+\n+    /**\n+     * Returns a constant representing the approximate number of milliseconds\n+     * elapsed from year 0 of this chronology. This constant <em>must</em> be\n+     * defined as:\n+     * <pre>\n+     *    yearAtEpoch * averageMillisPerYear + millisOfYearAtEpoch\n+     * <pre>\n+     * where epoch is 1970-01-01 (Gregorian).\n+     */\n+    abstract long getApproxMillisAtEpoch();\n+\n+    // Although accessed by multiple threads, this method doesn't need to be synchronized.\n+    private YearInfo getYearInfo(int year) {\n+        YearInfo[] cache = iYearInfoCache;\n+        int index = year & iYearInfoCacheMask;\n+        YearInfo info = cache[index];\n+        if (info == null || info.iYear != year) {\n+            info = new YearInfo(year, calculateFirstDayOfYearMillis(year));\n+            cache[index] = info;\n+        }\n+        return info;\n+    }\n+\n+    private static class HalfdayField extends PreciseDateTimeField {\n+        static final long serialVersionUID = 581601443656929254L;\n+\n+        HalfdayField() {\n+            super(\"halfdayOfDay\", cHalfdaysField, cDaysField);\n+        }\n+\n+        public String getAsText(long millis, Locale locale) {\n+            return GJLocaleSymbols.forLocale(locale).halfdayValueToText(get(millis));\n+        }\n+\n+        public long set(long millis, String text, Locale locale) {\n+            return set(millis, GJLocaleSymbols.forLocale(locale).halfdayTextToValue(text));\n+        }\n+\n+        public int getMaximumTextLength(Locale locale) {\n+            return GJLocaleSymbols.forLocale(locale).getHalfdayMaxTextLength();\n+        }\n+    }\n+\n+    private static class YearInfo {\n+        public final int iYear;\n+        public final long iFirstDayMillis;\n+\n+        YearInfo(int year, long firstDayMillis) {\n+            iYear = year;\n+            iFirstDayMillis = firstDayMillis;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Allows chronologies to be assembled from a container of fields.\n+ * <p>\n+ * AssembledChronology is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public abstract class AssembledChronology extends AbstractChronology {\n+\n+    static final long serialVersionUID = -6728465968995518215L;\n+\n+    private final Chronology iBase;\n+    private final Object iParam;\n+\n+    private transient DurationField iMillis;\n+    private transient DurationField iSeconds;\n+    private transient DurationField iMinutes;\n+    private transient DurationField iHours;\n+\n+    private transient DurationField iDays;\n+    private transient DurationField iWeeks;\n+    private transient DurationField iWeekyears;\n+    private transient DurationField iMonths;\n+    private transient DurationField iYears;\n+    private transient DurationField iCenturies;\n+    private transient DurationField iEras;\n+\n+    private transient DateTimeField iMillisOfSecond;\n+    private transient DateTimeField iMillisOfDay;\n+    private transient DateTimeField iSecondOfMinute;\n+    private transient DateTimeField iSecondOfDay;\n+    private transient DateTimeField iMinuteOfHour;\n+    private transient DateTimeField iMinuteOfDay;\n+    private transient DateTimeField iHourOfDay;\n+    private transient DateTimeField iClockhourOfDay;\n+    private transient DateTimeField iHourOfHalfday;\n+    private transient DateTimeField iClockhourOfHalfday;\n+    private transient DateTimeField iHalfdayOfDay;\n+\n+    private transient DateTimeField iDayOfWeek;\n+    private transient DateTimeField iDayOfMonth;\n+    private transient DateTimeField iDayOfYear;\n+    private transient DateTimeField iWeekOfWeekyear;\n+    private transient DateTimeField iWeekyear;\n+    private transient DateTimeField iMonthOfYear;\n+    private transient DateTimeField iYear;\n+    private transient DateTimeField iYearOfEra;\n+    private transient DateTimeField iYearOfCentury;\n+    private transient DateTimeField iCenturyOfEra;\n+    private transient DateTimeField iEra;\n+\n+    // Bit set determines which base fields are used\n+    // bit 1 set: hourOfDay, minuteOfHour, secondOfMinute, and millisOfSecond fields\n+    // bit 2 set: millisOfDayField\n+    // bit 3 set: year, monthOfYear, and dayOfMonth fields\n+    private transient int iBaseFlags;\n+\n+    /**\n+     * Constructor calls the assemble method, enabling subclasses to define its\n+     * supported fields. If a base chronology is supplied, the field set\n+     * initially contains references to each base chronlogy field.\n+     * <p>\n+     * Other methods in this class will delegate to the base chronology, if it\n+     * can be determined that the base chronology will produce the same results\n+     * as AbstractChronology.\n+     *\n+     * @param base optional base chronology to copy initial fields from\n+     * @param param optional param object avalable for assemble method\n+     */\n+    protected AssembledChronology(Chronology base, Object param) {\n+        iBase = base;\n+        iParam = param;\n+        setFields();\n+    }\n+\n+    public DateTimeZone getDateTimeZone() {\n+        Chronology base;\n+        if ((base = iBase) != null) {\n+            return base.getDateTimeZone();\n+        }\n+        return null;\n+    }\n+\n+    public long getDateOnlyMillis(long instant) {\n+        Chronology base;\n+        if ((base = iBase) != null) {\n+            return base.getDateOnlyMillis(instant);\n+        }\n+        return super.getDateOnlyMillis(instant);\n+    }\n+\n+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = iBase) != null && (iBaseFlags & 4) == 4) {\n+            // Only call specialized implementation if applicable fields are the same.\n+            return base.getDateOnlyMillis(year, monthOfYear, dayOfMonth);\n+        }\n+        return super.getDateOnlyMillis(year, monthOfYear, dayOfMonth);\n+    }\n+\n+    public long getTimeOnlyMillis(long instant) {\n+        Chronology base;\n+        if ((base = iBase) != null) {\n+            return base.getTimeOnlyMillis(instant);\n+        }\n+        return super.getTimeOnlyMillis(instant);\n+    }\n+\n+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = iBase) != null && (iBaseFlags & 1) == 1) {\n+            // Only call specialized implementation if applicable fields are the same.\n+            return base.getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        }\n+        return super.getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = iBase) != null && (iBaseFlags & 6) == 6) {\n+            // Only call specialized implementation if applicable fields are the same.\n+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n+        }\n+        return super.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n+    }\n+\n+    public long getDateTimeMillis(long instant,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = iBase) != null && (iBaseFlags & 1) == 1) {\n+            // Only call specialized implementation if applicable fields are the same.\n+            return base.getDateTimeMillis\n+                (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        }\n+        return super.getDateTimeMillis\n+            (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = iBase) != null && (iBaseFlags & 5) == 5) {\n+            // Only call specialized implementation if applicable fields are the same.\n+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n+                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        }\n+        return super.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n+                                       hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    public final DurationField millis() {\n+        return iMillis;\n+    }\n+\n+    public final DateTimeField millisOfSecond() {\n+        return iMillisOfSecond;\n+    }\n+\n+    public final DateTimeField millisOfDay() {\n+        return iMillisOfDay;\n+    }\n+\n+    public final DurationField seconds() {\n+        return iSeconds;\n+    }\n+\n+    public final DateTimeField secondOfMinute() {\n+        return iSecondOfMinute;\n+    }\n+\n+    public final DateTimeField secondOfDay() {\n+        return iSecondOfDay;\n+    }\n+\n+    public final DurationField minutes() {\n+        return iMinutes;\n+    }\n+\n+    public final DateTimeField minuteOfHour() {\n+        return iMinuteOfHour;\n+    }\n+\n+    public final DateTimeField minuteOfDay() {\n+        return iMinuteOfDay;\n+    }\n+\n+    public final DurationField hours() {\n+        return iHours;\n+    }\n+\n+    public final DateTimeField hourOfDay() {\n+        return iHourOfDay;\n+    }\n+\n+    public final DateTimeField clockhourOfDay() {\n+        return iClockhourOfDay;\n+    }\n+\n+    public final DateTimeField hourOfHalfday() {\n+        return iHourOfHalfday;\n+    }\n+\n+    public final DateTimeField clockhourOfHalfday() {\n+        return iClockhourOfHalfday;\n+    }\n+\n+    public final DateTimeField halfdayOfDay() {\n+        return iHalfdayOfDay;\n+    }\n+\n+    public final DurationField days() {\n+        return iDays;\n+    }\n+\n+    public final DateTimeField dayOfWeek() {\n+        return iDayOfWeek;\n+    }\n+\n+    public final DateTimeField dayOfMonth() {\n+        return iDayOfMonth;\n+    }\n+\n+    public final DateTimeField dayOfYear() {\n+        return iDayOfYear;\n+    }\n+\n+    public final DurationField weeks() {\n+        return iWeeks;\n+    }\n+\n+    public final DateTimeField weekOfWeekyear() {\n+        return iWeekOfWeekyear;\n+    }\n+\n+    public final DurationField weekyears() {\n+        return iWeekyears;\n+    }\n+\n+    public final DateTimeField weekyear() {\n+        return iWeekyear;\n+    }\n+\n+    public final DurationField months() {\n+        return iMonths;\n+    }\n+\n+    public final DateTimeField monthOfYear() {\n+        return iMonthOfYear;\n+    }\n+\n+    public final DurationField years() {\n+        return iYears;\n+    }\n+\n+    public final DateTimeField year() {\n+        return iYear;\n+    }\n+\n+    public final DateTimeField yearOfEra() {\n+        return iYearOfEra;\n+    }\n+\n+    public final DateTimeField yearOfCentury() {\n+        return iYearOfCentury;\n+    }\n+\n+    public final DurationField centuries() {\n+        return iCenturies;\n+    }\n+\n+    public final DateTimeField centuryOfEra() {\n+        return iCenturyOfEra;\n+    }\n+\n+    public final DurationField eras() {\n+        return iEras;\n+    }\n+\n+    public final DateTimeField era() {\n+        return iEra;\n+    }\n+\n+    /**\n+     * Invoked by the constructor and after deserialization to allow subclasses\n+     * to define all of its supported fields. All unset fields default to\n+     * unsupported instances.\n+     *\n+     * @param fields container of fields\n+     */\n+    protected abstract void assemble(Fields fields);\n+\n+    /**\n+     * Returns the same base chronology as passed into the constructor.\n+     */\n+    protected final Chronology getBase() {\n+        return iBase;\n+    }\n+\n+    /**\n+     * Returns the same param object as passed into the constructor.\n+     */\n+    protected final Object getParam() {\n+        return iParam;\n+    }\n+\n+    private void setFields() {\n+        Fields fields = new Fields();\n+        if (iBase != null) {\n+            fields.copyFieldsFrom(iBase);\n+        }\n+        assemble(fields);\n+\n+        {\n+            DurationField f;\n+            iMillis    = (f = fields.millis)    != null ? f : super.millis();\n+            iSeconds   = (f = fields.seconds)   != null ? f : super.seconds();\n+            iMinutes   = (f = fields.minutes)   != null ? f : super.minutes();\n+            iHours     = (f = fields.hours)     != null ? f : super.hours();\n+            iDays      = (f = fields.days)      != null ? f : super.days();\n+            iWeeks     = (f = fields.weeks)     != null ? f : super.weeks();\n+            iWeekyears = (f = fields.weekyears) != null ? f : super.weekyears();\n+            iMonths    = (f = fields.months)    != null ? f : super.months();\n+            iYears     = (f = fields.years)     != null ? f : super.years();\n+            iCenturies = (f = fields.centuries) != null ? f : super.centuries();\n+            iEras      = (f = fields.eras)      != null ? f : super.eras();\n+        }\n+\n+        {\n+            DateTimeField f;\n+            iMillisOfSecond     = (f = fields.millisOfSecond)     != null ? f : super.millisOfSecond();\n+            iMillisOfDay        = (f = fields.millisOfDay)        != null ? f : super.millisOfDay();\n+            iSecondOfMinute     = (f = fields.secondOfMinute)     != null ? f : super.secondOfMinute();\n+            iSecondOfDay        = (f = fields.secondOfDay)        != null ? f : super.secondOfDay();\n+            iMinuteOfHour       = (f = fields.minuteOfHour)       != null ? f : super.minuteOfHour();\n+            iMinuteOfDay        = (f = fields.minuteOfDay)        != null ? f : super.minuteOfDay();\n+            iHourOfDay          = (f = fields.hourOfDay)          != null ? f : super.hourOfDay();\n+            iClockhourOfDay     = (f = fields.clockhourOfDay)     != null ? f : super.clockhourOfDay();\n+            iHourOfHalfday      = (f = fields.hourOfHalfday)      != null ? f : super.hourOfHalfday();\n+            iClockhourOfHalfday = (f = fields.clockhourOfHalfday) != null ? f : super.clockhourOfHalfday();\n+            iHalfdayOfDay       = (f = fields.halfdayOfDay)       != null ? f : super.halfdayOfDay();\n+            iDayOfWeek          = (f = fields.dayOfWeek)          != null ? f : super.dayOfWeek();\n+            iDayOfMonth         = (f = fields.dayOfMonth)         != null ? f : super.dayOfMonth();\n+            iDayOfYear          = (f = fields.dayOfYear)          != null ? f : super.dayOfYear();\n+            iWeekOfWeekyear     = (f = fields.weekOfWeekyear)     != null ? f : super.weekOfWeekyear();\n+            iWeekyear           = (f = fields.weekyear)           != null ? f : super.weekyear();\n+            iMonthOfYear        = (f = fields.monthOfYear)        != null ? f : super.monthOfYear();\n+            iYear               = (f = fields.year)               != null ? f : super.year();\n+            iYearOfEra          = (f = fields.yearOfEra)          != null ? f : super.yearOfEra();\n+            iYearOfCentury      = (f = fields.yearOfCentury)      != null ? f : super.yearOfCentury();\n+            iCenturyOfEra       = (f = fields.centuryOfEra)       != null ? f : super.centuryOfEra();\n+            iEra                = (f = fields.era)                != null ? f : super.era();\n+        }\n+\n+        int flags;\n+        if (iBase == null) {\n+            flags = 0;\n+        } else {\n+            flags = \n+                ((iHourOfDay      == iBase.hourOfDay()      &&\n+                  iMinuteOfHour   == iBase.minuteOfHour()   &&\n+                  iSecondOfMinute == iBase.secondOfMinute() &&\n+                  iMillisOfSecond == iBase.millisOfSecond()   ) ? 1 : 0) |\n+\n+                ((iMillisOfDay == iBase.millisOfDay()) ? 2 : 0) |\n+\n+                ((iYear        == iBase.year()        &&\n+                  iMonthOfYear == iBase.monthOfYear() &&\n+                  iDayOfMonth  == iBase.dayOfMonth()    ) ? 4 : 0);\n+        }\n+\n+        iBaseFlags = flags;\n+    }\n+\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        setFields();\n+    }\n+\n+    public static final class Fields {\n+        public DurationField millis;\n+        public DurationField seconds;\n+        public DurationField minutes;\n+        public DurationField hours;\n+    \n+        public DurationField days;\n+        public DurationField weeks;\n+        public DurationField weekyears;\n+        public DurationField months;\n+        public DurationField years;\n+        public DurationField centuries;\n+        public DurationField eras;\n+    \n+        public DateTimeField millisOfSecond;\n+        public DateTimeField millisOfDay;\n+        public DateTimeField secondOfMinute;\n+        public DateTimeField secondOfDay;\n+        public DateTimeField minuteOfHour;\n+        public DateTimeField minuteOfDay;\n+        public DateTimeField hourOfDay;\n+        public DateTimeField clockhourOfDay;\n+        public DateTimeField hourOfHalfday;\n+        public DateTimeField clockhourOfHalfday;\n+        public DateTimeField halfdayOfDay;\n+    \n+        public DateTimeField dayOfWeek;\n+        public DateTimeField dayOfMonth;\n+        public DateTimeField dayOfYear;\n+        public DateTimeField weekOfWeekyear;\n+        public DateTimeField weekyear;\n+        public DateTimeField monthOfYear;\n+        public DateTimeField year;\n+        public DateTimeField yearOfEra;\n+        public DateTimeField yearOfCentury;\n+        public DateTimeField centuryOfEra;\n+        public DateTimeField era;\n+\n+        Fields() {\n+        }\n+\n+        /**\n+         * Copy the supported fields from a chronology into this container.\n+         */\n+        public void copyFieldsFrom(Chronology chrono) {\n+            {\n+                DurationField f;\n+                if (isSupported(f = chrono.millis())) {\n+                    millis = f;\n+                }\n+                if (isSupported(f = chrono.seconds())) {\n+                    seconds = f;\n+                }\n+                if (isSupported(f = chrono.minutes())) {\n+                    minutes = f;\n+                }\n+                if (isSupported(f = chrono.hours())) {\n+                    hours = f;\n+                }\n+                if (isSupported(f = chrono.days())) {\n+                    days = f;\n+                }\n+                if (isSupported(f = chrono.weeks())) {\n+                    weeks = f;\n+                }\n+                if (isSupported(f = chrono.weekyears())) {\n+                    weekyears = f;\n+                }\n+                if (isSupported(f = chrono.months())) {\n+                    months = f;\n+                }\n+                if (isSupported(f = chrono.years())) {\n+                    years = f;\n+                }\n+                if (isSupported(f = chrono.centuries())) {\n+                    centuries = f;\n+                }\n+                if (isSupported(f = chrono.eras())) {\n+                    eras = f;\n+                }\n+            }\n+\n+            {\n+                DateTimeField f;\n+                if (isSupported(f = chrono.millisOfSecond())) {\n+                    millisOfSecond = f;\n+                }\n+                if (isSupported(f = chrono.millisOfDay())) {\n+                    millisOfDay = f;\n+                }\n+                if (isSupported(f = chrono.secondOfMinute())) {\n+                    secondOfMinute = f;\n+                }\n+                if (isSupported(f = chrono.secondOfDay())) {\n+                    secondOfDay = f;\n+                }\n+                if (isSupported(f = chrono.minuteOfHour())) {\n+                    minuteOfHour = f;\n+                }\n+                if (isSupported(f = chrono.minuteOfDay())) {\n+                    minuteOfDay = f;\n+                }\n+                if (isSupported(f = chrono.hourOfDay())) {\n+                    hourOfDay = f;\n+                }\n+                if (isSupported(f = chrono.clockhourOfDay())) {\n+                    clockhourOfDay = f;\n+                }\n+                if (isSupported(f = chrono.hourOfHalfday())) {\n+                    hourOfHalfday = f;\n+                }\n+                if (isSupported(f = chrono.clockhourOfHalfday())) {\n+                    clockhourOfHalfday = f;\n+                }\n+                if (isSupported(f = chrono.halfdayOfDay())) {\n+                    halfdayOfDay = f;\n+                }\n+                if (isSupported(f = chrono.dayOfWeek())) {\n+                    dayOfWeek = f;\n+                }\n+                if (isSupported(f = chrono.dayOfMonth())) {\n+                    dayOfMonth = f;\n+                }\n+                if (isSupported(f = chrono.dayOfYear())) {\n+                    dayOfYear = f;\n+                }\n+                if (isSupported(f = chrono.weekOfWeekyear())) {\n+                    weekOfWeekyear = f;\n+                }\n+                if (isSupported(f = chrono.weekyear())) {\n+                    weekyear = f;\n+                }\n+                if (isSupported(f = chrono.monthOfYear())) {\n+                    monthOfYear = f;\n+                }\n+                if (isSupported(f = chrono.year())) {\n+                    year = f;\n+                }\n+                if (isSupported(f = chrono.yearOfEra())) {\n+                    yearOfEra = f;\n+                }\n+                if (isSupported(f = chrono.yearOfCentury())) {\n+                    yearOfCentury = f;\n+                }\n+                if (isSupported(f = chrono.centuryOfEra())) {\n+                    centuryOfEra = f;\n+                }\n+                if (isSupported(f = chrono.era())) {\n+                    era = f;\n+                }\n+            }\n+        }\n+\n+        private static boolean isSupported(DurationField field) {\n+            return field == null ? false : field.isSupported();\n+        }\n+\n+        private static boolean isSupported(DateTimeField field) {\n+            return field == null ? false : field.isSupported();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.DividedDateTimeField;\n+import org.joda.time.field.OffsetDateTimeField;\n+import org.joda.time.field.RemainderDateTimeField;\n+\n+/**\n+ * <code>BuddhistChronology</code> provides access to the individual date\n+ * time fields for the Buddhist chronological calendar system.\n+ * <p>\n+ * The Buddhist calendar differs from the GregorianJulian calendar only \n+ * in the year. This class is compatable with the BuddhistCalendar class \n+ * supplied by Sun.\n+ * <p>\n+ * BuddhistChronology is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class BuddhistChronology extends AssembledChronology {\n+    \n+    static final long serialVersionUID = -3474595157769370126L;\n+\n+    /**\n+     * Constant value for 'Buddhist Era', equivalent to the value returned\n+     * for AD/CE.\n+     */\n+    public static final int BE = DateTimeConstants.CE;\n+\n+    /** Number of years difference in calendars. */\n+    private static final int BUDDHIST_OFFSET = 543;\n+\n+    /** Cache of zone to chronology */\n+    private static final Map cCache = new HashMap();\n+\n+    /** UTC instance of the chronology */\n+    private static final BuddhistChronology INSTANCE_UTC = getInstance(DateTimeZone.UTC);\n+\n+    /**\n+     * Standard instance of a Buddhist Chronology, that matches\n+     * Sun's BuddhistCalendar class. This means that it follows the\n+     * GregorianJulian calendar rules with a cutover date.\n+     * <p>\n+     * The time zone of the returned instance is UTC.\n+     */\n+    public static BuddhistChronology getInstanceUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Standard instance of a Buddhist Chronology, that matches\n+     * Sun's BuddhistCalendar class. This means that it follows the\n+     * GregorianJulian calendar rules with a cutover date.\n+     */\n+    public static BuddhistChronology getInstance() {\n+        return getInstance(DateTimeZone.getDefault());\n+    }\n+\n+    /**\n+     * Standard instance of a Buddhist Chronology, that matches\n+     * Sun's BuddhistCalendar class. This means that it follows the\n+     * GregorianJulian calendar rules with a cutover date.\n+     *\n+     * @param zone  the time zone to use, null is default\n+     */\n+    public static synchronized BuddhistChronology getInstance(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        BuddhistChronology chrono = (BuddhistChronology) cCache.get(zone);\n+        if (chrono == null) {\n+            // First create without a lower limit.\n+            chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null);\n+            // Impose lower limit and make another BuddhistChronology.\n+            DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n+            chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), \"\");\n+            cCache.put(zone, chrono);\n+        }\n+        return chrono;\n+    }\n+\n+    // Constructors and instance variables\n+    //-----------------------------------------------------------------------\n+    \n+    /**\n+     * Restricted constructor.\n+     *\n+     * @param param if non-null, then don't change the field set\n+     */\n+    private BuddhistChronology(Chronology base, Object param) {\n+        super(base, param);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return getInstance(getBase().getDateTimeZone());\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the Chronology in the UTC time zone.\n+     * \n+     * @return the chronology in UTC\n+     */\n+    public Chronology withUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets the Chronology in a specific time zone.\n+     * \n+     * @param zone  the zone to get the chronology in, null is default\n+     * @return the chronology\n+     */\n+    public Chronology withDateTimeZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getDateTimeZone()) {\n+            return this;\n+        }\n+        return getInstance(zone);\n+    }\n+\n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging toString.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        String str = \"BuddhistChronology\";\n+        DateTimeZone zone = getDateTimeZone();\n+        if (zone != null) {\n+            str = str + '[' + zone.getID() + ']';\n+        }\n+        return str;\n+    }\n+\n+    protected void assemble(Fields fields) {\n+        if (getParam() == null) {\n+            DateTimeField field = fields.year;\n+            fields.year = new OffsetDateTimeField(field, field.getName(), BUDDHIST_OFFSET);\n+            fields.yearOfEra = fields.year;\n+            \n+            field = fields.weekyear;\n+            fields.weekyear = new OffsetDateTimeField(field, field.getName(), BUDDHIST_OFFSET);\n+            \n+            field = new OffsetDateTimeField(fields.yearOfEra, \"\", 99);\n+            fields.centuryOfEra = new DividedDateTimeField(field, \"centuryOfEra\", \"centuries\", 100);\n+            \n+            field = new RemainderDateTimeField\n+                ((DividedDateTimeField)fields.centuryOfEra, \"\");\n+            fields.yearOfCentury = new OffsetDateTimeField(field, \"yearOfCentury\", 1);\n+            \n+            fields.era = BuddhistEraDateTimeField.INSTANCE;\n+        }\n+    }\n+   \n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.AbstractDateTimeField;\n+import org.joda.time.field.UnsupportedDurationField;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * Provides time calculations for the buddhist era component of time.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+final class BuddhistEraDateTimeField extends AbstractDateTimeField {\n+    \n+    static final long serialVersionUID = -9175876774456816364L;\n+\n+    /**\n+     * Singleton instance\n+     */\n+    static final DateTimeField INSTANCE = new BuddhistEraDateTimeField();\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    private BuddhistEraDateTimeField() {\n+        super(\"era\");\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    /**\n+     * Get the Era component of the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to query.\n+     * @return the era extracted from the input.\n+     */\n+    public int get(long instant) {\n+        return BuddhistChronology.BE;\n+    }\n+\n+    /**\n+     * Set the Era component of the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param era  the era (BuddhistChronology.BE) to update the time to.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException  if era is invalid.\n+     */\n+    public long set(long instant, int era) {\n+        FieldUtils.verifyValueBounds(this, era, getMinimumValue(), getMaximumValue());\n+\n+        return instant;\n+    }\n+\n+    /**\n+     * @see org.joda.time.DateTimeField#set(long, String, Locale)\n+     */\n+    public long set(long instant, String text, Locale locale) {\n+        if (\"BE\".equals(text) == false) {\n+            throw new IllegalArgumentException(\"Invalid era text: \" + text);\n+        }\n+        return instant;\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return Long.MIN_VALUE;\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        return Long.MAX_VALUE;\n+    }\n+\n+    public long roundHalfFloor(long instant) {\n+        return Long.MIN_VALUE;\n+    }\n+\n+    public long roundHalfCeiling(long instant) {\n+        return Long.MIN_VALUE;\n+    }\n+\n+    public long roundHalfEven(long instant) {\n+        return Long.MIN_VALUE;\n+    }\n+\n+    public DurationField getDurationField() {\n+        return UnsupportedDurationField.INSTANCE;\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    public int getMinimumValue() {\n+        return BuddhistChronology.BE;\n+    }\n+\n+    public int getMaximumValue() {\n+        return BuddhistChronology.BE;\n+    }\n+    \n+    /**\n+     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)\n+     */\n+    public String getAsShortText(long instant, Locale locale) {\n+        return \"BE\";\n+    }\n+    \n+    /**\n+     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return 2;\n+    }\n+\n+    /**\n+     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)\n+     */\n+    public String getAsText(long instant, Locale locale) {\n+        return \"BE\";\n+    }\n+\n+    /**\n+     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        return 2;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.PreciseDurationField;\n+\n+/**\n+ * \n+ *\n+ * @author Brian S O'Neill\n+ */\n+public final class CopticChronology extends AbstractGJChronology {\n+\n+    static final long serialVersionUID = -5972804258688333942L;\n+\n+    /**\n+     * Constant value for 'Anno Martyrum' or 'Era of the Martyrs', equivalent\n+     * to the value returned for AD/CE.\n+     */\n+    public static final int AM = DateTimeConstants.CE;\n+\n+    private static final long MILLIS_PER_YEAR =\n+        (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY);\n+\n+    private static final long MILLIS_PER_MONTH =\n+        (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY / 12);\n+\n+    private static final DurationField cMonthsField;\n+\n+    /** Singleton instance of a UTC CopticChronology */\n+    private static final CopticChronology INSTANCE_UTC;\n+\n+    /** Cache of zone to chronology arrays */\n+    private static final Map cCache = new HashMap();\n+\n+    static {\n+        cMonthsField =  new PreciseDurationField\n+            (\"months\", 30L * DateTimeConstants.MILLIS_PER_DAY);\n+        INSTANCE_UTC = getInstance(DateTimeZone.UTC);\n+    }\n+\n+    /**\n+     * Gets an instance of the CopticChronology.\n+     * The time zone of the returned instance is UTC.\n+     * \n+     * @return a singleton UTC instance of the chronology\n+     */\n+    public static CopticChronology getInstanceUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets an instance of the CopticChronology in the default time zone.\n+     * \n+     * @return a chronology in the default time zone\n+     */\n+    public static CopticChronology getInstance() {\n+        return getInstance(DateTimeZone.getDefault(), 4);\n+    }\n+\n+    /**\n+     * Gets an instance of the CopticChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @return a chronology in the specified time zone\n+     */\n+    public static CopticChronology getInstance(DateTimeZone zone) {\n+        return getInstance(zone, 4);\n+    }\n+\n+    /**\n+     * Gets an instance of the CopticChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n+     * @return a chronology in the specified time zone\n+     */\n+    public static CopticChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        CopticChronology chrono;\n+        synchronized (cCache) {\n+            CopticChronology[] chronos = (CopticChronology[]) cCache.get(zone);\n+            if (chronos == null) {\n+                chronos = new CopticChronology[7];\n+                cCache.put(zone, chronos);\n+            }\n+            try {\n+                chrono = chronos[minDaysInFirstWeek - 1];\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                throw new IllegalArgumentException\n+                    (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n+            }\n+            if (chrono == null) {\n+                if (zone == DateTimeZone.UTC) {\n+                    // First create without a lower limit.\n+                    chrono = new CopticChronology(null, null, minDaysInFirstWeek);\n+                    // Impose lower limit and make another CopticChronology.\n+                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n+                    chrono = new CopticChronology\n+                        (LimitChronology.getInstance(chrono, lowerLimit, null),\n+                         null, minDaysInFirstWeek);\n+                } else {\n+                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n+                    chrono = new CopticChronology\n+                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n+                }\n+                chronos[minDaysInFirstWeek - 1] = chrono;\n+            }\n+        }\n+        return chrono;\n+    }\n+\n+    // Constructors and instance variables\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    CopticChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n+        super(base, param, minDaysInFirstWeek);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return getInstance(getBase().getDateTimeZone());\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the Chronology in the UTC time zone.\n+     * \n+     * @return the chronology in UTC\n+     */\n+    public Chronology withUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets the Chronology in a specific time zone.\n+     * \n+     * @param zone  the zone to get the chronology in, null is default\n+     * @return the chronology\n+     */\n+    public Chronology withDateTimeZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getDateTimeZone()) {\n+            return this;\n+        }\n+        return getInstance(zone);\n+    }\n+\n+    boolean isLeapYear(int year) {\n+        return (year & 3) == 3;\n+    }\n+\n+    long calculateFirstDayOfYearMillis(int year) {\n+        // Java epoch is 1970-01-01 Gregorian which is 1686-04-23 Coptic.\n+        // Calculate relative to the nearest leap year and account for the\n+        // difference later.\n+\n+        int relativeYear = year - 1687;\n+        int leapYears;\n+        if (relativeYear <= 0) {\n+            // Add 3 before shifting right since /4 and >>2 behave differently\n+            // on negative numbers.\n+            leapYears = (relativeYear + 3) >> 2;\n+        } else {\n+            leapYears = relativeYear >> 2;\n+            // For post 1687 an adjustment is needed as jan1st is before leap day\n+            if (!isLeapYear(year)) {\n+                leapYears++;\n+            }\n+        }\n+        \n+        long millis = (relativeYear * 365L + leapYears)\n+            * (long)DateTimeConstants.MILLIS_PER_DAY;\n+\n+        // Adjust to account for difference between 1687-01-01 and 1686-04-23.\n+\n+        return millis + (365L - 112) * DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    int getMinYear() {\n+        // The lowest year that can be fully supported.\n+        return 1;\n+    }\n+\n+    int getMaxYear() {\n+        // The highest year that can be fully supported.\n+        // TODO\n+        return 292272992;\n+    }\n+\n+    long getAverageMillisPerYear() {\n+        return MILLIS_PER_YEAR;\n+    }\n+\n+    long getAverageMillisPerMonth() {\n+        return MILLIS_PER_MONTH;\n+    }\n+\n+    long getApproxMillisAtEpoch() {\n+        return 1686L * MILLIS_PER_YEAR + 112L * DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    protected void assemble(Fields fields) {\n+        if (getBase() == null) {\n+            super.assemble(fields);\n+            // Coptic, like Julian, has no year zero.\n+            fields.year = new JulianChronology.NoYearZeroField(this, fields.year);\n+            fields.weekyear = new JulianChronology.NoWeekyearZeroField(this, fields.weekyear);\n+            \n+            fields.era = CopticEraDateTimeField.INSTANCE;\n+            fields.months = cMonthsField;\n+            fields.monthOfYear = new CopticMonthOfYearDateTimeField(this, cMonthsField);\n+            fields.dayOfMonth = new CopticDayOfMonthDateTimeField(this, fields.days);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DurationField;\n+import org.joda.time.field.PreciseDurationDateTimeField;\n+\n+/**\n+ * Provides time calculations for the day of the month component of time.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+final class CopticDayOfMonthDateTimeField extends PreciseDurationDateTimeField {\n+\n+    static final long serialVersionUID = -5441610762799659434L;\n+\n+    private final AbstractGJChronology iChronology;\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    CopticDayOfMonthDateTimeField(AbstractGJChronology chronology, DurationField days) {\n+        super(\"dayOfMonth\", days);\n+        iChronology = chronology;\n+    }\n+\n+    public int get(long instant) {\n+        return (iChronology.getDayOfYear(instant) - 1) % 30 + 1;\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.months();\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 30;\n+    }\n+\n+    public int getMaximumValue(long instant) {\n+\t\tif (((iChronology.getDayOfYear(instant) - 1) / 30) < 12) {\n+\t\t\treturn 30;\n+\t\t}\n+\t\treturn iChronology.isLeapYear(iChronology.getYear(instant)) ? 6 : 5;\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.dayOfMonth();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.AbstractDateTimeField;\n+import org.joda.time.field.UnsupportedDurationField;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * Provides time calculations for the coptic era component of time.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+final class CopticEraDateTimeField extends AbstractDateTimeField {\n+    \n+    static final long serialVersionUID = 4090856468123006167L;\n+\n+    /**\n+     * Singleton instance\n+     */\n+    static final DateTimeField INSTANCE = new CopticEraDateTimeField();\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    private CopticEraDateTimeField() {\n+        super(\"era\");\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    /**\n+     * Get the Era component of the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to query.\n+     * @return the era extracted from the input.\n+     */\n+    public int get(long instant) {\n+        return CopticChronology.AM;\n+    }\n+\n+    /**\n+     * Set the Era component of the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param era  the era (CopticChronology.AM) to update the time to.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException  if era is invalid.\n+     */\n+    public long set(long instant, int era) {\n+        FieldUtils.verifyValueBounds(this, era, getMinimumValue(), getMaximumValue());\n+\n+        return instant;\n+    }\n+\n+    /**\n+     * @see org.joda.time.DateTimeField#set(long, String, Locale)\n+     */\n+    public long set(long instant, String text, Locale locale) {\n+        if (\"AM\".equals(text) == false) {\n+            throw new IllegalArgumentException(\"Invalid era text: \" + text);\n+        }\n+        return instant;\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return Long.MIN_VALUE;\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        return Long.MAX_VALUE;\n+    }\n+\n+    public long roundHalfFloor(long instant) {\n+        return Long.MIN_VALUE;\n+    }\n+\n+    public long roundHalfCeiling(long instant) {\n+        return Long.MIN_VALUE;\n+    }\n+\n+    public long roundHalfEven(long instant) {\n+        return Long.MIN_VALUE;\n+    }\n+\n+    public DurationField getDurationField() {\n+        return UnsupportedDurationField.INSTANCE;\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    public int getMinimumValue() {\n+        return CopticChronology.AM;\n+    }\n+\n+    public int getMaximumValue() {\n+        return CopticChronology.AM;\n+    }\n+    \n+    /**\n+     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)\n+     */\n+    public String getAsShortText(long instant, Locale locale) {\n+        return \"AM\";\n+    }\n+    \n+    /**\n+     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return 2;\n+    }\n+\n+    /**\n+     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)\n+     */\n+    public String getAsText(long instant, Locale locale) {\n+        return \"AM\";\n+    }\n+\n+    /**\n+     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        return 2;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticMonthOfYearDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DurationField;\n+import org.joda.time.field.PreciseDurationDateTimeField;\n+\n+/**\n+ * \n+ *\n+ * @author Brian S O'Neill\n+ */\n+final class CopticMonthOfYearDateTimeField extends PreciseDurationDateTimeField {\n+\n+    static final long serialVersionUID = 7741038885247700323L;\n+\n+    private final AbstractGJChronology iChronology;\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    CopticMonthOfYearDateTimeField(AbstractGJChronology chronology, DurationField months) {\n+        super(\"monthOfYear\", months);\n+        iChronology = chronology;\n+    }\n+\n+    public int get(long instant) {\n+        return (iChronology.getDayOfYear(instant) - 1) / 30 + 1;\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.years();\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return get(instant) > 12 && iChronology.isLeapYear(iChronology.getYear(instant));\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        return isLeap(instant) ? 1 : 0;\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return iChronology.days();\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 13;\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.monthOfYear();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+// Import for @link support\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n+import org.joda.time.Instant;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.field.AbstractDateTimeField;\n+import org.joda.time.field.DecoratedDurationField;\n+import org.joda.time.format.DateTimePrinter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * GJChronology provides access to the individual date time fields for the\n+ * Gregorian/Julian defined chronological calendar system.\n+ * <p>\n+ * The Gregorian calendar replaced the Julian calendar, and the point in time\n+ * when this chronology switches can be controlled using the second parameter\n+ * of the getInstance method. By default this cutover is set to the date the\n+ * Gregorian calendar was first instituted, October 15, 1582.\n+ * <p>\n+ * Before this date, this chronology uses the proleptic Julian calendar\n+ * (proleptic means extending indefinitely). The Julian calendar has leap \n+ * years every four years, whereas the Gregorian has special rules for 100 \n+ * and 400 years. A meaningful result will thus be obtained for all input \n+ * values. However before March 1, 4 CE, Julian leap years were irregular,\n+ * and before 45 BCE there was no Julian calendar.\n+ * <p>\n+ * This chronology differs from {@link java.util.GregorianCalendar\n+ * java.util.GregorianCalendar} in that years in BCE are returned\n+ * correctly. Thus year 1 BCE is returned as -1 instead of 1. The yearOfEra\n+ * field produces results compatible with GregorianCalendar.\n+ * <p>\n+ * The Julian calendar does not have a year zero, and so year -1 is followed by\n+ * year 1. If the Gregorian cutover date is specified at or before year -1\n+ * (Julian), year zero is defined. In other words, the proleptic Gregorian\n+ * chronology implemented by this class has a year zero.\n+ * <p>\n+ * To create a pure proleptic Julian chronology, use {@link JulianChronology},\n+ * and to create a pure proleptic Gregorian chronology, use\n+ * {@link GregorianChronology}.\n+ * <p>\n+ * GJChronology is thread-safe and immutable.\n+ * \n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public final class GJChronology extends AssembledChronology {\n+\n+    static final long serialVersionUID = -2545574827706931671L;\n+\n+    /**\n+     * Convert a datetime from one chronology to another.\n+     */\n+    private static long convertByYear(long instant, Chronology from, Chronology to) {\n+        return to.getDateTimeMillis\n+            (from.year().get(instant),\n+             from.monthOfYear().get(instant),\n+             from.dayOfMonth().get(instant),\n+             from.millisOfDay().get(instant));\n+    }\n+\n+    /**\n+     * Convert a datetime from one chronology to another.\n+     */\n+    private static long convertByWeekyear(final long instant, Chronology from, Chronology to) {\n+        long newInstant;\n+        newInstant = to.weekyear().set(0, from.weekyear().get(instant));\n+        newInstant = to.weekOfWeekyear().set(newInstant, from.weekOfWeekyear().get(instant));\n+        newInstant = to.dayOfWeek().set(newInstant, from.dayOfWeek().get(instant));\n+        newInstant = to.millisOfDay().set(newInstant, from.millisOfDay().get(instant));\n+        return newInstant;\n+    }\n+\n+    /**\n+     * The default GregorianJulian cutover point\n+     */\n+    static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L);\n+\n+    /** Cache of zone to chronology list */\n+    private static final Map cCache = new HashMap();\n+\n+    /**\n+     * Factory method returns instances of the default GJ cutover\n+     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)\n+     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by\n+     * October 15, 1582 (Gregorian).\n+     *\n+     * <p>The first day of the week is designated to be\n+     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the\n+     * first week of the year is 4.\n+     *\n+     * <p>The time zone of the returned instance is UTC.\n+     */\n+    public static GJChronology getInstanceUTC() {\n+        return getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n+    }\n+\n+    /**\n+     * Factory method returns instances of the default GJ cutover\n+     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)\n+     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by\n+     * October 15, 1582 (Gregorian).\n+     *\n+     * <p>The first day of the week is designated to be\n+     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the\n+     * first week of the year is 4.\n+     *\n+     * <p>The returned chronology is in the default time zone.\n+     */\n+    public static GJChronology getInstance() {\n+        return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, 4);\n+    }\n+\n+    /**\n+     * Factory method returns instances of the GJ cutover chronology. This uses\n+     * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this\n+     * value, October 4, 1582 (Julian) is followed by October 15, 1582\n+     * (Gregorian).\n+     *\n+     * <p>The first day of the week is designated to be\n+     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the\n+     * first week of the year is 4.\n+     *\n+     * @param zone  the time zone to use, null is default\n+     */\n+    public static GJChronology getInstance(DateTimeZone zone) {\n+        return getInstance(zone, DEFAULT_CUTOVER, 4);\n+    }\n+\n+    /**\n+     * Factory method returns instances of the GJ cutover chronology. Any\n+     * cutover date may be specified.\n+     *\n+     * <p>The first day of the week is designated to be\n+     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the\n+     * first week of the year is 4.\n+     *\n+     * @param zone  the time zone to use, null is default\n+     * @param gregorianCutover  the cutover to use, null means default\n+     */\n+    public static GJChronology getInstance(DateTimeZone zone,\n+                                           ReadableInstant gregorianCutover) \n+    {\n+        return getInstance(zone, gregorianCutover, 4);\n+    }\n+    \n+    /**\n+     * Factory method returns instances of the GJ cutover chronology. Any\n+     * cutover date may be specified.\n+     *\n+     * @param zone  the time zone to use, null is default\n+     * @param gregorianCutover  the cutover to use, null means default\n+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n+     */\n+    public static synchronized GJChronology getInstance(DateTimeZone zone,\n+                                                        ReadableInstant gregorianCutover,\n+                                                        int minDaysInFirstWeek)\n+    {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        Instant cutoverInstant;\n+        if (gregorianCutover == null) {\n+            cutoverInstant = DEFAULT_CUTOVER;\n+        } else {\n+            cutoverInstant = gregorianCutover.toInstant();\n+        }\n+\n+        GJChronology chrono;\n+\n+        ArrayList chronos = (ArrayList)cCache.get(zone);\n+        if (chronos == null) {\n+            chronos = new ArrayList(2);\n+            cCache.put(zone, chronos);\n+        } else {\n+            for (int i=chronos.size(); --i>=0; ) {\n+                chrono = (GJChronology)chronos.get(i);\n+                if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\n+                    cutoverInstant.equals(chrono.getGregorianCutover())) {\n+                    \n+                    return chrono;\n+                }\n+            }\n+        }\n+\n+        if (zone == DateTimeZone.UTC) {\n+            chrono = new GJChronology\n+                (JulianChronology.getInstance(zone, minDaysInFirstWeek),\n+                 GregorianChronology.getInstance(zone, minDaysInFirstWeek),\n+                 cutoverInstant);\n+        } else {\n+            chrono = getInstance(DateTimeZone.UTC, gregorianCutover, minDaysInFirstWeek);\n+            chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone));\n+        }\n+\n+        chronos.add(chrono);\n+\n+        return chrono;\n+    }\n+\n+    /**\n+     * Factory method returns instances of the GJ cutover chronology. Any\n+     * cutover date may be specified.\n+     *\n+     * @param zone  the time zone to use, null is default\n+     * @param gregorianCutover  the cutover to use\n+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n+     */\n+    public static synchronized GJChronology getInstance(DateTimeZone zone,\n+                                                        long gregorianCutover,\n+                                                        int minDaysInFirstWeek)\n+    {\n+        Instant cutoverInstant;\n+        if (gregorianCutover == DEFAULT_CUTOVER.getMillis()) {\n+            cutoverInstant = null;\n+        } else {\n+            cutoverInstant = new Instant(gregorianCutover);\n+        }\n+        return getInstance(zone, cutoverInstant, minDaysInFirstWeek);\n+    }\n+\n+    private JulianChronology iJulianChronology;\n+    private GregorianChronology iGregorianChronology;\n+    private Instant iCutoverInstant;\n+\n+    long iCutoverMillis;\n+    long iGapDuration;\n+\n+    /**\n+     * @param julian chronology used before the cutover instant\n+     * @param gregorian chronology used at and after the cutover instant\n+     * @param cutoverInstant instant when the gregorian chronology began\n+     */\n+    private GJChronology(JulianChronology julian,\n+                         GregorianChronology gregorian,\n+                         Instant cutoverInstant) {\n+        super(null, new Object[] {julian, gregorian, cutoverInstant});\n+    }\n+\n+    /**\n+     * Called when applying a time zone.\n+     */\n+    private GJChronology(Chronology base) {\n+        super(base, null);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return getInstance(getDateTimeZone(), iCutoverInstant, getMinimumDaysInFirstWeek());\n+    }\n+\n+    public DateTimeZone getDateTimeZone() {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getDateTimeZone();\n+        }\n+        return DateTimeZone.UTC;\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the Chronology in the UTC time zone.\n+     * \n+     * @return the chronology in UTC\n+     */\n+    public Chronology withUTC() {\n+        return withDateTimeZone(DateTimeZone.UTC);\n+    }\n+\n+    /**\n+     * Gets the Chronology in a specific time zone.\n+     * \n+     * @param zone  the zone to get the chronology in, null is default\n+     * @return the chronology\n+     */\n+    public Chronology withDateTimeZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getDateTimeZone()) {\n+            return this;\n+        }\n+        return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());\n+    }\n+\n+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getDateOnlyMillis(year, monthOfYear, dayOfMonth);\n+        }\n+\n+        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n+    }\n+\n+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        }\n+\n+        // Time fields are same for Julian and Gregorian.\n+        return iGregorianChronology.getTimeOnlyMillis\n+            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n+        }\n+\n+        // Assume date is Gregorian.\n+        long instant = iGregorianChronology.getDateTimeMillis\n+            (year, monthOfYear, dayOfMonth, millisOfDay);\n+        if (instant < iCutoverMillis) {\n+            // Maybe it's Julian.\n+            instant = iJulianChronology.getDateTimeMillis\n+                (year, monthOfYear, dayOfMonth, millisOfDay);\n+            if (instant >= iCutoverMillis) {\n+                // Okay, it's in the illegal cutover gap.\n+                throw new IllegalArgumentException(\"Specified date does not exist\");\n+            }\n+        }\n+        return instant;\n+    }\n+\n+    public long getDateTimeMillis(long instant,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getDateTimeMillis\n+                (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        }\n+\n+        return getDateOnlyMillis(instant)\n+            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getDateTimeMillis\n+                (year, monthOfYear, dayOfMonth,\n+                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        }\n+\n+        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0)\n+            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    /**\n+     * Gets the cutover instant between Gregorian and Julian chronologies.\n+     * @return the cutover instant\n+     */\n+    public Instant getGregorianCutover() {\n+        Instant cutover = iCutoverInstant;\n+        if (cutover == null) {\n+            iCutoverInstant = cutover = new Instant(iCutoverMillis);\n+        }\n+        return cutover;\n+    }\n+\n+    public final int getMinimumDaysInFirstWeek() {\n+        return iGregorianChronology.getMinimumDaysInFirstWeek();\n+    }\n+\n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging toString.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        StringBuffer sb = new StringBuffer(60);\n+        sb.append(\"GJCutoverChronology\");\n+        sb.append('[');\n+        sb.append(getDateTimeZone().getID());\n+        sb.append(\", \");\n+\n+        sb.append(\"cutover=\");\n+        ISODateTimeFormat format = ISODateTimeFormat.getInstance(withUTC());\n+        DateTimePrinter printer;\n+        if (withUTC().getTimeOnlyMillis(iCutoverMillis) == 0) {\n+            printer = format.date();\n+        } else {\n+            printer = format.dateTime();\n+        }\n+        printer.printTo(sb, iCutoverMillis);\n+\n+        sb.append(\", mdfw=\");\n+        sb.append(getMinimumDaysInFirstWeek());\n+        sb.append(']');\n+\n+        return sb.toString();\n+    }\n+\n+    protected void assemble(Fields fields) {\n+        if (getBase() != null) {\n+            return;\n+        }\n+\n+        Object[] params = (Object[])getParam();\n+\n+        JulianChronology julian = (JulianChronology)params[0];\n+        GregorianChronology gregorian = (GregorianChronology)params[1];\n+        Instant cutoverInstant = (Instant)params[2];\n+        iCutoverMillis = cutoverInstant.getMillis();\n+\n+        if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        iJulianChronology = julian;\n+        iGregorianChronology = gregorian;\n+        iCutoverInstant = cutoverInstant;\n+\n+        // Compute difference between the chronologies at the cutover instant\n+        iGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);\n+\n+        // Begin field definitions.\n+\n+        // First just copy all the Gregorian fields and then override those\n+        // that need special attention.\n+        fields.copyFieldsFrom(gregorian);\n+        \n+        // Assuming cutover is at midnight, all time of day fields can be\n+        // gregorian since they are unaffected by cutover.\n+\n+        // Verify assumption.\n+        if (gregorian.millisOfDay().get(iCutoverMillis) == 0) {\n+            // Cutover is sometime in the day, so cutover fields are required\n+            // for time of day.\n+\n+            fields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond);\n+            fields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay);\n+            fields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute);\n+            fields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay);\n+            fields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour);\n+            fields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay);\n+            fields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay);\n+            fields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday);\n+            fields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay);\n+            fields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),\n+                                                         fields.clockhourOfHalfday);\n+            fields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay);\n+        }\n+\n+        // These fields just require basic cutover support.\n+        {\n+            fields.era = new CutoverField(julian.era(), fields.era);\n+            fields.dayOfMonth = new CutoverField(julian.dayOfMonth(), fields.dayOfMonth);\n+        }\n+\n+        // DayOfYear and weekOfWeekyear require special handling since cutover\n+        // year has fewer days and weeks. Extend the cutover to the start of\n+        // the next year or weekyear. This keeps the sequence unbroken during\n+        // the cutover year.\n+\n+        {\n+            long cutover = gregorian.year().roundCeiling(iCutoverMillis);\n+            fields.dayOfYear = new CutoverField\n+                (julian.dayOfYear(), fields.dayOfYear, cutover);\n+        }\n+\n+        {\n+            long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);\n+            fields.weekOfWeekyear = new CutoverField\n+                (julian.weekOfWeekyear(), fields.weekOfWeekyear, cutover, true);\n+        }\n+\n+        // These fields are special because they have imprecise durations. The\n+        // family of addition methods need special attention. Override affected\n+        // duration fields as well.\n+        {\n+            fields.year = new ImpreciseCutoverField(julian.year(), fields.year);\n+            fields.years = fields.year.getDurationField();\n+            fields.yearOfEra = new ImpreciseCutoverField\n+                (julian.yearOfEra(), fields.yearOfEra, fields.years);\n+            fields.yearOfCentury = new ImpreciseCutoverField\n+                (julian.yearOfCentury(), fields.yearOfCentury, fields.years);\n+            \n+            fields.centuryOfEra = new ImpreciseCutoverField\n+                (julian.centuryOfEra(), fields.centuryOfEra);\n+            fields.centuries = fields.centuryOfEra.getDurationField();\n+            \n+            fields.monthOfYear = new ImpreciseCutoverField\n+                (julian.monthOfYear(), fields.monthOfYear);\n+            fields.months = fields.monthOfYear.getDurationField();\n+            \n+            fields.weekyear = new ImpreciseCutoverField(julian.weekyear(), fields.weekyear, true);\n+            fields.weekyears = fields.weekyear.getDurationField();\n+        }\n+    }\n+\n+    long julianToGregorianByYear(long instant) {\n+        return convertByYear(instant, iJulianChronology, iGregorianChronology);\n+    }\n+\n+    long gregorianToJulianByYear(long instant) {\n+        return convertByYear(instant, iGregorianChronology, iJulianChronology);\n+    }\n+\n+    long julianToGregorianByWeekyear(long instant) {\n+        return convertByWeekyear(instant, iJulianChronology, iGregorianChronology);\n+    }\n+\n+    long gregorianToJulianByWeekyear(long instant) {\n+        return convertByWeekyear(instant, iGregorianChronology, iJulianChronology);\n+    }\n+\n+    /**\n+     * This basic cutover field adjusts calls to 'get' and 'set' methods, and\n+     * assumes that calls to add and addWrapped are unaffected by the cutover.\n+     */\n+    private class CutoverField extends AbstractDateTimeField {\n+        static final long serialVersionUID = 3528501219481026402L;\n+\n+        final DateTimeField iJulianField;\n+        final DateTimeField iGregorianField;\n+        final long iCutover;\n+        final boolean iConvertByWeekyear;\n+\n+        protected DurationField iDurationField;\n+\n+        /**\n+         * @param julianField field from the chronology used before the cutover instant\n+         * @param gregorianField field from the chronology used at and after the cutover\n+         */\n+        CutoverField(DateTimeField julianField, DateTimeField gregorianField) {\n+            this(julianField, gregorianField, iCutoverMillis, false);\n+        }\n+\n+        /**\n+         * @param julianField field from the chronology used before the cutover instant\n+         * @param gregorianField field from the chronology used at and after the cutover\n+         * @param convertByWeekyear\n+         */\n+        CutoverField(DateTimeField julianField, DateTimeField gregorianField, boolean convertByWeekyear) {\n+            this(julianField, gregorianField, iCutoverMillis, convertByWeekyear);\n+        }\n+\n+        CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\n+            this(julianField, gregorianField, cutoverMillis, false);\n+        }\n+\n+        CutoverField(DateTimeField julianField, DateTimeField gregorianField,\n+                     long cutoverMillis, boolean convertByWeekyear) {\n+            super(gregorianField.getName());\n+            iJulianField = julianField;\n+            iGregorianField = gregorianField;\n+            iCutover = cutoverMillis;\n+            iConvertByWeekyear = convertByWeekyear;\n+            // Although average length of Julian and Gregorian years differ,\n+            // use the Gregorian duration field because it is more accurate.\n+            iDurationField = gregorianField.getDurationField();\n+        }\n+\n+        public boolean isLenient() {\n+            return false;\n+        }\n+\n+        public int get(long instant) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.get(instant);\n+            } else {\n+                return iJulianField.get(instant);\n+            }\n+        }\n+\n+        public String getAsText(long instant, Locale locale) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.getAsText(instant, locale);\n+            } else {\n+                return iJulianField.getAsText(instant, locale);\n+            }\n+        }\n+\n+        public String getAsShortText(long instant, Locale locale) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.getAsShortText(instant, locale);\n+            } else {\n+                return iJulianField.getAsShortText(instant, locale);\n+            }\n+        }\n+\n+        public long add(long instant, int value) {\n+            return iGregorianField.add(instant, value);\n+        }\n+\n+        public long add(long instant, long value) {\n+            return iGregorianField.add(instant, value);\n+        }\n+\n+        public int getDifference(long minuendInstant, long subtrahendInstant) {\n+            return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n+        }\n+\n+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+            return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+        }\n+\n+        public long set(long instant, int value) {\n+            if (instant >= iCutover) {\n+                instant = iGregorianField.set(instant, value);\n+                if (instant < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant + iGapDuration < iCutover) {\n+                        instant = gregorianToJulian(instant);\n+                    }\n+                    // Verify that new value stuck.\n+                    if (get(instant) != value) {\n+                        throw new IllegalArgumentException\n+                            (\"Illegal value for \" + iGregorianField.getName() + \": \" + value);\n+                    }\n+                }\n+            } else {\n+                instant = iJulianField.set(instant, value);\n+                if (instant >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant - iGapDuration >= iCutover) {\n+                        instant = julianToGregorian(instant);\n+                    }\n+                    // Verify that new value stuck.\n+                    if (get(instant) != value) {\n+                        throw new IllegalArgumentException\n+                            (\"Illegal value for \" + iJulianField.getName() + \": \" + value);\n+                    }\n+                }\n+            }\n+            return instant;\n+        }\n+\n+        public long set(long instant, String text, Locale locale) {\n+            if (instant >= iCutover) {\n+                instant = iGregorianField.set(instant, text, locale);\n+                if (instant < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant + iGapDuration < iCutover) {\n+                        instant = gregorianToJulian(instant);\n+                    }\n+                    // Cannot verify that new value stuck because set may be lenient.\n+                }\n+            } else {\n+                instant = iJulianField.set(instant, text, locale);\n+                if (instant >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant - iGapDuration >= iCutover) {\n+                        instant = julianToGregorian(instant);\n+                    }\n+                    // Cannot verify that new value stuck because set may be lenient.\n+                }\n+            }\n+            return instant;\n+        }\n+\n+        public DurationField getDurationField() {\n+            return iDurationField;\n+        }\n+\n+        public DurationField getRangeDurationField() {\n+            DurationField rangeField = iGregorianField.getRangeDurationField();\n+            if (rangeField == null) {\n+                rangeField = iJulianField.getRangeDurationField();\n+            }\n+            return rangeField;\n+        }\n+\n+        public boolean isLeap(long instant) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.isLeap(instant);\n+            } else {\n+                return iJulianField.isLeap(instant);\n+            }\n+        }\n+\n+        public int getLeapAmount(long instant) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.getLeapAmount(instant);\n+            } else {\n+                return iJulianField.getLeapAmount(instant);\n+            }\n+        }\n+\n+        public DurationField getLeapDurationField() {\n+            return iGregorianField.getLeapDurationField();\n+        }\n+\n+\n+        public int getMinimumValue() {\n+            // For all precise fields, the Julian and Gregorian limits are\n+            // identical. Choose Julian to tighten up the year limits.\n+            return iJulianField.getMinimumValue();\n+        }\n+        \n+        public int getMinimumValue(long instant) {\n+            if (instant < iCutover) {\n+                return iJulianField.getMinimumValue(instant);\n+            }\n+\n+            int min = iGregorianField.getMinimumValue(instant);\n+\n+            // Because the cutover may reduce the length of this field, verify\n+            // the minimum by setting it.\n+            instant = iGregorianField.set(instant, min);\n+            if (instant < iCutover) {\n+                min = iGregorianField.get(iCutover);\n+            }\n+\n+            return min;\n+        }\n+\n+        public int getMaximumValue() {\n+            // For all precise fields, the Julian and Gregorian limits are\n+            // identical.\n+            return iGregorianField.getMaximumValue();\n+        }\n+\n+        public int getMaximumValue(long instant) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.getMaximumValue(instant);\n+            }\n+\n+            int max = iJulianField.getMaximumValue(instant);\n+\n+            // Because the cutover may reduce the length of this field, verify\n+            // the maximum by setting it.\n+            instant = iJulianField.set(instant, max);\n+            if (instant >= iCutover) {\n+                max = iJulianField.get(iJulianField.add(iCutover, -1));\n+            }\n+\n+            return max;\n+        }\n+\n+        public long roundFloor(long instant) {\n+            if (instant >= iCutover) {\n+                instant = iGregorianField.roundFloor(instant);\n+                if (instant < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant + iGapDuration < iCutover) {\n+                        instant = gregorianToJulian(instant);\n+                    }\n+                }\n+            } else {\n+                instant = iJulianField.roundFloor(instant);\n+            }\n+            return instant;\n+        }\n+\n+        public long roundCeiling(long instant) {\n+            if (instant >= iCutover) {\n+                instant = iGregorianField.roundCeiling(instant);\n+            } else {\n+                instant = iJulianField.roundCeiling(instant);\n+                if (instant >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant - iGapDuration >= iCutover) {\n+                        instant = julianToGregorian(instant);\n+                    }\n+                }\n+            }\n+            return instant;\n+        }\n+\n+        public int getMaximumTextLength(Locale locale) {\n+            return Math.max(iJulianField.getMaximumTextLength(locale),\n+                            iGregorianField.getMaximumTextLength(locale));\n+        }\n+\n+        public int getMaximumShortTextLength(Locale locale) {\n+            return Math.max(iJulianField.getMaximumShortTextLength(locale),\n+                            iGregorianField.getMaximumShortTextLength(locale));\n+        }\n+\n+        protected long julianToGregorian(long instant) {\n+            if (iConvertByWeekyear) {\n+                return julianToGregorianByWeekyear(instant);\n+            } else {\n+                return julianToGregorianByYear(instant);\n+            }\n+        }\n+\n+        protected long gregorianToJulian(long instant) {\n+            if (iConvertByWeekyear) {\n+                return gregorianToJulianByWeekyear(instant);\n+            } else {\n+                return gregorianToJulianByYear(instant);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Cutover field for variable length fields. These fields internally call\n+     * set whenever add is called. As a result, the same correction applied to\n+     * set must be applied to add and addWrapped. Knowing when to use this\n+     * field requires specific knowledge of how the GJ fields are implemented.\n+     */\n+    private final class ImpreciseCutoverField extends CutoverField {\n+        static final long serialVersionUID = 3410248757173576441L;\n+\n+        /**\n+         * Creates a duration field that links back to this.\n+         */\n+        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField) {\n+            this(julianField, gregorianField, null, false);\n+        }\n+\n+        /**\n+         * Creates a duration field that links back to this.\n+         */\n+        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n+                              boolean convertByWeekyear) {\n+            this(julianField, gregorianField, null, convertByWeekyear);\n+        }\n+\n+        /**\n+         * Uses a shared duration field rather than creating a new one.\n+         *\n+         * @param durationField shared duration field\n+         */\n+        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n+                              DurationField durationField)\n+        {\n+            this(julianField, gregorianField, durationField, false);\n+        }\n+\n+        /**\n+         * Uses a shared duration field rather than creating a new one.\n+         *\n+         * @param durationField shared duration field\n+         */\n+        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n+                              DurationField durationField, boolean convertByWeekyear)\n+        {\n+            super(julianField, gregorianField, convertByWeekyear);\n+            if (durationField == null) {\n+                durationField = new LinkedDurationField(iDurationField, this);\n+            }\n+            iDurationField = durationField;\n+        }\n+\n+        public long add(long instant, int value) {\n+            if (instant >= iCutover) {\n+                instant = iGregorianField.add(instant, value);\n+                if (instant < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant + iGapDuration < iCutover) {\n+                        instant = gregorianToJulian(instant);\n+                    }\n+                }\n+            } else {\n+                instant = iJulianField.add(instant, value);\n+                if (instant >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant - iGapDuration >= iCutover) {\n+                        instant = julianToGregorian(instant);\n+                    }\n+                }\n+            }\n+            return instant;\n+        }\n+        \n+        public long add(long instant, long value) {\n+            if (instant >= iCutover) {\n+                instant = iGregorianField.add(instant, value);\n+                if (instant < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant + iGapDuration < iCutover) {\n+                        instant = gregorianToJulian(instant);\n+                    }\n+                }\n+            } else {\n+                instant = iJulianField.add(instant, value);\n+                if (instant >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant - iGapDuration >= iCutover) {\n+                        instant = julianToGregorian(instant);\n+                    }\n+                }\n+            }\n+            return instant;\n+        }\n+\n+        public int getDifference(long minuendInstant, long subtrahendInstant) {\n+            if (minuendInstant >= iCutover) {\n+                if (subtrahendInstant >= iCutover) {\n+                    return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n+                }\n+                // Remember, the add is being reversed. Since subtrahend is\n+                // Julian, convert minuend to Julian to match.\n+                minuendInstant = gregorianToJulian(minuendInstant);\n+                return iJulianField.getDifference(minuendInstant, subtrahendInstant);\n+            } else {\n+                if (subtrahendInstant < iCutover) {\n+                    return iJulianField.getDifference(minuendInstant, subtrahendInstant);\n+                }\n+                // Remember, the add is being reversed. Since subtrahend is\n+                // Gregorian, convert minuend to Gregorian to match.\n+                minuendInstant = julianToGregorian(minuendInstant);\n+                return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n+            }\n+        }\n+\n+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+            if (minuendInstant >= iCutover) {\n+                if (subtrahendInstant >= iCutover) {\n+                    return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+                }\n+                // Remember, the add is being reversed. Since subtrahend is\n+                // Julian, convert minuend to Julian to match.\n+                minuendInstant = gregorianToJulian(minuendInstant);\n+                return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+            } else {\n+                if (subtrahendInstant < iCutover) {\n+                    return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+                }\n+                // Remember, the add is being reversed. Since subtrahend is\n+                // Gregorian, convert minuend to Gregorian to match.\n+                minuendInstant = julianToGregorian(minuendInstant);\n+                return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+            }\n+        }\n+\n+        // Since the imprecise fields have durations longer than the gap\n+        // duration, keep these methods simple. The inherited implementations\n+        // produce incorrect results.\n+        //\n+        // Degenerate case: If this field is a month, and the cutover is set\n+        // far into the future, then the gap duration may be so large as to\n+        // reduce the number of months in a year. If the missing month(s) are\n+        // at the beginning or end of the year, then the minimum and maximum\n+        // values are not 1 and 12. I don't expect this case to ever occur.\n+\n+        public int getMinimumValue(long instant) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.getMinimumValue(instant);\n+            } else {\n+                return iJulianField.getMinimumValue(instant);\n+            }\n+        }\n+\n+        public int getMaximumValue(long instant) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.getMaximumValue(instant);\n+            } else {\n+                return iJulianField.getMaximumValue(instant);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Links the duration back to a ImpreciseCutoverField.\n+     */\n+    private static class LinkedDurationField extends DecoratedDurationField {\n+        static final long serialVersionUID = 4097975388007713084L;\n+\n+        private final ImpreciseCutoverField iField;\n+\n+        LinkedDurationField(DurationField durationField, ImpreciseCutoverField dateTimeField) {\n+            super(durationField, durationField.getName());\n+            iField = dateTimeField;\n+        }\n+\n+        public long add(long instant, int value) {\n+            return iField.add(instant, value);\n+        }\n+\n+        public long add(long instant, long value) {\n+            return iField.add(instant, value);\n+        }\n+\n+        public int getDifference(long minuendInstant, long subtrahendInstant) {\n+            return iField.getDifference(minuendInstant, subtrahendInstant);\n+        }\n+\n+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+            return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DurationField;\n+import org.joda.time.field.PreciseDurationDateTimeField;\n+\n+/**\n+ * Provides time calculations for the day of the month component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+final class GJDayOfMonthDateTimeField extends PreciseDurationDateTimeField {\n+\n+    static final long serialVersionUID = -4677223814028011723L;\n+\n+    private final AbstractGJChronology iChronology;\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    GJDayOfMonthDateTimeField(AbstractGJChronology chronology, DurationField days) {\n+        super(\"dayOfMonth\", days);\n+        iChronology = chronology;\n+    }\n+\n+    /**\n+     * Get the day of the month component of the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to query.\n+     * @return the day of the month extracted from the input.\n+     */\n+    public int get(long instant) {\n+        return iChronology.getDayOfMonth(instant);\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.months();\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 31;\n+    }\n+\n+    public int getMaximumValue(long instant) {\n+        int thisYear = iChronology.getYear(instant);\n+        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n+        return iChronology.getDaysInYearMonth(thisYear, thisMonth);\n+    }\n+\n+    protected int getMaximumValueForSet(long instant, int value) {\n+        return value > 28 ? getMaximumValue(instant) : 28;\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.dayOfMonth();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.PreciseDurationDateTimeField;\n+\n+/**\n+ * GJDayOfWeekDateTimeField provides time calculations for the\n+ * day of the week component of time.\n+ *\n+ * @since 1.0\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ */\n+final class GJDayOfWeekDateTimeField extends PreciseDurationDateTimeField {\n+    \n+    static final long serialVersionUID = -3857947176719041436L;\n+\n+    private final AbstractGJChronology iChronology;\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    GJDayOfWeekDateTimeField(AbstractGJChronology chronology, DurationField days) {\n+        super(\"dayOfWeek\", days);\n+        iChronology = chronology;\n+    }\n+\n+    /**\n+     * Get the value of the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to query\n+     * @return the day of the week extracted from the input\n+     */\n+    public int get(long instant) {\n+        return iChronology.getDayOfWeek(instant);\n+    }\n+\n+    /**\n+     * Get the textual value of the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to query\n+     * @param locale  the locale to use\n+     * @return the day of the week, such as 'Monday'\n+     */\n+    public String getAsText(long instant, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(instant));\n+    }\n+\n+    /**\n+     * Get the abbreviated textual value of the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to query\n+     * @param locale  the locale to use\n+     * @return the day of the week, such as 'Mon'\n+     */\n+    public String getAsShortText(long instant, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToShortText(get(instant));\n+    }\n+\n+    /**\n+     * Set the value of the specified time instant from text.\n+     * \n+     * @param instant  the time instant in millis to update\n+     * @param text  the text to set from\n+     * @param locale  the locale to use\n+     * @return the updated millis\n+     */\n+    public long set(long instant, String text, Locale locale) {\n+        return set(instant, GJLocaleSymbols.forLocale(locale).dayOfWeekTextToValue(text));\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.weeks();\n+    }\n+\n+    /**\n+     * Get the minimum value that this field can have.\n+     * \n+     * @return the field's minimum value\n+     */\n+    public int getMinimumValue() {\n+        return DateTimeConstants.MONDAY;\n+    }\n+\n+    /**\n+     * Get the maximum value that this field can have.\n+     * \n+     * @return the field's maximum value\n+     */\n+    public int getMaximumValue() {\n+        return DateTimeConstants.SUNDAY;\n+    }\n+\n+    /**\n+     * Get the maximum length of the text returned by this field.\n+     * \n+     * @param locale  the locale to use\n+     * @return the maximum textual length\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxTextLength();\n+    }\n+\n+    /**\n+     * Get the maximum length of the abbreviated text returned by this field.\n+     * \n+     * @param locale  the locale to use\n+     * @return the maximum abbreviated textual length\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxShortTextLength();\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.dayOfWeek();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.PreciseDurationDateTimeField;\n+\n+/**\n+ * Provides time calculations for the day of the year component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+final class GJDayOfYearDateTimeField extends PreciseDurationDateTimeField {\n+\n+    static final long serialVersionUID = -6821236822336841037L;\n+\n+    private final AbstractGJChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    GJDayOfYearDateTimeField(AbstractGJChronology chronology, DurationField days) {\n+        super(\"dayOfYear\", days);\n+        iChronology = chronology;\n+    }\n+\n+    /**\n+     * Get the day of the year component of the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to query.\n+     * @return the day of the year extracted from the input.\n+     */\n+    public int get(long instant) {\n+        return iChronology.getDayOfYear(instant);\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.years();\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 366;\n+    }\n+\n+    public int getMaximumValue(long instant) {\n+        int thisYear = iChronology.getYear(instant);\n+        return iChronology.getDaysInYear(thisYear);\n+    }\n+\n+    protected int getMaximumValueForSet(long instant, int value) {\n+        return value > 365 ? getMaximumValue(instant) : 365;\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.dayOfYear();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.AbstractDateTimeField;\n+import org.joda.time.field.UnsupportedDurationField;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * Provides time calculations for the era component of time.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @version 1.0\n+ * @since 1.0\n+ */\n+final class GJEraDateTimeField extends AbstractDateTimeField {\n+    \n+    static final long serialVersionUID = 4240986525305515528L;\n+\n+    private final AbstractGJChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    GJEraDateTimeField(AbstractGJChronology chronology) {\n+        super(\"era\");\n+        iChronology = chronology;\n+    }\n+\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    /**\n+     * Get the Era component of the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to query.\n+     */\n+    public int get(long instant) {\n+        if (iChronology.getYear(instant) <= 0) {\n+            return DateTimeConstants.BCE;\n+        } else {\n+            return DateTimeConstants.CE;\n+        }\n+    }\n+\n+    public String getAsText(long instant, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).eraValueToText(get(instant));\n+    }\n+\n+    /**\n+     * Set the Era component of the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param era  the era to update the time to.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException  if era is invalid.\n+     */\n+    public long set(long instant, int era) {\n+        FieldUtils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE);\n+            \n+        int oldEra = get(instant);\n+        if (oldEra != era) {\n+            int year = iChronology.getYear(instant);\n+            return iChronology.setYear(instant, -year);\n+        } else {\n+            return instant;\n+        }\n+    }\n+\n+    public long set(long instant, String text, Locale locale) {\n+        return set(instant, GJLocaleSymbols.forLocale(locale).eraTextToValue(text));\n+    }\n+\n+    public long roundFloor(long instant) {\n+        if (get(instant) == DateTimeConstants.CE) {\n+            return iChronology.setYear(0, 1);\n+        } else {\n+            return Long.MIN_VALUE;\n+        }\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        if (get(instant) == DateTimeConstants.BCE) {\n+            return iChronology.setYear(0, 1);\n+        } else {\n+            return Long.MAX_VALUE;\n+        }\n+    }\n+\n+    public long roundHalfFloor(long instant) {\n+        // In reality, the era is infinite, so there is no halfway point.\n+        return roundFloor(instant);\n+    }\n+\n+    public long roundHalfCeiling(long instant) {\n+        // In reality, the era is infinite, so there is no halfway point.\n+        return roundFloor(instant);\n+    }\n+\n+    public long roundHalfEven(long instant) {\n+        // In reality, the era is infinite, so there is no halfway point.\n+        return roundFloor(instant);\n+    }\n+\n+    public DurationField getDurationField() {\n+        return UnsupportedDurationField.INSTANCE;\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    public int getMinimumValue() {\n+        return DateTimeConstants.BCE;\n+    }\n+\n+    public int getMaximumValue() {\n+        return DateTimeConstants.CE;\n+    }\n+\n+    public int getMaximumTextLength(Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).getEraMaxTextLength();\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.era();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJLocaleSymbols.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.lang.ref.WeakReference;\n+import java.text.DateFormatSymbols;\n+import java.util.WeakHashMap;\n+import java.util.Locale;\n+\n+/**\n+ * Utility class used by a few of the GJDateTimeFields.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+class GJLocaleSymbols {\n+    private static final int FAST_CACHE_SIZE = 64;\n+\n+    private static final GJLocaleSymbols[] cFastCache = new GJLocaleSymbols[FAST_CACHE_SIZE];\n+\n+    private static WeakHashMap cCache = new WeakHashMap();\n+\n+    public static GJLocaleSymbols forLocale(Locale locale) {\n+        int index = System.identityHashCode(locale) & (FAST_CACHE_SIZE - 1);\n+        GJLocaleSymbols symbols = cFastCache[index];\n+        if (symbols != null && symbols.iLocale.get() == locale) {\n+            return symbols;\n+        }\n+        synchronized (cCache) {\n+            symbols = (GJLocaleSymbols) cCache.get(locale);\n+            if (symbols == null) {\n+                symbols = new GJLocaleSymbols(locale);\n+                cCache.put(locale, symbols);\n+            }\n+        }\n+        cFastCache[index] = symbols;\n+        return symbols;\n+    }\n+\n+    private static String[] realignMonths(String[] months) {\n+        String[] a = new String[13];\n+        for (int i=1; i<13; i++) {\n+            a[i] = months[i - 1];\n+        }\n+        return a;\n+    }\n+\n+    private static String[] realignDaysOfWeek(String[] daysOfWeek) {\n+        String[] a = new String[8];\n+        for (int i=1; i<8; i++) {\n+            a[i] = daysOfWeek[(i < 7) ? i + 1 : 1];\n+        }\n+        return a;\n+    }\n+\n+    private static int maxLength(String[] a) {\n+        int max = 0;\n+        for (int i=a.length; --i>=0; ) {\n+            String s = a[i];\n+            if (s != null) {\n+                int len = s.length();\n+                if (len > max) {\n+                    max = len;\n+                }\n+            }\n+        }\n+        return max;\n+    }\n+\n+    private final WeakReference iLocale;\n+\n+    private final String[] iEras;\n+    private final String[] iDaysOfWeek;\n+    private final String[] iShortDaysOfWeek;\n+    private final String[] iMonths;\n+    private final String[] iShortMonths;\n+    private final String[] iHalfday;\n+\n+    private final int iMaxEraLength;\n+    private final int iMaxDayOfWeekLength;\n+    private final int iMaxShortDayOfWeekLength;\n+    private final int iMaxMonthLength;\n+    private final int iMaxShortMonthLength;\n+    private final int iMaxHalfdayLength;\n+\n+    private GJLocaleSymbols(Locale locale) {\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+\n+        iLocale = new WeakReference(locale);\n+\n+        DateFormatSymbols dfs = new DateFormatSymbols(locale);\n+\n+        iEras = dfs.getEras();\n+        iDaysOfWeek = realignDaysOfWeek(dfs.getWeekdays());\n+        iShortDaysOfWeek = realignDaysOfWeek(dfs.getShortWeekdays());\n+        iMonths = realignMonths(dfs.getMonths());\n+        iShortMonths = realignMonths(dfs.getShortMonths());\n+        iHalfday = dfs.getAmPmStrings();\n+\n+        iMaxEraLength = maxLength(iEras);\n+        iMaxDayOfWeekLength = maxLength(iDaysOfWeek);\n+        iMaxShortDayOfWeekLength = maxLength(iShortDaysOfWeek);\n+        iMaxMonthLength = maxLength(iMonths);\n+        iMaxShortMonthLength = maxLength(iShortMonths);\n+        iMaxHalfdayLength = maxLength(iHalfday);\n+    }\n+\n+    public String eraValueToText(int value) {\n+        return iEras[value];\n+    }\n+\n+    public int eraTextToValue(String text) {\n+        String[] eras = iEras;\n+        for (int i=eras.length; --i>=0; ) {\n+            if (eras[i].equalsIgnoreCase(text)) {\n+                return i;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Illegal era text: \" + text);\n+    }\n+\n+    public int getEraMaxTextLength() {\n+        return iMaxEraLength;\n+    }\n+\n+    public String monthOfYearValueToText(int value) {\n+        return iMonths[value];\n+    }\n+\n+    public String monthOfYearValueToShortText(int value) {\n+        return iShortMonths[value];\n+    }\n+\n+    public int monthOfYearTextToValue(String text) {\n+        String[] months = iMonths;\n+        for (int i=months.length; --i>=1; ) {\n+            if (months[i].equalsIgnoreCase(text)) {\n+                return i;\n+            }\n+        }\n+        months = iShortMonths;\n+        for (int i=months.length; --i>=1; ) {\n+            if (months[i].equalsIgnoreCase(text)) {\n+                return i;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Illegal monthOfYear text: \" + text);\n+    }\n+\n+    public int getMonthMaxTextLength() {\n+        return iMaxMonthLength;\n+    }\n+\n+    public int getMonthMaxShortTextLength() {\n+        return iMaxShortMonthLength;\n+    }\n+\n+    public String dayOfWeekValueToText(int value) {\n+        return iDaysOfWeek[value];\n+    }\n+\n+    public String dayOfWeekValueToShortText(int value) {\n+        return iShortDaysOfWeek[value];\n+    }\n+\n+    public int dayOfWeekTextToValue(String text) {\n+        String[] daysOfWeek = iDaysOfWeek;\n+        for (int i=daysOfWeek.length; --i>=1; ) {\n+            if (daysOfWeek[i].equalsIgnoreCase(text)) {\n+                return i;\n+            }\n+        }\n+        daysOfWeek = iShortDaysOfWeek;\n+        for (int i=daysOfWeek.length; --i>=1; ) {\n+            if (daysOfWeek[i].equalsIgnoreCase(text)) {\n+                return i;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Illegal dayOfWeek text: \" + text);\n+    }\n+\n+    public int getDayOfWeekMaxTextLength() {\n+        return iMaxDayOfWeekLength;\n+    }\n+\n+    public int getDayOfWeekMaxShortTextLength() {\n+        return iMaxShortDayOfWeekLength;\n+    }\n+\n+    public String halfdayValueToText(int value) {\n+        return iHalfday[value];\n+    }\n+\n+    public int halfdayTextToValue(String text) {\n+        String[] halfday = iHalfday;\n+        for (int i = halfday.length; --i>=0; ) {\n+            if (halfday[i].equalsIgnoreCase(text)) {\n+                return i;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Illegal halfday text: \" + text);\n+    }\n+\n+    public int getHalfdayMaxTextLength() {\n+        return iMaxHalfdayLength;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.ImpreciseDateTimeField;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * Provides time calculations for the month of the year component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @version 1.0\n+ * @since 1.0\n+ */\n+final class GJMonthOfYearDateTimeField extends ImpreciseDateTimeField {\n+\n+    static final long serialVersionUID = -4748157875845286249L;\n+\n+    private static final int MIN = DateTimeConstants.JANUARY;\n+    private static final int MAX = DateTimeConstants.DECEMBER;\n+\n+    private final AbstractGJChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    GJMonthOfYearDateTimeField(AbstractGJChronology chronology) {\n+        super(\"monthOfYear\", \"months\", chronology.getAverageMillisPerMonth());\n+        iChronology = chronology;\n+    }\n+\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    /**\n+     * Get the Month component of the specified time instant.\n+     *\n+     * @see org.joda.time.DateTimeField#get(long)\n+     * @see org.joda.time.ReadableDateTime#getMonthOfYear()\n+     * @param instant  the time instant in millis to query.\n+     * @return the month extracted from the input.\n+     */\n+    public int get(long instant) {\n+        return iChronology.getMonthOfYear(instant);\n+    }\n+\n+    public String getAsText(long instant, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToText(get(instant));\n+    }\n+\n+    public String getAsShortText(long instant, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToShortText(get(instant));\n+    }\n+\n+    /**\n+     * Add the specified month to the specified time instant.\n+     * The amount added may be negative.<p>\n+     * If the new month has less total days than the specified\n+     * day of the month, this value is coerced to the nearest\n+     * sane value. e.g.<p>\n+     * 07-31 - (1 month) = 06-30<p>\n+     * 03-31 - (1 month) = 02-28 or 02-29 depending<p>\n+     * \n+     * @see org.joda.time.DateTimeField#add\n+     * @see org.joda.time.ReadWritableDateTime#addMonths(int)\n+     * @param instant  the time instant in millis to update.\n+     * @param months  the months to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, int months) {\n+        if (months == 0) {\n+            return instant; // the easy case\n+        }\n+        //\n+        // Save time part first.\n+        //\n+        long timePart = iChronology.getMillisOfDay(instant);\n+        //\n+        //\n+        // Get this year and month.\n+        //\n+        int thisYear = iChronology.getYear(instant);\n+        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n+        // ----------------------------------------------------------\n+        //\n+        // Do not refactor without careful consideration.\n+        // Order of calculation is important.\n+        //\n+        int yearToUse;\n+        // Initially, monthToUse is zero-based\n+        int monthToUse = thisMonth - 1 + months;\n+        if (monthToUse >= 0) {\n+            yearToUse = thisYear + (monthToUse / MAX);\n+            monthToUse = (monthToUse % MAX) + 1;\n+        } else {\n+            yearToUse = thisYear + (monthToUse / MAX) - 1;\n+            monthToUse = Math.abs(monthToUse);\n+            int remMonthToUse = monthToUse % MAX;\n+            // Take care of the boundary condition\n+            if (remMonthToUse == 0) {\n+                remMonthToUse = MAX;\n+            }\n+            monthToUse = MAX - remMonthToUse + 1;\n+            // Take care of the boundary condition\n+            if (monthToUse == 1) {\n+                yearToUse += 1;\n+            }\n+        }\n+        // End of do not refactor.\n+        // ----------------------------------------------------------\n+\n+        //\n+        // Quietly force DOM to nearest sane value.\n+        //\n+        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n+        int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);\n+        if (dayToUse > maxDay) {\n+            dayToUse = maxDay;\n+        }\n+        //\n+        // get proper date part, and return result\n+        //\n+        long datePart =\n+            iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);\n+        return datePart + timePart;\n+    }\n+\n+    public long add(long instant, long months) {\n+        int i_months = (int)months;\n+        if (i_months == months) {\n+            return add(instant, i_months);\n+        }\n+\n+        // Copied from add(long, int) and modified slightly:\n+\n+        long timePart = iChronology.getMillisOfDay(instant);\n+\n+        int thisYear = iChronology.getYear(instant);\n+        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n+\n+        long yearToUse;\n+        long monthToUse = thisMonth - 1 + months;\n+        if (monthToUse >= 0) {\n+            yearToUse = thisYear + (monthToUse / MAX);\n+            monthToUse = (monthToUse % MAX) + 1;\n+        } else {\n+            yearToUse = thisYear + (monthToUse / MAX) - 1;\n+            monthToUse = Math.abs(monthToUse);\n+            int remMonthToUse = (int)(monthToUse % MAX);\n+            if (remMonthToUse == 0) {\n+                remMonthToUse = MAX;\n+            }\n+            monthToUse = MAX - remMonthToUse + 1;\n+            if (monthToUse == 1) {\n+                yearToUse += 1;\n+            }\n+        }\n+\n+        if (yearToUse < iChronology.getMinYear() ||\n+            yearToUse > iChronology.getMaxYear()) {\n+\n+            throw new IllegalArgumentException\n+                (\"Magnitude of add amount is too large: \" + months);\n+        }\n+\n+        int i_yearToUse = (int)yearToUse;\n+        int i_monthToUse = (int)monthToUse;\n+\n+        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n+        int maxDay = iChronology.getDaysInYearMonth(i_yearToUse, i_monthToUse);\n+        if (dayToUse > maxDay) {\n+            dayToUse = maxDay;\n+        }\n+\n+        long datePart =\n+            iChronology.getYearMonthDayMillis(i_yearToUse, i_monthToUse, dayToUse);\n+        return datePart + timePart;\n+    }\n+\n+    /**\n+     * Add to the Month component of the specified time instant\n+     * wrapping around within that component if necessary.\n+     * \n+     * @see org.joda.time.DateTimeField#addWrapped\n+     * @see org.joda.time.ReadWritableDateTime#addWrappedMonthOfYear(int)\n+     * @param instant  the time instant in millis to update.\n+     * @param months  the months to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long instant, int months) {\n+        return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, MAX));\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        if (minuendInstant < subtrahendInstant) {\n+            return -getDifference(subtrahendInstant, minuendInstant);\n+        }\n+\n+        int minuendYear = iChronology.getYear(minuendInstant);\n+        int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear);\n+        int subtrahendYear = iChronology.getYear(subtrahendInstant);\n+        int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear);\n+\n+        long difference = (minuendYear - subtrahendYear) * 12L + minuendMonth - subtrahendMonth;\n+\n+        // Before adjusting for remainder, account for special case of add\n+        // where the day-of-month is forced to the nearest sane value.\n+        int minuendDom = iChronology.getDayOfMonth\n+            (minuendInstant, minuendYear, minuendMonth);\n+        if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) {\n+            // Last day of the minuend month...\n+            int subtrahendDom = iChronology.getDayOfMonth\n+                (subtrahendInstant, subtrahendYear, subtrahendMonth);\n+            if (subtrahendDom > minuendDom) {\n+                // ...and day of subtrahend month is larger.\n+                // TODO: Don't depend on other fields\n+                subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom);\n+            }\n+        }\n+\n+        // Inlined remainder method to avoid duplicate calls.\n+        long minuendRem = minuendInstant\n+            - iChronology.getYearMonthMillis(minuendYear, minuendMonth);\n+        long subtrahendRem = subtrahendInstant\n+            - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth);\n+\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+\n+        return difference;\n+    }\n+\n+    /**\n+     * Set the Month component of the specified time instant.<p>\n+     * If the new month has less total days than the specified\n+     * day of the month, this value is coerced to the nearest\n+     * sane value. e.g.<p>\n+     * 07-31 to month 6 = 06-30<p>\n+     * 03-31 to month 2 = 02-28 or 02-29 depending<p>\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param month  the month (1,12) to update the time to.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException  if month is invalid\n+     */\n+    public long set(long instant, int month) {\n+        FieldUtils.verifyValueBounds(this, month, MIN, MAX);\n+        //\n+        int thisYear = iChronology.getYear(instant);\n+        //\n+        int thisDom = iChronology.getDayOfMonth(instant, thisYear);\n+        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n+        if (thisDom > maxDom) {\n+            // Quietly force DOM to nearest sane value.\n+            thisDom = maxDom;\n+        }\n+        // Return newly calculated millis value\n+        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n+            iChronology.getMillisOfDay(instant);\n+    }\n+\n+    public long set(long instant, String text, Locale locale) {\n+        return set(instant, GJLocaleSymbols.forLocale(locale).monthOfYearTextToValue(text));\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.years();\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        int thisYear = iChronology.getYear(instant);\n+        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n+        if (thisMonth != 2) {\n+            return false;\n+        } else {\n+            return 29 == iChronology.getDaysInYearMonth(thisYear, thisMonth);\n+        }\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        return isLeap(instant) ? 1 : 0;\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return iChronology.days();\n+    }\n+\n+    public int getMinimumValue() {\n+        return MIN;\n+    }\n+\n+    public int getMaximumValue() {\n+        return MAX;\n+    }\n+\n+    public int getMaximumTextLength(Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).getMonthMaxTextLength();\n+    }\n+\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).getMonthMaxShortTextLength();\n+    }\n+\n+    public long roundFloor(long instant) {\n+        int year = iChronology.getYear(instant);\n+        int month = iChronology.getMonthOfYear(instant, year);\n+        return iChronology.getYearMonthMillis(year, month);\n+    }\n+\n+    public long remainder(long instant) {\n+        return instant - roundFloor(instant);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.monthOfYear();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.PreciseDurationDateTimeField;\n+\n+/**\n+ * Provides time calculations for the week of a week based year component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @version 1.0\n+ * @since 1.0\n+ */\n+final class GJWeekOfWeekyearDateTimeField extends PreciseDurationDateTimeField {\n+\n+    static final long serialVersionUID = -1587436826395135328L;\n+\n+    private final AbstractGJChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    GJWeekOfWeekyearDateTimeField(AbstractGJChronology chronology, DurationField weeks) {\n+        super(\"weekOfWeekyear\", weeks);\n+        iChronology = chronology;\n+    }\n+\n+    /**\n+     * Get the week of a week based year component of the specified time instant.\n+     * \n+     * @see org.joda.time.DateTimeField#get(long)\n+     * @param instant  the time instant in millis to query.\n+     * @return the week of the year extracted from the input.\n+     */\n+    public int get(long instant) {\n+        return iChronology.getWeekOfWeekyear(instant);\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.weekyears();\n+    }\n+\n+    // 1970-01-01 is day of week 4, Thursday. The rounding methods need to\n+    // apply a corrective alignment since weeks begin on day of week 1, Monday.\n+\n+    public long roundFloor(long instant) {\n+        return super.roundFloor(instant + 3 * DateTimeConstants.MILLIS_PER_DAY)\n+            - 3 * DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        return super.roundCeiling(instant + 3 * DateTimeConstants.MILLIS_PER_DAY)\n+            - 3 * DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    public long remainder(long instant) {\n+        return super.remainder(instant + 3 * DateTimeConstants.MILLIS_PER_DAY);\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 53;\n+    }\n+\n+    public int getMaximumValue(long instant) {\n+        int thisYear = iChronology.getWeekyear(instant);\n+        return iChronology.getWeeksInYear(thisYear);\n+    }\n+\n+    protected int getMaximumValueForSet(long instant, int value) {\n+        return value > 52 ? getMaximumValue(instant) : 52;\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.weekOfWeekyear();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJWeekyearDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.ImpreciseDateTimeField;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * Provides time calculations for the week of the weekyear component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @version 1.0\n+ * @since 1.0\n+ * @see org.joda.time.DateTimeField\n+ */\n+final class GJWeekyearDateTimeField extends ImpreciseDateTimeField {\n+    \n+    static final long serialVersionUID = 6215066916806820644L;\n+\n+    private static final long WEEK_53 = (53L - 1) * DateTimeConstants.MILLIS_PER_WEEK;\n+\n+    private final AbstractGJChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    GJWeekyearDateTimeField(AbstractGJChronology chronology) {\n+        super(\"weekyear\", \"weekyears\", chronology.getAverageMillisPerYear());\n+        iChronology = chronology;\n+    }\n+\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    /**\n+     * Get the Year of a week based year component of the specified time instant.\n+     * \n+     * @see org.joda.time.DateTimeField#get\n+     * @param instant  the time instant in millis to query.\n+     * @return the year extracted from the input.\n+     */\n+    public int get(long instant) {\n+        return iChronology.getWeekyear(instant);\n+    }\n+\n+    /**\n+     * Add the specified years to the specified time instant.\n+     * \n+     * @see org.joda.time.DateTimeField#add\n+     * @param instant  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, int years) {\n+        if (years == 0) {\n+            return instant;\n+        }\n+        return set(instant, get(instant) + years);\n+    }\n+\n+    public long add(long instant, long value) {\n+        return add(instant, FieldUtils.safeToInt(value));\n+    }\n+\n+    /**\n+     * Add to the year component of the specified time instant\n+     * wrapping around within that component if necessary.\n+     * \n+     * @see org.joda.time.DateTimeField#addWrapped\n+     * @param instant  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long instant, int years) {\n+        return add(instant, years);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        if (minuendInstant < subtrahendInstant) {\n+            return -getDifference(subtrahendInstant, minuendInstant);\n+        }\n+\n+        int minuendWeekyear = get(minuendInstant);\n+        int subtrahendWeekyear = get(subtrahendInstant);\n+\n+        long minuendRem = remainder(minuendInstant);\n+        long subtrahendRem = remainder(subtrahendInstant);\n+\n+        // Balance leap weekyear differences on remainders.\n+        if (subtrahendRem >= WEEK_53 && iChronology.getWeeksInYear(minuendWeekyear) <= 52) {\n+            subtrahendRem -= DateTimeConstants.MILLIS_PER_WEEK;\n+        }\n+\n+        int difference = minuendWeekyear - subtrahendWeekyear;\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+        return difference;\n+    }\n+\n+    /**\n+     * Set the Year of a week based year component of the specified time instant.\n+     *\n+     * @see org.joda.time.DateTimeField#set\n+     * @param instant  the time instant in millis to update.\n+     * @param year  the year (-9999,9999) to set the date to.\n+     * @return the updated DateTime.\n+     * @throws IllegalArgumentException  if year is invalid.\n+     */\n+    public long set(long instant, int year) {\n+        FieldUtils.verifyValueBounds(this, Math.abs(year),\n+                                     iChronology.getMinYear(), iChronology.getMaxYear());\n+        //\n+        // Do nothing if no real change is requested.\n+        //\n+        int thisWeekyear = get( instant );\n+        if ( thisWeekyear == year ) {\n+            return instant;\n+        }\n+        //\n+        // Calculate the DayOfWeek (to be preserved).\n+        //\n+        int thisDow = iChronology.getDayOfWeek(instant);\n+        //\n+        // Calculate the maximum weeks in the target year.\n+        //\n+        int weeksInFromYear = iChronology.getWeeksInYear( thisWeekyear );\n+        int weeksInToYear = iChronology.getWeeksInYear( year );\n+        int maxOutWeeks = (weeksInToYear < weeksInFromYear) ?\n+            weeksInToYear : weeksInFromYear;\n+        //\n+        // Get the current week of the year. This will be preserved in\n+        // the output unless it is greater than the maximum possible\n+        // for the target weekyear.  In that case it is adjusted\n+        // to the maximum possible.\n+        //\n+        int setToWeek = iChronology.getWeekOfWeekyear(instant);\n+        if ( setToWeek > maxOutWeeks ) {\n+            setToWeek = maxOutWeeks;\n+        }\n+        //\n+        // Get a wroking copy of the current date-time.\n+        // This can be a convenience for debugging.\n+        //\n+        long workInstant = instant; // Get a copy\n+        //\n+        // Attempt to get close to the proper weekyear.\n+        // Note - we cannot currently call ourself, so we just call\n+        // set for the year.  This at least gets us close.\n+        //\n+        workInstant = iChronology.setYear( workInstant, year );\n+        //\n+        // Calculate the weekyear number for the get close to value\n+        // (which might not be equal to the year just set).\n+        //\n+        int workWoyYear = get( workInstant );\n+\n+        //\n+        // At most we are off by one year, which can be \"fixed\" by\n+        // adding/subtracting a week.\n+        //\n+        if ( workWoyYear < year ) {\n+            workInstant += DateTimeConstants.MILLIS_PER_WEEK;\n+        } else if ( workWoyYear > year ) {\n+            workInstant -= DateTimeConstants.MILLIS_PER_WEEK;\n+        }\n+        //\n+        // Set the proper week in the current weekyear.\n+        //\n+\n+        // BEGIN: possible set WeekOfWeekyear logic.\n+        int currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant);\n+        // No range check required (we already know it is OK).\n+        workInstant = workInstant + (setToWeek - currentWoyWeek)\n+            * (long)DateTimeConstants.MILLIS_PER_WEEK;\n+        // END: possible set WeekOfWeekyear logic.\n+\n+        //\n+        // Reset DayOfWeek to previous value.\n+        //\n+        // TODO: Don't depend on other fields\n+        workInstant = iChronology.dayOfWeek().set( workInstant, thisDow );\n+        //\n+        // Return result.\n+        //\n+        return workInstant;\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return iChronology.getWeeksInYear(iChronology.getWeekyear(instant)) > 52;\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        return iChronology.getWeeksInYear(iChronology.getWeekyear(instant)) - 52;\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return iChronology.weeks();\n+    }\n+\n+    public int getMinimumValue() {\n+        return iChronology.getMinYear();\n+    }\n+\n+    public int getMaximumValue() {\n+        return iChronology.getMaxYear();\n+    }\n+\n+    public long roundFloor(long instant) {\n+        // TODO: Don't depend on other fields\n+        instant = iChronology.weekOfWeekyear().roundFloor(instant);\n+        int wow = iChronology.getWeekOfWeekyear(instant);\n+        if (wow > 1) {\n+            instant -= ((long) DateTimeConstants.MILLIS_PER_WEEK) * (wow - 1);\n+        }\n+        return instant;\n+    }\n+\n+    public long remainder(long instant) {\n+        return instant - roundFloor(instant);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.weekyear();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJYearDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.ImpreciseDateTimeField;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * Provides time calculations for the year component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+final class GJYearDateTimeField extends ImpreciseDateTimeField {\n+\n+    static final long serialVersionUID = -679076949530018869L;\n+\n+    private static final long FEB_29 = (31L + 29 - 1) * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    private final AbstractGJChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    GJYearDateTimeField(AbstractGJChronology chronology) {\n+        super(\"year\", \"years\", chronology.getAverageMillisPerYear());\n+        iChronology = chronology;\n+    }\n+\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    /**\n+     * Get the Year component of the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to query.\n+     * @return the year extracted from the input.\n+     */\n+    public int get(long instant) {\n+        return iChronology.getYear(instant);\n+    }\n+\n+    /**\n+     * Add the specified year to the specified time instant.\n+     * The amount added may be negative.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, int years) {\n+        if (years == 0) {\n+            return instant;\n+        }\n+        int thisYear = get(instant);\n+        int newYear = thisYear + years;\n+        return set(instant, newYear);\n+    }\n+\n+    public long add(long instant, long years) {\n+        return add(instant, FieldUtils.safeToInt(years));\n+    }\n+\n+    /**\n+     * Add to the Year component of the specified time instant\n+     * wrapping around within that component if necessary.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long instant, int years) {\n+        if (years == 0) {\n+            return instant;\n+        }\n+        // Return newly calculated millis value\n+        int thisYear = iChronology.getYear(instant);\n+        int wrappedYear = FieldUtils.getWrappedValue\n+            (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear());\n+        return set(instant, wrappedYear);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        if (minuendInstant < subtrahendInstant) {\n+            return -getDifference(subtrahendInstant, minuendInstant);\n+        }\n+\n+        int minuendYear = get(minuendInstant);\n+        int subtrahendYear = get(subtrahendInstant);\n+\n+        // Inlined remainder method to avoid duplicate calls to get.\n+        long minuendRem = minuendInstant - iChronology.getYearMillis(minuendYear);\n+        long subtrahendRem = subtrahendInstant - iChronology.getYearMillis(subtrahendYear);\n+\n+        // Balance leap year differences on remainders.\n+        if (subtrahendRem >= FEB_29) {\n+            if (iChronology.isLeapYear(subtrahendYear)) {\n+                if (!iChronology.isLeapYear(minuendYear)) {\n+                    subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY;\n+                }\n+            } else if (minuendRem >= FEB_29 && iChronology.isLeapYear(minuendYear)) {\n+                minuendRem -= DateTimeConstants.MILLIS_PER_DAY;\n+            }\n+        }\n+\n+        int difference = minuendYear - subtrahendYear;\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+        return difference;\n+    }\n+\n+    /**\n+     * Set the Year component of the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param year  the year (-292269055,292278994) to update the time to.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException  if year is invalid.\n+     */\n+    public long set(long instant, int year) {\n+        FieldUtils.verifyValueBounds\n+            (this, year, iChronology.getMinYear(), iChronology.getMaxYear());\n+        return iChronology.setYear(instant, year);\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return iChronology.isLeapYear(get(instant));\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        if (iChronology.isLeapYear(get(instant))) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return iChronology.days();\n+    }\n+\n+    public int getMinimumValue() {\n+        return iChronology.getMinYear();\n+    }\n+\n+    public int getMaximumValue() {\n+        return iChronology.getMaxYear();\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return iChronology.getYearMillis(get(instant));\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        int year = get(instant);\n+        long yearStartMillis = iChronology.getYearMillis(year);\n+        if (instant != yearStartMillis) {\n+            // Bump up to start of next year.\n+            instant = iChronology.getYearMillis(year + 1);\n+        }\n+        return instant;\n+    }\n+\n+    public long remainder(long instant) {\n+        return instant - roundFloor(instant);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.year();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.field.DecoratedDateTimeField;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * Provides time calculations for the year of era component of time.\n+ * \n+ * @author Brian S O'Neill\n+ */\n+final class GJYearOfEraDateTimeField extends DecoratedDateTimeField {\n+\n+    static final long serialVersionUID = -5961050944769862059L;\n+\n+    private final AbstractGJChronology iChronology;\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    GJYearOfEraDateTimeField(DateTimeField yearField, AbstractGJChronology chronology) {\n+        super(yearField, \"yearOfEra\");\n+        iChronology = chronology;\n+    }\n+\n+    /**\n+     * Get the year of era component of the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to query.\n+     * @return the year of era extracted from the input.\n+     */\n+    public int get(long instant) {\n+        int year = getWrappedField().get(instant);\n+        if (year <= 0) {\n+            year = 1 - year;\n+        }\n+        return year;\n+    }\n+\n+    /**\n+     * Add the specified year to the specified time instant.\n+     * The amount added may be negative.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, int years) {\n+        return getWrappedField().add(instant, years);\n+    }\n+\n+    public long add(long instant, long years) {\n+        return getWrappedField().add(instant, years);\n+    }\n+\n+    /**\n+     * Add to the year component of the specified time instant\n+     * wrapping around within that component if necessary.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long instant, int years) {\n+        return getWrappedField().addWrapped(instant, years);\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    /**\n+     * Set the year component of the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param year  the year (0,292278994) to update the time to.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException  if year is invalid.\n+     */\n+    public long set(long instant, int year) {\n+        FieldUtils.verifyValueBounds(this, year, 1, getMaximumValue());\n+        if (iChronology.getYear(instant) <= 0) {\n+            year = 1 - year;\n+        }\n+        return super.set(instant, year);\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return getWrappedField().getMaximumValue();\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return getWrappedField().roundFloor(instant);\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        return getWrappedField().roundCeiling(instant);\n+    }\n+\n+    public long remainder(long instant) {\n+        return getWrappedField().remainder(instant);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.yearOfEra();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.field.DividedDateTimeField;\n+import org.joda.time.field.OffsetDateTimeField;\n+import org.joda.time.field.RemainderDateTimeField;\n+\n+/**\n+ * \n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ */\n+public final class GregorianChronology extends AbstractGJChronology {\n+\n+    static final long serialVersionUID = -861407383323710522L;\n+\n+    private static final long MILLIS_PER_YEAR =\n+        (long) (365.2425 * DateTimeConstants.MILLIS_PER_DAY);\n+\n+    private static final long MILLIS_PER_MONTH =\n+        (long) (365.2425 * DateTimeConstants.MILLIS_PER_DAY / 12);\n+\n+    /** Singleton instance of a UTC GregorianChronology */\n+    private static final GregorianChronology INSTANCE_UTC;\n+\n+    /** Cache of zone to chronology arrays */\n+    private static final Map cCache = new HashMap();\n+\n+    static {\n+        INSTANCE_UTC = getInstance(DateTimeZone.UTC);\n+    }\n+\n+    /**\n+     * Gets an instance of the GregorianChronology.\n+     * The time zone of the returned instance is UTC.\n+     * \n+     * @return a singleton UTC instance of the chronology\n+     */\n+    public static GregorianChronology getInstanceUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets an instance of the GregorianChronology in the default time zone.\n+     * \n+     * @return a chronology in the default time zone\n+     */\n+    public static GregorianChronology getInstance() {\n+        return getInstance(DateTimeZone.getDefault(), 4);\n+    }\n+\n+    /**\n+     * Gets an instance of the GregorianChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @return a chronology in the specified time zone\n+     */\n+    public static GregorianChronology getInstance(DateTimeZone zone) {\n+        return getInstance(zone, 4);\n+    }\n+\n+    /**\n+     * Gets an instance of the GregorianChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n+     * @return a chronology in the specified time zone\n+     */\n+    public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        GregorianChronology chrono;\n+        synchronized (cCache) {\n+            GregorianChronology[] chronos = (GregorianChronology[]) cCache.get(zone);\n+            if (chronos == null) {\n+                chronos = new GregorianChronology[7];\n+                cCache.put(zone, chronos);\n+            }\n+            try {\n+                chrono = chronos[minDaysInFirstWeek - 1];\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                throw new IllegalArgumentException\n+                    (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n+            }\n+            if (chrono == null) {\n+                if (zone == DateTimeZone.UTC) {\n+                    chrono = new GregorianChronology(null, null, minDaysInFirstWeek);\n+                } else {\n+                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n+                    chrono = new GregorianChronology\n+                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n+                }\n+                chronos[minDaysInFirstWeek - 1] = chrono;\n+            }\n+        }\n+        return chrono;\n+    }\n+\n+    // Constructors and instance variables\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n+        super(base, param, minDaysInFirstWeek);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return getInstance(getBase().getDateTimeZone());\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the Chronology in the UTC time zone.\n+     * \n+     * @return the chronology in UTC\n+     */\n+    public Chronology withUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets the Chronology in a specific time zone.\n+     * \n+     * @param zone  the zone to get the chronology in, null is default\n+     * @return the chronology\n+     */\n+    public Chronology withDateTimeZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getDateTimeZone()) {\n+            return this;\n+        }\n+        return getInstance(zone);\n+    }\n+\n+    protected void assemble(Fields fields) {\n+        if (getBase() == null) {\n+            super.assemble(fields);\n+        }\n+    }\n+\n+    boolean isLeapYear(int year) {\n+        return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0);\n+    }\n+\n+    long calculateFirstDayOfYearMillis(int year) {\n+        // Calculate relative to 2000 as that is on a 400 year boundary\n+        // and that makes the sum easier\n+        int relativeYear = year - 2000;\n+        // Initial value is just temporary.\n+        int leapYears = relativeYear / 100;\n+        if (relativeYear <= 0) {\n+            // Add 3 before shifting right since /4 and >>2 behave differently\n+            // on negative numbers. When the expression is written as\n+            // (relativeYear / 4) - (relativeYear / 100) + (relativeYear / 400),\n+            // it works for both positive and negative values, except this optimization\n+            // eliminates two divisions.\n+            leapYears = ((relativeYear + 3) >> 2) - leapYears + ((leapYears + 3) >> 2);\n+        } else {\n+            leapYears = (relativeYear >> 2) - leapYears + (leapYears >> 2);\n+            // For post 2000 an adjustment is needed as jan1st is before leap day\n+            if (!isLeapYear(year)) {\n+                leapYears++;\n+            }\n+        }\n+        \n+        long millis = (relativeYear * 365L + leapYears)\n+            * (long)DateTimeConstants.MILLIS_PER_DAY;\n+        \n+        // Previous line was reduced from this to eliminate a multiplication.\n+        // millis = ((relativeYear - leapYears) * 365L + leapYears * 366) * MILLIS_PER_DAY;\n+        // (x - y)*c + y*(c + 1) => x*c - y*c + y*c + y => x*c + y\n+        \n+        return millis + MILLIS_1970_TO_2000;\n+    }\n+\n+    int getMinYear() {\n+        // The lowest year that can be fully supported.\n+        return -292275054;\n+    }\n+\n+    int getMaxYear() {\n+        // The highest year that can be fully supported.\n+        return 292278993;\n+    }\n+\n+    long getAverageMillisPerYear() {\n+        return MILLIS_PER_YEAR;\n+    }\n+\n+    long getAverageMillisPerMonth() {\n+        return MILLIS_PER_MONTH;\n+    }\n+\n+    long getApproxMillisAtEpoch() {\n+        return 1970L * MILLIS_PER_YEAR;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.field.DividedDateTimeField;\n+import org.joda.time.field.RemainderDateTimeField;\n+\n+/**\n+ * ISOChronology provides access to the individual date time fields \n+ * for the ISO8601 defined chronological calendar system. When ISO \n+ * does not define a field, but it can be determined (such as AM/PM)\n+ * it is included.\n+ * <p>\n+ * ISOChronology is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class ISOChronology extends AssembledChronology {\n+    \n+    static final long serialVersionUID = -6212696554273812441L;\n+\n+    /** Singleton instance of a UTC ISOChronology */\n+    private static final ISOChronology INSTANCE_UTC =\n+        new ISOChronology(GregorianChronology.getInstanceUTC());\n+        \n+    private static final int FAST_CACHE_SIZE = 64;\n+\n+    /** Fast cache of zone to chronology */\n+    private static final ISOChronology[] cFastCache = new ISOChronology[FAST_CACHE_SIZE];\n+\n+    /** Cache of zone to chronology */\n+    private static final Map cCache = new HashMap();\n+    static {\n+        cCache.put(DateTimeZone.UTC, INSTANCE_UTC);\n+    }\n+\n+    /**\n+     * Gets an instance of the ISOChronology.\n+     * The time zone of the returned instance is UTC.\n+     * \n+     * @return a singleton UTC instance of the chronology\n+     */\n+    public static ISOChronology getInstanceUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets an instance of the ISOChronology in the default time zone.\n+     * \n+     * @return a chronology in the default time zone\n+     */\n+    public static ISOChronology getInstance() {\n+        return getInstance(DateTimeZone.getDefault());\n+    }\n+\n+    /**\n+     * Gets an instance of the ISOChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @return a chronology in the specified time zone\n+     */\n+    public static ISOChronology getInstance(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\n+        ISOChronology chrono = cFastCache[index];\n+        if (chrono != null && chrono.getDateTimeZone() == zone) {\n+            return chrono;\n+        }\n+        synchronized (cCache) {\n+            chrono = (ISOChronology) cCache.get(zone);\n+            if (chrono == null) {\n+                chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\n+                cCache.put(zone, chrono);\n+            }\n+        }\n+        cFastCache[index] = chrono;\n+        return chrono;\n+    }\n+\n+    // Constructors and instance variables\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    private ISOChronology(Chronology base) {\n+        super(base, null);\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the Chronology in the UTC time zone.\n+     * \n+     * @return the chronology in UTC\n+     */\n+    public Chronology withUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets the Chronology in a specific time zone.\n+     * \n+     * @param zone  the zone to get the chronology in, null is default\n+     * @return the chronology\n+     */\n+    public Chronology withDateTimeZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getDateTimeZone()) {\n+            return this;\n+        }\n+        return getInstance(zone);\n+    }\n+\n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging toString.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        String str = \"ISOChronology\";\n+        DateTimeZone zone = getDateTimeZone();\n+        if (zone != null) {\n+            str = str + '[' + zone.getID() + ']';\n+        }\n+        return str;\n+    }\n+\n+    protected void assemble(Fields fields) {\n+        if (getBase().getDateTimeZone() == DateTimeZone.UTC) {\n+            // Use zero based century and year of century.\n+            fields.centuryOfEra = new DividedDateTimeField\n+                (fields.yearOfEra, \"centuryOfEra\", \"centuries\", 100);\n+            fields.yearOfCentury = new RemainderDateTimeField\n+                ((DividedDateTimeField)fields.centuryOfEra, \"yearOfCentury\");\n+\n+            fields.centuries = fields.centuryOfEra.getDurationField();\n+        }\n+    }\n+\n+    /**\n+     * Serialize ISOChronology instances using a small stub. This reduces the\n+     * serialized size, and deserialized instances come from the cache.\n+     */\n+    private Object writeReplace() {\n+        return new Stub(getDateTimeZone());\n+    }\n+\n+    private static final class Stub implements Serializable {\n+        static final long serialVersionUID = -6212696554273812441L;\n+\n+        private transient DateTimeZone iZone;\n+\n+        Stub(DateTimeZone zone) {\n+            iZone = zone;\n+        }\n+\n+        private Object readResolve() {\n+            return ISOChronology.getInstance(iZone);\n+        }\n+\n+        private void writeObject(ObjectOutputStream out) throws IOException {\n+            out.writeObject(iZone);\n+        }\n+\n+        private void readObject(ObjectInputStream in)\n+            throws IOException, ClassNotFoundException\n+        {\n+            iZone = (DateTimeZone)in.readObject();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.field.DelegatedDateTimeField;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ *\n+ * @author Guy Allard\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ */\n+public final class JulianChronology extends AbstractGJChronology {\n+\n+    static final long serialVersionUID = -8731039522547897247L;\n+\n+    private static final long MILLIS_PER_YEAR =\n+        (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY);\n+\n+    private static final long MILLIS_PER_MONTH =\n+        (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY / 12);\n+\n+    /** Singleton instance of a UTC JulianChronology */\n+    private static final JulianChronology INSTANCE_UTC;\n+\n+    /** Cache of zone to chronology arrays */\n+    private static final Map cCache = new HashMap();\n+\n+    static {\n+        INSTANCE_UTC = getInstance(DateTimeZone.UTC);\n+    }\n+\n+    static int adjustYearForSet(int year) {\n+        if (year <= 0) {\n+            if (year == 0) {\n+                throw new IllegalArgumentException(\"Invalid year: \" + year);\n+            }\n+            year++;\n+        }\n+        return year;\n+    }\n+\n+    /**\n+     * Gets an instance of the JulianChronology.\n+     * The time zone of the returned instance is UTC.\n+     * \n+     * @return a singleton UTC instance of the chronology\n+     */\n+    public static JulianChronology getInstanceUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets an instance of the JulianChronology in the default time zone.\n+     * \n+     * @return a chronology in the default time zone\n+     */\n+    public static JulianChronology getInstance() {\n+        return getInstance(DateTimeZone.getDefault(), 4);\n+    }\n+\n+    /**\n+     * Gets an instance of the JulianChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @return a chronology in the specified time zone\n+     */\n+    public static JulianChronology getInstance(DateTimeZone zone) {\n+        return getInstance(zone, 4);\n+    }\n+\n+    /**\n+     * Gets an instance of the JulianChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n+     * @return a chronology in the specified time zone\n+     */\n+    public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        JulianChronology chrono;\n+        synchronized (cCache) {\n+            JulianChronology[] chronos = (JulianChronology[]) cCache.get(zone);\n+            if (chronos == null) {\n+                chronos = new JulianChronology[7];\n+                cCache.put(zone, chronos);\n+            }\n+            try {\n+                chrono = chronos[minDaysInFirstWeek - 1];\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                throw new IllegalArgumentException\n+                    (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n+            }\n+            if (chrono == null) {\n+                if (zone == DateTimeZone.UTC) {\n+                    chrono = new JulianChronology(null, null, minDaysInFirstWeek);\n+                } else {\n+                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n+                    chrono = new JulianChronology\n+                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n+                }\n+                chronos[minDaysInFirstWeek - 1] = chrono;\n+            }\n+        }\n+        return chrono;\n+    }\n+\n+    // Constructors and instance variables\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    JulianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n+        super(base, param, minDaysInFirstWeek);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return getInstance(getBase().getDateTimeZone());\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the Chronology in the UTC time zone.\n+     * \n+     * @return the chronology in UTC\n+     */\n+    public Chronology withUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets the Chronology in a specific time zone.\n+     * \n+     * @param zone  the zone to get the chronology in, null is default\n+     * @return the chronology\n+     */\n+    public Chronology withDateTimeZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getDateTimeZone()) {\n+            return this;\n+        }\n+        return getInstance(zone);\n+    }\n+\n+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException\n+    {\n+        return super.getDateOnlyMillis(adjustYearForSet(year), monthOfYear, dayOfMonth);\n+    }\n+\n+    boolean isLeapYear(int year) {\n+        return (year & 3) == 0;\n+    }\n+\n+    long calculateFirstDayOfYearMillis(int year) {\n+        // Java epoch is 1970-01-01 Gregorian which is 1969-12-19 Julian.\n+        // Calculate relative to the nearest leap year and account for the\n+        // difference later.\n+\n+        int relativeYear = year - 1968;\n+        int leapYears;\n+        if (relativeYear <= 0) {\n+            // Add 3 before shifting right since /4 and >>2 behave differently\n+            // on negative numbers.\n+            leapYears = (relativeYear + 3) >> 2;\n+        } else {\n+            leapYears = relativeYear >> 2;\n+            // For post 1968 an adjustment is needed as jan1st is before leap day\n+            if (!isLeapYear(year)) {\n+                leapYears++;\n+            }\n+        }\n+        \n+        long millis = (relativeYear * 365L + leapYears)\n+            * (long)DateTimeConstants.MILLIS_PER_DAY;\n+\n+        // Adjust to account for difference between 1968-01-01 and 1969-12-19.\n+\n+        return millis - (366L + 352) * DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    int getMinYear() {\n+        // The lowest year that can be fully supported.\n+        return -292269053;\n+    }\n+\n+    int getMaxYear() {\n+        // The highest year that can be fully supported.\n+        return 292272992;\n+    }\n+\n+    long getAverageMillisPerYear() {\n+        return MILLIS_PER_YEAR;\n+    }\n+\n+    long getAverageMillisPerMonth() {\n+        return MILLIS_PER_MONTH;\n+    }\n+\n+    long getApproxMillisAtEpoch() {\n+        return 1969L * MILLIS_PER_YEAR + 352L * DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    protected void assemble(Fields fields) {\n+        if (getBase() == null) {\n+            super.assemble(fields);\n+            // Julian chronology has no year zero.\n+            fields.year = new NoYearZeroField(this, fields.year);\n+            fields.weekyear = new NoWeekyearZeroField(this, fields.weekyear);\n+        }\n+    }\n+\n+    static class NoYearZeroField extends DelegatedDateTimeField {\n+        static final long serialVersionUID = -8869148464118507846L;\n+\n+        final AbstractGJChronology iChronology;\n+        private transient int iMinYear;\n+\n+        NoYearZeroField(AbstractGJChronology chronology, DateTimeField field) {\n+            super(field);\n+            iChronology = chronology;\n+            int min = super.getMinimumValue();\n+            if (min < 0) {\n+                iMinYear = min - 1;\n+            } else if (min == 0) {\n+                iMinYear = 1;\n+            } else {\n+                iMinYear = min;\n+            }\n+        }\n+        \n+        public int get(long millis) {\n+            int year = super.get(millis);\n+            if (year <= 0) {\n+                year--;\n+            }\n+            return year;\n+        }\n+\n+        public long set(long millis, int year) {\n+            FieldUtils.verifyValueBounds(this, year, iMinYear, getMaximumValue());\n+            return super.set(millis, adjustYearForSet(year));\n+        }\n+\n+        public int getMinimumValue() {\n+            return iMinYear;\n+        }\n+\n+        private Object readResolve() {\n+            return iChronology.year();\n+        }\n+    }\n+\n+    static class NoWeekyearZeroField extends NoYearZeroField {\n+        static final long serialVersionUID = -5013429014495501104L;\n+\n+        NoWeekyearZeroField(AbstractGJChronology chronology, DateTimeField field) {\n+            super(chronology, field);\n+        }\n+        \n+        private Object readResolve() {\n+            return iChronology.weekyear();\n+        }\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeZone;\n+import org.joda.time.field.LenientDateTimeField;\n \n /**\n  * Wraps another chronology, ensuring all the fields are lenient.\n  * @see LenientDateTimeField\n  * @see StrictChronology\n  */\n-public class LenientChronology extends DelegatedChronology {\n+public final class LenientChronology extends AssembledChronology {\n \n     static final long serialVersionUID = -3148237568046877177L;\n \n-    private transient DateTimeField iYearField;\n-    private transient DateTimeField iYearOfEraField;\n-    private transient DateTimeField iYearOfCenturyField;\n-    private transient DateTimeField iCenturyOfEraField;\n-    private transient DateTimeField iEraField;\n-    private transient DateTimeField iDayOfWeekField;\n-    private transient DateTimeField iDayOfMonthField;\n-    private transient DateTimeField iDayOfYearField;\n-    private transient DateTimeField iMonthOfYearField;\n-    private transient DateTimeField iWeekOfWeekyearField;\n-    private transient DateTimeField iWeekyearField;\n-\n-    private transient DateTimeField iMillisOfSecondField;\n-    private transient DateTimeField iMillisOfDayField;\n-    private transient DateTimeField iSecondOfMinuteField;\n-    private transient DateTimeField iSecondOfDayField;\n-    private transient DateTimeField iMinuteOfHourField;\n-    private transient DateTimeField iMinuteOfDayField;\n-    private transient DateTimeField iHourOfDayField;\n-    private transient DateTimeField iHourOfHalfdayField;\n-    private transient DateTimeField iClockhourOfDayField;\n-    private transient DateTimeField iClockhourOfHalfdayField;\n-    private transient DateTimeField iHalfdayOfDayField;\n+    /**\n+     * Create a LenientChronology for any chronology.\n+     *\n+     * @param base the chronology to wrap\n+     * @throws IllegalArgumentException if chronology is null\n+     */\n+    public static LenientChronology getInstance(Chronology base) {\n+        if (base == null) {\n+            throw new IllegalArgumentException(\"Must supply a chronology\");\n+        }\n+        return new LenientChronology(base);\n+    }\n \n     private transient Chronology iWithUTC;\n \n     /**\n      * Create a LenientChronology for any chronology.\n      *\n-     * @param chrono the chronology\n-     * @throws IllegalArgumentException if chronology is null\n+     * @param base the chronology to wrap\n      */\n-    public LenientChronology(Chronology chrono) {\n-        super(chrono);\n+    private LenientChronology(Chronology base) {\n+        super(base, null);\n     }\n \n     public Chronology withUTC() {\n         if (iWithUTC == null) {\n-            iWithUTC = new LenientChronology(getWrappedChronology().withUTC());\n+            if (getDateTimeZone() == DateTimeZone.UTC) {\n+                iWithUTC = this;\n+            } else {\n+                iWithUTC = LenientChronology.getInstance(getBase().withUTC());\n+            }\n         }\n         return iWithUTC;\n     }\n \n     public Chronology withDateTimeZone(DateTimeZone zone) {\n-        return new LenientChronology(getWrappedChronology().withDateTimeZone(zone));\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == DateTimeZone.UTC) {\n+            return withUTC();\n+        }\n+        if (zone == getDateTimeZone()) {\n+            return this;\n+        }\n+        return LenientChronology.getInstance(getBase().withDateTimeZone(zone));\n     }\n \n-    /**\n-     * Overridden to ensure lenient fields are used.\n-     */\n-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n-        throws IllegalArgumentException\n-    {\n-        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n+    protected void assemble(Fields fields) {\n+        fields.year = convertField(fields.year);\n+        fields.yearOfEra = convertField(fields.yearOfEra);\n+        fields.yearOfCentury = convertField(fields.yearOfCentury);\n+        fields.centuryOfEra = convertField(fields.centuryOfEra);\n+        fields.era = convertField(fields.era);\n+        fields.dayOfWeek = convertField(fields.dayOfWeek);\n+        fields.dayOfMonth = convertField(fields.dayOfMonth);\n+        fields.dayOfYear = convertField(fields.dayOfYear);\n+        fields.monthOfYear = convertField(fields.monthOfYear);\n+        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear);\n+        fields.weekyear = convertField(fields.weekyear);\n+\n+        fields.millisOfSecond = convertField(fields.millisOfSecond);\n+        fields.millisOfDay = convertField(fields.millisOfDay);\n+        fields.secondOfMinute = convertField(fields.secondOfMinute);\n+        fields.secondOfDay = convertField(fields.secondOfDay);\n+        fields.minuteOfHour = convertField(fields.minuteOfHour);\n+        fields.minuteOfDay = convertField(fields.minuteOfDay);\n+        fields.hourOfDay = convertField(fields.hourOfDay);\n+        fields.hourOfHalfday = convertField(fields.hourOfHalfday);\n+        fields.clockhourOfDay = convertField(fields.clockhourOfDay);\n+        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday);\n+        fields.halfdayOfDay = convertField(fields.halfdayOfDay);\n     }\n \n-    /**\n-     * Overridden to ensure lenient fields are used.\n-     */\n-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        long instant = hourOfDay().set(0, hourOfDay);\n-        instant = minuteOfHour().set(instant, minuteOfHour);\n-        instant = secondOfMinute().set(instant, secondOfMinute);\n-        return millisOfSecond().set(instant, millisOfSecond);\n-    }\n-\n-    /**\n-     * Overridden to ensure lenient fields are used.\n-     */\n-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n-                                  int millisOfDay)\n-        throws IllegalArgumentException\n-    {\n-        long instant = year().set(0, year);\n-        instant = monthOfYear().set(instant, monthOfYear);\n-        instant = dayOfMonth().set(instant, dayOfMonth);\n-        return millisOfDay().set(instant, millisOfDay);\n-    }\n-\n-    /**\n-     * Overridden to ensure lenient fields are used.\n-     */\n-    public long getDateTimeMillis(long instant,\n-                                  int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        instant = hourOfDay().set(instant, hourOfDay);\n-        instant = minuteOfHour().set(instant, minuteOfHour);\n-        instant = secondOfMinute().set(instant, secondOfMinute);\n-        return millisOfSecond().set(instant, millisOfSecond);\n-    }\n-\n-    /**\n-     * Overridden to ensure lenient fields are used.\n-     */\n-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n-                                  int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        long instant = year().set(0, year);\n-        instant = monthOfYear().set(instant, monthOfYear);\n-        instant = dayOfMonth().set(instant, dayOfMonth);\n-        instant = hourOfDay().set(instant, hourOfDay);\n-        instant = minuteOfHour().set(instant, minuteOfHour);\n-        instant = secondOfMinute().set(instant, secondOfMinute);\n-        return millisOfSecond().set(instant, millisOfSecond);\n-    }\n-\n-    // Milliseconds\n-    //------------------------------------------------------------\n-\n-    public DateTimeField millisOfSecond() {\n-        if (iMillisOfDayField == null) {\n-            iMillisOfSecondField = LenientDateTimeField.getInstance(super.millisOfSecond());\n-        }\n-        return iMillisOfSecondField;\n-    }\n-\n-    public DateTimeField millisOfDay() {\n-        if (iMillisOfDayField == null) {\n-            iMillisOfDayField = LenientDateTimeField.getInstance(super.millisOfDay());\n-        }\n-        return iMillisOfDayField;\n-    }\n-\n-    // Seconds\n-    //------------------------------------------------------------\n-\n-    public DateTimeField secondOfMinute() {\n-        if (iSecondOfMinuteField == null) {\n-            iSecondOfMinuteField = LenientDateTimeField.getInstance(super.secondOfMinute());\n-        }\n-        return iSecondOfMinuteField;\n-    }\n-\n-    public DateTimeField secondOfDay() {\n-        if (iSecondOfDayField == null) {\n-            iSecondOfDayField = LenientDateTimeField.getInstance(super.secondOfDay());\n-        }\n-        return iSecondOfDayField;\n-    }\n-\n-    // Minutes\n-    //------------------------------------------------------------\n-\n-    public DateTimeField minuteOfHour() {\n-        if (iMinuteOfHourField == null) {\n-            iMinuteOfHourField = LenientDateTimeField.getInstance(super.minuteOfHour());\n-        }\n-        return iMinuteOfHourField;\n-    }\n-\n-    public DateTimeField minuteOfDay() {\n-        if (iMinuteOfDayField == null) {\n-            iMinuteOfDayField = LenientDateTimeField.getInstance(super.minuteOfDay());\n-        }\n-        return iMinuteOfDayField;\n-    }\n-\n-    // Hours\n-    //------------------------------------------------------------\n-\n-    public DateTimeField hourOfDay() {\n-        if (iHourOfDayField == null) {\n-            iHourOfDayField = LenientDateTimeField.getInstance(super.hourOfDay());\n-        }\n-        return iHourOfDayField;\n-    }\n-\n-    public DateTimeField clockhourOfDay() {\n-        if (iClockhourOfDayField == null) {\n-            iClockhourOfDayField = LenientDateTimeField.getInstance(super.clockhourOfDay());\n-        }\n-        return iClockhourOfDayField;\n-    }\n-\n-    public DateTimeField hourOfHalfday() {\n-        if (iHourOfHalfdayField == null) {\n-            iHourOfHalfdayField = LenientDateTimeField.getInstance(super.hourOfHalfday());\n-        }\n-        return iHourOfHalfdayField;\n-    }\n-\n-    public DateTimeField clockhourOfHalfday() {\n-        if (iClockhourOfHalfdayField == null) {\n-            iClockhourOfHalfdayField =\n-                LenientDateTimeField.getInstance(super.clockhourOfHalfday());\n-        }\n-        return iClockhourOfHalfdayField;\n-    }\n-\n-    public DateTimeField halfdayOfDay() {\n-        if (iHalfdayOfDayField == null) {\n-            iHalfdayOfDayField = LenientDateTimeField.getInstance(super.halfdayOfDay());\n-        }\n-        return iHalfdayOfDayField;\n-    }\n-\n-    // Day\n-    //------------------------------------------------------------\n-\n-    public DateTimeField dayOfWeek() {\n-        if (iDayOfWeekField == null) {\n-            iDayOfWeekField = LenientDateTimeField.getInstance(super.dayOfWeek());\n-        }\n-        return iDayOfWeekField;\n-    }\n-\n-    public DateTimeField dayOfMonth() {\n-        if (iDayOfMonthField == null) {\n-            iDayOfMonthField = LenientDateTimeField.getInstance(super.dayOfMonth());\n-        }\n-        return iDayOfMonthField;\n-    }\n-\n-    public DateTimeField dayOfYear() {\n-        if (iDayOfYearField == null) {\n-            iDayOfYearField = LenientDateTimeField.getInstance(super.dayOfYear());\n-        }\n-        return iDayOfYearField;\n-    }\n-\n-    // Week\n-    //------------------------------------------------------------\n-\n-    public DateTimeField weekOfWeekyear() {\n-        if (iWeekOfWeekyearField == null) {\n-            iWeekOfWeekyearField = LenientDateTimeField.getInstance(super.weekOfWeekyear());\n-        }\n-        return iWeekOfWeekyearField;\n-    }\n-\n-    public DateTimeField weekyear() {\n-        if (iWeekyearField == null) {\n-            iWeekyearField = LenientDateTimeField.getInstance(super.weekyear());\n-        }\n-        return iWeekyearField;\n-    }\n-\n-    // Month\n-    //------------------------------------------------------------\n-\n-    public DateTimeField monthOfYear() {\n-        if (iMonthOfYearField == null) {\n-            iMonthOfYearField = LenientDateTimeField.getInstance(super.monthOfYear());\n-        }\n-        return iMonthOfYearField;\n-    }\n-\n-    // Year\n-    //------------------------------------------------------------\n-\n-    public DateTimeField year() {\n-        if (iYearField == null) {\n-            iYearField = LenientDateTimeField.getInstance(super.year());\n-        }\n-        return iYearField;\n-    }\n-\n-    public DateTimeField yearOfEra() {\n-        if (iYearOfEraField == null) {\n-            iYearOfEraField = LenientDateTimeField.getInstance(super.yearOfEra());\n-        }\n-        return iYearOfEraField;\n-    }\n-\n-    public DateTimeField yearOfCentury() {\n-        if (iYearOfCenturyField == null) {\n-            iYearOfCenturyField = LenientDateTimeField.getInstance(super.yearOfCentury());\n-        }\n-        return iYearOfCenturyField;\n-    }\n-\n-    public DateTimeField centuryOfEra() {\n-        if (iCenturyOfEraField == null) {\n-            iCenturyOfEraField = LenientDateTimeField.getInstance(super.centuryOfEra());\n-        }\n-        return iCenturyOfEraField;\n-    }\n-\n-    public DateTimeField era() {\n-        if (iEraField == null) {\n-            iEraField = LenientDateTimeField.getInstance(super.era());\n-        }\n-        return iEraField;\n+    private static final DateTimeField convertField(DateTimeField field) {\n+        return LenientDateTimeField.getInstance(field);\n     }\n \n     public String toString() {\n-        return \"LenientChronology[\" + getWrappedChronology().toString() + ']';\n+        return \"LenientChronology[\" + getBase().toString() + ']';\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java\n import org.joda.time.DurationField;\n import org.joda.time.MutableDateTime;\n import org.joda.time.ReadableDateTime;\n+import org.joda.time.field.DecoratedDateTimeField;\n+import org.joda.time.field.DecoratedDurationField;\n import org.joda.time.format.DateTimePrinter;\n import org.joda.time.format.ISODateTimeFormat;\n \n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public class LimitChronology extends Chronology {\n+public final class LimitChronology extends AssembledChronology {\n \n     static final long serialVersionUID = 7670866536893052522L;\n \n-    private final Chronology iChronology;\n+    /**\n+     * Wraps another chronology, with datetime limits. When withUTC or\n+     * withDateTimeZone is called, the returned LimitChronology instance has\n+     * the same limits, except they are time zone adjusted.\n+     *\n+     * @param base base chronology to wrap\n+     * @param lowerLimit  inclusive lower limit, or null if none\n+     * @param upperLimit  exclusive upper limit, or null if none\n+     * @throws IllegalArgumentException if chronology is null or limits are invalid\n+     */\n+    public static LimitChronology getInstance(Chronology base,\n+                                              ReadableDateTime lowerLimit,\n+                                              ReadableDateTime upperLimit) {\n+        if (base == null) {\n+            throw new IllegalArgumentException(\"Must supply a chronology\");\n+        }\n+\n+        lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime();\n+        upperLimit = upperLimit == null ? null : upperLimit.toDateTime();\n+\n+        if (lowerLimit != null && upperLimit != null) {\n+            if (!lowerLimit.isBefore(upperLimit)) {\n+                throw new IllegalArgumentException\n+                    (\"The lower limit must be come before than the upper limit\");\n+            }\n+        }\n+\n+        return new LimitChronology(base, (DateTime)lowerLimit, (DateTime)upperLimit);\n+    }\n \n     final DateTime iLowerLimit;\n     final DateTime iUpperLimit;\n \n     private transient LimitChronology iWithUTC;\n-\n-    private transient DurationField iErasField;\n-    private transient DurationField iCenturiesField;\n-    private transient DurationField iYearsField;\n-    private transient DurationField iMonthsField;\n-    private transient DurationField iWeekyearsField;\n-    private transient DurationField iWeeksField;\n-    private transient DurationField iDaysField;\n-\n-    private transient DurationField iHoursField;\n-    private transient DurationField iMinutesField;\n-    private transient DurationField iSecondsField;\n-    private transient DurationField iMillisField;\n-\n-    private transient DateTimeField iYearField;\n-    private transient DateTimeField iYearOfEraField;\n-    private transient DateTimeField iYearOfCenturyField;\n-    private transient DateTimeField iCenturyOfEraField;\n-    private transient DateTimeField iEraField;\n-    private transient DateTimeField iDayOfWeekField;\n-    private transient DateTimeField iDayOfMonthField;\n-    private transient DateTimeField iDayOfYearField;\n-    private transient DateTimeField iMonthOfYearField;\n-    private transient DateTimeField iWeekOfWeekyearField;\n-    private transient DateTimeField iWeekyearField;\n-\n-    private transient DateTimeField iMillisOfSecondField;\n-    private transient DateTimeField iMillisOfDayField;\n-    private transient DateTimeField iSecondOfMinuteField;\n-    private transient DateTimeField iSecondOfDayField;\n-    private transient DateTimeField iMinuteOfHourField;\n-    private transient DateTimeField iMinuteOfDayField;\n-    private transient DateTimeField iHourOfDayField;\n-    private transient DateTimeField iHourOfHalfdayField;\n-    private transient DateTimeField iClockhourOfDayField;\n-    private transient DateTimeField iClockhourOfHalfdayField;\n-    private transient DateTimeField iHalfdayOfDayField;\n \n     /**\n      * Wraps another chronology, with datetime limits. When withUTC or\n      *\n      * @param lowerLimit  inclusive lower limit, or null if none\n      * @param upperLimit  exclusive upper limit, or null if none\n-     * @throws IllegalArgumentException if chronology is null or limits are invalid\n      */\n-    public LimitChronology(Chronology chrono,\n-                           ReadableDateTime lowerLimit, ReadableDateTime upperLimit) {\n-        if (chrono == null) {\n-            throw new IllegalArgumentException(\"Must supply a chronology\");\n-        }\n-\n-        iChronology = chrono;\n-\n-        iLowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime();\n-        iUpperLimit = upperLimit == null ? null : upperLimit.toDateTime();\n-\n-        if (iLowerLimit != null && iUpperLimit != null) {\n-            if (!iLowerLimit.isBefore(iUpperLimit)) {\n-                throw new IllegalArgumentException\n-                    (\"The lower limit must be come before than the upper limit\");\n-            }\n-        }\n-\n-        setFields();\n-    }\n-\n-    private void setFields() {\n-        Chronology c = iChronology;\n-\n-        // Keep a local cache of converted fields so as not to create redundant\n-        // objects.\n-        HashMap converted = new HashMap();\n-\n-        // Convert duration fields...\n-\n-        iErasField = convertField(c.eras(), converted);\n-        iCenturiesField = convertField(c.centuries(), converted);\n-        iYearsField = convertField(c.years(), converted);\n-        iMonthsField = convertField(c.months(), converted);\n-        iWeekyearsField = convertField(c.weekyears(), converted);\n-        iWeeksField = convertField(c.weeks(), converted);\n-        iDaysField = convertField(c.days(), converted);\n-\n-        iHoursField = convertField(c.hours(), converted);\n-        iMinutesField = convertField(c.minutes(), converted);\n-        iSecondsField = convertField(c.seconds(), converted);\n-        iMillisField = convertField(c.millis(), converted);\n-\n-        // Convert datetime fields...\n-\n-        iYearField = convertField(c.year(), converted);\n-        iYearOfEraField = convertField(c.yearOfEra(), converted);\n-        iYearOfCenturyField = convertField(c.yearOfCentury(), converted);\n-        iCenturyOfEraField = convertField(c.centuryOfEra(), converted);\n-        iEraField = convertField(c.era(), converted);\n-        iDayOfWeekField = convertField(c.dayOfWeek(), converted);\n-        iDayOfMonthField = convertField(c.dayOfMonth(), converted);\n-        iDayOfYearField = convertField(c.dayOfYear(), converted);\n-        iMonthOfYearField = convertField(c.monthOfYear(), converted);\n-        iWeekOfWeekyearField = convertField(c.weekOfWeekyear(), converted);\n-        iWeekyearField = convertField(c.weekyear(), converted);\n-\n-        iMillisOfSecondField = convertField(c.millisOfSecond(), converted);\n-        iMillisOfDayField = convertField(c.millisOfDay(), converted);\n-        iSecondOfMinuteField = convertField(c.secondOfMinute(), converted);\n-        iSecondOfDayField = convertField(c.secondOfDay(), converted);\n-        iMinuteOfHourField = convertField(c.minuteOfHour(), converted);\n-        iMinuteOfDayField = convertField(c.minuteOfDay(), converted);\n-        iHourOfDayField = convertField(c.hourOfDay(), converted);\n-        iHourOfHalfdayField = convertField(c.hourOfHalfday(), converted);\n-        iClockhourOfDayField = convertField(c.clockhourOfDay(), converted);\n-        iClockhourOfHalfdayField = convertField(c.clockhourOfHalfday(), converted);\n-        iHalfdayOfDayField = convertField(c.halfdayOfDay(), converted);\n-    }\n-\n-    private DurationField convertField(DurationField field, HashMap converted) {\n-        if (field == null || !field.isSupported()) {\n-            return field;\n-        }\n-        if (converted.containsKey(field)) {\n-            return (DurationField)converted.get(field);\n-        }\n-        LimitDurationField limitField = new LimitDurationField(field);\n-        converted.put(field, limitField);\n-        return limitField;\n-    }\n-\n-    private DateTimeField convertField(DateTimeField field, HashMap converted) {\n-        if (field == null || !field.isSupported()) {\n-            return field;\n-        }\n-        if (converted.containsKey(field)) {\n-            return (DateTimeField)converted.get(field);\n-        }\n-        LimitDateTimeField limitField =\n-            new LimitDateTimeField(field,\n-                                   convertField(field.getDurationField(), converted),\n-                                   convertField(field.getRangeDurationField(), converted),\n-                                   convertField(field.getLeapDurationField(), converted));\n-        converted.put(field, limitField);\n-        return limitField;\n+    private LimitChronology(Chronology base,\n+                            DateTime lowerLimit, DateTime upperLimit) {\n+        super(base, null);\n+        // These can be set after assembly.\n+        iLowerLimit = lowerLimit;\n+        iUpperLimit = upperLimit;\n     }\n \n     /**\n      * \n      * @return upper limit\n      */\n-    public DateTime getUpperBound() {\n+    public DateTime getUpperLimit() {\n         return iUpperLimit;\n-    }\n-\n-    /**\n-     * Gets the wrapped chronology.\n-     * \n-     * @return the wrapped Chronology\n-     */\n-    protected Chronology getWrappedChronology() {\n-        return iChronology;\n     }\n \n     /**\n             upperLimit = mdt.toDateTime();\n         }\n         \n-        LimitChronology chrono = new LimitChronology\n-            (iChronology.withDateTimeZone(zone), lowerLimit, upperLimit);\n+        LimitChronology chrono = getInstance\n+            (getBase().withDateTimeZone(zone), lowerLimit, upperLimit);\n \n         if (zone == DateTimeZone.UTC) {\n             iWithUTC = chrono;\n         return chrono;\n     }\n \n-    public DateTimeZone getDateTimeZone() {\n-        return iChronology.getDateTimeZone();\n-    }\n-\n     public long getDateOnlyMillis(long instant) {\n         checkLimits(instant, null);\n-        instant = iChronology.getDateOnlyMillis(instant);\n+        instant = getBase().getDateOnlyMillis(instant);\n         checkLimits(instant, \"resulting\");\n         return instant;\n     }\n     public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n         throws IllegalArgumentException\n     {\n-        long instant = iChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);\n+        long instant = getBase().getDateOnlyMillis(year, monthOfYear, dayOfMonth);\n         checkLimits(instant, \"resulting\");\n         return instant;\n     }\n \n     public long getTimeOnlyMillis(long instant) {\n         checkLimits(instant, null);\n-        instant = iChronology.getTimeOnlyMillis(instant);\n+        instant = getBase().getTimeOnlyMillis(instant);\n         checkLimits(instant, \"resulting\");\n         return instant;\n     }\n                                   int secondOfMinute, int millisOfSecond)\n         throws IllegalArgumentException\n     {\n-        long instant = iChronology.getTimeOnlyMillis\n+        long instant = getBase().getTimeOnlyMillis\n             (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n         checkLimits(instant, \"resulting\");\n         return instant;\n                                   int millisOfDay)\n         throws IllegalArgumentException\n     {\n-        long instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n+        long instant = getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n         checkLimits(instant, \"resulting\");\n         return instant;\n     }\n         throws IllegalArgumentException\n     {\n         checkLimits(instant, null);\n-        instant = iChronology.getDateTimeMillis\n+        instant = getBase().getDateTimeMillis\n             (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n         checkLimits(instant, \"resulting\");\n         return instant;\n                                   int secondOfMinute, int millisOfSecond)\n         throws IllegalArgumentException\n     {\n-        long instant = iChronology.getDateTimeMillis\n+        long instant = getBase().getDateTimeMillis\n             (year, monthOfYear, dayOfMonth,\n              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n         checkLimits(instant, \"resulting\");\n         return instant;\n     }\n \n-    // Milliseconds\n-    //------------------------------------------------------------\n-\n-    public DurationField millis() {\n-        return iMillisField;\n-    }\n-\n-    public DateTimeField millisOfSecond() {\n-        return iMillisOfSecondField;\n-    }\n-\n-    public DateTimeField millisOfDay() {\n-        return iMillisOfDayField;\n-    }\n-\n-    // Seconds\n-    //------------------------------------------------------------\n-\n-    public DurationField seconds() {\n-        return iSecondsField;\n-    }\n-\n-    public DateTimeField secondOfMinute() {\n-        return iSecondOfMinuteField;\n-    }\n-\n-    public DateTimeField secondOfDay() {\n-        return iSecondOfDayField;\n-    }\n-\n-    // Minutes\n-    //------------------------------------------------------------\n-\n-    public DurationField minutes() {\n-        return iMinutesField;\n-    }\n-\n-    public DateTimeField minuteOfHour() {\n-        return iMinuteOfHourField;\n-    }\n-\n-    public DateTimeField minuteOfDay() {\n-        return iMinuteOfDayField;\n-    }\n-\n-    // Hours\n-    //------------------------------------------------------------\n-\n-    public DurationField hours() {\n-        return iHoursField;\n-    }\n-\n-    public DateTimeField hourOfDay() {\n-        return iHourOfDayField;\n-    }\n-\n-    public DateTimeField clockhourOfDay() {\n-        return iClockhourOfDayField;\n-    }\n-\n-    public DateTimeField hourOfHalfday() {\n-        return iHourOfHalfdayField;\n-    }\n-\n-    public DateTimeField clockhourOfHalfday() {\n-        return iClockhourOfHalfdayField;\n-    }\n-\n-    public DateTimeField halfdayOfDay() {\n-        return iHalfdayOfDayField;\n-    }\n-\n-    // Day\n-    //------------------------------------------------------------\n-\n-    public DurationField days() {\n-        return iDaysField;\n-    }\n-\n-    public DateTimeField dayOfWeek() {\n-        return iDayOfWeekField;\n-    }\n-\n-    public DateTimeField dayOfMonth() {\n-        return iDayOfMonthField;\n-    }\n-\n-    public DateTimeField dayOfYear() {\n-        return iDayOfYearField;\n-    }\n-\n-    // Week\n-    //------------------------------------------------------------\n-\n-    public DurationField weeks() {\n-        return iWeeksField;\n-    }\n-\n-    public DateTimeField weekOfWeekyear() {\n-        return iWeekOfWeekyearField;\n-    }\n-\n-    public DurationField weekyears() {\n-        return iWeekyearsField;\n-    }\n-\n-    public DateTimeField weekyear() {\n-        return iWeekyearField;\n-    }\n-\n-    // Month\n-    //------------------------------------------------------------\n-\n-    public DurationField months() {\n-        return iMonthsField;\n-    }\n-\n-    public DateTimeField monthOfYear() {\n-        return iMonthOfYearField;\n-    }\n-\n-    // Year\n-    //------------------------------------------------------------\n-\n-    public DurationField years() {\n-        return iYearsField;\n-    }\n-\n-    public DateTimeField year() {\n-        return iYearField;\n-    }\n-\n-    public DateTimeField yearOfEra() {\n-        return iYearOfEraField;\n-    }\n-\n-    public DateTimeField yearOfCentury() {\n-        return iYearOfCenturyField;\n-    }\n-\n-    public DurationField centuries() {\n-        return iCenturiesField;\n-    }\n-\n-    public DateTimeField centuryOfEra() {\n-        return iCenturyOfEraField;\n-    }\n-\n-    public DurationField eras() {\n-        return iErasField;\n-    }\n-\n-    public DateTimeField era() {\n-        return iEraField;\n+    protected void assemble(Fields fields) {\n+        // Keep a local cache of converted fields so as not to create redundant\n+        // objects.\n+        HashMap converted = new HashMap();\n+\n+        // Convert duration fields...\n+\n+        fields.eras = convertField(fields.eras, converted);\n+        fields.centuries = convertField(fields.centuries, converted);\n+        fields.years = convertField(fields.years, converted);\n+        fields.months = convertField(fields.months, converted);\n+        fields.weekyears = convertField(fields.weekyears, converted);\n+        fields.weeks = convertField(fields.weeks, converted);\n+        fields.days = convertField(fields.days, converted);\n+\n+        fields.hours = convertField(fields.hours, converted);\n+        fields.minutes = convertField(fields.minutes, converted);\n+        fields.seconds = convertField(fields.seconds, converted);\n+        fields.millis = convertField(fields.millis, converted);\n+\n+        // Convert datetime fields...\n+\n+        fields.year = convertField(fields.year, converted);\n+        fields.yearOfEra = convertField(fields.yearOfEra, converted);\n+        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);\n+        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);\n+        fields.era = convertField(fields.era, converted);\n+        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);\n+        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);\n+        fields.dayOfYear = convertField(fields.dayOfYear, converted);\n+        fields.monthOfYear = convertField(fields.monthOfYear, converted);\n+        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);\n+        fields.weekyear = convertField(fields.weekyear, converted);\n+\n+        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);\n+        fields.millisOfDay = convertField(fields.millisOfDay, converted);\n+        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);\n+        fields.secondOfDay = convertField(fields.secondOfDay, converted);\n+        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);\n+        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);\n+        fields.hourOfDay = convertField(fields.hourOfDay, converted);\n+        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);\n+        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);\n+        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);\n+        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n+    }\n+\n+    private DurationField convertField(DurationField field, HashMap converted) {\n+        if (field == null || !field.isSupported()) {\n+            return field;\n+        }\n+        if (converted.containsKey(field)) {\n+            return (DurationField)converted.get(field);\n+        }\n+        LimitDurationField limitField = new LimitDurationField(field);\n+        converted.put(field, limitField);\n+        return limitField;\n+    }\n+\n+    private DateTimeField convertField(DateTimeField field, HashMap converted) {\n+        if (field == null || !field.isSupported()) {\n+            return field;\n+        }\n+        if (converted.containsKey(field)) {\n+            return (DateTimeField)converted.get(field);\n+        }\n+        LimitDateTimeField limitField =\n+            new LimitDateTimeField(field,\n+                                   convertField(field.getDurationField(), converted),\n+                                   convertField(field.getRangeDurationField(), converted),\n+                                   convertField(field.getLeapDurationField(), converted));\n+        converted.put(field, limitField);\n+        return limitField;\n     }\n \n     public String toString() {\n-        return iChronology.toString();\n-    }\n-\n-    private void readObject(ObjectInputStream in)\n-        throws IOException, ClassNotFoundException\n-    {\n-        in.defaultReadObject();\n-        setFields();\n+        return getBase().toString();\n     }\n \n     void checkLimits(long instant, String desc) {\n             }\n             buf.append(\" instant is \");\n \n-            DateTimePrinter p = ISODateTimeFormat.getInstance(getWrappedChronology()).dateTime();\n+            DateTimePrinter p = ISODateTimeFormat.getInstance(getBase()).dateTime();\n \n             if (iIsLow) {\n                 buf.append(\"below the supported minimum of \");\n-                p.printTo(buf, iLowerLimit);\n+                p.printTo(buf, getLowerLimit());\n             } else {\n                 buf.append(\"above the supported maximum of \");\n-                p.printTo(buf, iUpperLimit);\n+                p.printTo(buf, getUpperLimit());\n             }\n             \n             buf.append(\" (\");\n-            buf.append(getWrappedChronology());\n+            buf.append(getBase());\n             buf.append(')');\n \n             return buf.toString();\n--- a/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeZone;\n+import org.joda.time.field.StrictDateTimeField;\n \n /**\n  * Wraps another chronology, ensuring all the fields are strict.\n  * @see StrictDateTimeField\n  * @see LenientChronology\n  */\n-public class StrictChronology extends DelegatedChronology {\n+public final class StrictChronology extends AssembledChronology {\n \n     static final long serialVersionUID = 6633006628097111960L;\n \n-    private transient DateTimeField iYearField;\n-    private transient DateTimeField iYearOfEraField;\n-    private transient DateTimeField iYearOfCenturyField;\n-    private transient DateTimeField iCenturyOfEraField;\n-    private transient DateTimeField iEraField;\n-    private transient DateTimeField iDayOfWeekField;\n-    private transient DateTimeField iDayOfMonthField;\n-    private transient DateTimeField iDayOfYearField;\n-    private transient DateTimeField iMonthOfYearField;\n-    private transient DateTimeField iWeekOfWeekyearField;\n-    private transient DateTimeField iWeekyearField;\n-\n-    private transient DateTimeField iMillisOfSecondField;\n-    private transient DateTimeField iMillisOfDayField;\n-    private transient DateTimeField iSecondOfMinuteField;\n-    private transient DateTimeField iSecondOfDayField;\n-    private transient DateTimeField iMinuteOfHourField;\n-    private transient DateTimeField iMinuteOfDayField;\n-    private transient DateTimeField iHourOfDayField;\n-    private transient DateTimeField iHourOfHalfdayField;\n-    private transient DateTimeField iClockhourOfDayField;\n-    private transient DateTimeField iClockhourOfHalfdayField;\n-    private transient DateTimeField iHalfdayOfDayField;\n+    /**\n+     * Create a StrictChronology for any chronology.\n+     *\n+     * @param base the chronology to wrap\n+     * @throws IllegalArgumentException if chronology is null\n+     */\n+    public static StrictChronology getInstance(Chronology base) {\n+        if (base == null) {\n+            throw new IllegalArgumentException(\"Must supply a chronology\");\n+        }\n+        return new StrictChronology(base);\n+    }\n \n     private transient Chronology iWithUTC;\n \n     /**\n      * Create a StrictChronology for any chronology.\n      *\n-     * @param chrono the chronology\n-     * @throws IllegalArgumentException if chronology is null\n+     * @param base the chronology to wrap\n      */\n-    public StrictChronology(Chronology chrono) {\n-        super(chrono);\n+    private StrictChronology(Chronology base) {\n+        super(base, null);\n     }\n \n     public Chronology withUTC() {\n         if (iWithUTC == null) {\n-            iWithUTC = new StrictChronology(getWrappedChronology().withUTC());\n+            if (getDateTimeZone() == DateTimeZone.UTC) {\n+                iWithUTC = this;\n+            } else {\n+                iWithUTC = StrictChronology.getInstance(getBase().withUTC());\n+            }\n         }\n         return iWithUTC;\n     }\n \n     public Chronology withDateTimeZone(DateTimeZone zone) {\n-        return new StrictChronology(getWrappedChronology().withDateTimeZone(zone));\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == DateTimeZone.UTC) {\n+            return withUTC();\n+        }\n+        if (zone == getDateTimeZone()) {\n+            return this;\n+        }\n+        return StrictChronology.getInstance(getBase().withDateTimeZone(zone));\n     }\n \n-    /**\n-     * Overridden to ensure strict fields are used.\n-     */\n-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n-        throws IllegalArgumentException\n-    {\n-        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n+    protected void assemble(Fields fields) {\n+        fields.year = convertField(fields.year);\n+        fields.yearOfEra = convertField(fields.yearOfEra);\n+        fields.yearOfCentury = convertField(fields.yearOfCentury);\n+        fields.centuryOfEra = convertField(fields.centuryOfEra);\n+        fields.era = convertField(fields.era);\n+        fields.dayOfWeek = convertField(fields.dayOfWeek);\n+        fields.dayOfMonth = convertField(fields.dayOfMonth);\n+        fields.dayOfYear = convertField(fields.dayOfYear);\n+        fields.monthOfYear = convertField(fields.monthOfYear);\n+        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear);\n+        fields.weekyear = convertField(fields.weekyear);\n+\n+        fields.millisOfSecond = convertField(fields.millisOfSecond);\n+        fields.millisOfDay = convertField(fields.millisOfDay);\n+        fields.secondOfMinute = convertField(fields.secondOfMinute);\n+        fields.secondOfDay = convertField(fields.secondOfDay);\n+        fields.minuteOfHour = convertField(fields.minuteOfHour);\n+        fields.minuteOfDay = convertField(fields.minuteOfDay);\n+        fields.hourOfDay = convertField(fields.hourOfDay);\n+        fields.hourOfHalfday = convertField(fields.hourOfHalfday);\n+        fields.clockhourOfDay = convertField(fields.clockhourOfDay);\n+        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday);\n+        fields.halfdayOfDay = convertField(fields.halfdayOfDay);\n     }\n \n-    /**\n-     * Overridden to ensure strict fields are used.\n-     */\n-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        long instant = hourOfDay().set(0, hourOfDay);\n-        instant = minuteOfHour().set(instant, minuteOfHour);\n-        instant = secondOfMinute().set(instant, secondOfMinute);\n-        return millisOfSecond().set(instant, millisOfSecond);\n-    }\n-\n-    /**\n-     * Overridden to ensure strict fields are used.\n-     */\n-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n-                                  int millisOfDay)\n-        throws IllegalArgumentException\n-    {\n-        long instant = year().set(0, year);\n-        instant = monthOfYear().set(instant, monthOfYear);\n-        instant = dayOfMonth().set(instant, dayOfMonth);\n-        return millisOfDay().set(instant, millisOfDay);\n-    }\n-\n-    /**\n-     * Overridden to ensure strict fields are used.\n-     */\n-    public long getDateTimeMillis(long instant,\n-                                  int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        instant = hourOfDay().set(instant, hourOfDay);\n-        instant = minuteOfHour().set(instant, minuteOfHour);\n-        instant = secondOfMinute().set(instant, secondOfMinute);\n-        return millisOfSecond().set(instant, millisOfSecond);\n-    }\n-\n-    /**\n-     * Overridden to ensure strict fields are used.\n-     */\n-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n-                                  int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        long instant = year().set(0, year);\n-        instant = monthOfYear().set(instant, monthOfYear);\n-        instant = dayOfMonth().set(instant, dayOfMonth);\n-        instant = hourOfDay().set(instant, hourOfDay);\n-        instant = minuteOfHour().set(instant, minuteOfHour);\n-        instant = secondOfMinute().set(instant, secondOfMinute);\n-        return millisOfSecond().set(instant, millisOfSecond);\n-    }\n-\n-    // Milliseconds\n-    //------------------------------------------------------------\n-\n-    public DateTimeField millisOfSecond() {\n-        if (iMillisOfDayField == null) {\n-            iMillisOfSecondField = StrictDateTimeField.getInstance(super.millisOfSecond());\n-        }\n-        return iMillisOfSecondField;\n-    }\n-\n-    public DateTimeField millisOfDay() {\n-        if (iMillisOfDayField == null) {\n-            iMillisOfDayField = StrictDateTimeField.getInstance(super.millisOfDay());\n-        }\n-        return iMillisOfDayField;\n-    }\n-\n-    // Seconds\n-    //------------------------------------------------------------\n-\n-    public DateTimeField secondOfMinute() {\n-        if (iSecondOfMinuteField == null) {\n-            iSecondOfMinuteField = StrictDateTimeField.getInstance(super.secondOfMinute());\n-        }\n-        return iSecondOfMinuteField;\n-    }\n-\n-    public DateTimeField secondOfDay() {\n-        if (iSecondOfDayField == null) {\n-            iSecondOfDayField = StrictDateTimeField.getInstance(super.secondOfDay());\n-        }\n-        return iSecondOfDayField;\n-    }\n-\n-    // Minutes\n-    //------------------------------------------------------------\n-\n-    public DateTimeField minuteOfHour() {\n-        if (iMinuteOfHourField == null) {\n-            iMinuteOfHourField = StrictDateTimeField.getInstance(super.minuteOfHour());\n-        }\n-        return iMinuteOfHourField;\n-    }\n-\n-    public DateTimeField minuteOfDay() {\n-        if (iMinuteOfDayField == null) {\n-            iMinuteOfDayField = StrictDateTimeField.getInstance(super.minuteOfDay());\n-        }\n-        return iMinuteOfDayField;\n-    }\n-\n-    // Hours\n-    //------------------------------------------------------------\n-\n-    public DateTimeField hourOfDay() {\n-        if (iHourOfDayField == null) {\n-            iHourOfDayField = StrictDateTimeField.getInstance(super.hourOfDay());\n-        }\n-        return iHourOfDayField;\n-    }\n-\n-    public DateTimeField clockhourOfDay() {\n-        if (iClockhourOfDayField == null) {\n-            iClockhourOfDayField = StrictDateTimeField.getInstance(super.clockhourOfDay());\n-        }\n-        return iClockhourOfDayField;\n-    }\n-\n-    public DateTimeField hourOfHalfday() {\n-        if (iHourOfHalfdayField == null) {\n-            iHourOfHalfdayField = StrictDateTimeField.getInstance(super.hourOfHalfday());\n-        }\n-        return iHourOfHalfdayField;\n-    }\n-\n-    public DateTimeField clockhourOfHalfday() {\n-        if (iClockhourOfHalfdayField == null) {\n-            iClockhourOfHalfdayField =\n-                StrictDateTimeField.getInstance(super.clockhourOfHalfday());\n-        }\n-        return iClockhourOfHalfdayField;\n-    }\n-\n-    public DateTimeField halfdayOfDay() {\n-        if (iHalfdayOfDayField == null) {\n-            iHalfdayOfDayField = StrictDateTimeField.getInstance(super.halfdayOfDay());\n-        }\n-        return iHalfdayOfDayField;\n-    }\n-\n-    // Day\n-    //------------------------------------------------------------\n-\n-    public DateTimeField dayOfWeek() {\n-        if (iDayOfWeekField == null) {\n-            iDayOfWeekField = StrictDateTimeField.getInstance(super.dayOfWeek());\n-        }\n-        return iDayOfWeekField;\n-    }\n-\n-    public DateTimeField dayOfMonth() {\n-        if (iDayOfMonthField == null) {\n-            iDayOfMonthField = StrictDateTimeField.getInstance(super.dayOfMonth());\n-        }\n-        return iDayOfMonthField;\n-    }\n-\n-    public DateTimeField dayOfYear() {\n-        if (iDayOfYearField == null) {\n-            iDayOfYearField = StrictDateTimeField.getInstance(super.dayOfYear());\n-        }\n-        return iDayOfYearField;\n-    }\n-\n-    // Week\n-    //------------------------------------------------------------\n-\n-    public DateTimeField weekOfWeekyear() {\n-        if (iWeekOfWeekyearField == null) {\n-            iWeekOfWeekyearField = StrictDateTimeField.getInstance(super.weekOfWeekyear());\n-        }\n-        return iWeekOfWeekyearField;\n-    }\n-\n-    public DateTimeField weekyear() {\n-        if (iWeekyearField == null) {\n-            iWeekyearField = StrictDateTimeField.getInstance(super.weekyear());\n-        }\n-        return iWeekyearField;\n-    }\n-\n-    // Month\n-    //------------------------------------------------------------\n-\n-    public DateTimeField monthOfYear() {\n-        if (iMonthOfYearField == null) {\n-            iMonthOfYearField = StrictDateTimeField.getInstance(super.monthOfYear());\n-        }\n-        return iMonthOfYearField;\n-    }\n-\n-    // Year\n-    //------------------------------------------------------------\n-\n-    public DateTimeField year() {\n-        if (iYearField == null) {\n-            iYearField = StrictDateTimeField.getInstance(super.year());\n-        }\n-        return iYearField;\n-    }\n-\n-    public DateTimeField yearOfEra() {\n-        if (iYearOfEraField == null) {\n-            iYearOfEraField = StrictDateTimeField.getInstance(super.yearOfEra());\n-        }\n-        return iYearOfEraField;\n-    }\n-\n-    public DateTimeField yearOfCentury() {\n-        if (iYearOfCenturyField == null) {\n-            iYearOfCenturyField = StrictDateTimeField.getInstance(super.yearOfCentury());\n-        }\n-        return iYearOfCenturyField;\n-    }\n-\n-    public DateTimeField centuryOfEra() {\n-        if (iCenturyOfEraField == null) {\n-            iCenturyOfEraField = StrictDateTimeField.getInstance(super.centuryOfEra());\n-        }\n-        return iCenturyOfEraField;\n-    }\n-\n-    public DateTimeField era() {\n-        if (iEraField == null) {\n-            iEraField = StrictDateTimeField.getInstance(super.era());\n-        }\n-        return iEraField;\n+    private static final DateTimeField convertField(DateTimeField field) {\n+        return StrictDateTimeField.getInstance(field);\n     }\n \n     public String toString() {\n-        return \"StrictChronology[\" + getWrappedChronology().toString() + ']';\n+        return \"StrictChronology[\" + getBase().toString() + ']';\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n  */\n package org.joda.time.chrono;\n \n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-\n import java.util.HashMap;\n import java.util.Locale;\n \n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeZone;\n import org.joda.time.DurationField;\n+import org.joda.time.field.AbstractDateTimeField;\n+import org.joda.time.field.AbstractDurationField;\n \n /**\n  * Wraps another Chronology for supporting time zones.\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public class ZonedChronology extends Chronology {\n+public final class ZonedChronology extends AssembledChronology {\n+\n+    /**\n+     * Create a ZonedChronology for any chronology, overriding any time zone it\n+     * may already have.\n+     *\n+     * @param base base chronology to wrap\n+     * @param zone the time zone\n+     * @throws IllegalArgumentException if chronology or time zone is null\n+     */\n+    public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\n+        if (base == null) {\n+            throw new IllegalArgumentException(\"Must supply a chronology\");\n+        }\n+        base = base.withUTC();\n+        if (base == null) {\n+            throw new IllegalArgumentException(\"UTC chronology must not be null\");\n+        }\n+        if (zone == null) {\n+            throw new IllegalArgumentException(\"DateTimeZone must not be null\");\n+        }\n+        return new ZonedChronology(base, zone);\n+    }\n \n     static final long serialVersionUID = -1079258847191166848L;\n \n         return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;\n     }\n \n-    private final Chronology iChronology;\n-    private final DateTimeZone iZone;\n-\n-    private transient DurationField iErasField;\n-    private transient DurationField iCenturiesField;\n-    private transient DurationField iYearsField;\n-    private transient DurationField iMonthsField;\n-    private transient DurationField iWeekyearsField;\n-    private transient DurationField iWeeksField;\n-    private transient DurationField iDaysField;\n-\n-    private transient DurationField iHoursField;\n-    private transient DurationField iMinutesField;\n-    private transient DurationField iSecondsField;\n-    private transient DurationField iMillisField;\n-\n-    private transient DateTimeField iYearField;\n-    private transient DateTimeField iYearOfEraField;\n-    private transient DateTimeField iYearOfCenturyField;\n-    private transient DateTimeField iCenturyOfEraField;\n-    private transient DateTimeField iEraField;\n-    private transient DateTimeField iDayOfWeekField;\n-    private transient DateTimeField iDayOfMonthField;\n-    private transient DateTimeField iDayOfYearField;\n-    private transient DateTimeField iMonthOfYearField;\n-    private transient DateTimeField iWeekOfWeekyearField;\n-    private transient DateTimeField iWeekyearField;\n-\n-    private transient DateTimeField iMillisOfSecondField;\n-    private transient DateTimeField iMillisOfDayField;\n-    private transient DateTimeField iSecondOfMinuteField;\n-    private transient DateTimeField iSecondOfDayField;\n-    private transient DateTimeField iMinuteOfHourField;\n-    private transient DateTimeField iMinuteOfDayField;\n-    private transient DateTimeField iHourOfDayField;\n-    private transient DateTimeField iHourOfHalfdayField;\n-    private transient DateTimeField iClockhourOfDayField;\n-    private transient DateTimeField iClockhourOfHalfdayField;\n-    private transient DateTimeField iHalfdayOfDayField;\n-\n     /**\n-     * Create a ZonedChronology for any chronology, overriding any time zone it\n-     * may already have.\n+     * Restricted constructor\n      *\n-     * @param chrono the chronology\n+     * @param base base chronology to wrap\n      * @param zone the time zone\n-     * @throws IllegalArgumentException if chronology or time zone is null\n      */\n-    public ZonedChronology(Chronology chrono, DateTimeZone zone) {\n-        if (chrono == null) {\n-            throw new IllegalArgumentException(\"Must supply a chronology\");\n-        }\n-        chrono = chrono.withUTC();\n-        if (chrono == null) {\n-            throw new IllegalArgumentException(\"UTC chronology must not be null\");\n-        }\n+    private ZonedChronology(Chronology base, DateTimeZone zone) {\n+        super(base, zone);\n+    }\n+\n+    public DateTimeZone getDateTimeZone() {\n+        return (DateTimeZone)getParam();\n+    }\n+\n+    public Chronology withUTC() {\n+        return getBase();\n+    }\n+\n+    public Chronology withDateTimeZone(DateTimeZone zone) {\n         if (zone == null) {\n-            throw new IllegalArgumentException(\"DateTimeZone must not be null\");\n-        }\n-\n-        iChronology = chrono;\n-        iZone = zone;\n-        setFields();\n-    }\n-\n-    private void setFields() {\n-        Chronology c = iChronology;\n-\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getParam()) {\n+            return this;\n+        }\n+        if (zone == DateTimeZone.UTC) {\n+            return getBase();\n+        }\n+        return new ZonedChronology(getBase(), zone);\n+    }\n+\n+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException\n+    {\n+        return localToUTC(getBase().getDateOnlyMillis\n+                          (year, monthOfYear, dayOfMonth));\n+    }\n+\n+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return localToUTC(getBase().getTimeOnlyMillis\n+                          (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        return localToUTC(getBase().getDateTimeMillis\n+                          (year, monthOfYear, dayOfMonth, millisOfDay));\n+    }\n+\n+    public long getDateTimeMillis(long instant,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return localToUTC(getBase().getDateTimeMillis\n+                          (instant + getDateTimeZone().getOffset(instant),\n+                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return localToUTC(getBase().getDateTimeMillis\n+                          (year, monthOfYear, dayOfMonth, \n+                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n+    }\n+\n+    /**\n+     * @param instant instant from 1970-01-01T00:00:00 local time\n+     */\n+    private long localToUTC(long instant) {\n+        DateTimeZone zone = getDateTimeZone();\n+        int offset = zone.getOffsetFromLocal(instant);\n+        instant -= offset;\n+        if (offset != zone.getOffset(instant)) {\n+            throw new IllegalArgumentException\n+                (\"Illegal instant due to time zone offset transition\");\n+        }\n+        return instant;\n+    }\n+\n+    protected void assemble(Fields fields) {\n         // Keep a local cache of converted fields so as not to create redundant\n         // objects.\n         HashMap converted = new HashMap();\n \n         // Convert duration fields...\n \n-        iErasField = convertField(c.eras(), converted);\n-        iCenturiesField = convertField(c.centuries(), converted);\n-        iYearsField = convertField(c.years(), converted);\n-        iMonthsField = convertField(c.months(), converted);\n-        iWeekyearsField = convertField(c.weekyears(), converted);\n-        iWeeksField = convertField(c.weeks(), converted);\n-        iDaysField = convertField(c.days(), converted);\n-\n-        iHoursField = convertField(c.hours(), converted);\n-        iMinutesField = convertField(c.minutes(), converted);\n-        iSecondsField = convertField(c.seconds(), converted);\n-        iMillisField = convertField(c.millis(), converted);\n+        fields.eras = convertField(fields.eras, converted);\n+        fields.centuries = convertField(fields.centuries, converted);\n+        fields.years = convertField(fields.years, converted);\n+        fields.months = convertField(fields.months, converted);\n+        fields.weekyears = convertField(fields.weekyears, converted);\n+        fields.weeks = convertField(fields.weeks, converted);\n+        fields.days = convertField(fields.days, converted);\n+\n+        fields.hours = convertField(fields.hours, converted);\n+        fields.minutes = convertField(fields.minutes, converted);\n+        fields.seconds = convertField(fields.seconds, converted);\n+        fields.millis = convertField(fields.millis, converted);\n \n         // Convert datetime fields...\n \n-        iYearField = convertField(c.year(), converted);\n-        iYearOfEraField = convertField(c.yearOfEra(), converted);\n-        iYearOfCenturyField = convertField(c.yearOfCentury(), converted);\n-        iCenturyOfEraField = convertField(c.centuryOfEra(), converted);\n-        iEraField = convertField(c.era(), converted);\n-        iDayOfWeekField = convertField(c.dayOfWeek(), converted);\n-        iDayOfMonthField = convertField(c.dayOfMonth(), converted);\n-        iDayOfYearField = convertField(c.dayOfYear(), converted);\n-        iMonthOfYearField = convertField(c.monthOfYear(), converted);\n-        iWeekOfWeekyearField = convertField(c.weekOfWeekyear(), converted);\n-        iWeekyearField = convertField(c.weekyear(), converted);\n-\n-        iMillisOfSecondField = convertField(c.millisOfSecond(), converted);\n-        iMillisOfDayField = convertField(c.millisOfDay(), converted);\n-        iSecondOfMinuteField = convertField(c.secondOfMinute(), converted);\n-        iSecondOfDayField = convertField(c.secondOfDay(), converted);\n-        iMinuteOfHourField = convertField(c.minuteOfHour(), converted);\n-        iMinuteOfDayField = convertField(c.minuteOfDay(), converted);\n-        iHourOfDayField = convertField(c.hourOfDay(), converted);\n-        iHourOfHalfdayField = convertField(c.hourOfHalfday(), converted);\n-        iClockhourOfDayField = convertField(c.clockhourOfDay(), converted);\n-        iClockhourOfHalfdayField = convertField(c.clockhourOfHalfday(), converted);\n-        iHalfdayOfDayField = convertField(c.halfdayOfDay(), converted);\n+        fields.year = convertField(fields.year, converted);\n+        fields.yearOfEra = convertField(fields.yearOfEra, converted);\n+        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);\n+        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);\n+        fields.era = convertField(fields.era, converted);\n+        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);\n+        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);\n+        fields.dayOfYear = convertField(fields.dayOfYear, converted);\n+        fields.monthOfYear = convertField(fields.monthOfYear, converted);\n+        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);\n+        fields.weekyear = convertField(fields.weekyear, converted);\n+\n+        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);\n+        fields.millisOfDay = convertField(fields.millisOfDay, converted);\n+        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);\n+        fields.secondOfDay = convertField(fields.secondOfDay, converted);\n+        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);\n+        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);\n+        fields.hourOfDay = convertField(fields.hourOfDay, converted);\n+        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);\n+        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);\n+        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);\n+        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n     }\n \n     private DurationField convertField(DurationField field, HashMap converted) {\n         if (converted.containsKey(field)) {\n             return (DurationField)converted.get(field);\n         }\n-        ZonedDurationField zonedField = new ZonedDurationField(field, iZone);\n+        ZonedDurationField zonedField = new ZonedDurationField(field, getDateTimeZone());\n         converted.put(field, zonedField);\n         return zonedField;\n     }\n             return (DateTimeField)converted.get(field);\n         }\n         ZonedDateTimeField zonedField =\n-            new ZonedDateTimeField(field, iZone,\n+            new ZonedDateTimeField(field, getDateTimeZone(),\n                                    convertField(field.getDurationField(), converted),\n                                    convertField(field.getRangeDurationField(), converted),\n                                    convertField(field.getLeapDurationField(), converted));\n         return zonedField;\n     }\n \n-    public DateTimeZone getDateTimeZone() {\n-        return iZone;\n-    }\n-\n-    public Chronology withUTC() {\n-        return iChronology;\n-    }\n-\n-    public Chronology withDateTimeZone(DateTimeZone zone) {\n-        if (zone == null) {\n-            zone = DateTimeZone.getDefault();\n-        }\n-        if (zone == iZone) {\n-            return this;\n-        }\n-        if (zone == DateTimeZone.UTC) {\n-            return iChronology;\n-        }\n-        return new ZonedChronology(iChronology, zone);\n-    }\n-\n-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n-        throws IllegalArgumentException\n-    {\n-        return localToUTC(iChronology.getDateOnlyMillis\n-                          (year, monthOfYear, dayOfMonth));\n-    }\n-\n-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        return localToUTC(iChronology.getTimeOnlyMillis\n-                          (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n-    }\n-\n-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n-                                  int millisOfDay)\n-        throws IllegalArgumentException\n-    {\n-        return localToUTC(iChronology.getDateTimeMillis\n-                          (year, monthOfYear, dayOfMonth, millisOfDay));\n-    }\n-\n-    public long getDateTimeMillis(long instant,\n-                                  int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        return localToUTC(iChronology.getDateTimeMillis\n-                          (instant + iZone.getOffset(instant),\n-                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n-    }\n-\n-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n-                                  int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        return localToUTC(iChronology.getDateTimeMillis\n-                          (year, monthOfYear, dayOfMonth, \n-                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n-    }\n-\n-    /**\n-     * @param instant instant from 1970-01-01T00:00:00 local time\n-     */\n-    private long localToUTC(long instant) {\n-        int offset = iZone.getOffsetFromLocal(instant);\n-        instant -= offset;\n-        if (offset != iZone.getOffset(instant)) {\n-            throw new IllegalArgumentException\n-                (\"Illegal instant due to time zone offset transition\");\n-        }\n-        return instant;\n-    }\n-\n-    // Milliseconds\n-    //------------------------------------------------------------\n-\n-    public DurationField millis() {\n-        return iMillisField;\n-    }\n-\n-    public DateTimeField millisOfSecond() {\n-        return iMillisOfSecondField;\n-    }\n-\n-    public DateTimeField millisOfDay() {\n-        return iMillisOfDayField;\n-    }\n-\n-    // Seconds\n-    //------------------------------------------------------------\n-\n-    public DurationField seconds() {\n-        return iSecondsField;\n-    }\n-\n-    public DateTimeField secondOfMinute() {\n-        return iSecondOfMinuteField;\n-    }\n-\n-    public DateTimeField secondOfDay() {\n-        return iSecondOfDayField;\n-    }\n-\n-    // Minutes\n-    //------------------------------------------------------------\n-\n-    public DurationField minutes() {\n-        return iMinutesField;\n-    }\n-\n-    public DateTimeField minuteOfHour() {\n-        return iMinuteOfHourField;\n-    }\n-\n-    public DateTimeField minuteOfDay() {\n-        return iMinuteOfDayField;\n-    }\n-\n-    // Hours\n-    //------------------------------------------------------------\n-\n-    public DurationField hours() {\n-        return iHoursField;\n-    }\n-\n-    public DateTimeField hourOfDay() {\n-        return iHourOfDayField;\n-    }\n-\n-    public DateTimeField clockhourOfDay() {\n-        return iClockhourOfDayField;\n-    }\n-\n-    public DateTimeField hourOfHalfday() {\n-        return iHourOfHalfdayField;\n-    }\n-\n-    public DateTimeField clockhourOfHalfday() {\n-        return iClockhourOfHalfdayField;\n-    }\n-\n-    public DateTimeField halfdayOfDay() {\n-        return iHalfdayOfDayField;\n-    }\n-\n-    // Day\n-    //------------------------------------------------------------\n-\n-    public DurationField days() {\n-        return iDaysField;\n-    }\n-\n-    public DateTimeField dayOfWeek() {\n-        return iDayOfWeekField;\n-    }\n-\n-    public DateTimeField dayOfMonth() {\n-        return iDayOfMonthField;\n-    }\n-\n-    public DateTimeField dayOfYear() {\n-        return iDayOfYearField;\n-    }\n-\n-    // Week\n-    //------------------------------------------------------------\n-\n-    public DurationField weeks() {\n-        return iWeeksField;\n-    }\n-\n-    public DateTimeField weekOfWeekyear() {\n-        return iWeekOfWeekyearField;\n-    }\n-\n-    public DurationField weekyears() {\n-        return iWeekyearsField;\n-    }\n-\n-    public DateTimeField weekyear() {\n-        return iWeekyearField;\n-    }\n-\n-    // Month\n-    //------------------------------------------------------------\n-\n-    public DurationField months() {\n-        return iMonthsField;\n-    }\n-\n-    public DateTimeField monthOfYear() {\n-        return iMonthOfYearField;\n-    }\n-\n-    // Year\n-    //------------------------------------------------------------\n-\n-    public DurationField years() {\n-        return iYearsField;\n-    }\n-\n-    public DateTimeField year() {\n-        return iYearField;\n-    }\n-\n-    public DateTimeField yearOfEra() {\n-        return iYearOfEraField;\n-    }\n-\n-    public DateTimeField yearOfCentury() {\n-        return iYearOfCenturyField;\n-    }\n-\n-    public DurationField centuries() {\n-        return iCenturiesField;\n-    }\n-\n-    public DateTimeField centuryOfEra() {\n-        return iCenturyOfEraField;\n-    }\n-\n-    public DurationField eras() {\n-        return iErasField;\n-    }\n-\n-    public DateTimeField era() {\n-        return iEraField;\n-    }\n-\n     public String toString() {\n-        return iChronology.toString();\n-    }\n-\n-    private void readObject(ObjectInputStream in)\n-        throws IOException, ClassNotFoundException\n-    {\n-        in.defaultReadObject();\n-        setFields();\n+        return \"ZonedChronology[\" + getBase() + \", \" + getDateTimeZone().getID() + ']';\n     }\n \n     /*\n--- a/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * AbstractConverter simplifies the process of implementing a converter.\n--- a/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.chrono.buddhist.BuddhistChronology;\n-import org.joda.time.chrono.gj.GJChronology;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.BuddhistChronology;\n+import org.joda.time.chrono.GJChronology;\n+import org.joda.time.chrono.GregorianChronology;\n+import org.joda.time.chrono.JulianChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * CalendarConverter converts a java util Calendar to milliseconds in the\n     public Chronology getChronology(Object object, DateTimeZone zone) {\n         if (object instanceof GregorianCalendar) {\n             GregorianCalendar gc = (GregorianCalendar) object;\n-            return GJChronology.getInstance(zone, gc.getGregorianChange().getTime(), false);\n-            \n+            long cutover = gc.getGregorianChange().getTime();\n+            if (cutover == Long.MIN_VALUE) {\n+                return GregorianChronology.getInstance(zone);\n+            } else if (cutover == Long.MAX_VALUE) {\n+                return JulianChronology.getInstance(zone);\n+            } else {\n+                return GJChronology.getInstance(zone, cutover, 4);\n+            }\n         } else if (object.getClass().getName().endsWith(\".BuddhistCalendar\")) {\n             return BuddhistChronology.getInstance(zone);\n-            \n         } else {\n             return ISOChronology.getInstance(zone);\n         }\n--- a/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n import org.joda.time.PartialInstant;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * PartialInstantConverter extracts milliseconds and chronology from a\n--- a/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n import org.joda.time.ReadableInstant;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * ReadableInstantConverter extracts milliseconds and chronology from a ReadableInstant.\n--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n import org.joda.time.ReadWritableDuration;\n import org.joda.time.ReadWritableInterval;\n import org.joda.time.ReadableDuration;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n import org.joda.time.format.DateTimeParser;\n import org.joda.time.format.DurationParser;\n import org.joda.time.format.ISODateTimeFormat;\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/AbstractDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * AbstractDateTimeField provides the common behaviour for DateTimeField\n+ * implementations. \n+ * <p>\n+ * This class should generally not be used directly by API users. The\n+ * DateTimeField interface should be used when different kinds of DateTimeField\n+ * objects are to be referenced.\n+ * <p>\n+ * AbstractDateTimeField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see DecoratedDateTimeField\n+ */\n+public abstract class AbstractDateTimeField implements DateTimeField, Serializable {\n+\n+    static final long serialVersionUID = -4388055220581798589L;\n+\n+    /** A desriptive name for the field */\n+    private final String iName;\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractDateTimeField(String name) {\n+        super();\n+        if (name == null) {\n+            throw new IllegalArgumentException(\"The name must not be null\");\n+        }\n+        iName = name;\n+    }\n+    \n+    public final String getName() {\n+        return iName;\n+    }\n+\n+    /**\n+     * @return true always\n+     */\n+    public final boolean isSupported() {\n+        return true;\n+    }\n+\n+    // Main access API\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get the value of this field from the milliseconds.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the value of the field, in the units of the field\n+     */\n+    public abstract int get(long instant);\n+\n+    /**\n+     * Get the human-readable, text value of this field from the milliseconds.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns Integer.toString(get(instant)).\n+     * <p>\n+     * Note: subclasses that override this method should also override\n+     * getMaximumTextLength.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @param locale the locale to use for selecting a text symbol, null for\n+     * default\n+     * @return the text value of the field\n+     */\n+    public String getAsText(long instant, Locale locale) {\n+        return Integer.toString(get(instant));\n+    }\n+\n+    /**\n+     * Get the human-readable, text value of this field from the milliseconds.\n+     * This implementation returns getAsText(instant, null).\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the text value of the field\n+     */\n+    public final String getAsText(long instant) {\n+        return getAsText(instant, null);\n+    }\n+\n+    /**\n+     * Get the human-readable, short text value of this field from the\n+     * milliseconds.  If the specified locale is null, the default locale is\n+     * used.\n+     * <p>\n+     * The default implementation returns getAsText(instant, locale).\n+     * <p>\n+     * Note: subclasses that override this method should also override\n+     * getMaximumShortTextLength.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @param locale the locale to use for selecting a text symbol, null for\n+     * default\n+     * @return the short text value of the field\n+     */\n+    public String getAsShortText(long instant, Locale locale) {\n+        return getAsText(instant, locale);\n+    }\n+\n+    /**\n+     * Get the human-readable, short text value of this field from the\n+     * milliseconds.  This implementation returns getAsShortText(instant, null).\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the short text value of the field\n+     */\n+    public final String getAsShortText(long instant) {\n+        return getAsShortText(instant, null);\n+    }\n+\n+    /**\n+     * Adds a value (which may be negative) to the instant value,\n+     * overflowing into larger fields if necessary.\n+     * <p>\n+     * The value will be added to this field. If the value is too large to be\n+     * added solely to this field, larger fields will increase as required.\n+     * Smaller fields should be unaffected, except where the result would be\n+     * an invalid value for a smaller field. In this case the smaller field is\n+     * adjusted to be in range.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 2000-08-20 add six months is 2001-02-20<br>\n+     * 2000-08-20 add twenty months is 2002-04-20<br>\n+     * 2000-08-20 add minus nine months is 1999-11-20<br>\n+     * 2001-01-31 add one month  is 2001-02-28<br>\n+     * 2001-01-31 add two months is 2001-03-31<br>\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the value to add, in the units of the field\n+     * @return the updated milliseconds\n+     */\n+    public long add(long instant, int value) {\n+        return getDurationField().add(instant, value);\n+    }\n+\n+    /**\n+     * Adds a value (which may be negative) to the instant value,\n+     * overflowing into larger fields if necessary.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the long value to add, in the units of the field\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if value is too large\n+     * @see #add(long,int)\n+     */\n+    public long add(long instant, long value) {\n+        return getDurationField().add(instant, value);\n+    }\n+\n+    /**\n+     * Adds a value (which may be negative) to the instant value,\n+     * wrapping within this field.\n+     * <p>\n+     * The value will be added to this field. If the value is too large to be\n+     * added solely to this field then it wraps. Larger fields are always\n+     * unaffected. Smaller fields should be unaffected, except where the\n+     * result would be an invalid value for a smaller field. In this case the\n+     * smaller field is adjusted to be in range.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 2000-08-20 addWrapped six months is 2000-02-20<br>\n+     * 2000-08-20 addWrapped twenty months is 2000-04-20<br>\n+     * 2000-08-20 addWrapped minus nine months is 2000-11-20<br>\n+     * 2001-01-31 addWrapped one month  is 2001-02-28<br>\n+     * 2001-01-31 addWrapped two months is 2001-03-31<br>\n+     * <p>\n+     * The default implementation internally calls set. Subclasses are\n+     * encouraged to provide a more efficient implementation.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the value to add, in the units of the field\n+     * @return the updated milliseconds\n+     */\n+    public long addWrapped(long instant, int value) {\n+        int current = get(instant);\n+        int wrapped = FieldUtils.getWrappedValue\n+            (current, value, getMinimumValue(instant), getMaximumValue(instant));\n+        return set(instant, wrapped);\n+    }\n+\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * int v = ...\n+     * int age = getDifference(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getDurationField().getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * long v = ...\n+     * long age = getDifferenceAsLong(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    /**\n+     * Sets a value in the milliseconds supplied.\n+     * <p>\n+     * The value of this field will be set. If the value is invalid, an\n+     * exception if thrown. Other fields are always unaffected.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param value  the value to set, in the units of the field\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public abstract long set(long instant, int value);\n+\n+    /**\n+     * Sets a value in the milliseconds supplied from a human-readable, text\n+     * value. If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns set(instant,\n+     * Integer.parseInt(instant)).\n+     * <p>\n+     * Note: subclasses that override this method should also override\n+     * getAsText.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param text  the text value to set\n+     * @param locale the locale to use for selecting a text symbol, null for\n+     * default\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if the text value is invalid\n+     */\n+    public long set(long instant, String text, Locale locale) {\n+        try {\n+            return set(instant, Integer.parseInt(text));\n+        } catch (NumberFormatException ex) {\n+            throw new IllegalArgumentException(\"Invalid \" + getName() + \" text: \" + text);\n+        }\n+    }\n+\n+    /**\n+     * Sets a value in the milliseconds supplied from a human-readable, text\n+     * value. This implementation returns set(instant, text, null).\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param text  the text value to set\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if the text value is invalid\n+     */\n+    public final long set(long instant, String text) {\n+        return set(instant, text, null);\n+    }\n+\n+    // Extra information API\n+    //------------------------------------------------------------------------\n+    /**\n+     * Returns the duration per unit value of this field. For example, if this\n+     * field represents \"hour of day\", then the unit duration is an hour.\n+     *\n+     * @return the duration of this field, or UnsupportedDurationField if field\n+     * has no duration\n+     */\n+    public abstract DurationField getDurationField();\n+\n+    /**\n+     * Returns the range duration of this field. For example, if this field\n+     * represents \"hour of day\", then the range duration is a day.\n+     *\n+     * @return the range duration of this field, or null if field has no range\n+     */\n+    public abstract DurationField getRangeDurationField();\n+\n+    /**\n+     * Returns whether this field is 'leap' for the specified instant.\n+     * <p>\n+     * For example, a leap year would return true, a non leap year would return\n+     * false.\n+     * <p>\n+     * This implementation returns false.\n+     * \n+     * @return true if the field is 'leap'\n+     */\n+    public boolean isLeap(long instant) {\n+        return false;\n+    }\n+\n+    /**\n+     * Gets the amount by which this field is 'leap' for the specified instant.\n+     * <p>\n+     * For example, a leap year would return one, a non leap year would return\n+     * zero.\n+     * <p>\n+     * This implementation returns zero.\n+     */\n+    public int getLeapAmount(long instant) {\n+        return 0;\n+    }\n+\n+    /**\n+     * If this field were to leap, then it would be in units described by the\n+     * returned duration. If this field doesn't ever leap, null is returned.\n+     * <p>\n+     * This implementation returns null.\n+     */\n+    public DurationField getLeapDurationField() {\n+        return null;\n+    }\n+\n+    /**\n+     * Get the minimum allowable value for this field.\n+     * \n+     * @return the minimum valid value for this field, in the units of the\n+     * field\n+     */\n+    public abstract int getMinimumValue();\n+\n+    /**\n+     * Get the minimum value for this field evaluated at the specified time.\n+     * <p>\n+     * This implementation returns the same as {@link #getMinimumValue()}.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the minimum value for this field, in the units of the field\n+     */\n+    public int getMinimumValue(long instant) {\n+        return getMinimumValue();\n+    }\n+\n+    /**\n+     * Get the maximum allowable value for this field.\n+     * \n+     * @return the maximum valid value for this field, in the units of the\n+     * field\n+     */\n+    public abstract int getMaximumValue();\n+\n+    /**\n+     * Get the maximum value for this field evaluated at the specified time.\n+     * <p>\n+     * This implementation returns the same as {@link #getMaximumValue()}.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the maximum value for this field, in the units of the field\n+     */\n+    public int getMaximumValue(long instant) {\n+        return getMaximumValue();\n+    }\n+\n+    /**\n+     * Get the maximum text value for this field. The default implementation\n+     * returns the equivalent of Integer.toString(getMaximumValue()).length().\n+     * \n+     * @param locale  the locale to use for selecting a text symbol\n+     * @return the maximum text length\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        int max = getMaximumValue();\n+        if (max >= 0) {\n+            if (max < 10) {\n+                return 1;\n+            } else if (max < 100) {\n+                return 2;\n+            } else if (max < 1000) {\n+                return 3;\n+            }\n+        }\n+        return Integer.toString(max).length();\n+    }\n+\n+    /**\n+     * Get the maximum short text value for this field. The default\n+     * implementation returns getMaximumTextLength().\n+     * \n+     * @param locale  the locale to use for selecting a text symbol\n+     * @return the maximum short text length\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return getMaximumTextLength(locale);\n+    }\n+\n+    // Calculation API\n+    //------------------------------------------------------------------------\n+    /**\n+     * Round to the lowest whole unit of this field. After rounding, the value\n+     * of this field and all fields of a higher magnitude are retained. The\n+     * fractional millis that cannot be expressed in whole increments of this\n+     * field are set to minimum.\n+     * <p>\n+     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the\n+     * lowest whole hour is 2002-11-02T23:00:00.000.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public abstract long roundFloor(long instant);\n+\n+    /**\n+     * Round to the highest whole unit of this field. The value of this field\n+     * and all fields of a higher magnitude may be incremented in order to\n+     * achieve this result. The fractional millis that cannot be expressed in\n+     * whole increments of this field are set to minimum.\n+     * <p>\n+     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the\n+     * highest whole hour is 2002-11-03T00:00:00.000.\n+     * <p>\n+     * The default implementation calls roundFloor, and if the instant is\n+     * modified as a result, adds one field unit. Subclasses are encouraged to\n+     * provide a more efficient implementation.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public long roundCeiling(long instant) {\n+        long newInstant = roundFloor(instant);\n+        if (newInstant != instant) {\n+            instant = add(newInstant, 1);\n+        }\n+        return instant;\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field. If the given millisecond\n+     * value is closer to the floor or is exactly halfway, this function\n+     * behaves like roundFloor. If the millisecond value is closer to the\n+     * ceiling, this function behaves like roundCeiling.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public long roundHalfFloor(long instant) {\n+        long floor = roundFloor(instant);\n+        long ceiling = roundCeiling(instant);\n+\n+        long diffFromFloor = instant - floor;\n+        long diffToCeiling = ceiling - instant;\n+\n+        if (diffFromFloor <= diffToCeiling) {\n+            // Closer to the floor, or halfway - round floor\n+            return floor;\n+        } else {\n+            return ceiling;\n+        }\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field. If the given millisecond\n+     * value is closer to the floor, this function behaves like roundFloor. If\n+     * the millisecond value is closer to the ceiling or is exactly halfway,\n+     * this function behaves like roundCeiling.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public long roundHalfCeiling(long instant) {\n+        long floor = roundFloor(instant);\n+        long ceiling = roundCeiling(instant);\n+\n+        long diffFromFloor = instant - floor;\n+        long diffToCeiling = ceiling - instant;\n+\n+        if (diffToCeiling <= diffFromFloor) {\n+            // Closer to the ceiling, or halfway - round ceiling\n+            return ceiling;\n+        } else {\n+            return floor;\n+        }\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field. If the given millisecond\n+     * value is closer to the floor, this function behaves like roundFloor. If\n+     * the millisecond value is closer to the ceiling, this function behaves\n+     * like roundCeiling.\n+     * <p>\n+     * If the millisecond value is exactly halfway between the floor and\n+     * ceiling, the ceiling is chosen over the floor only if it makes this\n+     * field's value even.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public long roundHalfEven(long instant) {\n+        long floor = roundFloor(instant);\n+        long ceiling = roundCeiling(instant);\n+\n+        long diffFromFloor = instant - floor;\n+        long diffToCeiling = ceiling - instant;\n+\n+        if (diffFromFloor < diffToCeiling) {\n+            // Closer to the floor - round floor\n+            return floor;\n+        } else if (diffToCeiling < diffFromFloor) {\n+            // Closer to the ceiling - round ceiling\n+            return ceiling;\n+        } else {\n+            // Round to the instant that makes this field even. If both values\n+            // make this field even (unlikely), favor the ceiling.\n+            if ((get(ceiling) & 1) == 0) {\n+                return ceiling;\n+            }\n+            return floor;\n+        }\n+    }\n+\n+    /**\n+     * Returns the fractional duration milliseconds of this field. In other\n+     * words, calling remainder returns the duration that roundFloor would\n+     * subtract.\n+     * <p>\n+     * For example, on a datetime of 2002-11-02T23:34:56.789, the remainder by\n+     * hour is 34 minutes and 56.789 seconds.\n+     * <p>\n+     * The default implementation computes\n+     * <code>instant - roundFloor(instant)</code>. Subclasses are encouraged to\n+     * provide a more efficient implementation.\n+     *\n+     * @param instant the milliseconds from 1970-01-01T00:00:00Z to get the\n+     * remainder\n+     * @return remainder duration, in milliseconds\n+     */\n+    public long remainder(long instant) {\n+        return instant - roundFloor(instant);\n+    }\n+\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return \"DateTimeField[\" + getName() + ']';\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/AbstractDurationField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import java.io.Serializable;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * AbstractDurationField provides the common behaviour for DurationField\n+ * implementations.\n+ * <p>\n+ * This class should generally not be used directly by API users. The\n+ * DurationField interface should be used when different kinds of DurationField\n+ * objects are to be referenced.\n+ * <p>\n+ * AbstractDurationField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @see DecoratedDurationField\n+ */\n+public abstract class AbstractDurationField implements DurationField, Serializable {\n+\n+    static final long serialVersionUID = -2554245107589433218L;\n+\n+    /** A desriptive name for the field */\n+    private final String iName;\n+\n+    protected AbstractDurationField(String name) {\n+        super();\n+        if (name == null) {\n+            throw new IllegalArgumentException(\"The name must not be null\");\n+        }\n+        iName = name;\n+    }\n+\n+    public final String getName() {\n+        return iName;\n+    }\n+\n+    /**\n+     * @return true always\n+     */\n+    public final boolean isSupported() {\n+        return true;\n+    }\n+\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get the value of this field from the milliseconds, which is approximate\n+     * if this field is imprecise.\n+     *\n+     * @param duration  the milliseconds to query, which may be negative\n+     * @return the value of the field, in the units of the field, which may be\n+     * negative\n+     */\n+    public int getValue(long duration) {\n+        return FieldUtils.safeToInt(getValueAsLong(duration));\n+    }\n+\n+    /**\n+     * Get the value of this field from the milliseconds, which is approximate\n+     * if this field is imprecise.\n+     *\n+     * @param duration  the milliseconds to query, which may be negative\n+     * @return the value of the field, in the units of the field, which may be\n+     * negative\n+     */\n+    public long getValueAsLong(long duration) {\n+        return duration / getUnitMillis();\n+    }\n+\n+    /**\n+     * Get the value of this field from the milliseconds relative to an\n+     * instant.\n+     *\n+     * <p>If the milliseconds is positive, then the instant is treated as a\n+     * \"start instant\". If negative, the instant is treated as an \"end\n+     * instant\".\n+     *\n+     * <p>The default implementation returns\n+     * <code>Utils.safeToInt(getAsLong(millisDuration, instant))</code>.\n+     * \n+     * @param duration  the milliseconds to query, which may be negative\n+     * @param instant  the start instant to calculate relative to\n+     * @return the value of the field, in the units of the field, which may be\n+     * negative\n+     */\n+    public int getValue(long duration, long instant) {\n+        return FieldUtils.safeToInt(getValueAsLong(duration, instant));\n+    }\n+\n+    /**\n+     * Get the millisecond duration of this field from its value, which is\n+     * approximate if this field is imprecise.\n+     * \n+     * @param value  the value of the field, which may be negative\n+     * @return the milliseconds that the field represents, which may be\n+     * negative\n+     */\n+    public long getMillis(int value) {\n+        return value * getUnitMillis();\n+    }\n+\n+    /**\n+     * Get the millisecond duration of this field from its value, which is\n+     * approximate if this field is imprecise.\n+     * \n+     * @param value  the value of the field, which may be negative\n+     * @return the milliseconds that the field represents, which may be\n+     * negative\n+     */\n+    public long getMillis(long value) {\n+        return value * getUnitMillis();\n+    }\n+\n+    // Calculation API\n+    //------------------------------------------------------------------------\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));\n+    }\n+\n+    //------------------------------------------------------------------------\n+    public int compareTo(Object durationField) {\n+        DurationField otherField = (DurationField) durationField;\n+        long otherMillis = otherField.getUnitMillis();\n+        long thisMillis = getUnitMillis();\n+        // cannot do (thisMillis - otherMillis) as can overflow\n+        if (thisMillis == otherMillis) {\n+            return 0;\n+        }\n+        if (thisMillis < otherMillis) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return \"DurationField[\" + getName() + ']';\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * <code>DecoratedDateTimeField</code> extends {@link AbstractDateTimeField},\n+ * implementing only the minimum required set of methods. These implemented\n+ * methods delegate to a wrapped field.\n+ * <p>\n+ * This design allows new DateTimeField types to be defined that piggyback on\n+ * top of another, inheriting all the safe method implementations from\n+ * AbstractDateTimeField. Should any method require pure delegation to the\n+ * wrapped field, simply override and use the provided getWrappedField method.\n+ * <p>\n+ * DecoratedDateTimeField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see DelegatedDateTimeField\n+ */\n+public class DecoratedDateTimeField extends AbstractDateTimeField {\n+\n+    static final long serialVersionUID = 203115783733757597L;\n+\n+    /** The DateTimeField being wrapped */\n+    private final DateTimeField iField;\n+\n+    /**\n+     * @param name allow name to be overridden\n+     */\n+    public DecoratedDateTimeField(DateTimeField field, String name) {\n+        super(name);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (!field.isSupported()) {\n+            throw new IllegalArgumentException(\"The field must be supported\");\n+        }\n+        iField = field;\n+    }\n+\n+    /**\n+     * Gets the wrapped date time field.\n+     * \n+     * @return the wrapped DateTimeField\n+     */\n+    public final DateTimeField getWrappedField() {\n+        return iField;\n+    }\n+\n+    public boolean isLenient() {\n+        return iField.isLenient();\n+    }\n+\n+    public int get(long instant) {\n+        return iField.get(instant);\n+    }\n+\n+    public long set(long instant, int value) {\n+        return iField.set(instant, value);\n+    }\n+\n+    public DurationField getDurationField() {\n+        return iField.getDurationField();\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iField.getRangeDurationField();\n+    }\n+\n+    public int getMinimumValue() {\n+        return iField.getMinimumValue();\n+    }\n+\n+    public int getMaximumValue() {\n+        return iField.getMaximumValue();\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return iField.roundFloor(instant);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/DecoratedDurationField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DurationField;\n+\n+/**\n+ * <code>DecoratedDurationField</code> extends {@link AbstractDurationField},\n+ * implementing only the minimum required set of methods. These implemented\n+ * methods delegate to a wrapped field.\n+ * <p>\n+ * This design allows new DurationField types to be defined that piggyback on\n+ * top of another, inheriting all the safe method implementations from\n+ * AbstractDurationField. Should any method require pure delegation to the\n+ * wrapped field, simply override and use the provided getWrappedField method.\n+ * <p>\n+ * DecoratedDurationField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @see DelegatedDurationField\n+ */\n+public class DecoratedDurationField extends AbstractDurationField {\n+\n+    static final long serialVersionUID = 8019982251647420015L;\n+\n+    /** The DurationField being wrapped */\n+    private final DurationField iField;\n+\n+    /**\n+     * @param name allow name to be overridden\n+     */\n+    public DecoratedDurationField(DurationField field, String name) {\n+        super(name);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (!field.isSupported()) {\n+            throw new IllegalArgumentException(\"The field must be supported\");\n+        }\n+        iField = field;\n+    }\n+\n+    /**\n+     * Gets the wrapped duration field.\n+     * \n+     * @return the wrapped DurationField\n+     */\n+    public final DurationField getWrappedField() {\n+        return iField;\n+    }\n+\n+    public boolean isPrecise() {\n+        return iField.isPrecise();\n+    }\n+\n+    public long getValueAsLong(long duration, long instant) {\n+        return iField.getValueAsLong(duration, instant);\n+    }\n+\n+    public long getMillis(int value, long instant) {\n+        return iField.getMillis(value, instant);\n+    }\n+\n+    public long getMillis(long value, long instant) {\n+        return iField.getMillis(value, instant);\n+    }\n+\n+    public long add(long instant, int value) {\n+        return iField.add(instant, value);\n+    }\n+\n+    public long add(long instant, long value) {\n+        return iField.add(instant, value);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long getUnitMillis() {\n+        return iField.getUnitMillis();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * <code>DelegatedDateTimeField</code> delegates each method call to the\n+ * date time field it wraps.\n+ * <p>\n+ * DelegatedDateTimeField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see DecoratedDateTimeField\n+ */\n+public class DelegatedDateTimeField implements DateTimeField, Serializable {\n+\n+    static final long serialVersionUID = -4730164440214502503L;\n+\n+    /** The DateTimeField being wrapped */\n+    private final DateTimeField iField;\n+    /** A desriptive name for the field */\n+    private final String iName;\n+\n+    protected DelegatedDateTimeField(DateTimeField field) {\n+        this(field, null);\n+    }\n+\n+    protected DelegatedDateTimeField(DateTimeField field, String name) {\n+        super();\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        iField = field;\n+        iName = name;\n+    }\n+\n+    /**\n+     * Gets the wrapped date time field.\n+     * \n+     * @return the wrapped DateTimeField\n+     */\n+    public final DateTimeField getWrappedField() {\n+        return iField;\n+    }\n+\n+    public String getName() {\n+        return (iName == null) ? iField.getName() : iName;\n+    }\n+\n+    public boolean isSupported() {\n+        return iField.isSupported();\n+    }\n+\n+    public boolean isLenient() {\n+        return iField.isLenient();\n+    }\n+\n+    public int get(long instant) {\n+        return iField.get(instant);\n+    }\n+\n+    public String getAsText(long instant, Locale locale) {\n+        return iField.getAsText(instant, locale);\n+    }\n+\n+    public String getAsText(long instant) {\n+        return iField.getAsText(instant);\n+    }\n+\n+    public String getAsShortText(long instant, Locale locale) {\n+        return iField.getAsShortText(instant, locale);\n+    }\n+\n+    public String getAsShortText(long instant) {\n+        return iField.getAsShortText(instant);\n+    }\n+\n+    public long add(long instant, int value) {\n+        return iField.add(instant, value);\n+    }\n+\n+    public long add(long instant, long value) {\n+        return iField.add(instant, value);\n+    }\n+\n+    public long addWrapped(long instant, int value) {\n+        return iField.addWrapped(instant, value);\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return iField.getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long set(long instant, int value) {\n+        return iField.set(instant, value);\n+    }\n+\n+    public long set(long instant, String text, Locale locale) {\n+        return iField.set(instant, text, locale);\n+    }\n+\n+    public long set(long instant, String text) {\n+        return iField.set(instant, text);\n+    }\n+\n+    public DurationField getDurationField() {\n+        return iField.getDurationField();\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iField.getRangeDurationField();\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return iField.isLeap(instant);\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        return iField.getLeapAmount(instant);\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return iField.getLeapDurationField();\n+    }\n+\n+    public int getMinimumValue() {\n+        return iField.getMinimumValue();\n+    }\n+\n+    public int getMinimumValue(long instant) {\n+        return iField.getMinimumValue(instant);\n+    }\n+\n+    public int getMaximumValue() {\n+        return iField.getMaximumValue();\n+    }\n+\n+    public int getMaximumValue(long instant) {\n+        return iField.getMaximumValue(instant);\n+    }\n+\n+    public int getMaximumTextLength(Locale locale) {\n+        return iField.getMaximumTextLength(locale);\n+    }\n+\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return iField.getMaximumShortTextLength(locale);\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return iField.roundFloor(instant);\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        return iField.roundCeiling(instant);\n+    }\n+\n+    public long roundHalfFloor(long instant) {\n+        return iField.roundHalfFloor(instant);\n+    }\n+\n+    public long roundHalfCeiling(long instant) {\n+        return iField.roundHalfCeiling(instant);\n+    }\n+\n+    public long roundHalfEven(long instant) {\n+        return iField.roundHalfEven(instant);\n+    }\n+\n+    public long remainder(long instant) {\n+        return iField.remainder(instant);\n+    }\n+\n+    public String toString() {\n+        return (iName == null) ? iField.toString() :\n+            (\"DateTimeField[\" + iName + ']');\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDurationField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import java.io.Serializable;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * <code>DelegatedDurationField</code> delegates each method call to the\n+ * duration field it wraps.\n+ * <p>\n+ * DelegatedDurationField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @see DecoratedDurationField\n+ */\n+public class DelegatedDurationField implements DurationField, Serializable {\n+\n+    static final long serialVersionUID = -5576443481242007829L;\n+\n+    /** The DurationField being wrapped */\n+    private final DurationField iField;\n+    /** A desriptive name for the field */\n+    private final String iName;\n+\n+    protected DelegatedDurationField(DurationField field) {\n+        this(field, null);\n+    }\n+\n+    /**\n+     * @param name allow name to be overridden\n+     */\n+    protected DelegatedDurationField(DurationField field, String name) {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        iField = field;\n+        iName = name;\n+    }\n+\n+    /**\n+     * Gets the wrapped duration field.\n+     * \n+     * @return the wrapped DurationField\n+     */\n+    public final DurationField getWrappedField() {\n+        return iField;\n+    }\n+\n+    public String getName() {\n+        return (iName == null) ? iField.getName() : iName;\n+    }\n+\n+    /**\n+     * Returns true if this field is supported.\n+     */\n+    public boolean isSupported() {\n+        return iField.isSupported();\n+    }\n+\n+    public boolean isPrecise() {\n+        return iField.isPrecise();\n+    }\n+    \n+    public int getValue(long duration) {\n+        return iField.getValue(duration);\n+    }\n+\n+    public long getValueAsLong(long duration) {\n+        return iField.getValueAsLong(duration);\n+    }\n+\n+    public int getValue(long duration, long instant) {\n+        return iField.getValue(duration, instant);\n+    }\n+\n+    public long getValueAsLong(long duration, long instant) {\n+        return iField.getValueAsLong(duration, instant);\n+    }\n+\n+    public long getMillis(int value) {\n+        return iField.getMillis(value);\n+    }\n+\n+    public long getMillis(long value) {\n+        return iField.getMillis(value);\n+    }\n+\n+    public long getMillis(int value, long instant) {\n+        return iField.getMillis(value, instant);\n+    }\n+\n+    public long getMillis(long value, long instant) {\n+        return iField.getMillis(value, instant);\n+    }\n+\n+    public long add(long instant, int value) {\n+        return iField.add(instant, value);\n+    }\n+\n+    public long add(long instant, long value) {\n+        return iField.add(instant, value);\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return iField.getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long getUnitMillis() {\n+        return iField.getUnitMillis();\n+    }\n+\n+    public int compareTo(Object durationField) {\n+        return iField.compareTo(durationField);\n+    }\n+\n+    public String toString() {\n+        return (iName == null) ? iField.toString() :\n+            (\"DurationField[\" + iName + ']');\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/DividedDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Divides a DateTimeField such that the retrieved values are reduced by a\n+ * fixed divisor. The field's unit duration is scaled accordingly, but the\n+ * range duration is unchanged.\n+ * <p>\n+ * DividedDateTimeField is thread-safe and immutable.\n+ *\n+ * @see RemainderDateTimeField\n+ * \n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class DividedDateTimeField extends DecoratedDateTimeField {\n+\n+    static final long serialVersionUID = 8318475124230605365L;\n+\n+    // Shared with RemainderDateTimeField.\n+    final int iDivisor;\n+    final DurationField iDurationField;\n+\n+    private final int iMin;\n+    private final int iMax;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param field  the field to wrap, like \"year()\".\n+     * @param name  short, descriptive name, like \"century\".\n+     * @param durationName  short, descriptive name, like \"centuries\".\n+     * @param divisor  divisor, such as 100 years in a century\n+     * @throws IllegalArgumentException if divisor is less than two\n+     */\n+    public DividedDateTimeField(DateTimeField field,\n+                                String name, String durationName, int divisor) {\n+        super(field, name);\n+                \n+        if (divisor < 2) {\n+            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n+        }\n+\n+        DurationField unitField = field.getDurationField();\n+        if (unitField == null) {\n+            iDurationField = null;\n+        } else {\n+            iDurationField = new ScaledDurationField(unitField, durationName, divisor);\n+        }\n+\n+        iDivisor = divisor;\n+\n+        int i = field.getMinimumValue();\n+        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);\n+\n+        int j = field.getMaximumValue();\n+        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);\n+\n+        iMin = min;\n+        iMax = max;\n+    }\n+\n+    /**\n+     * Construct a DividedDateTimeField that compliments the given\n+     * RemainderDateTimeField.\n+     *\n+     * @param remainderField  complimentary remainder field, like \"yearOfCentury()\".\n+     * @param name  short, descriptive name, like \"century\".\n+     */\n+    public DividedDateTimeField(RemainderDateTimeField remainderField, String name) {\n+        super(remainderField.getWrappedField(), name);\n+        int divisor = iDivisor = remainderField.iDivisor;\n+        iDurationField = remainderField.iRangeField;\n+\n+        DateTimeField field = getWrappedField();\n+        int i = field.getMinimumValue();\n+        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);\n+\n+        int j = field.getMaximumValue();\n+        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);\n+\n+        iMin = min;\n+        iMax = max;\n+    }\n+\n+    /**\n+     * Get the amount of scaled units from the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to query.\n+     * @return the amount of scaled units extracted from the input.\n+     */\n+    public int get(long instant) {\n+        int value = getWrappedField().get(instant);\n+        if (value >= 0) {\n+            return value / iDivisor;\n+        } else {\n+            return ((value + 1) / iDivisor) - 1;\n+        }\n+    }\n+\n+    /**\n+     * Add the specified amount of scaled units to the specified time\n+     * instant. The amount added may be negative.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param amount  the amount of scaled units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, int amount) {\n+        return getWrappedField().add(instant, amount * iDivisor);\n+    }\n+\n+    /**\n+     * Add the specified amount of scaled units to the specified time\n+     * instant. The amount added may be negative.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param amount  the amount of scaled units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, long amount) {\n+        return getWrappedField().add(instant, amount * iDivisor);\n+    }\n+\n+    /**\n+     * Add to the scaled component of the specified time instant,\n+     * wrapping around within that component if necessary.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param amount  the amount of scaled units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long instant, int amount) {\n+        return set(instant, FieldUtils.getWrappedValue(get(instant), amount, iMin, iMax));\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant) / iDivisor;\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant) / iDivisor;\n+    }\n+\n+    /**\n+     * Set the specified amount of scaled units to the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param value  value of scaled units to set.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException if value is too large or too small.\n+     */\n+    public long set(long instant, int value) {\n+        FieldUtils.verifyValueBounds(this, value, iMin, iMax);\n+        int remainder = getRemainder(getWrappedField().get(instant));\n+        return getWrappedField().set(instant, value * iDivisor + remainder);\n+    }\n+\n+    /**\n+     * Returns a scaled version of the wrapped field's unit duration field.\n+     */\n+    public DurationField getDurationField() {\n+        return iDurationField;\n+    }\n+\n+    /**\n+     * Get the minimum value for the field.\n+     * \n+     * @return the minimum value\n+     */\n+    public int getMinimumValue() {\n+        return iMin;\n+    }\n+\n+    /**\n+     * Get the maximum value for the field.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue() {\n+        return iMax;\n+    }\n+\n+    public long roundFloor(long instant) {\n+        DateTimeField field = getWrappedField();\n+        return field.roundFloor(field.set(instant, get(instant) * iDivisor));\n+    }\n+\n+    public long remainder(long instant) {\n+        return set(instant, get(getWrappedField().remainder(instant)));\n+    }\n+\n+    /**\n+     * Returns the divisor applied, in the field's units.\n+     * \n+     * @return the divisor\n+     */\n+    public int getDivisor() {\n+        return iDivisor;\n+    }\n+\n+    private int getRemainder(int value) {\n+        if (value >= 0) {\n+            return value % iDivisor;\n+        } else {\n+            return (iDivisor - 1) + ((value + 1) % iDivisor);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/FieldUtils.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * General utilities that don't fit elsewhere.\n+ * <p>\n+ * Utils is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public class FieldUtils {\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private FieldUtils() {\n+        super();\n+    }\n+    \n+    //------------------------------------------------------------------------\n+    /**\n+     * Add two values throwing an exception if overflow occurs.\n+     * \n+     * @param val1  the first value\n+     * @param val2  the second value\n+     * @return the new total\n+     */\n+    public static long safeAdd(long val1, long val2) {\n+        long total = val1 + val2;\n+        if (val1 > 0 && val2 > 0 && total < 0) {\n+            throw new ArithmeticException(\"The calculation caused an overflow: \" + val1 +\" + \" + val2);\n+        }\n+        if (val1 < 0 && val2 < 0 && total > 0) {\n+            throw new ArithmeticException(\"The calculation caused an overflow: \" + val1 +\" + \" + val2);\n+        }\n+        return total;\n+    }\n+    \n+    /**\n+     * Multiply two values throwing an exception if overflow occurs.\n+     * \n+     * @param val1  the first value\n+     * @param val2  the second value\n+     * @return the new total\n+     */\n+    public static long safeMultiply(long val1, long val2) {\n+        if (val1 == 0  || val2 == 0) {\n+            return 0L;\n+        }\n+        long total = val1 * val2;\n+        if (total / val2 != val1) {\n+            throw new ArithmeticException(\"The calculation caused an overflow: \" + val1 +\" * \" + val2);\n+        }\n+        return total;\n+    }\n+    \n+    /**\n+     * Casts to an int throwing an exception if overflow occurs.\n+     * \n+     * @param value  the value\n+     * @return the value as an int\n+     */\n+    public static int safeToInt(long value) {\n+        if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {\n+            return (int) value;\n+        }\n+        throw new ArithmeticException(\"Value cannot fit in an int: \" + value);\n+    }\n+\n+    /**\n+     * Verify that input values are within specified bounds.\n+     * \n+     * @param value  the value to check\n+     * @param lowerBound  the lower bound allowed for value\n+     * @param upperBound  the upper bound allowed for value\n+     * @throws IllegalArgumentException if value is not in the specified bounds\n+     */\n+    public static void verifyValueBounds(DateTimeField field, \n+                                         int value, int lowerBound, int upperBound) {\n+        if ((value < lowerBound) || (value > upperBound)) {\n+            throw new IllegalArgumentException(\n+                \"Value \"\n+                    + value\n+                    + \" for \"\n+                    + field.getName()\n+                    + \" must be in the range [\"\n+                    + lowerBound\n+                    + ','\n+                    + upperBound\n+                    + ']');\n+        }\n+    }\n+\n+    /**\n+     * Verify that input values are within specified bounds.\n+     * \n+     * @param value  the value to check\n+     * @param lowerBound  the lower bound allowed for value\n+     * @param upperBound  the upper bound allowed for value\n+     * @throws IllegalArgumentException if value is not in the specified bounds\n+     */\n+    public static void verifyValueBounds(String fieldName,\n+                                         int value, int lowerBound, int upperBound) {\n+        if ((value < lowerBound) || (value > upperBound)) {\n+            throw new IllegalArgumentException(\n+                \"Value \"\n+                    + value\n+                    + \" for \"\n+                    + fieldName\n+                    + \" must be in the range [\"\n+                    + lowerBound\n+                    + ','\n+                    + upperBound\n+                    + ']');\n+        }\n+    }\n+\n+    /**\n+     * Utility method used by addWrapped implementations to ensure the new\n+     * value lies within the field's legal value range.\n+     *\n+     * @param currentValue the current value of the data, which may lie outside\n+     * the wrapped value range\n+     * @param wrapValue  the value to add to current value before\n+     *  wrapping.  This may be negative.\n+     * @param minValue the wrap range minimum value.\n+     * @param maxValue the wrap range maximum value.  This must be\n+     *  greater than minValue (checked by the method).\n+     * @return the wrapped value\n+     * @throws IllegalArgumentException if minValue is greater\n+     *  than or equal to maxValue\n+     */\n+    public static int getWrappedValue(int currentValue, int wrapValue,\n+                                      int minValue, int maxValue) {\n+        return getWrappedValue(currentValue + wrapValue, minValue, maxValue);\n+    }\n+\n+    /**\n+     * Utility method that ensures the given value lies within the field's\n+     * legal value range.\n+     * \n+     * @param value  the value to fit into the wrapped value range\n+     * @param minValue the wrap range minimum value.\n+     * @param maxValue the wrap range maximum value.  This must be\n+     *  greater than minValue (checked by the method).\n+     * @return the wrapped value\n+     * @throws IllegalArgumentException if minValue is greater\n+     *  than or equal to maxValue\n+     */\n+    public static int getWrappedValue(int value, int minValue, int maxValue) {\n+        if (minValue >= maxValue) {\n+            throw new IllegalArgumentException(\"MIN > MAX\");\n+        }\n+\n+        int wrapRange = maxValue - minValue + 1;\n+        value -= minValue;\n+\n+        if (value >= 0) {\n+            return (value % wrapRange) + minValue;\n+        }\n+\n+        int remByRange = (-value) % wrapRange;\n+\n+        if (remByRange == 0) {\n+            return 0 + minValue;\n+        }\n+        return (wrapRange - remByRange) + minValue;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/ImpreciseDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Abstract datetime field class that defines its own DurationField, which\n+ * delegates back into this ImpreciseDateTimeField.\n+ * <p>\n+ * This DateTimeField is useful for defining DateTimeFields that are composed\n+ * of imprecise durations. If both duration fields are precise, then a\n+ * {@link PreciseDateTimeField} should be used instead.\n+ * <p>\n+ * When defining imprecise DateTimeFields where a matching DurationField is\n+ * already available, just extend AbstractDateTimeField directly so as not to\n+ * create redundant DurationField instances.\n+ * <p>\n+ * ImpreciseDateTimeField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @see PreciseDateTimeField\n+ */\n+public abstract class ImpreciseDateTimeField extends AbstractDateTimeField {\n+\n+    static final long serialVersionUID = 7190739608550251860L;\n+\n+    final long iUnitMillis;\n+    private final DurationField iDurationField;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param name  short, descriptive name, like \"monthOfYear\".\n+     * @param durationName  short, descriptive name, like \"months\".\n+     * @param unitMillis  the average duration unit milliseconds\n+     */\n+    public ImpreciseDateTimeField(String name, String durationName, long unitMillis) {\n+        super(name);\n+        iUnitMillis = unitMillis;\n+        iDurationField = new LinkedDurationField(durationName);\n+    }\n+\n+    public abstract int get(long instant);\n+\n+    public abstract long set(long instant, int value);\n+\n+    public abstract long add(long instant, int value);\n+\n+    public abstract long add(long instant, long value);\n+\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * int v = ...\n+     * int age = getDifference(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     * <p>\n+     * The default implementation call getDifferenceAsLong and converts the\n+     * return value to an int.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));\n+    }\n+\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * long v = ...\n+     * long age = getDifferenceAsLong(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     * <p>\n+     * The default implementation performs a guess-and-check algorithm using\n+     * getDurationField().getUnitMillis() and the add() method. Subclasses are\n+     * encouraged to provide a more efficient implementation.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        if (minuendInstant < subtrahendInstant) {\n+            return -getDifferenceAsLong(subtrahendInstant, minuendInstant);\n+        }\n+        \n+        long difference = (minuendInstant - subtrahendInstant) / iUnitMillis;\n+        if (add(subtrahendInstant, difference) < minuendInstant) {\n+            do {\n+                difference++;\n+            } while (add(subtrahendInstant, difference) <= minuendInstant);\n+            difference--;\n+        } else if (add(subtrahendInstant, difference) > minuendInstant) {\n+            do {\n+                difference--;\n+            } while (add(subtrahendInstant, difference) > minuendInstant);\n+        }\n+        return difference;\n+    }\n+\n+    public final DurationField getDurationField() {\n+        return iDurationField;\n+    }\n+\n+    public abstract DurationField getRangeDurationField();\n+\n+    public abstract long roundFloor(long instant);\n+\n+    protected final long getDurationUnitMillis() {\n+        return iUnitMillis;\n+    }\n+\n+    private final class LinkedDurationField extends AbstractDurationField {\n+        static final long serialVersionUID = -203813474600094134L;\n+\n+        LinkedDurationField(String name) {\n+            super(name);\n+        }\n+    \n+        public boolean isPrecise() {\n+            return false;\n+        }\n+    \n+        public long getUnitMillis() {\n+            return iUnitMillis;\n+        }\n+\n+        public int getValue(long duration, long instant) {\n+            return ImpreciseDateTimeField.this\n+                .getDifference(instant + duration, instant);\n+        }\n+\n+        public long getValueAsLong(long duration, long instant) {\n+            return ImpreciseDateTimeField.this\n+                .getDifferenceAsLong(instant + duration, instant);\n+        }\n+        \n+        public long getMillis(int value, long instant) {\n+            return ImpreciseDateTimeField.this.add(instant, value) - instant;\n+        }\n+\n+        public long getMillis(long value, long instant) {\n+            return ImpreciseDateTimeField.this.add(instant, value) - instant;\n+        }\n+\n+        public long add(long instant, int value) {\n+            return ImpreciseDateTimeField.this.add(instant, value);\n+        }\n+        \n+        public long add(long instant, long value) {\n+            return ImpreciseDateTimeField.this.add(instant, value);\n+        }\n+        \n+        public int getDifference(long minuendInstant, long subtrahendInstant) {\n+            return ImpreciseDateTimeField.this\n+                .getDifference(minuendInstant, subtrahendInstant);\n+        }\n+        \n+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+            return ImpreciseDateTimeField.this\n+                .getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/LenientDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Converts a strict DateTimeField into a lenient one. By being lenient, the\n+ * set method accepts out of bounds values, performing an addition instead.\n+ * <p>\n+ * LenientDateTimeField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @see org.joda.time.chrono.LenientChronology\n+ * @see StrictDateTimeField\n+ */\n+public class LenientDateTimeField extends DelegatedDateTimeField {\n+\n+    static final long serialVersionUID = 8714085824173290599L;\n+\n+    /**\n+     * Returns a lenient version of the given field. If it is already lenient,\n+     * then it is returned as-is. Otherwise, a new LenientDateTimeField is\n+     * returned.\n+     */\n+    public static DateTimeField getInstance(DateTimeField field) {\n+        if (field == null) {\n+            return null;\n+        }\n+        if (field instanceof StrictDateTimeField) {\n+            field = ((StrictDateTimeField)field).getWrappedField();\n+        }\n+        if (field.isLenient()) {\n+            return field;\n+        }\n+        return new LenientDateTimeField(field);\n+    }\n+\n+    protected LenientDateTimeField(DateTimeField field) {\n+        super(field);\n+    }\n+\n+    public final boolean isLenient() {\n+        return true;\n+    }\n+\n+    /**\n+     * Set values which may be out of bounds. If the value is out of bounds,\n+     * the instant is first set to the minimum allowed value, and then the\n+     * difference is added.\n+     */\n+    public long set(long instant, int value) {\n+        int min = getMinimumValue(instant);\n+        if (value >= min && value < getMaximumValue(instant)) {\n+            return super.set(instant, value);\n+        }\n+        return add(super.set(instant, min), value - min);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/MillisDurationField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import java.io.Serializable;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Duration field class representing a field with a fixed unit length of one\n+ * millisecond.\n+ * <p>\n+ * MillisDurationField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public final class MillisDurationField implements DurationField, Serializable {\n+    \n+    static final long serialVersionUID = 2656707858124633367L;\n+\n+    public static final DurationField INSTANCE = new MillisDurationField();\n+\n+    private MillisDurationField() {\n+    }\n+    \n+    //------------------------------------------------------------------------\n+    public String getName() {\n+        return \"millis\";\n+    }\n+\n+    /**\n+     * @return true always\n+     */\n+    public boolean isSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * This field is precise.\n+     * \n+     * @return true always\n+     */\n+    public final boolean isPrecise() {\n+        return true;\n+    }\n+    \n+    /**\n+     * Returns the amount of milliseconds per unit value of this field.\n+     *\n+     * @return one always\n+     */\n+    public final long getUnitMillis() {\n+        return 1;\n+    }\n+\n+    //------------------------------------------------------------------------\n+    public int getValue(long duration) {\n+        return FieldUtils.safeToInt(duration);\n+    }\n+\n+    public long getValueAsLong(long duration) {\n+        return duration;\n+    }\n+\n+    public int getValue(long duration, long instant) {\n+        return FieldUtils.safeToInt(duration);\n+    }\n+\n+    public long getValueAsLong(long duration, long instant) {\n+        return duration;\n+    }\n+\n+    public long getMillis(int value) {\n+        return value;\n+    }\n+\n+    public long getMillis(long value) {\n+        return value;\n+    }\n+\n+    public long getMillis(int value, long instant) {\n+        return value;\n+    }\n+\n+    public long getMillis(long value, long instant) {\n+        return value;\n+    }\n+\n+    public long add(long instant, int value) {\n+        return instant + value;\n+    }\n+\n+    public long add(long instant, long value) {\n+        return instant + value;\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return FieldUtils.safeToInt(minuendInstant - subtrahendInstant);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return minuendInstant - subtrahendInstant;\n+    }\n+\n+    //------------------------------------------------------------------------\n+    public int compareTo(Object durationField) {\n+        DurationField otherField = (DurationField) durationField;\n+        long otherMillis = otherField.getUnitMillis();\n+        long thisMillis = getUnitMillis();\n+        // cannot do (thisMillis - otherMillis) as can overflow\n+        if (thisMillis == otherMillis) {\n+            return 0;\n+        }\n+        if (thisMillis < otherMillis) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return \"DurationField[\" + getName() + ']';\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Wraps another field such that zero values are replaced with one more than\n+ * it's maximum. This is particularly useful for implementing an clockhourOfDay\n+ * field, where the midnight value of 0 is replaced with 24.\n+ * <p>\n+ * NonZeroDateTimeField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class NonZeroDateTimeField extends DecoratedDateTimeField {\n+\n+    static final long serialVersionUID = 961749798233026866L;\n+\n+    /**\n+     * @param name  short, descriptive name, like \"clockhourOfDay\".\n+     * @throws IllegalArgumentException if wrapped field's minimum value is not zero\n+     */\n+    public NonZeroDateTimeField(DateTimeField field, String name) {\n+        super(field, name);\n+        if (field.getMinimumValue() != 0) {\n+            throw new IllegalArgumentException(\"Wrapped field's minumum value must be zero\");\n+        }\n+    }\n+\n+    public int get(long instant) {\n+        int value = getWrappedField().get(instant);\n+        if (value == 0) {\n+            value = getMaximumValue();\n+        }\n+        return value;\n+    }\n+\n+    public long add(long instant, int value) {\n+        return getWrappedField().add(instant, value);\n+    }\n+\n+    public long add(long instant, long value) {\n+        return getWrappedField().add(instant, value);\n+    }\n+\n+    public long addWrapped(long instant, int value) {\n+        return getWrappedField().addWrapped(instant, value);\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long set(long instant, int value) {\n+        int max = getMaximumValue();\n+        FieldUtils.verifyValueBounds(this, value, 1, max);\n+        if (value == max) {\n+            value = 0;\n+        }\n+        return getWrappedField().set(instant, value);\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return getWrappedField().isLeap(instant);\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        return getWrappedField().getLeapAmount(instant);\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return getWrappedField().getLeapDurationField();\n+    }\n+\n+    /**\n+     * Always returns 1.\n+     * \n+     * @return the minimum value of 1\n+     */\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    /**\n+     * Always returns 1.\n+     * \n+     * @return the minimum value of 1\n+     */\n+    public int getMinimumValue(long instant) {\n+        return 1;\n+    }\n+\n+    /**\n+     * Get the maximum value for the field, which is one more than the wrapped\n+     * field's maximum value.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue() {\n+        return getWrappedField().getMaximumValue() + 1;\n+    }\n+\n+    /**\n+     * Get the maximum value for the field, which is one more than the wrapped\n+     * field's maximum value.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue(long instant) {\n+        return getWrappedField().getMaximumValue(instant) + 1;\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return getWrappedField().roundFloor(instant);\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        return getWrappedField().roundCeiling(instant);\n+    }\n+\n+    public long roundHalfFloor(long instant) {\n+        return getWrappedField().roundHalfFloor(instant);\n+    }\n+\n+    public long roundHalfCeiling(long instant) {\n+        return getWrappedField().roundHalfCeiling(instant);\n+    }\n+\n+    public long roundHalfEven(long instant) {\n+        return getWrappedField().roundHalfEven(instant);\n+    }\n+\n+    public long remainder(long instant) {\n+        return getWrappedField().remainder(instant);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/OffsetDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Generic offset adjusting datetime field.\n+ * <p>\n+ * OffsetDateTimeField is thread-safe and immutable.\n+ * \n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class OffsetDateTimeField extends DecoratedDateTimeField {\n+    static final long serialVersionUID = 3145790132623583142L;\n+\n+    private final int iOffset;\n+\n+    private final int iMin;\n+    private final int iMax;\n+\n+    /**\n+     * Constructor\n+     * \n+     * @param field  the field to wrap, like \"year()\".\n+     * @param name  short, descriptive name, like \"offsetYear\".\n+     * @param offset  offset to add to field values\n+     * @throws IllegalArgumentException if offset is zero\n+     */\n+    public OffsetDateTimeField(DateTimeField field, String name, int offset) {\n+        this(field, name, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Constructor\n+     * \n+     * @param field  the field to wrap, like \"year()\".\n+     * @param name  short, descriptive name, like \"offsetYear\".\n+     * @param offset  offset to add to field values\n+     * @param minValue  minimum allowed value\n+     * @param maxValue  maximum allowed value\n+     * @throws IllegalArgumentException if offset is zero\n+     */\n+    public OffsetDateTimeField(DateTimeField field, String name, int offset,\n+                               int minValue, int maxValue) {\n+        super(field, name);\n+                \n+        if (offset == 0) {\n+            throw new IllegalArgumentException(\"The offset cannot be zero\");\n+        }\n+\n+        iOffset = offset;\n+\n+        if (minValue < (field.getMinimumValue() + offset)) {\n+            iMin = field.getMinimumValue() + offset;\n+        } else {\n+            iMin = minValue;\n+        }\n+        if (maxValue > (field.getMaximumValue() + offset)) {\n+            iMax = field.getMaximumValue() + offset;\n+        } else {\n+            iMax = maxValue;\n+        }\n+    }\n+\n+    /**\n+     * Get the amount of offset units from the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to query.\n+     * @return the amount of units extracted from the input.\n+     */\n+    public int get(long instant) {\n+        return super.get(instant) + iOffset;\n+    }\n+\n+    /**\n+     * Add the specified amount of offset units to the specified time\n+     * instant. The amount added may be negative.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param amount  the amount of units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, int amount) {\n+        instant = super.add(instant, amount);\n+        FieldUtils.verifyValueBounds(this, get(instant), iMin, iMax);\n+        return instant;\n+    }\n+\n+    /**\n+     * Add the specified amount of offset units to the specified time\n+     * instant. The amount added may be negative.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param amount  the amount of units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, long amount) {\n+        instant = super.add(instant, amount);\n+        FieldUtils.verifyValueBounds(this, get(instant), iMin, iMax);\n+        return instant;\n+    }\n+\n+    /**\n+     * Add to the offset component of the specified time instant,\n+     * wrapping around within that component if necessary.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param amount  the amount of units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long instant, int amount) {\n+        return set(instant, FieldUtils.getWrappedValue(get(instant), amount, iMin, iMax));\n+    }\n+\n+    /**\n+     * Set the specified amount of offset units to the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param value  value of units to set.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException if value is too large or too small.\n+     */\n+    public long set(long instant, int value) {\n+        FieldUtils.verifyValueBounds(this, value, iMin, iMax);\n+        return super.set(instant, value - iOffset);\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return getWrappedField().isLeap(instant);\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        return getWrappedField().getLeapAmount(instant);\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return getWrappedField().getLeapDurationField();\n+    }\n+\n+    /**\n+     * Get the minimum value for the field.\n+     * \n+     * @return the minimum value\n+     */\n+    public int getMinimumValue() {\n+        return iMin;\n+    }\n+\n+    /**\n+     * Get the maximum value for the field.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue() {\n+        return iMax;\n+    }\n+    \n+    public long roundFloor(long instant) {\n+        return getWrappedField().roundFloor(instant);\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        return getWrappedField().roundCeiling(instant);\n+    }\n+\n+    public long roundHalfFloor(long instant) {\n+        return getWrappedField().roundHalfFloor(instant);\n+    }\n+\n+    public long roundHalfCeiling(long instant) {\n+        return getWrappedField().roundHalfCeiling(instant);\n+    }\n+\n+    public long roundHalfEven(long instant) {\n+        return getWrappedField().roundHalfEven(instant);\n+    }\n+\n+    public long remainder(long instant) {\n+        return getWrappedField().remainder(instant);\n+    }\n+\n+    /**\n+     * Returns the offset added to the field values.\n+     * \n+     * @return the offset\n+     */\n+    public int getOffset() {\n+        return iOffset;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/PreciseDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Precise datetime field, composed of two precise duration fields.\n+ * <p>\n+ * This DateTimeField is useful for defining DateTimeFields that are composed\n+ * of precise durations, like time of day fields. If either duration field is\n+ * imprecise, then an {@link ImpreciseDateTimeField} may be used instead.\n+ * <p>\n+ * PreciseDateTimeField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ * @see ImpreciseDateTimeField\n+ */\n+public class PreciseDateTimeField extends PreciseDurationDateTimeField {\n+\n+    static final long serialVersionUID = -5586801265774496376L;\n+\n+    /** The maximum range in the correct units */\n+    private final int iRange;\n+\n+    private final DurationField iRangeField;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param name  short, descriptive name, like \"secondOfMinute\".\n+     * @param unit  precise unit duration, like \"seconds()\".\n+     * @param range precise range duration, preferably a multiple of the unit,\n+     * like \"minutes()\".\n+     * @throws IllegalArgumentException if either duration field is imprecise\n+     * @throws IllegalArgumentException if unit milliseconds is less than one\n+     * or effective value range is less than two.\n+     */\n+    public PreciseDateTimeField(String name,\n+                                DurationField unit, DurationField range) {\n+        super(name, unit);\n+\n+        if (!range.isPrecise()) {\n+            throw new IllegalArgumentException(\"Range duration field must be precise\");\n+        }\n+\n+        long rangeMillis = range.getUnitMillis();\n+        iRange = (int)(rangeMillis / getUnitMillis());\n+        if (iRange < 2) {\n+            throw new IllegalArgumentException(\"The effective range must be at least 2\");\n+        }\n+\n+        iRangeField = range;\n+    }\n+\n+    /**\n+     * Get the amount of fractional units from the specified time instant.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the amount of fractional units extracted from the input.\n+     */\n+    public int get(long instant) {\n+        if (instant >= 0) {\n+            return (int) ((instant / getUnitMillis()) % iRange);\n+        } else {\n+            return iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange);\n+        }\n+    }\n+\n+    /**\n+     * Add to the component of the specified time instant, wrapping around\n+     * within that component if necessary.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param amount  the amount of units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long instant, int amount) {\n+        int thisValue = get(instant);\n+        int wrappedValue = FieldUtils.getWrappedValue\n+            (thisValue, amount, getMinimumValue(), getMaximumValue());\n+        // copy code from set() to avoid repeat call to get()\n+        return instant + (wrappedValue - thisValue) * getUnitMillis();\n+    }\n+\n+    /**\n+     * Set the specified amount of units to the specified time instant.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param value  value of units to set.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException if value is too large or too small.\n+     */\n+    public long set(long instant, int value) {\n+        FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());\n+        return instant + (value - get(instant)) * iUnitMillis;\n+    }\n+\n+    /**\n+     * Returns the range duration of this field. For example, if this field\n+     * represents \"minute of hour\", then the range duration field is an hours.\n+     *\n+     * @return the range duration of this field, or null if field has no range\n+     */\n+    public DurationField getRangeDurationField() {\n+        return iRangeField;\n+    }\n+\n+    /**\n+     * Get the maximum value for the field.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue() {\n+        return iRange - 1;\n+    }\n+    \n+    /**\n+     * Returns the range of the field in the field's units.\n+     * <p>\n+     * For example, 60 for seconds per minute. The field is allowed values\n+     * from 0 to range - 1.\n+     * \n+     * @return unit range\n+     */\n+    public int getRange() {\n+        return iRange;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/PreciseDurationDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Precise datetime field, which has a precise unit duration field.\n+ * <p>\n+ * PreciseDurationDateTimeField is thread-safe and immutable, and its\n+ * subclasses must be as well.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public abstract class PreciseDurationDateTimeField extends AbstractDateTimeField {\n+\n+    static final long serialVersionUID = 5004523158306266035L;\n+\n+    /** The fractional unit in millis */\n+    final long iUnitMillis;\n+\n+    private final DurationField iUnitField;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param name  short, descriptive name, like \"dayOfMonth\".\n+     * @param unit  precise unit duration, like \"days()\".\n+     * @throws IllegalArgumentException if duration field is imprecise\n+     * @throws IllegalArgumentException if unit milliseconds is less than one\n+     */\n+    public PreciseDurationDateTimeField(String name, DurationField unit) {\n+        super(name);\n+\n+        if (!unit.isPrecise()) {\n+            throw new IllegalArgumentException(\"Unit duration field must be precise\");\n+        }\n+\n+        iUnitMillis = unit.getUnitMillis();\n+        if (iUnitMillis < 1) {\n+            throw new IllegalArgumentException(\"The unit milliseconds must be at least 1\");\n+        }\n+\n+        iUnitField = unit;\n+    }\n+\n+    /**\n+     * Returns false by default.\n+     */\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    /**\n+     * Add the specified amount of units to the specified time instant. The\n+     * amount added may be negative.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param amount  the amount of units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, int amount) {\n+        return instant + amount * iUnitMillis;\n+    }\n+\n+    /**\n+     * Add the specified amount of units to the specified time instant. The\n+     * amount added may be negative.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param amount  the amount of units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, long amount) {\n+        return instant + amount * iUnitMillis;\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return (minuendInstant - subtrahendInstant) / iUnitMillis;\n+    }\n+\n+    /**\n+     * Set the specified amount of units to the specified time instant.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param value  value of units to set.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException if value is too large or too small.\n+     */\n+    public long set(long instant, int value) {\n+        FieldUtils.verifyValueBounds(this, value, getMinimumValue(),\n+                                     getMaximumValueForSet(instant, value));\n+        return instant + (value - get(instant)) * iUnitMillis;\n+    }\n+\n+    /**\n+     * This method assumes that this field is properly rounded on\n+     * 1970-01-01T00:00:00. If the rounding alignment differs, override this\n+     * method as follows:\n+     * <pre>\n+     * return super.roundFloor(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;\n+     * </pre>\n+     */\n+    public long roundFloor(long instant) {\n+        if (instant >= 0) {\n+            return instant - instant % iUnitMillis;\n+        } else {\n+            instant += 1;\n+            return instant - instant % iUnitMillis - iUnitMillis;\n+        }\n+    }\n+\n+    /**\n+     * This method assumes that this field is properly rounded on\n+     * 1970-01-01T00:00:00. If the rounding alignment differs, override this\n+     * method as follows:\n+     * <pre>\n+     * return super.roundCeiling(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;\n+     * </pre>\n+     */\n+    public long roundCeiling(long instant) {\n+        if (instant >= 0) {\n+            instant -= 1;\n+            return instant - instant % iUnitMillis + iUnitMillis;\n+        } else {\n+            return instant - instant % iUnitMillis;\n+        }\n+    }\n+\n+    /**\n+     * This method assumes that this field is properly rounded on\n+     * 1970-01-01T00:00:00. If the rounding alignment differs, override this\n+     * method as follows:\n+     * <pre>\n+     * return super.remainder(instant + ALIGNMENT_MILLIS);\n+     * </pre>\n+     */\n+    public long remainder(long instant) {\n+        if (instant >= 0) {\n+            return instant % iUnitMillis;\n+        } else {\n+            return (instant + 1) % iUnitMillis + iUnitMillis - 1;\n+        }\n+    }\n+\n+    /**\n+     * Returns the duration per unit value of this field. For example, if this\n+     * field represents \"minute of hour\", then the duration field is minutes.\n+     *\n+     * @return the duration of this field, or UnsupportedDurationField if field\n+     * has no duration\n+     */\n+    public DurationField getDurationField() {\n+        return iUnitField;\n+    }\n+\n+    /**\n+     * Get the minimum value for the field.\n+     * \n+     * @return the minimum value\n+     */\n+    public int getMinimumValue() {\n+        return 0;\n+    }\n+\n+    public final long getUnitMillis() {\n+        return iUnitMillis;\n+    }\n+\n+    /**\n+     * Called by the set method to get the maximum allowed value. By default,\n+     * returns getMaximumValue(instant). Override to provide a faster\n+     * implementation.\n+     */\n+    protected int getMaximumValueForSet(long instant, int value) {\n+        return getMaximumValue(instant);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/PreciseDurationField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+/**\n+ * Duration field class representing a field with a fixed unit length.\n+ * <p>\n+ * PreciseDurationField is thread-safe and immutable.\n+ * \n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class PreciseDurationField extends AbstractDurationField {\n+    \n+    static final long serialVersionUID = -8346152187724495365L;\n+\n+    /** The size of the unit */\n+    private final long iUnitMillis;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param name  the name of the field, like \"seconds\"\n+     * @param unitMillis  the unit milliseconds\n+     */    \n+    public PreciseDurationField(String name, long unitMillis) {\n+        super(name);\n+        iUnitMillis = unitMillis;\n+    }\n+    \n+    //------------------------------------------------------------------------\n+    /**\n+     * This field is precise.\n+     * \n+     * @return true always\n+     */\n+    public final boolean isPrecise() {\n+        return true;\n+    }\n+    \n+    /**\n+     * Returns the amount of milliseconds per unit value of this field.\n+     *\n+     * @return the unit size of this field, in milliseconds\n+     */\n+    public final long getUnitMillis() {\n+        return iUnitMillis;\n+    }\n+\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get the value of this field from the milliseconds.\n+     * \n+     * @param duration  the milliseconds to query, which may be negative\n+     * @param instant  ignored\n+     * @return the value of the field, in the units of the field, which may be\n+     * negative\n+     */\n+    public long getValueAsLong(long duration, long instant) {\n+        return duration / iUnitMillis;\n+    }\n+\n+    /**\n+     * Get the millisecond duration of this field from its value.\n+     * \n+     * @param value  the value of the field, which may be negative\n+     * @param instant  ignored\n+     * @return the milliseconds that the field represents, which may be\n+     * negative\n+     */\n+    public long getMillis(int value, long instant) {\n+        return value * iUnitMillis;\n+    }\n+\n+    /**\n+     * Get the millisecond duration of this field from its value.\n+     * \n+     * @param value  the value of the field, which may be negative\n+     * @param instant  ignored\n+     * @return the milliseconds that the field represents, which may be\n+     * negative\n+     */\n+    public long getMillis(long value, long instant) {\n+        return value * iUnitMillis;\n+    }\n+\n+    public long add(long instant, int value) {\n+        return instant + value * iUnitMillis;\n+    }\n+\n+    public long add(long instant, long value) {\n+        return instant + value * iUnitMillis;\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return (minuendInstant - subtrahendInstant) / iUnitMillis;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/RemainderDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Counterpart remainder datetime field to {@link DividedDateTimeField}. The\n+ * field's unit duration is unchanged, but the range duration is scaled\n+ * accordingly.\n+ * <p>\n+ * RemainderDateTimeField is thread-safe and immutable.\n+ *\n+ * @see DividedDateTimeField\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class RemainderDateTimeField extends DecoratedDateTimeField {\n+\n+    static final long serialVersionUID = 5708241235177666790L;\n+\n+    // Shared with DividedDateTimeField.\n+    final int iDivisor;\n+    final DurationField iRangeField;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param field  the field to wrap, like \"year()\".\n+     * @param name  short, descriptive name, like \"yearOfCentury\".\n+     * @param rangeName  short, descriptive name, like \"centuries\".\n+     * @param divisor  divisor, such as 100 years in a century\n+     * @throws IllegalArgumentException if divisor is less than two\n+     */\n+    public RemainderDateTimeField(DateTimeField field,\n+                                  String name, String rangeName, int divisor) {\n+        super(field, name);\n+\n+        if (divisor < 2) {\n+            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n+        }\n+\n+        DurationField rangeField = field.getDurationField();\n+        if (rangeField == null) {\n+            iRangeField = null;\n+        } else {\n+            iRangeField = new ScaledDurationField(rangeField, rangeName, divisor);\n+        }\n+\n+        iDivisor = divisor;\n+    }\n+\n+    /**\n+     * Construct a RemainderDateTimeField that compliments the given\n+     * DividedDateTimeField.\n+     *\n+     * @param dividedField  complimentary divided field, like \"century()\".\n+     * @param name  short, descriptive name, like \"yearOfCentury\".\n+     */\n+    public RemainderDateTimeField(DividedDateTimeField dividedField, String name) {\n+        super(dividedField.getWrappedField(), name);\n+        iDivisor = dividedField.iDivisor;\n+        iRangeField = dividedField.iDurationField;\n+    }\n+\n+    /**\n+     * Get the remainder from the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to query.\n+     * @return the remainder extracted from the input.\n+     */\n+    public int get(long instant) {\n+        int value = getWrappedField().get(instant);\n+        if (value >= 0) {\n+            return value % iDivisor;\n+        } else {\n+            return (iDivisor - 1) + ((value + 1) % iDivisor);\n+        }\n+    }\n+\n+    /**\n+     * Add the specified amount to the specified time instant, wrapping around\n+     * within the remainder range if necessary. The amount added may be\n+     * negative.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param amount  the amount to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long instant, int amount) {\n+        return set(instant, FieldUtils.getWrappedValue(get(instant), amount, 0, iDivisor - 1));\n+    }\n+\n+    /**\n+     * Set the specified amount of remainder units to the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param value  value of remainder units to set.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException if value is too large or too small.\n+     */\n+    public long set(long instant, int value) {\n+        FieldUtils.verifyValueBounds(this, value, 0, iDivisor - 1);\n+        int divided = getDivided(getWrappedField().get(instant));\n+        return getWrappedField().set(instant, divided * iDivisor + value);\n+    }\n+\n+    /**\n+     * Returns a scaled version of the wrapped field's unit duration field.\n+     */\n+    public DurationField getRangeDurationField() {\n+        return iRangeField;\n+    }\n+\n+    /**\n+     * Get the minimum value for the field, which is always zero.\n+     * \n+     * @return the minimum value of zero.\n+     */\n+    public int getMinimumValue() {\n+        return 0;\n+    }\n+\n+    /**\n+     * Get the maximum value for the field, which is always one less than the\n+     * divisor.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue() {\n+        return iDivisor - 1;\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return getWrappedField().roundFloor(instant);\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        return getWrappedField().roundCeiling(instant);\n+    }\n+\n+    public long roundHalfFloor(long instant) {\n+        return getWrappedField().roundHalfFloor(instant);\n+    }\n+\n+    public long roundHalfCeiling(long instant) {\n+        return getWrappedField().roundHalfCeiling(instant);\n+    }\n+\n+    public long roundHalfEven(long instant) {\n+        return getWrappedField().roundHalfEven(instant);\n+    }\n+\n+    public long remainder(long instant) {\n+        return getWrappedField().remainder(instant);\n+    }\n+\n+    /**\n+     * Returns the divisor applied, in the field's units.\n+     * \n+     * @return the divisor\n+     */\n+    public int getDivisor() {\n+        return iDivisor;\n+    }\n+\n+    private int getDivided(int value) {\n+        if (value >= 0) {\n+            return value / iDivisor;\n+        } else {\n+            return ((value + 1) / iDivisor) - 1;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/ScaledDurationField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Scales a DurationField such that it's unit millis becomes larger in\n+ * magnitude.\n+ * <p>\n+ * ScaledDurationField is thread-safe and immutable.\n+ *\n+ * @see PreciseDurationField\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public class ScaledDurationField extends DecoratedDurationField {\n+\n+    static final long serialVersionUID = -3205227092378684157L;\n+\n+    private final int iScalar;\n+\n+    /**\n+     * Constructor\n+     * \n+     * @param field  the field to wrap, like \"year()\".\n+     * @param name  short, descriptive name, like \"centuries\".\n+     * @param scalar  scalar, such as 100 years in a century\n+     * @throws IllegalArgumentException if scalar is zero or one.\n+     */\n+    public ScaledDurationField(DurationField field, String name, int scalar) {\n+        super(field, name);\n+        if (scalar == 0 || scalar == 1) {\n+            throw new IllegalArgumentException(\"The scalar must not be 0 or 1\");\n+        }\n+        iScalar = scalar;\n+    }\n+\n+    public int getValue(long duration) {\n+        return getWrappedField().getValue(duration) / iScalar;\n+    }\n+\n+    public long getValueAsLong(long duration) {\n+        return getWrappedField().getValueAsLong(duration) / iScalar;\n+    }\n+\n+    public int getValue(long duration, long instant) {\n+        return getWrappedField().getValue(duration, instant) / iScalar;\n+    }\n+\n+    public long getValueAsLong(long duration, long instant) {\n+        return getWrappedField().getValueAsLong(duration, instant) / iScalar;\n+    }\n+\n+    public long getMillis(int value) {\n+        return getWrappedField().getMillis(value * iScalar);\n+    }\n+\n+    public long getMillis(long value) {\n+        return getWrappedField().getMillis(value * iScalar);\n+    }\n+\n+    public long getMillis(int value, long instant) {\n+        return getWrappedField().getMillis(value * iScalar, instant);\n+    }\n+\n+    public long getMillis(long value, long instant) {\n+        return getWrappedField().getMillis(value * iScalar, instant);\n+    }\n+\n+    public long add(long instant, int value) {\n+        return getWrappedField().add(instant, value * iScalar);\n+    }\n+\n+    public long add(long instant, long value) {\n+        return getWrappedField().add(instant, value * iScalar);\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant) / iScalar;\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant) / iScalar;\n+    }\n+\n+    public long getUnitMillis() {\n+        return getWrappedField().getUnitMillis() * iScalar;\n+    }\n+\n+    /**\n+     * Returns the scalar applied, in the field's units.\n+     * \n+     * @return the scalar\n+     */\n+    public int getScalar() {\n+        return iScalar;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/StrictDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Converts a lenient DateTimeField into a strict one. By being strict, the set\n+ * throws an IllegalArgumentException if the value is out of bounds.\n+ * <p>\n+ * StrictDateTimeField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @see org.joda.time.chrono.StrictChronology\n+ * @see LenientDateTimeField\n+ */\n+public class StrictDateTimeField extends DelegatedDateTimeField {\n+\n+    static final long serialVersionUID = 3154803964207950910L;\n+\n+    /**\n+     * Returns a strict version of the given field. If it is already strict,\n+     * then it is returned as-is. Otherwise, a new StrictDateTimeField is\n+     * returned.\n+     */\n+    public static DateTimeField getInstance(DateTimeField field) {\n+        if (field == null) {\n+            return null;\n+        }\n+        if (field instanceof LenientDateTimeField) {\n+            field = ((LenientDateTimeField)field).getWrappedField();\n+        }\n+        if (!field.isLenient()) {\n+            return field;\n+        }\n+        return new StrictDateTimeField(field);\n+    }\n+\n+    protected StrictDateTimeField(DateTimeField field) {\n+        super(field);\n+    }\n+\n+    public final boolean isLenient() {\n+        return false;\n+    }\n+\n+    /**\n+     * Does a bounds check before setting the value.\n+     *\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public long set(long instant, int value) {\n+        FieldUtils.verifyValueBounds\n+            (this, value, getMinimumValue(instant), getMaximumValue(instant));\n+        return super.set(instant, value);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * A placeholder implementation to use when a datetime field is not supported.\n+ * <p>\n+ * UnsupportedDateTimeField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public final class UnsupportedDateTimeField implements DateTimeField, Serializable {\n+\n+    static final long serialVersionUID = -1934618396111902255L;\n+\n+    /**\n+     * Instance with the name \"unsupported\".\n+     */\n+    public static final UnsupportedDateTimeField INSTANCE =\n+        getInstance(\"unsupported\", UnsupportedDurationField.INSTANCE);\n+\n+    private static HashMap cCache;\n+\n+    /**\n+     * @throws IllegalArgumentException if durationField is null\n+     */\n+    public static synchronized UnsupportedDateTimeField getInstance\n+        (String name, DurationField durationField) {\n+\n+        UnsupportedDateTimeField field;\n+        if (cCache == null) {\n+            cCache = new HashMap(7);\n+            field = null;\n+        } else {\n+            field = (UnsupportedDateTimeField)cCache.get(name);\n+            if (field != null && field.getDurationField() != durationField) {\n+                field = null;\n+            }\n+        }\n+        if (field == null) {\n+            field = new UnsupportedDateTimeField(name, durationField);\n+            cCache.put(name, field);\n+        }\n+        return field;\n+    }\n+\n+    private final String iName;\n+    private final DurationField iDurationField;\n+\n+    private UnsupportedDateTimeField(String name, DurationField durationField) {\n+        if (durationField == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        iName = name;\n+        iDurationField = durationField;\n+    }\n+\n+    // Design note: Simple accessors return a suitable value, but methods\n+    // intended to perform calculations throw an UnsupportedOperationException.\n+\n+    public String getName() {\n+        return iName;\n+    }\n+\n+    /**\n+     * This field is not supported.\n+     *\n+     * @return false always\n+     */\n+    public boolean isSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * This field is not lenient.\n+     *\n+     * @return false always\n+     */\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int get(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public String getAsText(long instant, Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public String getAsText(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public String getAsShortText(long instant, Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public String getAsShortText(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Delegates to the duration field.\n+     *\n+     * @throws UnsupportedOperationException if the duration is unsupported\n+     */\n+    public long add(long instant, int value) {\n+        return getDurationField().add(instant, value);\n+    }\n+\n+    /**\n+     * Delegates to the duration field.\n+     *\n+     * @throws UnsupportedOperationException if the duration is unsupported\n+     */\n+    public long add(long instant, long value) {\n+        return getDurationField().add(instant, value);\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long addWrapped(long instant, int value) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Delegates to the duration field.\n+     *\n+     * @throws UnsupportedOperationException if the duration is unsupported\n+     */\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getDurationField().getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    /**\n+     * Delegates to the duration field.\n+     *\n+     * @throws UnsupportedOperationException if the duration is unsupported\n+     */\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long set(long instant, int value) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long set(long instant, String text, Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long set(long instant, String text) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Even though this DateTimeField is unsupported, the duration field might\n+     * be supported.\n+     *\n+     * @return a possibly supported DurationField\n+     */\n+    public DurationField getDurationField() {\n+        return iDurationField;\n+    }\n+\n+    /**\n+     * Always returns null.\n+     *\n+     * @return null always\n+     */\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public boolean isLeap(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getLeapAmount(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always returns null.\n+     *\n+     * @return null always\n+     */\n+    public DurationField getLeapDurationField() {\n+        return null;\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMinimumValue() {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMinimumValue(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMaximumValue() {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMaximumValue(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long roundFloor(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long roundCeiling(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long roundHalfFloor(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long roundHalfCeiling(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long roundHalfEven(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long remainder(long instant) {\n+        throw unsupported();\n+    }\n+\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return \"UnsupportedDateTimeField\";\n+    }\n+\n+    /**\n+     * Ensure proper singleton serialization\n+     */\n+    private Object readResolve() {\n+        return getInstance(iName, iDurationField);\n+    }\n+\n+    private UnsupportedOperationException unsupported() {\n+        return new UnsupportedOperationException(iName + \" field is unsupported\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDurationField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * A placeholder implementation to use when a duration field is not supported.\n+ * <p>\n+ * UnsupportedDurationField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public final class UnsupportedDurationField implements DurationField, Serializable {\n+\n+    static final long serialVersionUID = -6390301302770925357L;\n+\n+    /**\n+     * Instance with the name \"unsupported\".\n+     */\n+    public static final UnsupportedDurationField INSTANCE = getInstance(\"unsupported\");\n+\n+    private static HashMap cCache;\n+\n+    public static synchronized UnsupportedDurationField getInstance(String name) {\n+        UnsupportedDurationField field;\n+        if (cCache == null) {\n+            cCache = new HashMap(7);\n+            field = null;\n+        } else {\n+            field = (UnsupportedDurationField)cCache.get(name);\n+        }\n+        if (field == null) {\n+            field = new UnsupportedDurationField(name);\n+            cCache.put(name, field);\n+        }\n+        return field;\n+    }\n+\n+    private final String iName;\n+\n+    private UnsupportedDurationField(String name) {\n+        iName = name;\n+    }\n+\n+    // Design note: Simple Accessors return a suitable value, but methods\n+    // intended to perform calculations throw an UnsupportedOperationException.\n+\n+    public String getName() {\n+        return iName;\n+    }\n+\n+    /**\n+     * This field is not supported.\n+     *\n+     * @return false always\n+     */\n+    public boolean isSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * This field is precise.\n+     * \n+     * @return true always\n+     */\n+    public boolean isPrecise() {\n+        return true;\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getValue(long duration) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getValueAsLong(long duration) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getValue(long duration, long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getValueAsLong(long duration, long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getMillis(int value) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getMillis(long value) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getMillis(int value, long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getMillis(long value, long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long add(long instant, int value) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long add(long instant, long value) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always returns zero.\n+     *\n+     * @return zero always\n+     */\n+    public long getUnitMillis() {\n+        return 0;\n+    }\n+\n+    /**\n+     * Always returns zero, indicating that sort order is not relevent.\n+     *\n+     * @return zero always\n+     */\n+    public int compareTo(Object durationField) {\n+        return 0;\n+    }\n+\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return \"UnsupportedDurationField\";\n+    }\n+\n+    /**\n+     * Ensure proper singleton serialization\n+     */\n+    private Object readResolve() {\n+        return getInstance(iName);\n+    }\n+\n+    private UnsupportedOperationException unsupported() {\n+        return new UnsupportedOperationException(iName + \" field is unsupported\");\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n import org.joda.time.MutableDateTime;\n import org.joda.time.ReadWritableInstant;\n import org.joda.time.ReadableInstant;\n-import org.joda.time.chrono.RemainderDateTimeField;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.field.RemainderDateTimeField;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * DateTimeFormat provides localized printing and parsing capabilities for all\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.chrono.MillisDurationField;\n-import org.joda.time.chrono.PreciseDateTimeField;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.field.MillisDurationField;\n+import org.joda.time.field.PreciseDateTimeField;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * DateTimeFormatterBuilder is used for constructing {@link DateTimeFormatter}s.\n--- a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * ISODateTimeFormat provides factory methods for the ISO8601 standard.\n--- a/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * DateTimeZoneBuilder allows complex DateTimeZones to be constructed. Since\n--- a/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java\n+++ b/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java\n import org.joda.time.format.DateTimeParser;\n import org.joda.time.format.ISODateTimeFormat;\n import org.joda.time.chrono.LenientChronology;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * Compiles Olson ZoneInfo database files into binary files for each time zone\n  * @author Brian S O'Neill\n  */\n public class ZoneInfoCompiler {\n-    static final DateTimeOfYear START_OF_YEAR = new DateTimeOfYear();\n+    static DateTimeOfYear cStartOfYear;\n+\n+    static Chronology cLenientISO;\n \n     /**\n      * Launches the ZoneInfoCompiler tool.\n         System.out.println(\"  -dst <directory>    Specify where to write generated files\");\n     }\n \n+    static DateTimeOfYear getStartOfYear() {\n+        if (cStartOfYear == null) {\n+            cStartOfYear = new DateTimeOfYear();\n+        }\n+        return cStartOfYear;\n+    }\n+\n+    static Chronology getLenientISOChronology() {\n+        if (cLenientISO == null) {\n+            cLenientISO = LenientChronology.getInstance(ISOChronology.getInstanceUTC());\n+        }\n+        return cLenientISO;\n+    }\n+\n     /**\n      * @param zimap maps string ids to DateTimeZone objects.\n      */\n     }\n \n     static int parseTime(String str) {\n-        Chronology chrono = new LenientChronology(ISOChronology.getInstanceUTC());\n         DateTimeParser p = ISODateTimeFormat\n-            .getInstance(chrono)\n+            .getInstance(getLenientISOChronology())\n             .hourMinuteSecondFraction();\n-        MutableDateTime mdt = new MutableDateTime(0, chrono);\n+        MutableDateTime mdt = new MutableDateTime(0, getLenientISOChronology());\n         int pos = 0;\n         if (str.startsWith(\"-\")) {\n             pos = 1;\n             iFormat = st.nextToken().intern();\n \n             int year = Integer.MAX_VALUE;\n-            DateTimeOfYear dtOfYear = START_OF_YEAR;\n+            DateTimeOfYear dtOfYear = getStartOfYear();\n \n             if (st.hasMoreTokens()) {\n                 year = Integer.parseInt(st.nextToken());\n--- a/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java\n+++ b/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java\n import org.joda.time.DateTimeZone;\n import org.joda.time.Instant;\n import org.joda.time.ReadableInstant;\n-import org.joda.time.chrono.gj.GJChronology;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.GJChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * This class is a Junit unit test base class for\n--- a/JodaTime/src/test/org/joda/test/time/AbstractTestReadableInstant.java\n+++ b/JodaTime/src/test/org/joda/test/time/AbstractTestReadableInstant.java\n import org.joda.time.DateTimeZone;\n import org.joda.time.Instant;\n import org.joda.time.ReadableInstant;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n /**\n  * This class is a Junit unit test base class for\n  * ReadableInstant implementations.\n--- a/JodaTime/src/test/org/joda/test/time/BulkMDTTests.java\n+++ b/JodaTime/src/test/org/joda/test/time/BulkMDTTests.java\n import junit.framework.TestSuite;\n \n import org.joda.time.*;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n /**\n  * This class is a Junit unit test for the\n  * org.joda.time.MutableDateTime class.\n--- a/JodaTime/src/test/org/joda/test/time/BulkTest.java\n+++ b/JodaTime/src/test/org/joda/test/time/BulkTest.java\n import junit.framework.TestSuite;\n \n import org.joda.time.MutableDateTime;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n /**\n  *  A {@link TestCase} that can define both simple and bulk test methods.<P>\n  *\n--- a/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java\n+++ b/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java\n \n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.chrono.buddhist.BuddhistChronology;\n+import org.joda.time.chrono.BuddhistChronology;\n \n import junit.framework.TestSuite;\n /**\n--- a/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java\n+++ b/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java\n import org.joda.time.DateTimeComparator;\n import org.joda.time.DateTimeZone;\n import org.joda.time.ReadableInstant;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n /**\n  * This class is a Junit unit test for the\n  * org.joda.time.DateTimeComparator class.\n--- a/JodaTime/src/test/org/joda/test/time/TestDateTimeCtors.java\n+++ b/JodaTime/src/test/org/joda/test/time/TestDateTimeCtors.java\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.ReadableInstant;\n-import org.joda.time.chrono.gj.GJChronology;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.GJChronology;\n+import org.joda.time.chrono.ISOChronology;\n /**\n  * This class is a Junit unit test for the CTORs of the\n  * DateTime date time class.  The DateTime class is passed\n--- a/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java\n+++ b/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java\n import org.joda.time.Instant;\n import org.joda.time.MutableDateTime;\n import org.joda.time.ReadableInstant;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n /**\n  * This class is a Junit unit test for the\n  * org.joda.time.MutableDateTime class.\n--- a/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java\n+++ b/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java\n import org.joda.time.Instant;\n import org.joda.time.MutableDateTime;\n import org.joda.time.ReadableInstant;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n /**\n  * This class is a Junit unit test for the\n  * org.joda.time.MutableDateTime class.\n--- a/JodaTime/src/test/org/joda/test/time/TestMDTGet.java\n+++ b/JodaTime/src/test/org/joda/test/time/TestMDTGet.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTimeConstants;\n import org.joda.time.MutableDateTime;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n /**\n  * This class is a Junit unit test for the\n  * org.joda.time.MutableDateTime class.\n--- a/JodaTime/src/test/org/joda/test/time/TestMDTSet.java\n+++ b/JodaTime/src/test/org/joda/test/time/TestMDTSet.java\n import org.joda.time.Instant;\n import org.joda.time.MutableDateTime;\n import org.joda.time.ReadableInstant;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n /**\n  * This class is a Junit unit test for the\n  * org.joda.time.MutableDateTime class.\n--- a/JodaTime/src/test/org/joda/test/time/TestMutableDateTime.java\n+++ b/JodaTime/src/test/org/joda/test/time/TestMutableDateTime.java\n import junit.framework.TestSuite;\n \n import org.joda.time.MutableDateTime;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n /**\n  * This class is a Junit unit test for the\n  * org.joda.time.MutableDateTime class.\n--- a/JodaTime/src/test/org/joda/test/time/TestMutableDateTimeCtors.java\n+++ b/JodaTime/src/test/org/joda/test/time/TestMutableDateTimeCtors.java\n import org.joda.time.DateTime;\n import org.joda.time.MutableDateTime;\n import org.joda.time.ReadableInstant;\n-import org.joda.time.chrono.gj.GJChronology;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.GJChronology;\n+import org.joda.time.chrono.ISOChronology;\n /**\n  * This class is a Junit unit test for the CTORs of the\n  * MutableDateTime date time class.  The MutableDateTime class is passed\n--- a/JodaTime/src/test/org/joda/test/time/buddhist/TestBuddhistEraDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/buddhist/TestBuddhistEraDateTimeField.java\n import org.joda.test.time.AbstractTestDateTimeField;\n import org.joda.test.time.BulkTest;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.buddhist.BuddhistChronology;\n+import org.joda.time.chrono.BuddhistChronology;\n /**\n  * This class is the Junit unit test for a DateTimeField.\n  *\n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GregorianChronology;\n+import org.joda.time.chrono.JulianChronology;\n \n /**\n  * Tests either the Julian or Gregorian chronology from org.joda.time.chrono.gj\n         iMode = mode;\n         if (mode == GREGORIAN_MODE) {\n             iTest = new TestGregorianChronology();\n-            iActual = GJChronology.getInstance(DateTimeZone.UTC, Long.MIN_VALUE, true);\n+            iActual = GregorianChronology.getInstanceUTC();\n         } else {\n             iTest = new TestJulianChronology();\n-            iActual = GJChronology.getInstance(DateTimeZone.UTC, Long.MAX_VALUE, true);\n+            iActual = JulianChronology.getInstanceUTC();\n         }\n     }\n \n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeZone;\n import org.joda.time.DurationField;\n+import org.joda.time.chrono.AbstractChronology;\n \n /**\n  * A reference Gregorian/Julian chronology implementation, intended for testing\n  *\n  * @author Brian S O'Neill\n  */\n-abstract class TestGJChronology extends Chronology {\n+abstract class TestGJChronology extends AbstractChronology {\n     static final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;\n \n     /**\n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java\n  */\n package org.joda.test.time.chrono.gj;\n \n-import org.joda.time.chrono.ImpreciseDateTimeField;\n-import org.joda.time.chrono.Utils;\n+import org.joda.time.field.ImpreciseDateTimeField;\n \n /**\n  * \n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java\n  */\n package org.joda.test.time.chrono.gj;\n \n-import org.joda.time.chrono.Utils;\n+import org.joda.time.field.FieldUtils;\n \n /**\n  * \n \n     public long addWrapped(long millis, int value) {\n         int weekyear = get(millis);\n-        int wrapped = Utils.getWrappedValue\n+        int wrapped = FieldUtils.getWrappedValue\n             (weekyear, value, getMinimumValue(), getMaximumValue());\n         return add(millis, (long) wrapped - weekyear);\n     }\n \n     public long add(long millis, long value) {\n         int weekyear = get(millis);\n-        int newWeekyear = weekyear + Utils.safeToInt(value);\n+        int newWeekyear = weekyear + FieldUtils.safeToInt(value);\n         if (weekyear < 0) {\n             if (newWeekyear >= 0) {\n                 newWeekyear++;\n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java\n  */\n package org.joda.test.time.chrono.gj;\n \n-import org.joda.time.chrono.Utils;\n+import org.joda.time.field.FieldUtils;\n \n /**\n  * \n \n     public long addWrapped(long millis, int value) {\n         int year = get(millis);\n-        int wrapped = Utils.getWrappedValue\n+        int wrapped = FieldUtils.getWrappedValue\n             (year, value, getMinimumValue(), getMaximumValue());\n         return add(millis, (long) wrapped - year);\n     }\n \n     public long add(long millis, long value) {\n         int year = get(millis);\n-        int newYear = year + Utils.safeToInt(value);\n+        int newYear = year + FieldUtils.safeToInt(value);\n         if (year < 0) {\n             if (newYear >= 0) {\n                 newYear++;\n--- a/JodaTime/src/test/org/joda/test/time/gj/AbstractTestGJDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/AbstractTestGJDateTimeField.java\n package org.joda.test.time.gj;\n \n import org.joda.test.time.AbstractTestDateTimeField;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GJChronology;\n /**\n  * This class is a Junit unit test for the date time field.\n  *\n     }\n \n     static final int[] monthLengths = {-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n-    protected static final long GJ_CUTOVER_MILLIS = GJChronology.getInstanceUTC().getGregorianJulianCutoverMillis();\n+    protected static final long GJ_CUTOVER_MILLIS = GJChronology.getInstanceUTC().getGregorianCutover().getMillis();\n     \n     protected int[] getDMYDS(long millis) {\n         return getDMYDS(millis, GJ_CUTOVER_MILLIS, 1582, 10);\n--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfDayDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfDayDateTimeField.java\n \n import org.joda.test.time.AbstractTestDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GJChronology;\n /**\n  * This class is a Junit unit test for the date time field.\n  *\n--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfHalfdayDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfHalfdayDateTimeField.java\n \n import org.joda.test.time.AbstractTestDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GJChronology;\n /**\n  * This class is a Junit unit test for the date time field.\n  *\n--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfMonthDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfMonthDateTimeField.java\n import junit.framework.TestSuite;\n \n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GJChronology;\n /**\n  * This class is a Junit unit test for the date time field.\n  *\n--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfWeekDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfWeekDateTimeField.java\n import org.joda.test.time.AbstractTestDateTimeField;\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GJChronology;\n /**\n  * This class is a Junit unit test for the date time field.\n  *\n--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfYearDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfYearDateTimeField.java\n import junit.framework.TestSuite;\n \n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GJChronology;\n /**\n  * This class is a Junit unit test for the date time field.\n  *\n--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJHalfdayOfDayDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJHalfdayOfDayDateTimeField.java\n \n import org.joda.test.time.AbstractTestDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GJChronology;\n /**\n  * This class is a Junit unit test for the date time field.\n  *\n--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfDayDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfDayDateTimeField.java\n \n import org.joda.test.time.AbstractTestDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GJChronology;\n /**\n  * This class is a Junit unit test for the date time field.\n  *\n--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfHalfdayDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfHalfdayDateTimeField.java\n \n import org.joda.test.time.AbstractTestDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GJChronology;\n /**\n  * This class is a Junit unit test for the date time field.\n  *\n--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfDayDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfDayDateTimeField.java\n \n import org.joda.test.time.AbstractTestDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GJChronology;\n /**\n  * This class is a Junit unit test for the date time field.\n  *\n--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfSecondDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfSecondDateTimeField.java\n \n import org.joda.test.time.AbstractTestDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GJChronology;\n /**\n  * This class is a Junit unit test for the date time field.\n  *\n--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfDayDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfDayDateTimeField.java\n \n import org.joda.test.time.AbstractTestDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GJChronology;\n /**\n  * This class is a Junit unit test for the date time field.\n  *\n--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfHourDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfHourDateTimeField.java\n \n import org.joda.test.time.AbstractTestDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GJChronology;\n /**\n  * This class is a Junit unit test for the date time field.\n  *\n--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJMonthOfYearDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMonthOfYearDateTimeField.java\n import junit.framework.TestSuite;\n \n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GJChronology;\n /**\n  * This class is a Junit unit test for the date time field.\n  *\n--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfDayDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfDayDateTimeField.java\n \n import org.joda.test.time.AbstractTestDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GJChronology;\n /**\n  * This class is a Junit unit test for the date time field.\n  *\n--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfMinuteDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfMinuteDateTimeField.java\n \n import org.joda.test.time.AbstractTestDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GJChronology;\n /**\n  * This class is a Junit unit test for the date time field.\n  *\n--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeField;\n import org.joda.time.Instant;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GJChronology;\n /**\n  * This class is a Junit unit test for the date time field.\n  *\n--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfCenturyDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfCenturyDateTimeField.java\n \n import org.joda.test.time.AbstractTestDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GJChronology;\n /**\n  * This class is a Junit unit test for the date time field.\n  *\n--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java\n \n import org.joda.test.time.AbstractTestDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.GJChronology;\n /**\n  * This class is a Junit unit test for the date time field.\n  *\n--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfDayDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfDayDateTimeField.java\n \n import org.joda.test.time.gj.TestGJClockhourOfDayDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * This class is a Junit unit test for the date time field.\n--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfHalfdayDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfHalfdayDateTimeField.java\n \n import org.joda.test.time.gj.TestGJClockhourOfHalfdayDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * This class is a Junit unit test for the date time field.\n--- a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfMonthDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfMonthDateTimeField.java\n \n import org.joda.test.time.gj.TestGJDayOfMonthDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * This class is a Junit unit test for the date time field.\n--- a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfWeekDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfWeekDateTimeField.java\n \n import org.joda.test.time.gj.TestGJDayOfWeekDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * This class is a Junit unit test for the date time field.\n--- a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfYearDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfYearDateTimeField.java\n \n import org.joda.test.time.gj.TestGJDayOfYearDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * This class is a Junit unit test for the date time field.\n--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOHalfdayOfDayDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOHalfdayOfDayDateTimeField.java\n \n import org.joda.test.time.gj.TestGJHalfdayOfDayDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * This class is a Junit unit test for the date time field.\n--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfDayDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfDayDateTimeField.java\n \n import org.joda.test.time.gj.TestGJHourOfDayDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * This class is a Junit unit test for the date time field.\n--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfHalfdayDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfHalfdayDateTimeField.java\n \n import org.joda.test.time.gj.TestGJHourOfHalfdayDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * This class is a Junit unit test for the date time field.\n--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfDayDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfDayDateTimeField.java\n \n import org.joda.test.time.gj.TestGJMillisOfDayDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * This class is a Junit unit test for the date time field.\n--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfSecondDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfSecondDateTimeField.java\n \n import org.joda.test.time.gj.TestGJMillisOfSecondDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * This class is a Junit unit test for the date time field.\n--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfDayDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfDayDateTimeField.java\n \n import org.joda.test.time.gj.TestGJMinuteOfDayDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * This class is a Junit unit test for the date time field.\n--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfHourDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfHourDateTimeField.java\n \n import org.joda.test.time.gj.TestGJMinuteOfHourDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * This class is a Junit unit test for the date time field.\n--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOMonthOfYearDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMonthOfYearDateTimeField.java\n \n import org.joda.test.time.gj.TestGJMonthOfYearDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * This class is a Junit unit test for the date time field.\n--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfDayDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfDayDateTimeField.java\n \n import org.joda.test.time.gj.TestGJSecondOfDayDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * This class is a Junit unit test for the date time field.\n--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfMinuteDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfMinuteDateTimeField.java\n \n import org.joda.test.time.gj.TestGJSecondOfMinuteDateTimeField;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * This class is a Junit unit test for the date time field.", "timestamp": 1075273950, "metainfo": ""}