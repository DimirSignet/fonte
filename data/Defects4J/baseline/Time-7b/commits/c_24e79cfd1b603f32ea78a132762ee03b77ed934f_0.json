{"sha": "24e79cfd1b603f32ea78a132762ee03b77ed934f", "log": "Split Duration and TimePeriod converters and Javadoc   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/AbstractTimePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractTimePeriod.java\n \n import java.io.Serializable;\n \n-import org.joda.time.convert.DurationConverter;\n import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.TimePeriodConverter;\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.ISOTimePeriodFormat;\n \n     private int iMillis;\n \n     /**\n-     * Creates a duration from the given millisecond duration.\n+     * Creates a period from the given millisecond duration.\n      * <p>\n      * The millisecond duration will be split to fields using a UTC version of\n      * the duration type.\n      *\n      * @param duration  the duration, in milliseconds\n-     * @param type  which set of fields this duration supports\n+     * @param type  which set of fields this period supports\n      * @throws IllegalArgumentException if duration type is invalid\n      */\n     public AbstractTimePeriod(long duration, DurationType type) {\n     }\n \n     /**\n-     * Creates a duration from a set of field values.\n-     *\n-     * @param years  amount of years in this duration, which must be zero if unsupported\n-     * @param months  amount of months in this duration, which must be zero if unsupported\n-     * @param weeks  amount of weeks in this duration, which must be zero if unsupported\n-     * @param days  amount of days in this duration, which must be zero if unsupported\n-     * @param hours  amount of hours in this duration, which must be zero if unsupported\n-     * @param minutes  amount of minutes in this duration, which must be zero if unsupported\n-     * @param seconds  amount of seconds in this duration, which must be zero if unsupported\n-     * @param millis  amount of milliseconds in this duration, which must be zero if unsupported\n-     * @param type  which set of fields this duration supports\n+     * Creates a period from a set of field values.\n+     *\n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @param type  which set of fields this period supports\n      * @throws IllegalArgumentException if duration type is invalid\n      * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n     }\n \n     /**\n-     * Creates a duration from the given interval endpoints.\n+     * Creates a period from the given interval endpoints.\n      *\n      * @param startInstant  interval start, in milliseconds\n      * @param endInstant  interval end, in milliseconds\n-     * @param type  which set of fields this duration supports\n+     * @param type  which set of fields this period supports\n      * @throws IllegalArgumentException if duration type is invalid\n      */\n     public AbstractTimePeriod(long startInstant, long endInstant, DurationType type) {\n     }\n \n     /**\n-     * Creates a duration from the given interval endpoints.\n+     * Creates a period from the given interval endpoints.\n      *\n      * @param startInstant  interval start, null means now\n      * @param endInstant  interval end, null means now\n-     * @param type  which set of fields this duration supports\n+     * @param type  which set of fields this period supports\n      * @throws IllegalArgumentException if duration type is invalid\n      */\n     public AbstractTimePeriod(\n     }\n \n     /**\n-     * Creates a new duration based on another using the {@link ConverterManager}.\n-     *\n-     * @param duration  duration to convert\n-     * @param type  which set of fields this duration supports, null means use type from object\n-     * @throws IllegalArgumentException if duration is invalid\n+     * Creates a new period based on another using the {@link ConverterManager}.\n+     *\n+     * @param period  the period to convert\n+     * @param type  which set of fields this period supports, null means use type from object\n+     * @throws IllegalArgumentException if period is invalid\n      * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n-    public AbstractTimePeriod(Object duration, DurationType type) {\n+    public AbstractTimePeriod(Object period, DurationType type) {\n         super();\n-        DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);\n-        type = (type == null ? converter.getDurationType(duration, false) : type);\n+        TimePeriodConverter converter = ConverterManager.getInstance().getTimePeriodConverter(period);\n+        type = (type == null ? converter.getDurationType(period, false) : type);\n         type = checkDurationType(type);\n         iType = type;\n-        if (type.isPrecise() && converter.isPrecise(duration)) {\n-            // Only call a private method\n-            setTimePeriod(type, converter.getDurationMillis(duration));\n-        } else if (this instanceof ReadWritableTimePeriod) {\n-            converter.setInto((ReadWritableTimePeriod) this, duration);\n+        if (this instanceof ReadWritableTimePeriod) {\n+            converter.setInto((ReadWritableTimePeriod) this, period);\n         } else {\n             // Only call a private method\n-            setTimePeriod(type, new MutableTimePeriod(duration, type));\n+            setTimePeriod(type, new MutableTimePeriod(period, type));\n         }\n     }\n \n \n     //-----------------------------------------------------------------------\n     /**\n-     * Returns the object which defines which fields this duration supports.\n+     * Returns the object which defines which fields this period supports.\n      */\n     public final DurationType getDurationType() {\n         return iType;\n     }\n \n     /**\n-     * Is this duration a precise length of time, or descriptive.\n-     * <p>\n-     * A typical precise duration could include millis, seconds, minutes or hours,\n+     * Is this period a precise length of time, or descriptive.\n+     * <p>\n+     * A typical precise period could include millis, seconds, minutes or hours,\n      * but days, weeks, months and years usually vary in length, resulting in\n-     * an imprecise duration.\n-     * <p>\n-     * An imprecise duration can be made precise by pairing it with a\n+     * an imprecise period.\n+     * <p>\n+     * An imprecise period can be made precise by pairing it with a\n      * date in a {@link ReadableInterval}.\n      *\n-     * @return true if the duration is precise\n+     * @return true if the period is precise\n      */\n     public final boolean isPrecise() {\n         int state = iState;\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Adds this duration to the given instant using the chronology of the duration\n+     * Adds this period to the given instant using the chronology of the period\n      * which typically ignores time zones.\n      * <p>\n      * To add just once, pass in a scalar of one. To subtract once, pass\n      * in a scalar of minus one.\n      *\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n-     * duration to\n-     * @param scalar  the number of times to add the duration, negative to subtract\n-     * @return milliseconds value plus this duration times scalar\n+     * period to\n+     * @param scalar  the number of times to add the period, negative to subtract\n+     * @return milliseconds value plus this period times scalar\n      * @throws ArithmeticException if the result of the calculation is too large\n      */\n     public final long addTo(long instant, int scalar) {\n     }\n \n     /**\n-     * Adds this duration to the given instant using a specific chronology.\n+     * Adds this period to the given instant using a specific chronology.\n      * <p>\n      * To add just once, pass in a scalar of one. To subtract once, pass\n      * in a scalar of minus one.\n      *\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n-     * duration to\n-     * @param scalar  the number of times to add the duration, negative to subtract\n-     * @param chrono  override the duration's chronology, unless null is passed in\n-     * @return milliseconds value plus this duration times scalar\n+     * period to\n+     * @param scalar  the number of times to add the period, negative to subtract\n+     * @param chrono  override the period's chronology, unless null is passed in\n+     * @return milliseconds value plus this period times scalar\n      * @throws ArithmeticException if the result of the calculation is too large\n      */\n     public final long addTo(long instant, int scalar, Chronology chrono) {\n     }\n \n     /**\n-     * Adds this duration to the given instant using the chronology of the specified\n+     * Adds this period to the given instant using the chronology of the specified\n      * instant (if present), returning a new Instant.\n      * <p>\n      * To add just once, pass in a scalar of one. To subtract once, pass\n      * in a scalar of minus one.\n      *\n-     * @param instant  the instant to add the duration to, null means now\n-     * @param scalar  the number of times to add the duration, negative to subtract\n-     * @return instant with the original value plus this duration times scalar\n+     * @param instant  the instant to add the period to, null means now\n+     * @param scalar  the number of times to add the period, negative to subtract\n+     * @return instant with the original value plus this period times scalar\n      * @throws ArithmeticException if the result of the calculation is too large\n      */\n     public final Instant addTo(ReadableInstant instant, int scalar) {\n     }\n \n     /**\n-     * Adds this duration into the given mutable instant using the chronology of\n+     * Adds this period into the given mutable instant using the chronology of\n      * the specified mutable instant (if present).\n      * <p>\n      * To add just once, pass in a scalar of one. To subtract once, pass\n      * in a scalar of minus one.\n      *\n-     * @param instant  the instant to update with the added duration, must not be null\n-     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @param instant  the instant to update with the added period, must not be null\n+     * @param scalar  the number of times to add the period, negative to subtract\n      * @throws IllegalArgumentException if the instant is null\n      * @throws ArithmeticException if the result of the calculation is too large\n      */\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the years field part of the duration.\n-     * \n-     * @return the number of years in the duration, zero if unsupported\n+     * Gets the years field part of the period.\n+     * \n+     * @return the number of years in the period, zero if unsupported\n      */\n     public final int getYears() {\n         return iYears;\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the months field part of the duration.\n-     * \n-     * @return the number of months in the duration, zero if unsupported\n+     * Gets the months field part of the period.\n+     * \n+     * @return the number of months in the period, zero if unsupported\n      */\n     public final int getMonths() {\n         return iMonths;\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the weeks field part of the duration.\n-     * \n-     * @return the number of weeks in the duration, zero if unsupported\n+     * Gets the weeks field part of the period.\n+     * \n+     * @return the number of weeks in the period, zero if unsupported\n      */\n     public final int getWeeks() {\n         return iWeeks;\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the days field part of the duration.\n-     * \n-     * @return the number of days in the duration, zero if unsupported\n+     * Gets the days field part of the period.\n+     * \n+     * @return the number of days in the period, zero if unsupported\n      */\n     public final int getDays() {\n         return iDays;\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the hours field part of the duration.\n-     * \n-     * @return the number of hours in the duration, zero if unsupported\n+     * Gets the hours field part of the period.\n+     * \n+     * @return the number of hours in the period, zero if unsupported\n      */\n     public final int getHours() {\n         return iHours;\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the minutes field part of the duration.\n-     * \n-     * @return the number of minutes in the duration, zero if unsupported\n+     * Gets the minutes field part of the period.\n+     * \n+     * @return the number of minutes in the period, zero if unsupported\n      */\n     public final int getMinutes() {\n         return iMinutes;\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the seconds field part of the duration.\n-     * \n-     * @return the number of seconds in the duration, zero if unsupported\n+     * Gets the seconds field part of the period.\n+     * \n+     * @return the number of seconds in the period, zero if unsupported\n      */\n     public final int getSeconds() {\n         return iSeconds;\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the millis field part of the duration.\n-     * \n-     * @return the number of millis in the duration, zero if unsupported\n+     * Gets the millis field part of the period.\n+     * \n+     * @return the number of millis in the period, zero if unsupported\n      */\n     public final int getMillis() {\n         return iMillis;\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the total length of this duration in milliseconds, \n-     * failing if the duration is imprecise.\n-     *\n-     * @return the total length of the duration in milliseconds.\n-     * @throws IllegalStateException if the duration is imprecise\n+     * Gets the total millisecond duration of this period,\n+     * failing if the period is imprecise.\n+     *\n+     * @return the total length of the period in milliseconds.\n+     * @throws IllegalStateException if the period is imprecise\n      * @throws ArithmeticException if the millis exceeds the capacity of the duration\n      */\n     public final long toDurationMillis() {\n     }\n \n     /**\n-     * Gets the total length of this duration in milliseconds, \n-     * failing if the duration is imprecise.\n-     *\n-     * @return the total length of the duration in milliseconds.\n-     * @throws IllegalStateException if the duration is imprecise\n+     * Gets the total millisecond duration of this period,\n+     * failing if the period is imprecise.\n+     *\n+     * @return the total length of the period in milliseconds.\n+     * @throws IllegalStateException if the period is imprecise\n      * @throws ArithmeticException if the millis exceeds the capacity of the duration\n      */\n     public final Duration toDuration() {\n      * Compares this object with the specified object for equality based\n      * on the value of each field. All ReadableTimePeriod instances are accepted.\n      * <p>\n-     * To compare two durations for absolute duration (ie. millisecond duration\n+     * To compare two periods for absolute duration (ie. millisecond duration\n      * ignoring the fields), use {@link #toDurationMillis()} or {@link #toDuration()}.\n      *\n-     * @param readableDuration  a readable duration to check against\n+     * @param readablePeriod  a readable period to check against\n      * @return true if all the field values are equal, false if\n-     *  not or the duration is null or of an incorrect type\n-     */\n-    public final boolean equals(Object readableTimePeriod) {\n-        if (this == readableTimePeriod) {\n+     *  not or the period is null or of an incorrect type\n+     */\n+    public final boolean equals(Object readablePeriod) {\n+        if (this == readablePeriod) {\n             return true;\n         }\n-        if (readableTimePeriod instanceof ReadableTimePeriod == false) {\n+        if (readablePeriod instanceof ReadableTimePeriod == false) {\n             return false;\n         }\n-        ReadableTimePeriod other = (ReadableTimePeriod) readableTimePeriod;\n+        ReadableTimePeriod other = (ReadableTimePeriod) readablePeriod;\n         DurationType type = getDurationType();\n         if (type.equals(other.getDurationType()) == false) {\n             return false;\n     }\n \n     /**\n-     * Gets a hash code for the duration that is compatable with the \n+     * Gets a hash code for the period that is compatable with the \n      * equals method.\n      *\n      * @return a hash code\n      * empty implementation that is protected and final. This also ensures that\n      * all lower subclasses are also immutable.\n      * \n-     * @param years  amount of years in this duration, which must be zero if unsupported\n-     * @param months  amount of months in this duration, which must be zero if unsupported\n-     * @param weeks  amount of weeks in this duration, which must be zero if unsupported\n-     * @param days  amount of days in this duration, which must be zero if unsupported\n-     * @param hours  amount of hours in this duration, which must be zero if unsupported\n-     * @param minutes  amount of minutes in this duration, which must be zero if unsupported\n-     * @param seconds  amount of seconds in this duration, which must be zero if unsupported\n-     * @param millis  amount of milliseconds in this duration, which must be zero if unsupported\n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n      * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n     protected void setTimePeriod(int years, int months, int weeks, int days,\n     //-----------------------------------------------------------------------\n     /**\n      * Walks through the field values, determining total millis and whether\n-     * this duration is precise.\n+     * this period is precise.\n      *\n      * @return new state\n-     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n+     * @throws ArithmeticException if the millis exceeds the capacity of the period\n      */\n     private int updateTotalMillis() {\n         final DurationType type = iType;\n      */\n     protected void add(ReadableInterval interval) {\n         if (interval != null) {\n-            add(new TimePeriod(interval.getStartMillis(), interval.getEndMillis()));\n+            add(interval.toTimePeriod(getDurationType()));\n         }\n     }\n \n     }\n \n     /**\n-     * Normalizes all the field values in this duration.\n+     * Normalizes all the field values in this period.\n      * <p>\n      * This method converts to a milliecond duration and back again.\n      *\n-     * @throws IllegalStateException if this duration is imprecise\n+     * @throws IllegalStateException if this period is imprecise\n      */\n     protected void normalize() {\n         setTimePeriod(toDurationMillis());\n--- a/JodaTime/src/java/org/joda/time/JodaTimePermission.java\n+++ b/JodaTime/src/java/org/joda/time/JodaTimePermission.java\n  * ConverterManager\n  *   .alterInstantConverters     Allows an instant converter to be added or removed\n  *   .alterDurationConverters    Allows a duration converter to be added or removed\n+ *   .alterTimePeriodConverters  Allows a time period converter to be added or removed\n  *   .alterIntervalConverters    Allows an interval converter to be added or removed\n  *\n  * CurrentTime.setProvider       Allows the current time provider to be set\n--- a/JodaTime/src/java/org/joda/time/MutableTimePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/MutableTimePeriod.java\n     }\n \n     /**\n-     * Adds an interval to this one by dividing the duration into\n-     * fields and then adding each field in turn.\n+     * Adds an interval to this one by converting it to a period using the same\n+     * duration type and then adding each field in turn.\n      * \n      * @param interval  the interval to add, null means add nothing\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n--- a/JodaTime/src/java/org/joda/time/ReadableTimePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableTimePeriod.java\n public interface ReadableTimePeriod {\n \n     /**\n-     * Returns the object which defines which fields this duration supports.\n+     * Returns the object which defines which fields this period supports.\n      */\n     DurationType getDurationType();\n \n     /**\n-     * Is this duration a precise length of time, or descriptive.\n-     * <p>\n-     * A precise duration could include millis, seconds, minutes or hours.\n+     * Is this period a precise length of time, or descriptive.\n+     * <p>\n+     * A precise period could include millis, seconds, minutes or hours.\n      * However, days, weeks, months and years can vary in length, resulting in\n-     * an imprecise duration.\n-     * <p>\n-     * An imprecise duration can be made precise by pairing it with a\n+     * an imprecise period.\n+     * <p>\n+     * An imprecise period can be made precise by pairing it with a\n      * date in a {@link ReadableInterval}.\n      *\n-     * @return true if the duration is precise\n+     * @return true if the period is precise\n      */\n     boolean isPrecise();\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Adds this duration to the given instant, returning a new value.\n+     * Adds this period to the given instant, returning a new value.\n      * <p>\n      * The addition uses the chronology of the DurationType.\n      * To add just once, pass in a scalar of one. To subtract once, pass\n      * in a scalar of minus one.\n      *\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n-     * duration to\n-     * @param scalar  the number of times to add the duration, negative to subtract\n-     * @return milliseconds value plus this duration times scalar\n+     * period to\n+     * @param scalar  the number of times to add the period, negative to subtract\n+     * @return milliseconds value plus this period times scalar\n      * @throws ArithmeticException if the result of the calculation is too large\n      */\n     long addTo(long instant, int scalar);\n \n     /**\n-     * Adds this duration to the given instant, returning a new value.\n+     * Adds this period to the given instant, returning a new value.\n      * <p>\n      * The addition uses the chronology specified.\n      * To add just once, pass in a scalar of one. To subtract once, pass\n      * in a scalar of minus one.\n      *\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n-     * duration to\n-     * @param scalar  the number of times to add the duration, negative to subtract\n-     * @param chrono  override the chronology of the duration type, unless null is passed in\n-     * @return milliseconds value plus this duration times scalar\n+     * period to\n+     * @param scalar  the number of times to add the period, negative to subtract\n+     * @param chrono  override the chronology of the period type, unless null is passed in\n+     * @return milliseconds value plus this period times scalar\n      * @throws ArithmeticException if the result of the calculation is too large\n      */\n     long addTo(long instant, int scalar, Chronology chrono);\n \n     /**\n-     * Adds this duration to the given instant, returning a new Instant.\n-     * <p>\n-     * To add just once, pass in a scalar of one. To subtract once, pass\n-     * in a scalar of minus one.\n-     *\n-     * @param instant  the instant to add the duration to\n-     * @param scalar  the number of times to add the duration, negative to subtract\n-     * @return instant with the original value plus this duration times scalar\n+     * Adds this period to the given instant, returning a new Instant.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the instant to add the period to\n+     * @param scalar  the number of times to add the period, negative to subtract\n+     * @return instant with the original value plus this period times scalar\n      * @throws IllegalArgumentException if the instant is null\n      * @throws ArithmeticException if the result of the calculation is too large\n      */\n     Instant addTo(ReadableInstant instant, int scalar);\n \n     /**\n-     * Adds this duration into the given mutable instant.\n-     * <p>\n-     * To add just once, pass in a scalar of one. To subtract once, pass\n-     * in a scalar of minus one.\n-     *\n-     * @param instant  the instant to update with the added duration\n-     * @param scalar  the number of times to add the duration, negative to subtract\n+     * Adds this period into the given mutable instant.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the instant to update with the added period\n+     * @param scalar  the number of times to add the period, negative to subtract\n      * @throws IllegalArgumentException if the instant is null\n      * @throws ArithmeticException if the result of the calculation is too large\n      */\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the years field part of the duration.\n-     * \n-     * @return the number of years in the duration, zero if unsupported\n+     * Gets the years field part of the period.\n+     * \n+     * @return the number of years in the period, zero if unsupported\n      */\n     int getYears();\n \n     /**\n-     * Gets the months field part of the duration.\n-     * \n-     * @return the number of months in the duration, zero if unsupported\n+     * Gets the months field part of the period.\n+     * \n+     * @return the number of months in the period, zero if unsupported\n      */\n     int getMonths();\n \n     /**\n-     * Gets the weeks field part of the duration.\n-     * \n-     * @return the number of weeks in the duration, zero if unsupported\n+     * Gets the weeks field part of the period.\n+     * \n+     * @return the number of weeks in the period, zero if unsupported\n      */\n     int getWeeks();\n \n     /**\n-     * Gets the days field part of the duration.\n-     * \n-     * @return the number of days in the duration, zero if unsupported\n+     * Gets the days field part of the period.\n+     * \n+     * @return the number of days in the period, zero if unsupported\n      */\n     int getDays();\n \n     /**\n-     * Gets the hours field part of the duration.\n-     * \n-     * @return the number of hours in the duration, zero if unsupported\n+     * Gets the hours field part of the period.\n+     * \n+     * @return the number of hours in the period, zero if unsupported\n      */\n     int getHours();\n \n     /**\n-     * Gets the minutes field part of the duration.\n-     * \n-     * @return the number of minutes in the duration, zero if unsupported\n+     * Gets the minutes field part of the period.\n+     * \n+     * @return the number of minutes in the period, zero if unsupported\n      */\n     int getMinutes();\n \n     /**\n-     * Gets the seconds field part of the duration.\n-     * \n-     * @return the number of seconds in the duration, zero if unsupported\n+     * Gets the seconds field part of the period.\n+     * \n+     * @return the number of seconds in the period, zero if unsupported\n      */\n     int getSeconds();\n \n     /**\n-     * Gets the millis field part of the duration.\n-     * \n-     * @return the number of millis in the duration, zero if unsupported\n+     * Gets the millis field part of the period.\n+     * \n+     * @return the number of millis in the period, zero if unsupported\n      */\n     int getMillis();\n \n \n     /**\n      * Gets the total length of this time period in milliseconds, \n-     * failing if the duration is imprecise.\n+     * failing if the period is imprecise.\n      *\n      * @return the total length of the time period in milliseconds.\n      * @throws IllegalStateException if this time period is imprecise\n \n     /**\n      * Gets the total length of this time period,\n-     * failing if the duration is imprecise.\n+     * failing if the period is imprecise.\n      *\n      * @return the total length of the time period in milliseconds.\n      * @throws IllegalStateException if this time period is imprecise\n      * Compares this object with the specified object for equality based\n      * on the value of each field. All ReadableTimePeriod instances are accepted.\n      * <p>\n-     * To compare two durations for absolute duration (ie. millisecond duration\n+     * To compare two periods for absolute duration (ie. millisecond duration\n      * ignoring the fields), use {@link #toDurationMillis()} or {@link #toDuration()}.\n      *\n-     * @param readableDuration  a readable duration to check against\n+     * @param readablePeriod  a readable period to check against\n      * @return true if all the field values are equal, false if\n-     *  not or the duration is null or of an incorrect type\n-     */\n-    boolean equals(Object readableTimePeriod);\n-\n-    /**\n-     * Gets a hash code for the duration that is compatable with the \n+     *  not or the period is null or of an incorrect type\n+     */\n+    boolean equals(Object readablePeriod);\n+\n+    /**\n+     * Gets a hash code for the period that is compatable with the \n      * equals method. The hashcode must be calculated as follows:\n      * <pre>\n      *   int hash = getDurationType().hashCode();\n--- a/JodaTime/src/java/org/joda/time/TimePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/TimePeriod.java\n         extends AbstractTimePeriod\n         implements ReadableTimePeriod, Serializable {\n \n-    /** Constant representing zero millisecond duration */\n-    public static final TimePeriod ZERO = new TimePeriod(0L);\n-\n     /** Serialization version */\n     private static final long serialVersionUID = 741052353876488155L;\n \n     /**\n-     * Creates a duration from the given millisecond duration using AllType.\n+     * Creates a period from the given millisecond duration using AllType.\n      * <p>\n      * The millisecond duration will be split to fields using a UTC version of\n      * the duration type. This ensures that there are no odd effects caused by\n     }\n \n     /**\n-     * Creates a duration from the given millisecond duration.\n+     * Creates a period from the given millisecond duration.\n      * <p>\n      * The millisecond duration will be split to fields using a UTC version of\n      * the duration type. This ensures that there are no odd effects caused by\n      * of the duration type.\n      *\n      * @param duration  the duration, in milliseconds\n-     * @param type  which set of fields this duration supports\n+     * @param type  which set of fields this period supports\n      */\n     public TimePeriod(long duration, DurationType type) {\n         super(duration, type);\n     }\n \n     /**\n-     * Create a duration from a set of field values using AllType.\n-     * This constructor creates a precise duration.\n-     *\n-     * @param hours  amount of hours in this duration\n-     * @param minutes  amount of minutes in this duration\n-     * @param seconds  amount of seconds in this duration\n-     * @param millis  amount of milliseconds in this duration\n+     * Create a period from a set of field values using AllType.\n+     * This constructor creates a precise period.\n+     *\n+     * @param hours  amount of hours in this period\n+     * @param minutes  amount of minutes in this period\n+     * @param seconds  amount of seconds in this period\n+     * @param millis  amount of milliseconds in this period\n      */\n     public TimePeriod(int hours, int minutes, int seconds, int millis) {\n         super(0, 0, 0, 0, hours, minutes, seconds, millis, null);\n     }\n \n     /**\n-     * Create a duration from a set of field values using AllType.\n-     *\n-     * @param years  amount of years in this duration\n-     * @param months  amount of months in this duration\n-     * @param weeks  amount of weeks in this duration\n-     * @param days  amount of days in this duration\n-     * @param hours  amount of hours in this duration\n-     * @param minutes  amount of minutes in this duration\n-     * @param seconds  amount of seconds in this duration\n-     * @param millis  amount of milliseconds in this duration\n+     * Create a period from a set of field values using AllType.\n+     *\n+     * @param years  amount of years in this period\n+     * @param months  amount of months in this period\n+     * @param weeks  amount of weeks in this period\n+     * @param days  amount of days in this period\n+     * @param hours  amount of hours in this period\n+     * @param minutes  amount of minutes in this period\n+     * @param seconds  amount of seconds in this period\n+     * @param millis  amount of milliseconds in this period\n      */\n     public TimePeriod(int years, int months, int weeks, int days,\n                     int hours, int minutes, int seconds, int millis) {\n     }\n \n     /**\n-     * Create a duration from a set of field values.\n-     *\n-     * @param years  amount of years in this duration, which must be zero if unsupported\n-     * @param months  amount of months in this duration, which must be zero if unsupported\n-     * @param weeks  amount of weeks in this duration, which must be zero if unsupported\n-     * @param days  amount of days in this duration, which must be zero if unsupported\n-     * @param hours  amount of hours in this duration, which must be zero if unsupported\n-     * @param minutes  amount of minutes in this duration, which must be zero if unsupported\n-     * @param seconds  amount of seconds in this duration, which must be zero if unsupported\n-     * @param millis  amount of milliseconds in this duration, which must be zero if unsupported\n-     * @param type  which set of fields this duration supports, null means AllType\n+     * Create a period from a set of field values.\n+     *\n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @param type  which set of fields this period supports, null means AllType\n      * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n     public TimePeriod(int years, int months, int weeks, int days,\n     }\n \n     /**\n-     * Creates a duration from the given interval endpoints using AllType.\n-     * This constructor creates a precise duration.\n+     * Creates a period from the given interval endpoints using AllType.\n+     * This constructor creates a precise period.\n      *\n      * @param startInstant  interval start, in milliseconds\n      * @param endInstant  interval end, in milliseconds\n     }\n \n     /**\n-     * Creates a duration from the given interval endpoints.\n-     * This constructor creates a precise duration.\n+     * Creates a period from the given interval endpoints.\n+     * This constructor creates a precise period.\n      *\n      * @param startInstant  interval start, in milliseconds\n      * @param endInstant  interval end, in milliseconds\n-     * @param type  which set of fields this duration supports, null means AllType\n+     * @param type  which set of fields this period supports, null means AllType\n      */\n     public TimePeriod(long startInstant, long endInstant, DurationType type) {\n         super(startInstant, endInstant, type);\n     }\n \n     /**\n-     * Creates a duration from the given interval endpoints using AllType.\n-     * This constructor creates a precise duration.\n+     * Creates a period from the given interval endpoints using AllType.\n+     * This constructor creates a precise period.\n      *\n      * @param startInstant  interval start, null means now\n      * @param endInstant  interval end, null means now\n     }\n \n     /**\n-     * Creates a duration from the given interval endpoints.\n-     * This constructor creates a precise duration.\n+     * Creates a period from the given interval endpoints.\n+     * This constructor creates a precise period.\n      *\n      * @param startInstant  interval start, null means now\n      * @param endInstant  interval end, null means now\n-     * @param type  which set of fields this duration supports, null means AllType\n+     * @param type  which set of fields this period supports, null means AllType\n      */\n     public TimePeriod(ReadableInstant startInstant, ReadableInstant endInstant, DurationType type) {\n         super(startInstant, endInstant, type);\n     }\n \n     /**\n-     * Creates a duration from the specified object using the\n+     * Creates a period from the specified object using the\n      * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n      *\n-     * @param duration  duration to convert\n-     * @throws IllegalArgumentException if duration is invalid\n+     * @param period  period to convert\n+     * @throws IllegalArgumentException if period is invalid\n      * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n      */\n-    public TimePeriod(Object duration) {\n-        super(duration, null);\n-    }\n-\n-    /**\n-     * Creates a duration from the specified object using the\n+    public TimePeriod(Object period) {\n+        super(period, null);\n+    }\n+\n+    /**\n+     * Creates a period from the specified object using the\n      * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n      *\n-     * @param duration  duration to convert\n-     * @param type  which set of fields this duration supports, null means use converter\n-     * @throws IllegalArgumentException if duration is invalid\n+     * @param period  period to convert\n+     * @param type  which set of fields this period supports, null means use converter\n+     * @throws IllegalArgumentException if period is invalid\n      * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n      */\n-    public TimePeriod(Object duration, DurationType type) {\n-        super(duration, type);\n+    public TimePeriod(Object period, DurationType type) {\n+        super(period, type);\n     }\n \n     //-----------------------------------------------------------------------\n      * different DurationType.\n      * \n      * @param type  the duration type to use, null means AllType\n-     * @return the new duration instance\n-     * @throws IllegalArgumentException if the new duration won't accept all of the current fields\n+     * @return the new period instance\n+     * @throws IllegalArgumentException if the new period won't accept all of the current fields\n      */\n     public TimePeriod withDurationType(DurationType type) {\n         if (type == null) {\n      * different DurationType.\n      * \n      * @param type  the duration type to use, null means AllType\n-     * @return the new duration instance\n-     * @throws IllegalStateException if this duration is imprecise\n+     * @return the new period instance\n+     * @throws IllegalStateException if this period is imprecise\n      */\n     public TimePeriod withDurationTypeRetainDuration(DurationType type) {\n         if (type == null) {\n      * Creates a new TimePeriod instance with the same millisecond duration but\n      * all the fields normalized to be within their standard ranges.\n      * \n-     * @return the new duration instance\n-     * @throws IllegalStateException if this duration is imprecise\n+     * @return the new period instance\n+     * @throws IllegalStateException if this period is imprecise\n      */\n     public TimePeriod withFieldsNormalized() {\n         return new TimePeriod(toDurationMillis(), getDurationType());\n--- a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java\n  * <p>\n  * This class enables additional conversion classes to be added via\n  * {@link #addInstantConverter(InstantConverter)}, which may replace an\n- * existing converter. Similar methods exist for duration and interval\n- * converters.\n+ * existing converter. Similar methods exist for duration, time period and\n+ * interval converters.\n  * <p>\n  * This class is threadsafe, so adding/removing converters can be done at any\n  * time. Updating the set of convertors is relatively expensive, and so should\n  * <li>Long (milliseconds)\n  * <li>null (now)\n  * </ul>\n+ * \n  * The default duration converters are:\n  * <ul>\n  * <li>ReadableDuration\n  * <li>null (zero ms)\n  * </ul>\n  *\n+ * The default time period converters are:\n+ * <ul>\n+ * <li>ReadableTimePeriod\n+ * <li>ReadableInterval\n+ * <li>String\n+ * <li>null (zero)\n+ * </ul>\n+ * \n  * The default interval converters are:\n  * <ul>\n  * <li>ReadableInterval\n     \n     private ConverterSet iInstantConverters;\n     private ConverterSet iDurationConverters;\n+    private ConverterSet iTimePeriodConverters;\n     private ConverterSet iIntervalConverters;\n     \n     /**\n             NullConverter.INSTANCE,\n         });\n \n+        iTimePeriodConverters = new ConverterSet(new Converter[] {\n+            ReadableTimePeriodConverter.INSTANCE,\n+            ReadableIntervalConverter.INSTANCE,\n+            StringConverter.INSTANCE,\n+            NullConverter.INSTANCE,\n+        });\n+\n         iIntervalConverters = new ConverterSet(new Converter[] {\n             ReadableIntervalConverter.INSTANCE,\n             StringConverter.INSTANCE,\n         });\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the best converter for the object specified.\n      * @throws IllegalStateException if multiple converters match the type\n      * equally well\n      */\n-    public IntervalConverter getIntervalConverter(Object object) {\n-        IntervalConverter converter =\n-            (IntervalConverter)iIntervalConverters.select(object == null ? null : object.getClass());\n+    public TimePeriodConverter getTimePeriodConverter(Object object) {\n+        TimePeriodConverter converter =\n+            (TimePeriodConverter)iTimePeriodConverters.select(object == null ? null : object.getClass());\n         if (converter != null) {\n             return converter;\n         }\n-        throw new IllegalArgumentException(\"No interval converter found for type: \" +\n+        throw new IllegalArgumentException(\"No period converter found for type: \" +\n             (object == null ? \"null\" : object.getClass().getName()));\n     }\n     \n      * \n      * @return the converters, a copy of the real data, never null\n      */\n-    public IntervalConverter[] getIntervalConverters() {\n-        ConverterSet set = iIntervalConverters;\n-        IntervalConverter[] converters = new IntervalConverter[set.size()];\n+    public TimePeriodConverter[] getTimePeriodConverters() {\n+        ConverterSet set = iTimePeriodConverters;\n+        TimePeriodConverter[] converters = new TimePeriodConverter[set.size()];\n         set.copyInto(converters);\n         return converters;\n     }\n      * @param converter  the converter to add, null ignored\n      * @return replaced converter, or null\n      */\n+    public TimePeriodConverter addTimePeriodConverter(TimePeriodConverter converter)\n+            throws SecurityException {\n+        \n+        checkAlterTimePeriodConverters();\n+        if (converter == null) {\n+            return null;\n+        }\n+        TimePeriodConverter[] removed = new TimePeriodConverter[1];\n+        iTimePeriodConverters = iTimePeriodConverters.add(converter, removed);\n+        return removed[0];\n+    }\n+    \n+    /**\n+     * Removes a converter from the set of converters. If the converter was\n+     * not in the set, no changes are made.\n+     * \n+     * @param converter  the converter to remove, null ignored\n+     * @return replaced converter, or null\n+     */\n+    public TimePeriodConverter removeTimePeriodConverter(TimePeriodConverter converter)\n+            throws SecurityException {\n+        \n+        checkAlterTimePeriodConverters();\n+        if (converter == null) {\n+            return null;\n+        }\n+        TimePeriodConverter[] removed = new TimePeriodConverter[1];\n+        iTimePeriodConverters = iTimePeriodConverters.remove(converter, removed);\n+        return removed[0];\n+    }\n+    \n+    /**\n+     * Checks whether the user has permission 'ConverterManager.alterInstantConverters'.\n+     * \n+     * @throws SecurityException if the user does not have the permission\n+     */\n+    private void checkAlterTimePeriodConverters() throws SecurityException {\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterTimePeriodConverters\"));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the best converter for the object specified.\n+     * \n+     * @param object  the object to convert\n+     * @return the converter to use\n+     * @throws IllegalArgumentException if no suitable converter\n+     * @throws IllegalStateException if multiple converters match the type\n+     * equally well\n+     */\n+    public IntervalConverter getIntervalConverter(Object object) {\n+        IntervalConverter converter =\n+            (IntervalConverter)iIntervalConverters.select(object == null ? null : object.getClass());\n+        if (converter != null) {\n+            return converter;\n+        }\n+        throw new IllegalArgumentException(\"No interval converter found for type: \" +\n+            (object == null ? \"null\" : object.getClass().getName()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of the list of converters.\n+     * \n+     * @return the converters, a copy of the real data, never null\n+     */\n+    public IntervalConverter[] getIntervalConverters() {\n+        ConverterSet set = iIntervalConverters;\n+        IntervalConverter[] converters = new IntervalConverter[set.size()];\n+        set.copyInto(converters);\n+        return converters;\n+    }\n+    \n+    /**\n+     * Adds a converter to the set of converters. If a matching converter is\n+     * already in the set, the given converter replaces it. If the converter is\n+     * exactly the same as one already in the set, no changes are made.\n+     * <p>\n+     * The order in which converters are added is not relevent. The best\n+     * converter is selected by examining the object hierarchy.\n+     * \n+     * @param converter  the converter to add, null ignored\n+     * @return replaced converter, or null\n+     */\n     public IntervalConverter addIntervalConverter(IntervalConverter converter) \n             throws SecurityException {\n         \n         return \"ConverterManager[\" +\n             iInstantConverters.size() + \" instant,\" +\n             iDurationConverters.size() + \" duration,\" +\n+            iTimePeriodConverters.size() + \" period,\" +\n             iIntervalConverters.size() + \" interval]\";\n     }\n \n--- a/JodaTime/src/java/org/joda/time/convert/DurationConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/DurationConverter.java\n  */\n package org.joda.time.convert;\n \n-import org.joda.time.DurationType;\n-import org.joda.time.ReadWritableTimePeriod;\n-\n /**\n  * DurationConverter defines how an object is converted to a millisecond duration.\n  *\n public interface DurationConverter extends Converter {\n \n     /**\n-     * Returns true if the given support object represents a precice\n-     * duration. If so, getDurationMillis can be called.\n-     *\n-     * @throws ClassCastException if the object is invalid\n-     */\n-    boolean isPrecise(Object object);\n-\n-    /**\n      * Extracts the millis from an object of this convertor's type.\n      * \n      * @param object  the object to convert, must not be null\n      */\n     long getDurationMillis(Object object);\n \n-    /**\n-     * Extracts duration values from an object of this converter's type, and\n-     * sets them into the given ReadWritableDuration.\n-     *\n-     * @param duration duration to get modified\n-     * @param object  the object to convert, must not be null\n-     * @throws ClassCastException if the object is invalid\n-     */\n-    void setInto(ReadWritableTimePeriod duration, Object object);\n-\n-    /**\n-     * Selects a suitable duration type for the given object.\n-     *\n-     * @param object  the object to examine, must not be null\n-     * @param totalMillisMaster  true if total millis based duration\n-     * @return the duration type, never null\n-     * @throws ClassCastException if the object is invalid\n-     */\n-    DurationType getDurationType(Object object, boolean totalMillisMaster);\n-\n }\n--- a/JodaTime/src/java/org/joda/time/convert/LongConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/LongConverter.java\n     \n     //-----------------------------------------------------------------------\n     /**\n-     * Returns true always.\n-     */\n-    public boolean isPrecise(Object object) {\n-        return true;\n-    }\n-\n-    /**\n      * Gets the millisecond duration, which is the Long value.\n      * \n      * @param object  the object to convert, must not be null\n         return ((Long) object).longValue();\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Extracts duration values from an object of this converter's type, and\n      * sets them into the given ReadWritableDuration.\n--- a/JodaTime/src/java/org/joda/time/convert/NullConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/NullConverter.java\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-class NullConverter extends AbstractConverter implements InstantConverter, DurationConverter {\n+class NullConverter extends AbstractConverter\n+        implements InstantConverter, DurationConverter, TimePeriodConverter {\n     \n     /**\n      * Singleton instance.\n     \n     //-----------------------------------------------------------------------\n     /**\n-     * Returns true always.\n-     */\n-    public boolean isPrecise(Object object) {\n-        return true;\n-    }\n-\n-    /**\n      * Gets the millisecond duration, which is zero.\n      * \n      * @param object  the object to convert\n         return 0L;\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Sets the given ReadWritableDuration to zero milliseconds.\n      *\n--- a/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java\n  */\n package org.joda.time.convert;\n \n-import org.joda.time.DurationType;\n import org.joda.time.ReadableDuration;\n-import org.joda.time.ReadWritableTimePeriod;\n \n /**\n  * ReadableDurationConverter extracts milliseconds and chronology from a ReadableDuration.\n  * @since 1.0\n  */\n class ReadableDurationConverter extends AbstractConverter implements DurationConverter {\n-    \n+\n     /**\n      * Singleton instance.\n      */\n     static final ReadableDurationConverter INSTANCE = new ReadableDurationConverter();\n-    \n+\n     /**\n      * Restricted constructor.\n      */\n     }\n \n     //-----------------------------------------------------------------------\n-    /**\n-     * Returns true if the given support object represents a precice\n-     * duration. If so, getDurationMillis can be called.\n-     *\n-     * @throws NullPointerException if the object is null\n-     * @throws ClassCastException if the object is an invalid type\n-     */\n-    public boolean isPrecise(Object object) {\n-        return true;\n-    }\n-\n     /**\n      * Extracts the millis from an object of this convertor's type.\n      * \n     public long getDurationMillis(Object object) {\n         return ((ReadableDuration) object).getMillis();\n     }\n-    \n-    /**\n-     * Extracts duration values from an object of this converter's type, and\n-     * sets them into the given ReadWritableDuration.\n-     *\n-     * @param duration duration to get modified\n-     * @param object  the object to convert, must not be null\n-     * @return the millisecond duration\n-     * @throws NullPointerException if the duration or object is null\n-     * @throws ClassCastException if the object is an invalid type\n-     * @throws IllegalArgumentException if the object is invalid\n-     */\n-    public void setInto(ReadWritableTimePeriod duration, Object object) {\n-        duration.setTimePeriod((ReadableDuration) object);\n-    }\n-\n-    /**\n-     * Selects a suitable duration type for the given object.\n-     *\n-     * @param object  the object to examine, must not be null\n-     * @param precise  true if a precise type is required\n-     * @return the duration type from the readable duration\n-     * @throws NullPointerException if the object is null\n-     * @throws ClassCastException if the object is an invalid type\n-     */\n-    public DurationType getDurationType(Object object, boolean precise) {\n-        return DurationType.getPreciseAllType();\n-    }\n \n     //-----------------------------------------------------------------------\n     /**\n     public Class getSupportedType() {\n         return ReadableDuration.class;\n     }\n-    \n+\n }\n--- a/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-class ReadableIntervalConverter extends AbstractConverter implements IntervalConverter, DurationConverter {\n+class ReadableIntervalConverter extends AbstractConverter\n+        implements IntervalConverter, DurationConverter, TimePeriodConverter {\n \n     /**\n      * Singleton instance.\n         super();\n     }\n \n-    /**\n-     * Returns true always.\n-     * \n-     * @param object  the interval\n-     */\n-    public boolean isPrecise(Object object) {\n-        return true;\n-    }\n-\n+    //-----------------------------------------------------------------------\n     /**\n      * Gets the millisecond length of the interval.\n      * \n         return (((ReadableInterval) object)).getDurationMillis();\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Sets the values of the mutable duration from the specified interval.\n      * \n-     * @param writableDuration  the duration to set\n+     * @param writablePeriod  the period to modify\n      * @param object  the interval to set from\n      */\n-    public void setInto(ReadWritableTimePeriod writableDuration, Object object) {\n+    public void setInto(ReadWritableTimePeriod writablePeriod, Object object) {\n         ReadableInterval interval = (ReadableInterval) object;\n-        writableDuration.setTimePeriod(interval.getStartMillis(), interval.getEndMillis());\n+        writablePeriod.setTimePeriod(interval.getStartMillis(), interval.getEndMillis());\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Sets the values of the mutable interval from the specified interval.\n      * \n         writableInterval.setEndMillis(interval.getEndMillis());\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Returns ReadableInterval.class.\n      */\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableTimePeriodConverter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.DurationType;\n+import org.joda.time.ReadWritableTimePeriod;\n+import org.joda.time.ReadableTimePeriod;\n+\n+/**\n+ * ReadableDurationConverter extracts milliseconds and chronology from a ReadableDuration.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+class ReadableTimePeriodConverter extends AbstractConverter implements TimePeriodConverter {\n+\n+    /**\n+     * Singleton instance.\n+     */\n+    static final ReadableTimePeriodConverter INSTANCE = new ReadableTimePeriodConverter();\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    protected ReadableTimePeriodConverter() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Extracts duration values from an object of this converter's type, and\n+     * sets them into the given ReadWritableDuration.\n+     *\n+     * @param duration duration to get modified\n+     * @param object  the object to convert, must not be null\n+     * @return the millisecond duration\n+     * @throws NullPointerException if the duration or object is null\n+     * @throws ClassCastException if the object is an invalid type\n+     * @throws IllegalArgumentException if the object is invalid\n+     */\n+    public void setInto(ReadWritableTimePeriod duration, Object object) {\n+        duration.setTimePeriod((ReadableTimePeriod) object);\n+    }\n+\n+    /**\n+     * Selects a suitable duration type for the given object.\n+     *\n+     * @param object  the object to examine, must not be null\n+     * @param precise  true if a precise type is required\n+     * @return the duration type from the readable duration\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object is an invalid type\n+     */\n+    public DurationType getDurationType(Object object, boolean precise) {\n+        return DurationType.getPreciseAllType();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns ReadableTimePeriod class.\n+     * \n+     * @return ReadableTimePeriod.class\n+     */\n+    public Class getSupportedType() {\n+        return ReadableTimePeriod.class;\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationType;\n+import org.joda.time.MutableTimePeriod;\n+import org.joda.time.ReadWritableInterval;\n import org.joda.time.ReadWritableTimePeriod;\n-import org.joda.time.ReadWritableInterval;\n-import org.joda.time.ReadableDuration;\n import org.joda.time.TimePeriod;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.format.DateTimeParser;\n+import org.joda.time.format.ISODateTimeFormat;\n+import org.joda.time.format.ISOTimePeriodFormat;\n import org.joda.time.format.TimePeriodFormatter;\n import org.joda.time.format.TimePeriodParser;\n-import org.joda.time.format.ISODateTimeFormat;\n-import org.joda.time.format.ISOTimePeriodFormat;\n \n /**\n  * StringConverter converts a String to milliseconds in the ISOChronology.\n  * @since 1.0\n  */\n class StringConverter extends AbstractConverter\n-    implements InstantConverter, DurationConverter, IntervalConverter {\n-    \n+        implements InstantConverter, DurationConverter, TimePeriodConverter, IntervalConverter {\n+\n     /**\n      * Singleton instance.\n      */\n     static final StringConverter INSTANCE = new StringConverter();\n-    \n+\n     /**\n      * Restricted constructor.\n      */\n         DateTimeParser p = ISODateTimeFormat.getInstance(chrono).dateTimeParser();\n         return p.parseMillis(str);\n     }\n-    \n+\n     /**\n      * Gets the millis, which is the ISO parsed string value.\n      * \n         DateTimeParser p = ISODateTimeFormat.getInstance(chrono).dateTimeParser();\n         return p.parseMillis(str);\n     }\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Returns false always.\n-     */\n-    public boolean isPrecise(Object object) {\n-        return false;\n-    }\n-\n-    /**\n-     * @throws UnsupportedOperationException always\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the duration of the string using the PreciseAll type.\n+     * This matches the toString() method of ReadableDuration.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @throws ClassCastException if the object is invalid\n      */\n     public long getDurationMillis(Object object) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n+        String str = (String) object;\n+        MutableTimePeriod period = new MutableTimePeriod(DurationType.getPreciseAllType());\n+        TimePeriodParser parser = ISOTimePeriodFormat.getInstance().standard();\n+        int pos = parser.parseInto(period, str, 0);\n+        if (pos < str.length()) {\n+            if (pos < 0) {\n+                // Parse again to get a better exception thrown.\n+                parser.parseMutableTimePeriod(period.getDurationType(), str);\n+            }\n+            throw new IllegalArgumentException(\"Invalid format: \\\"\" + str + '\"');\n+        }\n+        return period.toDurationMillis();\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Extracts duration values from an object of this converter's type, and\n      * sets them into the given ReadWritableDuration.\n      *\n-     * @param duration duration to get modified\n+     * @param period  period to get modified\n      * @param object  the object to convert, must not be null\n      * @return the millisecond duration\n      * @throws ClassCastException if the object is invalid\n      */\n-    public void setInto(ReadWritableTimePeriod duration, Object object) {\n+    public void setInto(ReadWritableTimePeriod period, Object object) {\n         String str = (String) object;\n         TimePeriodParser parser = ISOTimePeriodFormat.getInstance().standard();\n-        int pos = parser.parseInto(duration, str, 0);\n+        int pos = parser.parseInto(period, str, 0);\n         if (pos < str.length()) {\n             if (pos < 0) {\n                 // Parse again to get a better exception thrown.\n-                parser.parseMutableTimePeriod(duration.getDurationType(), str);\n+                parser.parseMutableTimePeriod(period.getDurationType(), str);\n             }\n             throw new IllegalArgumentException(\"Invalid format: \\\"\" + str + '\"');\n         }\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Sets the value of the mutable interval from the string.\n      * \n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/convert/TimePeriodConverter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.DurationType;\n+import org.joda.time.ReadWritableTimePeriod;\n+\n+/**\n+ * TimePeriodConverter defines how an object is converted to a time period.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public interface TimePeriodConverter extends Converter {\n+\n+    /**\n+     * Extracts duration values from an object of this converter's type, and\n+     * sets them into the given ReadWritableDuration.\n+     *\n+     * @param period  the period to modify\n+     * @param object  the object to convert, must not be null\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    void setInto(ReadWritableTimePeriod period, Object object);\n+\n+    /**\n+     * Selects a suitable duration type for the given object.\n+     *\n+     * @param object  the object to examine, must not be null\n+     * @param precise  true if the duration type must be precise\n+     * @return the duration type, never null\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    DurationType getDurationType(Object object, boolean precise);\n+\n+}", "timestamp": 1091573873, "metainfo": ""}