{"sha": "f5dd6bffe00eb9ec8dca2e156cf06c12584ee18a", "log": "Add YearMonth [1863090]  ", "commit": "\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/YearMonth.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Locale;\n+\n+import org.joda.time.base.BasePartial;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.field.AbstractPartialFieldProperty;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * YearMonth is an immutable partial supporting the year and monthOfYear fields.\n+ * <p>\n+ * NOTE: This class only supports the two fields listed above.\n+ * It is impossible to query any other fields, such as dayOfWeek or centuryOfEra.\n+ * <p>\n+ * Calculations on YearMonth are performed using a {@link Chronology}.\n+ * This chronology is set to be in the UTC time zone for all calculations.\n+ * <p>\n+ * Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getMonthOfYear()</code>\n+ * <li><code>monthOfYear().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value - <code>monthOfYear().get()</code>\n+ * <li>text value - <code>monthOfYear().getAsText()</code>\n+ * <li>short text value - <code>monthOfYear().getAsShortText()</code>\n+ * <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code>\n+ * <li>add/subtract - <code>monthOfYear().addToCopy()</code>\n+ * <li>set - <code>monthOfYear().setCopy()</code>\n+ * </ul>\n+ * <p>\n+ * YearMonth is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ */\n+public final class YearMonth\n+        extends BasePartial\n+        implements ReadablePartial, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 797544782896179L;\n+    /** The singleton set of field types */\n+    private static final DateTimeFieldType[] FIELD_TYPES = new DateTimeFieldType[] {\n+        DateTimeFieldType.year(),\n+        DateTimeFieldType.monthOfYear(),\n+    };\n+\n+    /** The index of the year field in the field array */\n+    public static final int YEAR = 0;\n+    /** The index of the monthOfYear field in the field array */\n+    public static final int MONTH_OF_YEAR = 1;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a YearMonth from a <code>java.util.Calendar</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Calendar and assigned to the YearMonth.\n+     * <p>\n+     * This factory method ignores the type of the calendar and always\n+     * creates a YearMonth with ISO chronology. It is expected that you\n+     * will only pass in instances of <code>GregorianCalendar</code> however\n+     * this is not validated.\n+     *\n+     * @param calendar  the Calendar to extract fields from\n+     * @return the created YearMonth, never null\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the year or month is invalid for the ISO chronology\n+     */\n+    public static YearMonth fromCalendarFields(Calendar calendar) {\n+        if (calendar == null) {\n+            throw new IllegalArgumentException(\"The calendar must not be null\");\n+        }\n+        return new YearMonth(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH) + 1);\n+    }\n+\n+    /**\n+     * Constructs a YearMonth from a <code>java.util.Date</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Date and assigned to the YearMonth.\n+     * <p>\n+     * This factory method always creates a YearMonth with ISO chronology.\n+     *\n+     * @param date  the Date to extract fields from\n+     * @return the created YearMonth, never null\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the year or month is invalid for the ISO chronology\n+     */\n+    public static YearMonth fromDateFields(Date date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return new YearMonth(date.getYear() + 1900, date.getMonth() + 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a YearMonth with the current year-month, using ISOChronology in\n+     * the default zone to extract the fields.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a time-zone (by switching to UTC).\n+     */\n+    public YearMonth() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a YearMonth with the current year-month, using ISOChronology in\n+     * the specified zone to extract the fields.\n+     * <p>\n+     * The constructor uses the specified time zone to obtain the current year-month.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a time-zone (by switching to UTC).\n+     * \n+     * @param zone  the zone to use, null means default zone\n+     */\n+    public YearMonth(DateTimeZone zone) {\n+        super(ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs a YearMonth with the current year-month, using the specified chronology\n+     * and zone to extract the fields.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a time-zone (by switching to UTC).\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public YearMonth(Chronology chronology) {\n+        super(chronology);\n+    }\n+\n+    /**\n+     * Constructs a YearMonth extracting the partial fields from the specified\n+     * milliseconds using the ISOChronology in the default zone.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a time-zone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public YearMonth(long instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs a YearMonth extracting the partial fields from the specified\n+     * milliseconds using the chronology provided.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a time-zone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public YearMonth(long instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs a YearMonth from an Object that represents some form of time.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateOptionalTimeParser()}.\n+     * <p>\n+     * The chronology used will be derived from the object, defaulting to ISO.\n+     *\n+     * @param instant  the date-time object, null means now\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public YearMonth(Object instant) {\n+        super(instant, null, ISODateTimeFormat.dateOptionalTimeParser());\n+    }\n+\n+    /**\n+     * Constructs a YearMonth from an Object that represents some form of time,\n+     * using the specified chronology.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateOptionalTimeParser()}.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a time-zone (by switching to UTC).\n+     * The specified chronology overrides that of the object.\n+     *\n+     * @param instant  the date-time object, null means now\n+     * @param chronology  the chronology, null means ISO default\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public YearMonth(Object instant, Chronology chronology) {\n+        super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.dateOptionalTimeParser());\n+    }\n+\n+    /**\n+     * Constructs a YearMonth with specified year and month\n+     * using <code>ISOChronology</code>.\n+     * <p>\n+     * The constructor uses the no time zone initialising the fields as provided.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a time-zone (by switching to UTC).\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     */\n+    public YearMonth(int year, int monthOfYear) {\n+        this(year, monthOfYear, null);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the specified year and month\n+     * using the specified chronology, whose zone is ignored.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code> is used.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a time-zone (by switching to UTC).\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public YearMonth(int year, int monthOfYear, Chronology chronology) {\n+        super(new int[] {year, monthOfYear}, chronology);\n+    }\n+\n+    /**\n+     * Constructs a YearMonth with chronology from this instance and new values.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param values  the new set of values\n+     */\n+    YearMonth(YearMonth partial, int[] values) {\n+        super(partial, values);\n+    }\n+\n+    /**\n+     * Constructs a YearMonth with values from this instance and a new chronology.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param chrono  the new chronology\n+     */\n+    YearMonth(YearMonth partial, Chronology chrono) {\n+        super(partial, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial, which is two.\n+     * The supported fields are Year and MonthOfYear.\n+     * Note that only these fields may be queried.\n+     *\n+     * @return the field count, two\n+     */\n+    public int size() {\n+        return 2;\n+    }\n+\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * <p>\n+     * This method must not use any instance variables.\n+     * \n+     * @param index  the index to retrieve\n+     * @param chrono  the chronology to use\n+     * @return the field, never null\n+     */\n+    protected DateTimeField getField(int index, Chronology chrono) {\n+        switch (index) {\n+            case YEAR:\n+                return chrono.year();\n+            case MONTH_OF_YEAR:\n+                return chrono.monthOfYear();\n+            default:\n+                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n+    }\n+\n+    /**\n+     * Gets the field type at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index, never null\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeFieldType getFieldType(int index) {\n+        return FIELD_TYPES[index];\n+    }\n+\n+    /**\n+     * Gets an array of the field type of each of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, Year, Month\n+     *\n+     * @return the array of field types (cloned), largest to smallest, never null\n+     */\n+    public DateTimeFieldType[] getFieldTypes() {\n+        return (DateTimeFieldType[]) FIELD_TYPES.clone();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this year-month with the specified chronology.\n+     * This instance is immutable and unaffected by this method call.\n+     * <p>\n+     * This method retains the values of the fields, thus the result will\n+     * typically refer to a different instant.\n+     * <p>\n+     * The time zone of the specified chronology is ignored, as YearMonth\n+     * operates without a time zone.\n+     *\n+     * @param newChronology  the new chronology, null means ISO\n+     * @return a copy of this year-month with a different chronology, never null\n+     * @throws IllegalArgumentException if the values are invalid for the new chronology\n+     */\n+    public YearMonth withChronologyRetainFields(Chronology newChronology) {\n+        newChronology = DateTimeUtils.getChronology(newChronology);\n+        newChronology = newChronology.withUTC();\n+        if (newChronology == getChronology()) {\n+            return this;\n+        } else {\n+            YearMonth newYearMonth = new YearMonth(this, newChronology);\n+            newChronology.validate(newYearMonth, getValues());\n+            return newYearMonth;\n+        }\n+    }\n+\n+    /**\n+     * Returns a copy of this year-month with the specified field set to a new value.\n+     * <p>\n+     * For example, if the field type is <code>dayOfMonth</code> then the day\n+     * would be changed in the returned instance.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * YearMonth updated = ym.withField(DateTimeFieldType.dayOfMonth(), 6);\n+     * YearMonth updated = ym.dayOfMonth().setCopy(6);\n+     * YearMonth updated = ym.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this instance with the field set, never null\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public YearMonth withField(DateTimeFieldType fieldType, int value) {\n+        int index = indexOfSupported(fieldType);\n+        if (value == getValue(index)) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).set(this, index, newValues, value);\n+        return new YearMonth(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this year-month with the value of the specified field increased.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * YearMonth added = ym.withFieldAdded(DurationFieldType.days(), 6);\n+     * YearMonth added = ym.plusDays(6);\n+     * YearMonth added = ym.dayOfMonth().addToCopy(6);\n+     * </pre>\n+     * \n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this instance with the field updated, never null\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new date-time exceeds the capacity\n+     */\n+    public YearMonth withFieldAdded(DurationFieldType fieldType, int amount) {\n+        int index = indexOfSupported(fieldType);\n+        if (amount == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).add(this, index, newValues, amount);\n+        return new YearMonth(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this year-month with the specified period added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * Fields in the period that aren't present in the partial are ignored.\n+     * <p>\n+     * This method is typically used to add multiple copies of complex\n+     * period instances. Adding one field is best achieved using methods\n+     * like {@link #withFieldAdded(DurationFieldType, int)}\n+     * or {@link #plusYears(int)}.\n+     * \n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this instance with the period added, never null\n+     * @throws ArithmeticException if the new date-time exceeds the capacity\n+     */\n+    public YearMonth withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period == null || scalar == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        for (int i = 0; i < period.size(); i++) {\n+            DurationFieldType fieldType = period.getFieldType(i);\n+            int index = indexOf(fieldType);\n+            if (index >= 0) {\n+                newValues = getField(index).add(this, index, newValues,\n+                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n+            }\n+        }\n+        return new YearMonth(this, newValues);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this year-month with the specified period added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add complex period instances.\n+     * Adding one field is best achieved using methods\n+     * like {@link #plusYears(int)}.\n+     * \n+     * @param period  the duration to add to this one, null means zero\n+     * @return a copy of this instance with the period added, never null\n+     * @throws ArithmeticException if the new year-month exceeds the capacity\n+     */\n+    public YearMonth plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this year-month plus the specified number of years.\n+     * <p>\n+     * This year-month instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * YearMonth added = ym.plusYears(6);\n+     * YearMonth added = ym.plus(Period.years(6));\n+     * YearMonth added = ym.withFieldAdded(DurationFieldType.years(), 6);\n+     * </pre>\n+     *\n+     * @param years  the amount of years to add, may be negative\n+     * @return the new year-month plus the increased years, never null\n+     */\n+    public YearMonth plusYears(int years) {\n+        return withFieldAdded(DurationFieldType.years(), years);\n+    }\n+\n+    /**\n+     * Returns a copy of this year-month plus the specified number of months.\n+     * <p>\n+     * This year-month instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * YearMonth added = ym.plusMonths(6);\n+     * YearMonth added = ym.plus(Period.months(6));\n+     * YearMonth added = ym.withFieldAdded(DurationFieldType.months(), 6);\n+     * </pre>\n+     *\n+     * @param months  the amount of months to add, may be negative\n+     * @return the new year-month plus the increased months, never null\n+     */\n+    public YearMonth plusMonths(int months) {\n+        return withFieldAdded(DurationFieldType.months(), months);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this year-month with the specified period taken away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to subtract complex period instances.\n+     * Subtracting one field is best achieved using methods\n+     * like {@link #minusYears(int)}.\n+     * \n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this instance with the period taken away, never null\n+     * @throws ArithmeticException if the new year-month exceeds the capacity\n+     */\n+    public YearMonth minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this year-month minus the specified number of years.\n+     * <p>\n+     * This year-month instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * YearMonth subtracted = ym.minusYears(6);\n+     * YearMonth subtracted = ym.minus(Period.years(6));\n+     * YearMonth subtracted = ym.withFieldAdded(DurationFieldType.years(), -6);\n+     * </pre>\n+     *\n+     * @param years  the amount of years to subtract, may be negative\n+     * @return the new year-month minus the increased years, never null\n+     */\n+    public YearMonth minusYears(int years) {\n+        return withFieldAdded(DurationFieldType.years(), FieldUtils.safeNegate(years));\n+    }\n+\n+    /**\n+     * Returns a copy of this year-month minus the specified number of months.\n+     * <p>\n+     * This year-month instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * YearMonth subtracted = ym.minusMonths(6);\n+     * YearMonth subtracted = ym.minus(Period.months(6));\n+     * YearMonth subtracted = ym.withFieldAdded(DurationFieldType.months(), -6);\n+     * </pre>\n+     *\n+     * @param months  the amount of months to subtract, may be negative\n+     * @return the new year-month minus the increased months, never null\n+     */\n+    public YearMonth minusMonths(int months) {\n+        return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to a LocalDate with the same year-month and chronology.\n+     *\n+     * @param dayOfMonth the day of month to use, valid for chronology, such as 1-31 for ISO\n+     * @return a LocalDate with the same year-month and chronology, never null\n+     */\n+    public LocalDate toLocalDate(int dayOfMonth) {\n+        return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to an Interval representing the whole month.\n+     * <p>\n+     * The interval will use the chronology of the year-month in the default zone.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @return an interval over the month, never null\n+     */\n+    public Interval toInterval() {\n+        return toInterval(null);\n+    }\n+\n+    /**\n+     * Converts this object to an Interval representing the whole month.\n+     * <p>\n+     * The interval will use the chronology of the year-month in the specified zone.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param zone  the zone to get the Interval in, null means default\n+     * @return an interval over the month, never null\n+     */\n+    public Interval toInterval(DateTimeZone zone) {\n+        zone = DateTimeUtils.getZone(zone);\n+        DateTime start = toLocalDate(1).toDateTimeAtStartOfDay(zone);\n+        DateTime end = plusMonths(1).toLocalDate(1).toDateTimeAtStartOfDay(zone);\n+        return new Interval(start, end);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the year field value.\n+     *\n+     * @return the year\n+     */\n+    public int getYear() {\n+        return getValue(YEAR);\n+    }\n+\n+    /**\n+     * Get the month of year field value.\n+     *\n+     * @return the month of year\n+     */\n+    public int getMonthOfYear() {\n+        return getValue(MONTH_OF_YEAR);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this year-month with the year field updated.\n+     * <p>\n+     * YearMonth is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * year changed.\n+     *\n+     * @param year  the year to set\n+     * @return a copy of this object with the field set, never null\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public YearMonth withYear(int year) {\n+        int[] newValues = getValues();\n+        newValues = getChronology().year().set(this, YEAR, newValues, year);\n+        return new YearMonth(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this year-month with the month of year field updated.\n+     * <p>\n+     * YearMonth is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * month of year changed.\n+     *\n+     * @param monthOfYear  the month of year to set\n+     * @return a copy of this object with the field set, never null\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public YearMonth withMonthOfYear(int monthOfYear) {\n+        int[] newValues = getValues();\n+        newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear);\n+        return new YearMonth(this, newValues);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains\n+     * many useful methods.\n+     *\n+     * @param type  the field type to get the property for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType type) {\n+        return new Property(this, indexOfSupported(type));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the year field property which provides access to advanced functionality.\n+     * \n+     * @return the year property\n+     */\n+    public Property year() {\n+        return new Property(this, YEAR);\n+    }\n+\n+    /**\n+     * Get the month of year field property which provides access to advanced functionality.\n+     * \n+     * @return the month of year property\n+     */\n+    public Property monthOfYear() {\n+        return new Property(this, MONTH_OF_YEAR);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the year-month in ISO8601 format (yyyy-MM-dd).\n+     *\n+     * @return ISO8601 time formatted string.\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.yearMonth().print(this);\n+    }\n+\n+    /**\n+     * Output the year-month using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern) {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Output the year-month using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @param locale  Locale to use, null means default\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The property class for <code>YearMonth</code>.\n+     * <p>\n+     * This class binds a <code>YearMonth</code> to a <code>DateTimeField</code>.\n+     * \n+     * @author Stephen Colebourne\n+     * @since 2.0\n+     */\n+    public static class Property extends AbstractPartialFieldProperty implements Serializable {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 5727734012190224363L;\n+\n+        /** The partial */\n+        private final YearMonth iYearMonth;\n+        /** The field index */\n+        private final int iFieldIndex;\n+\n+        /**\n+         * Constructs a property.\n+         * \n+         * @param partial  the partial instance\n+         * @param fieldIndex  the index in the partial\n+         */\n+        Property(YearMonth partial, int fieldIndex) {\n+            super();\n+            iYearMonth = partial;\n+            iFieldIndex = fieldIndex;\n+        }\n+\n+        /**\n+         * Gets the field that this property uses.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iYearMonth.getField(iFieldIndex);\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        protected ReadablePartial getReadablePartial() {\n+            return iYearMonth;\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        public YearMonth getYearMonth() {\n+            return iYearMonth;\n+        }\n+\n+        /**\n+         * Gets the value of this field.\n+         * \n+         * @return the field value\n+         */\n+        public int get() {\n+            return iYearMonth.getValue(iFieldIndex);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to the value of this field in a copy of this YearMonth.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it will affect larger fields.\n+         * Smaller fields are unaffected.\n+         * <p>\n+         * If the result would be too large, beyond the maximum year, then an\n+         * IllegalArgumentException is thrown.\n+         * <p>\n+         * The YearMonth attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the YearMonth with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public YearMonth addToCopy(int valueToAdd) {\n+            int[] newValues = iYearMonth.getValues();\n+            newValues = getField().add(iYearMonth, iFieldIndex, newValues, valueToAdd);\n+            return new YearMonth(iYearMonth, newValues);\n+        }\n+\n+        /**\n+         * Adds to the value of this field in a copy of this YearMonth wrapping\n+         * within this field if the maximum value is reached.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it wraps within this field.\n+         * Other fields are unaffected.\n+         * <p>\n+         * For example,\n+         * <code>2004-12</code> addWrapField one month returns <code>2004-01</code>.\n+         * <p>\n+         * The YearMonth attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the YearMonth with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public YearMonth addWrapFieldToCopy(int valueToAdd) {\n+            int[] newValues = iYearMonth.getValues();\n+            newValues = getField().addWrapField(iYearMonth, iFieldIndex, newValues, valueToAdd);\n+            return new YearMonth(iYearMonth, newValues);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the YearMonth.\n+         * <p>\n+         * The YearMonth attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the YearMonth with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public YearMonth setCopy(int value) {\n+            int[] newValues = iYearMonth.getValues();\n+            newValues = getField().set(iYearMonth, iFieldIndex, newValues, value);\n+            return new YearMonth(iYearMonth, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the YearMonth to a parsed text value.\n+         * <p>\n+         * The YearMonth attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the YearMonth with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public YearMonth setCopy(String text, Locale locale) {\n+            int[] newValues = iYearMonth.getValues();\n+            newValues = getField().set(iYearMonth, iFieldIndex, newValues, text, locale);\n+            return new YearMonth(iYearMonth, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the YearMonth to a parsed text value.\n+         * <p>\n+         * The YearMonth attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @return a copy of the YearMonth with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public YearMonth setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+    }\n+\n+}\n--- a/JodaTime/src/test/org/joda/time/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/TestAll.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n         suite.addTest(TestYearMonthDay_Constructors.suite());\n         suite.addTest(TestYearMonthDay_Properties.suite());\n         \n+        suite.addTest(TestYearMonth_Basics.suite());\n+        suite.addTest(TestYearMonth_Constructors.suite());\n+        suite.addTest(TestYearMonth_Properties.suite());\n+        \n         suite.addTest(TestPartial_Basics.suite());\n         suite.addTest(TestPartial_Constructors.suite());\n         suite.addTest(TestPartial_Properties.suite());\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestYearMonth_Basics.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Arrays;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.BuddhistChronology;\n+import org.joda.time.chrono.CopticChronology;\n+import org.joda.time.chrono.GregorianChronology;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+/**\n+ * This class is a Junit unit test for YearMonth.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestYearMonth_Basics extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n+    private static final DateTimeZone TOKYO = DateTimeZone.forID(\"Asia/Tokyo\");\n+    private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS);\n+    private static final Chronology COPTIC_LONDON = CopticChronology.getInstance(LONDON);\n+    private static final Chronology COPTIC_TOKYO = CopticChronology.getInstance(TOKYO);\n+    private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC();\n+//    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);\n+//    private static final Chronology ISO_LONDON = ISOChronology.getInstance(LONDON);\n+//    private static final Chronology ISO_TOKYO = ISOChronology.getInstance(TOKYO);\n+    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();\n+//    private static final Chronology BUDDHIST_PARIS = BuddhistChronology.getInstance(PARIS);\n+//    private static final Chronology BUDDHIST_LONDON = BuddhistChronology.getInstance(LONDON);\n+    private static final Chronology BUDDHIST_TOKYO = BuddhistChronology.getInstance(TOKYO);\n+    private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC();\n+    \n+    private long TEST_TIME_NOW =\n+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestYearMonth_Basics.class);\n+    }\n+\n+    public TestYearMonth_Basics(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGet() {\n+        YearMonth test = new YearMonth();\n+        assertEquals(1970, test.get(DateTimeFieldType.year()));\n+        assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));\n+        try {\n+            test.get(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.get(DateTimeFieldType.dayOfMonth());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSize() {\n+        YearMonth test = new YearMonth();\n+        assertEquals(2, test.size());\n+    }\n+\n+    public void testGetFieldType() {\n+        YearMonth test = new YearMonth(COPTIC_PARIS);\n+        assertSame(DateTimeFieldType.year(), test.getFieldType(0));\n+        assertSame(DateTimeFieldType.monthOfYear(), test.getFieldType(1));\n+        try {\n+            test.getFieldType(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            test.getFieldType(2);\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetFieldTypes() {\n+        YearMonth test = new YearMonth(COPTIC_PARIS);\n+        DateTimeFieldType[] fields = test.getFieldTypes();\n+        assertEquals(2, fields.length);\n+        assertSame(DateTimeFieldType.year(), fields[0]);\n+        assertSame(DateTimeFieldType.monthOfYear(), fields[1]);\n+        assertNotSame(test.getFieldTypes(), test.getFieldTypes());\n+    }\n+\n+    public void testGetField() {\n+        YearMonth test = new YearMonth(COPTIC_PARIS);\n+        assertSame(COPTIC_UTC.year(), test.getField(0));\n+        assertSame(COPTIC_UTC.monthOfYear(), test.getField(1));\n+        try {\n+            test.getField(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            test.getField(2);\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetFields() {\n+        YearMonth test = new YearMonth(COPTIC_PARIS);\n+        DateTimeField[] fields = test.getFields();\n+        assertEquals(2, fields.length);\n+        assertSame(COPTIC_UTC.year(), fields[0]);\n+        assertSame(COPTIC_UTC.monthOfYear(), fields[1]);\n+        assertNotSame(test.getFields(), test.getFields());\n+    }\n+\n+    public void testGetValue() {\n+        YearMonth test = new YearMonth();\n+        assertEquals(1970, test.getValue(0));\n+        assertEquals(6, test.getValue(1));\n+        try {\n+            test.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            test.getValue(2);\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetValues() {\n+        YearMonth test = new YearMonth();\n+        int[] values = test.getValues();\n+        assertEquals(2, values.length);\n+        assertEquals(1970, values[0]);\n+        assertEquals(6, values[1]);\n+        assertNotSame(test.getValues(), test.getValues());\n+    }\n+\n+    public void testIsSupported() {\n+        YearMonth test = new YearMonth(COPTIC_PARIS);\n+        assertEquals(true, test.isSupported(DateTimeFieldType.year()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.monthOfYear()));\n+        assertEquals(false, test.isSupported(DateTimeFieldType.dayOfMonth()));\n+        assertEquals(false, test.isSupported(DateTimeFieldType.hourOfDay()));\n+    }\n+\n+    public void testEqualsHashCode() {\n+        YearMonth test1 = new YearMonth(1970, 6, COPTIC_PARIS);\n+        YearMonth test2 = new YearMonth(1970, 6, COPTIC_PARIS);\n+        assertEquals(true, test1.equals(test2));\n+        assertEquals(true, test2.equals(test1));\n+        assertEquals(true, test1.equals(test1));\n+        assertEquals(true, test2.equals(test2));\n+        assertEquals(true, test1.hashCode() == test2.hashCode());\n+        assertEquals(true, test1.hashCode() == test1.hashCode());\n+        assertEquals(true, test2.hashCode() == test2.hashCode());\n+        \n+        YearMonth test3 = new YearMonth(1971, 6);\n+        assertEquals(false, test1.equals(test3));\n+        assertEquals(false, test2.equals(test3));\n+        assertEquals(false, test3.equals(test1));\n+        assertEquals(false, test3.equals(test2));\n+        assertEquals(false, test1.hashCode() == test3.hashCode());\n+        assertEquals(false, test2.hashCode() == test3.hashCode());\n+        \n+        assertEquals(false, test1.equals(\"Hello\"));\n+        assertEquals(true, test1.equals(new MockYM()));\n+        assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));\n+    }\n+    \n+    class MockYM extends MockPartial {\n+        public Chronology getChronology() {\n+            return COPTIC_UTC;\n+        }\n+        public DateTimeField[] getFields() {\n+            return new DateTimeField[] {\n+                COPTIC_UTC.year(),\n+                COPTIC_UTC.monthOfYear(),\n+            };\n+        }\n+        public int[] getValues() {\n+            return new int[] {1970, 6};\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCompareTo() {\n+        YearMonth test1 = new YearMonth(2005, 6);\n+        YearMonth test1a = new YearMonth(2005, 6);\n+        assertEquals(0, test1.compareTo(test1a));\n+        assertEquals(0, test1a.compareTo(test1));\n+        assertEquals(0, test1.compareTo(test1));\n+        assertEquals(0, test1a.compareTo(test1a));\n+        \n+        YearMonth test2 = new YearMonth(2005, 7);\n+        assertEquals(-1, test1.compareTo(test2));\n+        assertEquals(+1, test2.compareTo(test1));\n+        \n+        YearMonth test3 = new YearMonth(2005, 7, GregorianChronology.getInstanceUTC());\n+        assertEquals(-1, test1.compareTo(test3));\n+        assertEquals(+1, test3.compareTo(test1));\n+        assertEquals(0, test3.compareTo(test2));\n+        \n+        DateTimeFieldType[] types = new DateTimeFieldType[] {\n+            DateTimeFieldType.year(),\n+            DateTimeFieldType.monthOfYear(),\n+        };\n+        int[] values = new int[] {2005, 6};\n+        Partial p = new Partial(types, values);\n+        assertEquals(0, test1.compareTo(p));\n+        try {\n+            test1.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            test1.compareTo(new LocalTime());\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        Partial partial = new Partial()\n+            .with(DateTimeFieldType.centuryOfEra(), 1)\n+            .with(DateTimeFieldType.halfdayOfDay(), 0)\n+            .with(DateTimeFieldType.dayOfMonth(), 9);\n+        try {\n+            new YearMonth(1970, 6).compareTo(partial);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsEqual_YM() {\n+        YearMonth test1 = new YearMonth(2005, 6);\n+        YearMonth test1a = new YearMonth(2005, 6);\n+        assertEquals(true, test1.isEqual(test1a));\n+        assertEquals(true, test1a.isEqual(test1));\n+        assertEquals(true, test1.isEqual(test1));\n+        assertEquals(true, test1a.isEqual(test1a));\n+        \n+        YearMonth test2 = new YearMonth(2005, 7);\n+        assertEquals(false, test1.isEqual(test2));\n+        assertEquals(false, test2.isEqual(test1));\n+        \n+        YearMonth test3 = new YearMonth(2005, 7, GregorianChronology.getInstanceUTC());\n+        assertEquals(false, test1.isEqual(test3));\n+        assertEquals(false, test3.isEqual(test1));\n+        assertEquals(true, test3.isEqual(test2));\n+        \n+        try {\n+            new YearMonth(2005, 7).isEqual(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsBefore_YM() {\n+        YearMonth test1 = new YearMonth(2005, 6);\n+        YearMonth test1a = new YearMonth(2005, 6);\n+        assertEquals(false, test1.isBefore(test1a));\n+        assertEquals(false, test1a.isBefore(test1));\n+        assertEquals(false, test1.isBefore(test1));\n+        assertEquals(false, test1a.isBefore(test1a));\n+        \n+        YearMonth test2 = new YearMonth(2005, 7);\n+        assertEquals(true, test1.isBefore(test2));\n+        assertEquals(false, test2.isBefore(test1));\n+        \n+        YearMonth test3 = new YearMonth(2005, 7, GregorianChronology.getInstanceUTC());\n+        assertEquals(true, test1.isBefore(test3));\n+        assertEquals(false, test3.isBefore(test1));\n+        assertEquals(false, test3.isBefore(test2));\n+        \n+        try {\n+            new YearMonth(2005, 7).isBefore(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAfter_YM() {\n+        YearMonth test1 = new YearMonth(2005, 6);\n+        YearMonth test1a = new YearMonth(2005, 6);\n+        assertEquals(false, test1.isAfter(test1a));\n+        assertEquals(false, test1a.isAfter(test1));\n+        assertEquals(false, test1.isAfter(test1));\n+        assertEquals(false, test1a.isAfter(test1a));\n+        \n+        YearMonth test2 = new YearMonth(2005, 7);\n+        assertEquals(false, test1.isAfter(test2));\n+        assertEquals(true, test2.isAfter(test1));\n+        \n+        YearMonth test3 = new YearMonth(2005, 7, GregorianChronology.getInstanceUTC());\n+        assertEquals(false, test1.isAfter(test3));\n+        assertEquals(true, test3.isAfter(test1));\n+        assertEquals(false, test3.isAfter(test2));\n+        \n+        try {\n+            new YearMonth(2005, 7).isAfter(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testWithChronologyRetainFields_Chrono() {\n+        YearMonth base = new YearMonth(2005, 6, COPTIC_PARIS);\n+        YearMonth test = base.withChronologyRetainFields(BUDDHIST_TOKYO);\n+        check(base, 2005, 6);\n+        assertEquals(COPTIC_UTC, base.getChronology());\n+        check(test, 2005, 6);\n+        assertEquals(BUDDHIST_UTC, test.getChronology());\n+    }\n+\n+    public void testWithChronologyRetainFields_sameChrono() {\n+        YearMonth base = new YearMonth(2005, 6, COPTIC_PARIS);\n+        YearMonth test = base.withChronologyRetainFields(COPTIC_TOKYO);\n+        assertSame(base, test);\n+    }\n+\n+    public void testWithChronologyRetainFields_nullChrono() {\n+        YearMonth base = new YearMonth(2005, 6, COPTIC_PARIS);\n+        YearMonth test = base.withChronologyRetainFields(null);\n+        check(base, 2005, 6);\n+        assertEquals(COPTIC_UTC, base.getChronology());\n+        check(test, 2005, 6);\n+        assertEquals(ISO_UTC, test.getChronology());\n+    }\n+\n+    public void testWithChronologyRetainFields_invalidInNewChrono() {\n+        YearMonth base = new YearMonth(2005, 13, COPTIC_UTC);\n+        try {\n+            base.withChronologyRetainFields(ISO_UTC);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithField() {\n+        YearMonth test = new YearMonth(2004, 6);\n+        YearMonth result = test.withField(DateTimeFieldType.year(), 2006);\n+        \n+        assertEquals(new YearMonth(2004, 6), test);\n+        assertEquals(new YearMonth(2006, 6), result);\n+    }\n+\n+    public void testWithField_nullField() {\n+        YearMonth test = new YearMonth(2004, 6);\n+        try {\n+            test.withField(null, 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testWithField_unknownField() {\n+        YearMonth test = new YearMonth(2004, 6);\n+        try {\n+            test.withField(DateTimeFieldType.hourOfDay(), 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testWithField_same() {\n+        YearMonth test = new YearMonth(2004, 6);\n+        YearMonth result = test.withField(DateTimeFieldType.year(), 2004);\n+        assertEquals(new YearMonth(2004, 6), test);\n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithFieldAdded() {\n+        YearMonth test = new YearMonth(2004, 6);\n+        YearMonth result = test.withFieldAdded(DurationFieldType.years(), 6);\n+        \n+        assertEquals(new YearMonth(2004, 6), test);\n+        assertEquals(new YearMonth(2010, 6), result);\n+    }\n+\n+    public void testWithFieldAdded_nullField_zero() {\n+        YearMonth test = new YearMonth(2004, 6);\n+        try {\n+            test.withFieldAdded(null, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testWithFieldAdded_nullField_nonZero() {\n+        YearMonth test = new YearMonth(2004, 6);\n+        try {\n+            test.withFieldAdded(null, 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testWithFieldAdded_zero() {\n+        YearMonth test = new YearMonth(2004, 6);\n+        YearMonth result = test.withFieldAdded(DurationFieldType.years(), 0);\n+        assertSame(test, result);\n+    }\n+\n+    public void testWithFieldAdded_unknownField() {\n+        YearMonth test = new YearMonth(2004, 6);\n+        try {\n+            test.withFieldAdded(DurationFieldType.hours(), 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPlus_RP() {\n+        YearMonth test = new YearMonth(2002, 5, BuddhistChronology.getInstance());\n+        YearMonth result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8));\n+        YearMonth expected = new YearMonth(2003, 7, BuddhistChronology.getInstance());\n+        assertEquals(expected, result);\n+        \n+        result = test.plus((ReadablePeriod) null);\n+        assertSame(test, result);\n+    }\n+\n+    public void testPlusYears_int() {\n+        YearMonth test = new YearMonth(2002, 5, BuddhistChronology.getInstance());\n+        YearMonth result = test.plusYears(1);\n+        YearMonth expected = new YearMonth(2003, 5, BuddhistChronology.getInstance());\n+        assertEquals(expected, result);\n+        \n+        result = test.plusYears(0);\n+        assertSame(test, result);\n+    }\n+\n+    public void testPlusMonths_int() {\n+        YearMonth test = new YearMonth(2002, 5, BuddhistChronology.getInstance());\n+        YearMonth result = test.plusMonths(1);\n+        YearMonth expected = new YearMonth(2002, 6, BuddhistChronology.getInstance());\n+        assertEquals(expected, result);\n+        \n+        result = test.plusMonths(0);\n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMinus_RP() {\n+        YearMonth test = new YearMonth(2002, 5, BuddhistChronology.getInstance());\n+        YearMonth result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1));\n+        YearMonth expected = new YearMonth(2001, 4, BuddhistChronology.getInstance());\n+        assertEquals(expected, result);\n+        \n+        result = test.minus((ReadablePeriod) null);\n+        assertSame(test, result);\n+    }\n+\n+    public void testMinusYears_int() {\n+        YearMonth test = new YearMonth(2002, 5, BuddhistChronology.getInstance());\n+        YearMonth result = test.minusYears(1);\n+        YearMonth expected = new YearMonth(2001, 5, BuddhistChronology.getInstance());\n+        assertEquals(expected, result);\n+        \n+        result = test.minusYears(0);\n+        assertSame(test, result);\n+    }\n+\n+    public void testMinusMonths_int() {\n+        YearMonth test = new YearMonth(2002, 5, BuddhistChronology.getInstance());\n+        YearMonth result = test.minusMonths(1);\n+        YearMonth expected = new YearMonth(2002, 4, BuddhistChronology.getInstance());\n+        assertEquals(expected, result);\n+        \n+        result = test.minusMonths(0);\n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToLocalDate() {\n+        YearMonth base = new YearMonth(2005, 6, COPTIC_UTC);\n+        LocalDate test = base.toLocalDate(9);\n+        assertEquals(new LocalDate(2005, 6, 9, COPTIC_UTC), test);\n+        try {\n+            base.toLocalDate(0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTime_RI() {\n+        YearMonth base = new YearMonth(2005, 6, COPTIC_PARIS);\n+        DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7);\n+        \n+        DateTime test = base.toDateTime(dt);\n+        check(base, 2005, 6);\n+        DateTime expected = dt;\n+        expected = expected.year().setCopy(2005);\n+        expected = expected.monthOfYear().setCopy(6);\n+        assertEquals(expected, test);\n+    }\n+\n+    public void testToDateTime_nullRI() {\n+        YearMonth base = new YearMonth(2005, 6);\n+        DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7);\n+        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n+        \n+        DateTime test = base.toDateTime((ReadableInstant) null);\n+        check(base, 2005, 6);\n+        DateTime expected = dt;\n+        expected = expected.year().setCopy(2005);\n+        expected = expected.monthOfYear().setCopy(6);\n+        assertEquals(expected, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToInterval() {\n+        YearMonth base = new YearMonth(2005, 6, COPTIC_PARIS); // PARIS irrelevant\n+        Interval test = base.toInterval();\n+        check(base, 2005, 6);\n+        DateTime start = new DateTime(2005, 6, 1, 0, 0, COPTIC_LONDON);\n+        DateTime end = new DateTime(2005, 7, 1, 0, 0, COPTIC_LONDON);\n+        Interval expected = new Interval(start, end);\n+        assertEquals(expected, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToInterval_Zone() {\n+        YearMonth base = new YearMonth(2005, 6, COPTIC_PARIS); // PARIS irrelevant\n+        Interval test = base.toInterval(TOKYO);\n+        check(base, 2005, 6);\n+        DateTime start = new DateTime(2005, 6, 1, 0, 0, COPTIC_TOKYO);\n+        DateTime end = new DateTime(2005, 7, 1, 0, 0, COPTIC_TOKYO);\n+        Interval expected = new Interval(start, end);\n+        assertEquals(expected, test);\n+    }\n+\n+    public void testToInterval_nullZone() {\n+        YearMonth base = new YearMonth(2005, 6, COPTIC_PARIS); // PARIS irrelevant\n+        Interval test = base.toInterval(null);\n+        check(base, 2005, 6);\n+        DateTime start = new DateTime(2005, 6, 1, 0, 0, COPTIC_LONDON);\n+        DateTime end = new DateTime(2005, 7, 1, 0, 0, COPTIC_LONDON);\n+        Interval expected = new Interval(start, end);\n+        assertEquals(expected, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithers() {\n+        YearMonth test = new YearMonth(1970, 6);\n+        check(test.withYear(2000), 2000, 6);\n+        check(test.withMonthOfYear(2), 1970, 2);\n+        try {\n+            test.withMonthOfYear(0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.withMonthOfYear(13);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testProperty() {\n+        YearMonth test = new YearMonth(2005, 6);\n+        assertEquals(test.year(), test.property(DateTimeFieldType.year()));\n+        assertEquals(test.monthOfYear(), test.property(DateTimeFieldType.monthOfYear()));\n+        try {\n+            test.property(DateTimeFieldType.millisOfDay());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.property(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        YearMonth test = new YearMonth(1972, 6, COPTIC_PARIS);\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        YearMonth result = (YearMonth) ois.readObject();\n+        ois.close();\n+        \n+        assertEquals(test, result);\n+        assertTrue(Arrays.equals(test.getValues(), result.getValues()));\n+        assertTrue(Arrays.equals(test.getFields(), result.getFields()));\n+        assertEquals(test.getChronology(), result.getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        YearMonth test = new YearMonth(2002, 6);\n+        assertEquals(\"2002-06\", test.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString_String() {\n+        YearMonth test = new YearMonth(2002, 6);\n+        assertEquals(\"2002 \\ufffd\\ufffd\", test.toString(\"yyyy HH\"));\n+        assertEquals(\"2002-06\", test.toString((String) null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString_String_Locale() {\n+        YearMonth test = new YearMonth(2002, 6);\n+        assertEquals(\"\\ufffd \\ufffd/6\", test.toString(\"EEE d/M\", Locale.ENGLISH));\n+        assertEquals(\"\\ufffd \\ufffd/6\", test.toString(\"EEE d/M\", Locale.FRENCH));\n+        assertEquals(\"2002-06\", test.toString(null, Locale.ENGLISH));\n+        assertEquals(\"\\ufffd \\ufffd/6\", test.toString(\"EEE d/M\", null));\n+        assertEquals(\"2002-06\", test.toString(null, null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString_DTFormatter() {\n+        YearMonth test = new YearMonth(2002, 6);\n+        assertEquals(\"2002 \\ufffd\\ufffd\", test.toString(DateTimeFormat.forPattern(\"yyyy HH\")));\n+        assertEquals(\"2002-06\", test.toString((DateTimeFormatter) null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void check(YearMonth test, int year, int month) {\n+        assertEquals(year, test.getYear());\n+        assertEquals(month, test.getMonthOfYear());\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestYearMonth_Constructors.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.GregorianChronology;\n+import org.joda.time.chrono.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for YearMonth.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestYearMonth_Constructors extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n+    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();\n+    private static final Chronology GREGORIAN_UTC = GregorianChronology.getInstanceUTC();\n+    private static final Chronology GREGORIAN_PARIS = GregorianChronology.getInstance(PARIS);\n+    \n+    private long TEST_TIME_NOW =\n+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    private long TEST_TIME1 =\n+        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private long TEST_TIME2 =\n+        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestYearMonth_Constructors.class);\n+    }\n+\n+    public TestYearMonth_Constructors(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_FromCalendarFields() throws Exception {\n+        GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n+        cal.set(Calendar.MILLISECOND, 7);\n+        YearMonth expected = new YearMonth(1970, 2);\n+        assertEquals(expected, YearMonth.fromCalendarFields(cal));\n+        try {\n+            YearMonth.fromCalendarFields(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_FromDateFields() throws Exception {\n+        GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n+        cal.set(Calendar.MILLISECOND, 7);\n+        YearMonth expected = new YearMonth(1970, 2);\n+        assertEquals(expected, YearMonth.fromDateFields(cal.getTime()));\n+        try {\n+            YearMonth.fromDateFields(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor ()\n+     */\n+    public void testConstructor() throws Throwable {\n+        YearMonth test = new YearMonth();\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+    }\n+\n+    /**\n+     * Test constructor (DateTimeZone)\n+     */\n+    public void testConstructor_DateTimeZone() throws Throwable {\n+        DateTime dt = new DateTime(2005, 6, 30, 23, 59, 0, 0, LONDON);\n+        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n+        // 23:59 in London is 00:59 the following day in Paris\n+        \n+        YearMonth test = new YearMonth(LONDON);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(2005, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        \n+        test = new YearMonth(PARIS);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(2005, test.getYear());\n+        assertEquals(7, test.getMonthOfYear());\n+    }\n+\n+    /**\n+     * Test constructor (DateTimeZone=null)\n+     */\n+    public void testConstructor_nullDateTimeZone() throws Throwable {\n+        DateTime dt = new DateTime(2005, 6, 30, 23, 59, 0, 0, LONDON);\n+        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n+        // 23:59 in London is 00:59 the following day in Paris\n+        \n+        YearMonth test = new YearMonth((DateTimeZone) null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(2005, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+    }\n+\n+    /**\n+     * Test constructor (Chronology)\n+     */\n+    public void testConstructor_Chronology() throws Throwable {\n+        YearMonth test = new YearMonth(GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+    }\n+\n+    /**\n+     * Test constructor (Chronology=null)\n+     */\n+    public void testConstructor_nullChronology() throws Throwable {\n+        YearMonth test = new YearMonth((Chronology) null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long1() throws Throwable {\n+        YearMonth test = new YearMonth(TEST_TIME1);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+    }\n+\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long2() throws Throwable {\n+        YearMonth test = new YearMonth(TEST_TIME2);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1971, test.getYear());\n+        assertEquals(5, test.getMonthOfYear());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology)\n+     */\n+    public void testConstructor_long1_Chronology() throws Throwable {\n+        YearMonth test = new YearMonth(TEST_TIME1, GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology)\n+     */\n+    public void testConstructor_long2_Chronology() throws Throwable {\n+        YearMonth test = new YearMonth(TEST_TIME2, GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(1971, test.getYear());\n+        assertEquals(5, test.getMonthOfYear());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology=null)\n+     */\n+    public void testConstructor_long_nullChronology() throws Throwable {\n+        YearMonth test = new YearMonth(TEST_TIME1, null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_Object() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        YearMonth test = new YearMonth(date);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+    }\n+\n+    public void testConstructor_nullObject() throws Throwable {\n+        YearMonth test = new YearMonth((Object) null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+    }\n+\n+    public void testConstructor_ObjectString1() throws Throwable {\n+        YearMonth test = new YearMonth(\"1972-12\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1972, test.getYear());\n+        assertEquals(12, test.getMonthOfYear());\n+    }\n+\n+    public void testConstructor_ObjectString2() throws Throwable {\n+        YearMonth test = new YearMonth(\"1972-12-01T+14:00\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1972, test.getYear());\n+        assertEquals(11, test.getMonthOfYear());  // timezone\n+    }\n+\n+    public void testConstructor_ObjectString3() throws Throwable {\n+        YearMonth test = new YearMonth(\"1972-12-03T10:20:30.040\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1972, test.getYear());\n+        assertEquals(12, test.getMonthOfYear());\n+    }\n+\n+    public void testConstructor_ObjectString4() throws Throwable {\n+        YearMonth test = new YearMonth(\"1972-12-01T10:20:30.040+14:00\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1972, test.getYear());\n+        assertEquals(11, test.getMonthOfYear());  // timezone\n+    }\n+\n+    public void testConstructor_ObjectString5() throws Throwable {\n+        YearMonth test = new YearMonth(\"10\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(10, test.getYear());\n+        assertEquals(1, test.getMonthOfYear());\n+    }\n+\n+    public void testConstructor_ObjectStringEx1() throws Throwable {\n+        try {\n+            new YearMonth(\"T10:20:30.040\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testConstructor_ObjectStringEx2() throws Throwable {\n+        try {\n+            new YearMonth(\"T10:20:30.040+14:00\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testConstructor_ObjectStringEx3() throws Throwable {\n+        try {\n+            new YearMonth(\"10:20:30.040\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testConstructor_ObjectStringEx4() throws Throwable {\n+        try {\n+            new YearMonth(\"10:20:30.040+14:00\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (Object, Chronology)\n+     */\n+    public void testConstructor_Object_Chronology() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        YearMonth test = new YearMonth(date, GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, Chronology)\n+     */\n+    public void testConstructor_nullObject_Chronology() throws Throwable {\n+        YearMonth test = new YearMonth((Object) null, GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+    }\n+\n+    /**\n+     * Test constructor (Object, Chronology=null)\n+     */\n+    public void testConstructor_Object_nullChronology() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        YearMonth test = new YearMonth(date, null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, Chronology=null)\n+     */\n+    public void testConstructor_nullObject_nullChronology() throws Throwable {\n+        YearMonth test = new YearMonth((Object) null, null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (int, int)\n+     */\n+    public void testConstructor_int_int() throws Throwable {\n+        YearMonth test = new YearMonth(1970, 6);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        try {\n+            new YearMonth(Integer.MIN_VALUE, 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonth(Integer.MAX_VALUE, 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonth(1970, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonth(1970, 13);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, Chronology)\n+     */\n+    public void testConstructor_int_int_Chronology() throws Throwable {\n+        YearMonth test = new YearMonth(1970, 6, GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        try {\n+            new YearMonth(Integer.MIN_VALUE, 6, GREGORIAN_PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonth(Integer.MAX_VALUE, 6, GREGORIAN_PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonth(1970, 0, GREGORIAN_PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonth(1970, 13, GREGORIAN_PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, Chronology=null)\n+     */\n+    public void testConstructor_int_int_nullChronology() throws Throwable {\n+        YearMonth test = new YearMonth(1970, 6, null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestYearMonth_Properties.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.CopticChronology;\n+import org.joda.time.chrono.LenientChronology;\n+import org.joda.time.chrono.StrictChronology;\n+\n+/**\n+ * This class is a Junit unit test for YearMonth.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestYearMonth_Properties extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS);\n+\n+    private long TEST_TIME_NOW =\n+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    private long TEST_TIME1 =\n+        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private long TEST_TIME2 =\n+        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestYearMonth_Properties.class);\n+    }\n+\n+    public TestYearMonth_Properties(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(DateTimeZone.UTC);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetYear() {\n+        YearMonth test = new YearMonth(1972, 6);\n+        assertSame(test.getChronology().year(), test.year().getField());\n+        assertEquals(\"year\", test.year().getName());\n+        assertEquals(\"Property[year]\", test.year().toString());\n+        assertSame(test, test.year().getReadablePartial());\n+        assertSame(test, test.year().getYearMonth());\n+        assertEquals(1972, test.year().get());\n+        assertEquals(\"1972\", test.year().getAsString());\n+        assertEquals(\"1972\", test.year().getAsText());\n+        assertEquals(\"1972\", test.year().getAsText(Locale.FRENCH));\n+        assertEquals(\"1972\", test.year().getAsShortText());\n+        assertEquals(\"1972\", test.year().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().years(), test.year().getDurationField());\n+        assertEquals(null, test.year().getRangeDurationField());\n+        assertEquals(9, test.year().getMaximumTextLength(null));\n+        assertEquals(9, test.year().getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesYear() {\n+        YearMonth test = new YearMonth(1972, 6);\n+        assertEquals(-292275054, test.year().getMinimumValue());\n+        assertEquals(-292275054, test.year().getMinimumValueOverall());\n+        assertEquals(292278993, test.year().getMaximumValue());\n+        assertEquals(292278993, test.year().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddYear() {\n+        YearMonth test = new YearMonth(1972, 6);\n+        YearMonth copy = test.year().addToCopy(9);\n+        check(test, 1972, 6);\n+        check(copy, 1981, 6);\n+        \n+        copy = test.year().addToCopy(0);\n+        check(copy, 1972, 6);\n+        \n+        copy = test.year().addToCopy(292277023 - 1972);\n+        check(copy, 292277023, 6);\n+        \n+        try {\n+            test.year().addToCopy(292278993 - 1972 + 1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 1972, 6);\n+        \n+        copy = test.year().addToCopy(-1972);\n+        check(copy, 0, 6);\n+        \n+        copy = test.year().addToCopy(-1973);\n+        check(copy, -1, 6);\n+        \n+        try {\n+            test.year().addToCopy(-292275054 - 1972 - 1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 1972, 6);\n+    }\n+\n+    public void testPropertyAddWrapFieldYear() {\n+        YearMonth test = new YearMonth(1972, 6);\n+        YearMonth copy = test.year().addWrapFieldToCopy(9);\n+        check(test, 1972, 6);\n+        check(copy, 1981, 6);\n+        \n+        copy = test.year().addWrapFieldToCopy(0);\n+        check(copy, 1972, 6);\n+        \n+        copy = test.year().addWrapFieldToCopy(292278993 - 1972 + 1);\n+        check(copy, -292275054, 6);\n+        \n+        copy = test.year().addWrapFieldToCopy(-292275054 - 1972 - 1);\n+        check(copy, 292278993, 6);\n+    }\n+\n+    public void testPropertySetYear() {\n+        YearMonth test = new YearMonth(1972, 6);\n+        YearMonth copy = test.year().setCopy(12);\n+        check(test, 1972, 6);\n+        check(copy, 12, 6);\n+    }\n+\n+    public void testPropertySetTextYear() {\n+        YearMonth test = new YearMonth(1972, 6);\n+        YearMonth copy = test.year().setCopy(\"12\");\n+        check(test, 1972, 6);\n+        check(copy, 12, 6);\n+    }\n+\n+    public void testPropertyCompareToYear() {\n+        YearMonth test1 = new YearMonth(TEST_TIME1);\n+        YearMonth test2 = new YearMonth(TEST_TIME2);\n+        assertEquals(true, test1.year().compareTo(test2) < 0);\n+        assertEquals(true, test2.year().compareTo(test1) > 0);\n+        assertEquals(true, test1.year().compareTo(test1) == 0);\n+        try {\n+            test1.year().compareTo((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.year().compareTo(dt2) < 0);\n+        assertEquals(true, test2.year().compareTo(dt1) > 0);\n+        assertEquals(true, test1.year().compareTo(dt1) == 0);\n+        try {\n+            test1.year().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetMonth() {\n+        YearMonth test = new YearMonth(1972, 6);\n+        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());\n+        assertEquals(\"monthOfYear\", test.monthOfYear().getName());\n+        assertEquals(\"Property[monthOfYear]\", test.monthOfYear().toString());\n+        assertSame(test, test.monthOfYear().getReadablePartial());\n+        assertSame(test, test.monthOfYear().getYearMonth());\n+        assertEquals(6, test.monthOfYear().get());\n+        assertEquals(\"6\", test.monthOfYear().getAsString());\n+        assertEquals(\"June\", test.monthOfYear().getAsText());\n+        assertEquals(\"juin\", test.monthOfYear().getAsText(Locale.FRENCH));\n+        assertEquals(\"Jun\", test.monthOfYear().getAsShortText());\n+        assertEquals(\"juin\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());\n+        assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());\n+        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));\n+        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));\n+        test = new YearMonth(1972, 7);\n+        assertEquals(\"juillet\", test.monthOfYear().getAsText(Locale.FRENCH));\n+        assertEquals(\"juil.\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesMonth() {\n+        YearMonth test = new YearMonth(1972, 6);\n+        assertEquals(1, test.monthOfYear().getMinimumValue());\n+        assertEquals(1, test.monthOfYear().getMinimumValueOverall());\n+        assertEquals(12, test.monthOfYear().getMaximumValue());\n+        assertEquals(12, test.monthOfYear().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddMonth() {\n+        YearMonth test = new YearMonth(1972, 6);\n+        YearMonth copy = test.monthOfYear().addToCopy(6);\n+        check(test, 1972, 6);\n+        check(copy, 1972, 12);\n+        \n+        copy = test.monthOfYear().addToCopy(7);\n+        check(copy, 1973, 1);\n+        \n+        copy = test.monthOfYear().addToCopy(-5);\n+        check(copy, 1972, 1);\n+        \n+        copy = test.monthOfYear().addToCopy(-6);\n+        check(copy, 1971, 12);\n+    }\n+\n+    public void testPropertyAddWrapFieldMonth() {\n+        YearMonth test = new YearMonth(1972, 6);\n+        YearMonth copy = test.monthOfYear().addWrapFieldToCopy(4);\n+        check(test, 1972, 6);\n+        check(copy, 1972, 10);\n+        \n+        copy = test.monthOfYear().addWrapFieldToCopy(8);\n+        check(copy, 1972, 2);\n+        \n+        copy = test.monthOfYear().addWrapFieldToCopy(-8);\n+        check(copy, 1972, 10);\n+    }\n+\n+    public void testPropertySetMonth() {\n+        YearMonth test = new YearMonth(1972, 6);\n+        YearMonth copy = test.monthOfYear().setCopy(12);\n+        check(test, 1972, 6);\n+        check(copy, 1972, 12);\n+        \n+        try {\n+            test.monthOfYear().setCopy(13);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.monthOfYear().setCopy(0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testPropertySetTextMonth() {\n+        YearMonth test = new YearMonth(1972, 6);\n+        YearMonth copy = test.monthOfYear().setCopy(\"12\");\n+        check(test, 1972, 6);\n+        check(copy, 1972, 12);\n+        \n+        copy = test.monthOfYear().setCopy(\"December\");\n+        check(test, 1972, 6);\n+        check(copy, 1972, 12);\n+        \n+        copy = test.monthOfYear().setCopy(\"Dec\");\n+        check(test, 1972, 6);\n+        check(copy, 1972, 12);\n+    }\n+\n+    public void testPropertyCompareToMonth() {\n+        YearMonth test1 = new YearMonth(TEST_TIME1);\n+        YearMonth test2 = new YearMonth(TEST_TIME2);\n+        assertEquals(true, test1.monthOfYear().compareTo(test2) < 0);\n+        assertEquals(true, test2.monthOfYear().compareTo(test1) > 0);\n+        assertEquals(true, test1.monthOfYear().compareTo(test1) == 0);\n+        try {\n+            test1.monthOfYear().compareTo((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0);\n+        assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0);\n+        assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0);\n+        try {\n+            test1.monthOfYear().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyEquals() {\n+        YearMonth test1 = new YearMonth(11, 11);\n+        YearMonth test2 = new YearMonth(11, 12);\n+        YearMonth test3 = new YearMonth(11, 11, CopticChronology.getInstanceUTC());\n+        assertEquals(true, test1.monthOfYear().equals(test1.monthOfYear()));\n+        assertEquals(false, test1.monthOfYear().equals(test1.year()));\n+        assertEquals(false, test1.monthOfYear().equals(test2.monthOfYear()));\n+        assertEquals(false, test1.monthOfYear().equals(test2.year()));\n+        \n+        assertEquals(false, test1.year().equals(test1.monthOfYear()));\n+        assertEquals(true, test1.year().equals(test1.year()));\n+        assertEquals(false, test1.year().equals(test2.monthOfYear()));\n+        assertEquals(true, test1.year().equals(test2.year()));\n+        \n+        assertEquals(false, test1.monthOfYear().equals(null));\n+        assertEquals(false, test1.monthOfYear().equals(\"any\"));\n+        \n+        // chrono\n+        assertEquals(false, test1.monthOfYear().equals(test3.monthOfYear()));\n+    }\n+\n+    public void testPropertyHashCode() {\n+        YearMonth test1 = new YearMonth(2005, 11);\n+        YearMonth test2 = new YearMonth(2005, 12);\n+        assertEquals(true, test1.monthOfYear().hashCode() == test1.monthOfYear().hashCode());\n+        assertEquals(false, test1.monthOfYear().hashCode() == test2.monthOfYear().hashCode());\n+        assertEquals(true, test1.year().hashCode() == test1.year().hashCode());\n+        assertEquals(true, test1.year().hashCode() == test2.year().hashCode());\n+    }\n+\n+    public void testPropertyEqualsHashCodeLenient() {\n+        YearMonth test1 = new YearMonth(1970, 6, LenientChronology.getInstance(COPTIC_PARIS));\n+        YearMonth test2 = new YearMonth(1970, 6, LenientChronology.getInstance(COPTIC_PARIS));\n+        assertEquals(true, test1.monthOfYear().equals(test2.monthOfYear()));\n+        assertEquals(true, test2.monthOfYear().equals(test1.monthOfYear()));\n+        assertEquals(true, test1.monthOfYear().equals(test1.monthOfYear()));\n+        assertEquals(true, test2.monthOfYear().equals(test2.monthOfYear()));\n+        assertEquals(true, test1.monthOfYear().hashCode() == test2.monthOfYear().hashCode());\n+        assertEquals(true, test1.monthOfYear().hashCode() == test1.monthOfYear().hashCode());\n+        assertEquals(true, test2.monthOfYear().hashCode() == test2.monthOfYear().hashCode());\n+    }\n+\n+    public void testPropertyEqualsHashCodeStrict() {\n+        YearMonth test1 = new YearMonth(1970, 6, StrictChronology.getInstance(COPTIC_PARIS));\n+        YearMonth test2 = new YearMonth(1970, 6, StrictChronology.getInstance(COPTIC_PARIS));\n+        assertEquals(true, test1.monthOfYear().equals(test2.monthOfYear()));\n+        assertEquals(true, test2.monthOfYear().equals(test1.monthOfYear()));\n+        assertEquals(true, test1.monthOfYear().equals(test1.monthOfYear()));\n+        assertEquals(true, test2.monthOfYear().equals(test2.monthOfYear()));\n+        assertEquals(true, test1.monthOfYear().hashCode() == test2.monthOfYear().hashCode());\n+        assertEquals(true, test1.monthOfYear().hashCode() == test1.monthOfYear().hashCode());\n+        assertEquals(true, test2.monthOfYear().hashCode() == test2.monthOfYear().hashCode());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void check(YearMonth test, int year, int month) {\n+        assertEquals(year, test.getYear());\n+        assertEquals(month, test.getMonthOfYear());\n+    }\n+}", "timestamp": 1257610436, "metainfo": ""}