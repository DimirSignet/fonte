{"sha": "de0a35397489a3d8ae2664b6b6d48604f9a6900f", "log": "Add DateTimeFieldType and DurationFieldType   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/Chronology.java\n+++ b/JodaTime/src/java/org/joda/time/Chronology.java\n      */\n     public abstract void validate(ReadablePartial instant, int[] values);\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the field from the type.\n+     * <p>\n+     * This method obtains the <code>DateTimeField</code> for the <code>DateTimeFieldType</code>.\n+     * It is essentially a generic way of calling one of the field methods.\n+     *\n+     * @param type  a field type, usually obtained from DateTimeFieldType\n+     * @return the chronology field\n+     * @throws IllegalArgumentException if the field is null\n+     */\n+    public abstract DateTimeField getField(DateTimeFieldType type);\n+\n     // Millis\n     //-----------------------------------------------------------------------\n     /**\n--- a/JodaTime/src/java/org/joda/time/DateTimeComparator.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeComparator.java\n import java.util.Comparator;\n \n import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.InstantConverter;\n \n /**\n  * DateTimeComparator provides comparators to compare one date with another.\n     private static final long serialVersionUID = -6097339773320178364L;\n \n     /** Singleton instance */\n-    private static final DateTimeComparator INSTANCE = new DateTimeComparator(null, null);\n+    private static final DateTimeComparator ALL_INSTANCE = new DateTimeComparator(null, null);\n+    /** Singleton instance */\n+    private static final DateTimeComparator DATE_INSTANCE = new DateTimeComparator(DateTimeFieldType.dayOfYear(), null);\n+    /** Singleton instance */\n+    private static final DateTimeComparator TIME_INSTANCE = new DateTimeComparator(null, DateTimeFieldType.dayOfYear());\n \n     /** The lower limit of fields to compare, null if no limit */\n-    private final DateTimeField iLowerLimit;\n+    private final DateTimeFieldType iLowerLimit;\n     /** The upper limit of fields to compare, null if no limit */\n-    private final DateTimeField iUpperLimit;\n+    private final DateTimeFieldType iUpperLimit;\n \n     //-----------------------------------------------------------------------\n     /**\n      * @return a comparator over all fields\n      */\n     public static DateTimeComparator getInstance() {\n-        return INSTANCE;\n+        return ALL_INSTANCE;\n     }\n \n     /**\n      * @param lowerLimit  inclusive lower limit for fields to be compared, null means no limit\n      * @return a comparator over all fields above the lower limit\n      */\n-    public static DateTimeComparator getInstance(DateTimeField lowerLimit) {\n+    public static DateTimeComparator getInstance(DateTimeFieldType lowerLimit) {\n         return getInstance(lowerLimit, null);\n     }\n \n      * @param lowerLimit  inclusive lower limit for fields to be compared, null means no limit\n      * @param upperLimit  exclusive upper limit for fields to be compared, null means no limit\n      * @return a comparator over all fields between the limits\n-     * @throws IllegalArgumentException if the lower limit is greater than the upper\n-     */\n-    public static DateTimeComparator getInstance(DateTimeField lowerLimit, DateTimeField upperLimit) {\n+     */\n+    public static DateTimeComparator getInstance(DateTimeFieldType lowerLimit, DateTimeFieldType upperLimit) {\n         if (lowerLimit == null && upperLimit == null) {\n-            return INSTANCE;\n-        }\n-        if (lowerLimit != null && upperLimit != null) {\n-            if (lowerLimit.getDurationField().getUnitMillis() > upperLimit.getDurationField().getUnitMillis()) {\n-                throw new IllegalArgumentException(\"Lower limit greater than upper: \" +\n-                    lowerLimit.getName() + \" > \" + upperLimit.getName());\n-            }\n+            return ALL_INSTANCE;\n+        }\n+        if (lowerLimit == DateTimeFieldType.dayOfYear() && upperLimit == null) {\n+            return DATE_INSTANCE;\n+        }\n+        if (lowerLimit == null && upperLimit == DateTimeFieldType.dayOfYear()) {\n+            return TIME_INSTANCE;\n         }\n         return new DateTimeComparator(lowerLimit, upperLimit);\n     }\n      * Returns a comparator that only considers date fields.\n      * Time of day is ignored.\n      * \n-     * @param chrono  the chronology to use\n      * @return a comparator over all date fields\n      */\n-    public static DateTimeComparator getDateOnlyInstance(Chronology chrono) {\n-        chrono = DateTimeUtils.getChronology(chrono);\n-        return getInstance(chrono.dayOfYear(), null);\n+    public static DateTimeComparator getDateOnlyInstance() {\n+        return DATE_INSTANCE;\n     }\n \n     /**\n      * Returns a comparator that only considers time fields.\n      * Date is ignored.\n      * \n-     * @param chrono  the chronology to use\n      * @return a comparator over all time fields\n      */\n-    public static DateTimeComparator getTimeOnlyInstance(Chronology chrono) {\n-        chrono = DateTimeUtils.getChronology(chrono);\n-        return getInstance(null, chrono.dayOfYear());\n+    public static DateTimeComparator getTimeOnlyInstance() {\n+        return TIME_INSTANCE;\n     }\n \n     /**\n      * @param lowerLimit  the lower field limit, null means no limit\n      * @param upperLimit  the upper field limit, null means no limit\n      */\n-    protected DateTimeComparator(DateTimeField lowerLimit, DateTimeField upperLimit) {\n+    protected DateTimeComparator(DateTimeFieldType lowerLimit, DateTimeFieldType upperLimit) {\n         super();\n         iLowerLimit = lowerLimit;\n         iUpperLimit = upperLimit;\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the field that represents the lower limit of comparison.\n-     * \n-     * @return the field, null if no upper limit\n-     */\n-    public DateTimeField getLowerLimit() {\n+     * Gets the field type that represents the lower limit of comparison.\n+     * \n+     * @return the field type, null if no upper limit\n+     */\n+    public DateTimeFieldType getLowerLimit() {\n         return iLowerLimit;\n     }\n \n     /**\n-     * Gets the field that represents the upper limit of comparison.\n-     * \n-     * @return the field, null if no upper limit\n-     */\n-    public DateTimeField getUpperLimit() {\n+     * Gets the field type that represents the upper limit of comparison.\n+     * \n+     * @return the field type, null if no upper limit\n+     */\n+    public DateTimeFieldType getUpperLimit() {\n         return iUpperLimit;\n     }\n \n      * @throws IllegalArgumentException if either argument is not supported\n      */\n     public int compare(Object lhsObj, Object rhsObj) {\n-        long lhsMillis = getMillisFromObject(lhsObj);\n-        long rhsMillis = getMillisFromObject(rhsObj);\n+        InstantConverter conv = ConverterManager.getInstance().getInstantConverter(lhsObj);\n+        long lhsMillis = conv.getInstantMillis(lhsObj);\n+        Chronology lhsChrono = conv.getChronology(lhsObj);\n+        \n+        conv = ConverterManager.getInstance().getInstantConverter(rhsObj);\n+        long rhsMillis = conv.getInstantMillis(rhsObj);\n+        Chronology rhsChrono = conv.getChronology(rhsObj);\n \n         if (iLowerLimit != null) {\n-            lhsMillis = iLowerLimit.roundFloor(lhsMillis);\n-            rhsMillis = iLowerLimit.roundFloor(rhsMillis);\n+            lhsMillis = lhsChrono.getField(iLowerLimit).roundFloor(lhsMillis);\n+            rhsMillis = rhsChrono.getField(iLowerLimit).roundFloor(rhsMillis);\n         }\n \n         if (iUpperLimit != null) {\n-            lhsMillis = iUpperLimit.remainder(lhsMillis);\n-            rhsMillis = iUpperLimit.remainder(rhsMillis);\n+            lhsMillis = lhsChrono.getField(iUpperLimit).remainder(lhsMillis);\n+            rhsMillis = rhsChrono.getField(iUpperLimit).remainder(rhsMillis);\n         }\n \n         if (lhsMillis < rhsMillis) {\n         } else {\n             return 0;\n         }\n-    }\n-\n-    /**\n-     * Gets the millisecond value from an object using the converter system.\n-     * \n-     * @param obj  the object to convert\n-     * @return millis since the epoch\n-     */\n-    private static long getMillisFromObject(Object obj) {\n-        return ConverterManager.getInstance().getInstantConverter(obj).getInstantMillis(obj);\n     }\n \n     //-----------------------------------------------------------------------\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/DateTimeFieldType.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Identifies a field, such as year or minuteOfHour, in a chronology-neutral way.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public class DateTimeFieldType implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -42615285973990L;\n+\n+    /** The cache of name to type used to ensure singletons. */\n+    private static Map cCache = new HashMap();\n+    /** The era field. */\n+    private static final DateTimeFieldType ERA = new DateTimeFieldType(\"era\");\n+    /** The yearOfEra field. */\n+    private static final DateTimeFieldType YEAR_OF_ERA = new DateTimeFieldType(\"yearOfEra\");\n+    /** The centuryOfEra field. */\n+    private static final DateTimeFieldType CENTURY_OF_ERA = new DateTimeFieldType(\"centuryOfEra\");\n+    /** The yearOfCentury field. */\n+    private static final DateTimeFieldType YEAR_OF_CENTURY = new DateTimeFieldType(\"yearOfCentury\");\n+    /** The year field. */\n+    private static final DateTimeFieldType YEAR = new DateTimeFieldType(\"year\");\n+    /** The dayOfYear field. */\n+    private static final DateTimeFieldType DAY_OF_YEAR = new DateTimeFieldType(\"dayOfYear\");\n+    /** The monthOfYear field. */\n+    private static final DateTimeFieldType MONTH_OF_YEAR = new DateTimeFieldType(\"monthOfYear\");\n+    /** The dayOfMonth field. */\n+    private static final DateTimeFieldType DAY_OF_MONTH = new DateTimeFieldType(\"dayOfMonth\");\n+    /** The weekyear field. */\n+    private static final DateTimeFieldType WEEKYEAR = new DateTimeFieldType(\"weekyear\");\n+    /** The weekOfWeekyear field. */\n+    private static final DateTimeFieldType WEEK_OF_WEEKYEAR = new DateTimeFieldType(\"weekOfWeekyear\");\n+    /** The dayOfWeek field. */\n+    private static final DateTimeFieldType DAY_OF_WEEK = new DateTimeFieldType(\"dayOfWeek\");\n+\n+    /** The halfday field. */\n+    private static final DateTimeFieldType HALFDAY_OF_DAY = new DateTimeFieldType(\"halfdayOfDay\");\n+    /** The hourOfHalfday field. */\n+    private static final DateTimeFieldType HOUR_OF_HALFDAY = new DateTimeFieldType(\"hourOfHalfday\");\n+    /** The clockhourOfHalfday field. */\n+    private static final DateTimeFieldType CLOCKHOUR_OF_HALFDAY = new DateTimeFieldType(\"clockhourOfHalfday\");\n+    /** The clockhourOfDay field. */\n+    private static final DateTimeFieldType CLOCKHOUR_OF_DAY = new DateTimeFieldType(\"clockhourOfDay\");\n+    /** The hourOfDay field. */\n+    private static final DateTimeFieldType HOUR_OF_DAY = new DateTimeFieldType(\"hourOfDay\");\n+    /** The minuteOfDay field. */\n+    private static final DateTimeFieldType MINUTE_OF_DAY = new DateTimeFieldType(\"minuteOfDay\");\n+    /** The minuteOfHour field. */\n+    private static final DateTimeFieldType MINUTE_OF_HOUR = new DateTimeFieldType(\"minuteOfHour\");\n+    /** The secondOfDay field. */\n+    private static final DateTimeFieldType SECOND_OF_DAY = new DateTimeFieldType(\"secondOfDay\");\n+    /** The secondOfMinute field. */\n+    private static final DateTimeFieldType SECOND_OF_MINUTE = new DateTimeFieldType(\"secondOfMinute\");\n+    /** The millisOfDay field. */\n+    private static final DateTimeFieldType MILLIS_OF_DAY = new DateTimeFieldType(\"millisOfDay\");\n+    /** The millisOfSecond field. */\n+    private static final DateTimeFieldType MILLIS_OF_SECOND = new DateTimeFieldType(\"millisOfSecond\");\n+\n+    /** The name of the field. */\n+    private final String iName;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Factory method to obtain a DateTimeFieldType by name ensuring each\n+     * type is a singleton.\n+     * <p>\n+     * If the name is not found, an error is thrown.\n+     * \n+     * @param name  the name to retrieve\n+     * @return the singleton type\n+     */\n+    public static synchronized DateTimeFieldType getInstance(String name) {\n+        DateTimeFieldType type = (DateTimeFieldType) cCache.get(name);\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The field '\" + name + \"' is unknown\");\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Factory method to define a DateTimeFieldType by name ensuring each\n+     * type is a singleton.\n+     * <p>\n+     * This method checks to see if the name is previously defined, in which\n+     * case it returns the previously defined type object.\n+     * If the name is not found, a new type is created.\n+     * <p>\n+     * It is intended that this method is called once in your program startup\n+     * and then you use the <code>getInstance</code> method. This could be\n+     * achieved by subclassing this class.\n+     * \n+     * @param name  the name to retrieve\n+     * @return the singleton type\n+     */\n+    public static synchronized DateTimeFieldType define(String name) {\n+        DateTimeFieldType type = (DateTimeFieldType) cCache.get(name);\n+        if (type == null) {\n+            return new DateTimeFieldType(name);\n+        }\n+        return type;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     * \n+     * @param name  the name to use\n+     */\n+    private DateTimeFieldType(String name) {\n+        super();\n+        iName = name;\n+        cCache.put(name, this);\n+    }\n+\n+    /**\n+     * Ensure a singleton is returned.\n+     * \n+     * @return the singleton type\n+     */\n+    private Object readResolve() {\n+        return getInstance(iName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the millis of second field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType millisOfSecond() {\n+        return MILLIS_OF_SECOND;\n+    }\n+\n+    /**\n+     * Get the millis of day field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType millisOfDay() {\n+        return MILLIS_OF_DAY;\n+    }\n+\n+    /**\n+     * Get the second of minute field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType secondOfMinute() {\n+        return SECOND_OF_MINUTE;\n+    }\n+\n+    /**\n+     * Get the second of day field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType secondOfDay() {\n+        return SECOND_OF_DAY;\n+    }\n+\n+    /**\n+     * Get the minute of hour field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType minuteOfHour() {\n+        return MINUTE_OF_HOUR;\n+    }\n+\n+    /**\n+     * Get the minute of day field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType minuteOfDay() {\n+        return MINUTE_OF_DAY;\n+    }\n+\n+    /**\n+     * Get the hour of day (0-23) field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType hourOfDay() {\n+        return HOUR_OF_DAY;\n+    }\n+\n+    /**\n+     * Get the hour of day (offset to 1-24) field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType clockhourOfDay() {\n+        return CLOCKHOUR_OF_DAY;\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (0-11) field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType hourOfHalfday() {\n+        return HOUR_OF_HALFDAY;\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (offset to 1-12) field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType clockhourOfHalfday() {\n+        return CLOCKHOUR_OF_HALFDAY;\n+    }\n+\n+    /**\n+     * Get the AM(0) PM(1) field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType halfdayOfDay() {\n+        return HALFDAY_OF_DAY;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the day of week field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType dayOfWeek() {\n+        return DAY_OF_WEEK;\n+    }\n+\n+    /**\n+     * Get the day of month field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType dayOfMonth() {\n+        return DAY_OF_MONTH;\n+    }\n+\n+    /**\n+     * Get the day of year field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType dayOfYear() {\n+        return DAY_OF_YEAR;\n+    }\n+\n+    /**\n+     * Get the week of a week based year field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType weekOfWeekyear() {\n+        return WEEK_OF_WEEKYEAR;\n+    }\n+\n+    /**\n+     * Get the year of a week based year field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType weekyear() {\n+        return WEEKYEAR;\n+    }\n+\n+    /**\n+     * Get the month of year field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType monthOfYear() {\n+        return MONTH_OF_YEAR;\n+    }\n+\n+    /**\n+     * Get the year field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType year() {\n+        return YEAR;\n+    }\n+\n+    /**\n+     * Get the year of era field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType yearOfEra() {\n+        return YEAR_OF_ERA;\n+    }\n+\n+    /**\n+     * Get the year of century field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType yearOfCentury() {\n+        return YEAR_OF_CENTURY;\n+    }\n+\n+    /**\n+     * Get the century of era field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType centuryOfEra() {\n+        return CENTURY_OF_ERA;\n+    }\n+\n+    /**\n+     * Get the era field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType era() {\n+        return ERA;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the name of the field.\n+     * By convention, names follow a pattern of \"dddOfRrr\", where \"ddd\" represents\n+     * the (singular) duration field name and \"Rrr\" represents the (singular)\n+     * range duration field name. If the range field is not applicable, then\n+     * the name of the field is simply the (singular) duration field name.\n+     * \n+     * @return field name\n+     */\n+    public String getName() {\n+        return iName;\n+    }\n+\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return getName();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/DurationFieldType.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Identifies a field, such as year or minutes, in a chronology-neutral way.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public class DurationFieldType implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 8765135187319L;\n+\n+    /** The cache of name to type used to ensure singletons. */\n+    private static Map cCache = new HashMap();\n+    /** The eras field. */\n+    private static final DurationFieldType ERAS = new DurationFieldType(\"eras\");\n+    /** The centuries field. */\n+    private static final DurationFieldType CENTURIES = new DurationFieldType(\"centuries\");\n+    /** The weekyears field. */\n+    private static final DurationFieldType WEEKYEARS = new DurationFieldType(\"weekyears\");\n+    /** The years field. */\n+    private static final DurationFieldType YEARS = new DurationFieldType(\"years\");\n+    /** The months field. */\n+    private static final DurationFieldType MONTHS = new DurationFieldType(\"months\");\n+    /** The weeks field. */\n+    private static final DurationFieldType WEEKS = new DurationFieldType(\"weeks\");\n+    /** The days field. */\n+    private static final DurationFieldType DAYS = new DurationFieldType(\"days\");\n+    /** The halfdays field. */\n+    private static final DurationFieldType HALFDAYS = new DurationFieldType(\"halfdays\");\n+    /** The hours field. */\n+    private static final DurationFieldType HOURS = new DurationFieldType(\"hours\");\n+    /** The minutes field. */\n+    private static final DurationFieldType MINUTES = new DurationFieldType(\"minutes\");\n+    /** The seconds field. */\n+    private static final DurationFieldType SECONDS = new DurationFieldType(\"seconds\");\n+    /** The millis field. */\n+    private static final DurationFieldType MILLIS = new DurationFieldType(\"millis\");\n+\n+    /** The name of the field. */\n+    private final String iName;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Factory method to obtain a DurationFieldType by name ensuring each\n+     * type is a singleton.\n+     * <p>\n+     * If the name is not found, an error is thrown.\n+     * \n+     * @param name  the name to retrieve\n+     * @return the singleton type\n+     */\n+    public static synchronized DurationFieldType getInstance(String name) {\n+        DurationFieldType type = (DurationFieldType) cCache.get(name);\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The field '\" + name + \"' is unknown\");\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Factory method to define a DurationFieldType by name ensuring each\n+     * type is a singleton.\n+     * <p>\n+     * This method checks to see if the name is previously defined, in which\n+     * case it returns the previously defined type object.\n+     * If the name is not found, a new type is created.\n+     * <p>\n+     * It is intended that this method is called once in your program startup\n+     * and then you use the <code>getInstance</code> method. This could be\n+     * achieved by subclassing this class.\n+     * \n+     * @param name  the name to retrieve\n+     * @return the singleton type\n+     */\n+    public static synchronized DurationFieldType define(String name) {\n+        DurationFieldType type = (DurationFieldType) cCache.get(name);\n+        if (type == null) {\n+            return new DurationFieldType(name);\n+        }\n+        return type;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     * \n+     * @param name  the name to use\n+     */\n+    private DurationFieldType(String name) {\n+        super();\n+        iName = name;\n+        cCache.put(name, this);\n+    }\n+\n+    /**\n+     * Ensure a singleton is returned.\n+     * \n+     * @return the singleton type\n+     */\n+    private Object readResolve() {\n+        return getInstance(iName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the millis field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType millis() {\n+        return MILLIS;\n+    }\n+\n+    /**\n+     * Get the seconds field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType seconds() {\n+        return SECONDS;\n+    }\n+\n+    /**\n+     * Get the minutes field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType minutes() {\n+        return MINUTES;\n+    }\n+\n+    /**\n+     * Get the hours field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType hours() {\n+        return HOURS;\n+    }\n+\n+    /**\n+     * Get the halfdays field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType halfdays() {\n+        return HALFDAYS;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the days field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType days() {\n+        return DAYS;\n+    }\n+\n+    /**\n+     * Get the weeks field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType weeks() {\n+        return WEEKS;\n+    }\n+\n+    /**\n+     * Get the weekyears field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType weekyears() {\n+        return WEEKYEARS;\n+    }\n+\n+    /**\n+     * Get the months field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType months() {\n+        return MONTHS;\n+    }\n+\n+    /**\n+     * Get the years field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType years() {\n+        return YEARS;\n+    }\n+\n+    /**\n+     * Get the centuries field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType centuries() {\n+        return CENTURIES;\n+    }\n+\n+    /**\n+     * Get the eras field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType eras() {\n+        return ERAS;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the name of the field.\n+     * By convention, names have a plural name.\n+     * \n+     * @return field name\n+     */\n+    public String getName() {\n+        return iName;\n+    }\n+\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return getName();\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/ReadableDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableDateTime.java\n public interface ReadableDateTime extends ReadableInstant {\n \n     /**\n+     * Get the value of one of the fields of a datetime.\n+     * <p>\n+     * This method uses the chronology of the datetime to obtain the value.\n+     * It is essentially a generic way of calling one of the get methods.\n+     *\n+     * @param type  a field type, usually obtained from DateTimeFieldType\n+     * @return the value of that field\n+     * @throws IllegalArgumentException if the field is null\n+     */\n+    int get(DateTimeFieldType type);\n+\n+    /**\n      * Get the day of week field value.\n      * <p>\n      * The values for the day of week are defined in {@link DateTimeConstants}.\n--- a/JodaTime/src/java/org/joda/time/ReadableInstant.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableInstant.java\n     DateTimeZone getZone();\n \n     /**\n-     * Get the value of one of the fields of a datetime.\n-     * <p>\n-     * DateTimeField instances are generally obtained from a {@link Chronology} subclass.\n-     * However, an application can create its own DateTimeField to manipulate the\n-     * date time millis in new ways.\n-     *\n-     * @param field  a DateTimeField instance, usually obtained from a Chronology\n+     * Gets a value of the specified field, which is obtained from a Chronology.\n+     * <p>\n+     * Field instances are generally obtained from a {@link Chronology}.\n+     * However, an application can create its own fields to manipulate the\n+     * datetime millis in new ways.\n+     *\n+     * @param field  a field, usually obtained from a Chronology\n      * @return the value of that field for the millis set in the implementation\n      * @throws IllegalArgumentException if the field is null\n      */\n--- a/JodaTime/src/java/org/joda/time/base/AbstractDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractDateTime.java\n \n import java.util.Locale;\n \n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.ReadableDateTime;\n import org.joda.time.format.DateTimeFormat;\n \n \n     //-----------------------------------------------------------------------\n     /**\n+     * Get the value of one of the fields of a datetime.\n+     * <p>\n+     * This method uses the chronology of the datetime to obtain the value.\n+     * It is essentially a generic way of calling one of the get methods.\n+     *\n+     * @param type  a field type, usually obtained from DateTimeFieldType\n+     * @return the value of that field\n+     * @throws IllegalArgumentException if the field is null\n+     */\n+    public int get(DateTimeFieldType type) {\n+        return getChronology().getField(type).get(getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Get the era field value.\n      * \n      * @return the era\n--- a/JodaTime/src/java/org/joda/time/chrono/BaseChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BaseChronology.java\n import java.io.Serializable;\n \n import org.joda.time.Chronology;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeZone;\n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n         }\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the field from the type.\n+     * <p>\n+     * This method obtains the <code>DateTimeField</code> for the <code>DateTimeFieldType</code>.\n+     * It is essentially a generic way of calling one of the field methods.\n+     *\n+     * @param type  a field type, usually obtained from DateTimeFieldType\n+     * @return the chronology field\n+     * @throws IllegalArgumentException if the field is null\n+     */\n+    public DateTimeField getField(DateTimeFieldType type) {\n+        if (type == DateTimeFieldType.millisOfSecond()) {\n+            return millisOfSecond();\n+        } else if (type == DateTimeFieldType.millisOfDay()) {\n+            return millisOfDay();\n+        } else if (type == DateTimeFieldType.secondOfMinute()) {\n+            return secondOfMinute();\n+        } else if (type == DateTimeFieldType.secondOfDay()) {\n+            return secondOfDay();\n+        } else if (type == DateTimeFieldType.minuteOfHour()) {\n+            return minuteOfHour();\n+        } else if (type == DateTimeFieldType.minuteOfDay()) {\n+            return minuteOfDay();\n+        } else if (type == DateTimeFieldType.hourOfDay()) {\n+            return hourOfDay();\n+        } else if (type == DateTimeFieldType.hourOfHalfday()) {\n+            return hourOfHalfday();\n+        } else if (type == DateTimeFieldType.clockhourOfDay()) {\n+            return clockhourOfDay();\n+        } else if (type == DateTimeFieldType.halfdayOfDay()) {\n+            return halfdayOfDay();\n+        } else if (type == DateTimeFieldType.clockhourOfHalfday()) {\n+            return clockhourOfHalfday();\n+        } else if (type == DateTimeFieldType.dayOfWeek()) {\n+            return dayOfWeek();\n+        } else if (type == DateTimeFieldType.dayOfMonth()) {\n+            return dayOfMonth();\n+        } else if (type == DateTimeFieldType.dayOfYear()) {\n+            return dayOfYear();\n+        } else if (type == DateTimeFieldType.weekOfWeekyear()) {\n+            return weekOfWeekyear();\n+        } else if (type == DateTimeFieldType.weekyear()) {\n+            return weekyear();\n+        } else if (type == DateTimeFieldType.monthOfYear()) {\n+            return monthOfYear();\n+        } else if (type == DateTimeFieldType.year()) {\n+            return year();\n+        } else if (type == DateTimeFieldType.yearOfEra()) {\n+            return yearOfEra();\n+        } else if (type == DateTimeFieldType.yearOfCentury()) {\n+            return yearOfCentury();\n+        } else if (type == DateTimeFieldType.centuryOfEra()) {\n+            return centuryOfEra();\n+        } else if (type == DateTimeFieldType.era()) {\n+            return era();\n+        } else {\n+            throw new IllegalArgumentException(\"Unrecognised field: \" + type);\n+        }\n+    }\n+\n     // Millis\n     //-----------------------------------------------------------------------\n     /**\n--- a/JodaTime/src/test/org/joda/time/TestDateMidnight_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateMidnight_Basics.java\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGet() {\n+    public void testGet_DateTimeField() {\n         DateMidnight test = new DateMidnight();\n         assertEquals(1, test.get(ISOChronology.getInstance().era()));\n         assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra()));\n         assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));\n         assertEquals(0, test.get(ISOChronology.getInstance().millisOfDay()));\n         try {\n-            test.get(null);\n+            test.get((DateTimeField) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testGet_DateTimeFieldType() {\n+        DateMidnight test = new DateMidnight();\n+        assertEquals(1, test.get(DateTimeFieldType.era()));\n+        assertEquals(20, test.get(DateTimeFieldType.centuryOfEra()));\n+        assertEquals(2, test.get(DateTimeFieldType.yearOfCentury()));\n+        assertEquals(2002, test.get(DateTimeFieldType.yearOfEra()));\n+        assertEquals(2002, test.get(DateTimeFieldType.year()));\n+        assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));\n+        assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));\n+        assertEquals(2002, test.get(DateTimeFieldType.weekyear()));\n+        assertEquals(23, test.get(DateTimeFieldType.weekOfWeekyear()));\n+        assertEquals(7, test.get(DateTimeFieldType.dayOfWeek()));\n+        assertEquals(160, test.get(DateTimeFieldType.dayOfYear()));\n+        assertEquals(0, test.get(DateTimeFieldType.halfdayOfDay()));\n+        assertEquals(0, test.get(DateTimeFieldType.hourOfHalfday()));\n+        assertEquals(24, test.get(DateTimeFieldType.clockhourOfDay()));\n+        assertEquals(12, test.get(DateTimeFieldType.clockhourOfHalfday()));\n+        assertEquals(0, test.get(DateTimeFieldType.hourOfDay()));\n+        assertEquals(0, test.get(DateTimeFieldType.minuteOfHour()));\n+        assertEquals(0, test.get(DateTimeFieldType.minuteOfDay()));\n+        assertEquals(0, test.get(DateTimeFieldType.secondOfMinute()));\n+        assertEquals(0, test.get(DateTimeFieldType.secondOfDay()));\n+        assertEquals(0, test.get(DateTimeFieldType.millisOfSecond()));\n+        assertEquals(0, test.get(DateTimeFieldType.millisOfDay()));\n+        try {\n+            test.get((DateTimeFieldType) null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n--- a/JodaTime/src/test/org/joda/time/TestDateTimeComparator.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateTimeComparator.java\n \n         // super.setUp();\n         // Obtain comparator's\n-        cMillis = DateTimeComparator.getInstance(null, chrono.secondOfMinute());\n-        cSecond = DateTimeComparator.getInstance(chrono.secondOfMinute(), chrono.minuteOfHour());\n-        cMinute = DateTimeComparator.getInstance(chrono.minuteOfHour(), chrono.hourOfDay());\n-        cHour = DateTimeComparator.getInstance(chrono.hourOfDay(), chrono.dayOfYear());\n-        cDayOfWeek = DateTimeComparator.getInstance(chrono.dayOfWeek(), chrono.weekOfWeekyear());\n-        cDayOfMonth = DateTimeComparator.getInstance(chrono.dayOfMonth(), chrono.monthOfYear());\n-        cDayOfYear = DateTimeComparator.getInstance(chrono.dayOfYear(), chrono.year());\n-        cWeekOfWeekyear = DateTimeComparator.getInstance(chrono.weekOfWeekyear(), chrono.weekyear());\n-        cWeekyear = DateTimeComparator.getInstance(chrono.weekyear());\n-        cMonth = DateTimeComparator.getInstance(chrono.monthOfYear(), chrono.year());\n-        cYear = DateTimeComparator.getInstance(chrono.year());\n-        cDate = DateTimeComparator.getDateOnlyInstance(chrono);\n-        cTime = DateTimeComparator.getTimeOnlyInstance(chrono);\n-    }\n+        cMillis = DateTimeComparator.getInstance(null, DateTimeFieldType.secondOfMinute());\n+        cSecond = DateTimeComparator.getInstance(DateTimeFieldType.secondOfMinute(), DateTimeFieldType.minuteOfHour());\n+        cMinute = DateTimeComparator.getInstance(DateTimeFieldType.minuteOfHour(), DateTimeFieldType.hourOfDay());\n+        cHour = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay(), DateTimeFieldType.dayOfYear());\n+        cDayOfWeek = DateTimeComparator.getInstance(DateTimeFieldType.dayOfWeek(), DateTimeFieldType.weekOfWeekyear());\n+        cDayOfMonth = DateTimeComparator.getInstance(DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear());\n+        cDayOfYear = DateTimeComparator.getInstance(DateTimeFieldType.dayOfYear(), DateTimeFieldType.year());\n+        cWeekOfWeekyear = DateTimeComparator.getInstance(DateTimeFieldType.weekOfWeekyear(), DateTimeFieldType.weekyear());\n+        cWeekyear = DateTimeComparator.getInstance(DateTimeFieldType.weekyear());\n+        cMonth = DateTimeComparator.getInstance(DateTimeFieldType.monthOfYear(), DateTimeFieldType.year());\n+        cYear = DateTimeComparator.getInstance(DateTimeFieldType.year());\n+        cDate = DateTimeComparator.getDateOnlyInstance();\n+        cTime = DateTimeComparator.getTimeOnlyInstance();\n+    }\n+\n     /**\n      * Junit <code>tearDown()</code> method.\n      */\n         assertEquals(\"DateTimeComparator[]\", c.toString());\n     }        \n     public void testStaticGetDateOnlyInstance() {\n-        DateTimeComparator c = DateTimeComparator.getDateOnlyInstance(ISO);\n-        assertEquals(ISO.dayOfYear(), c.getLowerLimit());\n+        DateTimeComparator c = DateTimeComparator.getDateOnlyInstance();\n+        assertEquals(DateTimeFieldType.dayOfYear(), c.getLowerLimit());\n         assertEquals(null, c.getUpperLimit());\n         assertEquals(\"DateTimeComparator[dayOfYear-]\", c.toString());\n         \n-        c = DateTimeComparator.getDateOnlyInstance(null);\n-        assertEquals(ISO.dayOfYear(), c.getLowerLimit());\n-        assertEquals(null, c.getUpperLimit());\n+        assertSame(DateTimeComparator.getDateOnlyInstance(), DateTimeComparator.getDateOnlyInstance());\n     }\n     public void testStaticGetTimeOnlyInstance() {\n-        DateTimeComparator c = DateTimeComparator.getTimeOnlyInstance(ISO);\n+        DateTimeComparator c = DateTimeComparator.getTimeOnlyInstance();\n         assertEquals(null, c.getLowerLimit());\n-        assertEquals(ISO.dayOfYear(), c.getUpperLimit());\n+        assertEquals(DateTimeFieldType.dayOfYear(), c.getUpperLimit());\n         assertEquals(\"DateTimeComparator[-dayOfYear]\", c.toString());\n         \n-        c = DateTimeComparator.getTimeOnlyInstance(null);\n-        assertEquals(null, c.getLowerLimit());\n-        assertEquals(ISO.dayOfYear(), c.getUpperLimit());\n+        assertSame(DateTimeComparator.getTimeOnlyInstance(), DateTimeComparator.getTimeOnlyInstance());\n     }\n     public void testStaticGetInstanceLower() {\n-        DateTimeComparator c = DateTimeComparator.getInstance(ISO.hourOfDay());\n-        assertEquals(ISO.hourOfDay(), c.getLowerLimit());\n+        DateTimeComparator c = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay());\n+        assertEquals(DateTimeFieldType.hourOfDay(), c.getLowerLimit());\n         assertEquals(null, c.getUpperLimit());\n         assertEquals(\"DateTimeComparator[hourOfDay-]\", c.toString());\n         \n         assertSame(DateTimeComparator.getInstance(), c);\n     }\n     public void testStaticGetInstanceLowerUpper() {\n-        DateTimeComparator c = DateTimeComparator.getInstance(ISO.hourOfDay(), ISO.dayOfYear());\n-        assertEquals(ISO.hourOfDay(), c.getLowerLimit());\n-        assertEquals(ISO.dayOfYear(), c.getUpperLimit());\n+        DateTimeComparator c = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay(), DateTimeFieldType.dayOfYear());\n+        assertEquals(DateTimeFieldType.hourOfDay(), c.getLowerLimit());\n+        assertEquals(DateTimeFieldType.dayOfYear(), c.getUpperLimit());\n         assertEquals(\"DateTimeComparator[hourOfDay-dayOfYear]\", c.toString());\n         \n-        c = DateTimeComparator.getInstance(ISO.hourOfDay(), ISO.hourOfDay());\n-        assertEquals(ISO.hourOfDay(), c.getLowerLimit());\n-        assertEquals(ISO.hourOfDay(), c.getUpperLimit());\n+        c = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay(), DateTimeFieldType.hourOfDay());\n+        assertEquals(DateTimeFieldType.hourOfDay(), c.getLowerLimit());\n+        assertEquals(DateTimeFieldType.hourOfDay(), c.getUpperLimit());\n         assertEquals(\"DateTimeComparator[hourOfDay]\", c.toString());\n         \n         c = DateTimeComparator.getInstance(null, null);\n         assertSame(DateTimeComparator.getInstance(), c);\n         \n-        try {\n-            DateTimeComparator.getInstance(ISO.dayOfYear(), ISO.hourOfDay());\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n+        c = DateTimeComparator.getInstance(DateTimeFieldType.dayOfYear(), null);\n+        assertSame(DateTimeComparator.getDateOnlyInstance(), c);\n+        \n+        c = DateTimeComparator.getInstance(null, DateTimeFieldType.dayOfYear());\n+        assertSame(DateTimeComparator.getTimeOnlyInstance(), c);\n     }\n     \n     //-----------------------------------------------------------------------\n         assertEquals(false, c1.equals(null));\n         assertEquals(true, c1.hashCode() == c1.hashCode());\n         \n-        DateTimeComparator c2 = DateTimeComparator.getTimeOnlyInstance(ISOChronology.getInstance());\n+        DateTimeComparator c2 = DateTimeComparator.getTimeOnlyInstance();\n         assertEquals(true, c2.equals(c2));\n         assertEquals(false, c2.equals(c1));\n         assertEquals(false, c1.equals(c2));\n         assertEquals(false, c2.equals(null));\n         assertEquals(false, c1.hashCode() == c2.hashCode());\n         \n-        DateTimeComparator c3 = DateTimeComparator.getTimeOnlyInstance(ISOChronology.getInstance());\n+        DateTimeComparator c3 = DateTimeComparator.getTimeOnlyInstance();\n         assertEquals(true, c3.equals(c3));\n         assertEquals(false, c3.equals(c1));\n         assertEquals(true, c3.equals(c2));\n         assertEquals(false, c1.hashCode() == c3.hashCode());\n         assertEquals(true, c2.hashCode() == c3.hashCode());\n         \n-        DateTimeComparator c4 = DateTimeComparator.getDateOnlyInstance(ISOChronology.getInstance());\n+        DateTimeComparator c4 = DateTimeComparator.getDateOnlyInstance();\n         assertEquals(false, c4.hashCode() == c3.hashCode());\n     }\n     \n     public void testSerialization1() throws Exception {\n         DateTimeField f = ISO.dayOfYear();\n         f.toString();\n-        DateTimeComparator c = DateTimeComparator.getInstance(ISO.hourOfDay(), ISO.dayOfYear());\n+        DateTimeComparator c = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay(), DateTimeFieldType.dayOfYear());\n         \n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         ObjectOutputStream oos = new ObjectOutputStream(baos);\n--- a/JodaTime/src/test/org/joda/time/TestDateTime_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateTime_Basics.java\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGet() {\n+    public void testGet_DateTimeField() {\n         DateTime test = new DateTime();\n         assertEquals(1, test.get(ISOChronology.getInstance().era()));\n         assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra()));\n         assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));\n         assertEquals(60 * 60 * 1000, test.get(ISOChronology.getInstance().millisOfDay()));\n         try {\n-            test.get(null);\n+            test.get((DateTimeField) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testGet_DateTimeFieldType() {\n+        DateTime test = new DateTime();\n+        assertEquals(1, test.get(DateTimeFieldType.era()));\n+        assertEquals(20, test.get(DateTimeFieldType.centuryOfEra()));\n+        assertEquals(2, test.get(DateTimeFieldType.yearOfCentury()));\n+        assertEquals(2002, test.get(DateTimeFieldType.yearOfEra()));\n+        assertEquals(2002, test.get(DateTimeFieldType.year()));\n+        assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));\n+        assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));\n+        assertEquals(2002, test.get(DateTimeFieldType.weekyear()));\n+        assertEquals(23, test.get(DateTimeFieldType.weekOfWeekyear()));\n+        assertEquals(7, test.get(DateTimeFieldType.dayOfWeek()));\n+        assertEquals(160, test.get(DateTimeFieldType.dayOfYear()));\n+        assertEquals(0, test.get(DateTimeFieldType.halfdayOfDay()));\n+        assertEquals(1, test.get(DateTimeFieldType.hourOfHalfday()));\n+        assertEquals(1, test.get(DateTimeFieldType.clockhourOfDay()));\n+        assertEquals(1, test.get(DateTimeFieldType.clockhourOfHalfday()));\n+        assertEquals(1, test.get(DateTimeFieldType.hourOfDay()));\n+        assertEquals(0, test.get(DateTimeFieldType.minuteOfHour()));\n+        assertEquals(60, test.get(DateTimeFieldType.minuteOfDay()));\n+        assertEquals(0, test.get(DateTimeFieldType.secondOfMinute()));\n+        assertEquals(60 * 60, test.get(DateTimeFieldType.secondOfDay()));\n+        assertEquals(0, test.get(DateTimeFieldType.millisOfSecond()));\n+        assertEquals(60 * 60 * 1000, test.get(DateTimeFieldType.millisOfDay()));\n+        try {\n+            test.get((DateTimeFieldType) null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n--- a/JodaTime/src/test/org/joda/time/TestMutableDateTime_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableDateTime_Basics.java\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGet() {\n+    public void testGet_DateTimeField() {\n         MutableDateTime test = new MutableDateTime();\n         assertEquals(1, test.get(ISOChronology.getInstance().era()));\n         assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra()));\n         assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));\n         assertEquals(60 * 60 * 1000, test.get(ISOChronology.getInstance().millisOfDay()));\n         try {\n-            test.get(null);\n+            test.get((DateTimeField) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testGet_DateTimeFieldType() {\n+        MutableDateTime test = new MutableDateTime();\n+        assertEquals(1, test.get(DateTimeFieldType.era()));\n+        assertEquals(20, test.get(DateTimeFieldType.centuryOfEra()));\n+        assertEquals(2, test.get(DateTimeFieldType.yearOfCentury()));\n+        assertEquals(2002, test.get(DateTimeFieldType.yearOfEra()));\n+        assertEquals(2002, test.get(DateTimeFieldType.year()));\n+        assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));\n+        assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));\n+        assertEquals(2002, test.get(DateTimeFieldType.weekyear()));\n+        assertEquals(23, test.get(DateTimeFieldType.weekOfWeekyear()));\n+        assertEquals(7, test.get(DateTimeFieldType.dayOfWeek()));\n+        assertEquals(160, test.get(DateTimeFieldType.dayOfYear()));\n+        assertEquals(0, test.get(DateTimeFieldType.halfdayOfDay()));\n+        assertEquals(1, test.get(DateTimeFieldType.hourOfHalfday()));\n+        assertEquals(1, test.get(DateTimeFieldType.clockhourOfDay()));\n+        assertEquals(1, test.get(DateTimeFieldType.clockhourOfHalfday()));\n+        assertEquals(1, test.get(DateTimeFieldType.hourOfDay()));\n+        assertEquals(0, test.get(DateTimeFieldType.minuteOfHour()));\n+        assertEquals(60, test.get(DateTimeFieldType.minuteOfDay()));\n+        assertEquals(0, test.get(DateTimeFieldType.secondOfMinute()));\n+        assertEquals(60 * 60, test.get(DateTimeFieldType.secondOfDay()));\n+        assertEquals(0, test.get(DateTimeFieldType.millisOfSecond()));\n+        assertEquals(60 * 60 * 1000, test.get(DateTimeFieldType.millisOfDay()));\n+        try {\n+            test.get((DateTimeFieldType) null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }", "timestamp": 1094157716, "metainfo": ""}