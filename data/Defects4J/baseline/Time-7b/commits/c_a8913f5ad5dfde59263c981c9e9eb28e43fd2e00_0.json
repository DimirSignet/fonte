{"sha": "a8913f5ad5dfde59263c981c9e9eb28e43fd2e00", "log": "Fix time zone later/earlier offset methods in Western hemisphere [3476684]", "commit": "\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n /*\n- *  Copyright 2001-2011 Stephen Colebourne\n+ *  Copyright 2001-2012 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n      * @return the adjusted instant millis\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n-        long before = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long after = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (before == after) {\n-            return instant;\n-        }\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? after : before);\n-    }\n+        // a bit messy, but will work in all non-pathological cases\n+        \n+        // evaluate 3 hours before and after to work out if anything is happening\n+        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n+        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\n+        long offsetBefore = getOffset(instantBefore);\n+        long offsetAfter = getOffset(instantAfter);\n+        if (offsetBefore <= offsetAfter) {\n+            return instant;  // not an overlap (less than is a gap, equal is normal case)\n+        }\n+        \n+        // work out range of instants that have duplicate local times\n+        long diff = offsetBefore - offsetAfter;\n+        long transition = nextTransition(instantBefore);\n+        long overlapStart = transition - diff;\n+        long overlapEnd = transition + diff;\n+        if (instant < overlapStart || instant >= overlapEnd) {\n+          return instant;  // not an overlap\n+        }\n+        \n+        // calculate result\n+        long afterStart = instant - overlapStart;\n+        if (afterStart >= diff) {\n+          // currently in later offset\n+          return earlierOrLater ? instant : instant - diff;\n+        } else {\n+          // currently in earlier offset\n+          return earlierOrLater ? instant + diff : instant;\n+        }\n+    }\n+//    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + \" \" + new DateTime(transitionStart, this));\n \n     //-----------------------------------------------------------------------\n     /**\n--- a/src/test/java/org/joda/time/TestDateTimeZoneCutover.java\n+++ b/src/test/java/org/joda/time/TestDateTimeZoneCutover.java\n /*\n- *  Copyright 2001-2007 Stephen Colebourne\n+ *  Copyright 2001-2012 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n         assertEquals(baseAfter.toString(), testAfter.toString());\n     }\n \n+    //-------------------------------------------------------------------------\n     public void testBug3192457_adjustOffset() {\n         final DateTimeZone zone = DateTimeZone.forID(\"Europe/Paris\");\n         DateTime base = new DateTime(2007, 10, 28, 3, 15, zone);\n         \n         assertSame(base, base.withEarlierOffsetAtOverlap());\n         assertSame(base, base.withLaterOffsetAtOverlap());\n+        \n         assertSame(baseBefore, baseBefore.withEarlierOffsetAtOverlap());\n+        assertEquals(baseAfter, baseBefore.withLaterOffsetAtOverlap());\n+        \n         assertSame(baseAfter, baseAfter.withLaterOffsetAtOverlap());\n-        \n         assertEquals(baseBefore, baseAfter.withEarlierOffsetAtOverlap());\n-        assertEquals(baseAfter, baseAfter.withLaterOffsetAtOverlap());\n-    }\n+    }\n+\n+    public void testBug3476684_adjustOffset() {\n+        final DateTimeZone zone = DateTimeZone.forID(\"America/Sao_Paulo\");\n+        DateTime base = new DateTime(2012, 2, 25, 22, 15, zone);\n+        DateTime baseBefore = base.plusHours(1);  // 23:15 (first)\n+        DateTime baseAfter = base.plusHours(2);  // 23:15 (second)\n+        \n+        assertSame(base, base.withEarlierOffsetAtOverlap());\n+        assertSame(base, base.withLaterOffsetAtOverlap());\n+        \n+        assertSame(baseBefore, baseBefore.withEarlierOffsetAtOverlap());\n+        assertEquals(baseAfter, baseBefore.withLaterOffsetAtOverlap());\n+        \n+        assertSame(baseAfter, baseAfter.withLaterOffsetAtOverlap());\n+        assertEquals(baseBefore, baseAfter.withEarlierOffsetAtOverlap());\n+    }\n+\n+    public void testBug3476684_adjustOffset_springGap() {\n+      final DateTimeZone zone = DateTimeZone.forID(\"America/Sao_Paulo\");\n+      DateTime base = new DateTime(2011, 10, 15, 22, 15, zone);\n+      DateTime baseBefore = base.plusHours(1);  // 23:15\n+      DateTime baseAfter = base.plusHours(2);  // 01:15\n+      \n+      assertSame(base, base.withEarlierOffsetAtOverlap());\n+      assertSame(base, base.withLaterOffsetAtOverlap());\n+      \n+      assertSame(baseBefore, baseBefore.withEarlierOffsetAtOverlap());\n+      assertEquals(baseBefore, baseBefore.withLaterOffsetAtOverlap());\n+      \n+      assertSame(baseAfter, baseAfter.withLaterOffsetAtOverlap());\n+      assertEquals(baseAfter, baseAfter.withEarlierOffsetAtOverlap());\n+  }\n \n     // ensure Summer time picked\n     //-----------------------------------------------------------------------", "timestamp": 1328188176, "metainfo": ""}