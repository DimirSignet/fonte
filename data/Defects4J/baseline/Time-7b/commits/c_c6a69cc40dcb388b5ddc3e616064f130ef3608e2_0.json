{"sha": "c6a69cc40dcb388b5ddc3e616064f130ef3608e2", "log": "Refactor DateTimeParserBucket to inner class to aid package comprehension   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/BaseDateTimeFormatter.java\n+++ b/JodaTime/src/java/org/joda/time/format/BaseDateTimeFormatter.java\n \n import java.io.IOException;\n import java.io.Writer;\n+import java.util.Arrays;\n+import java.util.Locale;\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n import org.joda.time.MutableDateTime;\n         Chronology chrono = instant.getChronology();\n         long instantLocal = millis + chrono.getZone().getOffset(millis);\n \n-        DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono);\n+        ParseBucket bucket = new ParseBucket(instantLocal, chrono);\n         int resultPos = parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis());\n         return resultPos;\n     }\n \n     public long parseMillis(String text, Chronology chrono) {\n-        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono);\n+        ParseBucket bucket = new ParseBucket(0, chrono);\n \n         int newPos = parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n     public long parseMillis(String text, long instant, Chronology chrono) {\n         chrono = DateTimeUtils.getChronology(chrono);\n         long instantLocal = instant + chrono.getZone().getOffset(instant);\n-        DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono);\n+        ParseBucket bucket = new ParseBucket(instantLocal, chrono);\n \n         int newPos = parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n         throw new UnsupportedOperationException(\"Parsing not supported\");\n     }\n \n-    protected int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+    protected int parseInto(ParseBucket bucket, String text, int position) {\n         throw new UnsupportedOperationException(\"Parsing not supported\");\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Internal class used to build the state during parsing.\n+     * <p>\n+     * Allows fields to be saved in any order, but be physically set in a\n+     * consistent order. This is useful for parsing against formats that allow\n+     * field values to contradict each other.\n+     * <p>\n+     * Field values are applied in an order where the \"larger\" fields are set\n+     * first, making their value less likely to stick.  A field is larger than\n+     * another when it's range duration is longer. If both ranges are the same,\n+     * then the larger field has the longer duration. If it cannot be determined\n+     * which field is larger, then the fields are set in the order they were saved.\n+     * <p>\n+     * For example, these fields were saved in this order: dayOfWeek, monthOfYear,\n+     * dayOfMonth, dayOfYear. When computeMillis is called, the fields are set in\n+     * this order: monthOfYear, dayOfYear, dayOfMonth, dayOfWeek.\n+     * <p>\n+     * ParseBucket is mutable and not thread-safe.\n+     *\n+     * @author Brian S O'Neill\n+     * @since 1.0\n+     */\n+    public static class ParseBucket {\n+\n+        private final Chronology iChrono;\n+        private final long iMillis;\n+\n+        // TimeZone to switch to in computeMillis. If null, use offset.\n+        DateTimeZone iZone;\n+        int iOffset;\n+\n+        SavedField[] iSavedFields = new SavedField[8];\n+        int iSavedFieldsCount;\n+        boolean iSavedFieldsShared;\n+\n+        private Object iSavedState;\n+\n+        /**\n+         * Constucts a bucket.\n+         * \n+         * @param instantLocal the initial millis from 1970-01-01T00:00:00, local time\n+         * @param chrono  the chronology to use\n+         */\n+        public ParseBucket(long instantLocal, Chronology chrono) {\n+            super();\n+            chrono = DateTimeUtils.getChronology(chrono);\n+            iMillis = instantLocal;\n+            iChrono = chrono.withUTC();\n+            setZone(chrono.getZone());\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Gets the chronology of the bucket, which will be a local (UTC) chronology.\n+         */\n+        public Chronology getChronology() {\n+            return iChrono;\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Returns the time zone used by computeMillis, or null if an offset is\n+         * used instead.\n+         */\n+        public DateTimeZone getZone() {\n+            return iZone;\n+        }\n+\n+        /**\n+         * Set a time zone to be used when computeMillis is called, which\n+         * overrides any set time zone offset.\n+         *\n+         * @param zone the date time zone to operate in, or null if UTC\n+         */\n+        public void setZone(DateTimeZone zone) {\n+            iSavedState = null;\n+            iZone = zone == DateTimeZone.UTC ? null : zone;\n+            iOffset = 0;\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Returns the time zone offset used by computeMillis, unless\n+         * getZone doesn't return null.\n+         */\n+        public int getOffset() {\n+            return iOffset;\n+        }\n+\n+        /**\n+         * Set a time zone offset to be used when computeMillis is called, which\n+         * overrides the time zone.\n+         */\n+        public void setOffset(int offset) {\n+            iSavedState = null;\n+            iOffset = offset;\n+            iZone = null;\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Saves a datetime field value.\n+         * \n+         * @param field  the field, whose chronology must match that of this bucket\n+         * @param value  the value\n+         */\n+        public void saveField(DateTimeField field, int value) {\n+            saveField(new SavedField(field, value));\n+        }\n+\n+        /**\n+         * Saves a datetime field value.\n+         * \n+         * @param fieldType  the field type\n+         * @param value  the value\n+         */\n+        public void saveField(DateTimeFieldType fieldType, int value) {\n+            saveField(new SavedField(fieldType.getField(iChrono), value));\n+        }\n+\n+        /**\n+         * Saves a datetime field text value.\n+         * \n+         * @param fieldType  the field type\n+         * @param text  the text value\n+         * @param locale  the locale to use\n+         */\n+        public void saveField(DateTimeFieldType fieldType, String text, Locale locale) {\n+            saveField(new SavedField(fieldType.getField(iChrono), text, locale));\n+        }\n+\n+        private void saveField(SavedField field) {\n+            SavedField[] savedFields = iSavedFields;\n+            int savedFieldsCount = iSavedFieldsCount;\n+\n+            if (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\n+                // Expand capacity or merely copy if saved fields are shared.\n+                SavedField[] newArray = new SavedField\n+                    [savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length];\n+                System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount);\n+                iSavedFields = savedFields = newArray;\n+                iSavedFieldsShared = false;\n+            }\n+\n+            iSavedState = null;\n+            savedFields[savedFieldsCount] = field;\n+            iSavedFieldsCount = savedFieldsCount + 1;\n+        }\n+\n+        /**\n+         * Saves the state of this bucket, returning it in an opaque object. Call\n+         * restoreState to undo any changes that were made since the state was\n+         * saved. Calls to saveState may be nested.\n+         *\n+         * @return opaque saved state, which may be passed to restoreState\n+         */\n+        public Object saveState() {\n+            if (iSavedState == null) {\n+                iSavedState = new SavedState();\n+            }\n+            return iSavedState;\n+        }\n+\n+        /**\n+         * Restores the state of this bucket from a previously saved state. The\n+         * state object passed into this method is not consumed, and it can be used\n+         * later to restore to that state again.\n+         *\n+         * @param savedState opaque saved state, returned from saveState\n+         * @return true state object is valid and state restored\n+         */\n+        public boolean restoreState(Object savedState) {\n+            if (savedState instanceof SavedState) {\n+                if (((SavedState) savedState).restoreState(this)) {\n+                    iSavedState = savedState;\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        /**\n+         * Computes the parsed datetime by setting the saved fields.\n+         * This method is idempotent, but it is not thread-safe.\n+         *\n+         * @return milliseconds since 1970-01-01T00:00:00Z\n+         * @throws IllegalArgumentException if any field is out of range\n+         */\n+        public long computeMillis() {\n+            return computeMillis(false);\n+        }\n+\n+        /**\n+         * Computes the parsed datetime by setting the saved fields.\n+         * This method is idempotent, but it is not thread-safe.\n+         *\n+         * @param resetFields false by default, but when true, unsaved field values are cleared\n+         * @return milliseconds since 1970-01-01T00:00:00Z\n+         * @throws IllegalArgumentException if any field is out of range\n+         */\n+        public long computeMillis(boolean resetFields) {\n+            SavedField[] savedFields = iSavedFields;\n+            int count = iSavedFieldsCount;\n+            if (iSavedFieldsShared) {\n+                iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n+                iSavedFieldsShared = false;\n+            }\n+            sort(savedFields, count);\n+\n+            long millis = iMillis;\n+            for (int i=0; i<count; i++) {\n+                millis = savedFields[i].set(millis, resetFields);\n+            }\n+\n+            if (iZone == null) {\n+                millis -= iOffset;\n+            } else {\n+                int offset = iZone.getOffsetFromLocal(millis);\n+                millis -= offset;\n+                if (offset != iZone.getOffset(millis)) {\n+                    throw new IllegalArgumentException\n+                        (\"Illegal instant due to time zone offset transition\");\n+                }\n+            }\n+\n+            return millis;\n+        }\n+\n+        /**\n+         * Sorts elements [0,high). Calling java.util.Arrays isn't always the right\n+         * choice since it always creates an internal copy of the array, even if it\n+         * doesn't need to. If the array slice is small enough, an insertion sort\n+         * is chosen instead, but it doesn't need a copy!\n+         * <p>\n+         * This method has a modified version of that insertion sort, except it\n+         * doesn't create an unnecessary array copy. If high is over 10, then\n+         * java.util.Arrays is called, which will perform a merge sort, which is\n+         * faster than insertion sort on large lists.\n+         * <p>\n+         * The end result is much greater performace when computeMillis is called.\n+         * Since the amount of saved fields is small, the insertion sort is a\n+         * better choice. Additional performance is gained since there is no extra\n+         * array allocation and copying. Also, the insertion sort here does not\n+         * perform any casting operations. The version in java.util.Arrays performs\n+         * casts within the insertion sort loop.\n+         */\n+        private static void sort(Comparable[] array, int high) {\n+            if (high > 10) {\n+                Arrays.sort(array, 0, high);\n+            } else {\n+                for (int i=0; i<high; i++) {\n+                    for (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\n+                        Comparable t = array[j];\n+                        array[j] = array[j-1];\n+                        array[j-1] = t;\n+                    }\n+                }\n+            }\n+        }\n+\n+        class SavedState {\n+            final DateTimeZone iZone;\n+            final int iOffset;\n+            final SavedField[] iSavedFields;\n+            final int iSavedFieldsCount;\n+\n+            SavedState() {\n+                this.iZone = ParseBucket.this.iZone;\n+                this.iOffset = ParseBucket.this.iOffset;\n+                this.iSavedFields = ParseBucket.this.iSavedFields;\n+                this.iSavedFieldsCount = ParseBucket.this.iSavedFieldsCount;\n+            }\n+\n+            boolean restoreState(ParseBucket enclosing) {\n+                if (enclosing != ParseBucket.this) {\n+                    return false;\n+                }\n+                enclosing.iZone = this.iZone;\n+                enclosing.iOffset = this.iOffset;\n+                enclosing.iSavedFields = this.iSavedFields;\n+                if (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) {\n+                    // Since count is being restored to a lower count, the\n+                    // potential exists for new saved fields to destroy data being\n+                    // shared by another state. Set this flag such that the array\n+                    // of saved fields is cloned prior to modification.\n+                    enclosing.iSavedFieldsShared = true;\n+                }\n+                enclosing.iSavedFieldsCount = this.iSavedFieldsCount;\n+                return true;\n+            }\n+        }\n+\n+        static class SavedField implements Comparable {\n+            final DateTimeField iField;\n+            final int iValue;\n+            final String iText;\n+            final Locale iLocale;\n+\n+            SavedField(DateTimeField field, int value) {\n+                iField = field;\n+                iValue = value;\n+                iText = null;\n+                iLocale = null;\n+            }\n+\n+            SavedField(DateTimeField field, String text, Locale locale) {\n+                iField = field;\n+                iValue = 0;\n+                iText = text;\n+                iLocale = locale;\n+            }\n+\n+            long set(long millis, boolean reset) {\n+                if (iText == null) {\n+                    millis = iField.set(millis, iValue);\n+                } else {\n+                    millis = iField.set(millis, iText, iLocale);\n+                }\n+                if (reset) {\n+                    millis = iField.roundFloor(millis);\n+                }\n+                return millis;\n+            }\n+\n+            /**\n+             * The field with the longer range duration is ordered first, where\n+             * null is considered infinite. If the ranges match, then the field\n+             * with the longer duration is ordered first.\n+             */\n+            public int compareTo(Object obj) {\n+                DateTimeField other = ((SavedField)obj).iField;\n+                int result = compareReverse\n+                    (iField.getRangeDurationField(), other.getRangeDurationField());\n+                if (result != 0) {\n+                    return result;\n+                }\n+                return compareReverse\n+                    (iField.getDurationField(), other.getDurationField());\n+            }\n+\n+            private int compareReverse(Comparable a, Comparable b) {\n+                if (a == null) {\n+                    if (b == null) {\n+                        return 0;\n+                    }\n+                    return -1;\n+                }\n+                if (b == null) {\n+                    return 1;\n+                }\n+                return -a.compareTo(b);\n+            }\n+        }\n+    }\n+\n }\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n             return 1;\n         }\n \n-        protected int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+        protected int parseInto(ParseBucket bucket, String text, int position) {\n             if (position >= text.length()) {\n                 return ~position;\n             }\n             return iValue.length();\n         }\n \n-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+        public int parseInto(ParseBucket bucket, String text, int position) {\n             if (text.regionMatches(true, position, iValue, 0, iValue.length())) {\n                 return position + iValue.length();\n             }\n             return iMaxParsedDigits;\n         }\n \n-        protected int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+        protected int parseInto(ParseBucket bucket, String text, int position) {\n             int limit = Math.min(iMaxParsedDigits, text.length() - position);\n \n             boolean negative = false;\n             return 2;\n         }\n \n-        protected int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+        protected int parseInto(ParseBucket bucket, String text, int position) {\n             int limit = Math.min(2, text.length() - position);\n             if (limit < 2) {\n                 return ~position;\n             return estimatePrintedLength();\n         }\n \n-        protected int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+        protected int parseInto(ParseBucket bucket, String text, int position) {\n             int limit = text.length();\n             int i = position;\n             for (; i<limit; i++) {\n             return iMaxDigits;\n         }\n \n-        protected int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+        protected int parseInto(ParseBucket bucket, String text, int position) {\n             DateTimeField field = iFieldType.getField(bucket.getChronology());\n             \n             int limit = Math.min(iMaxDigits, text.length() - position);\n             return estimatePrintedLength();\n         }\n \n-        protected int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+        protected int parseInto(ParseBucket bucket, String text, int position) {\n             int limit = text.length() - position;\n \n             zeroOffset:\n             return iParsedLengthEstimate;\n         }\n \n-        protected int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+        protected int parseInto(ParseBucket bucket, String text, int position) {\n             BaseDateTimeFormatter[] elements = iParsers;\n             if (elements == null) {\n                 throw new UnsupportedOperationException();\n             return iParsedLengthEstimate;\n         }\n \n-        protected int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+        protected int parseInto(ParseBucket bucket, String text, int position) {\n             BaseDateTimeFormatter[] parsers = iParsers;\n             int length = parsers.length;\n ", "timestamp": 1099005551, "metainfo": ""}