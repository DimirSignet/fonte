{"sha": "260472337ce9d54d76074a4d400241813b4676d2", "log": "Make YearMonthDay and TimeOfDay implement Comparable   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/TimeOfDay.java\n+++ b/JodaTime/src/java/org/joda/time/TimeOfDay.java\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Is this TimeOfDay later than the specified TimeOfDay.\n+     * <p>\n+     * You may not pass null into this method. This is because you need\n+     * a time zone to accurately determine the current time.\n+     *\n+     * @param time  a time to check against, null means now\n+     * @return true if this time is after the time passed in\n+     * @throws IllegalArgumentException if the specified TimeOfDay is null\n+     */\n+    public boolean isAfter(TimeOfDay time) {\n+        if (time == null) {\n+            throw new IllegalArgumentException(\"TimeOfDay cannot be null\");\n+        }\n+        return super.compareTo(time) > 0;\n+    }\n+\n+    /**\n+     * Is this TimeOfDay earlier than the specified TimeOfDay.\n+     * <p>\n+     * You may not pass null into this method. This is because you need\n+     * a time zone to accurately determine the current time.\n+     *\n+     * @param time  a time to check against, null means now\n+     * @return true if this time is before the time passed in\n+     * @throws IllegalArgumentException if the specified TimeOfDay is null\n+     */\n+    public boolean isBefore(TimeOfDay time) {\n+        if (time == null) {\n+            throw new IllegalArgumentException(\"TimeOfDay cannot be null\");\n+        }\n+        return super.compareTo(time) < 0;\n+    }\n+\n+    /**\n+     * Is this TimeOfDay the same as the specified TimeOfDay.\n+     * <p>\n+     * You may not pass null into this method. This is because you need\n+     * a time zone to accurately determine the current time.\n+     *\n+     * @param time  a time to check against, null means now\n+     * @return true if this time is the same as the time passed in\n+     * @throws IllegalArgumentException if the specified TimeOfDay is null\n+     */\n+    public boolean isEqual(TimeOfDay time) {\n+        if (time == null) {\n+            throw new IllegalArgumentException(\"TimeOfDay cannot be null\");\n+        }\n+        return super.compareTo(time) == 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Output the time in the ISO8601 format THH:mm:ss.SSS.\n      * \n      * @return ISO8601 formatted string\n--- a/JodaTime/src/java/org/joda/time/YearMonthDay.java\n+++ b/JodaTime/src/java/org/joda/time/YearMonthDay.java\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Is this YearMonthDay later than the specified YearMonthDay.\n+     * <p>\n+     * You may not pass null into this method. This is because you need\n+     * a time zone to accurately determine the current date.\n+     *\n+     * @param date  an date to check against, null means now\n+     * @return true if this date is after the date passed in\n+     * @throws IllegalArgumentException if the specified YearMonthDay is null\n+     */\n+    public boolean isAfter(YearMonthDay date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"YearMonthDay cannot be null\");\n+        }\n+        return super.compareTo(date) > 0;\n+    }\n+\n+    /**\n+     * Is this YearMonthDay earlier than the specified YearMonthDay.\n+     * <p>\n+     * You may not pass null into this method. This is because you need\n+     * a time zone to accurately determine the current date.\n+     *\n+     * @param date  an date to check against, null means now\n+     * @return true if this date is before the date passed in\n+     * @throws IllegalArgumentException if the specified YearMonthDay is null\n+     */\n+    public boolean isBefore(YearMonthDay date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"YearMonthDay cannot be null\");\n+        }\n+        return super.compareTo(date) < 0;\n+    }\n+\n+    /**\n+     * Is this YearMonthDay the same as the specified YearMonthDay.\n+     * <p>\n+     * You may not pass null into this method. This is because you need\n+     * a time zone to accurately determine the current date.\n+     *\n+     * @param date  an date to check against, null means now\n+     * @return true if this date is the same as the date passed in\n+     * @throws IllegalArgumentException if the specified YearMonthDay is null\n+     */\n+    public boolean isEqual(YearMonthDay date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"YearMonthDay cannot be null\");\n+        }\n+        return super.compareTo(date) == 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Output the date in the ISO8601 format YYYY-MM-DD.\n      * \n      * @return ISO8601 formatted string\n--- a/JodaTime/src/java/org/joda/time/base/BasePartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/BasePartial.java\n  */\n public abstract class BasePartial\n         extends AbstractPartial\n-        implements ReadablePartial, Serializable {\n+        implements ReadablePartial, Comparable, Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 2353678632973660L;\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Compares this ReadablePartial with another returning an integer\n+     * indicating the order.\n+     * <p>\n+     * The specified object must be a ReadablePartial whose field types\n+     * match those of this partial. Normally that means that the partials\n+     * must be the same class.\n+     *\n+     * @param partial  an object to check against\n+     * @return negative if this is less, zero if equal, positive if greater\n+     * @throws ClassCastException if the partial is the wrong class\n+     *  or if it has field types that don't match\n+     * @throws NullPointerException if the partial is null\n+     */\n+    public int compareTo(Object partial) {\n+        if (this == partial) {\n+            return 0;\n+        }\n+        ReadablePartial other = (ReadablePartial) partial;\n+        if (size() != other.size()) {\n+            throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n+        }\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getFieldType(i) != other.getFieldType(i)) {\n+                throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n+            }\n+        }\n+        // fields are ordered largest first\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getValue(i) > other.getValue(i)) {\n+                return 1;\n+            }\n+            if (getValue(i) < other.getValue(i)) {\n+                return -1;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Output the date using the specified format pattern.\n      *\n      * @param pattern  the pattern specification, null means use <code>toString</code>\n--- a/JodaTime/src/test/org/joda/time/TestTimeOfDay_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestTimeOfDay_Basics.java\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.util.Arrays;\n+import java.util.Date;\n import java.util.Locale;\n-\n-import org.joda.time.chrono.BuddhistChronology;\n \n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.BuddhistChronology;\n+import org.joda.time.chrono.GregorianChronology;\n \n /**\n  * This class is a Junit unit test for TimeOfDay.\n         }\n     }\n \n+    //-----------------------------------------------------------------------\n+    public void testCompareTo() {\n+        TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay test1a = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(0, test1.compareTo(test1a));\n+        assertEquals(0, test1a.compareTo(test1));\n+        assertEquals(0, test1.compareTo(test1));\n+        assertEquals(0, test1a.compareTo(test1a));\n+        \n+        TimeOfDay test2 = new TimeOfDay(10, 20, 35, 40);\n+        assertEquals(-1, test1.compareTo(test2));\n+        assertEquals(+1, test2.compareTo(test1));\n+        \n+        TimeOfDay test3 = new TimeOfDay(10, 20, 35, 40, GregorianChronology.getInstanceUTC());\n+        assertEquals(-1, test1.compareTo(test3));\n+        assertEquals(+1, test3.compareTo(test1));\n+        assertEquals(0, test3.compareTo(test2));\n+        \n+        assertEquals(+1, test2.compareTo(new MockInstant()));\n+        assertEquals(0, test1.compareTo(new MockInstant()));\n+        \n+        try {\n+            test1.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            test1.compareTo(new Date());\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsEqual_TOD() {\n+        TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay test1a = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(true, test1.isEqual(test1a));\n+        assertEquals(true, test1a.isEqual(test1));\n+        assertEquals(true, test1.isEqual(test1));\n+        assertEquals(true, test1a.isEqual(test1a));\n+        \n+        TimeOfDay test2 = new TimeOfDay(10, 20, 35, 40);\n+        assertEquals(false, test1.isEqual(test2));\n+        assertEquals(false, test2.isEqual(test1));\n+        \n+        TimeOfDay test3 = new TimeOfDay(10, 20, 35, 40, GregorianChronology.getInstanceUTC());\n+        assertEquals(false, test1.isEqual(test3));\n+        assertEquals(false, test3.isEqual(test1));\n+        assertEquals(true, test3.isEqual(test2));\n+        \n+        try {\n+            new TimeOfDay(10, 20, 35, 40).isEqual(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsBefore_TOD() {\n+        TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay test1a = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(false, test1.isBefore(test1a));\n+        assertEquals(false, test1a.isBefore(test1));\n+        assertEquals(false, test1.isBefore(test1));\n+        assertEquals(false, test1a.isBefore(test1a));\n+        \n+        TimeOfDay test2 = new TimeOfDay(10, 20, 35, 40);\n+        assertEquals(true, test1.isBefore(test2));\n+        assertEquals(false, test2.isBefore(test1));\n+        \n+        TimeOfDay test3 = new TimeOfDay(10, 20, 35, 40, GregorianChronology.getInstanceUTC());\n+        assertEquals(true, test1.isBefore(test3));\n+        assertEquals(false, test3.isBefore(test1));\n+        assertEquals(false, test3.isBefore(test2));\n+        \n+        try {\n+            new TimeOfDay(10, 20, 35, 40).isBefore(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAfter_TOD() {\n+        TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay test1a = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(false, test1.isAfter(test1a));\n+        assertEquals(false, test1a.isAfter(test1));\n+        assertEquals(false, test1.isAfter(test1));\n+        assertEquals(false, test1a.isAfter(test1a));\n+        \n+        TimeOfDay test2 = new TimeOfDay(10, 20, 35, 40);\n+        assertEquals(false, test1.isAfter(test2));\n+        assertEquals(true, test2.isAfter(test1));\n+        \n+        TimeOfDay test3 = new TimeOfDay(10, 20, 35, 40, GregorianChronology.getInstanceUTC());\n+        assertEquals(false, test1.isAfter(test3));\n+        assertEquals(true, test3.isAfter(test1));\n+        assertEquals(false, test3.isAfter(test2));\n+        \n+        try {\n+            new TimeOfDay(10, 20, 35, 40).isAfter(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n     //-----------------------------------------------------------------------\n     public void testWithChronologyRetainFields_Chrono() {\n         TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);\n--- a/JodaTime/src/test/org/joda/time/TestYearMonthDay_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestYearMonthDay_Basics.java\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.util.Arrays;\n+import java.util.Date;\n import java.util.Locale;\n-\n-import org.joda.time.chrono.BuddhistChronology;\n \n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.BuddhistChronology;\n+import org.joda.time.chrono.GregorianChronology;\n \n /**\n  * This class is a Junit unit test for YearMonthDay.\n     }\n \n     //-----------------------------------------------------------------------\n+    public void testCompareTo() {\n+        YearMonthDay test1 = new YearMonthDay(2005, 6, 2);\n+        YearMonthDay test1a = new YearMonthDay(2005, 6, 2);\n+        assertEquals(0, test1.compareTo(test1a));\n+        assertEquals(0, test1a.compareTo(test1));\n+        assertEquals(0, test1.compareTo(test1));\n+        assertEquals(0, test1a.compareTo(test1a));\n+        \n+        YearMonthDay test2 = new YearMonthDay(2005, 7, 2);\n+        assertEquals(-1, test1.compareTo(test2));\n+        assertEquals(+1, test2.compareTo(test1));\n+        \n+        YearMonthDay test3 = new YearMonthDay(2005, 7, 2, GregorianChronology.getInstanceUTC());\n+        assertEquals(-1, test1.compareTo(test3));\n+        assertEquals(+1, test3.compareTo(test1));\n+        assertEquals(0, test3.compareTo(test2));\n+        \n+        assertEquals(+1, test2.compareTo(new MockInstant()));\n+        assertEquals(0, new YearMonthDay(1970, 6, 9).compareTo(new MockInstant()));\n+        \n+        try {\n+            test1.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            test1.compareTo(new Date());\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsEqual_YMD() {\n+        YearMonthDay test1 = new YearMonthDay(2005, 6, 2);\n+        YearMonthDay test1a = new YearMonthDay(2005, 6, 2);\n+        assertEquals(true, test1.isEqual(test1a));\n+        assertEquals(true, test1a.isEqual(test1));\n+        assertEquals(true, test1.isEqual(test1));\n+        assertEquals(true, test1a.isEqual(test1a));\n+        \n+        YearMonthDay test2 = new YearMonthDay(2005, 7, 2);\n+        assertEquals(false, test1.isEqual(test2));\n+        assertEquals(false, test2.isEqual(test1));\n+        \n+        YearMonthDay test3 = new YearMonthDay(2005, 7, 2, GregorianChronology.getInstanceUTC());\n+        assertEquals(false, test1.isEqual(test3));\n+        assertEquals(false, test3.isEqual(test1));\n+        assertEquals(true, test3.isEqual(test2));\n+        \n+        try {\n+            new YearMonthDay(2005, 7, 2).isEqual(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsBefore_YMD() {\n+        YearMonthDay test1 = new YearMonthDay(2005, 6, 2);\n+        YearMonthDay test1a = new YearMonthDay(2005, 6, 2);\n+        assertEquals(false, test1.isBefore(test1a));\n+        assertEquals(false, test1a.isBefore(test1));\n+        assertEquals(false, test1.isBefore(test1));\n+        assertEquals(false, test1a.isBefore(test1a));\n+        \n+        YearMonthDay test2 = new YearMonthDay(2005, 7, 2);\n+        assertEquals(true, test1.isBefore(test2));\n+        assertEquals(false, test2.isBefore(test1));\n+        \n+        YearMonthDay test3 = new YearMonthDay(2005, 7, 2, GregorianChronology.getInstanceUTC());\n+        assertEquals(true, test1.isBefore(test3));\n+        assertEquals(false, test3.isBefore(test1));\n+        assertEquals(false, test3.isBefore(test2));\n+        \n+        try {\n+            new YearMonthDay(2005, 7, 2).isBefore(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAfter_YMD() {\n+        YearMonthDay test1 = new YearMonthDay(2005, 6, 2);\n+        YearMonthDay test1a = new YearMonthDay(2005, 6, 2);\n+        assertEquals(false, test1.isAfter(test1a));\n+        assertEquals(false, test1a.isAfter(test1));\n+        assertEquals(false, test1.isAfter(test1));\n+        assertEquals(false, test1a.isAfter(test1a));\n+        \n+        YearMonthDay test2 = new YearMonthDay(2005, 7, 2);\n+        assertEquals(false, test1.isAfter(test2));\n+        assertEquals(true, test2.isAfter(test1));\n+        \n+        YearMonthDay test3 = new YearMonthDay(2005, 7, 2, GregorianChronology.getInstanceUTC());\n+        assertEquals(false, test1.isAfter(test3));\n+        assertEquals(true, test3.isAfter(test1));\n+        assertEquals(false, test3.isAfter(test2));\n+        \n+        try {\n+            new YearMonthDay(2005, 7, 2).isAfter(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n     public void testWithChronologyRetainFields_Chrono() {\n         YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n         YearMonthDay test = base.withChronologyRetainFields(BUDDHIST_TOKYO);", "timestamp": 1113669875, "metainfo": ""}