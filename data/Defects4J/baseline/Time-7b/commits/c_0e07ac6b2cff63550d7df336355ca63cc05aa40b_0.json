{"sha": "0e07ac6b2cff63550d7df336355ca63cc05aa40b", "log": "Move from Joda CVS   ", "commit": "\n--- a/JodaTime/src/example/org/joda/example/time/AgeCalculator.java\n+++ b/JodaTime/src/example/org/joda/example/time/AgeCalculator.java\n import java.awt.event.ActionListener;\n import java.awt.event.ItemEvent;\n import java.awt.event.ItemListener;\n-import java.text.ParseException;\n \n import javax.swing.BorderFactory;\n import javax.swing.Box;\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n-import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n import org.joda.time.chrono.iso.ISOChronology;\n \n /**\n  */\n public class AgeCalculator extends JFrame {\n     static final int\n-        YEAR = 1,\n-        MONTH_OF_YEAR = 2,\n-        DAY_OF_MONTH = 3,\n-        WEEKYEAR = 4,\n-        WEEK_OF_WEEKYEAR = 5,\n-        DAY_OF_WEEK = 6,\n-        HOUR_OF_DAY = 101,\n-        MINUTE_OF_HOUR = 102,\n-        SECOND_OF_MINUTE = 103;\n+        YEARS = 1,\n+        MONTHS = 2,\n+        DAYS = 3,\n+        WEEKYEARS = 4,\n+        WEEKS = 5,\n+        HOURS = 101,\n+        MINUTES = 102,\n+        SECONDS = 103;\n \n     public static void main(String[] args) throws Exception {\n         new AgeCalculator().show();\n \n         iFieldSets = new FieldSet[] {\n             new FieldSet(\"Month Based\", new FieldGroup[] {\n-                new FieldGroup(listener, \"Years\", YEAR),\n-                new FieldGroup(listener, \"Months\", MONTH_OF_YEAR),\n-                new FieldGroup(listener, \"Days\", DAY_OF_MONTH),\n-                new FieldGroup(listener, \"Hours\", HOUR_OF_DAY),\n-                new FieldGroup(listener, \"Minutes\", MINUTE_OF_HOUR),\n-                new FieldGroup(listener, \"Seconds\", SECOND_OF_MINUTE)\n+                new FieldGroup(listener, \"Years\", YEARS),\n+                new FieldGroup(listener, \"Months\", MONTHS),\n+                new FieldGroup(listener, \"Days\", DAYS),\n+                new FieldGroup(listener, \"Hours\", HOURS),\n+                new FieldGroup(listener, \"Minutes\", MINUTES),\n+                new FieldGroup(listener, \"Seconds\", SECONDS)\n             })\n             ,\n             new FieldSet(\"Week Based\", new FieldGroup[] {\n-                new FieldGroup(listener, \"Weekyears\", WEEKYEAR),\n-                new FieldGroup(listener, \"Weeks\", WEEK_OF_WEEKYEAR),\n-                new FieldGroup(listener, \"Days\", DAY_OF_WEEK),\n-                new FieldGroup(listener, \"Hours\", HOUR_OF_DAY),\n-                new FieldGroup(listener, \"Minutes\", MINUTE_OF_HOUR),\n-                new FieldGroup(listener, \"Seconds\", SECOND_OF_MINUTE)\n+                new FieldGroup(listener, \"Weekyears\", WEEKYEARS),\n+                new FieldGroup(listener, \"Weeks\", WEEKS),\n+                new FieldGroup(listener, \"Days\", DAYS),\n+                new FieldGroup(listener, \"Hours\", HOURS),\n+                new FieldGroup(listener, \"Minutes\", MINUTES),\n+                new FieldGroup(listener, \"Seconds\", SECONDS)\n             })\n         };\n \n                 iFieldSets[i].updateResults(minuend, subtrahend);\n             }\n         }\n-        catch (ParseException e) {\n+        catch (IllegalArgumentException e) {\n             for (int i=0; i<iFieldSets.length; i++) {\n                 iFieldSets[i].setResultsText(\"\");\n             }\n             // Because time zone can be dynamically changed, field must be\n             // dynamically acquired.\n \n-            DateTimeField field;\n+            DurationField field;\n             switch (iFieldType) {\n-            case YEAR:\n-                field = iChronology.year();\n-                break;\n-            case MONTH_OF_YEAR:\n-                field = iChronology.monthOfYear();\n-                break;\n-            case DAY_OF_MONTH:\n-                field = iChronology.dayOfMonth();\n-                break;\n-            case WEEKYEAR:\n-                field = iChronology.weekyear();\n-                break;\n-            case WEEK_OF_WEEKYEAR:\n-                field = iChronology.weekOfWeekyear();\n-                break;\n-            case DAY_OF_WEEK:\n-                field = iChronology.dayOfWeek();\n-                break;\n-            case HOUR_OF_DAY:\n-                field = iChronology.hourOfDay();\n-                break;\n-            case MINUTE_OF_HOUR:\n-                field = iChronology.minuteOfHour();\n-                break;\n-            case SECOND_OF_MINUTE: default:\n-                field = iChronology.secondOfMinute();\n+            case YEARS:\n+                field = iChronology.years();\n+                break;\n+            case MONTHS:\n+                field = iChronology.months();\n+                break;\n+            case DAYS:\n+                field = iChronology.days();\n+                break;\n+            case WEEKYEARS:\n+                field = iChronology.weekyears();\n+                break;\n+            case WEEKS:\n+                field = iChronology.weeks();\n+                break;\n+            case HOURS:\n+                field = iChronology.hours();\n+                break;\n+            case MINUTES:\n+                field = iChronology.minutes();\n+                break;\n+            case SECONDS: default:\n+                field = iChronology.seconds();\n                 break;\n             }\n \n             String textToSet = \"\";\n \n             if (iCheckbox.isSelected()) {\n-                long difference = field.getDifference(minuend, subtrahend);\n+                long difference = field.getDifferenceAsLong(minuend, subtrahend);\n                 textToSet = Long.toString(difference);\n                 subtrahend = field.add(subtrahend, difference);\n             }\n--- a/JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java\n+++ b/JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java\n /*\n  * Import required Java packages.\n  */\n-import java.awt.*;\n-import java.awt.event.*;\n-import javax.swing.*;\n-import javax.swing.table.*;\n-import java.io.*;\n-import java.util.*;\n-import java.text.*;\n-/*\n- * Import required Joda packages.\n- */\n-import org.joda.time.*;\n+import java.awt.Dimension;\n+import java.awt.Toolkit;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.TimeZone;\n+\n+import javax.swing.AbstractAction;\n+import javax.swing.Action;\n+import javax.swing.JFileChooser;\n+import javax.swing.JFrame;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTable;\n+import javax.swing.WindowConstants;\n+import javax.swing.table.TableColumn;\n+import javax.swing.table.TableColumnModel;\n+\n+import org.joda.time.DateTime;\n \n /** DateTimeBrowser is a Java Swing application which reads a file contining\n  * strings and displays DateTime values in a JTable.<p>\n         {\n             retDT = new DateTime( s );\n         } // the try\n-        catch(ParseException pe)\n+        catch(IllegalArgumentException pe)\n         {\n             // ignore it here, caller sees null\n         } // the catch\n--- a/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java\n+++ b/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java\n import org.joda.time.DateTime;\n import org.joda.time.MutableDateTime;\n import org.joda.time.chrono.gj.GJChronology;\n-import org.joda.time.chrono.iso.ISOChronology;\n+\n /**\n  * DateTimePerformance provides various comparisons between the Java supplied\n  * Date classes and the Joda ones.\n      */\n     public DateTimePerformance() throws Exception {\n         checkJodaConstructor1();\n+        checkJISOConstructor1();\n         checkGCalConstructor1();\n         checkDateConstructor1();\n         \n         checkJodaConstructor2();\n+        checkJISOConstructor2();\n         checkGCalConstructor2();\n         checkDateConstructor2();\n         \n         checkJodaConstructor3();\n+        checkJISOConstructor3();\n         checkGCalConstructor3();\n         checkDateConstructor3();\n         \n         checkJodaGetYear();\n+        checkJISOGetYear();\n         checkGCalGetYear();\n         checkDateGetYear();\n         \n //        checkJodaGetMonth();\n+//        checkJISOGetMonth();\n //        checkGCalGetMonth();\n //        checkDateGetMonth();\n         \n //        checkJodaGetDay();\n+//        checkJISOGetDay();\n //        checkGCalGetDay();\n //        checkDateGetDay();\n         \n         checkJodaGetHour();\n+        checkJISOGetHour();\n         checkGCalGetHour();\n         checkDateGetHour();\n         \n         checkJodaSetYear();\n+        checkJISOSetYear();\n         checkGCalSetYear();\n         checkDateSetYear();\n         \n         checkJodaSetGetYear();\n+        checkJISOSetGetYear();\n         checkGCalSetGetYear();\n         checkDateSetGetYear();\n         \n         checkJodaSetHour();\n+        checkJISOSetHour();\n         checkGCalSetHour();\n         checkDateSetHour();\n         \n         checkJodaSetGetHour();\n+        checkJISOSetGetHour();\n         checkGCalSetGetHour();\n         checkDateSetGetHour();\n         \n         System.out.println(\"\");\n         long jodaTotal = 0;\n+        long jisoTotal = 0;\n         long gcalTotal = 0;\n         long dateTotal = 0;\n         for (Iterator it = resultList.iterator(); it.hasNext();) {\n             System.out.println(res.object + \".\" + res.name + \": \" + res.avg + \"ns\");\n             if (res.object.equals(\"Joda\")) {\n                 jodaTotal += res.avg;\n+            } else if (res.object.equals(\"JISO\")) {\n+                jisoTotal += res.avg;\n             } else if (res.object.equals(\"GCal\")) {\n                 gcalTotal += res.avg;\n             } else if (res.object.equals(\"Date\")) {\n             }\n         }\n         System.out.println(\"Joda: \" + jodaTotal);\n+        System.out.println(\"JISO: \" + jisoTotal);\n         System.out.println(\"GCal: \" + gcalTotal);\n         System.out.println(\"Date: \" + dateTotal);\n     }\n         int COUNT = COUNT_SLOW;\n         DateTime dt = new DateTime(GJChronology.getInstance());\n         for (int i = 0; i < AVERAGE; i++) {\n-            start(\"Joda\", \"new\");\n+            start(\"Joda\", \"new()\");\n             for (int j = 0; j < COUNT; j++) {\n                 dt = new DateTime(GJChronology.getInstance());\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkJISOConstructor1() {\n+        int COUNT = COUNT_SLOW;\n+        DateTime dt = new DateTime();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"JISO\", \"new()\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt = new DateTime();\n                 if (dt == null) {System.out.println(\"Anti optimise\");}\n             }\n             end(COUNT);\n         int COUNT = COUNT_SLOW;\n         GregorianCalendar dt = new GregorianCalendar();\n         for (int i = 0; i < AVERAGE; i++) {\n-            start(\"GCal\", \"new\");\n+            start(\"GCal\", \"new()\");\n             for (int j = 0; j < COUNT; j++) {\n                 dt = new GregorianCalendar();\n                 if (dt == null) {System.out.println(\"Anti optimise\");}\n         int COUNT = COUNT_SLOW;\n         Date dt = new Date();\n         for (int i = 0; i < AVERAGE; i++) {\n-            start(\"Date\", \"new\");\n+            start(\"Date\", \"new()\");\n             for (int j = 0; j < COUNT; j++) {\n                 dt = new Date();\n                 if (dt == null) {System.out.println(\"Anti optimise\");}\n             start(\"Joda\", \"new(millis)\");\n             for (int j = 0; j < COUNT; j++) {\n                 dt = new DateTime(12345L, GJChronology.getInstance());\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkJISOConstructor2() {\n+        int COUNT = COUNT_VERY_FAST;\n+        DateTime dt = new DateTime(12345L);\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"JISO\", \"new(millis)\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt = new DateTime(12345L);\n                 if (dt == null) {System.out.println(\"Anti optimise\");}\n             }\n             end(COUNT);\n     \n     private void checkJodaConstructor3() {\n         int COUNT = COUNT_SLOW;\n-        DateTime dt = new DateTime(12345L, GJChronology.getInstance());\n-        MutableDateTime mdt = new MutableDateTime(ISOChronology.getInstance());\n+        DateTime dt = new DateTime(1972, 10, 1, 0, 0, 0, 0,\n+                                   GJChronology.getInstance());\n         for (int i = 0; i < AVERAGE; i++) {\n             start(\"Joda\", \"new(YMD)\");\n             for (int j = 0; j < COUNT; j++) {\n-                mdt = new MutableDateTime(ISOChronology.getInstance());\n-                mdt.setDate(1972, 10, 1);\n-                dt = mdt.toDateTime();\n+                dt = new DateTime(1972, 10, 1, 0, 0, 0, 0,\n+                                  GJChronology.getInstance());\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkJISOConstructor3() {\n+        int COUNT = COUNT_SLOW;\n+        DateTime dt = new DateTime(1972, 10, 1, 0, 0, 0, 0);\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"JISO\", \"new(YMD)\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt = new DateTime(1972, 10, 1, 0, 0, 0, 0);\n                 if (dt == null) {System.out.println(\"Anti optimise\");}\n             }\n             end(COUNT);\n         }\n     }\n \n+    private void checkJISOGetYear() {\n+        int COUNT = COUNT_VERY_FAST;\n+        DateTime dt = new DateTime();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"JISO\", \"getYear\");\n+            for (int j = 0; j < COUNT; j++) {\n+                int val = dt.getYear();\n+                if (val == 0) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n     private void checkGCalGetYear() {\n         int COUNT = COUNT_VERY_FAST;\n         GregorianCalendar dt = new GregorianCalendar();\n         }\n     }\n \n+    private void checkJISOGetMonth() {\n+        int COUNT = COUNT_VERY_FAST;\n+        DateTime dt = new DateTime();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"JISO\", \"getMonth\");\n+            for (int j = 0; j < COUNT; j++) {\n+                int val = dt.getMonthOfYear();\n+                if (val == 0) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n     private void checkGCalGetMonth() {\n         int COUNT = COUNT_VERY_FAST;\n         GregorianCalendar dt = new GregorianCalendar();\n         DateTime dt = new DateTime(GJChronology.getInstance());\n         for (int i = 0; i < AVERAGE; i++) {\n             start(\"Joda\", \"getDay\");\n+            for (int j = 0; j < COUNT; j++) {\n+                int val = dt.getDayOfMonth();\n+                if (val == 0) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkJISOGetDay() {\n+        int COUNT = COUNT_VERY_FAST;\n+        DateTime dt = new DateTime();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"JISO\", \"getDay\");\n             for (int j = 0; j < COUNT; j++) {\n                 int val = dt.getDayOfMonth();\n                 if (val == 0) {System.out.println(\"Anti optimise\");}\n         }\n     }\n \n+    private void checkJISOGetHour() {\n+        int COUNT = COUNT_VERY_FAST;\n+        DateTime dt = new DateTime();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"JISO\", \"getHour\");\n+            for (int j = 0; j < COUNT; j++) {\n+                int val = dt.getHourOfDay();\n+                if (val == -1) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n     private void checkGCalGetHour() {\n         int COUNT = COUNT_VERY_FAST;\n         GregorianCalendar dt = new GregorianCalendar();\n         }\n     }\n \n+    private void checkJISOSetYear() {\n+        int COUNT = COUNT_FAST;\n+        // Is it fair to use only MutableDateTime here? You decide.\n+        MutableDateTime dt = new MutableDateTime();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"JISO\", \"setYear\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt.setYear(1972);\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n     private void checkGCalSetYear() {\n         int COUNT = COUNT_VERY_FAST;\n         GregorianCalendar dt = new GregorianCalendar();\n         }\n     }\n \n+    private void checkJISOSetGetYear() {\n+        int COUNT = COUNT_FAST;\n+        // Is it fair to use only MutableDateTime here? You decide.\n+        MutableDateTime dt = new MutableDateTime();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"JISO\", \"setGetYear\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt.setYear(1972);\n+                int val = dt.getYear();\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n     private void checkGCalSetGetYear() {\n         int COUNT = COUNT_FAST;\n         GregorianCalendar dt = new GregorianCalendar();\n         }\n     }\n \n+    private void checkJISOSetHour() {\n+        int COUNT = COUNT_VERY_FAST;\n+        // Is it fair to use only MutableDateTime here? You decide.\n+        MutableDateTime dt = new MutableDateTime();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"JISO\", \"setHour\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt.setHourOfDay(13);\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n     private void checkGCalSetHour() {\n         int COUNT = COUNT_VERY_FAST;\n         GregorianCalendar dt = new GregorianCalendar();\n         MutableDateTime dt = new MutableDateTime(GJChronology.getInstance());\n         for (int i = 0; i < AVERAGE; i++) {\n             start(\"Joda\", \"setGetHour\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt.setHourOfDay(13);\n+                int val = dt.getHourOfDay();\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkJISOSetGetHour() {\n+        int COUNT = COUNT_VERY_FAST;\n+        // Is it fair to use only MutableDateTime here? You decide.\n+        MutableDateTime dt = new MutableDateTime();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"JISO\", \"setGetHour\");\n             for (int j = 0; j < COUNT; j++) {\n                 dt.setHourOfDay(13);\n                 int val = dt.getHourOfDay();\n--- a/JodaTime/src/java/org/joda/time/AbstractDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractDateTime.java\n  */\n package org.joda.time;\n \n-import java.util.Calendar;\n-import java.util.Date;\n-import java.util.GregorianCalendar;\n+import java.io.Serializable;\n import java.util.Locale;\n \n-import org.joda.time.chrono.buddhist.BuddhistChronology;\n-import org.joda.time.chrono.gj.GJChronology;\n import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.convert.InstantConverter;\n+import org.joda.time.convert.ConverterManager;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.ISODateTimeFormat;\n \n /**\n- * AbstractDateTime provides the common behaviour for immutable datetime\n- * classes.\n+ * AbstractDateTime provides the common behaviour for datetime classes.\n  * <p>\n- * This class should generally not be used directly by API users. The \n- * {@link ReadableDateTime} interface should be used when different \n+ * This class should generally not be used directly by API users.\n+ * The {@link ReadableDateTime} interface should be used when different \n  * kinds of date/time objects are to be referenced.\n+ * <p>\n+ * AbstractDateTime subclasses may be mutable and not thread-safe.\n  *\n  * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n  * @since 1.0\n  */\n public abstract class AbstractDateTime extends AbstractInstant\n-        implements ReadableDateTime {\n-\n-    // The following package-private static methods are used in the\n-    // constructors for DateTime, DateOnly, TimeOnly, and MutableDateTime.\n-\n-    /**\n-     * Validates the parameters and returns a suitable chronology.\n+    implements ReadableDateTime, Serializable {\n+\n+    static final long serialVersionUID = 597501475466447837L;\n+\n+    /**\n+     * Selects the correct chronology to use for the chronology based constructors\n+     * on subclasses.\n      * \n      * @param chrono  the chronology to use, must not be null\n      * @return the passed in Chronology\n-     * @throws IllegalArgumentException if the chronology is null\n-     */\n-    static Chronology selectChronology(Chronology chrono) {\n+     */\n+    private static Chronology selectChronology(Chronology chrono) {\n         if (chrono == null) {\n-            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+            return ISOChronology.getInstance();\n         }\n         return chrono;\n     }\n \n-    /**\n-     * Validates the parameters and returns a suitable chronology. If the\n-     * instant's chronology is null, ISOChronology in the default time zone is\n-     * returned.\n-     * \n-     * @param instant  the instant to use, must not be null\n-     * @return a suitable Chronology\n-     * @throws IllegalArgumentException if the instant is null\n-     */\n-    static Chronology selectChronology(ReadableInstant instant) {\n-        if (instant == null) {\n-            throw new IllegalArgumentException(\"The ReadableInstant must not be null\");\n-        }\n-        Chronology chrono = instant.getChronology();\n-        if (chrono == null) {\n-            chrono = ISOChronology.getInstance();\n-        }\n-        return chrono;\n-    }\n-\n-    /**\n-     * Validates the parameters and returns a suitable chronology. If the\n-     * instant's chronology is null, ISOChronology in the given time zone is\n-     * returned.\n-     * \n-     * @param instant  the instant to use, must not be null\n-     * @param zone  the time zone to use, must not be null\n-     * @return a suitable Chronology\n-     * @throws IllegalArgumentException if the instant or zone is null\n-     */\n-    static Chronology selectChronology(ReadableInstant instant, DateTimeZone zone) {\n-        Chronology chrono = selectChronology(instant);\n-        if (zone == null) {\n-            throw new IllegalArgumentException(\"The DateTimeZone must not be null\");\n-        }\n-        if (chrono.getDateTimeZone() != zone) {\n-            chrono = chrono.withDateTimeZone(zone);\n-            if (chrono == null) {\n-                chrono = ISOChronology.getInstance(zone);\n-            }\n-        }\n-        return chrono;\n-    }\n-\n-    /**\n-     * Validates the parameters and returns a suitable chronology.\n-     *\n-     * @param instant  the instant to use, must not be null\n-     * @param chrono  the chronology to use, must not be null\n-     * @return the passed in chronology\n-     * @throws IllegalArgumentException if the instant or chronology is null\n-     */\n-    static Chronology selectChronology(ReadableInstant instant, Chronology chrono) {\n-        if (instant == null) {\n-            throw new IllegalArgumentException(\"The ReadableInstant must not be null\");\n-        }\n-        return selectChronology(chrono);\n-    }\n-\n-    /**\n-     * Validates the parameters and returns a suitable chronology. If the\n-     * instant's chronology is null, ISOChronology in UTC is returned.\n-     *\n-     * <p>Note: This method does not guarantee returning a UTC chronology\n-     * \n-     * @param instant  the instant to use, must not be null\n-     * @return a suitable Chronology\n-     * @throws IllegalArgumentException if the instant is null\n-     */\n-    static Chronology selectChronologyUTC(ReadableInstant instant) {\n-        if (instant == null) {\n-            throw new IllegalArgumentException(\"The ReadableInstant must not be null\");\n-        }\n-        Chronology chrono = instant.getChronology();\n-        if (chrono == null) {\n-            chrono = ISOChronology.getInstanceUTC();\n-        }\n-        return chrono;\n-    }\n-\n-    /**\n-     * Validates the parameters and returns a suitable chronology.\n-     * \n-     * @param date  the date to be validated, must not be null\n-     * @return a suitable Chronology\n-     * @throws IllegalArgumentException if the date is null\n-     */\n-    static Chronology selectChronology(Date date) {\n-        return selectChronology(date, ISOChronology.getInstance());\n-    }\n-\n-    /**\n-     * Validates the parameters and returns a suitable chronology.\n-     * \n-     * @param date  the date to be validated, must not be null\n-     * @param zone  the zone to use, must not be null\n-     * @return a suitable Chronology\n-     * @throws IllegalArgumentException if the date or zone is null\n-     */\n-    static Chronology selectChronology(Date date, DateTimeZone zone) {\n-        return selectChronology(date, ISOChronology.getInstance(zone));\n-    }\n-\n-    /**\n-     * Validates the parameters and returns a suitable chronology.\n-     * \n-     * @param date  the date to be validated, must not be null\n-     * @param chrono  the chronology to use, must not be null\n-     * @return a suitable Chronology\n-     * @throws IllegalArgumentException if the date or chronology is null\n-     */\n-    static Chronology selectChronology(Date date, Chronology chrono) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"The Date must not be null\");\n-        }\n-        return selectChronology(chrono);\n-    }\n-\n-    /**\n-     * Validates the parameters and returns a suitable chronology. The method\n-     * is aware of GregorianCalendar and BuddhistCalendar and maps them\n-     * accordingly. Other calendars map to ISO.\n-     * \n-     * @param calendar  the calendar to be used, must not be null\n-     * @return a suitable Chronology\n-     * @throws IllegalArgumentException if the calendar is null\n-     */\n-    static Chronology selectChronology(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The Calendar must not be null\");\n-        }\n-        DateTimeZone zone = null;\n-        try {\n-            zone = DateTimeZone.getInstance(calendar.getTimeZone());\n-        } catch (IllegalArgumentException ex) {\n-            return ISOChronology.getInstance();\n-        }\n-        return selectChronology(calendar, zone);\n-    }\n-\n-    /**\n-     * Validates the parameters and returns a suitable chronology. The method\n-     * is aware of GregorianCalendar and BuddhistCalendar and maps them\n-     * accordingly. Other calendars map to ISO.\n-     * \n-     * @param calendar  the calendar to be used, must not be null\n-     * @param zone  the time zone to use\n-     * @return a suitable Chronology\n-     * @throws IllegalArgumentException if the calendar is null\n-     */\n-    static Chronology selectChronology(Calendar calendar, DateTimeZone zone) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The Calendar must not be null\");\n-        }\n-        if (zone == null) {\n-            throw new IllegalArgumentException(\"The DateTimeZone must not be null\");\n-        }\n-        if (calendar instanceof GregorianCalendar) {\n-            GregorianCalendar gc = (GregorianCalendar) calendar;\n-            return GJChronology.getInstance(zone, gc.getGregorianChange().getTime(), false);\n-        } else if (calendar.getClass().getName().endsWith(\".BuddhistCalendar\")) {\n-            return BuddhistChronology.getInstance(zone);\n-        } else {\n-            return ISOChronology.getInstance(zone);\n-        }\n-    }\n-\n-    /**\n-     * Validates the parameters and returns a suitable chronology.\n-     * \n-     * @param calendar  the calendar to be used, must not be null\n-     * @param chrono  the chronology to use, must not be null\n-     * @return a suitable Chronology\n-     * @throws IllegalArgumentException if the calendar is null\n-     */\n-    static Chronology selectChronology(Calendar calendar, Chronology chrono) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The Calendar must not be null\");\n-        }\n-        return selectChronology(chrono);\n-    }\n-\n-    /**\n-     * Validates the parameters and returns a suitable chronology.\n-     * \n-     * @param string  the string to parse, must not be null\n-     * @return a suitable Chronology\n-     * @throws IllegalArgumentException if the string is null\n-     */\n-    static Chronology selectChronology(String str) {\n-        return selectChronology(str, ISOChronology.getInstance());\n-    }\n-\n-    /**\n-     * Validates the parameters and returns a suitable chronology.\n-     * \n-     * @param string  the string to parse, must not be null\n-     * @param zone  the zone to use, must not be null\n-     * @return a suitable Chronology\n-     * @throws IllegalArgumentException if the string or zone is null\n-     */\n-    static Chronology selectChronology(String str, DateTimeZone zone) {\n-        return selectChronology(str, ISOChronology.getInstance(zone));\n-    }\n-\n-    /**\n-     * Validates the parameters and returns a suitable chronology.\n-     * \n-     * @param str  the string to parse, must not be null\n-     * @param chrono  the chronology to use, must not be null\n-     * @return a suitable Chronology\n-     * @throws IllegalArgumentException if the string or chronology is null\n-     */\n-    static Chronology selectChronology(String str, Chronology chrono) {\n-        if (str == null) {\n-            throw new IllegalArgumentException(\"The String must not be null\");\n-        }\n-        return selectChronology(chrono);\n-    }\n-\n-    public AbstractDateTime() {\n-        super();\n+    /** The millis from 1970-01-01T00:00:00Z */\n+    private long iMillis;\n+    /** The chronology to use */\n+    private Chronology iChronology;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using <code>ISOChronology</code> in the default time zone.\n+     */\n+    protected AbstractDateTime() {\n+        super();\n+        iChronology = ISOChronology.getInstance();\n+        iMillis = System.currentTimeMillis();\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param zone  the time zone, null means default zone\n+     */\n+    protected AbstractDateTime(final DateTimeZone zone) {\n+        super();\n+        iChronology = ISOChronology.getInstance(zone);\n+        iMillis = System.currentTimeMillis();\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    protected AbstractDateTime(final Chronology chronology) {\n+        super();\n+        iChronology = selectChronology(chronology);\n+        iMillis = System.currentTimeMillis();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using <code>ISOChronology</code> in the default time zone.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    protected AbstractDateTime(final long instant) {\n+        super();\n+        iChronology = ISOChronology.getInstance();\n+        iMillis = instant;\n+    }\n+\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param zone  the time zone, null means default zone\n+     */\n+    protected AbstractDateTime(final long instant, final DateTimeZone zone) {\n+        super();\n+        iChronology = ISOChronology.getInstance(zone);\n+        iMillis = instant;\n+    }\n+\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    protected AbstractDateTime(final long instant, final Chronology chronology) {\n+        super();\n+        iChronology = selectChronology(chronology);\n+        iMillis = instant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from an Object that represents a datetime.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @throws IllegalArgumentException if the instant is null or invalid\n+     */\n+    protected AbstractDateTime(final Object instant) {\n+        super();\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        iChronology = converter.getChronology(instant);\n+        iMillis = converter.getInstantMillis(instant);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * forcing the time zone to that specified.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * If the specified time zone is null, the default zone is used.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @param zone  the time zone, null means default time zone\n+     * @throws IllegalArgumentException if the instant is null or invalid\n+     */\n+    protected AbstractDateTime(final Object instant, final DateTimeZone zone) {\n+        super();\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        iChronology = converter.getChronology(instant, zone);\n+        iMillis = converter.getInstantMillis(instant, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, ISOChronology in the default time zone is used.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     * @throws IllegalArgumentException if the instant is null or invalid\n+     */\n+    protected AbstractDateTime(final Object instant, final Chronology chronology) {\n+        super();\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        iChronology = converter.getChronology(instant, chronology);\n+        iMillis = converter.getInstantMillis(instant, chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the default time zone.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the milisecond of the second\n+     */\n+    protected AbstractDateTime(\n+            final int year,\n+            final int monthOfYear,\n+            final int dayOfMonth,\n+            final int hourOfDay,\n+            final int minuteOfHour,\n+            final int secondOfMinute,\n+            final int millisOfSecond) {\n+        super();\n+        iChronology = ISOChronology.getInstance();\n+        iMillis = iChronology.getDateTimeMillis(\n+            year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the milisecond of the second\n+     * @param zone  the time zone, null means default time zone\n+     */\n+    protected AbstractDateTime(\n+            final int year,\n+            final int monthOfYear,\n+            final int dayOfMonth,\n+            final int hourOfDay,\n+            final int minuteOfHour,\n+            final int secondOfMinute,\n+            final int millisOfSecond,\n+            final DateTimeZone zone) {\n+        super();\n+        iChronology = ISOChronology.getInstance(zone);\n+        iMillis = iChronology.getDateTimeMillis(\n+            year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the milisecond of the second\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    protected AbstractDateTime(\n+            final int year,\n+            final int monthOfYear,\n+            final int dayOfMonth,\n+            final int hourOfDay,\n+            final int minuteOfHour,\n+            final int secondOfMinute,\n+            final int millisOfSecond,\n+            final Chronology chronology) {\n+        super();\n+        iChronology = selectChronology(chronology);\n+        iMillis = iChronology.getDateTimeMillis(\n+            year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    // Accessors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the milliseconds of the datetime instant from the Java epoch\n+     * of 1970-01-01T00:00:00Z.\n+     * \n+     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n+     */\n+    public final long getMillis() {\n+        return iMillis;\n+    }\n+\n+    /**\n+     * Gets the milliseconds of the datetime instant from the Java epoch\n+     * of 1970-01-01T00:00:00Z.\n+     * \n+     * @param base ignored\n+     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n+     */\n+    public final long getMillis(ReadableInstant base) {\n+        return iMillis;\n+    }\n+\n+    /**\n+     * Gets the milliseconds of the datetime instant from the Java epoch\n+     * of 1970-01-01T00:00:00Z.\n+     * \n+     * @param base ignored\n+     * @param zone ignored\n+     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n+     */\n+    public final long getMillis(ReadableInstant base, DateTimeZone zone) {\n+        return iMillis;\n+    }\n+\n+    /**\n+     * Gets the chronology of the datetime.\n+     * \n+     * @return the Chronology that the datetime is using\n+     */\n+    public final Chronology getChronology() {\n+        return iChronology;\n     }\n \n     // Date field access\n     //-----------------------------------------------------------------------\n+    /**\n+     * Get the era field value.\n+     * \n+     * @return the era\n+     */\n+    public final int getEra() {\n+        return getChronology().era().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year of era field value.\n+     * \n+     * @return the year of era\n+     */\n+    public final int getCenturyOfEra() {\n+        return getChronology().centuryOfEra().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year of era field value.\n+     * \n+     * @return the year of era\n+     */\n+    public final int getYearOfEra() {\n+        return getChronology().yearOfEra().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year of century field value.\n+     * \n+     * @return the year of century\n+     */\n+    public final int getYearOfCentury() {\n+        return getChronology().yearOfCentury().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year field value.\n+     * \n+     * @return the year\n+     */\n+    public final int getYear() {\n+        return getChronology().year().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the weekyear field value.\n+     * \n+     * @return the year of a week based year\n+     */\n+    public final int getWeekyear() {\n+        return getChronology().weekyear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the month of year field value.\n+     * \n+     * @return the month of year\n+     */\n+    public final int getMonthOfYear() {\n+        return getChronology().monthOfYear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the week of weekyear field value.\n+     * \n+     * @return the week of a week based year\n+     */\n+    public final int getWeekOfWeekyear() {\n+        return getChronology().weekOfWeekyear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the day of year field value.\n+     * \n+     * @return the day of year\n+     */\n+    public final int getDayOfYear() {\n+        return getChronology().dayOfYear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the day of month field value.\n+     * <p>\n+     * The values for the day of month are defined in {@link DateTimeConstants}.\n+     * \n+     * @return the day of month\n+     */\n+    public final int getDayOfMonth() {\n+        return getChronology().dayOfMonth().get(getMillis());\n+    }\n+\n     /**\n      * Get the day of week field value.\n      * <p>\n         return getChronology().dayOfWeek().get(getMillis());\n     }\n \n-    /**\n-     * Get the day of month field value.\n-     * \n-     * @return the day of month\n-     */\n-    public final int getDayOfMonth() {\n-        return getChronology().dayOfMonth().get(getMillis());\n-    }\n-\n-    /**\n-     * Get the day of year field value.\n-     * \n-     * @return the day of year\n-     */\n-    public final int getDayOfYear() {\n-        return getChronology().dayOfYear().get(getMillis());\n-    }\n-\n-    /**\n-     * Get the week of weekyear field value.\n-     * \n-     * @return the week of a week based year\n-     */\n-    public final int getWeekOfWeekyear() {\n-        return getChronology().weekOfWeekyear().get(getMillis());\n-    }\n-\n-    /**\n-     * Get the weekyear field value.\n-     * \n-     * @return the year of a week based year\n-     */\n-    public final int getWeekyear() {\n-        return getChronology().weekyear().get(getMillis());\n-    }\n-\n-    /**\n-     * Get the month of year field value.\n-     * \n-     * @return the month of year\n-     */\n-    public final int getMonthOfYear() {\n-        return getChronology().monthOfYear().get(getMillis());\n-    }\n-\n-    /**\n-     * Get the year field value.\n-     * \n-     * @return the year\n-     */\n-    public final int getYear() {\n-        return getChronology().year().get(getMillis());\n-    }\n-\n-    /**\n-     * Get the year of era field value.\n-     * \n-     * @return the year of era\n-     */\n-    public final int getYearOfEra() {\n-        return getChronology().yearOfEra().get(getMillis());\n-    }\n-\n-    /**\n-     * Get the year of century field value.\n-     * \n-     * @return the year of century\n-     */\n-    public final int getYearOfCentury() {\n-        return getChronology().yearOfCentury().get(getMillis());\n-    }\n-\n-    /**\n-     * Get the year of era field value.\n-     * \n-     * @return the year of era\n-     */\n-    public final int getCenturyOfEra() {\n-        return getChronology().centuryOfEra().get(getMillis());\n-    }\n-\n-    /**\n-     * Get the era field value.\n-     * \n-     * @return the era\n-     */\n-    public final int getEra() {\n-        return getChronology().era().get(getMillis());\n-    }\n-\n     // Time field access\n     //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day field value.\n+     *\n+     * @return the hour of day\n+     */\n+    public final int getHourOfDay() {\n+        return getChronology().hourOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the minute of day field value.\n+     *\n+     * @return the minute of day\n+     */\n+    public final int getMinuteOfDay() {\n+        return getChronology().minuteOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the minute of hour field value.\n+     *\n+     * @return the minute of hour\n+     */\n+    public final int getMinuteOfHour() {\n+        return getChronology().minuteOfHour().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the second of day field value.\n+     *\n+     * @return the second of day\n+     */\n+    public final int getSecondOfDay() {\n+        return getChronology().secondOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the second of minute field value.\n+     *\n+     * @return the second of minute\n+     */\n+    public final int getSecondOfMinute() {\n+        return getChronology().secondOfMinute().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the millis of day field value.\n+     *\n+     * @return the millis of day\n+     */\n+    public final int getMillisOfDay() {\n+        return getChronology().millisOfDay().get(getMillis());\n+    }\n+\n     /**\n      * Get the millis of second field value.\n      *\n         return getChronology().millisOfSecond().get(getMillis());\n     }\n \n-    /**\n-     * Get the millis of day field value.\n-     *\n-     * @return the millis of day\n-     */\n-    public final int getMillisOfDay() {\n-        return getChronology().millisOfDay().get(getMillis());\n-    }\n-\n-    /**\n-     * Get the second of minute field value.\n-     *\n-     * @return the second of minute\n-     */\n-    public final int getSecondOfMinute() {\n-        return getChronology().secondOfMinute().get(getMillis());\n-    }\n-\n-    /**\n-     * Get the second of day field value.\n-     *\n-     * @return the second of day\n-     */\n-    public final int getSecondOfDay() {\n-        return getChronology().secondOfDay().get(getMillis());\n-    }\n-\n-    /**\n-     * Get the minute of hour field value.\n-     *\n-     * @return the minute of hour\n-     */\n-    public final int getMinuteOfHour() {\n-        return getChronology().minuteOfHour().get(getMillis());\n-    }\n-\n-    /**\n-     * Get the minute of day field value.\n-     *\n-     * @return the minute of day\n-     */\n-    public final int getMinuteOfDay() {\n-        return getChronology().minuteOfDay().get(getMillis());\n-    }\n-\n-    /**\n-     * Get the hour of day field value.\n-     *\n-     * @return the hour of day\n-     */\n-    public final int getHourOfDay() {\n-        return getChronology().hourOfDay().get(getMillis());\n-    }\n-\n-    // Conversion\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Get this object as a DateTime.\n-     * \n-     * @return a DateTime using the same millis\n-     */\n-    public final DateTime toDateTime() {\n-        if (this instanceof DateTime) {\n-            return (DateTime)this;\n-        }\n-        return new DateTime(this);\n-    }\n-\n-    /**\n-     * Get this object as a DateTime.\n-     * \n-     * @param zone time zone to apply\n-     * @return a DateTime using the same millis\n-     * @throws IllegalArgumentException if the time zone is null\n-     */\n-    public final DateTime toDateTime(DateTimeZone zone) {\n-        if (zone == null) {\n-            throw new IllegalArgumentException(\"The DateTimeZone must not be null\");\n-        }\n-        if (this instanceof DateTime) {\n-            DateTime dt = (DateTime)this;\n-            if (dt.getDateTimeZone() == zone) {\n-                return dt;\n-            }\n-        }\n-        return new DateTime(this, zone);\n-    }\n-\n-    /**\n-     * Get this object as a DateTime.\n-     * \n-     * @param chronology chronology to apply\n-     * @return a DateTime using the same millis\n-     * @throws IllegalArgumentException if the chronology is null\n-     */\n-    public final DateTime toDateTime(Chronology chronology) {\n-        if (chronology == null) {\n-            throw new IllegalArgumentException(\"The Chronology must not be null\");\n-        }\n-        if (this instanceof DateTime) {\n-            DateTime dt = (DateTime)this;\n-            if (dt.getChronology() == chronology) {\n-                return dt;\n-            }\n-        }\n-        return new DateTime(this, chronology);\n-    }\n-\n-    /**\n-     * Get this object as a trusted ISO DateTime.\n-     * \n-     * @return an ISO DateTime using the same millis\n-     */\n-    public final DateTime toISODateTime() {\n-        if (this instanceof DateTime) {\n-            DateTime dt = (DateTime)this;\n-            if (dt.getChronology() instanceof ISOChronology) {\n-                // Verify that the time zone is trusted.\n-                DateTimeZone tz = dt.getDateTimeZone();\n-                DateTimeZone trusted = DateTimeZone.getInstance(tz.getID());\n-                if (tz == trusted) {\n-                    return dt;\n-                }\n-                return new DateTime(this, trusted);\n-            }\n-        }\n-        return new DateTime(this);\n-    }\n-\n-    /**\n-     * Get this object as a trusted ISO DateTime.\n-     * \n-     * @param zone time zone to apply\n-     * @return an ISO DateTime using the same millis\n-     * @throws IllegalArgumentException if the time zone is null\n-     */\n-    public final DateTime toISODateTime(DateTimeZone zone) {\n-        if (zone == null) {\n-            throw new IllegalArgumentException(\"The DateTimeZone must not be null\");\n-        }\n-        if (this instanceof DateTime) {\n-            DateTime dt = (DateTime)this;\n-            if (dt.getChronology() instanceof ISOChronology) {\n-                if (dt.getDateTimeZone() == zone) {\n-                    return dt;\n-                }\n-            }\n-        }\n-        return new DateTime(this, zone);\n-    }\n-\n-    /**\n-     * Get this object as a MutableDateTime.\n-     * \n-     * @return a MutableDateTime using the same millis\n-     */\n-    public final MutableDateTime toMutableDateTime() {\n-        if (this instanceof MutableDateTime) {\n-            return (MutableDateTime)this;\n-        }\n-        return new MutableDateTime(this);\n-    }\n-\n-    /**\n-     * Get this object as a MutableDateTime.\n-     * \n-     * @param zone time zone to apply\n-     * @return a MutableDateTime using the same millis\n-     * @throws IllegalArgumentException if the time zone is null\n-     */\n-    public final MutableDateTime toMutableDateTime(DateTimeZone zone) {\n-        if (zone == null) {\n-            throw new IllegalArgumentException(\"The DateTimeZone must not be null\");\n-        }\n-        if (this instanceof MutableDateTime) {\n-            MutableDateTime mdt = (MutableDateTime)this;\n-            if (mdt.getDateTimeZone() == zone) {\n-                return mdt;\n-            }\n-        }\n-        return new MutableDateTime(this, zone);\n-    }\n-\n-    /**\n-     * Get this object as a MutableDateTime.\n-     * \n-     * @param chronology chronology to apply\n-     * @return a MutableDateTime using the same millis\n-     * @throws IllegalArgumentException if the chronology is null\n-     */\n-    public final MutableDateTime toMutableDateTime(Chronology chronology) {\n-        if (chronology == null) {\n-            throw new IllegalArgumentException(\"The Chronology must not be null\");\n-        }\n-        if (this instanceof MutableDateTime) {\n-            MutableDateTime mdt = (MutableDateTime)this;\n-            if (mdt.getChronology() == chronology) {\n-                return mdt;\n-            }\n-        }\n-        return new MutableDateTime(this, chronology);\n-    }\n-\n-    /**\n-     * Get this object as a trusted ISO MutableDateTime.\n-     * \n-     * @return an ISO MutableDateTime using the same millis\n-     */\n-    public final MutableDateTime toISOMutableDateTime() {\n-        if (this instanceof DateTime) {\n-            MutableDateTime mdt = (MutableDateTime)this;\n-            if (mdt.getChronology() instanceof ISOChronology) {\n-                // Verify that the time zone is trusted.\n-                DateTimeZone tz = mdt.getDateTimeZone();\n-                DateTimeZone trusted = DateTimeZone.getInstance(tz.getID());\n-                if (tz == trusted) {\n-                    return mdt;\n-                }\n-                return new MutableDateTime(this, trusted);\n-            }\n-        }\n-        return new MutableDateTime(this);\n-    }\n-\n-    /**\n-     * Get this object as a trusted ISO MutableDateTime.\n-     * \n-     * @param zone time zone to apply\n-     * @return an ISO MutableDateTime using the same millis\n-     * @throws IllegalArgumentException if the time zone is null\n-     */\n-    public final MutableDateTime toISOMutableDateTime(DateTimeZone zone) {\n-        if (zone == null) {\n-            throw new IllegalArgumentException(\"The DateTimeZone must not be null\");\n-        }\n-        if (this instanceof MutableDateTime) {\n-            MutableDateTime mdt = (MutableDateTime)this;\n-            if (mdt.getChronology() instanceof ISOChronology) {\n-                if (mdt.getDateTimeZone() == zone) {\n-                    return mdt;\n-                }\n-            }\n-        }\n-        return new MutableDateTime(this, zone);\n-    }\n-\n-    /**\n-     * Get this object as a DateOnly.\n-     * \n-     * @return a DateOnly using the same millis\n-     */\n-    /*\n-    public final DateOnly toDateOnly() {\n-        if (this instanceof DateOnly) {\n-            return (DateOnly)this;\n-        }\n-        return new DateOnly(this);\n-    }\n-    /*\n-\n-    /**\n-     * Get this object as a DateOnly.\n-     * \n-     * @param chronology chronology to apply\n-     * @return a DateOnly using the same millis\n-     * @throws IllegalArgumentException if the chronology is null\n-     */\n-    /*\n-    public final DateOnly toDateOnly(Chronology chronology) {\n-        if (chronology == null) {\n-            throw new IllegalArgumentException(\"The Chronology must not be null\");\n-        }\n-        chronology = chronology.withUTC();\n-        if (this instanceof DateOnly) {\n-            DateOnly d = (DateOnly)this;\n-            if (d.getChronology() == chronology) {\n-                return d;\n-            }\n-        }\n-        return new DateOnly(this, chronology);\n-    }\n-    */\n-\n-    /**\n-     * Get this object as a TimeOnly.\n-     * \n-     * @return a TimeOnly using the same millis\n-     */\n-    /*\n-    public final TimeOnly toTimeOnly() {\n-        if (this instanceof TimeOnly) {\n-            return (TimeOnly)this;\n-        }\n-        return new TimeOnly(this);\n-    }\n-    */\n-\n-    /**\n-     * Get this object as a TimeOnly.\n-     * \n-     * @param chronology chronology to apply\n-     * @return a TimeOnly using the same millis\n-     * @throws IllegalArgumentException if the chronology is null\n-     */\n-    /*\n-    public final TimeOnly toTimeOnly(Chronology chronology) {\n-        if (chronology == null) {\n-            throw new IllegalArgumentException(\"The Chronology must not be null\");\n-        }\n-        chronology = chronology.withUTC();\n-        if (this instanceof TimeOnly) {\n-            TimeOnly t = (TimeOnly)this;\n-            if (t.getChronology() == chronology) {\n-                return t;\n-            }\n-        }\n-        return new TimeOnly(this, chronology);\n-    }\n-    */\n-\n     // Output\n     //-----------------------------------------------------------------------\n     /**\n      * Output the instant using the specified format pattern.\n      *\n      * @param pattern  the pattern specification\n-     * @see org.joda.time.format.DateTimeFormatterBuilder#appendPattern(java.lang.String)\n+     * @throws IllegalArgumentException  if pattern is invalid\n+     * @see  org.joda.time.format.DateTimeFormat\n      */\n     public String toString(String pattern) throws IllegalArgumentException {\n-        Chronology chrono = getChronology();\n-        if (chrono == null) {\n-            chrono = ISOChronology.getInstanceUTC();\n+        return DateTimeFormat.getInstance(getChronology()).forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Output the instant using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification\n+     * @param locale  Locale to use, or default if null\n+     * @throws IllegalArgumentException  if pattern is invalid\n+     * @see  org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n+        return DateTimeFormat.getInstance(getChronology(), locale).forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Set the value as the number of miliseconds since the epoch,\n+     * 1970-01-01T00:00:00Z.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     *\n+     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the\n+     * instant to\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    protected void setMillis(long instant) {\n+        iMillis = instant;\n+    }\n+\n+    /**\n+     * Set the value from an Object representing an instant.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * \n+     * @param instant  an object representing an instant\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    protected void setMillis(Object instant) {\n+        // Don't set iMillis directly, as it may provide a backdoor to\n+        // immutable subclasses.\n+        if (instant instanceof ReadableInstant) {\n+            setMillis(((ReadableInstant) instant).getMillis());\n+        } else {\n+            InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+            setMillis(converter.getInstantMillis(instant));\n         }\n-        return DateTimeFormat.getInstance(chrono).forPattern(pattern).print(this);\n-    }\n-\n-    /**\n-     * Output the instant using the specified format pattern.\n-     *\n-     * @param pattern  the pattern specification\n-     * @param locale  the Locale to use, must not be null\n-     * @see org.joda.time.format.DateTimeFormatterBuilder#appendPattern(java.lang.String)\n-     * @throws IllegalArgumentException if the locale is null\n-     */\n-    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n-        if (locale == null) {\n-            throw new IllegalArgumentException(\"The Locale must not be null\");\n+    }\n+\n+    /**\n+     * Set the chronology of the datetime.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param chronology  the chronology to use, null means ISOChronology in default zone\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    protected void setChronology(Chronology chronology) {\n+        iChronology = selectChronology(chronology);\n+    }\n+\n+    /**\n+     * Sets the time zone of the datetime via the chronology. Setting the time\n+     * zone does not affect the millisecond value of this instant.\n+     *\n+     * @param zone  the time zone to use, null means default zone\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @see #moveDateTimeZone\n+     */\n+    protected void setDateTimeZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n         }\n-        Chronology chrono = getChronology();\n-        if (chrono == null) {\n-            chrono = ISOChronology.getInstanceUTC();\n+        if (iChronology.getDateTimeZone() != zone) {\n+            // Don't set iChronology directly, as it may provide a backdoor to\n+            // immutable subclasses.\n+            setChronology(iChronology.withDateTimeZone(zone));\n         }\n-        return DateTimeFormat.getInstance(chrono, locale).forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Moves the time zone of the datetime via the chronology. Moving the time\n+     * zone alters the millisecond value of this instant such that it is\n+     * relative to the new time zone.\n+     *\n+     * @param zone  the time zone to use, null means default zone\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @see #setDateTimeZone\n+     */\n+    protected void moveDateTimeZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        DateTimeZone currentZone = iChronology.getDateTimeZone();\n+        if (currentZone != zone) {\n+            long millis = iMillis;\n+            millis += currentZone.getOffset(millis);\n+            millis -= zone.getOffsetFromLocal(millis);\n+            // Don't set iChronology and iMillis directly, as it may provide a\n+            // backdoor to immutable subclasses.\n+            setChronology(iChronology.withDateTimeZone(zone));\n+            setMillis(millis);\n+        }\n     }\n \n }\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/AbstractDateTimeFieldProperty.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.util.Locale;\n+import java.io.Serializable;\n+\n+/**\n+ * AbstractDateTimeFieldProperty is a base class for binding a\n+ * ReadableDateTime to a DateTimeField.\n+ * <p>\n+ * It allows the date and time manipulation code to be field based yet\n+ * still easy to use.\n+ * <p>\n+ * AbstractDateTimeFieldPropery itself is thread-safe and immutable, but the\n+ * ReadableDateTime being operated on may be mutable and not thread-safe.\n+ *\n+ * @see ReadableInstant\n+ * @see DateTimeField\n+ * \n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class AbstractDateTimeFieldProperty implements Serializable {\n+    \n+    static final long serialVersionUID = 1971226328211649661L;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public AbstractDateTimeFieldProperty() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field being used.\n+     * \n+     * @return the field\n+     */\n+    public abstract DateTimeField getField();\n+\n+    /**\n+     * Gets the name of the field.\n+     * \n+     * @return the field name\n+     */\n+    public String getName() {\n+        return getField().getName();\n+    }\n+\n+    /**\n+     * Gets the instant being used.\n+     * \n+     * @return the instant\n+     */\n+    public abstract ReadableDateTime getInstant();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a value from the instant.\n+     * \n+     * @return the current value\n+     * @see DateTimeField#get\n+     */\n+    public int get() {\n+        return getField().get(getInstant().getMillis());\n+    }\n+\n+    /**\n+     * Gets a text value from the instant.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the current text value\n+     * @see DateTimeField#getAsText\n+     */\n+    public String getAsText(Locale locale) {\n+        return getField().getAsText(getInstant().getMillis(), locale);\n+    }\n+\n+    /**\n+     * Gets a text value from the instant.\n+     * \n+     * @return the current text value\n+     * @see DateTimeField#getAsText\n+     */\n+    public final String getAsText() {\n+        return getField().getAsText(getInstant().getMillis(), null);\n+    }\n+\n+    /**\n+     * Gets a short text value from the instant.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the current text value\n+     * @see DateTimeField#getAsShortText\n+     */\n+    public String getAsShortText(Locale locale) {\n+        return getField().getAsShortText(getInstant().getMillis(), locale);\n+    }\n+\n+    /**\n+     * Gets a short text value from the instant.\n+     * \n+     * @return the current text value\n+     * @see DateTimeField#getAsShortText\n+     */\n+    public final String getAsShortText() {\n+        return getAsShortText(null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the difference between this field property instant and the one\n+     * passed in, in the units of this field. The sign of the difference\n+     * matches that of compareTo. In other words, this field property's instant\n+     * is the minuend.\n+     *\n+     * @param instant the subtrahend\n+     * @return the difference in the units of this field\n+     * @see DateTimeField#getDifference\n+     */\n+    public int getDifference(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        return getField().getDifference(getInstant().getMillis(), instant.getMillis());\n+    }\n+\n+    /**\n+     * Returns the difference between this field property instant and the one\n+     * passed in, in the units of this field. The sign of the difference\n+     * matches that of compareTo. In other words, this field property's instant\n+     * is the minuend.\n+     *\n+     * @param instant the subtrahend\n+     * @return the difference in the units of this field\n+     * @see DateTimeField#getDifference\n+     */\n+    public long getDifferenceAsLong(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        return getField().getDifferenceAsLong(getInstant().getMillis(), instant.getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the duration per unit value of this field. For example, if this\n+     * field represents \"hour of day\", then the duration is an hour.\n+     *\n+     * @return the duration of this field, or UnsupportedDurationField\n+     */\n+    public DurationField getDurationField() {\n+        return getField().getDurationField();\n+    }\n+\n+    /**\n+     * Returns the range duration of this field. For example, if this field\n+     * represents \"hour of day\", then the range duration is a day.\n+     *\n+     * @return the range duration of this field, or null if field has no range\n+     */\n+    public DurationField getRangeDurationField() {\n+        return getField().getRangeDurationField();\n+    }\n+\n+    /**\n+     * Gets whether this field is leap.\n+     * \n+     * @return true if a leap field\n+     * @see DateTimeField#isLeap\n+     */\n+    public boolean isLeap() {\n+        return getField().isLeap(getInstant().getMillis());\n+    }\n+\n+    /**\n+     * Gets the amount by which this field is leap.\n+     * \n+     * @return the amount by which the field is leap\n+     * @see DateTimeField#getLeapAmount\n+     */\n+    public int getLeapAmount() {\n+        return getField().getLeapAmount(getInstant().getMillis());\n+    }\n+\n+    /**\n+     * If this field were to leap, then it would be in units described by the\n+     * returned duration. If this field doesn't ever leap, null is returned.\n+     */\n+    public DurationField getLeapDurationField() {\n+        return getField().getLeapDurationField();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the minimum value for the field ignoring the current time.\n+     * \n+     * @return the minimum value\n+     * @see DateTimeField#getMinimumValue\n+     */\n+    public int getMinimumValueOverall() {\n+        return getField().getMinimumValue();\n+    }\n+\n+    /**\n+     * Gets the minimum value for the field.\n+     * \n+     * @return the minimum value\n+     * @see DateTimeField#getMinimumValue\n+     */\n+    public int getMinimumValue() {\n+        return getField().getMinimumValue(getInstant().getMillis());\n+    }\n+\n+    /**\n+     * Gets the maximum value for the field ignoring the current time.\n+     * \n+     * @return the maximum value\n+     * @see DateTimeField#getMaximumValue\n+     */\n+    public int getMaximumValueOverall() {\n+        return getField().getMaximumValue();\n+    }\n+\n+    /**\n+     * Gets the maximum value for the field.\n+     * \n+     * @return the maximum value\n+     * @see DateTimeField#getMaximumValue\n+     */\n+    public int getMaximumValue() {\n+        return getField().getMaximumValue(getInstant().getMillis());\n+    }\n+\n+    /**\n+     * Gets the maximum text length for the field.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the maximum length\n+     * @see DateTimeField#getMaximumTextLength\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        return getField().getMaximumTextLength(locale);\n+    }\n+\n+    /**\n+     * Gets the maximum short text length for the field.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the maximum length\n+     * @see DateTimeField#getMaximumShortTextLength\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return getField().getMaximumShortTextLength(locale);\n+    }\n+\n+\n+    /**\n+     * Returns the fractional duration milliseconds of this field.\n+     *\n+     * @see DateTimeField#remainder\n+     * @return remainder duration, in milliseconds\n+     */\n+    public long remainder() {\n+        return getField().remainder(getInstant().getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compare this field to the same field on another instant.\n+     * <p>\n+     * The {@link #get()} method is used to obtain the value to compare for\n+     * this instant and the {@link ReadableInstant#get(DateTimeField)} method\n+     * is used for the specified instant.\n+     * \n+     * @param instant  the instant to compare to\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    public int compareTo(ReadableDateTime instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        int thisValue = get();\n+        int otherValue = instant.get(getField());\n+        if (thisValue < otherValue) {\n+            return -1;\n+        } else if (thisValue > otherValue) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output a debugging string.\n+     * \n+     * @return debugging string\n+     */\n+    public String toString() {\n+        return \"Property[\" + getName() + \"]\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/AbstractDuration.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * AbstractDuration provides the common behaviour for duration classes.\n+ * <p>\n+ * This class should generally not be used directly by API users. The \n+ * {@link ReadableDuration} interface should be used when different \n+ * kinds of durations are to be referenced.\n+ * <p>\n+ * AbstractDuration subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class AbstractDuration implements ReadableDuration, Serializable {\n+\n+    static final long serialVersionUID = -2110953284060001145L;\n+\n+    private static void checkSupport(DurationField field, String name) {\n+        if (!field.isSupported()) {\n+            throw new UnsupportedOperationException\n+                (\"Duration does not support field \\\"\" + name\n+                 + \"\\\". Supplied value must be zero.\");\n+        }\n+    }\n+\n+    private static void checkPrecise(DurationField field, String name) {\n+        if (!field.isPrecise()) {\n+            throw new UnsupportedOperationException\n+                (\"The field \\\"\" + name + \"\\\" is imprecise\");\n+        }\n+    }\n+\n+    private final DurationType iType;\n+\n+    private long iTotalMillis;\n+    // 0=unknown, 1=imprecise, 2=precise\n+    private int iTotalMillisState;\n+\n+    private int iYears;\n+    private int iMonths;\n+    private int iWeeks;\n+    private int iDays;\n+    private int iHours;\n+    private int iMinutes;\n+    private int iSeconds;\n+    private int iMillis;\n+\n+    /**\n+     * Copies another duration to this one.\n+     *\n+     * @throws UnsupportedOperationException if an unsupported field's value is\n+     * non-zero\n+     */\n+    public AbstractDuration(ReadableDuration duration) {\n+        // Only call a private method\n+        setDuration(iType = duration.getDurationType(), duration);\n+    }\n+\n+    /**\n+     * Copies another duration to this one.\n+     *\n+     * @param type use a different DurationType\n+     * @throws UnsupportedOperationException if an unsupported field's value is\n+     * non-zero\n+     */\n+    public AbstractDuration(DurationType type, ReadableDuration duration) {\n+        // Only call a private method\n+        setDuration(iType = type, duration);\n+    }\n+\n+    /**\n+     * Create a duration from a set of field values.\n+     *\n+     * @param type determines which set of fields this duration supports\n+     * @param years amount of years in this duration, which must be zero if\n+     * unsupported.\n+     * @param months amount of months in this duration, which must be zero if\n+     * unsupported.\n+     * @param weeks amount of weeks in this duration, which must be zero if\n+     * unsupported.\n+     * @param days amount of days in this duration, which must be zero if\n+     * unsupported.\n+     * @param hours amount of hours in this duration, which must be zero if\n+     * unsupported.\n+     * @param minutes amount of minutes in this duration, which must be zero if\n+     * unsupported.\n+     * @param seconds amount of seconds in this duration, which must be zero if\n+     * unsupported.\n+     * @param millis amount of milliseconds in this duration, which must be\n+     * zero if unsupported.\n+     * @throws UnsupportedOperationException if an unsupported field's value is\n+     * non-zero\n+     */\n+    public AbstractDuration(DurationType type,\n+                            int years, int months, int weeks, int days,\n+                            int hours, int minutes, int seconds, int millis) {\n+        // Only call a private method\n+        setDuration(iType = type, years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param type determines which set of fields this duration supports\n+     * @param startInstant interval start, in milliseconds\n+     * @param endInstant interval end, in milliseconds\n+     */\n+    public AbstractDuration(DurationType type, long startInstant, long endInstant) {\n+        // Only call a private method\n+        setTotalMillis(iType = type, startInstant, endInstant);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param type determines which set of fields this duration supports\n+     * @param startInstant interval start\n+     * @param endInstant interval end\n+     */\n+    public AbstractDuration(DurationType type,\n+                            ReadableInstant startInstant, ReadableInstant  endInstant) {\n+        // Only call a private method\n+        setTotalMillis(iType = type, startInstant.getMillis(), endInstant.getMillis());\n+    }\n+\n+    /**\n+     * Creates a duration from the given millisecond duration. If any supported\n+     * fields are imprecise, an UnsupportedOperationException is thrown. The\n+     * exception to this is when the specified duration is zero.\n+     *\n+     * @param type determines which set of fields this duration supports\n+     * @param duration  the duration, in milliseconds\n+     * @throws UnsupportedOperationException if any fields are imprecise\n+     */\n+    public AbstractDuration(DurationType type, long duration) {\n+        // Only call a private method\n+        setTotalMillis(iType = type, duration);\n+    }\n+\n+    /**\n+     * Returns the object which defines which fields this duration supports.\n+     */\n+    public final DurationType getDurationType() {\n+        return iType;\n+    }\n+\n+    /**\n+     * Gets the total length of this duration in milliseconds, \n+     * failing if the duration is imprecise.\n+     *\n+     * @return the total length of the duration in milliseconds.\n+     * @throws IllegalStateException if the duration is imprecise\n+     */\n+    public final long getTotalMillis() {\n+        int state = iTotalMillisState;\n+        if (state == 0) {\n+            state = updateTotalMillis();\n+        }\n+        if (state != 2) {\n+            throw new IllegalStateException(\"Duration is imprecise\");\n+        }\n+        return iTotalMillis;\n+    }\n+\n+    /**\n+     * Is this duration a precise length of time, or descriptive.\n+     * <p>\n+     * A precise duration could include millis, seconds, minutes or hours.\n+     * However, days, weeks, months and years can vary in length, resulting in\n+     * an imprecise duration.\n+     * <p>\n+     * An imprecise duration can be made precise by pairing it with a\n+     * date in a {@link ReadableInterval}.\n+     *\n+     * @return true if the duration is precise\n+     */\n+    public final boolean isPrecise() {\n+        int state = iTotalMillisState;\n+        if (state == 0) {\n+            state = updateTotalMillis();\n+        }\n+        return state == 2;\n+    }\n+\n+    /**\n+     * Walks through the field values, determining total millis and whether\n+     * this duration is precise.\n+     *\n+     * @return new state\n+     */\n+    private int updateTotalMillis() {\n+        final DurationType type = iType;\n+\n+        boolean isPrecise = true;\n+        long totalMillis = 0;\n+\n+        DurationField field;\n+        int value;\n+\n+        if ((value = iYears) != 0) {\n+            field = type.years();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis += field.getMillis(value);\n+            }\n+        }\n+        if ((value = iMonths) != 0) {\n+            field = type.months();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis += field.getMillis(value);\n+            }\n+        }\n+        if ((value = iWeeks) != 0) {\n+            field = type.weeks();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis += field.getMillis(value);\n+            }\n+        }\n+        if ((value = iDays) != 0) {\n+            field = type.days();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis += field.getMillis(value);\n+            }\n+        }\n+        if ((value = iHours) != 0) {\n+            field = type.hours();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis += field.getMillis(value);\n+            }\n+        }\n+        if ((value = iMinutes) != 0) {\n+            field = type.minutes();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis += field.getMillis(value);\n+            }\n+        }\n+        if ((value = iSeconds) != 0) {\n+            field = type.seconds();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis += field.getMillis(value);\n+            }\n+        }\n+        if ((value = iMillis) != 0) {\n+            field = type.millis();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis += field.getMillis(value);\n+            }\n+        }\n+\n+        if (isPrecise) {\n+            iTotalMillis = totalMillis;\n+            return iTotalMillisState = 2;\n+        } else {\n+            iTotalMillis = totalMillis;\n+            return iTotalMillisState = 1;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds this duration to the given instant, returning a new value.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scaler of minus one.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n+     * duration to\n+     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @return milliseconds value plus this duration times scalar\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    public final long addTo(long instant, int scalar) {\n+        return addTo(instant, scalar, null);\n+    }\n+\n+    /**\n+     * Adds this duration to the given instant, returning a new value.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scaler of minus one.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n+     * duration to\n+     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @param chrono  override the duration's chronology, unless null is passed in\n+     * @return milliseconds value plus this duration times scalar\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    public final long addTo(long instant, int scalar, Chronology chrono) {\n+        if (isPrecise()) {\n+            return instant += getTotalMillis() * scalar;\n+        }\n+\n+        DurationType type = iType;\n+        if (chrono != null) {\n+            type = type.withChronology(chrono);\n+        }\n+\n+        int value;\n+\n+        if ((value = scaleValue(iYears, scalar)) != 0) {\n+            instant = type.years().add(instant, value);\n+        }\n+        if ((value = scaleValue(iMonths, scalar)) != 0) {\n+            instant = type.months().add(instant, value);\n+        }\n+        if ((value = scaleValue(iWeeks, scalar)) != 0) {\n+            instant = type.weeks().add(instant, value);\n+        }\n+        if ((value = scaleValue(iDays, scalar)) != 0) {\n+            instant = type.days().add(instant, value);\n+        }\n+        if ((value = scaleValue(iHours, scalar)) != 0) {\n+            instant = type.hours().add(instant, value);\n+        }\n+        if ((value = scaleValue(iMinutes, scalar)) != 0) {\n+            instant = type.minutes().add(instant, value);\n+        }\n+        if ((value = scaleValue(iSeconds, scalar)) != 0) {\n+            instant = type.seconds().add(instant, value);\n+        }\n+        if ((value = scaleValue(iMillis, scalar)) != 0) {\n+            instant = type.millis().add(instant, value);\n+        }\n+\n+        return instant;\n+    }\n+\n+    private static int scaleValue(int value, int scalar) {\n+        switch (scalar) {\n+        case -1:\n+            return -value;\n+        case 0:\n+            return 0;\n+        case 1:\n+            return value;\n+        default:\n+            return value * scalar;\n+        }\n+    }\n+\n+    /**\n+     * Adds this duration to the given instant, returning a new Instant.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scaler of minus one.\n+     *\n+     * @param instant  the instant to add the duration to\n+     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @return instant with the original value plus this duration times scalar\n+     * @throws IllegalArgumentException if the instant is null\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    public final ReadableInstant addTo(ReadableInstant instant, int scalar) {\n+        return instant.toCopy(addTo(instant.getMillis(), scalar));\n+    }\n+\n+    /**\n+     * Adds this duration into the given mutable instant.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scaler of minus one.\n+     *\n+     * @param instant  the instant to update with the added duration\n+     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @throws IllegalArgumentException if the instant is null\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    public final void addInto(ReadWritableInstant instant, int scalar) {\n+        instant.setMillis(addTo(instant.getMillis(), scalar));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the years field part of the duration.\n+     * \n+     * @return the number of years in the duration, zero if unsupported\n+     */\n+    public final int getYears() {\n+        return iYears;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the months field part of the duration.\n+     * \n+     * @return the number of months in the duration, zero if unsupported\n+     */\n+    public final int getMonths() {\n+        return iMonths;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the weeks field part of the duration.\n+     * \n+     * @return the number of weeks in the duration, zero if unsupported\n+     */\n+    public final int getWeeks() {\n+        return iWeeks;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the days field part of the duration.\n+     * \n+     * @return the number of days in the duration, zero if unsupported\n+     */\n+    public final int getDays() {\n+        return iDays;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the hours field part of the duration.\n+     * \n+     * @return the number of hours in the duration, zero if unsupported\n+     */\n+    public final int getHours() {\n+        return iHours;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the minutes field part of the duration.\n+     * \n+     * @return the number of minutes in the duration, zero if unsupported\n+     */\n+    public final int getMinutes() {\n+        return iMinutes;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the seconds field part of the duration.\n+     * \n+     * @return the number of seconds in the duration, zero if unsupported\n+     */\n+    public final int getSeconds() {\n+        return iSeconds;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the millis field part of the duration.\n+     * \n+     * @return the number of millis in the duration, zero if unsupported\n+     */\n+    public final int getMillis() {\n+        return iMillis;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this object as an immutable Duration. This can be useful if you\n+     * don't trust the implementation of the interface to be well-behaved, or\n+     * to get a guaranteed immutable object.\n+     * \n+     * @return a Duration using the same field set and values\n+     */\n+    public final Duration toDuration() {\n+        if (this instanceof Duration) {\n+            return (Duration) this;\n+        }\n+        return new Duration(this);\n+    }\n+\n+    /**\n+     * Get this object as a MutableDuration.\n+     * \n+     * @return a MutableDuration using the same field set and values\n+     */\n+    public final MutableDuration toMutableDuration() {\n+        return new MutableDuration(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this duration with the specified duration, which can only be\n+     * performed if both are precise.\n+     *\n+     * @param obj  a precise duration to check against\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the given object is not supported\n+     * @throws IllegalStateException if either duration is imprecise\n+     */\n+    public int compareTo(Object obj) {\n+        ReadableDuration thisDuration = (ReadableDuration) this;\n+        ReadableDuration otherDuration = (ReadableDuration) obj;\n+\n+        long thisMillis = thisDuration.getTotalMillis();\n+        long otherMillis = otherDuration.getTotalMillis();\n+        \n+        // cannot do (thisMillis - otherMillis) as it can overflow\n+        if (thisMillis < otherMillis) {\n+            return -1;\n+        }\n+        if (thisMillis > otherMillis) {\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Is the length of this duration equal to the duration passed in.\n+     * Both durations must be precise.\n+     *\n+     * @param duration  another duration to compare to\n+     * @return true if this duration is equal to than the duration passed in\n+     * @throws IllegalArgumentException if the duration is null\n+     * @throws IllegalStateException if either duration is imprecise\n+     */\n+    public boolean isEqual(ReadableDuration duration) {\n+        if (duration == null) {\n+            throw new IllegalArgumentException(\"The duration must not be null\");\n+        }\n+        return compareTo(duration) == 0;\n+    }\n+\n+    /**\n+     * Is the length of this duration longer than the duration passed in.\n+     * Both durations must be precise.\n+     *\n+     * @param duration  another duration to compare to\n+     * @return true if this duration is equal to than the duration passed in\n+     * @throws IllegalArgumentException if the duration is null\n+     * @throws IllegalStateException if either duration is imprecise\n+     */\n+    public boolean isLongerThan(ReadableDuration duration) {\n+        if (duration == null) {\n+            throw new IllegalArgumentException(\"The duration must not be null\");\n+        }\n+        return compareTo(duration) > 0;\n+    }\n+\n+    /**\n+     * Is the length of this duration shorter than the duration passed in.\n+     * Both durations must be precise.\n+     *\n+     * @param duration  another duration to compare to\n+     * @return true if this duration is equal to than the duration passed in\n+     * @throws IllegalArgumentException if the duration is null\n+     * @throws IllegalStateException if either duration is imprecise\n+     */\n+    public boolean isShorterThan(ReadableDuration duration) {\n+        if (duration == null) {\n+            throw new IllegalArgumentException(\"The duration must not be null\");\n+        }\n+        return compareTo(duration) < 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the value of each field. All ReadableDuration instances are accepted.\n+     * <p>\n+     * To compare two durations for absolute duration (ie. millisecond duration\n+     * ignoring the fields), use {@link #isEqual(ReadableDuration)} or\n+     * {@link #compareTo(Object)}.\n+     *\n+     * @param readableDuration  a readable duration to check against\n+     * @return true if all the field values are equal, false if\n+     *  not or the duration is null or of an incorrect type\n+     */\n+    public boolean equals(Object readableDuration) {\n+        if (this == readableDuration) {\n+            return true;\n+        }\n+        if (readableDuration instanceof ReadableDuration == false) {\n+            return false;\n+        }\n+        ReadableDuration other = (ReadableDuration) readableDuration;\n+        DurationType type = getDurationType();\n+        if (type.equals(other.getDurationType()) == false) {\n+            return false;\n+        }\n+        return getYears() == other.getYears()\n+            && getMonths() == other.getMonths()\n+            && getWeeks() == other.getWeeks()\n+            && getDays() == other.getDays()\n+            && getHours() == other.getHours()\n+            && getMinutes() == other.getMinutes()\n+            && getSeconds() == other.getSeconds()\n+            && getMillis() == other.getMillis();\n+    }\n+\n+    /**\n+     * Gets a hash code for the duration that is compatable with the \n+     * equals method.\n+     *\n+     * @return a hash code\n+     */\n+    public int hashCode() {\n+        int hash = getDurationType().hashCode();\n+        hash = 53 * hash + getYears();\n+        hash = 53 * hash + getMonths();\n+        hash = 53 * hash + getWeeks();\n+        hash = 53 * hash + getDays();\n+        hash = 53 * hash + getHours();\n+        hash = 53 * hash + getMinutes();\n+        hash = 53 * hash + getSeconds();\n+        hash = 53 * hash + getMillis();\n+        return hash;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"P6H3M5S\" represents 6 hours, 3 minutes, 5 seconds.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    // TODO\n+    //public String toString();\n+\n+    /**\n+     * Sets all the fields in one go from another ReadableDuration.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param duration  the duration to set\n+     * @throws IllegalArgumentException if duration is null\n+     * @throws UnsupportedOperationException if an unsupported field's value is\n+     * non-zero\n+     */\n+    protected void setDuration(ReadableDuration duration) {\n+        setDuration(iType, duration);\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     */\n+    private void setDuration(DurationType type, ReadableDuration duration) {\n+        if (duration == null) {\n+            throw new IllegalArgumentException(\"The duration must not be null\");\n+        }\n+        setDuration(type,\n+                    duration.getYears(), duration.getMonths(),\n+                    duration.getWeeks(), duration.getDays(),\n+                    duration.getHours(), duration.getMinutes(),\n+                    duration.getSeconds(), duration.getMillis());\n+    }\n+\n+    /**\n+     * Sets all the fields in one go.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param years amount of years in this duration, which must be zero if\n+     * unsupported.\n+     * @param months amount of months in this duration, which must be zero if\n+     * unsupported.\n+     * @param weeks amount of weeks in this duration, which must be zero if\n+     * unsupported.\n+     * @param days amount of days in this duration, which must be zero if\n+     * unsupported.\n+     * @param hours amount of hours in this duration, which must be zero if\n+     * unsupported.\n+     * @param minutes amount of minutes in this duration, which must be zero if\n+     * unsupported.\n+     * @param seconds amount of seconds in this duration, which must be zero if\n+     * unsupported.\n+     * @param millis amount of milliseconds in this duration, which must be\n+     * zero if unsupported.\n+     * @throws UnsupportedOperationException if an unsupported field's value is\n+     * non-zero\n+     */\n+    protected void setDuration(int years, int months, int weeks, int days,\n+                               int hours, int minutes, int seconds, int millis) {\n+        setDuration(iType, years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     */\n+    private void setDuration(DurationType type,\n+                             int years, int months, int weeks, int days,\n+                             int hours, int minutes, int seconds, int millis) {\n+\n+        if (years != 0) {\n+            checkSupport(type.years(), \"years\");\n+        }\n+        if (months != 0) {\n+            checkSupport(type.months(), \"months\");\n+        }\n+        if (weeks != 0) {\n+            checkSupport(type.weeks(), \"weeks\");\n+        }\n+        if (days != 0) {\n+            checkSupport(type.days(), \"days\");\n+        }\n+        if (hours != 0) {\n+            checkSupport(type.hours(), \"hours\");\n+        }\n+        if (minutes != 0) {\n+            checkSupport(type.minutes(), \"minutes\");\n+        }\n+        if (seconds != 0) {\n+            checkSupport(type.seconds(), \"seconds\");\n+        }\n+        if (millis != 0) {\n+            checkSupport(type.millis(), \"millis\");\n+        }\n+\n+        iYears = years;\n+        iMonths = months;\n+        iWeeks = weeks;\n+        iDays = days;\n+        iHours = hours;\n+        iMinutes = minutes;\n+        iSeconds = seconds;\n+        iMillis = millis;\n+\n+        iTotalMillisState = 0;\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond interval.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param startInstant interval start, in milliseconds\n+     * @param endInstant interval end, in milliseconds\n+     */\n+    protected void setTotalMillis(long startInstant, long endInstant) {\n+        setTotalMillis(iType, startInstant, endInstant);\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     *\n+     * @param startInstant interval start, in milliseconds\n+     * @param endInstant interval end, in milliseconds\n+     */\n+    private void setTotalMillis(DurationType type, long startInstant, long endInstant) {\n+        iTotalMillis = endInstant - startInstant;\n+\n+        boolean isPrecise = true;\n+\n+        DurationField field;\n+\n+        if (!(field = type.years()).isSupported()) {\n+            iYears = 0;\n+        } else if ((iYears = field.getDifference(endInstant, startInstant)) != 0) {\n+            isPrecise &= field.isPrecise();\n+            startInstant = field.add(startInstant, iYears);\n+        }\n+\n+        if (!(field = type.months()).isSupported()) {\n+            iMonths = 0;\n+        } else if ((iMonths = field.getDifference(endInstant, startInstant)) != 0) {\n+            isPrecise &= field.isPrecise();\n+            startInstant = field.add(startInstant, iMonths);\n+        }\n+    \n+        if (!(field = type.weeks()).isSupported()) {\n+            iWeeks = 0;\n+        } else if ((iWeeks = field.getDifference(endInstant, startInstant)) != 0) {\n+            isPrecise &= field.isPrecise();\n+            startInstant = field.add(startInstant, iWeeks);\n+        }\n+\n+        if (!(field = type.days()).isSupported()) {\n+            iDays = 0;\n+        } else if ((iDays = field.getDifference(endInstant, startInstant)) != 0) {\n+            isPrecise &= field.isPrecise();\n+            startInstant = field.add(startInstant, iDays);\n+        }\n+\n+        if (!(field = type.hours()).isSupported()) {\n+            iHours = 0;\n+        } else if ((iHours = field.getDifference(endInstant, startInstant)) != 0) {\n+            isPrecise &= field.isPrecise();\n+            startInstant = field.add(startInstant, iHours);\n+        }\n+        \n+        if (!(field = type.minutes()).isSupported()) {\n+            iMinutes = 0;\n+        } else if ((iMinutes = field.getDifference(endInstant, startInstant)) != 0) {\n+            isPrecise &= field.isPrecise();\n+            startInstant = field.add(startInstant, iMinutes);\n+        }\n+        \n+        if (!(field = type.seconds()).isSupported()) {\n+            iSeconds = 0;\n+        } else if ((iSeconds = field.getDifference(endInstant, startInstant)) != 0) {\n+            isPrecise &= field.isPrecise();\n+            startInstant = field.add(startInstant, iSeconds);\n+        }\n+\n+        if (!(field = type.millis()).isSupported()) {\n+            iMillis = 0;\n+        } else if ((iMillis = field.getDifference(endInstant, startInstant)) != 0) {\n+            isPrecise &= field.isPrecise();\n+            startInstant = field.add(startInstant, iMillis);\n+        }\n+\n+        iTotalMillisState = isPrecise ? 2 : 1;\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond duration. If any\n+     * supported fields are imprecise, an UnsupportedOperationException is\n+     * thrown. The exception to this is when the specified duration is zero.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param duration  the duration, in milliseconds\n+     * @throws UnsupportedOperationException if any fields are imprecise\n+     */\n+    protected void setTotalMillis(long duration) {\n+        setTotalMillis(iType, duration);\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @throws UnsupportedOperationException if any fields are imprecise\n+     */\n+    private void setTotalMillis(DurationType type, final long duration) {\n+        if (duration == 0) {\n+            iTotalMillis = duration;\n+            iTotalMillisState = 2;\n+\n+            iYears = 0;\n+            iMonths = 0;\n+            iWeeks = 0;\n+            iDays = 0;\n+            iHours = 0;\n+            iMinutes = 0;\n+            iSeconds = 0;\n+            iMillis = 0;\n+\n+            return;\n+        }\n+\n+        long startInstant = 0;\n+\n+        int years, months, weeks, days, hours, minutes, seconds, millis;\n+        DurationField field;\n+\n+        if (!(field = type.years()).isSupported()) {\n+            years = 0;\n+        } else {\n+            checkPrecise(field, \"years\");\n+            years = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, years);\n+        }\n+\n+        if (!(field = type.months()).isSupported()) {\n+            months = 0;\n+        } else {\n+            checkPrecise(field, \"months\");\n+            months = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, months);\n+        }\n+\n+        if (!(field = type.weeks()).isSupported()) {\n+            weeks = 0;\n+        } else {\n+            checkPrecise(field, \"weeks\");\n+            weeks = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, weeks);\n+        }\n+\n+        if (!(field = type.days()).isSupported()) {\n+            days = 0;\n+        } else {\n+            checkPrecise(field, \"days\");\n+            days = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, days);\n+        }\n+\n+        if (!(field = type.hours()).isSupported()) {\n+            hours = 0;\n+        } else {\n+            checkPrecise(field, \"hours\");\n+            hours = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, hours);\n+        }\n+\n+        if (!(field = type.minutes()).isSupported()) {\n+            minutes = 0;\n+        } else {\n+            checkPrecise(field, \"minutes\");\n+            minutes = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, minutes);\n+        }\n+\n+        if (!(field = type.seconds()).isSupported()) {\n+            seconds = 0;\n+        } else {\n+            checkPrecise(field, \"seconds\");\n+            seconds = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, seconds);\n+        }\n+\n+        if (!(field = type.millis()).isSupported()) {\n+            millis = 0;\n+        } else {\n+            checkPrecise(field, \"millis\");\n+            millis = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, millis);\n+        }\n+\n+        iTotalMillis = duration;\n+        iTotalMillisState = 2;\n+\n+        iYears = years;\n+        iMonths = months;\n+        iWeeks = weeks;\n+        iDays = days;\n+        iHours = hours;\n+        iMinutes = minutes;\n+        iSeconds = seconds;\n+        iMillis = millis;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a millisecond duration to this one. As a side-effect, all field\n+     * values are normalized.\n+     * \n+     * @param duration  the duration, in milliseconds\n+     * @throws IllegalStateException if the duration is imprecise\n+     */\n+    protected void add(long duration) {\n+        setTotalMillis(getTotalMillis() + duration);\n+    }\n+    \n+    /**\n+     * Adds a duration to this one.\n+     * \n+     * @param duration  the duration to add\n+     * @throws IllegalArgumentException if the duration is null\n+     * @throws IllegalStateException if the duration is imprecise\n+     */\n+    protected void add(ReadableDuration duration) {\n+        if (duration == null) {\n+            throw new IllegalArgumentException(\"The duration must not be null\");\n+        }\n+        add(duration.getTotalMillis());\n+    }\n+    \n+    /**\n+     * Normalizes all the field values in this duration.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     *\n+     * @throws IllegalStateException if this duration is imprecise\n+     */\n+    protected void normalize() {\n+        setTotalMillis(getTotalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of years of the duration.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void setYears(int years) {\n+        if (years != iYears) {\n+            if (years != 0) {\n+                checkSupport(iType.years(), \"years\");\n+            }\n+            iYears = years;\n+            iTotalMillisState = 0;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified years to the number of years in the duration.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void addYears(int years) {\n+        setYears(getYears() + years);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of months of the duration.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void setMonths(int months) {\n+        if (months != iMonths) {\n+            if (months != 0) {\n+                checkSupport(iType.months(), \"months\");\n+            }\n+            iMonths = months;\n+            iTotalMillisState = 0;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified months to the number of months in the duration.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void addMonths(int months) {\n+        setMonths(getMonths() + months);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of weeks of the duration.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void setWeeks(int weeks) {\n+        if (weeks != iWeeks) {\n+            if (weeks != 0) {\n+                checkSupport(iType.weeks(), \"weeks\");\n+            }\n+            iWeeks = weeks;\n+            iTotalMillisState = 0;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified weeks to the number of weeks in the duration.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void addWeeks(int weeks) {\n+        setWeeks(getWeeks() + weeks);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of days of the duration.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void setDays(int days) {\n+        if (days != iDays) {\n+            if (days != 0) {\n+                checkSupport(iType.days(), \"days\");\n+            }\n+            iDays = days;\n+            iTotalMillisState = 0;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified days to the number of days in the duration.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void addDays(int days) {\n+        setDays(getDays() + days);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of hours of the duration.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void setHours(int hours) {\n+        if (hours != iHours) {\n+            if (hours != 0) {\n+                checkSupport(iType.hours(), \"hours\");\n+            }\n+            iHours = hours;\n+            iTotalMillisState = 0;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified hours to the number of hours in the duration.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void addHours(int hours) {\n+        setHours(getHours() + hours);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of minutes of the duration.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void setMinutes(int minutes) {\n+        if (minutes != iMinutes) {\n+            if (minutes != 0) {\n+                checkSupport(iType.minutes(), \"minutes\");\n+            }\n+            iMinutes = minutes;\n+            iTotalMillisState = 0;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified minutes to the number of minutes in the duration.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void addMinutes(int minutes) {\n+        setMinutes(getMinutes() + minutes);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of seconds of the duration.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void setSeconds(int seconds) {\n+        if (seconds != iSeconds) {\n+            if (seconds != 0) {\n+                checkSupport(iType.seconds(), \"seconds\");\n+            }\n+            iSeconds = seconds;\n+            iTotalMillisState = 0;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified seconds to the number of seconds in the duration.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void addSeconds(int seconds) {\n+        setSeconds(getSeconds() + seconds);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of millis of the duration.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void setMillis(int millis) {\n+        if (millis != iMillis) {\n+            if (millis != 0) {\n+                checkSupport(iType.millis(), \"millis\");\n+            }\n+            iMillis = millis;\n+            iTotalMillisState = 0;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified millis to the number of millis in the duration.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void addMillis(int millis) {\n+        setMillis(getMillis() + millis);\n+    }\n+\n+}\n+\n--- a/JodaTime/src/java/org/joda/time/AbstractInstant.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractInstant.java\n  */\n package org.joda.time;\n \n-import java.io.Serializable;\n import java.util.Calendar;\n import java.util.Date;\n import java.util.GregorianCalendar;\n import java.util.Locale;\n+import org.joda.time.chrono.iso.ISOChronology;\n \n /**\n- * AbstractInstant provides the common behaviour for immutable time classes.\n+ * AbstractInstant provides the common behaviour for instant classes.\n  * <p>\n  * This class has no concept of a chronology, all methods work on the\n  * millisecond instant.\n  * This class should generally not be used directly by API users. The \n  * {@link ReadableInstant} interface should be used when different \n  * kinds of date/time objects are to be referenced.\n+ * <p>\n+ * AbstractInstant itself is thread-safe and immutable, but subclasses may be\n+ * mutable and not thread-safe.\n  *\n  * @author Stephen Colebourne\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public abstract class AbstractInstant\n-        implements ReadableInstant, Serializable {\n+public abstract class AbstractInstant implements ReadableInstant {\n \n     /**\n      * Constructor.\n      */\n-    public AbstractInstant() {\n+    protected AbstractInstant() {\n         super();\n     }\n \n      */\n     public final DateTimeZone getDateTimeZone() {\n         Chronology chrono = getChronology();\n-        return chrono != null ? chrono.getDateTimeZone() : null;\n+        return (chrono != null ? chrono.getDateTimeZone() : null);\n     }\n \n     /**\n      * The returned object will be a new instance of the implementation.\n      * Immutable subclasses may return <code>this</code> if appropriate.\n      *\n-     * @param millis  the new millis, from 1970-01-01T00:00:00Z\n+     * @param instant  the new instant, from 1970-01-01T00:00:00Z\n      * @param chrono  the new chronology\n      * @return a new instance of this class\n-     * @throws IllegalArgumentException if the chronology is null\n-     */\n-    protected abstract ReadableInstant create(long millis, Chronology chrono);\n+     */\n+    protected abstract ReadableInstant create(long instant, Chronology chrono);\n     \n     // Accessors\n     //-----------------------------------------------------------------------\n     /**\n      * Gets a copy of this instant with different millis.\n      * <p>\n-     * The returned object will be a new instance of <code>DateTime</code>.\n+     * The returned object will be a new instance of this type.\n      * Only the millis will change, the chronology and time zone are kept.\n      * If the millis is the same, <code>this</code> will be returned.\n      *\n     /**\n      * Gets a copy of this instant with a different chronology.\n      * <p>\n-     * The returned object will be a new instance of <code>DateTime</code>.\n+     * The returned object will be a new instance of this type.\n      * Only the chronology will change, the millis are kept.\n      * If the chronology is the same, <code>this</code> will be returned.\n      *\n      * @param newChronology  the new chronology\n      * @return a copy of this instant with a different chronology\n-     * @throws IllegalArgumentException if the chronology is null\n      */\n     public final ReadableInstant toCopy(Chronology newChronology) {\n         return create(getMillis(), newChronology);\n     }\n-    \n+\n     // Conversion\n     //-----------------------------------------------------------------------\n     /**\n      * Get this object as an Instant.\n      * \n-     * @return an Instant using the same millis\n+     * @return an Instant using the same millis, unless partially specified\n      */\n     public final Instant toInstant() {\n         if (this instanceof Instant) {\n     }\n \n     /**\n+     * Get this object as an Instant, using the given base instant to supply\n+     * missing field values.\n+     * \n+     * @param base source of missing fields\n+     * @return a new Instant\n+     */\n+    public final Instant toInstant(ReadableInstant base) {\n+        return new Instant(getMillis(base, null));\n+    }\n+\n+    /**\n+     * Get this object as a DateTime.\n+     * \n+     * @return a DateTime using the same millis, unless partially specified\n+     */\n+    public final DateTime toDateTime() {\n+        if (this instanceof DateTime) {\n+            return (DateTime) this;\n+        }\n+        return new DateTime(this);\n+    }\n+\n+    /**\n+     * Get this object as a DateTime.\n+     * \n+     * @param zone time zone to apply, or default if null\n+     * @return a DateTime using the same millis, unless partially specified\n+     */\n+    public final DateTime toDateTime(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (this instanceof DateTime && getDateTimeZone() == zone) {\n+            return (DateTime) this;\n+        }\n+        return new DateTime(this, zone);\n+    }\n+\n+    /**\n+     * Get this object as a DateTime.\n+     * \n+     * @param chronology chronology to apply, or ISOChronology if null\n+     * @return a DateTime using the same millis, unless partially specified\n+     */\n+    public final DateTime toDateTime(Chronology chronology) {\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        if (this instanceof DateTime && getChronology() == chronology) {\n+            return (DateTime) this;\n+        }\n+        return new DateTime(this, chronology);\n+    }\n+\n+    /**\n+     * Convert this object into a DateTime, using the given base instant to\n+     * supply missing field values and time zone.\n+     * \n+     * @param base source of missing fields\n+     * @return a new DateTime\n+     */\n+    public final DateTime toDateTime(ReadableInstant base) {\n+        if (base == null) {\n+            return new DateTime(this);\n+        }\n+        DateTimeZone zone = base.getDateTimeZone();\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        return new DateTime(getMillis(base), getChronology().withDateTimeZone(zone));\n+    }\n+\n+    /**\n+     * Convert this object into a DateTime, using the given base instant to\n+     * supply missing field values.\n+     * \n+     * @param base source of missing fields\n+     * @param zone  time zone to apply, or default if null\n+     * @return a new DateTime\n+     */\n+    public final DateTime toDateTime(ReadableInstant base, DateTimeZone zone) {\n+        if (base == null) {\n+            return new DateTime(this, zone);\n+        }\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        return new DateTime(getMillis(base, zone), getChronology().withDateTimeZone(zone));\n+    }\n+\n+    /**\n+     * Convert this object into a DateTime, using the given base instant to\n+     * supply missing field values.\n+     * \n+     * @param base source of missing fields\n+     * @param chronology  chronology to apply, or ISOChronology if null\n+     * @return a new DateTime\n+     */\n+    public final DateTime toDateTime(ReadableInstant base, Chronology chronology) {\n+        if (base == null) {\n+            return new DateTime(this, chronology);\n+        }\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        return new DateTime(getMillis(base, chronology.getDateTimeZone()), chronology);\n+    }\n+\n+    /**\n+     * Get this object as a trusted ISO immutable DateTime. The purpose of\n+     * this method is to guarantee that an externally received DateTime\n+     * object does not have any backdoors that allow it to be modified.\n+     * <p>\n+     * If this object is already a DateTime, whose chronology is\n+     * {@link ISOChronology ISO}, and the time zone came from the default\n+     * {@link org.joda.time.tz.Provider provider}, then this object is cast to\n+     * a DateTime and returned. Otherwise, a new trusted DateTime is returned.\n+     * \n+     * @return a trusted ISO DateTime using the same millis, unless partially specified\n+     * @throws IllegalArgumentException if the time zone is not trusted, and\n+     * no matching trusted time zone can be found.\n+     */\n+    public final DateTime toTrustedISODateTime() {\n+        DateTimeZone zone = getDateTimeZone();\n+        if (zone == null) {\n+            return new DateTime(this, (Chronology)null);\n+        }\n+\n+        DateTimeZone trusted = DateTimeZone.getInstance(zone.getID());\n+        \n+        if (zone == trusted && this instanceof DateTime\n+            && getChronology() instanceof ISOChronology) {\n+            return (DateTime) this;\n+        }\n+        \n+        return new DateTime(this, ISOChronology.getInstance(trusted));\n+    }\n+\n+    // NOTE: Although the toMutableDateTime methods could check to see if this\n+    // is already a MutableDateTime and return this casted, it makes it too\n+    // easy to mistakenly modify ReadableDateTime input parameters. Always\n+    // returning a copy prevents this.\n+\n+    /**\n+     * Get this object as a MutableDateTime.\n+     * \n+     * @return a MutableDateTime using the same millis, unless partially specified\n+     */\n+    public final MutableDateTime toMutableDateTime() {\n+        return new MutableDateTime(this);\n+    }\n+\n+    /**\n+     * Get this object as a MutableDateTime.\n+     * \n+     * @param zone time zone to apply, or default if null\n+     * @return a MutableDateTime using the same millis, unless partially specified\n+     */\n+    public final MutableDateTime toMutableDateTime(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        return new MutableDateTime(this, zone);\n+    }\n+\n+    /**\n+     * Get this object as a MutableDateTime.\n+     * \n+     * @param chronology chronology to apply, or ISOChronology if null\n+     * @return a MutableDateTime using the same millis, unless partially specified\n+     */\n+    public final MutableDateTime toMutableDateTime(Chronology chronology) {\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        return new MutableDateTime(this, chronology);\n+    }\n+\n+    /**\n+     * Convert this object into a MutableDateTime, using the given base instant\n+     * to supply missing field values and time zone.\n+     * \n+     * @param base source of missing fields\n+     * @return a new MutableDateTime\n+     */\n+    public final MutableDateTime toMutableDateTime(ReadableInstant base) {\n+        if (base == null) {\n+            return new MutableDateTime(this);\n+        }\n+        DateTimeZone zone = base.getDateTimeZone();\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        return new MutableDateTime(getMillis(base), getChronology().withDateTimeZone(zone));\n+    }\n+\n+    /**\n+     * Convert this object into a MutableDateTime, using the given base instant\n+     * to supply missing field values.\n+     * \n+     * @param base source of missing fields\n+     * @param zone  time zone to apply, or default if null\n+     * @return a new MutableDateTime\n+     */\n+    public final MutableDateTime toMutableDateTime(ReadableInstant base, DateTimeZone zone) {\n+        if (base == null) {\n+            return new MutableDateTime(this, zone);\n+        }\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        return new MutableDateTime(getMillis(base, zone), getChronology().withDateTimeZone(zone));\n+    }\n+\n+    /**\n+     * Convert this object into a MutableDateTime, using the given base instant\n+     * to supply missing field values.\n+     * \n+     * @param base source of missing fields\n+     * @param chronology  chronology to apply, or ISOChronology if null\n+     * @return a new MutableDateTime\n+     */\n+    public final MutableDateTime toMutableDateTime(ReadableInstant base, Chronology chronology) {\n+        if (base == null) {\n+            return new MutableDateTime(this, chronology);\n+        }\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        return new MutableDateTime(getMillis(base, chronology.getDateTimeZone()), chronology);\n+    }\n+\n+    /**\n+     * Get this object as a DateOnly.\n+     * \n+     * @return a DateOnly using the same millis, unless partially specified\n+     */\n+    public final DateOnly toDateOnly() {\n+        if (this instanceof DateOnly) {\n+            return (DateOnly) this;\n+        }\n+        return new DateOnly(this);\n+    }\n+\n+    /**\n+     * Get this object as a DateOnly.\n+     * \n+     * @param chronology chronology to apply, or ISOChronology if null\n+     * @return a DateOnly using the same millis, unless partially specified\n+     */\n+    public final DateOnly toDateOnly(Chronology chronology) {\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        if (this instanceof DateOnly) {\n+            DateOnly d = (DateOnly) this;\n+            if (d.getChronology() == chronology.withUTC()) {\n+                return d;\n+            }\n+        }\n+        return new DateOnly(this, chronology);\n+    }\n+\n+    /**\n+     * Get this object as a TimeOnly.\n+     * \n+     * @return a TimeOnly using the same millis, unless partially specified\n+     */\n+    public final TimeOnly toTimeOnly() {\n+        if (this instanceof TimeOnly) {\n+            return (TimeOnly) this;\n+        }\n+        return new TimeOnly(this);\n+    }\n+\n+    /**\n+     * Get this object as a TimeOnly.\n+     * \n+     * @param chronology chronology to apply, or ISOChronology if null\n+     * @return a TimeOnly using the same millis, unless partially specified\n+     */\n+    public final TimeOnly toTimeOnly(Chronology chronology) {\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        if (this instanceof TimeOnly) {\n+            TimeOnly t = (TimeOnly) this;\n+            if (t.getChronology() == chronology.withUTC()) {\n+                return t;\n+            }\n+        }\n+        return new TimeOnly(this, chronology);\n+    }\n+\n+    /**\n      * Get the date time as a <code>java.util.Date</code>.\n      * \n      * @return a Date initialised with this datetime\n      * The locale is passed in, enabling Calendar to select the correct\n      * localized subclass.\n      * \n-     * @param locale  the locale to get the Calendar for\n+     * @param locale  the locale to get the Calendar for, or default if null\n      * @return a localized Calendar initialised with this datetime\n-     * @throws IllegalArgumentException if the locale is null\n      */\n     public final Calendar toCalendar(Locale locale) {\n         if (locale == null) {\n-            throw new IllegalArgumentException(\"The Locale must not be null\");\n+            locale = Locale.getDefault();\n         }\n         Calendar cal = Calendar.getInstance(locale);\n         cal.setTime(toDate());\n      * @return true if millisecond and chronology are equal, false if\n      *  not or the instant is null or of an incorrect type\n      */\n-    public final boolean equals(Object readableInstant) {\n+    public boolean equals(Object readableInstant) {\n+        if (this == readableInstant) {\n+            return true;\n+        }\n         if (readableInstant instanceof ReadableInstant) {\n             ReadableInstant otherInstant = (ReadableInstant) readableInstant;\n             if (getMillis() == otherInstant.getMillis()) {\n      *\n      * @return a suitable hash code\n      */\n-    public final int hashCode() {\n+    public int hashCode() {\n         // following rules in [Bloch02]\n         int result = 317;\n         result = 59 * result + ((int) (getMillis() ^ (getMillis() >>> 32)));\n      * All ReadableInstant instances are accepted.\n      *\n      * @param readableInstant  a readable instant to check against\n-     * @return -1 if this is less, 0 if equal or +1 if greater\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n      * @throws NullPointerException if the object is null\n      * @throws ClassCastException if the object type is not supported\n      */\n     public final int compareTo(Object readableInstant) {\n+        if (this == readableInstant) {\n+            return 0;\n+        }\n+\n         ReadableInstant otherInstant = (ReadableInstant) readableInstant;\n-        long otherMillis = otherInstant.getMillis();\n-        long thisMillis = getMillis();\n+\n+        // If instants are partial, then they can use each other to fill in\n+        // missing fields.\n+        long otherMillis = otherInstant.getMillis(this);\n+        long thisMillis = getMillis(otherInstant);\n+\n         // cannot do (thisMillis - otherMillis) as can overflow\n         if (thisMillis == otherMillis) {\n             return 0;\n         if (readableInstant == null) {\n             throw new IllegalArgumentException(\"The instant must not be null\");\n         }\n-        return (getMillis() > readableInstant.getMillis());\n+        // If instants are partial, then they can use each other to fill in\n+        // missing fields.\n+        return (getMillis(readableInstant) > readableInstant.getMillis(this));\n     }\n \n     /**\n         if (readableInstant == null) {\n             throw new IllegalArgumentException(\"The instant must not be null\");\n         }\n-        return (getMillis() < readableInstant.getMillis());\n+        // If instants are partial, then they can use each other to fill in\n+        // missing fields.\n+        return (getMillis(readableInstant) < readableInstant.getMillis(this));\n     }\n \n     /**\n         if (readableInstant == null) {\n             throw new IllegalArgumentException(\"The instant must not be null\");\n         }\n-        return (getMillis() == readableInstant.getMillis());\n+        // If instants are partial, then they can use each other to fill in\n+        // missing fields.\n+        return (getMillis(readableInstant) == readableInstant.getMillis(this));\n     }\n \n     // Output    \n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.InstantConverter;\n+import org.joda.time.format.DateTimeFormat;\n+\n+/**\n+ * AbstractPartialInstant provides the common behaviour for partial instant\n+ * classes.\n+ * <p>\n+ * This class should generally not be used directly by API users. The \n+ * {@link PartialInstant} interface should be used when different \n+ * kinds of partial instants are to be referenced.\n+ * <p>\n+ * AbstractPartialInstant subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public abstract class AbstractPartialInstant extends AbstractInstant\n+    implements PartialInstant, Serializable {\n+\n+    static final long serialVersionUID = -8202208243769478085L;\n+\n+    /**\n+     * Converts the given instant to local time.\n+     *\n+     * @param instant instant to convert\n+     * @param original original chronology\n+     * @param chronoUTC chronology with no time zone\n+     */\n+    private static long toLocalTime(long instant, Chronology original, Chronology chronoUTC) {\n+        if (original != chronoUTC) {\n+            DateTimeZone zone = original.getDateTimeZone();\n+            if (zone != null) {\n+                instant += zone.getOffset(instant);\n+            }\n+        }\n+        return instant;\n+    }\n+\n+    /**\n+     * Returns a chronology that is UTC, defaulting to ISO if given chronology\n+     * is null.\n+     */\n+    private static Chronology selectChronologyUTC(final Chronology chronology) {\n+        if (chronology == null) {\n+            return ISOChronology.getInstanceUTC();\n+        } else {\n+            Chronology utc = chronology.withUTC();\n+            if (utc != null) {\n+                return utc;\n+            }\n+            DateTimeZone zone = chronology.getDateTimeZone();\n+            if (zone == null || zone == DateTimeZone.UTC) {\n+                return chronology;\n+            }\n+            throw new IllegalArgumentException(\"Chronology does not support UTC: \" + chronology);\n+        }\n+    }\n+\n+    private Chronology iChronology;\n+\n+    /** The millis from 1970-01-01T00:00:00Z */\n+    private long iMillis;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs with the current instant in the default time zone.\n+     */\n+    protected AbstractPartialInstant() {\n+        this(ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Constructs with the current instant in the given time zone.\n+     *\n+     * @param zone  the time zone, null means default zone\n+     */\n+    protected AbstractPartialInstant(DateTimeZone zone) {\n+        this(ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs with the current instant in the time zone of the given\n+     * chronology.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    protected AbstractPartialInstant(final Chronology chronology) {\n+        iChronology = selectChronologyUTC(chronology);\n+        iMillis = resetUnsupportedFields\n+            (toLocalTime(System.currentTimeMillis(), chronology, iChronology));\n+    }\n+\n+    /**\n+     * Constructs with milliseconds from 1970-01-01T00:00:00Z.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    protected AbstractPartialInstant(long instant) {\n+        iChronology = ISOChronology.getInstanceUTC();\n+        iMillis = resetUnsupportedFields(instant);\n+    }\n+\n+    /**\n+     * Constructs with milliseconds from 1970-01-01T00:00:00Z. If the time zone\n+     * of the given chronology is not null or UTC, then the instant is\n+     * converted to local time.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology\n+     */\n+    protected AbstractPartialInstant(long instant, final Chronology chronology) {\n+        iChronology = selectChronologyUTC(chronology);\n+        iMillis = resetUnsupportedFields\n+            (toLocalTime(instant, chronology, iChronology));\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a date.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    protected AbstractPartialInstant(Object instant) {\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        final Chronology chronology = converter.getChronology(instant);\n+        iChronology = selectChronologyUTC(chronology);\n+        iMillis = resetUnsupportedFields\n+            (toLocalTime(converter.getInstantMillis(instant), chronology, iChronology));\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a date, using the\n+     * specified chronology.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @param chronology  the chronology, must not be null\n+     * @throws IllegalArgumentException if the date or chronology is null\n+     */\n+    protected AbstractPartialInstant(Object instant, final Chronology chronology) {\n+        iChronology = selectChronologyUTC(chronology);\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        iMillis = resetUnsupportedFields\n+            (toLocalTime(converter.getInstantMillis(instant),\n+                         converter.getChronology(instant), iChronology));\n+    }\n+\n+    /**\n+     * Get the value as the number of milliseconds since the epoch,\n+     * 1970-01-01T00:00:00Z, with unsupported field values reset.\n+     *\n+     * @return the value as milliseconds\n+     */\n+    public final long getMillis() {\n+        return iMillis;\n+    }\n+\n+    /**\n+     * Get the value as the number of milliseconds since the epoch,\n+     * 1970-01-01T00:00:00Z, with unsupported field values and time zone filled\n+     * in by the given base instant.\n+     *\n+     * @param base source of missing fields\n+     * @return the value as milliseconds\n+     */\n+    public final long getMillis(ReadableInstant base) {\n+        if (base == null || isMatchingType(base)) {\n+            return getMillis();\n+        }\n+        return getMillis(base, base.getDateTimeZone());\n+    }\n+\n+    /**\n+     * Get the value as the number of milliseconds since the epoch,\n+     * 1970-01-01T00:00:00Z, with unsupported field values filled in by the\n+     * given base instant.\n+     *\n+     * @param base source of missing fields\n+     * @param zone override the base time zone, null implies override with no\n+     * time zone\n+     * @return the value as milliseconds\n+     */\n+    public final long getMillis(ReadableInstant base, DateTimeZone zone) {\n+        if (base == null || isMatchingType(base)) {\n+            return getMillis();\n+        }\n+\n+        long millis = getMillis();\n+        long baseMillis = base.getMillis();\n+\n+        DateTimeZone baseZone = base.getDateTimeZone();\n+        if (baseZone != null) {\n+            // Strip zone from base such that sum can be performed.\n+            baseMillis += baseZone.getOffset(baseMillis);\n+        }\n+\n+        millis += resetSupportedFields(baseMillis);\n+\n+        if (zone != null) {\n+            // Apply new zone.\n+            millis -= zone.getOffsetFromLocal(millis);\n+        }\n+\n+        return millis;\n+    }\n+\n+    /**\n+     * Gets the chronology of the instant, null if not applicable. The time\n+     * zone of the chronology is either null or UTC.\n+     * <p>\n+     * The {@link Chronology} provides conversion from the millisecond\n+     * value to meaningful fields in a particular calendar system.\n+     * \n+     * @return the Chronology\n+     */\n+    public final Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    /**\n+     * Returns the lower limiting field, where the lower limit field itself is\n+     * supported. In other words, for the range described by the lower and\n+     * upper limits, the lower limit is inclusive.\n+     *\n+     * @return lower limit or null if none\n+     */\n+    public abstract DateTimeField getLowerLimit();\n+\n+    /**\n+     * Returns the upper limiting field, where the upper limit field itself is\n+     * not supported. In other words, for the range described by the lower and\n+     * upper limits, the upper limit is exclusive.\n+     *\n+     * @return upper limit or null if none\n+     */\n+    public abstract DateTimeField getUpperLimit();\n+\n+    /**\n+     * Returns true if the given instant is a PartialDateTime that supports the\n+     * same exact set of fields. Implementations may simply do the following:\n+     * <pre>\n+     *     return instant instanceof &lt;this class&gt;;\n+     * </pre>\n+     *\n+     * @return true if instant is same type as this\n+     */\n+    public abstract boolean isMatchingType(ReadableInstant instant);\n+\n+    /**\n+     * Returns the given instant, except with lower and upper limits\n+     * applied. Field values are reset below the lower limit and at or above\n+     * the upper limit.\n+     *\n+     * @param instant milliseconds from 1970-01-01T00:00:00\n+     */\n+    public final long resetUnsupportedFields(long instant) {\n+        DateTimeField field;\n+        if ((field = getLowerLimit()) != null) {\n+            instant = field.roundFloor(instant);\n+        }\n+        if ((field = getUpperLimit()) != null) {\n+            instant = field.remainder(instant);\n+        }\n+        return instant;\n+    }\n+\n+    /**\n+     * Returns the given instant, except with lower and upper limits\n+     * applied. Field values are reset below the upper limit and at or above\n+     * the lower limit.\n+     *\n+     * @param instant milliseconds from 1970-01-01T00:00:00\n+     */\n+    public final long resetSupportedFields(final long instant) {\n+        long newInstant = 0;\n+        DateTimeField field;\n+        if ((field = getUpperLimit()) != null) {\n+            newInstant = field.roundFloor(instant);\n+        }\n+        if ((field = getLowerLimit()) != null) {\n+            newInstant += field.remainder(instant);\n+        }\n+        return newInstant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the millisecond instant, the Chronology, and the limiting fields.\n+     * <p>\n+     * To compare two instants for absolute time (ie. UTC milliseconds ignoring\n+     * the chronology), use {@link #isEqual(ReadableInstant)} or\n+     * {@link #compareTo(Object)}.\n+     *\n+     * @param readableInstant  a readable instant to check against\n+     * @return true if millisecond and chronology are equal, false if\n+     *  not or the instant is null or of an incorrect type\n+     */\n+    public boolean equals(Object readableInstant) {\n+        return super.equals(readableInstant) && isMatchingType((ReadableInstant) readableInstant);\n+    }\n+\n+    private static boolean equals(Object a, Object b) {\n+        return (a == b) || (a != null && a.equals(b));\n+    }\n+\n+    /**\n+     * Gets a hash code for the instant that is compatable with the \n+     * equals method.\n+     *\n+     * @return a suitable hash code\n+     */\n+    public int hashCode() {\n+        int result = super.hashCode();\n+        DateTimeField field;\n+        if ((field = getLowerLimit()) != null) {\n+            result = 31 * result + field.hashCode();\n+        }\n+        if ((field = getUpperLimit()) != null) {\n+            result = 31 * result + field.hashCode();\n+        }\n+        return result;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value as a String in a recognisable ISO8601 format, only\n+     * displaying supported fields.\n+     * <p>\n+     * The string output is in ISO8601 format to enable the String\n+     * constructor to correctly parse it.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public abstract String toString();\n+\n+    /**\n+     * Set the value as the number of miliseconds since the epoch,\n+     * 1970-01-01T00:00:00Z.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     *\n+     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the\n+     * instant to\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    protected void setMillis(long instant) {\n+        iMillis = resetUnsupportedFields(instant);\n+    }\n+\n+    /**\n+     * Set the value from an Object representing an instant.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * \n+     * @param instant  an object representing an instant\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    protected void setMillis(Object instant) {\n+        // Don't set iMillis directly, as it may provide a backdoor to\n+        // immutable subclasses.\n+        if (instant instanceof ReadableInstant) {\n+            setMillis(((ReadableInstant) instant).getMillis());\n+        } else {\n+            InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+            setMillis(converter.getInstantMillis(instant));\n+        }\n+    }\n+\n+    /**\n+     * Set the chronology of the instant.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param chronology  the chronology to use, null means ISOChronology/UTC\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    protected void setChronology(Chronology chronology) {\n+        iChronology = selectChronologyUTC(chronology);\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/Chronology.java\n+++ b/JodaTime/src/java/org/joda/time/Chronology.java\n package org.joda.time;\n \n import java.io.Serializable;\n+import org.joda.time.chrono.UnsupportedDateTimeField;\n+import org.joda.time.chrono.UnsupportedDurationField;\n \n /**\n  * Chronology provides access to the individual date time fields for\n  * a chronological calendar system.\n- * <p>\n- * Chronology subclasses <em>must</em> be immutable.\n- * <p>\n  * Various chronologies are supported by subclasses including ISO and \n  * GregorianJulian. \n  * <p>\n- * This class does not strongly define each field. Subclasses may interpret\n- * the fields differently.\n+ * This class defines a number of fields with names from the ISO8601 standard.\n+ * Chronology does not 'strongly' define these fields however, thus subclasses\n+ * are free to interpret the field names as they wish. For example, a week\n+ * could be defined as 10 days and a month as 40 days in a special\n+ * WeirdChronology subclass. Clearly the GJ and ISO implementations provided\n+ * use the field names as you would expect.\n+ * <p>\n+ * Chronology is thread-safe and immutable, and all subclasses must be as well.\n  * \n  * @see org.joda.time.chrono.iso.ISOChronology\n  * @see org.joda.time.chrono.gj.GJChronology\n  *\n  * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n  * @since 1.0\n  */\n public abstract class Chronology implements Serializable {\n     \n+    static final long serialVersionUID = -7310865996721419676L;\n+\n     /**\n      * Restricted constructor\n      */\n      * Returns an instance of this Chronology that operates in any time zone.\n      *\n      * @return a version of this chronology with a specific time zone\n-     * @throws IllegalArgumentException if zone is null\n+     * @param zone to use, or default if null\n      * @see org.joda.time.chrono.ZonedChronology\n      */\n     public abstract Chronology withDateTimeZone(DateTimeZone zone);\n \n     /**\n-     * Get the millis for a time only field. The default implementation simply\n-     * returns <code>dayOfYear().remainder(millis)</code>.\n-     * \n-     * @param millis  the millis to convert to time only\n-     * @return millis with the date part stripped\n-     */\n-    public long getTimeOnlyMillis(long millis) {\n-        return dayOfYear().remainder(millis);\n-    }\n-\n-    /**\n-     * Get the millis for a date only field. The default implementation simply\n-     * returns <code>dayOfYear().roundFloor(millis)</code>.\n-     * \n-     * @param millis  the millis to convert to date only\n-     * @return millis with the time part stripped\n-     */\n-    public long getDateOnlyMillis(long millis) {\n-        return dayOfYear().roundFloor(millis);\n+     * Returns a date-only millisecond instant, by clearing the time fields\n+     * from the given instant.\n+     * <p>\n+     * The default implementation simply returns\n+     * <code>dayOfYear().roundFloor(instant)</code>.\n+     * \n+     * @param instant the milliseconds from 1970-01-01T00:00:00Z\n+     * @return millisecond instant from 1970-01-01T00:00:00Z with the time part\n+     * cleared\n+     */\n+    public long getDateOnlyMillis(long instant) {\n+        return dayOfYear().roundFloor(instant);\n+    }\n+\n+    /**\n+     * Returns a date-only millisecond instant, formed from the given year,\n+     * month, and day values. The set of given values must refer to a valid\n+     * date, or else an IllegalArgumentException is thrown.\n+     * <p>\n+     * The default implementation simply returns\n+     * <code>getDateTimeMillis(year, monthOfYear, dayOfMonth, 0)</code>.\n+     *\n+     * @param year year to use\n+     * @param monthOfYear month to use\n+     * @param dayOfMonth day of month to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z without any time\n+     * part\n+     */\n+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException\n+    {\n+        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n+    }\n+\n+    /**\n+     * Returns a time-only millisecond instant, by clearing the date fields\n+     * from the given instant.\n+     * <p>\n+     * The default implementation simply returns\n+     * <code>dayOfYear().remainder(instant)</code>.\n+     * \n+     * @param instant the milliseconds from 1970-01-01T00:00:00Z\n+     * @return millisecond instant from 1970-01-01T00:00:00Z with the date part\n+     * cleared\n+     */\n+    public long getTimeOnlyMillis(long instant) {\n+        return dayOfYear().remainder(instant);\n+    }\n+\n+    /**\n+     * Returns a time-only millisecond instant, formed from the given hour,\n+     * minute, second, and millisecond values. The set of given values must\n+     * refer to a valid time, or else an IllegalArgumentException is thrown.\n+     * <p>\n+     * The default implementation calls upon separate DateTimeFields to\n+     * determine the result. Subclasses are encouraged to provide a more\n+     * efficient implementation.\n+     *\n+     * @param hourOfDay hour to use\n+     * @param minuteOfHour minute to use\n+     * @param secondOfMinute second to use\n+     * @param millisOfSecond millisecond to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z without any date\n+     * part\n+     */\n+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        long instant = hourOfDay().set(0, hourOfDay);\n+        instant = minuteOfHour().set(instant, minuteOfHour);\n+        instant = secondOfMinute().set(instant, secondOfMinute);\n+        return millisOfSecond().set(instant, millisOfSecond);\n+    }\n+\n+    /**\n+     * Returns a datetime millisecond instant, formed from the given year,\n+     * month, day, and millisecond values. The set of given values must refer\n+     * to a valid datetime, or else an IllegalArgumentException is thrown.\n+     * <p>\n+     * The default implementation calls upon separate DateTimeFields to\n+     * determine the result. Subclasses are encouraged to provide a more\n+     * efficient implementation.\n+     *\n+     * @param year year to use\n+     * @param monthOfYear month to use\n+     * @param dayOfMonth day of month to use\n+     * @param millisOfDay millisecond to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        long instant = year().set(0, year);\n+        instant = monthOfYear().set(instant, monthOfYear);\n+        instant = dayOfMonth().set(instant, dayOfMonth);\n+        return millisOfDay().set(instant, millisOfDay);\n+    }\n+\n+    /**\n+     * Returns a datetime millisecond instant, from from the given instant,\n+     * hour, minute, second, and millisecond values. The set of given values\n+     * must refer to a valid datetime, or else an IllegalArgumentException is\n+     * thrown.\n+     * <p>\n+     * The default implementation calls upon separate DateTimeFields to\n+     * determine the result. Subclasses are encouraged to provide a more\n+     * efficient implementation.\n+     *\n+     * @param instant instant to start from\n+     * @param hourOfDay hour to use\n+     * @param minuteOfHour minute to use\n+     * @param secondOfMinute second to use\n+     * @param millisOfSecond millisecond to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public long getDateTimeMillis(long instant,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        instant = hourOfDay().set(instant, hourOfDay);\n+        instant = minuteOfHour().set(instant, minuteOfHour);\n+        instant = secondOfMinute().set(instant, secondOfMinute);\n+        return millisOfSecond().set(instant, millisOfSecond);\n+    }\n+\n+    /**\n+     * Returns a datetime millisecond instant, formed from the given year,\n+     * month, day, hour, minute, second, and millisecond values. The set of\n+     * given values must refer to a valid datetime, or else an\n+     * IllegalArgumentException is thrown.\n+     * <p>\n+     * The default implementation calls upon separate DateTimeFields to\n+     * determine the result. Subclasses are encouraged to provide a more\n+     * efficient implementation.\n+     *\n+     * @param year year to use\n+     * @param monthOfYear month to use\n+     * @param dayOfMonth day of month to use\n+     * @param hourOfDay hour to use\n+     * @param minuteOfHour minute to use\n+     * @param secondOfMinute second to use\n+     * @param millisOfSecond millisecond to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        long instant = year().set(0, year);\n+        instant = monthOfYear().set(instant, monthOfYear);\n+        instant = dayOfMonth().set(instant, dayOfMonth);\n+        instant = hourOfDay().set(instant, hourOfDay);\n+        instant = minuteOfHour().set(instant, minuteOfHour);\n+        instant = secondOfMinute().set(instant, secondOfMinute);\n+        return millisOfSecond().set(instant, millisOfSecond);\n     }\n \n     // Millis\n     //-----------------------------------------------------------------------\n     /**\n+     * Get the millis duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField millis() {\n+        return UnsupportedDurationField.getInstance(\"millis\");\n+    }\n+\n+    /**\n      * Get the millis of second field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField millisOfSecond() {\n-        throw new UnsupportedOperationException(\"millisOfSecond is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance(\"millisOfSecond\", millis());\n     }\n \n     /**\n      * Get the millis of day field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField millisOfDay() {\n-        throw new UnsupportedOperationException(\"millisOfDay is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance(\"millisOfDay\", millis());\n     }\n \n     // Second\n     //-----------------------------------------------------------------------\n     /**\n+     * Get the seconds duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField seconds() {\n+        return UnsupportedDurationField.getInstance(\"seconds\");\n+    }\n+\n+    /**\n      * Get the second of minute field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField secondOfMinute() {\n-        throw new UnsupportedOperationException(\"secondOfMinute is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance(\"secondOfMinute\", seconds());\n     }\n \n     /**\n      * Get the second of day field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField secondOfDay() {\n-        throw new UnsupportedOperationException(\"secondOfDay is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance(\"secondOfDay\", seconds());\n     }\n \n     // Minute\n     //-----------------------------------------------------------------------\n     /**\n+     * Get the minutes duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField minutes() {\n+        return UnsupportedDurationField.getInstance(\"minutes\");\n+    }\n+\n+    /**\n      * Get the minute of hour field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField minuteOfHour() {\n-        throw new UnsupportedOperationException(\"minuteOfHour is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance(\"minuteOfHour\", minutes());\n     }\n \n     /**\n      * Get the minute of day field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField minuteOfDay() {\n-        throw new UnsupportedOperationException(\"minuteOfDay is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance(\"minuteOfDay\", minutes());\n     }\n \n     // Hour\n     //-----------------------------------------------------------------------\n     /**\n+     * Get the hours duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField hours() {\n+        return UnsupportedDurationField.getInstance(\"hours\");\n+    }\n+\n+    /**\n      * Get the hour of day (0-23) field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField hourOfDay() {\n-        throw new UnsupportedOperationException(\"hourOfDay is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance(\"hourOfDay\", hours());\n     }\n \n     /**\n      * Get the hour of day (offset to 1-24) field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField clockhourOfDay() {\n-        throw new UnsupportedOperationException(\"clockhourOfDay is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance(\"clockhourOfDay\", hours());\n     }\n \n     /**\n      * Get the hour of am/pm (0-11) field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField hourOfHalfday() {\n-        throw new UnsupportedOperationException(\"hourOfHalfday is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance(\"hourOfHalfday\", hours());\n     }\n \n     /**\n      * Get the hour of am/pm (offset to 1-12) field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField clockhourOfHalfday() {\n-        throw new UnsupportedOperationException(\"clockhourOfHalfday is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance(\"clockhourOfHalfday\", hours());\n     }\n \n     /**\n      * Get the AM(0) PM(1) field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField halfdayOfDay() {\n-        throw new UnsupportedOperationException(\"halfdayOfDay is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance\n+            (\"halfdayOfDay\", UnsupportedDurationField.getInstance(\"halfdays\"));\n     }\n \n     // Day\n     //-----------------------------------------------------------------------\n+    /**\n+     * Get the days duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField days() {\n+        return UnsupportedDurationField.getInstance(\"days\");\n+    }\n+\n     /**\n      * Get the day of week field for this chronology.\n      *\n      * <p>DayOfWeek values are defined in {@link DateTimeConstants}.\n      * They use the ISO definitions, where 1 is Monday and 7 is Sunday.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField dayOfWeek() {\n-        throw new UnsupportedOperationException(\"dayOfWeek is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance(\"dayOfWeek\", days());\n     }\n \n     /**\n      * Get the day of month field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField dayOfMonth() {\n-        throw new UnsupportedOperationException(\"dayOfMonth is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance(\"dayOfMonth\", days());\n     }\n \n     /**\n      * Get the day of year field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField dayOfYear() {\n-        throw new UnsupportedOperationException(\"dayOfYear is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance(\"dayOfYear\", days());\n     }\n \n     // Week\n     //-----------------------------------------------------------------------\n     /**\n+     * Get the weeks duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField weeks() {\n+        return UnsupportedDurationField.getInstance(\"weeks\");\n+    }\n+\n+    /**\n      * Get the week of a week based year field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField weekOfWeekyear() {\n-        throw new UnsupportedOperationException(\"weekOfWeekyear is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance(\"weekOfWeekyear\", weeks());\n+    }\n+\n+    /**\n+     * Get the weekyears duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField weekyears() {\n+        return UnsupportedDurationField.getInstance(\"weekyears\");\n     }\n \n     /**\n      * Get the year of a week based year field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField weekyear() {\n-        throw new UnsupportedOperationException(\"weekyear is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance(\"weekyear\", weekyears());\n     }\n \n     // Month\n     //-----------------------------------------------------------------------\n     /**\n+     * Get the months duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField months() {\n+        return UnsupportedDurationField.getInstance(\"months\");\n+    }\n+\n+    /**\n      * Get the month of year field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField monthOfYear() {\n-        throw new UnsupportedOperationException(\"monthOfYear is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance(\"monthOfYear\", months());\n     }\n \n     // Year\n     //-----------------------------------------------------------------------\n     /**\n+     * Get the years duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField years() {\n+        return UnsupportedDurationField.getInstance(\"years\");\n+    }\n+\n+    /**\n      * Get the year field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField year() {\n-        throw new UnsupportedOperationException(\"year is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance(\"year\", years());\n     }\n \n     /**\n      * Get the year of era field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField yearOfEra() {\n-        throw new UnsupportedOperationException(\"yearOfEra is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance(\"yearOfEra\", years());\n     }\n \n     /**\n      * Get the year of century field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField yearOfCentury() {\n-        throw new UnsupportedOperationException(\"yearOfCentury is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance(\"yearOfCentury\", years());\n+    }\n+\n+    /**\n+     * Get the centuries duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField centuries() {\n+        return UnsupportedDurationField.getInstance(\"centuries\");\n     }\n \n     /**\n      * Get the century of era field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField centuryOfEra() {\n-        throw new UnsupportedOperationException(\"centuryOfEra is unsupported for \" + getClass().getName());\n+        return UnsupportedDateTimeField.getInstance(\"centuryOfEra\", centuries());\n+    }\n+\n+    /**\n+     * Get the eras duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField eras() {\n+        return UnsupportedDurationField.getInstance(\"eras\");\n     }\n \n     /**\n      * Get the era field for this chronology.\n      * \n-     * @return DateTimeField\n-     * @throws UnsupportedOperationException if unsupported\n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField era() {\n-        throw new UnsupportedOperationException(\"era is unsupported for \" + getClass().getName());\n-    }\n+        return UnsupportedDateTimeField.getInstance(\"era\", eras());\n+    }\n+\n+    /**\n+     * Gets a debugging toString.\n+     * \n+     * @return a debugging string\n+     */\n+    public abstract String toString();\n \n }\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/DateOnly.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.chrono.iso.ISOChronology;\n+// Import for @link support\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/*\n+ * <p>Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getYear()</code>\n+ * <li><code>year().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value\n+ * <li>text value\n+ * <li>short text value\n+ * <li>maximum value\n+ * <li>minimum value\n+ * </ul>\n+ */\n+\n+/**\n+ * DateOnly is the basic implementation of a date only class supporting\n+ * chronologies. It holds the date as milliseconds from the Java epoch of\n+ * 1970-01-01. The time component and time zone is fixed at T00:00:00Z.\n+ * <p>\n+ * DateOnly is thread-safe and immutable, provided that the Chronology is as\n+ * well. All standard Chronology classes supplied are thread-safe and\n+ * immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see TimeOnly\n+ * @see DateTime\n+ */\n+public class DateOnly extends AbstractPartialInstant implements Serializable {\n+\n+    static final long serialVersionUID = -5796551185494585279L;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a DateOnly to the current date in the default time zone.\n+     */\n+    public DateOnly() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a DateOnly to the current date in the given time zone.\n+     *\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public DateOnly(DateTimeZone zone) {\n+        super(zone);\n+    }\n+\n+    /**\n+     * Constructs a DateOnly to the current date in the time zone of the given\n+     * chronology.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public DateOnly(Chronology chronology) {\n+        super(chronology);\n+    }\n+\n+    /**\n+     * Constructs a DateOnly set to the milliseconds from 1970-01-01T00:00:00Z.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public DateOnly(long instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs a DateOnly set to the milliseconds from\n+     * 1970-01-01T00:00:00Z. If the time zone of the given chronology is not\n+     * null or UTC, then the instant is converted to local time.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology\n+     */\n+    public DateOnly(long instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a date.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public DateOnly(Object instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a date, using the\n+     * specified chronology.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @param chronology  the chronology, must not be null\n+     * @throws IllegalArgumentException if the date or chronology is null\n+     */\n+    public DateOnly(Object instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs an instance from date field values using\n+     * <code>ISOChronology</code>.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     */\n+    public DateOnly(\n+            final int year,\n+            final int monthOfYear,\n+            final int dayOfMonth) {\n+\n+        super(ISOChronology.getInstanceUTC()\n+              .getDateOnlyMillis(year, monthOfYear, dayOfMonth),\n+              ISOChronology.getInstanceUTC());\n+    }\n+\n+    /**\n+     * Constructs an instance from date field values\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param chronology  the chronology, null means ISOChronology\n+     */\n+    public DateOnly(\n+            final int year,\n+            final int monthOfYear,\n+            final int dayOfMonth,\n+            Chronology chronology) {\n+\n+        super((chronology == null ? (chronology = ISOChronology.getInstanceUTC()) : chronology)\n+              .getDateOnlyMillis(year, monthOfYear, dayOfMonth),\n+              chronology);\n+    }\n+\n+    /**\n+     * Returns the lower limiting field, dayOfYear.\n+     *\n+     * @return dayOfYear field\n+     */\n+    public final DateTimeField getLowerLimit() {\n+        return getChronology().dayOfYear();\n+    }\n+\n+    /**\n+     * Returns the upper limiting field, null.\n+     *\n+     * @return null\n+     */\n+    public final DateTimeField getUpperLimit() {\n+        return null;\n+    }\n+\n+    public final boolean isMatchingType(ReadableInstant instant) {\n+        return instant instanceof DateOnly;\n+    }\n+\n+    // Date field access\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the era field value.\n+     * \n+     * @return the era\n+     */\n+    public final int getEra() {\n+        return getChronology().era().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year of era field value.\n+     * \n+     * @return the year of era\n+     */\n+    public final int getCenturyOfEra() {\n+        return getChronology().centuryOfEra().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year of era field value.\n+     * \n+     * @return the year of era\n+     */\n+    public final int getYearOfEra() {\n+        return getChronology().yearOfEra().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year of century field value.\n+     * \n+     * @return the year of century\n+     */\n+    public final int getYearOfCentury() {\n+        return getChronology().yearOfCentury().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year field value.\n+     * \n+     * @return the year\n+     */\n+    public final int getYear() {\n+        return getChronology().year().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the weekyear field value.\n+     * \n+     * @return the year of a week based year\n+     */\n+    public final int getWeekyear() {\n+        return getChronology().weekyear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the month of year field value.\n+     * \n+     * @return the month of year\n+     */\n+    public final int getMonthOfYear() {\n+        return getChronology().monthOfYear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the week of weekyear field value.\n+     * \n+     * @return the week of a week based year\n+     */\n+    public final int getWeekOfWeekyear() {\n+        return getChronology().weekOfWeekyear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the day of year field value.\n+     * \n+     * @return the day of year\n+     */\n+    public final int getDayOfYear() {\n+        return getChronology().dayOfYear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the day of month field value.\n+     * <p>\n+     * The values for the day of month are defined in {@link DateTimeConstants}.\n+     * \n+     * @return the day of month\n+     */\n+    public final int getDayOfMonth() {\n+        return getChronology().dayOfMonth().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the day of week field value.\n+     * <p>\n+     * The values for the day of week are defined in {@link DateTimeConstants}.\n+     * \n+     * @return the day of week\n+     */\n+    public final int getDayOfWeek() {\n+        return getChronology().dayOfWeek().get(getMillis());\n+    }\n+\n+    // TODO: DateTimeFieldProperty cannot be constructed with anything but\n+    // DateTime.\n+\n+    // Properties\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the day of week property.\n+     * <p>\n+     * The values for day of week are defined in {@link DateTimeConstants}.\n+     * \n+     * @return the day of week property\n+     * /\n+    public final DateTimeFieldProperty dayOfWeek() {\n+        return new DateTimeFieldProperty(this, getChronology().dayOfWeek());\n+    }\n+\n+    /**\n+     * Get the day of month property.\n+     * \n+     * @return the day of month property\n+     * /\n+    public final DateTimeFieldProperty dayOfMonth() {\n+        return new DateTimeFieldProperty(this, getChronology().dayOfMonth());\n+    }\n+\n+    /**\n+     * Get the day of year property.\n+     * \n+     * @return the day of year property\n+     * /\n+    public final DateTimeFieldProperty dayOfYear() {\n+        return new DateTimeFieldProperty(this, getChronology().dayOfYear());\n+    }\n+\n+    /**\n+     * Get the week of a week based year property.\n+     * \n+     * @return the week of a week based year property\n+     * /\n+    public final DateTimeFieldProperty weekOfWeekyear() {\n+        return new DateTimeFieldProperty(this, getChronology().weekOfWeekyear());\n+    }\n+\n+    /**\n+     * Get the year of a week based year property.\n+     * \n+     * @return the year of a week based year property\n+     * /\n+    public final DateTimeFieldProperty weekyear() {\n+        return new DateTimeFieldProperty(this, getChronology().weekyear());\n+    }\n+\n+    /**\n+     * Get the month of year property.\n+     * \n+     * @return the month of year property\n+     * /\n+    public final DateTimeFieldProperty monthOfYear() {\n+        return new DateTimeFieldProperty(this, getChronology().monthOfYear());\n+    }\n+\n+    /**\n+     * Get the year property.\n+     * \n+     * @return the year property\n+     * /\n+    public final DateTimeFieldProperty year() {\n+        return new DateTimeFieldProperty(this, getChronology().year());\n+    }\n+\n+    /**\n+     * Get the year of era property.\n+     * \n+     * @return the year of era property\n+     * /\n+    public final DateTimeFieldProperty yearOfEra() {\n+        return new DateTimeFieldProperty(this, getChronology().yearOfEra());\n+    }\n+\n+    /**\n+     * Get the year of century property.\n+     * \n+     * @return the year of era property\n+     * /\n+    public final DateTimeFieldProperty yearOfCentury() {\n+        return new DateTimeFieldProperty(this, getChronology().yearOfCentury());\n+    }\n+\n+    /**\n+     * Get the century of era property.\n+     * \n+     * @return the year of era property\n+     * /\n+    public final DateTimeFieldProperty centuryOfEra() {\n+        return new DateTimeFieldProperty(this, getChronology().centuryOfEra());\n+    }\n+\n+    /**\n+     * Get the era property.\n+     * \n+     * @return the era property\n+     * /\n+    public final DateTimeFieldProperty era() {\n+        return new DateTimeFieldProperty(this, getChronology().era());\n+    }\n+    */\n+\n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the date in ISO8601 date only format (yyyy-MM-dd).\n+     * \n+     * @return ISO8601 date formatted string\n+     */\n+    public final String toString() {\n+        return ISODateTimeFormat.getInstance(getChronology()).date().print(getMillis());\n+    }\n+\n+    protected ReadableInstant create(long millis, Chronology chronology) {\n+        if (chronology == null) {\n+            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+        }\n+        if (millis == getMillis() && chronology == getChronology()) {\n+            return this;\n+        }\n+        return new DateOnly(millis, chronology);\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void setMillis(long millis) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void setChronology(Chronology chronology) {\n+    }\n+    \n+}\n--- a/JodaTime/src/java/org/joda/time/DateTime.java\n+++ b/JodaTime/src/java/org/joda/time/DateTime.java\n  */\n package org.joda.time;\n \n-import java.text.ParseException;\n-import java.util.Calendar;\n-import java.util.Date;\n-\n-import org.joda.time.chrono.iso.ISOChronology;\n-import org.joda.time.format.DateTimeParser;\n+import java.io.Serializable;\n+\n+// Import for @link support\n+import org.joda.time.convert.ConverterManager;\n import org.joda.time.format.ISODateTimeFormat;\n \n /**\n- * DateTime is the basic implementation of a datetime class supporting\n- * chronologies and time zones. It holds the time as milliseconds from the Java\n- * epoch of 1970-01-01T00:00:00Z.\n+ * DateTime is the standard implementation of an unmodifiable datetime class.\n+ * It holds the datetime as milliseconds from the Java epoch of 1970-01-01T00:00:00Z.\n+ * <p>\n+ * This class uses a Chronology internally. The Chronology determines how the\n+ * millisecond instant value is converted into the date time fields.\n+ * The default Chronology is <code>ISOChronology</code> which is the agreed\n+ * international standard and compatable with the modern Gregorian calendar.\n  *\n  * <p>Each individual field can be queried in two ways:\n  * <ul>\n  * <li>minimum value\n  * </ul>\n  *\n- * <p>This class is immutable provided that the Chronology is immutable. All \n- * Chronology classes supplied are immutable.\n+ * <p>\n+ * DateTime is thread-safe and immutable, provided that the Chronology is as\n+ * well. All standard Chronology classes supplied are thread-safe and\n+ * immutable.\n  *\n  * @author Stephen Colebourne\n  * @author Kandarp Shah\n  * @author Brian S O'Neill\n  * @since 1.0\n+ * @see MutableDateTime\n+ * @see DateOnly\n+ * @see TimeOnly\n  */\n-public class DateTime extends AbstractDateTime implements ReadableDateTime {\n+public class DateTime extends AbstractDateTime\n+        implements ReadableDateTime, Serializable {\n     \n-    /** The millis from 1970-01-01T00:00:00Z */\n-    private final long iMillis;\n-    /** The chronology to use */\n-    private final Chronology iChronology;\n+    static final long serialVersionUID = -5171125899451703815L;\n \n     // Constructors\n     //-----------------------------------------------------------------------\n     /**\n-     * Constructs a DateTime to the current datetime, as reported by the system\n-     * clock. The chronology used is ISO, in the\n-     * {@link DateTimeZone#getDefault() default} time zone.\n+     * Constructs an instance set to the current system millisecond time\n+     * using <code>ISOChronology</code> in the default time zone.\n      */\n     public DateTime() {\n-        iChronology = ISOChronology.getInstance();\n-        iMillis = System.currentTimeMillis();\n-    }\n-\n-    /**\n-     * Constructs a DateTime to the current datetime, as reported by the system\n-     * clock. The chronology used is ISO, in the supplied time zone.\n-     *\n-     * @param zone  the time zone, must not be null\n-     * @throws IllegalArgumentException if the zone is null\n+        super();\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param zone  the time zone, null means default zone\n      */\n     public DateTime(DateTimeZone zone) {\n-        iChronology = ISOChronology.getInstance(zone);\n-        iMillis = System.currentTimeMillis();\n-    }\n-\n-    /**\n-     * Constructs a DateTime to the current datetime, as reported by the system\n-     * clock.\n-     *\n-     * @param chronology  the chronology, must not be null\n-     * @throws IllegalArgumentException if the chronology is null\n+        super(zone);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n      */\n     public DateTime(Chronology chronology) {\n-        iChronology = selectChronology(chronology);\n-        iMillis = System.currentTimeMillis();\n-    }\n-\n-    /**\n-     * Constructs a DateTime set to the milliseconds from 1970-01-01T00:00:00Z,\n-     * using the ISO chronology, in the\n-     * {@link DateTimeZone#getDefault() default} time zone.\n-     *\n-     * @param millis  the milliseconds\n-     */\n-    public DateTime(long millis) {\n-        iChronology = ISOChronology.getInstance();\n-        iMillis = millis;\n-    }\n-\n-    /**\n-     * Constructs a DateTime set to the milliseconds from 1970-01-01T00:00:00Z,\n-     * using the ISO chronology, in the supplied time zone.\n-     *\n-     * @param millis  the milliseconds\n-     * @param zone  the time zone, must not be null\n-     * @throws IllegalArgumentException if the zone is null\n-     */\n-    public DateTime(long millis, DateTimeZone zone) {\n-        iChronology = ISOChronology.getInstance(zone);\n-        iMillis = millis;\n-    }\n-\n-    /**\n-     * Constructs a DateTime set to the milliseconds from 1970-01-01T00:00:00Z,\n-     * using the supplied chronology.\n-     *\n-     * @param millis  the milliseconds\n-     * @param chronology  the chronology, must not be null\n-     * @throws IllegalArgumentException if the chronology is null\n-     */\n-    public DateTime(long millis, Chronology chronology) {\n-        iChronology = selectChronology(chronology);\n-        iMillis = millis;\n-    }\n-\n-    /**\n-     * Constructs a DateTime from a ReadableInstant, using its chronology. If\n-     * its chronology null, then the chronology is set to ISO, in the\n-     * {@link DateTimeZone#getDefault() default} time zone.\n-     *\n-     * @param instant  the ReadableInstant, must not be null\n-     * @throws IllegalArgumentException if the instant is null\n-     */\n-    public DateTime(ReadableInstant instant) {\n-        iChronology = selectChronology(instant);\n-        iMillis = instant.getMillis();\n-    }\n-\n-    /**\n-     * Constructs a DateTime from a ReadableInstant, using its chronology\n-     * against a different time zone. If its chronology is null, then the\n-     * chronology is set to ISO. If the selected chronology is not in the\n-     * supplied time zone, a new chronology is created that is.\n-     *\n-     * @param instant  the ReadableInstant, must not be null\n-     * @param zone  the time zone, must not be null\n-     * @throws IllegalArgumentException if the instant or zone is null\n-     */\n-    public DateTime(ReadableInstant instant, DateTimeZone zone) {\n-        iChronology = selectChronology(instant, zone);\n-        iMillis = instant.getMillis();\n-    }\n-\n-    /**\n-     * Constructs a DateTime from a ReadableInstant, using the supplied\n-     * chronology.\n-     *\n-     * @param instant  the ReadableInstant, must not be null\n-     * @param chronology  the chronology, must not be null\n-     * @throws IllegalArgumentException if the instant or chronology is null\n-     */\n-    public DateTime(ReadableInstant instant, Chronology chronology) {\n-        iChronology = selectChronology(instant, chronology);\n-        iMillis = instant.getMillis();\n-    }\n-\n-    /**\n-     * Constructs a DateTime from a Date, using the ISO chronology, in the\n-     * {@link DateTimeZone#getDefault() default} time zone.\n-     *\n-     * @param date  the Date, must not be null\n-     * @throws IllegalArgumentException if the date is null\n-     */\n-    public DateTime(Date date) {\n-        iChronology = selectChronology(date);\n-        iMillis = date.getTime();\n-    }\n-\n-    /**\n-     * Constructs a DateTime from a Date, using the ISO chronology, in the\n-     * supplied time zone.\n-     *\n-     * @param date  the Date, must not be null\n-     * @param zone  the time zone, must not be null\n-     * @throws IllegalArgumentException if the date or zone is null\n-     */\n-    public DateTime(Date date, DateTimeZone zone) {\n-        iChronology = selectChronology(date, zone);\n-        iMillis = date.getTime();\n-    }\n-\n-    /**\n-     * Constructs a DateTime from a Date, using the supplied chronology.\n-     *\n-     * @param date  the Date, must not be null\n-     * @param chronology  the chronology, must not be null\n-     * @throws IllegalArgumentException if the date or chronology is null\n-     */\n-    public DateTime(Date date, Chronology chronology) {\n-        iChronology = selectChronology(date, chronology);\n-        iMillis = date.getTime();\n-    }\n-\n-    /**\n-     * Constructs a DateTime from a Calendar, using its closest mapped\n-     * chronology and time zone.\n-     *\n-     * <p>When converting calendars to chronologies, the constructor is aware\n-     * of GregorianCalendar and BuddhistCalendar and maps them to the\n-     * equivalent chronology. Other calendars map to ISOChronology.\n-     *\n-     * @param calendar  the Calendar, must not be null\n-     * @throws IllegalArgumentException if the calendar is null\n-     */\n-    public DateTime(Calendar calendar) {\n-        iChronology = selectChronology(calendar);\n-        iMillis = calendar.getTime().getTime();\n-    }\n-\n-    /**\n-     * Constructs a DateTime from a Calendar, using its closest mapped\n-     * chronology against a different time zone.\n-     *\n-     * <p>When converting calendars to chronologies, the constructor is aware\n-     * of GregorianCalendar and BuddhistCalendar and maps them to the\n-     * equivalent chronology. Other calendars map to ISOChronology.\n-     *\n-     * @param calendar  the Calendar, must not be null\n-     * @param chronology  the chronology, must not be null\n-     * @throws IllegalArgumentException if the calendar or zone is null\n-     */\n-    public DateTime(Calendar calendar, DateTimeZone zone) {\n-        iChronology = selectChronology(calendar, zone);\n-        iMillis = calendar.getTime().getTime();\n-    }\n-\n-    /**\n-     * Constructs a DateTime from a Calendar, using the supplied chronology.\n-     *\n-     * @param calendar  the Calendar, must not be null\n-     * @param chronology  the chronology, must not be null\n-     * @throws IllegalArgumentException if the calendar or chronology is null\n-     */\n-    public DateTime(Calendar calendar, Chronology chronology) {\n-        iChronology = selectChronology(calendar, chronology);\n-        iMillis = calendar.getTime().getTime();\n-    }\n-\n-    /**\n-     * Constructs a DateTime from an ISO formatted String, using the ISO\n-     * chronology, in the {@link DateTimeZone#getDefault() default} time zone.\n-     *\n-     * @param str  the string to parse, must not be null\n-     * @throws IllegalArgumentException if the string is null\n-     * @throws ParseException if parsing fails\n-     */\n-    public DateTime(String str) throws ParseException {\n-        iChronology = selectChronology(str);\n-        DateTimeParser p = ISODateTimeFormat.getInstance(iChronology).dateTimeParser();\n-        iMillis = p.parseMillis(str);\n-    }\n-\n-    /**\n-     * Constructs a DateTime from an ISO formatted String, using the ISO\n-     * chronology, in the supplied time zone.\n-     *\n-     * @param str  the string to parse, must not be null\n-     * @param zone the time zone, must not be null\n-     * @throws IllegalArgumentException if the string or zone is null\n-     * @throws ParseException if parsing fails\n-     */\n-    public DateTime(String str, DateTimeZone zone) throws ParseException {\n-        iChronology = selectChronology(str, zone);\n-        DateTimeParser p = ISODateTimeFormat.getInstance(iChronology).dateTimeParser();\n-        iMillis = p.parseMillis(str);\n-    }\n-\n-    /**\n-     * Constructs a DateTime from an ISO formatted String, using the supplied\n-     * chronology.\n-     *\n-     * @param str  the string to parse, must not be null\n-     * @param chronology  the chronology, must not be null\n-     * @throws IllegalArgumentException if the string or chronology is null\n-     * @throws ParseException if parsing fails\n-     */\n-    public DateTime(String str, Chronology chronology) throws ParseException {\n-        iChronology = selectChronology(str, chronology);\n-        DateTimeParser p = ISODateTimeFormat.getInstance(iChronology).dateTimeParser();\n-        iMillis = p.parseMillis(str);\n-    }\n-\n+        super(chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using <code>ISOChronology</code> in the default time zone.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public DateTime(long instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public DateTime(long instant, DateTimeZone zone) {\n+        super(instant, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public DateTime(long instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from an Object that represents a datetime.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @throws IllegalArgumentException if the instant is null or invalid\n+     */\n+    public DateTime(Object instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * forcing the time zone to that specified.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * If the specified time zone is null, the default zone is used.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @param zone  the time zone, null means default time zone\n+     * @throws IllegalArgumentException if the instant is null or invalid\n+     */\n+    public DateTime(Object instant, DateTimeZone zone) {\n+        super(instant, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, ISOChronology in the default time zone is used.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     * @throws IllegalArgumentException if the instant is null or invalid\n+     */\n+    public DateTime(Object instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the default time zone.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the milisecond of the second\n+     */\n+    public DateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond) {\n+        super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the milisecond of the second\n+     * @param zone  the time zone, null means default time zone\n+     */\n+    public DateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond,\n+            DateTimeZone zone) {\n+        super(year, monthOfYear, dayOfMonth,\n+              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the milisecond of the second\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public DateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond,\n+            Chronology chronology) {\n+        super(year, monthOfYear, dayOfMonth,\n+              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Creates a new instance of this class.\n      * <p>\n      * The returned object will be a new instance of the implementation.\n      * Immutable subclasses may return <code>this</code> if appropriate.\n      *\n-     * @param millis  the new millis, from 1970-01-01T00:00:00Z\n+     * @param instant  the new instant, from 1970-01-01T00:00:00Z\n      * @param chrono  the new chronology\n      * @return a new instance of this class\n      * @throws IllegalArgumentException if the chronology is null\n      */\n-    protected ReadableInstant create(long millis, Chronology chrono) {\n+    protected final ReadableInstant create(final long instant, final Chronology chrono) {\n+        return createDateTime(instant, chrono);\n+    }\n+    \n+    /**\n+     * Creates a new instance of this class.\n+     * <p>\n+     * The returned object will be a new instance of DateTime, or a subclass.\n+     * Immutable subclasses may return <code>this</code> if appropriate.\n+     *\n+     * @param instant  the new instant, from 1970-01-01T00:00:00Z\n+     * @param chrono  the new chronology\n+     * @return a new instance of this class\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    protected DateTime createDateTime(final long instant, final Chronology chrono) {\n         if (chrono == null) {\n             throw new IllegalArgumentException(\"The Chronology must not be null\");\n         }\n-        if (millis == getMillis() && chrono == getChronology()) {\n+        if (instant == getMillis() && chrono == getChronology()) {\n             return this;\n         }\n-        return new DateTime(millis, chrono);\n+        return new DateTime(instant, chrono);\n     }\n     \n-    // Accessors\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the milliseconds of the datetime instant from the Java epoch\n-     * of 1970-01-01T00:00:00Z.\n-     * \n-     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n-     */\n-    public final long getMillis() {\n-        return iMillis;\n-    }\n-\n-    /**\n-     * Gets the chronology of the datetime.\n-     * \n-     * @return the Chronology that the datetime is using\n-     */\n-    public final Chronology getChronology() {\n-        return iChronology;\n-    }\n-\n     // Date properties\n     //-----------------------------------------------------------------------\n+    /**\n+     * Get the era property.\n+     * \n+     * @return the era property\n+     */\n+    public final DateTimeFieldProperty era() {\n+        return new DateTimeFieldProperty(this, getChronology().era());\n+    }\n+\n+    /**\n+     * Get the century of era property.\n+     * \n+     * @return the year of era property\n+     */\n+    public final DateTimeFieldProperty centuryOfEra() {\n+        return new DateTimeFieldProperty(this, getChronology().centuryOfEra());\n+    }\n+\n+    /**\n+     * Get the year of century property.\n+     * \n+     * @return the year of era property\n+     */\n+    public final DateTimeFieldProperty yearOfCentury() {\n+        return new DateTimeFieldProperty(this, getChronology().yearOfCentury());\n+    }\n+\n+    /**\n+     * Get the year of era property.\n+     * \n+     * @return the year of era property\n+     */\n+    public final DateTimeFieldProperty yearOfEra() {\n+        return new DateTimeFieldProperty(this, getChronology().yearOfEra());\n+    }\n+\n+    /**\n+     * Get the year property.\n+     * \n+     * @return the year property\n+     */\n+    public final DateTimeFieldProperty year() {\n+        return new DateTimeFieldProperty(this, getChronology().year());\n+    }\n+\n+    /**\n+     * Get the year of a week based year property.\n+     * \n+     * @return the year of a week based year property\n+     */\n+    public final DateTimeFieldProperty weekyear() {\n+        return new DateTimeFieldProperty(this, getChronology().weekyear());\n+    }\n+\n+    /**\n+     * Get the month of year property.\n+     * \n+     * @return the month of year property\n+     */\n+    public final DateTimeFieldProperty monthOfYear() {\n+        return new DateTimeFieldProperty(this, getChronology().monthOfYear());\n+    }\n+\n+    /**\n+     * Get the week of a week based year property.\n+     * \n+     * @return the week of a week based year property\n+     */\n+    public final DateTimeFieldProperty weekOfWeekyear() {\n+        return new DateTimeFieldProperty(this, getChronology().weekOfWeekyear());\n+    }\n+\n+    /**\n+     * Get the day of year property.\n+     * \n+     * @return the day of year property\n+     */\n+    public final DateTimeFieldProperty dayOfYear() {\n+        return new DateTimeFieldProperty(this, getChronology().dayOfYear());\n+    }\n+\n+    /**\n+     * Get the day of month property.\n+     * <p>\n+     * The values for day of month are defined in {@link DateTimeConstants}.\n+     * \n+     * @return the day of month property\n+     */\n+    public final DateTimeFieldProperty dayOfMonth() {\n+        return new DateTimeFieldProperty(this, getChronology().dayOfMonth());\n+    }\n+\n     /**\n      * Get the day of week property.\n      * <p>\n         return new DateTimeFieldProperty(this, getChronology().dayOfWeek());\n     }\n \n-    /**\n-     * Get the day of month property.\n-     * \n-     * @return the day of month property\n-     */\n-    public final DateTimeFieldProperty dayOfMonth() {\n-        return new DateTimeFieldProperty(this, getChronology().dayOfMonth());\n-    }\n-\n-    /**\n-     * Get the day of year property.\n-     * \n-     * @return the day of year property\n-     */\n-    public final DateTimeFieldProperty dayOfYear() {\n-        return new DateTimeFieldProperty(this, getChronology().dayOfYear());\n-    }\n-\n-    /**\n-     * Get the week of a week based year property.\n-     * \n-     * @return the week of a week based year property\n-     */\n-    public final DateTimeFieldProperty weekOfWeekyear() {\n-        return new DateTimeFieldProperty(this, getChronology().weekOfWeekyear());\n-    }\n-\n-    /**\n-     * Get the year of a week based year property.\n-     * \n-     * @return the year of a week based year property\n-     */\n-    public final DateTimeFieldProperty weekyear() {\n-        return new DateTimeFieldProperty(this, getChronology().weekyear());\n-    }\n-\n-    /**\n-     * Get the month of year property.\n-     * \n-     * @return the month of year property\n-     */\n-    public final DateTimeFieldProperty monthOfYear() {\n-        return new DateTimeFieldProperty(this, getChronology().monthOfYear());\n-    }\n-\n-    /**\n-     * Get the year property.\n-     * \n-     * @return the year property\n-     */\n-    public final DateTimeFieldProperty year() {\n-        return new DateTimeFieldProperty(this, getChronology().year());\n-    }\n-\n-    /**\n-     * Get the year of era property.\n-     * \n-     * @return the year of era property\n-     */\n-    public final DateTimeFieldProperty yearOfEra() {\n-        return new DateTimeFieldProperty(this, getChronology().yearOfEra());\n-    }\n-\n-    /**\n-     * Get the year of century property.\n-     * \n-     * @return the year of era property\n-     */\n-    public final DateTimeFieldProperty yearOfCentury() {\n-        return new DateTimeFieldProperty(this, getChronology().yearOfCentury());\n-    }\n-\n-    /**\n-     * Get the century of era property.\n-     * \n-     * @return the year of era property\n-     */\n-    public final DateTimeFieldProperty centuryOfEra() {\n-        return new DateTimeFieldProperty(this, getChronology().centuryOfEra());\n-    }\n-\n-    /**\n-     * Get the era property.\n-     * \n-     * @return the era property\n-     */\n-    public final DateTimeFieldProperty era() {\n-        return new DateTimeFieldProperty(this, getChronology().era());\n-    }\n-\n     // Time properties\n     //-----------------------------------------------------------------------\n     /**\n-     * Get the millis of second property.\n+     * Get the hour of day field property\n+     * \n+     * @return the hour of day property\n+     */\n+    public final DateTimeFieldProperty hourOfDay() {\n+        return new DateTimeFieldProperty(this, getChronology().hourOfDay());\n+    }\n+\n+    /**\n+     * Get the minute of day property\n+     * \n+     * @return the minute of day property\n+     */\n+    public final DateTimeFieldProperty minuteOfDay() {\n+        return new DateTimeFieldProperty(this, getChronology().minuteOfDay());\n+    }\n+\n+    /**\n+     * Get the minute of hour field property\n+     * \n+     * @return the minute of hour property\n+     */\n+    public final DateTimeFieldProperty minuteOfHour() {\n+        return new DateTimeFieldProperty(this, getChronology().minuteOfHour());\n+    }\n+\n+    /**\n+     * Get the second of day property\n+     * \n+     * @return the second of day property\n+     */\n+    public final DateTimeFieldProperty secondOfDay() {\n+        return new DateTimeFieldProperty(this, getChronology().secondOfDay());\n+    }\n+\n+    /**\n+     * Get the second of minute field property\n+     * \n+     * @return the second of minute property\n+     */\n+    public final DateTimeFieldProperty secondOfMinute() {\n+        return new DateTimeFieldProperty(this, getChronology().secondOfMinute());\n+    }\n+\n+    /**\n+     * Get the millis of day property\n+     * \n+     * @return the millis of day property\n+     */\n+    public final DateTimeFieldProperty millisOfDay() {\n+        return new DateTimeFieldProperty(this, getChronology().millisOfDay());\n+    }\n+\n+    /**\n+     * Get the millis of second property\n      * \n      * @return the millis of second property\n      */\n         return new DateTimeFieldProperty(this, getChronology().millisOfSecond());\n     }\n \n-    /**\n-     * Get the millis of day property.\n-     * \n-     * @return the millis of day property\n-     */\n-    public final DateTimeFieldProperty millisOfDay() {\n-        return new DateTimeFieldProperty(this, getChronology().millisOfDay());\n-    }\n-\n-    /**\n-     * Get the second of minute field property.\n-     * \n-     * @return the second of minute property\n-     */\n-    public final DateTimeFieldProperty secondOfMinute() {\n-        return new DateTimeFieldProperty(this, getChronology().secondOfMinute());\n-    }\n-\n-    /**\n-     * Get the second of day property.\n-     * \n-     * @return the second of day property\n-     */\n-    public final DateTimeFieldProperty secondOfDay() {\n-        return new DateTimeFieldProperty(this, getChronology().secondOfDay());\n-    }\n-\n-    /**\n-     * Get the minute of hour field property.\n-     * \n-     * @return the minute of hour property\n-     */\n-    public final DateTimeFieldProperty minuteOfHour() {\n-        return new DateTimeFieldProperty(this, getChronology().minuteOfHour());\n-    }\n-\n-    /**\n-     * Get the minute of day property.\n-     * \n-     * @return the minute of day property\n-     */\n-    public final DateTimeFieldProperty minuteOfDay() {\n-        return new DateTimeFieldProperty(this, getChronology().minuteOfDay());\n-    }\n-\n-    /**\n-     * Get the hour of day field property.\n-     * \n-     * @return the hour of day property\n-     */\n-    public final DateTimeFieldProperty hourOfDay() {\n-        return new DateTimeFieldProperty(this, getChronology().hourOfDay());\n-    }\n-\n     // Output\n     //-----------------------------------------------------------------------\n     /**\n         return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);\n     }\n \n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void setMillis(long millis) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void setChronology(Chronology chronology) {\n+    }\n+\n }\n--- a/JodaTime/src/java/org/joda/time/DateTimeComparator.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeComparator.java\n  */\n package org.joda.time;\n \n+import java.io.Serializable;\n import java.util.Comparator;\n+import org.joda.time.convert.ConverterManager;\n \n /**\n  * DateTimeComparator is the standard implementation of the Comparator\n  * <li>java.util.Long (milliseconds)\n  * </ul>\n  *\n+ * <p>\n+ * DateTimeComparator is thread-safe and immutable.\n+ *\n  * @author Guy Allard\n  * @author Stephen Colebourne\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public class DateTimeComparator implements Comparator {\n+public class DateTimeComparator implements Comparator, Serializable {\n+\n+    static final long serialVersionUID = -6097339773320178364L;\n \n     private static final DateTimeComparator INSTANCE = new DateTimeComparator(null, null);\n \n     }\n \n     /**\n+     * @return null if no lower limit\n+     */\n+    public DateTimeField getLowerLimit() {\n+        return iLowerLimit;\n+    }\n+\n+    /**\n+     * @return null if no upper limit\n+     */\n+    public DateTimeField getUpperLimit() {\n+        return iUpperLimit;\n+    }\n+\n+    /**\n      * Compare two objects against only the range of date time fields as\n      * specified in the constructor.\n      * \n      * comparison\n      * @param rhsObj The second object, logically on the right of a &lt;\n      * comparison\n-     * @return 0 if order does not matter, -1 if lhsObj &lt; rhsObj, 1\n-     * otherwise.\n-     * @throws IllegalArgumentException if either argument is null\n-     * @throws ClassCastException if either argument is one of the support\n-     * types\n+     * @return zero if order does not matter, negative value if lhsObj &lt;\n+     * rhsObj, positive value otherwise.\n+     * @throws IllegalArgumentException if either argument is not supported\n      */\n     public int compare(Object lhsObj, Object rhsObj) {\n-        long lhs = getMillisFromObject(lhsObj);\n-        long rhs = getMillisFromObject(rhsObj);\n-\n-        if (iLowerLimit != null) {\n-            lhs = iLowerLimit.roundFloor(lhs);\n-            rhs = iLowerLimit.roundFloor(rhs);\n-        }\n-\n-        if (iUpperLimit != null) {\n-            lhs = iUpperLimit.remainder(lhs);\n-            rhs = iUpperLimit.remainder(rhs);\n-        }\n-\n-        if (lhs < rhs) {\n+        long lhsMillis, rhsMillis;\n+\n+        if (lhsObj instanceof ReadableInstant) {\n+            ReadableInstant lhsInstant = (ReadableInstant) lhsObj;\n+\n+            if (rhsObj instanceof ReadableInstant) {\n+                ReadableInstant rhsInstant = (ReadableInstant) rhsObj;\n+\n+                // If instants are partial, then they can use each other to\n+                // fill in missing fields.\n+                lhsMillis = lhsInstant.getMillis(rhsInstant);\n+                rhsMillis = rhsInstant.getMillis(lhsInstant);\n+            } else {\n+                lhsMillis = lhsInstant.getMillis();\n+                rhsMillis = getMillisFromObject(rhsObj);\n+            }\n+        } else {\n+            lhsMillis = getMillisFromObject(lhsObj);\n+\n+            if (rhsObj instanceof ReadableInstant) {\n+                rhsMillis = ((ReadableInstant) rhsObj).getMillis();\n+            } else {\n+                rhsMillis = getMillisFromObject(rhsObj);\n+            }\n+        }\n+\n+        DateTimeField field;\n+        if ((field = iLowerLimit) != null) {\n+            lhsMillis = field.roundFloor(lhsMillis);\n+            rhsMillis = field.roundFloor(rhsMillis);\n+        }\n+\n+        if ((field = iUpperLimit) != null) {\n+            lhsMillis = field.remainder(lhsMillis);\n+            rhsMillis = field.remainder(rhsMillis);\n+        }\n+\n+        if (lhsMillis < rhsMillis) {\n             return -1;\n-        } else if (lhs > rhs) {\n+        } else if (lhsMillis > rhsMillis) {\n             return 1;\n         } else {\n             return 0;\n         }\n+    }\n+\n+    /**\n+     * Support serialization singletons\n+     */\n+    private Object readResolve() {\n+        return getInstance(iLowerLimit, iUpperLimit);\n     }\n \n     /*\n \n     /*\n      * @param obj\n-     * @throws ClassCastException\n      * @return millis since the epoch\n      */\n-    private long getMillisFromObject(Object obj) {\n-        if (obj instanceof ReadableInstant) {\n-            return ((ReadableInstant)obj).getMillis();\n-        }\n-        if (obj instanceof java.util.Date) {\n-            return ((java.util.Date)obj).getTime();\n-        }\n-        if (obj instanceof java.util.Calendar) {\n-            return ((java.util.Calendar)obj).getTime().getTime();\n-        }\n-        if (obj instanceof Long) {\n-            return ((Long)obj).longValue();\n-        }\n-\n-        if (obj == null) {\n-            throw new IllegalArgumentException(\"Object to compare must not be null\");\n-        }\n-\n-        throw new ClassCastException\n-            (\"Invalid class for DateTimeComparator: \" + obj.getClass());\n+    private static long getMillisFromObject(Object obj) {\n+        return ConverterManager.getInstance().getInstantConverter(obj).getInstantMillis(obj);\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/DateTimeConstants.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeConstants.java\n  */\n package org.joda.time;\n \n-import java.util.*;\n-\n /**\n  * DateTimeConstants is a non-instantiable class of constants used in\n  * the date time system. These are the ISO8601 constants, but should be\n  * used by all chronologies.\n+ * <p>\n+ * DateTimeConstants is thread-safe and immutable.\n  *\n  * @author Stephen Colebourne\n  * @author Brian S O'Neill\n \n     /** Constant (12) representing December, the twelfth month */\n     public static final int DECEMBER = 12;\n-\n-\n-    /**\n-     * Constant list of the number of days in the month. The index into\n-     * the list is the month constant as defined in ReadableDate, thus \n-     * MAX_DAYS_IN_MONTH.get(0) has no meaning and returns null. This is a \n-     * list rather than an array as it must be unmodifiable.\n-     */\n-    public static final List MAX_DAYS_PER_MONTH =\n-        Collections.unmodifiableList(\n-            Arrays.asList(\n-                new Integer[] {\n-                    null,\n-                    new Integer(31),\n-                    new Integer(29),\n-                    new Integer(31),\n-                    new Integer(30),\n-                    new Integer(31),\n-                    new Integer(30),\n-                    new Integer(31),\n-                    new Integer(31),\n-                    new Integer(30),\n-                    new Integer(31),\n-                    new Integer(30),\n-                    new Integer(31)}));\n-    /**\n-     * Constant list of the number of days in the month. The index into\n-     * the list is the month constant as defined in ReadableDate, thus \n-     * MIN_DAYS_IN_MONTH.get(0) has no meaning and returns null. This is a \n-     * list rather than an array as it must be unmodifiable.\n-     */\n-    public static final List MIN_DAYS_PER_MONTH =\n-        Collections.unmodifiableList(\n-            Arrays.asList(\n-                new Integer[] {\n-                    null,\n-                    new Integer(31),\n-                    new Integer(28),\n-                    new Integer(31),\n-                    new Integer(30),\n-                    new Integer(31),\n-                    new Integer(30),\n-                    new Integer(31),\n-                    new Integer(31),\n-                    new Integer(30),\n-                    new Integer(31),\n-                    new Integer(30),\n-                    new Integer(31)}));\n-\n \n     // These are ints not enumerations as they represent genuine int values\n     /** Constant (1) representing Monday, the first day of the week (ISO) */\n--- a/JodaTime/src/java/org/joda/time/DateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java\n  */\n package org.joda.time;\n \n-import java.io.Serializable;\n import java.util.Locale;\n \n /**\n- * DateTimeField is an abstract class which allows the date and time\n- * manipulation code to be field based. Each field within a datetime\n- * can be accessed and manipulated using a dedicated subclass of this\n- * one.\n+ * Defines the calculation engine for date and time fields.\n+ * The interface defines a set of methods that manipulate a millisecond datetime\n+ * with regards to a single field, such as monthOfYear or secondOfMinute.\n  * <p>\n- * This design is extensible, so if you wish to extract a different \n- * field from the milliseconds, you can do, simply by implementing\n- * your own subclass.\n+ * This design is extensible so, if you wish, you can extract a different field from\n+ * the milliseconds. A number of standard implementations are provided to assist.\n  *\n  * @author Guy Allard\n  * @author Stephen Colebourne\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public abstract class DateTimeField implements Serializable {\n-\n-    /** A desriptive name for the field */\n-    private final String iName;\n-\n-    /**\n-     * Constructor.\n-     * \n-     * @param name a short descriptive name for the field, such as\n-     * millisOfSecond\n-     */\n-    protected DateTimeField(String name) {\n-        super();\n-        \n-        iName = name;\n-    }\n-    \n+public interface DateTimeField {\n+\n     /**\n      * Get the name of the field.\n      * \n      * @return field name\n      */\n-    public String getName() {\n-        return iName;\n-    }\n+    public String getName();\n+\n+    /**\n+     * Returns true if this field is supported.\n+     * \n+     * @return true if this field is supported\n+     */\n+    public boolean isSupported();\n+\n+    /**\n+     * Returns true if the set method is lenient. If so, it accepts values that\n+     * are out of bounds. For example, a lenient day of month field accepts 32\n+     * for January, converting it to February 1.\n+     * \n+     * @return true if this field is lenient\n+     */\n+    public boolean isLenient();\n \n     // Main access API\n     //------------------------------------------------------------------------\n     /**\n      * Get the value of this field from the milliseconds.\n      * \n-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n      * @return the value of the field, in the units of the field\n      */\n-    public abstract int get(long millis);\n+    public int get(long instant);\n \n     /**\n      * Get the human-readable, text value of this field from the milliseconds.\n      * If the specified locale is null, the default locale is used.\n-     * <p>\n-     * The default implementation returns Integer.toString(get(millis)).\n-     * <p>\n-     * Note: subclasses that override this method should also override\n-     * getMaximumTextLength.\n-     *\n-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query\n-     * @param locale the locale to use for selecting a text symbol, null for\n-     * default\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @param locale the locale to use for selecting a text symbol, null for default\n      * @return the text value of the field\n      */\n-    public String getAsText(long millis, Locale locale) {\n-        return Integer.toString(get(millis));\n-    }\n+    public String getAsText(long instant, Locale locale);\n \n     /**\n      * Get the human-readable, text value of this field from the milliseconds.\n-     * This implementation returns getAsText(millis, null).\n-     * \n-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n      * @return the text value of the field\n      */\n-    public final String getAsText(long millis) {\n-        return getAsText(millis, null);\n-    }\n+    public String getAsText(long instant);\n \n     /**\n      * Get the human-readable, short text value of this field from the\n-     * milliseconds.  If the specified locale is null, the default locale is\n-     * used.\n-     * <p>\n-     * The default implementation returns getAsText(millis, locale).\n-     * <p>\n-     * Note: subclasses that override this method should also override\n-     * getMaximumShortTextLength.\n-     *\n-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query\n-     * @param locale the locale to use for selecting a text symbol, null for\n-     * default\n+     * milliseconds.  If the specified locale is null, the default locale is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @param locale the locale to use for selecting a text symbol, null for default\n      * @return the short text value of the field\n      */\n-    public String getAsShortText(long millis, Locale locale) {\n-        return getAsText(millis, locale);\n-    }\n+    public String getAsShortText(long instant, Locale locale);\n \n     /**\n      * Get the human-readable, short text value of this field from the\n-     * milliseconds.  This implementation returns getAsShortText(millis, null).\n-     * \n-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * milliseconds.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n      * @return the short text value of the field\n      */\n-    public final String getAsShortText(long millis) {\n-        return getAsShortText(millis, null);\n-    }\n+    public String getAsShortText(long instant);\n \n     /**\n      * Adds a value (which may be negative) to the millis value,\n      * 2001-01-31 add one month  is 2001-02-28<br>\n      * 2001-01-31 add two months is 2001-03-31<br>\n      * \n-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n      * @param value  the value to add, in the units of the field\n      * @return the updated milliseconds\n      */\n-    public abstract long add(long millis, int value);\n+    public long add(long instant, int value);\n \n     /**\n      * Adds a value (which may be negative) to the millis value,\n      * overflowing into larger fields if necessary.\n      * \n-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n      * @param value  the long value to add, in the units of the field\n      * @return the updated milliseconds\n      * @throws IllegalArgumentException if value is too large\n      * @see #add(long,int)\n      */\n-    public abstract long add(long millis, long value);\n+    public long add(long instant, long value);\n \n     /**\n      * Adds a value (which may be negative) to the millis value,\n      * 2001-01-31 addWrapped one month  is 2001-02-28<br>\n      * 2001-01-31 addWrapped two months is 2001-03-31<br>\n      * \n-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n      * @param value  the value to add, in the units of the field\n      * @return the updated milliseconds\n      */\n-    public long addWrapped(long millis, int value) {\n-        int current = get(millis);\n-        int wrapped = getWrappedValue\n-            (current, value, getMinimumValue(millis), getMaximumValue(millis));\n-        return set(millis, wrapped);\n-    }\n+    public long addWrapped(long instant, int value) ;\n \n     /**\n      * Computes the difference between two instants, as measured in the units\n      * getDifference reverses the effect of calling add. In the following code:\n      *\n      * <pre>\n-     * long millis = ...\n+     * long instant = ...\n      * int v = ...\n-     * long age = getDifference(add(millis, v), millis);\n+     * int age = getDifference(add(instant, v), instant);\n      * </pre>\n      *\n      * The value 'age' is the same as the value 'v'.\n-     * <p>\n-     * The default implementation performs a guess-and-check algorithm using\n-     * the getUnitMillis and add methods. Subclasses are encouraged to provide\n-     * a more efficient implementation.\n-     *\n-     * @param minuendMillis the milliseconds from 1970-01-01T00:00:00Z to\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n      * subtract from\n-     * @param subtrahendMillis the milliseconds from 1970-01-01T00:00:00Z to\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n      * subtract off the minuend\n      * @return the difference in the units of this field\n      */\n-    public long getDifference(long minuendMillis, long subtrahendMillis) {\n-        if (minuendMillis < subtrahendMillis) {\n-            return -getDifference(subtrahendMillis, minuendMillis);\n-        }\n-\n-        long difference = (minuendMillis - subtrahendMillis) / getUnitMillis();\n-        if (add(subtrahendMillis, difference) < minuendMillis) {\n-            do {\n-                difference++;\n-            } while (add(subtrahendMillis, difference) <= minuendMillis);\n-            difference--;\n-        } else if (add(subtrahendMillis, difference) > minuendMillis) {\n-            do {\n-                difference--;\n-            } while (add(subtrahendMillis, difference) > minuendMillis);\n-        }\n-        return difference;\n-    }\n+    public int getDifference(long minuendInstant, long subtrahendInstant);\n+\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * long v = ...\n+     * long age = getDifferenceAsLong(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant);\n \n     /**\n      * Sets a value in the milliseconds supplied.\n      * The value of this field will be set. If the value is invalid, an\n      * exception if thrown. Other fields are always unaffected.\n      * \n-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n      * @param value  the value to set, in the units of the field\n      * @return the updated milliseconds\n      * @throws IllegalArgumentException if the value is invalid\n      */\n-    public abstract long set(long millis, int value);\n+    public long set(long instant, int value);\n \n     /**\n      * Sets a value in the milliseconds supplied from a human-readable, text\n      * value. If the specified locale is null, the default locale is used.\n-     * <p>\n-     * The default implementation returns set(millis,\n-     * Integer.parseInt(millis)).\n-     * <p>\n-     * Note: subclasses that override this method should also override\n-     * getAsText.\n-     *\n-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n      * @param text  the text value to set\n      * @param locale the locale to use for selecting a text symbol, null for\n      * default\n      * @return the updated milliseconds\n      * @throws IllegalArgumentException if the text value is invalid\n      */\n-    public long set(long millis, String text, Locale locale) {\n-        try {\n-            return set(millis, Integer.parseInt(text));\n-        } catch (NumberFormatException ex) {\n-            throw new IllegalArgumentException(\"Invalid \" + getName() + \" text: \" + text);\n-        }\n-    }\n+    public long set(long instant, String text, Locale locale);\n \n     /**\n      * Sets a value in the milliseconds supplied from a human-readable, text\n-     * value. This implementation returns set(millis, text, null).\n-     * \n-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * value.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n      * @param text  the text value to set\n      * @return the updated milliseconds\n      * @throws IllegalArgumentException if the text value is invalid\n      */\n-    public final long set(long millis, String text) {\n-        return set(millis, text, null);\n-    }\n+    public long set(long instant, String text);\n \n     // Extra information API\n     //------------------------------------------------------------------------\n     /**\n-     * Returns whether this field is 'leap' for the specified millis.\n+     * Returns the duration per unit value of this field. For example, if this\n+     * field represents \"hour of day\", then the duration is an hour.\n+     *\n+     * @return the duration of this field, or UnsupportedDurationField if field\n+     * has no duration\n+     */\n+    public DurationField getDurationField();\n+\n+    /**\n+     * Returns the range duration of this field. For example, if this field\n+     * represents \"hour of day\", then the range duration is a day.\n+     *\n+     * @return the range duration of this field, or null if field has no range\n+     */\n+    public DurationField getRangeDurationField();\n+\n+    /**\n+     * Returns whether this field is 'leap' for the specified instant.\n      * <p>\n      * For example, a leap year would return true, a non leap year would return\n      * false.\n-     * <p>\n-     * This implementation returns false.\n      * \n      * @return true if the field is 'leap'\n      */\n-    public boolean isLeap(long millis) {\n-        return false;\n-    }\n-\n-    /**\n-     * Gets the amount by which this field is 'leap' for the specified millis.\n+    public boolean isLeap(long instant);\n+\n+    /**\n+     * Gets the amount by which this field is 'leap' for the specified instant.\n      * <p>\n      * For example, a leap year would return one, a non leap year would return\n      * zero.\n-     * <p>\n-     * This implementation returns zero.\n-     */\n-    public int getLeapAmount(long millis) {\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns the amount of milliseconds per unit value of this field. For\n-     * example, if this field represents \"hour of day\", then the unit is the\n-     * amount of milliseconds per one hour.\n-     * <p>\n-     * For fields with a variable unit size, this method returns a suitable\n-     * average value.\n-     *\n-     * @return the unit size of this field, in milliseconds\n-     */\n-    public abstract long getUnitMillis();\n-\n-    /**\n-     * Returns the range of this field, in milliseconds. For example, if this\n-     * field represents \"hour of day\", then the range is the amount of\n-     * milliseconds per one day.\n-     * <p>\n-     * For fields with a variable range, this method returns a suitable average\n-     * value. If the range is too large to fit in a long, Long.MAX_VALUE is\n-     * returned.\n-     *\n-     * @return the range of this field, in milliseconds\n-     */\n-    public abstract long getRangeMillis();\n+     */\n+    public int getLeapAmount(long instant);\n+\n+    /**\n+     * If this field were to leap, then it would be in units described by the\n+     * returned duration. If this field doesn't ever leap, null is returned.\n+     */\n+    public DurationField getLeapDurationField();\n \n     /**\n      * Get the minimum allowable value for this field.\n      * @return the minimum valid value for this field, in the units of the\n      * field\n      */\n-    public abstract int getMinimumValue();\n+    public int getMinimumValue();\n \n     /**\n      * Get the minimum value for this field evaluated at the specified time.\n-     * <p>\n-     * This implementation returns the same as {@link #getMinimumValue()}.\n-     * \n-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n      * @return the minimum value for this field, in the units of the field\n      */\n-    public int getMinimumValue(long millis) {\n-        return getMinimumValue();\n-    }\n+    public int getMinimumValue(long instant);\n \n     /**\n      * Get the maximum allowable value for this field.\n      * @return the maximum valid value for this field, in the units of the\n      * field\n      */\n-    public abstract int getMaximumValue();\n+    public int getMaximumValue();\n \n     /**\n      * Get the maximum value for this field evaluated at the specified time.\n-     * <p>\n-     * This implementation returns the same as {@link #getMaximumValue()}.\n-     * \n-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n      * @return the maximum value for this field, in the units of the field\n      */\n-    public int getMaximumValue(long millis) {\n-        return getMaximumValue();\n-    }\n-\n-    /**\n-     * Get the maximum text value for this field. The default implementation\n-     * returns the equivalent of Integer.toString(getMaximumValue()).length().\n+    public int getMaximumValue(long instant);\n+\n+    /**\n+     * Get the maximum text value for this field.\n      * \n      * @param locale  the locale to use for selecting a text symbol\n      * @return the maximum text length\n      */\n-    public int getMaximumTextLength(Locale locale) {\n-        int max = getMaximumValue();\n-        if (max >= 0) {\n-            if (max < 10) {\n-                return 1;\n-            } else if (max < 100) {\n-                return 2;\n-            } else if (max < 1000) {\n-                return 3;\n-            }\n-        }\n-        return Integer.toString(max).length();\n-    }\n-\n-    /**\n-     * Get the maximum short text value for this field. The default\n-     * implementation returns getMaximumTextLength().\n+    public int getMaximumTextLength(Locale locale);\n+\n+    /**\n+     * Get the maximum short text value for this field.\n      * \n      * @param locale  the locale to use for selecting a text symbol\n      * @return the maximum short text length\n      */\n-    public int getMaximumShortTextLength(Locale locale) {\n-        return getMaximumTextLength(locale);\n-    }\n+    public int getMaximumShortTextLength(Locale locale);\n \n     // Calculation API\n     //------------------------------------------------------------------------\n      * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the\n      * lowest whole hour is 2002-11-02T23:00:00.000.\n      *\n-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n      * @return rounded milliseconds\n      */\n-    public abstract long roundFloor(long millis);\n+    public long roundFloor(long instant);\n \n     /**\n      * Round to the highest whole unit of this field. The value of this field\n      * <p>\n      * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the\n      * highest whole hour is 2002-11-03T00:00:00.000.\n-     * <p>\n-     * The default implementation calls roundFloor, and if the millis is\n-     * modified as a result, adds one field unit. Subclasses are encouraged to\n-     * provide a more efficient implementation.\n-     *\n-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to round\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n      * @return rounded milliseconds\n      */\n-    public long roundCeiling(long millis) {\n-        long newMillis = roundFloor(millis);\n-        if (newMillis != millis) {\n-            millis = add(newMillis, 1);\n-        }\n-        return millis;\n-    }\n+    public long roundCeiling(long instant);\n \n     /**\n      * Round to the nearest whole unit of this field. If the given millisecond\n      * behaves like roundFloor. If the millisecond value is closer to the\n      * ceiling, this function behaves like roundCeiling.\n      *\n-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n      * @return rounded milliseconds\n      */\n-    public long roundHalfFloor(long millis) {\n-        long floor = roundFloor(millis);\n-        long ceiling = roundCeiling(millis);\n-\n-        long diffFromFloor = millis - floor;\n-        long diffToCeiling = ceiling - millis;\n-\n-        if (diffFromFloor <= diffToCeiling) {\n-            // Closer to the floor, or halfway - round floor\n-            return floor;\n-        } else {\n-            return ceiling;\n-        }\n-    }\n+    public long roundHalfFloor(long instant);\n \n     /**\n      * Round to the nearest whole unit of this field. If the given millisecond\n      * the millisecond value is closer to the ceiling or is exactly halfway,\n      * this function behaves like roundCeiling.\n      *\n-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n      * @return rounded milliseconds\n      */\n-    public long roundHalfCeiling(long millis) {\n-        long floor = roundFloor(millis);\n-        long ceiling = roundCeiling(millis);\n-\n-        long diffFromFloor = millis - floor;\n-        long diffToCeiling = ceiling - millis;\n-\n-        if (diffToCeiling <= diffFromFloor) {\n-            // Closer to the ceiling, or halfway - round ceiling\n-            return ceiling;\n-        } else {\n-            return floor;\n-        }\n-    }\n+    public long roundHalfCeiling(long instant);\n \n     /**\n      * Round to the nearest whole unit of this field. If the given millisecond\n      * ceiling, the ceiling is chosen over the floor only if it makes this\n      * field's value even.\n      *\n-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n      * @return rounded milliseconds\n      */\n-    public long roundHalfEven(long millis) {\n-        long floor = roundFloor(millis);\n-        long ceiling = roundCeiling(millis);\n-\n-        long diffFromFloor = millis - floor;\n-        long diffToCeiling = ceiling - millis;\n-\n-        if (diffFromFloor < diffToCeiling) {\n-            // Closer to the floor - round floor\n-            return floor;\n-        } else if (diffToCeiling < diffFromFloor) {\n-            // Closer to the ceiling - round ceiling\n-            return ceiling;\n-        } else {\n-            // Round to the millis that makes this field even. If both values\n-            // make this field even (unlikely), favor the ceiling.\n-            if ((get(ceiling) & 1) == 0) {\n-                return ceiling;\n-            }\n-            return floor;\n-        }\n-    }\n-\n-    /**\n-     * Retains only the fractional units of this field. This field value and\n-     * all fields of higher magnitude are reset. In other words, calling\n-     * remainder retains the part of the instant that roundFloor dropped.\n-     * <p>\n-     * For example, a datetime of 2002-11-02T23:34:56.789, the remainder by\n-     * hour is 1970-01-01T00:34:56.789.\n-     * <p>\n-     * The default implementation computes\n-     * <code>millis - roundFloor(millis)</code>. Subclasses are encouraged to\n-     * provide a more efficient implementation.\n-     *\n-     * @param millis the milliseconds from 1970-01-01T00:00:00Z to get the\n+    public long roundHalfEven(long instant);\n+\n+    /**\n+     * Returns the fractional duration milliseconds of this field. In other\n+     * words, calling remainder returns the duration that roundFloor would\n+     * subtract.\n+     * <p>\n+     * For example, on a datetime of 2002-11-02T23:34:56.789, the remainder by\n+     * hour is 34 minutes and 56.789 seconds.\n+     *\n+     * @param instant the milliseconds from 1970-01-01T00:00:00Z to get the\n      * remainder\n-     * @return remainder milliseconds\n-     */\n-    public long remainder(long millis) {\n-        return millis - roundFloor(millis);\n-    }\n-\n-    // Implementation helper methods\n-    //------------------------------------------------------------------------\n-    /**\n-     * Verify that input values are within specified bounds.\n-     * \n-     * @param value  the value to check\n-     * @param lowerBound  the lower bound allowed for value\n-     * @param upperBound  the upper bound allowed for value\n-     * @throws IllegalArgumentException if value is not in the specified bounds\n-     */\n-    protected void verifyValueBounds(int value, int lowerBound, int upperBound) {\n-        if ((value < lowerBound) || (value > upperBound)) {\n-            throw new IllegalArgumentException(\n-                \"Value: \"\n-                    + value\n-                    + \" for \"\n-                    + iName\n-                    + \" must be in the range (\"\n-                    + lowerBound\n-                    + ','\n-                    + upperBound\n-                    + ')');\n-        }\n-    }\n-\n-    /**\n-     * Utility method used by addWrapped implementations to ensure the new\n-     * value lies within the field's legal value range.\n-     *\n-     * @param currentValue the current value of the data, which may lie outside\n-     * the wrapped value range\n-     * @param wrapValue  the value to add to current value before\n-     *  wrapping.  This may be negative.\n-     * @param minValue the wrap range minimum value.\n-     * @param maxValue the wrap range maximum value.  This must be\n-     *  greater than minValue (checked by the method).\n-     * @return the wrapped value\n-     * @throws IllegalArgumentException if minValue is greater\n-     *  than or equal to maxValue\n-     */\n-    protected final int getWrappedValue(int currentValue, int wrapValue,\n-                                        int minValue, int maxValue) {\n-        return getWrappedValue(currentValue + wrapValue, minValue, maxValue);\n-    }\n-\n-    /**\n-     * Utility method that ensures the given value lies within the field's\n-     * legal value range.\n-     * \n-     * @param value  the value to fit into the wrapped value range\n-     * @param minValue the wrap range minimum value.\n-     * @param maxValue the wrap range maximum value.  This must be\n-     *  greater than minValue (checked by the method).\n-     * @return the wrapped value\n-     * @throws IllegalArgumentException if minValue is greater\n-     *  than or equal to maxValue\n-     */\n-    protected final int getWrappedValue(int value, int minValue, int maxValue) {\n-        if (minValue >= maxValue) {\n-            throw new IllegalArgumentException(\"MIN > MAX\");\n-        }\n-\n-        int wrapRange = maxValue - minValue + 1;\n-        value -= minValue;\n-\n-        if (value >= 0) {\n-            return (value % wrapRange) + minValue;\n-        }\n-\n-        int remByRange = (-value) % wrapRange;\n-\n-        if (remByRange == 0) {\n-            return 0 + minValue;\n-        }\n-        return (wrapRange - remByRange) + minValue;\n-    }\n-\n-    /**\n-     * If value can be safely cast to an int, then add(long, int) is called,\n-     * returning its result. Otherwise, an IllegalArgumentException is thrown.\n-     *\n-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to add to\n-     * @param value  the value to add, in the units of the field\n-     * @return the updated milliseconds\n-     * @throws IllegalArgumentException if value is too large\n-     */\n-    protected long addLong(long millis, long value) {\n-        int i_value = (int)value;\n-        if (i_value == value) {\n-            return add(millis, i_value);\n-        }\n-        throw new IllegalArgumentException\n-            (\"Magnitude of add amount is too large: \" + value);\n-    }\n+     * @return remainder duration, in milliseconds\n+     */\n+    public long remainder(long instant);\n \n     /**\n      * Get a suitable debug string.\n      * \n      * @return debug string\n      */\n-    public String toString() {\n-        return \"DateTimeField[\" + iName + ']';\n-    }\n+    public String toString();\n     \n }\n--- a/JodaTime/src/java/org/joda/time/DateTimeFieldProperty.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeFieldProperty.java\n package org.joda.time;\n \n import java.util.Locale;\n-import java.io.Serializable;\n \n /**\n- * DateTimeFieldProperty binds a ReadableInstant to a DateTimeField.\n+ * DateTimeFieldProperty binds a DateTime to a DateTimeField allowing powerful\n+ * datetime functionality to be easily accessed.\n  * <p>\n- * DateTimeFieldProperty allows the date and time manipulation code to be \n- * field based yet still easy to use.\n+ * The simplest use of this class is as an alternative get method, here used to\n+ * get the year '1972' (as an int) and the month 'December' (as a String).\n+ * <pre>\n+ * DateTime dt = new DateTime(1972, 12, 3, 0, 0, 0, 0);\n+ * int year = dt.year().get();\n+ * String monthStr = dt.month().getAsText();\n+ * </pre>\n+ * <p>\n+ * Methods are also provided that allow date modification. These return new instances\n+ * of DateTime - they do not modify the original. The example below yields two\n+ * independent immutable date objects 20 years apart.\n+ * <pre>\n+ * DateTime dt = new DateTime(1972, 12, 3, 0, 0, 0, 0);\n+ * DateTime dt20 = dt.year().addToCopy(20);\n+ * </pre>\n+ * Serious modification of dates (ie. more than just changing one or two fields)\n+ * should use the {@link MutableDateTime} class.\n+ * <p>\n+ * DateTimeFieldPropery itself is thread-safe and immutable, as well as the\n+ * DateTime being operated on.\n  *\n  * @see ReadableInstant\n  * @see DateTimeField\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public class DateTimeFieldProperty implements Serializable {\n+public class DateTimeFieldProperty extends AbstractDateTimeFieldProperty {\n     \n+    static final long serialVersionUID = -6983323811635733510L;\n+\n     /** The instant this property is working against */\n-    private final ReadableInstant iInstant;\n+    private final DateTime iInstant;\n     /** The field this property is working against */\n     private final DateTimeField iField;\n \n      * @param instant  the instant to set\n      * @param field  the field to use\n      */\n-    public DateTimeFieldProperty(ReadableInstant instant, DateTimeField field) {\n+    public DateTimeFieldProperty(DateTime instant, DateTimeField field) {\n         super();\n         iInstant = instant;\n         iField = field;\n     }\n \n     /**\n-     * Gets the name of the field.\n-     * \n-     * @return the field name\n-     */\n-    public String getName() {\n-        return iField.getName();\n-    }\n-\n-    /**\n      * Gets the instant being used.\n      * \n      * @return the instant\n      */\n-    public ReadableInstant getInstant() {\n+    public ReadableDateTime getInstant() {\n         return iInstant;\n     }\n \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets a value from the instant.\n-     * \n-     * @return the current value\n-     * @see DateTimeField#get\n-     */\n-    public int get() {\n-        return iField.get(iInstant.getMillis());\n-    }\n-\n-    /**\n-     * Gets a text value from the instant.\n-     * \n+    /**\n+     * Gets the instant being used.\n+     * \n+     * @return the instant\n+     */\n+    public DateTime getDateTime() {\n+        return iInstant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds to this field in a copy of this DateTime.\n+     * <p>\n+     * The DateTime attached to this property is unchanged by this call.\n+     * This operation is faster than converting a DateTime to a MutableDateTime\n+     * and back again when setting one field. When setting multiple fields,\n+     * it is generally quicker to make the conversion to MutableDateTime.\n+     * \n+     * @param value  the value to add to the field in the copy\n+     * @return a copy of the DateTime with the field value changed\n+     * @throws IllegalArgumentException if the value isn't valid\n+     */\n+    public DateTime addToCopy(int value) {\n+        long newMillis = iField.add(iInstant.getMillis(), value);\n+        return iInstant.createDateTime(newMillis, iInstant.getChronology());\n+    }\n+\n+    /**\n+     * Adds to this field in a copy of this DateTime.\n+     * <p>\n+     * The DateTime attached to this property is unchanged by this call.\n+     * This operation is faster than converting a DateTime to a MutableDateTime\n+     * and back again when setting one field. When setting multiple fields,\n+     * it is generally quicker to make the conversion to MutableDateTime.\n+     * \n+     * @param value  the value to add to the field in the copy\n+     * @return a copy of the DateTime with the field value changed\n+     * @throws IllegalArgumentException if the value isn't valid\n+     */\n+    public DateTime addToCopy(long value) {\n+        long newMillis = iField.add(iInstant.getMillis(), value);\n+        return iInstant.createDateTime(newMillis, iInstant.getChronology());\n+    }\n+\n+    /**\n+     * Adds to this field, possibly wrapped, in a copy of this DateTime.\n+     * A wrapped operation only changes this field.\n+     * Thus 31st January addWrapped one day goes to the 1st January.\n+     * <p>\n+     * The DateTime attached to this property is unchanged by this call.\n+     * This operation is faster than converting a DateTime to a MutableDateTime\n+     * and back again when setting one field. When setting multiple fields,\n+     * it is generally quicker to make the conversion to MutableDateTime.\n+     * \n+     * @param value  the value to add to the field in the copy\n+     * @return a copy of the DateTime with the field value changed\n+     * @throws IllegalArgumentException if the value isn't valid\n+     */\n+    public DateTime addWrappedToCopy(int value) {\n+        long newMillis = iField.addWrapped(iInstant.getMillis(), value);\n+        return iInstant.createDateTime(newMillis, iInstant.getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets this field in a copy of the DateTime.\n+     * <p>\n+     * The DateTime attached to this property is unchanged by this call.\n+     * This operation is faster than converting a DateTime to a MutableDateTime\n+     * and back again when setting one field. When setting multiple fields,\n+     * it is generally quicker to make the conversion to MutableDateTime.\n+     * \n+     * @param value  the value to set the field in the copy to\n+     * @return a copy of the DateTime with the field value changed\n+     * @throws IllegalArgumentException if the value isn't valid\n+     */\n+    public DateTime setCopy(int value) {\n+        long newMillis = iField.set(iInstant.getMillis(), value);\n+        return iInstant.createDateTime(newMillis, iInstant.getChronology());\n+    }\n+    \n+    /**\n+     * Sets this field in a copy of the DateTime to a parsed text value.\n+     * <p>\n+     * The DateTime attached to this property is unchanged by this call.\n+     * This operation is faster than converting a DateTime to a MutableDateTime\n+     * and back again when setting one field. When setting multiple fields,\n+     * it is generally quicker to make the conversion to MutableDateTime.\n+     * \n+     * @param text  the text value to set\n      * @param locale  optional locale to use for selecting a text symbol\n-     * @return the current text value\n-     * @see DateTimeField#getAsText\n-     */\n-    public String getAsText(Locale locale) {\n-        return iField.getAsText(iInstant.getMillis(), locale);\n-    }\n-\n-    /**\n-     * Gets a text value from the instant.\n-     * \n-     * @return the current text value\n-     * @see DateTimeField#getAsText\n-     */\n-    public final String getAsText() {\n-        return iField.getAsText(iInstant.getMillis(), null);\n-    }\n-\n-    /**\n-     * Gets a short text value from the instant.\n-     * \n-     * @param locale  optional locale to use for selecting a text symbol\n-     * @return the current text value\n-     * @see DateTimeField#getAsShortText\n-     */\n-    public String getAsShortText(Locale locale) {\n-        return iField.getAsShortText(iInstant.getMillis(), locale);\n-    }\n-\n-    /**\n-     * Gets a short text value from the instant.\n-     * \n-     * @return the current text value\n-     * @see DateTimeField#getAsShortText\n-     */\n-    public final String getAsShortText() {\n-        return getAsShortText(null);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Returns the difference between this field property instant and the one\n-     * passed in, in the units of this field. The sign of the difference\n-     * matches that of compareTo. In other words, this field property's instant\n-     * is the minuend.\n-     *\n-     * @param instant the subtrahend\n-     * @return the difference in the units of this field\n-     * @see DateTimeField#getDifference\n-     */\n-    public long getDifference(ReadableInstant instant) {\n-        if (instant == null) {\n-            throw new IllegalArgumentException(\"The instant must not be null\");\n-        }\n-        return iField.getDifference(iInstant.getMillis(), instant.getMillis());\n-    }\n-\n-    /**\n-     * Gets whether this field is leap.\n-     * \n-     * @return true if a leap field\n-     * @see DateTimeField#isLeap\n-     */\n-    public boolean isLeap() {\n-        return iField.isLeap(iInstant.getMillis());\n-    }\n-\n-    /**\n-     * Gets the amount by which this field is leap.\n-     * \n-     * @return the amount by which the field is leap\n-     * @see DateTimeField#getLeapAmount\n-     */\n-    public int getLeapAmount() {\n-        return iField.getLeapAmount(iInstant.getMillis());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the minimum value for the field ignoring the current time.\n-     * \n-     * @return the minimum value\n-     * @see DateTimeField#getMinimumValue\n-     */\n-    public int getMinimumValueOverall() {\n-        return iField.getMinimumValue();\n-    }\n-\n-    /**\n-     * Gets the minimum value for the field.\n-     * \n-     * @return the minimum value\n-     * @see DateTimeField#getMinimumValue\n-     */\n-    public int getMinimumValue() {\n-        return iField.getMinimumValue(iInstant.getMillis());\n-    }\n-\n-    /**\n-     * Gets the maximum value for the field ignoring the current time.\n-     * \n-     * @return the maximum value\n-     * @see DateTimeField#getMaximumValue\n-     */\n-    public int getMaximumValueOverall() {\n-        return iField.getMaximumValue();\n-    }\n-\n-    /**\n-     * Gets the maximum value for the field.\n-     * \n-     * @return the maximum value\n-     * @see DateTimeField#getMaximumValue\n-     */\n-    public int getMaximumValue() {\n-        return iField.getMaximumValue(iInstant.getMillis());\n-    }\n-\n-    /**\n-     * Gets the maximum text length for the field.\n-     * \n-     * @param locale  optional locale to use for selecting a text symbol\n-     * @return the maximum length\n-     * @see DateTimeField#getMaximumTextLength\n-     */\n-    public int getMaximumTextLength(Locale locale) {\n-        return iField.getMaximumTextLength(locale);\n-    }\n-\n-    /**\n-     * Gets the maximum short text length for the field.\n-     * \n-     * @param locale  optional locale to use for selecting a text symbol\n-     * @return the maximum length\n-     * @see DateTimeField#getMaximumShortTextLength\n-     */\n-    public int getMaximumShortTextLength(Locale locale) {\n-        return iField.getMaximumShortTextLength(locale);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Returns the amount of milliseconds per unit value of this field. For\n-     * example, if this field represents \"hour of day\", then the unit is the\n-     * amount of milliseconds per one hour.\n-     * <p>\n-     * For fields with a variable unit size, this method returns a suitable\n-     * average value.\n-     *\n-     * @return the unit size of this field, in milliseconds\n-     */\n-    public long getUnitMillis() {\n-        return iField.getUnitMillis();\n-    }\n-\n-    /**\n-     * Returns the range of this field, in milliseconds. For example, if this\n-     * field represents \"hour of day\", then the range is the amount of\n-     * milliseconds per one day.\n-     * <p>\n-     * For fields with a variable range, this method returns a suitable average\n-     * value. If the range is too large to fit in a long, Long.MAX_VALUE is\n-     * returned.\n-     *\n-     * @return the range of this field, in milliseconds\n-     */\n-    public long getRangeMillis() {\n-        return iField.getRangeMillis();\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Compare this field to the same field on another instant.\n-     * <p>\n-     * The {@link #get()} method is used to obtain the value to compare for\n-     * this instant and the {@link ReadableInstant#get(DateTimeField)} method\n-     * is used for the specified instant.\n-     * \n-     * @param instant  the instant to compare to\n-     * @return -1 if this is less, +1 if more and 0 if equal\n-     * @throws IllegalArgumentException if the instant is null\n-     */\n-    public int compareTo(ReadableInstant instant) {\n-        if (instant == null) {\n-            throw new IllegalArgumentException(\"The instant must not be null\");\n-        }\n-        int thisValue = get();\n-        int otherValue = iField.get(instant.getMillis());\n-        if (thisValue < otherValue) {\n-            return -1;\n-        } else if (thisValue > otherValue) {\n-            return 1;\n-        } else {\n-            return 0;\n-        }\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Output a debugging string.\n-     * \n-     * @return debugging string\n-     */\n-    public String toString() {\n-        return \"DateTimeFieldProperty[\" + getName() + \"]\";\n+     * @return a copy of the DateTime with the field value changed\n+     * @throws IllegalArgumentException if the text value isn't valid\n+     */\n+    public DateTime setCopy(String text, Locale locale) {\n+        long newMillis = iField.set(iInstant.getMillis(), text, locale);\n+        return iInstant.createDateTime(newMillis, iInstant.getChronology());\n+    }\n+\n+    /**\n+     * Sets this field in a copy of the DateTime to a parsed text value.\n+     * <p>\n+     * The DateTime attached to this property is unchanged by this call.\n+     * This operation is faster than converting a DateTime to a MutableDateTime\n+     * and back again when setting one field. When setting multiple fields,\n+     * it is generally quicker to make the conversion to MutableDateTime.\n+     * \n+     * @param text  the text value to set\n+     * @return a copy of the DateTime with the field value changed\n+     * @throws IllegalArgumentException if the text value isn't valid\n+     */\n+    public final DateTime setCopy(String text) {\n+        return setCopy(text, null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Rounds to the lowest whole unit of this field on a copy of this DateTime.\n+     *\n+     * @return a copy of the DateTime with the field value changed\n+     */\n+    public DateTime roundFloorCopy() {\n+        long newMillis = iField.roundFloor(iInstant.getMillis());\n+        return iInstant.createDateTime(newMillis, iInstant.getChronology());\n+    }\n+\n+    /**\n+     * Rounds to the highest whole unit of this field on a copy of this DateTime.\n+     *\n+     * @return a copy of the DateTime with the field value changed\n+     */\n+    public DateTime roundCeilingCopy() {\n+        long newMillis = iField.roundCeiling(iInstant.getMillis());\n+        return iInstant.createDateTime(newMillis, iInstant.getChronology());\n+    }\n+\n+    /**\n+     * Rounds to the nearest whole unit of this field on a copy of this DateTime,\n+     * favoring the floor if halfway.\n+     *\n+     * @return a copy of the DateTime with the field value changed\n+     */\n+    public DateTime roundHalfFloorCopy() {\n+        long newMillis = iField.roundHalfFloor(iInstant.getMillis());\n+        return iInstant.createDateTime(newMillis, iInstant.getChronology());\n+    }\n+\n+    /**\n+     * Rounds to the nearest whole unit of this field on a copy of this DateTime,\n+     * favoring the ceiling if halfway.\n+     *\n+     * @return a copy of the DateTime with the field value changed\n+     */\n+    public DateTime roundHalfCeilingCopy() {\n+        long newMillis = iField.roundHalfCeiling(iInstant.getMillis());\n+        return iInstant.createDateTime(newMillis, iInstant.getChronology());\n+    }\n+\n+    /**\n+     * Rounds to the nearest whole unit of this field on a copy of this DateTime.\n+     * If halfway, the ceiling is favored over the floor only if it makes this field's value even.\n+     *\n+     * @return a copy of the DateTime with the field value changed\n+     */\n+    public DateTime roundHalfEvenCopy() {\n+        long newMillis = iField.roundHalfEven(iInstant.getMillis());\n+        return iInstant.createDateTime(newMillis, iInstant.getChronology());\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java\n import java.io.ObjectOutputStream;\n import java.io.ObjectStreamException;\n import java.io.Serializable;\n-import java.text.ParseException;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Locale;\n \n import org.joda.time.format.DateTimeFormatter;\n import org.joda.time.format.DateTimeFormatterBuilder;\n+import org.joda.time.tz.DateTimeZonePermission;\n import org.joda.time.tz.DefaultNameProvider;\n import org.joda.time.tz.FixedDateTimeZone;\n import org.joda.time.tz.NameProvider;\n  * However, the factory that accepts a TimeZone will attempt to convert from\n  * the old short id to a suitable long id.\n  * <p>\n+ * DateTimeZone is thread-safe and immutable, and all subclasses must be as\n+ * well.\n  * \n  * @author Brian S O'Neill\n  * @author Stephen Colebourne\n  */\n public abstract class DateTimeZone implements Serializable {\n     \n+    static final long serialVersionUID = 5546345482340108586L;\n+\n     /** The UTC time zone */\n     public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n \n     private static Map cZoneIdConversion;\n \n     static {\n-        Provider provider = null;\n-\n-        String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n-        if (providerClass != null) {\n-            try {\n-                provider = (Provider)Class.forName(providerClass).newInstance();\n-            }\n-            catch (Exception e) {\n-                Thread t = Thread.currentThread();\n-                t.getThreadGroup().uncaughtException(t, e);\n-            }\n-        }\n-\n-        if (provider == null) {\n-            try {\n-                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n-            } catch (Exception e) {\n-                Thread t = Thread.currentThread();\n-                t.getThreadGroup().uncaughtException(t, e);\n-            }\n-        }\n-\n-        if (provider == null) {\n-            provider = new UTCProvider();\n-        }\n-\n-        setProvider(provider);\n-\n-        NameProvider nameProvider = null;\n-\n-        providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n-        if (providerClass != null) {\n-            try {\n-                nameProvider = (NameProvider)Class.forName(providerClass).newInstance();\n-            }\n-            catch (Exception e) {\n-                Thread t = Thread.currentThread();\n-                t.getThreadGroup().uncaughtException(t, e);\n-            }\n-        }\n-\n-        if (nameProvider == null) {\n-            nameProvider = new DefaultNameProvider();\n-        }\n-\n-        setNameProvider(nameProvider);\n+        setProvider0(null);\n+        setNameProvider0(null);\n \n         try {\n             try {\n      * @throws IllegalArgumentException if the zone is null\n      */\n     public static void setDefault(DateTimeZone zone) throws SecurityException {\n-        // TODO: Put in a security check.\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkPermission(new DateTimeZonePermission(\"setDefault\"));\n+        }\n         if (zone == null) {\n             throw new IllegalArgumentException(\"The datetime zone must not be null\");\n         }\n             return zone;\n         }\n         if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n-            try {\n-                int offset = -(int)offsetFormatter().parseMillis(id);\n-                // Canonicalize the id.\n-                id = offsetFormatter().print(0, UTC, offset);\n-                return new FixedDateTimeZone(id, null, offset, offset);\n-            } catch (ParseException e) {\n-                throw new IllegalArgumentException(e.getMessage());\n-            }\n+            int offset = -(int)offsetFormatter().parseMillis(id);\n+            // Canonicalize the id.\n+            id = offsetFormatter().print(0, UTC, offset);\n+            return new FixedDateTimeZone(id, null, offset, offset);\n         }\n         throw new IllegalArgumentException(\"The datetime zone id is not recognised: \" + id);\n     }\n             convId = zone.getDisplayName();\n             if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                 convId = convId.substring(3);\n-                try {\n-                    int offset = -(int)offsetFormatter().parseMillis(convId);\n-                    // Canonicalize the id.\n-                    convId = offsetFormatter().print(0, UTC, offset);\n-                    return new FixedDateTimeZone(convId, null, offset, offset);\n-                } catch (ParseException e) {\n-                    throw new IllegalArgumentException(e.getMessage());\n-                }\n+                int offset = -(int)offsetFormatter().parseMillis(convId);\n+                // Canonicalize the id.\n+                convId = offsetFormatter().print(0, UTC, offset);\n+                return new FixedDateTimeZone(convId, null, offset, offset);\n             }\n         }\n \n         return cProvider;\n     }\n \n+    /**\n+     * @param provider provider to use, or null for default\n+     */\n     public static void setProvider(Provider provider) throws SecurityException {\n-        // TODO: Put in a security check.\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkPermission(new DateTimeZonePermission(\"setProvider\"));\n+        }\n+        setProvider0(provider);\n+    }\n+\n+    /**\n+     * Doesn't perform a security check.\n+     */\n+    private static void setProvider0(Provider provider) {\n         if (provider == null) {\n-            throw new IllegalArgumentException(\"The provider must not be null\");\n+            provider = getDefaultProvider();\n         }\n         Set ids = provider.getAvailableIDs();\n         if (ids == null || ids.size() == 0) {\n         return cNameProvider;\n     }\n \n+    /**\n+     * @param nameProvider provider to use, or null for default\n+     */\n     public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n-        // TODO: Put in a security check.\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkPermission(new DateTimeZonePermission(\"setNameProvider\"));\n+        }\n+        setNameProvider0(nameProvider);\n+    }\n+\n+    /**\n+     * Doesn't perform a security check.\n+     */\n+    private static void setNameProvider0(NameProvider nameProvider) {\n         if (nameProvider == null) {\n-            throw new IllegalArgumentException(\"The provider must not be null\");\n+            nameProvider = getDefaultNameProvider();\n         }\n         cNameProvider = nameProvider;\n     }\n         return cOffsetFormatter;\n     }\n \n+    private static Provider getDefaultProvider() {\n+        Provider provider = null;\n+\n+        try {\n+            String providerClass =\n+                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n+            if (providerClass != null) {\n+                try {\n+                    provider = (Provider)Class.forName(providerClass).newInstance();\n+                }\n+                catch (Exception e) {\n+                    Thread t = Thread.currentThread();\n+                    t.getThreadGroup().uncaughtException(t, e);\n+                }\n+            }\n+        } catch (SecurityException e) {\n+        }\n+\n+        if (provider == null) {\n+            try {\n+                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n+            } catch (Exception e) {\n+                Thread t = Thread.currentThread();\n+                t.getThreadGroup().uncaughtException(t, e);\n+            }\n+        }\n+\n+        if (provider == null) {\n+            provider = new UTCProvider();\n+        }\n+\n+        return provider;\n+    }\n+\n+    private static NameProvider getDefaultNameProvider() {\n+        NameProvider nameProvider = null;\n+\n+        try {\n+            String providerClass =\n+                System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n+            if (providerClass != null) {\n+                try {\n+                    nameProvider = (NameProvider)Class.forName(providerClass).newInstance();\n+                }\n+                catch (Exception e) {\n+                    Thread t = Thread.currentThread();\n+                    t.getThreadGroup().uncaughtException(t, e);\n+                }\n+            }\n+        } catch (SecurityException e) {\n+        }\n+\n+        if (nameProvider == null) {\n+            nameProvider = new DefaultNameProvider();\n+        }\n+\n+        return nameProvider;\n+    }\n+\n     // Instance fields and methods\n     //--------------------------------------------------------------------\n \n      * Returns a non-localized name that is unique to this time zone. It can be\n      * combined with id to form a unique key for fetching localized names.\n      *\n-     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the name for\n      * @return name key or null if id should be used for names\n      */\n-    public abstract String getNameKey(long millis);\n+    public abstract String getNameKey(long instant);\n \n     /**\n      * Gets the short name of this datetime zone suitable for display using\n      * If the name is not available for the locale, then this method returns a\n      * string in the format <code>[+-]hh:mm</code>.\n      * \n-     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the name for\n      * @return the human-readable short name in the default locale\n      */\n-    public final String getShortName(long millis) {\n-        return getShortName(millis, null);\n+    public final String getShortName(long instant) {\n+        return getShortName(instant, null);\n     }\n \n     /**\n      * If the name is not available for the locale, then this method returns a\n      * string in the format <code>[+-]hh:mm</code>.\n      * \n-     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the name for\n      * @return the human-readable short name in the specified locale\n      */\n-    public String getShortName(long millis, Locale locale) {\n+    public String getShortName(long instant, Locale locale) {\n         if (locale == null) {\n             locale = Locale.getDefault();\n         }\n-        String nameKey = getNameKey(millis);\n+        String nameKey = getNameKey(instant);\n         if (nameKey == null) {\n             return iID;\n         }\n         if (name != null) {\n             return name;\n         }\n-        return offsetFormatter().print(millis, this);\n+        return offsetFormatter().print(instant, this);\n     }\n \n     /**\n      * If the name is not available for the locale, then this method returns a\n      * string in the format <code>[+-]hh:mm</code>.\n      * \n-     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the name for\n      * @return the human-readable long name in the default locale\n      */\n-    public final String getName(long millis) {\n-        return getName(millis, null);\n+    public final String getName(long instant) {\n+        return getName(instant, null);\n     }\n \n     /**\n      * If the name is not available for the locale, then this method returns a\n      * string in the format <code>[+-]hh:mm</code>.\n      * \n-     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the name for\n      * @return the human-readable long name in the specified locale\n      */\n-    public String getName(long millis, Locale locale) {\n+    public String getName(long instant, Locale locale) {\n         if (locale == null) {\n             locale = Locale.getDefault();\n         }\n-        String nameKey = getNameKey(millis);\n+        String nameKey = getNameKey(instant);\n         if (nameKey == null) {\n             return iID;\n         }\n         if (name != null) {\n             return name;\n         }\n-        return offsetFormatter().print(millis, this);\n+        return offsetFormatter().print(instant, this);\n     }\n \n     /**\n      * Gets the millisecond offset to add to UTC to get local time.\n      * \n-     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the offset for\n+     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the offset for\n      * @return the millisecond offset to add to UTC to get local time\n      */\n-    public abstract int getOffset(long millis);\n+    public abstract int getOffset(long instant);\n \n     /**\n      * Gets the millisecond offset to add to UTC to get local time.\n      * Gets the standard millisecond offset to add to UTC to get local time,\n      * when standard time is in effect.\n      * \n-     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the offset for\n+     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the offset for\n      * @return the millisecond offset to add to UTC to get local time\n      */\n-    public abstract int getStandardOffset(long millis);\n+    public abstract int getStandardOffset(long instant);\n \n     /**\n      * Gets the millisecond offset to subtract from local time to get UTC time.\n      * offset transitions (due to DST or other historical changes), ranges of\n      * local times may map to different UTC times.\n      *\n-     * @param millisLocal the millisecond instant, relative to this time zone, to\n+     * @param instantLocal the millisecond instant, relative to this time zone, to\n      * get the offset for\n      * @return the millisceond offset to subtract from local time to get UTC time.\n      */\n-    public int getOffsetFromLocal(long millisLocal) {\n-        return getOffset(millisLocal - getOffset(millisLocal));\n-    }\n+    public int getOffsetFromLocal(long instantLocal) {\n+        return getOffset(instantLocal - getOffset(instantLocal));\n+    }\n+\n+    /**\n+     * Returns true if this time zone has no transitions.\n+     *\n+     * @return true if no transitions\n+     */\n+    public abstract boolean isFixed();\n \n     /**\n      * Advances the given instant to where the time zone offset or name\n      * changes. If the instant returned is exactly the same as passed in, then\n      * no changes occur after the given instant.\n      *\n-     * @param millis milliseconds from 1970-01-01T00:00:00Z\n+     * @param instant milliseconds from 1970-01-01T00:00:00Z\n      * @return milliseconds from 1970-01-01T00:00:00Z\n      */\n-    public abstract long nextTransition(long millis);\n+    public abstract long nextTransition(long instant);\n \n     /**\n      * Retreats the given instant to where the time zone offset or name\n      * changes. If the instant returned is exactly the same as passed in, then\n      * no changes occur before the given instant.\n      *\n-     * @param millis milliseconds from 1970-01-01T00:00:00Z\n+     * @param instant milliseconds from 1970-01-01T00:00:00Z\n      * @return milliseconds from 1970-01-01T00:00:00Z\n      */\n-    public abstract long previousTransition(long millis);\n+    public abstract long previousTransition(long instant);\n \n     // Basic methods\n     //--------------------------------------------------------------------\n      * @param object the object to compare with\n      * @return true if equal, based on the ID and all internal rules\n      */\n-    public abstract boolean equals(Object obj);\n+    public abstract boolean equals(Object object);\n \n     /**\n      * Gets a hash code compatable with equals.\n      * Used to serialize DateTimeZones by id.\n      */\n     private static final class Stub implements Serializable {\n+        static final long serialVersionUID = -6471952376487863581L;\n+\n         private transient String iID;\n \n         Stub(String id) {\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/Duration.java\n+/* \n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Standard immutable duration implementation split on any set of fields.\n+ * <p>\n+ * A duration can be divided into a number of fields, such as hours and seconds.\n+ * The way in which that divide occurs is controlled by the DurationType class.\n+ * <p>\n+ * Duration is thread-safe and immutable, provided that the DurationType is\n+ * as well. All standard DurationType classes supplied are thread-safe and\n+ * immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ * @see MutableDuration\n+ */\n+public class Duration extends AbstractDuration implements ReadableDuration, Serializable {\n+\n+    static final long serialVersionUID = 741052353876488155L;\n+\n+    /**\n+     * Copies another duration to this one.\n+     *\n+     * @throws UnsupportedOperationException if an unsupported field's value is\n+     * non-zero\n+     */\n+    public Duration(ReadableDuration duration) {\n+        super(duration);\n+    }\n+\n+    /**\n+     * Copies another duration to this one.\n+     *\n+     * @param type use a different DurationType\n+     * @throws UnsupportedOperationException if an unsupported field's value is\n+     * non-zero\n+     */\n+    public Duration(DurationType type, ReadableDuration duration) {\n+        super(type, duration);\n+    }\n+\n+    /**\n+     * Create a duration from a set of field values.\n+     *\n+     * @param type determines which set of fields this duration supports\n+     * @param years amount of years in this duration, which must be zero if\n+     * unsupported.\n+     * @param months amount of months in this duration, which must be zero if\n+     * unsupported.\n+     * @param weeks amount of weeks in this duration, which must be zero if\n+     * unsupported.\n+     * @param days amount of days in this duration, which must be zero if\n+     * unsupported.\n+     * @param hours amount of hours in this duration, which must be zero if\n+     * unsupported.\n+     * @param minutes amount of minutes in this duration, which must be zero if\n+     * unsupported.\n+     * @param seconds amount of seconds in this duration, which must be zero if\n+     * unsupported.\n+     * @param millis amount of milliseconds in this duration, which must be\n+     * zero if unsupported.\n+     * @throws UnsupportedOperationException if an unsupported field's value is\n+     * non-zero\n+     */\n+    public Duration(DurationType type,\n+                    int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis) {\n+        super(type, years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param type determines which set of fields this duration supports\n+     * @param startInstant interval start, in milliseconds\n+     * @param endInstant interval end, in milliseconds\n+     */\n+    public Duration(DurationType type, long startInstant, long endInstant) {\n+        super(type, startInstant, endInstant);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param type determines which set of fields this duration supports\n+     * @param startInstant interval start\n+     * @param endInstant interval end\n+     */\n+    public Duration(DurationType type,\n+                    ReadableInstant startInstant, ReadableInstant endInstant) {\n+        super(type, startInstant, endInstant);\n+    }\n+\n+    /**\n+     * Creates a duration from the given millisecond duration. If any supported\n+     * fields are imprecise, an UnsupportedOperationException is thrown. The\n+     * exception to this is when the specified duration is zero.\n+     *\n+     * @param type determines which set of fields this duration supports\n+     * @param duration  the duration, in milliseconds\n+     * @throws UnsupportedOperationException if any fields are imprecise\n+     */\n+    public Duration(DurationType type, long duration) {\n+        super(type, duration);\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void setDuration(ReadableDuration duration) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void setDuration(int years, int months, int weeks, int days,\n+                                     int hours, int minutes, int seconds, int millis) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void setTotalMillis(long startInstant, long endInstant) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void setTotalMillis(long duration) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void normalize() {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void setYears(int years) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void setMonths(int months) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void setWeeks(int weeks) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void setDays(int days) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void setHours(int hours) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void setMinutes(int minutes) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void setSeconds(int seconds) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void setMillis(int millis) {\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/DurationField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Defines the calculation engine for duration fields.\n+ * The interface defines a set of methods that manipulate a millisecond duration\n+ * with regards to a single field, such as months or seconds.\n+ * <p>\n+ * This design is extensible so, if you wish, you can extract a different field from\n+ * the millisecond duration. A number of standard implementations are provided to assist.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public interface DurationField extends Comparable {\n+\n+    /**\n+     * Get the name of the field.\n+     * \n+     * @return field name\n+     */\n+    public String getName();\n+\n+    /**\n+     * Returns true if this field is supported.\n+     * \n+     * @return true if this field is supported\n+     */\n+    public boolean isSupported();\n+\n+    /**\n+     * Is this field precise. A precise field can calculate its value from\n+     * milliseconds without needing a reference date. Put another way, a\n+     * precise field's unit size is not variable.\n+     * \n+     * @return true if precise\n+     * @see #getUnitMillis()\n+     */\n+    public boolean isPrecise();\n+    \n+    /**\n+     * Returns the amount of milliseconds per unit value of this field. For\n+     * example, if this field represents \"seconds\", then this returns the\n+     * milliseconds in one second.\n+     * <p>\n+     * For imprecise fields, the unit size is variable, and so this method\n+     * returns a suitable average value.\n+     *\n+     * @return the unit size of this field, in milliseconds\n+     * @see #isPrecise()\n+     */\n+    public long getUnitMillis();\n+\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get the value of this field from the milliseconds, which is approximate\n+     * if this field is imprecise.\n+     *\n+     * @param duration  the milliseconds to query, which may be negative\n+     * @return the value of the field, in the units of the field, which may be\n+     * negative\n+     * @throws ArithmeticException if the value is too large for an int\n+     */\n+    public int getValue(long duration);\n+\n+    /**\n+     * Get the value of this field from the milliseconds, which is approximate\n+     * if this field is imprecise.\n+     *\n+     * @param duration  the milliseconds to query, which may be negative\n+     * @return the value of the field, in the units of the field, which may be\n+     * negative\n+     */\n+    public long getValueAsLong(long duration);\n+\n+    /**\n+     * Get the value of this field from the milliseconds relative to an\n+     * instant. For precise fields this method produces the same result as for\n+     * the single argument get method.\n+     * <p>\n+     * If the millisecond duration is positive, then the instant is treated as a\n+     * \"start instant\". If negative, the instant is treated as an \"end instant\".\n+     * \n+     * @param duration  the milliseconds to query, which may be negative\n+     * @param instant  the start instant to calculate relative to\n+     * @return the value of the field, in the units of the field, which may be\n+     * negative\n+     * @throws ArithmeticException if the value is too large for an int\n+     */\n+    public int getValue(long duration, long instant);\n+\n+    /**\n+     * Get the value of this field from the milliseconds relative to an\n+     * instant. For precise fields this method produces the same result as for\n+     * the single argument get method.\n+     * <p>\n+     * If the millisecond duration is positive, then the instant is treated as a\n+     * \"start instant\". If negative, the instant is treated as an \"end instant\".\n+     * \n+     * @param duration  the milliseconds to query, which may be negative\n+     * @param instant  the start instant to calculate relative to\n+     * @return the value of the field, in the units of the field, which may be\n+     * negative\n+     */\n+    public long getValueAsLong(long duration, long instant);\n+\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get the millisecond duration of this field from its value, which is\n+     * approximate if this field is imprecise.\n+     * \n+     * @param value  the value of the field, which may be negative\n+     * @return the milliseconds that the field represents, which may be\n+     * negative\n+     */\n+    public long getMillis(int value);\n+\n+    /**\n+     * Get the millisecond duration of this field from its value, which is\n+     * approximate if this field is imprecise.\n+     * \n+     * @param value  the value of the field, which may be negative\n+     * @return the milliseconds that the field represents, which may be\n+     * negative\n+     */\n+    public long getMillis(long value);\n+\n+    /**\n+     * Get the millisecond duration of this field from its value relative to an\n+     * instant. For precise fields this method produces the same result as for\n+     * the single argument getMillis method.\n+     * <p>\n+     * If the value is positive, then the instant is treated as a \"start\n+     * instant\". If negative, the instant is treated as an \"end instant\".\n+     *\n+     * @param value  the value of the field, which may be negative\n+     * @param instant  the instant to calculate relative to\n+     * @return the millisecond duration that the field represents, which may be\n+     * negative\n+     */\n+    public long getMillis(int value, long instant);\n+\n+    /**\n+     * Get the millisecond duration of this field from its value relative to an\n+     * instant. For precise fields this method produces the same result as for\n+     * the single argument getMillis method.\n+     * <p>\n+     * If the value is positive, then the instant is treated as a \"start\n+     * instant\". If negative, the instant is treated as an \"end instant\".\n+     *\n+     * @param value  the value of the field, which may be negative\n+     * @param instant  the instant to calculate relative to\n+     * @return the millisecond duration that the field represents, which may be\n+     * negative\n+     */\n+    public long getMillis(long value, long instant);\n+\n+    /**\n+     * Adds a duration value (which may be negative) to the instant.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the value to add, in the units of the field\n+     * @return the updated milliseconds\n+     */\n+    public long add(long instant, int value);\n+\n+    /**\n+     * Adds a duration value (which may be negative) to the instant.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the value to add, in the units of the field\n+     * @return the updated milliseconds\n+     */\n+    public long add(long instant, long value);\n+\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * int v = ...\n+     * int age = getDifference(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public int getDifference(long minuendInstant, long subtrahendInstant);\n+\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * long v = ...\n+     * long age = getDifferenceAsLong(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant);\n+\n+    /**\n+     * Compares this duration field with another duration field for ascending\n+     * unit millisecond order. This ordering is inconsistent with equals, as it\n+     * ignores name and precision.\n+     *\n+     * @param durationField  a duration field to check against\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object type is not supported\n+     */\n+    public int compareTo(Object durationField);\n+\n+    /**\n+     * Returns a localized unit name of this field, using the given value as an\n+     * aid. For example, the unit name may differ if it is plural.\n+     *\n+     * @param value the duration value to use for selecting a unit name\n+     * @param locale the locale to use for selecting a name, null for default\n+     */\n+    //public String getUnitName(long value, Locale locale);\n+\n+    /**\n+     * Returns a localized unit name of this field, using the given value as an\n+     * aid. For example, the unit name may differ if it is plural.\n+     *\n+     * @param value the duration value to use for selecting a unit name\n+     */\n+    //public String getUnitName(long value);\n+\n+    /**\n+     * Get the maximum length string returned by getUnitName.\n+     * \n+     * @param locale the locale to use for selecting a unit name, null for\n+     * default\n+     * @return the maximum name length\n+     */\n+    //public int getMaximumUnitNameLength(Locale locale);\n+\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString();\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/DurationType.java\n+/* \n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import org.joda.time.chrono.MillisDurationField;\n+import org.joda.time.chrono.ScaledDurationField;\n+import org.joda.time.chrono.UnsupportedDurationField;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * Controls a duration implementation by specifying which duration fields are to be used.\n+ * <p>\n+ * The following implementations are provided:\n+ * <ul>\n+ * <li>Millis - the duration is defined only in terms of milliseconds, other\n+ *  fields are not used\n+ * <li>DayHour - the duration is expressed in terms of days, hours, minutes, seconds\n+ *  and milliseconds\n+ * <li>YearMonth - the duration is expressed using all fields except weeks\n+ * <li>ISOYearMonth - as YearMonth, but with the month fixed at 30 days\n+ * <li>YearWeek - the duration is expressed using all fields except months\n+ * </ul>\n+ *\n+ * <p>\n+ * DurationType is thread-safe and immutable, and all subclasses must be as\n+ * well.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public abstract class DurationType implements Serializable {\n+    static final long serialVersionUID = 2274324892792009998L;\n+\n+    // TODO: Many caching opportunities\n+\n+    /**\n+     * Returns a DurationType of only a milliseconds field.\n+     */\n+    public static DurationType getMillisType() {\n+        return new MillisType();\n+    }\n+\n+    /**\n+     * Returns a DurationType of:\n+     *\n+     * <ul>\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     */\n+    public static DurationType getDayHourType() {\n+        return getDayHourType(null);\n+    }\n+\n+    /**\n+     * Returns a DurationType of:\n+     *\n+     * <ul>\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     *\n+     * This factory method returns a DurationType that calculates using any\n+     * Chronology. For best results, the Chronology's time zone should\n+     * be UTC or have fixed offsets.\n+     *\n+     * @param chrono Chronology to use for calculations.\n+     */\n+    public static DurationType getDayHourType(Chronology chrono) {\n+        if (chrono == null) {\n+            chrono = ISOChronology.getInstanceUTC();\n+        }\n+        return new DayHourType(chrono);\n+    }\n+\n+    /**\n+     * Returns a DurationType of:\n+     *\n+     * <ul>\n+     * <li>years\n+     * <li>months\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     */\n+    public static DurationType getYearMonthType() {\n+        return getYearMonthType(null);\n+    }\n+\n+    /**\n+     * Returns a DurationType of:\n+     *\n+     * <ul>\n+     * <li>years\n+     * <li>months\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     *\n+     * This factory method returns a DurationType that calculates using any\n+     * Chronology. For best results, the Chronology's time zone should\n+     * be UTC or have fixed offsets.\n+     *\n+     * @param chrono Chronology to use for calculations.\n+     */\n+    public static DurationType getYearMonthType(Chronology chrono) {\n+        if (chrono == null) {\n+            chrono = ISOChronology.getInstanceUTC();\n+        }\n+        return new YearMonthType(chrono);\n+    }\n+\n+    /**\n+     * Returns a DurationType of:\n+     *\n+     * <ul>\n+     * <li>years\n+     * <li>months (fixed at 30 days)\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     */\n+    public static DurationType getISOYearMonthType() {\n+        return getISOYearMonthType(null);\n+    }\n+\n+    /**\n+     * Returns a DurationType of:\n+     *\n+     * <ul>\n+     * <li>years\n+     * <li>months (fixed at 30 days)\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     *\n+     * This factory method returns a DurationType that calculates using any\n+     * Chronology. For best results, the Chronology's time zone should\n+     * be UTC or have fixed offsets.\n+     *\n+     * @param chrono Chronology to use for calculations.\n+     */\n+    public static DurationType getISOYearMonthType(Chronology chrono) {\n+        if (chrono == null) {\n+            chrono = ISOChronology.getInstanceUTC();\n+        }\n+        return new ISOYearMonthType(chrono);\n+    }\n+\n+    /**\n+     * Returns a DurationType of:\n+     *\n+     * <ul>\n+     * <li>years (weekyears)\n+     * <li>weeks\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     */\n+    public static DurationType getYearWeekType() {\n+        return getYearWeekType(null);\n+    }\n+\n+    /**\n+     * Returns a DurationType of:\n+     *\n+     * <ul>\n+     * <li>years (weekyears)\n+     * <li>weeks\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     *\n+     * This factory method returns a DurationType that calculates using any\n+     * Chronology. For best results, the Chronology's time zone should\n+     * be UTC or have fixed offsets.\n+     *\n+     * @param chrono Chronology to use for calculations.\n+     */\n+    public static DurationType getYearWeekType(Chronology chrono) {\n+        if (chrono == null) {\n+            chrono = ISOChronology.getInstanceUTC();\n+        }\n+        return new YearWeekType(chrono);\n+    }\n+\n+    protected DurationType() {\n+    }\n+\n+    /**\n+     * Returns the chronology used, or null if none.\n+     */\n+    public abstract Chronology getChronology();\n+\n+    /**\n+     * Returns a DurationType that uses the given chronology.\n+     */\n+    public abstract DurationType withChronology(Chronology chrono);\n+\n+    /**\n+     * Returns a DurationField representing years.\n+     *\n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField years() {\n+        return UnsupportedDurationField.INSTANCE;\n+    }\n+\n+    /**\n+     * Returns a DurationField representing months.\n+     *\n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField months() {\n+        return UnsupportedDurationField.INSTANCE;\n+    }\n+\n+    /**\n+     * Returns a DurationField representing weeks.\n+     *\n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField weeks() {\n+        return UnsupportedDurationField.INSTANCE;\n+    }\n+\n+    /**\n+     * Returns a DurationField representing days.\n+     *\n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField days() {\n+        return UnsupportedDurationField.INSTANCE;\n+    }\n+\n+    /**\n+     * Returns a DurationField representing hours.\n+     *\n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField hours() {\n+        return UnsupportedDurationField.INSTANCE;\n+    }\n+\n+    /**\n+     * Returns a DurationField representing minutes.\n+     *\n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField minutes() {\n+        return UnsupportedDurationField.INSTANCE;\n+    }\n+\n+    /**\n+     * Returns a DurationField representing seconds.\n+     *\n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField seconds() {\n+        return UnsupportedDurationField.INSTANCE;\n+    }\n+\n+    /**\n+     * Returns a DurationField representing milliseconds.\n+     *\n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField millis() {\n+        return UnsupportedDurationField.INSTANCE;\n+    }\n+\n+    /**\n+     * Returns a version of this DurationType instance that does not support\n+     * years.\n+     */\n+    public DurationType withYearsRemoved() {\n+        if (!years().isSupported()) {\n+            return this;\n+        }\n+        return MaskedType.mask(this, 1 << 0);\n+    }\n+\n+    /**\n+     * Returns a version of this DurationType instance that does not support\n+     * months.\n+     */\n+    public DurationType withMonthsRemoved() {\n+        if (!months().isSupported()) {\n+            return this;\n+        }\n+        return MaskedType.mask(this, 1 << 1);\n+    }\n+\n+    /**\n+     * Returns a version of this DurationType instance that does not support\n+     * weeks.\n+     */\n+    public DurationType withWeeksRemoved() {\n+        if (!weeks().isSupported()) {\n+            return this;\n+        }\n+        return MaskedType.mask(this, 1 << 2);\n+    }\n+\n+    /**\n+     * Returns a version of this DurationType instance that does not support\n+     * days.\n+     */\n+    public DurationType withDaysRemoved() {\n+        if (!days().isSupported()) {\n+            return this;\n+        }\n+        return MaskedType.mask(this, 1 << 3);\n+    }\n+\n+    /**\n+     * Returns a version of this DurationType instance that does not support\n+     * hours.\n+     */\n+    public DurationType withHoursRemoved() {\n+        if (!hours().isSupported()) {\n+            return this;\n+        }\n+        return MaskedType.mask(this, 1 << 4);\n+    }\n+\n+    /**\n+     * Returns a version of this DurationType instance that does not support\n+     * minutes.\n+     */\n+    public DurationType withMinutesRemoved() {\n+        if (!minutes().isSupported()) {\n+            return this;\n+        }\n+        return MaskedType.mask(this, 1 << 5);\n+    }\n+\n+    /**\n+     * Returns a version of this DurationType instance that does not support\n+     * seconds.\n+     */\n+    public DurationType withSecondsRemoved() {\n+        if (!seconds().isSupported()) {\n+            return this;\n+        }\n+        return MaskedType.mask(this, 1 << 6);\n+    }\n+\n+    /**\n+     * Returns a version of this DurationType instance that does not support\n+     * milliseconds.\n+     */\n+    public DurationType withMillisRemoved() {\n+        if (!millis().isSupported()) {\n+            return this;\n+        }\n+        return MaskedType.mask(this, 1 << 7);\n+    }\n+\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (!(obj instanceof DurationType)) {\n+            return false;\n+        }\n+        DurationType other = (DurationType)obj;\n+        Chronology chrono = getChronology();\n+        if (chrono == null) {\n+            if (other.getChronology() != null) {\n+                return false;\n+            }\n+        } else if (!chrono.equals(other.getChronology())) {\n+            return false;\n+        }\n+        return years().equals(other.years())\n+            && months().equals(other.months())\n+            && weeks().equals(other.weeks())\n+            && days().equals(other.days())\n+            && hours().equals(other.hours())\n+            && minutes().equals(other.minutes())\n+            && seconds().equals(other.seconds())\n+            && millis().equals(other.millis());\n+    }\n+\n+    public int hashCode() {\n+        int hash = 0;\n+        Chronology chrono = getChronology();\n+        if (chrono != null) {\n+            hash += chrono.hashCode();\n+        }\n+        hash = hash\n+            + years().hashCode()\n+            + months().hashCode()\n+            + weeks().hashCode()\n+            + days().hashCode()\n+            + hours().hashCode()\n+            + minutes().hashCode()\n+            + seconds().hashCode()\n+            + millis().hashCode();\n+        return hash;\n+    }\n+\n+    private static final class MillisType extends DurationType {\n+        static final long serialVersionUID = -4314867016852780422L;\n+\n+        public final DurationField millis() {\n+            return MillisDurationField.INSTANCE;\n+        }\n+\n+        public Chronology getChronology() {\n+            return null;\n+        }\n+\n+        public DurationType withChronology(Chronology chrono) {\n+            return this;\n+        }\n+\n+        private Object readResolve() {\n+            return getMillisType();\n+        }\n+    }\n+\n+    private static class DayHourType extends DurationType {\n+        static final long serialVersionUID = 1115025839896760481L;\n+\n+        protected final Chronology iChronology;\n+\n+        public DayHourType(Chronology chrono) {\n+            iChronology = chrono;\n+        }\n+\n+        public final Chronology getChronology() {\n+            return iChronology;\n+        }\n+\n+        public DurationType withChronology(Chronology chrono) {\n+            if (chrono == iChronology) {\n+                return this;\n+            }\n+            return new DayHourType(iChronology);\n+        }\n+\n+        public final DurationField days() {\n+            return iChronology.days();\n+        }\n+\n+        public final DurationField hours() {\n+            return iChronology.hours();\n+        }\n+\n+        public final DurationField minutes() {\n+            return iChronology.minutes();\n+        }\n+\n+        public final DurationField seconds() {\n+            return iChronology.seconds();\n+        }\n+\n+        public final DurationField millis() {\n+            return iChronology.millis();\n+        }\n+\n+        private Object readResolve() {\n+            return getDayHourType(iChronology);\n+        }\n+    }\n+\n+    private static final class YearMonthType extends DayHourType {\n+        static final long serialVersionUID = -1336767257680877683L;\n+\n+        public YearMonthType(Chronology chrono) {\n+            super(chrono);\n+        }\n+\n+        public DurationType withChronology(Chronology chrono) {\n+            if (chrono == iChronology) {\n+                return this;\n+            }\n+            return new YearMonthType(iChronology);\n+        }\n+\n+        public DurationField years() {\n+            return iChronology.years();\n+        }\n+\n+        public DurationField months() {\n+            return iChronology.months();\n+        }\n+\n+        private Object readResolve() {\n+            return getYearMonthType(iChronology);\n+        }\n+    }\n+\n+    private static final class ISOYearMonthType extends DayHourType {\n+        static final long serialVersionUID = 1203161678926193794L;\n+\n+        private final DurationField iMonths;\n+        \n+        public ISOYearMonthType(Chronology chrono) {\n+            super(chrono);\n+            iMonths = new ScaledDurationField(chrono.days(), \"ISOMonths\", 30);\n+        }\n+\n+        public DurationType withChronology(Chronology chrono) {\n+            if (chrono == iChronology) {\n+                return this;\n+            }\n+            return new ISOYearMonthType(iChronology);\n+        }\n+\n+        public DurationField years() {\n+            return iChronology.years();\n+        }\n+\n+        public DurationField months() {\n+            return iMonths;\n+        }\n+\n+        private Object readResolve() {\n+            return getISOYearMonthType(iChronology);\n+        }\n+    }\n+\n+    private static final class YearWeekType extends DayHourType {\n+        static final long serialVersionUID = 1347170237843447098L;\n+\n+        public YearWeekType(Chronology chrono) {\n+            super(chrono);\n+        }\n+\n+        public DurationType withChronology(Chronology chrono) {\n+            if (chrono == iChronology) {\n+                return this;\n+            }\n+            return new YearWeekType(iChronology);\n+        }\n+\n+        public DurationField years() {\n+            return iChronology.weekyears();\n+        }\n+\n+        public DurationField weeks() {\n+            return iChronology.weeks();\n+        }\n+\n+        private Object readResolve() {\n+            return getYearWeekType(iChronology);\n+        }\n+    }\n+\n+    private static final class MaskedType extends DurationType {\n+        static final long serialVersionUID = 940106774669244586L;\n+\n+        public static DurationType mask(DurationType type, int mask) {\n+            if (type instanceof MaskedType) {\n+                MaskedType masked = (MaskedType)type;\n+                if ((mask |= masked.iMask) == masked.iMask) {\n+                    // No additional fields removed, so return original.\n+                    return masked;\n+                }\n+                type = masked.iType;\n+            }\n+            return new MaskedType(type, mask);\n+        }\n+\n+        private final DurationType iType;\n+\n+        // Bit 0: when set, years is unsupported\n+        // Bit 1: when set, months is unsupported\n+        // ...\n+        private final int iMask;\n+\n+        private MaskedType(DurationType type, int mask) {\n+            iType = type;\n+            iMask = mask;\n+        }\n+\n+        public Chronology getChronology() {\n+            return iType.getChronology();\n+        }\n+\n+        public DurationType withChronology(Chronology chrono) {\n+            if (chrono == getChronology()) {\n+                return this;\n+            }\n+            return mask(iType.withChronology(chrono), iMask);\n+        }\n+\n+        public DurationField years() {\n+            if ((iMask & (1 << 0)) != 0) {\n+                return UnsupportedDurationField.INSTANCE;\n+            }\n+            return iType.years();\n+        }\n+\n+        public DurationField months() {\n+            if ((iMask & (1 << 1)) != 0) {\n+                return UnsupportedDurationField.INSTANCE;\n+            }\n+            return iType.months();\n+        }\n+\n+        public DurationField weeks() {\n+            if ((iMask & (1 << 2)) != 0) {\n+                return UnsupportedDurationField.INSTANCE;\n+            }\n+            return iType.weeks();\n+        }\n+\n+        public DurationField days() {\n+            if ((iMask & (1 << 3)) != 0) {\n+                return UnsupportedDurationField.INSTANCE;\n+            }\n+            return iType.days();\n+        }\n+\n+        public DurationField hours() {\n+            if ((iMask & (1 << 4)) != 0) {\n+                return UnsupportedDurationField.INSTANCE;\n+            }\n+            return iType.hours();\n+        }\n+\n+        public DurationField minutes() {\n+            if ((iMask & (1 << 5)) != 0) {\n+                return UnsupportedDurationField.INSTANCE;\n+            }\n+            return iType.minutes();\n+        }\n+\n+        public DurationField seconds() {\n+            if ((iMask & (1 << 6)) != 0) {\n+                return UnsupportedDurationField.INSTANCE;\n+            }\n+            return iType.seconds();\n+        }\n+\n+        public DurationField millis() {\n+            if ((iMask & (1 << 7)) != 0) {\n+                return UnsupportedDurationField.INSTANCE;\n+            }\n+            return iType.millis();\n+        }\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/Instant.java\n+++ b/JodaTime/src/java/org/joda/time/Instant.java\n  */\n package org.joda.time;\n \n-import java.text.ParseException;\n-import java.util.Calendar;\n-import java.util.Date;\n-\n+import java.io.Serializable;\n+\n+import org.joda.time.convert.InstantConverter;\n+import org.joda.time.convert.ConverterManager;\n import org.joda.time.format.ISODateTimeFormat;\n-import org.joda.time.format.DateTimeParser;\n \n /**\n- * Instant is the standard implementation of a fully immutable instant in \n- * time. It holds the instant as milliseconds from the Java Epoch of \n- * 1970-01-01T00:00:00Z.\n+ * Instant is the standard implementation of a fully immutable instant in time.\n+ * It holds the instant as milliseconds from the Java Epoch of 1970-01-01T00:00:00Z.\n  * <p>\n- * There is no concept of a calendar system, chronology or time zone. In \n- * a fully internationalized program, methods should accept the ReadableInstant \n- * interface as input and return Instant objects.\n+ * There is no concept of a calendar system, chronology or time zone.\n+ * In a fully internationalized program, you may want to ensure methods accept the\n+ * ReadableInstant interface as input and return Instant objects.\n+ * <p>\n+ * Instant is thread-safe and immutable.\n  *\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public final class Instant extends AbstractInstant implements ReadableInstant {\n+public final class Instant extends AbstractInstant\n+        implements ReadableInstant, Serializable {\n+\n+    static final long serialVersionUID = 3299096530934209741L;\n \n     /** The millis from 1970-01-01T00:00:00Z */\n     private final long iMillis;\n     // Constructors\n     //-----------------------------------------------------------------------\n     /**\n-     * Constructor that sets the time to be the current time from the\n-     * system clock.\n+     * Constructs an instance set to the current system millisecond time.\n      */\n     public Instant() {\n         super();\n     }\n \n     /**\n-     * Constructor that takes milliseconds from 1970-01-01T00:00:00Z.\n-     * \n-     * @param millis  the milliseconds\n-     */\n-    public Instant(long millis) {\n-        super();\n-        iMillis = millis;\n-    }\n-\n-    /**\n-     * Constructor that takes a ReadableInstant.\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public Instant(long instant) {\n+        super();\n+        iMillis = instant;\n+    }\n+\n+    /**\n+     * Constructs an instance from a <code>ReadableInstant</code>.\n      * \n      * @param instant  the ReadableInstant\n      * @throws IllegalArgumentException if the instant is null\n      */\n     public Instant(ReadableInstant instant) {\n         super();\n-        if (instant == null) {\n-            throw new IllegalArgumentException(\"The ReadableInstant must not be null\");\n-        }\n         iMillis = instant.getMillis();\n     }\n \n     /**\n-     * Constructor that takes a Date.\n-     * \n-     * @param date  the Date\n-     * @throws IllegalArgumentException if the date is null\n-     */\n-    public Instant(Date date) {\n-        super();\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"The Date must not be null\");\n-        }\n-        iMillis = date.getTime();\n-    }\n-\n-    /**\n-     * Constructor that takes a Calendar.\n-     * \n-     * @param calendar  the Calendar\n-     * @throws IllegalArgumentException if the calendar is null\n-     */\n-    public Instant(Calendar calendar) {\n-        super();\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The Calendar must not be null\");\n-        }\n-        iMillis = calendar.getTime().getTime();\n-    }\n-\n-    /**\n-     * Constructor that parses an ISO formatted string.\n-     * \n-     * @param str  the string\n-     * @throws IllegalArgumentException if the string is null\n-     * @throws ParseException if the string is incorrectly formatted\n-     */\n-    public Instant(String str) throws ParseException {\n-        super();\n-        if (str == null) {\n-            throw new IllegalArgumentException(\"The String must not be null\");\n-        }\n-        DateTimeParser p = ISODateTimeFormat.getInstanceUTC().dateTimeParser();\n-        iMillis = p.parseMillis(str);\n+     * Constructs an instance from an Object that represents a datetime.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @throws IllegalArgumentException if the instant is null or invalid\n+     */\n+    public Instant(Object instant) {\n+        super();\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        iMillis = converter.getInstantMillis(instant);\n     }\n \n     /**\n      * The returned object will be a new instance of the implementation.\n      * Immutable subclasses may return <code>this</code> if appropriate.\n      *\n-     * @param millis  the new millis, from 1970-01-01T00:00:00Z\n+     * @param instant  the new instant, from 1970-01-01T00:00:00Z\n      * @param chrono  the new chronology\n      * @return a new instance of this class\n      * @throws IllegalArgumentException if the chronology is null\n      */\n-    protected ReadableInstant create(long millis, Chronology chrono) {\n+    protected ReadableInstant create(long instant, Chronology chrono) {\n         // ignore chrono\n-        if (millis == getMillis()) {\n+        if (instant == getMillis()) {\n             return this;\n         }\n-        return new Instant(millis);\n+        return new Instant(instant);\n     }\n     \n     // Accessors\n      * @return the number of milliseconds since 1970-01-01T00:00:00Z\n      */\n     public final long getMillis() {\n+        return iMillis;\n+    }\n+\n+    /**\n+     * Gets the milliseconds of the instant.\n+     *\n+     * @param base ignored\n+     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n+     */\n+    public final long getMillis(ReadableInstant base) {\n+        return iMillis;\n+    }\n+\n+    /**\n+     * Gets the milliseconds of the instant.\n+     *\n+     * @param base ignored\n+     * @param zone ignored\n+     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n+     */\n+    public final long getMillis(ReadableInstant base, DateTimeZone zone) {\n         return iMillis;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java\n \n package org.joda.time;\n \n-import java.text.ParseException;\n-import java.util.Calendar;\n-import java.util.Date;\n+import java.io.Serializable;\n \n import org.joda.time.chrono.iso.ISOChronology;\n-import org.joda.time.format.DateTimeParser;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.DurationConverter;\n+import org.joda.time.convert.InstantConverter;\n import org.joda.time.format.ISODateTimeFormat;\n \n /**\n- * MutableDateTime is the standard implementation of a modifiable\n- * datetime class.\n- * It holds the date/time as milliseconds from the Java epoch of\n- * 1970-01-01T00:00:00Z.\n+ * MutableDateTime is the standard implementation of a modifiable datetime class.\n+ * It holds the datetime as milliseconds from the Java epoch of 1970-01-01T00:00:00Z.\n  * <p>\n- * This class requires a Chronology to be specified. The Chronology determines\n- * how the millisecond instant value is converted into the date time fields.\n+ * This class uses a Chronology internally. The Chronology determines how the\n+ * millisecond instant value is converted into the date time fields.\n+ * The default Chronology is <code>ISOChronology</code> which is the agreed\n+ * international standard and compatable with the modern Gregorian calendar.\n  * <p>\n  * Each individual field can be accessed in two ways:\n  * <ul>\n  * <li>field minimum value\n  * </ul>\n  *\n+ * <p>\n+ * MutableDateTime is mutable and not thread-safe, unless concurrent threads\n+ * are not invoking mutator methods.\n+ *\n  * @author Guy Allard\n  * @author Brian S O'Neill\n  * @author Stephen Colebourne\n  * @since 1.0\n+ * @see DateTime\n  */\n public class MutableDateTime extends AbstractDateTime\n-    implements ReadableDateTime, ReadWritableInstant, Cloneable\n-{\n-    /** The millis from 1970-01-01T00:00:00Z. */\n-    private long iMillis;\n-    /** The chronology to use */\n-    private Chronology iChronology;\n-\n-    // Constructors (same as DateTime)\n-    //-----------------------------------------------------------\n-\n-    /**\n-     * Constructs a MutableDateTime to the current datetime, as reported by the system\n-     * clock. The chronology used is ISO, in the\n-     * {@link DateTimeZone#getDefault() default} time zone.\n+        implements ReadWritableDateTime, Cloneable, Serializable {\n+    \n+    static final long serialVersionUID = 2852608688135209575L;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using <code>ISOChronology</code> in the default time zone.\n      */\n     public MutableDateTime() {\n-        iChronology = ISOChronology.getInstance();\n-        iMillis = System.currentTimeMillis();\n-    }\n-\n-    /**\n-     * Constructs a MutableDateTime to the current datetime, as reported by the system\n-     * clock. The chronology used is ISO, in the supplied time zone.\n-     *\n-     * @param zone  the time zone, must not be null\n-     * @throws IllegalArgumentException if the zone is null\n+        super();\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param zone  the time zone, null means default zone\n      */\n     public MutableDateTime(DateTimeZone zone) {\n-        iChronology = ISOChronology.getInstance(zone);\n-        iMillis = System.currentTimeMillis();\n-    }\n-\n-    /**\n-     * Constructs a MutableDateTime to the current datetime, as reported by the system\n-     * clock.\n-     *\n-     * @param chronology  the chronology, must not be null\n-     * @throws IllegalArgumentException if the chronology is null\n+        super(zone);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n      */\n     public MutableDateTime(Chronology chronology) {\n-        iChronology = selectChronology(chronology);\n-        iMillis = System.currentTimeMillis();\n-    }\n-\n-    /**\n-     * Constructs a MutableDateTime set to the milliseconds from 1970-01-01T00:00:00Z,\n-     * using the ISO chronology, in the\n-     * {@link DateTimeZone#getDefault() default} time zone.\n-     *\n-     * @param millis  the milliseconds\n-     */\n-    public MutableDateTime(long millis) {\n-        iChronology = ISOChronology.getInstance();\n-        iMillis = millis;\n-    }\n-\n-    /**\n-     * Constructs a MutableDateTime set to the milliseconds from 1970-01-01T00:00:00Z,\n-     * using the ISO chronology, in the supplied time zone.\n-     *\n-     * @param millis  the milliseconds\n-     * @param zone  the time zone, must not be null\n-     * @throws IllegalArgumentException if the zone is null\n-     */\n-    public MutableDateTime(long millis, DateTimeZone zone) {\n-        iChronology = ISOChronology.getInstance(zone);\n-        iMillis = millis;\n-    }\n-\n-    /**\n-     * Constructs a MutableDateTime set to the milliseconds from 1970-01-01T00:00:00Z,\n-     * using the supplied chronology.\n-     *\n-     * @param millis  the milliseconds\n-     * @param chronology  the chronology, must not be null\n-     * @throws IllegalArgumentException if the chronology is null\n-     */\n-    public MutableDateTime(long millis, Chronology chronology) {\n-        iChronology = selectChronology(chronology);\n-        iMillis = millis;\n-    }\n-\n-    /**\n-     * Constructs a MutableDateTime from a ReadableInstant, using its chronology. If\n-     * its chronology null, then the chronology is set to ISO, in the\n-     * {@link DateTimeZone#getDefault() default} time zone.\n-     *\n-     * @param instant  the ReadableInstant, must not be null\n-     * @throws IllegalArgumentException if the instant is null\n-     */\n-    public MutableDateTime(ReadableInstant instant) {\n-        iChronology = selectChronology(instant);\n-        iMillis = instant.getMillis();\n-    }\n-\n-    /**\n-     * Constructs a MutableDateTime from a ReadableInstant, using its chronology\n-     * against a different time zone. If its chronology is null, then the\n-     * chronology is set to ISO. If the selected chronology is not in the\n-     * supplied time zone, a new chronology is created that is.\n-     *\n-     * @param instant  the ReadableInstant, must not be null\n-     * @param zone  the time zone, must not be null\n-     * @throws IllegalArgumentException if the instant or zone is null\n-     */\n-    public MutableDateTime(ReadableInstant instant, DateTimeZone zone) {\n-        iChronology = selectChronology(instant, zone);\n-        iMillis = instant.getMillis();\n-    }\n-\n-    /**\n-     * Constructs a MutableDateTime from a ReadableInstant, using the supplied\n-     * chronology.\n-     *\n-     * @param instant  the ReadableInstant, must not be null\n-     * @param chronology  the chronology, must not be null\n-     * @throws IllegalArgumentException if the instant or chronology is null\n-     */\n-    public MutableDateTime(ReadableInstant instant, Chronology chronology) {\n-        iChronology = selectChronology(instant, chronology);\n-        iMillis = instant.getMillis();\n-    }\n-\n-    /**\n-     * Constructs a MutableDateTime from a Date, using the ISO chronology, in the\n-     * {@link DateTimeZone#getDefault() default} time zone.\n-     *\n-     * @param date  the Date, must not be null\n-     * @throws IllegalArgumentException if the date is null\n-     */\n-    public MutableDateTime(Date date) {\n-        iChronology = selectChronology(date);\n-        iMillis = date.getTime();\n-    }\n-\n-    /**\n-     * Constructs a MutableDateTime from a Date, using the ISO chronology, in the\n-     * supplied time zone.\n-     *\n-     * @param date  the Date, must not be null\n-     * @param zone  the time zone, must not be null\n-     * @throws IllegalArgumentException if the date or zone is null\n-     */\n-    public MutableDateTime(Date date, DateTimeZone zone) {\n-        iChronology = selectChronology(date, zone);\n-        iMillis = date.getTime();\n-    }\n-\n-    /**\n-     * Constructs a MutableDateTime from a Date, using the supplied chronology.\n-     *\n-     * @param date  the Date, must not be null\n-     * @param chronology  the chronology, must not be null\n-     * @throws IllegalArgumentException if the date or chronology is null\n-     */\n-    public MutableDateTime(Date date, Chronology chronology) {\n-        iChronology = selectChronology(date, chronology);\n-        iMillis = date.getTime();\n-    }\n-\n-    /**\n-     * Constructs a MutableDateTime from a Calendar, using its closest mapped\n-     * chronology and time zone.\n-     *\n-     * <p>When converting calendars to chronologies, the constructor is aware\n-     * of GregorianCalendar and BuddhistCalendar and maps them to the\n-     * equivalent chronology. Other calendars map to ISOChronology.\n-     *\n-     * @param calendar  the Calendar, must not be null\n-     * @throws IllegalArgumentException if the calendar is null\n-     */\n-    public MutableDateTime(Calendar calendar) {\n-        iChronology = selectChronology(calendar);\n-        iMillis = calendar.getTime().getTime();\n-    }\n-\n-    /**\n-     * Constructs a MutableDateTime from a Calendar, using its closest mapped\n-     * chronology against a different time zone.\n-     *\n-     * <p>When converting calendars to chronologies, the constructor is aware\n-     * of GregorianCalendar and BuddhistCalendar and maps them to the\n-     * equivalent chronology. Other calendars map to ISOChronology.\n-     *\n-     * @param calendar  the Calendar, must not be null\n-     * @param chronology  the chronology, must not be null\n-     * @throws IllegalArgumentException if the calendar or zone is null\n-     */\n-    public MutableDateTime(Calendar calendar, DateTimeZone zone) {\n-        iChronology = selectChronology(calendar, zone);\n-        iMillis = calendar.getTime().getTime();\n-    }\n-\n-    /**\n-     * Constructs a MutableDateTime from a Calendar, using the supplied chronology.\n-     *\n-     * @param calendar  the Calendar, must not be null\n-     * @param chronology  the chronology, must not be null\n-     * @throws IllegalArgumentException if the calendar or chronology is null\n-     */\n-    public MutableDateTime(Calendar calendar, Chronology chronology) {\n-        iChronology = selectChronology(calendar, chronology);\n-        iMillis = calendar.getTime().getTime();\n-    }\n-\n-    /**\n-     * Constructs a MutableDateTime from an ISO formatted String, using the ISO\n-     * chronology, in the {@link DateTimeZone#getDefault() default} time zone.\n-     *\n-     * @param str  the string to parse, must not be null\n-     * @throws IllegalArgumentException if the string is null\n-     * @throws ParseException if parsing fails\n-     */\n-    public MutableDateTime(String str) throws ParseException {\n-        iChronology = selectChronology(str);\n-        DateTimeParser p = ISODateTimeFormat.getInstance(iChronology).dateTimeParser();\n-        iMillis = p.parseMillis(str);\n-    }\n-\n-    /**\n-     * Constructs a MutableDateTime from an ISO formatted String, using the ISO\n-     * chronology, in the supplied time zone.\n-     *\n-     * @param str  the string to parse, must not be null\n-     * @param zone the time zone, must not be null\n-     * @throws IllegalArgumentException if the string or zone is null\n-     * @throws ParseException if parsing fails\n-     */\n-    public MutableDateTime(String str, DateTimeZone zone) throws ParseException {\n-        iChronology = selectChronology(str, zone);\n-        DateTimeParser p = ISODateTimeFormat.getInstance(iChronology).dateTimeParser();\n-        iMillis = p.parseMillis(str);\n-    }\n-\n-    /**\n-     * Constructs a MutableDateTime from an ISO formatted String, using the supplied\n-     * chronology.\n-     *\n-     * @param str  the string to parse, must not be null\n-     * @param chronology  the chronology, must not be null\n-     * @throws IllegalArgumentException if the string or chronology is null\n-     * @throws ParseException if parsing fails\n-     */\n-    public MutableDateTime(String str, Chronology chronology) throws ParseException {\n-        iChronology = selectChronology(str, chronology);\n-        DateTimeParser p = ISODateTimeFormat.getInstance(iChronology).dateTimeParser();\n-        iMillis = p.parseMillis(str);\n-    }\n-\n+        super(chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using <code>ISOChronology</code> in the default time zone.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public MutableDateTime(long instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public MutableDateTime(long instant, DateTimeZone zone) {\n+        super(instant, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public MutableDateTime(long instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from an Object that represents a datetime.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @throws IllegalArgumentException if the instant is null or invalid\n+     */\n+    public MutableDateTime(Object instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * forcing the time zone to that specified.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * If the specified time zone is null, the default zone is used.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @param zone  the time zone, null means default time zone\n+     * @throws IllegalArgumentException if the instant is null or invalid\n+     */\n+    public MutableDateTime(Object instant, DateTimeZone zone) {\n+        super(instant, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * using the specifed chronology.\n+     * <p>\n+     * If the chronology is null, ISOChronology in the default time zone is used.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     * @throws IllegalArgumentException if the instant is null or invalid\n+     */\n+    public MutableDateTime(Object instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the default time zone.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the milisecond of the second\n+     */\n+    public MutableDateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond) {\n+        super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the milisecond of the second\n+     * @param zone  the time zone, null means default time zone\n+     */\n+    public MutableDateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond,\n+            DateTimeZone zone) {\n+        super(year, monthOfYear, dayOfMonth,\n+              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the milisecond of the second\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public MutableDateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond,\n+            Chronology chronology) {\n+        super(year, monthOfYear, dayOfMonth,\n+              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Creates a new instance of this class.\n      * <p>\n      * The returned object will be a new instance of the implementation.\n      * Immutable subclasses may return <code>this</code> if appropriate.\n      *\n-     * @param millis  the new millis, from 1970-01-01T00:00:00Z\n+     * @param instant  the new instant, from 1970-01-01T00:00:00Z\n      * @param chrono  the new chronology\n      * @return a new instance of this class\n      * @throws IllegalArgumentException if the chronology is null\n      */\n-    protected ReadableInstant create(long millis, Chronology chrono) {\n+    protected ReadableInstant create(long instant, Chronology chrono) {\n         if (chrono == null) {\n             throw new IllegalArgumentException(\"The Chronology must not be null\");\n         }\n-        return new MutableDateTime(millis, chrono);\n+        return new MutableDateTime(instant, chrono);\n     }\n     \n-    // Accessor/mutator/adder methods (Accessors same as for DateTime)\n-    //-----------------------------------------------------------\n-\n-    /**\n-     * Gets the milliseconds of the datetime instant from the Java epoch\n-     * of 1970-01-01T00:00:00Z.\n-     * \n-     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n-     */\n-    public long getMillis() {\n-        return iMillis;\n-    }\n-\n+    // Millis\n+    //-----------------------------------------------------------------------\n     /**\n      * Set the milliseconds of the datetime.\n      *\n-     * @param millis the milliseconds since 1970-01-01T00:00:00Z to set the\n+     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the\n      * datetime to\n-     */\n-    public void setMillis(long millis) {\n-        iMillis = millis;\n-    }\n-\n-    /**\n-     * Set the number of milliseconds of the datetime.\n-     * \n-     * @param datetime  a ReadableInstant, Date, Calendar, Long or String\n-     * @throws IllegalArgumentException if the object is null\n-     * @throws ClassCastException if the object's type cannot be recognised\n-     */\n-    public void setMillis(Object object) {\n-        iMillis = getDateTimeMillisFromObject(object);\n+     * @see #setDateTime(long)\n+     */\n+    public void setMillis(long instant) {\n+        super.setMillis(instant);\n+    }\n+\n+    /**\n+     * Set the date and time from an object representing an instant.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  an object representing an instant\n+     * @throws IllegalArgumentException if the object is null or invalid\n+     * @see #setDateTime(Object)\n+     */\n+    public void setMillis(Object instant) {\n+        super.setMillis(instant);\n+    }\n+\n+    // Add\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Add an amount of time to the datetime.\n+     * \n+     * @param duration  the millis to add\n+     */\n+    public void add(final long duration) {\n+        setMillis(getMillis() + duration);\n     }\n \n     /**\n      * Add an amount of time to the date.\n      * \n-     * @param duration duration to add.\n-     */\n-    /*\n-    public void add(ReadableDuration duration) {\n-        duration.addTo(this, 1);\n-    }\n-    */\n+     * @param duration  duration to add.\n+     */\n+    public void add(final ReadableDuration duration) {\n+        duration.addInto(this, 1);\n+    }\n \n     /**\n      * Add an amount of time to the date.\n      * \n-     * @param duration duration to add.\n-     * @param scalar direction and amount to add, which may be negative\n-     */\n-    /*\n-    public void add(ReadableDuration duration, int scalar) {\n-        duration.addTo(this, scalar);\n-    }\n-    */\n+     * @param duration  duration to add.\n+     * @param scalar  direction and amount to add, which may be negative\n+     */\n+    public void add(final ReadableDuration duration, final int scalar) {\n+        duration.addInto(this, scalar);\n+    }\n \n     /**\n      * Add an amount of time to the date.\n-     * \n-     * @param object a ReadableDuration, Long or String evaluating to a\n-     * duration\n-     */\n-    public void add(Object object) {\n-        /*\n-        if (object instanceof ReadableDuration) {\n-            add((ReadableDuration)object);\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableDuration, String and Long.\n+     * \n+     * @param duration  an object representing a duration\n+     */\n+    public void add(final Object duration) {\n+        if (duration instanceof ReadableDuration) {\n+            add((ReadableDuration) duration);\n         } else {\n-            iMillis += getDurationMillisFromObject(object);\n+            DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);\n+            add(converter.getDurationMillis(duration));\n         }\n-        */\n-        iMillis += getDurationMillisFromObject(object);\n-    }\n-\n-    /**\n-     * Add an amount of time to the datetime.\n-     * \n-     * @param millis  the millis to add\n-     */\n-    public void addMillis(long millis) {\n-        iMillis += millis;\n-    }\n-\n-    /**\n-     * Gets the chronology of the datetime.\n-     * \n-     * @return the Chronology that the datetime is using\n-     */\n-    public Chronology getChronology() {\n-        return iChronology;\n-    }\n-\n+    }\n+\n+    // Chronology\n+    //-----------------------------------------------------------------------\n     /**\n      * Set the chronology of the datetime.\n      * \n-     * @param chronology  the chronology to use\n-     * @throws IllegalArgumentException if the chronology is null\n+     * @param chronology  the chronology to use, null means ISOChronology in default zone\n      */\n     public void setChronology(Chronology chronology) {\n-        if (chronology == null) {\n-            throw new IllegalArgumentException(\"The Chronology must not be null\");\n-        }\n-        iChronology = chronology;\n-    }\n-\n-    /**\n-     * Sets the time zone of the datetime via the chronology.\n-     *\n-     * @param zone  the time zone to use\n-     * @throws IllegalArgumentException if the time zone is null\n+        super.setChronology(chronology);\n+    }\n+\n+    // Time zone\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the time zone of the datetime, which changes the\n+     * chronology. Setting the time zone does not affect the millisecond value\n+     * of this instant.\n+     * <p>\n+     * If the chronology already has this time zone, no change occurs.\n+     *\n+     * @param zone  the time zone to use, null means default zone\n+     * @see #moveDateTimeZone\n      */\n     public void setDateTimeZone(DateTimeZone zone) {\n-        if (zone == null) {\n-            throw new IllegalArgumentException(\"The DateTimeZone must not be null\");\n-        }\n-        if (iChronology.getDateTimeZone() != zone) {\n-            iChronology = iChronology.withDateTimeZone(zone);\n-        }\n-    }\n-\n-    // public int get(DateTimeField field);  inherited from AbstractInstant\n-\n+        super.setDateTimeZone(zone);\n+    }\n+\n+    /**\n+     * Moves the time zone of the datetime, which changes the\n+     * chronology. Moving the time zone alters the millisecond value of this\n+     * instant such that it is relative to the new time zone.\n+     * <p>\n+     * If the chronology already has this time zone, no change occurs.\n+     *\n+     * @param zone  the time zone to use, null means default zone\n+     * @see #setDateTimeZone\n+     */\n+    public void moveDateTimeZone(DateTimeZone zone) {\n+        super.moveDateTimeZone(zone);\n+    }\n+\n+    // Field based\n+    //-----------------------------------------------------------------------\n     /**\n      * Set a value in the specified field.\n      * This could be used to set a field using a different Chronology.\n      * @param value the value\n      * @throws NullPointerException if the field is null\n      */\n-    public void set(DateTimeField field, int value) {\n-        iMillis = field.set(getMillis(), value);\n+    public void set(final DateTimeField field, final int value) {\n+        setMillis(field.set(getMillis(), value));\n     }\n \n     /**\n      * @param value the value\n      * @throws NullPointerException if the field is null\n      */\n-    public void add(DateTimeField field, int value) {\n-        iMillis = field.add(getMillis(), value);\n+    public void add(final DateTimeField field, final int value) {\n+        setMillis(field.add(getMillis(), value));\n     }\n \n     /**\n      * @param value the value\n      * @throws NullPointerException if the field is null\n      */\n-    public void addWrapped(DateTimeField field, int value) {\n-        iMillis = field.addWrapped(getMillis(), value);\n-    }\n-\n-    // Date field mutator/adder methods\n-    //-----------------------------------------------------------\n-\n-    /**\n-     * Set the day of week to a value.\n-     *\n-     * @param dayOfWeek  the day of the week.\n-     */\n-    public void setDayOfWeek(int dayOfWeek) {\n-        iMillis = getChronology().dayOfWeek().set(iMillis, dayOfWeek);\n-    }\n-\n-    /**\n-     * Set the day of the month to a value.\n-     *\n-     * @param dayOfMonth  the day of the month.\n-     */\n-    public void setDayOfMonth(int dayOfMonth) {\n-        iMillis = getChronology().dayOfMonth().set(iMillis, dayOfMonth);\n-    }\n-\n-    /**\n-     * Set the day of year to a value.\n-     *\n-     * @param dayOfYear the day of the year.\n-     */\n-    public void setDayOfYear(int dayOfYear) {\n-        iMillis = getChronology().dayOfYear().set(iMillis, dayOfYear);\n+    public void addWrapped(final DateTimeField field, final int value) {\n+        setMillis(field.addWrapped(getMillis(), value));\n+    }\n+\n+    // Date methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the year to the specified value.\n+     *\n+     * @param year  the year\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setYear(final int year) {\n+        setMillis(getChronology().year().set(getMillis(), year));\n+    }\n+\n+    /**\n+     * Add a number of years to the date.\n+     *\n+     * @param years  the years to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addYears(final int years) {\n+        setMillis(getChronology().years().add(getMillis(), years));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the week of the year to the specified value.\n+     *\n+     * @param weekyear  the weekyear\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setWeekyear(final int weekyear) {\n+        setMillis(getChronology().weekyear().set(getMillis(), weekyear));\n+    }\n+\n+    /**\n+     * Add a number of weekyears to the date.\n+     *\n+     * @param weekyears  the weekyears to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addWeekyears(final int weekyears) {\n+        setMillis(getChronology().weekyears().add(getMillis(), weekyears));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the month of the year to the specified value.\n+     *\n+     * @param monthOfYear  the month of the year\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setMonthOfYear(final int monthOfYear) {\n+        setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));\n+    }\n+\n+    /**\n+     * Add a number of months to the date.\n+     *\n+     * @param months  the months to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addMonths(final int months) {\n+        setMillis(getChronology().months().add(getMillis(), months));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the week of weekyear to the specified value.\n+     *\n+     * @param weekOfWeekyear the week of the weekyear\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setWeekOfWeekyear(final int weekOfWeekyear) {\n+        setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));\n+    }\n+\n+    /**\n+     * Add a number of weeks to the date.\n+     *\n+     * @param weeks  the weeks to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addWeeks(final int weeks) {\n+        setMillis(getChronology().weeks().add(getMillis(), weeks));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the day of year to the specified value.\n+     *\n+     * @param dayOfYear the day of the year\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setDayOfYear(final int dayOfYear) {\n+        setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));\n+    }\n+\n+    /**\n+     * Set the day of the month to the specified value.\n+     *\n+     * @param dayOfMonth  the day of the month\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setDayOfMonth(final int dayOfMonth) {\n+        setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));\n+    }\n+\n+    /**\n+     * Set the day of week to the specified value.\n+     *\n+     * @param dayOfWeek  the day of the week\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setDayOfWeek(final int dayOfWeek) {\n+        setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));\n     }\n \n     /**\n      * Add a number of days to the date.\n      *\n-     * @param days  the days to add.\n-     */\n-    public void addDays(int days) {\n-        iMillis = getChronology().dayOfYear().add(iMillis, days);\n-    }\n-\n-    /**\n-     * Set the week of weekyear to a value.\n-     *\n-     * @param weekOfWeekyear the week of the weekyear.\n-     */\n-    public void setWeekOfWeekyear(int weekOfWeekyear) {\n-        iMillis = getChronology().weekOfWeekyear().set(iMillis, weekOfWeekyear);\n-    }\n-\n-    /**\n-     * Add a number of weeks to the date.\n-     *\n-     * @param weeks  the weeks to add.\n-     */\n-    public void addWeeks(int weeks) {\n-        iMillis = getChronology().weekOfWeekyear().add(iMillis, weeks);\n-    }\n-\n-    /**\n-     * Set the week of the year to a value.\n-     *\n-     * @param weekyear  the weekyear.\n-     */\n-    public void setWeekyear(int weekyear) {\n-        iMillis = getChronology().weekyear().set(iMillis, weekyear);\n-    }\n-\n-    /**\n-     * Add a number of weekyears to the date.\n-     *\n-     * @param weekyears  the weekyears to add.\n-     */\n-    public void addWeekyears(int weekyears) {\n-        iMillis = getChronology().weekyear().add(iMillis, weekyears);\n-    }\n-\n-    /**\n-     * Set the month of the year to a value.\n-     *\n-     * @param month  the month of the year.\n-     */\n-    public void setMonthOfYear(int month) {\n-        iMillis = getChronology().monthOfYear().set(iMillis, month);\n-    }\n-\n-    /**\n-     * Add a number of months to the date.\n-     *\n-     * @param months  the months to add.\n-     */\n-    public void addMonths(int months) {\n-        iMillis = getChronology().monthOfYear().add(iMillis, months);\n-    }\n-\n-    /**\n-     * Set the year to a value.\n-     *\n-     * @param year  the year.\n-     */\n-    public void setYear(int year) {\n-        iMillis = getChronology().year().set(iMillis, year);\n-    }\n-\n-    /**\n-     * Add a number of years to the date.\n-     *\n-     * @param years  the years to add.\n-     */\n-    public void addYears(int years) {\n-        iMillis = getChronology().year().add(iMillis, years);\n-    }\n-\n-    // Time field mutator/adder methods\n-    //-----------------------------------------------------------\n-\n-    /**\n-     * Set the millis of the second.\n-     *\n-     * @param millis  the millis of second.\n-     */\n-    public void setMillisOfSecond(int millis) {\n-        iMillis = getChronology().millisOfSecond().set(iMillis, millis);\n-    }\n-\n-    /**\n-     * Set the millis of the day.\n-     *\n-     * @param millis  the millis of day.\n-     */\n-    public void setMillisOfDay(int millis) {\n-        iMillis = getChronology().millisOfDay().set(iMillis, millis);\n-    }\n-\n-    /**\n-     * Set the second of the minute.\n-     *\n-     * @param second  the second of minute.\n-     */\n-    public void setSecondOfMinute(int second) {\n-        iMillis = getChronology().secondOfMinute().set(iMillis, second);\n-    }\n-\n-    /**\n-     * Set the second of the day.\n-     *\n-     * @param second  the second of day.\n-     */\n-    public void setSecondOfDay(int second) {\n-        iMillis = getChronology().secondOfDay().set(iMillis, second);\n+     * @param days  the days to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addDays(final int days) {\n+        setMillis(getChronology().days().add(getMillis(), days));\n+    }\n+\n+    // Time methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the hour of the day to the specified value.\n+     *\n+     * @param hourOfDay  the hour of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setHourOfDay(final int hourOfDay) {\n+        setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay));\n+    }\n+\n+    /**\n+     * Add a number of hours to the date.\n+     *\n+     * @param hours  the hours to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addHours(final int hours) {\n+        setMillis(getChronology().hours().add(getMillis(), hours));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the minute of the day to the specified value.\n+     *\n+     * @param minuteOfDay  the minute of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setMinuteOfDay(final int minuteOfDay) {\n+        setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay));\n+    }\n+\n+    /**\n+     * Set the minute of the hour to the specified value.\n+     *\n+     * @param minuteOfHour  the minute of hour\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setMinuteOfHour(final int minuteOfHour) {\n+        setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour));\n+    }\n+\n+    /**\n+     * Add a number of minutes to the date.\n+     *\n+     * @param minutes  the minutes to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addMinutes(final int minutes) {\n+        setMillis(getChronology().minutes().add(getMillis(), minutes));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the second of the day to the specified value.\n+     *\n+     * @param secondOfDay  the second of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setSecondOfDay(final int secondOfDay) {\n+        setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay));\n+    }\n+\n+    /**\n+     * Set the second of the minute to the specified value.\n+     *\n+     * @param secondOfMinute  the second of minute\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setSecondOfMinute(final int secondOfMinute) {\n+        setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute));\n     }\n \n     /**\n      * Add a number of seconds to the date.\n      *\n-     * @param seconds  the seconds to add.\n-     */\n-    public void addSeconds(int seconds) {\n-        iMillis = getChronology().secondOfDay().add(iMillis, seconds);\n-    }\n-\n-    /**\n-     * Set the minute of the hour.\n-     *\n-     * @param minute  the minute of hour.\n-     */\n-    public void setMinuteOfHour(int minute) {\n-        iMillis = getChronology().minuteOfHour().set(iMillis, minute);\n-    }\n-\n-    /**\n-     * Set the minute of the day.\n-     *\n-     * @param minute  the minute of day.\n-     */\n-    public void setMinuteOfDay(int minute) {\n-        iMillis = getChronology().minuteOfDay().set(iMillis, minute);\n-    }\n-\n-    /**\n-     * Add a number of minutes to the date.\n-     *\n-     * @param minutes  the minutes to add.\n-     */\n-    public void addMinutes(int minutes) {\n-        iMillis = getChronology().minuteOfDay().add(iMillis, minutes);\n-    }\n-\n-    /**\n-     * Set the hour of the day.\n-     *\n-     * @param hour  the hour of day.\n-     */\n-    public void setHourOfDay(int hour) {\n-        iMillis = getChronology().hourOfDay().set(iMillis, hour);\n-    }\n-\n-    /**\n-     * Add a number of hours to the date.\n-     *\n-     * @param hours  the hours to add.\n-     */\n-    public void addHours(int hours) {\n-        iMillis = getChronology().hourOfDay().add(iMillis, hours);\n-    }\n-\n-    // Convenient helpers\n-    //----------------------------------------------------\n-    \n-    /**\n-     * Set the date from various different types of object.\n-     * The time part of the parameter will be ignored.\n+     * @param seconds  the seconds to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addSeconds(final int seconds) {\n+        setMillis(getChronology().seconds().add(getMillis(), seconds));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the millis of the day to the specified value.\n+     *\n+     * @param millisOfDay  the millis of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setMillisOfDay(final int millisOfDay) {\n+        setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));\n+    }\n+\n+    /**\n+     * Set the millis of the second to the specified value.\n+     *\n+     * @param millisOfSecond  the millis of second\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setMillisOfSecond(final int millisOfSecond) {\n+        setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond));\n+    }\n+\n+    /**\n+     * Add a number of milliseconds to the date. The implementation of this\n+     * method differs from the {@link #add(long)} method in that a\n+     * DateTimeField performs the addition.\n+     *\n+     * @param millis  the milliseconds to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addMillis(final int millis) {\n+        setMillis(getChronology().millis().add(getMillis(), millis));\n+    }\n+\n+    // Setters\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the date from milliseconds.\n      * The time part of this object will be unaffected.\n      *\n-     * @param date  a ReadableInstant, Date, Calendar, Long or String\n-     * @throws IllegalArgumentException if the object is null.\n-     * @throws ClassCastException if the object's type cannot be recognised\n-     */\n-    public void setDate(Object date) {\n-        setDate(getDateTimeMillisFromObject(date));\n-    }\n-\n-    /**\n-     * Set the date from milliseconds.\n-     * The time part of the parameter will be ignored.\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z, time part ignored\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setDate(final long instant) {\n+        Chronology c = getChronology();\n+        setMillis(c.getDateOnlyMillis(instant) + c.getTimeOnlyMillis(getMillis()));\n+    }\n+\n+    /**\n+     * Set the date from an object representing an instant.\n      * The time part of this object will be unaffected.\n-     *\n-     * @param millis milliseconds from 1970-01-01T00:00:00Z, ignoring time of\n-     * day\n-     */\n-    public void setDate(long millis) {\n-        Chronology c = getChronology();\n-        iMillis = c.getDateOnlyMillis(millis) + c.getTimeOnlyMillis(iMillis);\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  an object representing an instant, time part ignored\n+     * @throws IllegalArgumentException if the object is null or invalid\n+     */\n+    public void setDate(final Object instant) {\n+        if (instant instanceof ReadableInstant) {\n+            setDate(((ReadableInstant) instant).getMillis());\n+        } else {\n+            InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+            setDate(converter.getInstantMillis(instant));\n+        }\n     }\n \n     /**\n      * The time part of this object will be unaffected.\n      *\n      * @param year  the year\n-     * @param month  the month of the year\n+     * @param monthOfYear  the month of the year\n      * @param dayOfMonth  the day of the month\n-     */\n-    public void setDate(int year, int monthOfYear, int dayOfMonth) {\n-        // Do not modify this object until method completion\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setDate(\n+            final int year,\n+            final int monthOfYear,\n+            final int dayOfMonth) {\n         Chronology c = getChronology();\n-        long workVal = c.getTimeOnlyMillis( iMillis );\n-        workVal = c.year().set( workVal, year );\n-        workVal = c.monthOfYear().set( workVal, monthOfYear );\n-        workVal = c.dayOfMonth().set( workVal, dayOfMonth );\n-        iMillis = workVal;\n-    }\n-\n-    /**\n-     * Set the time from an object.\n-     * The date part of the parameter will be ignored.\n+        long instant = c.getDateTimeMillis(\n+            year, monthOfYear, dayOfMonth, 0, 0, 0, 0);\n+        setDate(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the time from milliseconds.\n      * The date part of this object will be unaffected.\n      *\n-     * @param time  a ReadableInstant, Date, Calendar, Long or String\n-     * @throws IllegalArgumentException if the object is null.\n-     * @throws ClassCastException if the object's type cannot be recognised\n-     */\n-    public void setTime(Object time) {\n-        setTime(getDateTimeMillisFromObject(time));\n-    }\n-\n-    /**\n-     * Set the time from milliseconds.\n-     * The date part of the parameter will be ignored.\n+     * @param millis milliseconds from T00:00:00Z, date part ignored\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setTime(final long millis) {\n+        Chronology c = getChronology();\n+        setMillis(c.getDateOnlyMillis(getMillis()) + c.getTimeOnlyMillis(millis));\n+    }\n+\n+    /**\n+     * Set the date from an object representing an instant.\n      * The date part of this object will be unaffected.\n-     *\n-     * @param millis milliseconds from T00:00:00Z, ignoring date\n-     */\n-    public void setTime(long millis) {\n-        Chronology c = getChronology();\n-        iMillis = c.getDateOnlyMillis(iMillis) + c.getTimeOnlyMillis(millis);\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  an object representing an instant, date part ignored\n+     * @throws IllegalArgumentException if the object is null or invalid\n+     */\n+    public void setTime(final Object instant) {\n+        if (instant instanceof ReadableInstant) {\n+            setDateTime(((ReadableInstant) instant).getMillis());\n+        } else {\n+            InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+            setDateTime(converter.getInstantMillis(instant));\n+        }\n     }\n \n     /**\n      * @param minuteOfHour  the minute of the hour\n      * @param secondOfMinute  the second of the minute\n      * @param millisOfSecond  the milisecond of the second\n-     */\n-    public void setTime(int hour, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n-        // Do not modify this object until method completion\n-        Chronology c = getChronology();\n-        long workVal = c.getDateOnlyMillis( iMillis );\n-        workVal = c.hourOfDay().set( workVal, hour );\n-        workVal = c.minuteOfHour().set( workVal, minuteOfHour );\n-        workVal = c.secondOfMinute().set( workVal, secondOfMinute );\n-        workVal = c.millisOfSecond().set( workVal, millisOfSecond );\n-        iMillis = workVal;\n-    }\n-\n-    /**\n-     * Set the date and time from an object.\n-     *\n-     * @param datetime  a ReadableInstant, Date, Calendar, Long or String\n-     * @throws IllegalArgumentException if the object is null.\n-     * @throws ClassCastException if the object's type cannot be recognised\n-     */\n-    public void setDateTime(Object datetime) {\n-        iMillis = getDateTimeMillisFromObject(datetime);\n-    }\n-\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setTime(\n+            final int hour,\n+            final int minuteOfHour,\n+            final int secondOfMinute,\n+            final int millisOfSecond) {\n+        long instant = getChronology().getDateTimeMillis(\n+            getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond);\n+        setTime(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Set the date and time from milliseconds.\n-     *\n-     * @param millis  the millis\n-     */\n-    public void setDateTime(long millis) {\n-        iMillis = millis;\n+     * This method is a synonm for {@link #setMillis(long)}.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setDateTime(final long instant) {\n+        setMillis(instant);\n+    }\n+\n+    /**\n+     * Set the date and time from an object representing an instant.\n+     * This method is a synonm for {@link #setMillis(Object)}.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  an object representing an instant\n+     * @throws IllegalArgumentException if the object is null or invalid\n+     */\n+    public void setDateTime(final Object instant) {\n+        setDateTime(instant);\n     }\n \n     /**\n      * Set the date and time from fields.\n      *\n      * @param year  the year\n-     * @param month  the month of the year\n+     * @param monthOfYear  the month of the year\n      * @param dayOfMonth  the day of the month\n-     * @param hour  the hour\n+     * @param hourOfDay  the hour of the day\n      * @param minuteOfHour  the minute of the hour\n      * @param secondOfMinute  the second of the minute\n      * @param millisOfSecond  the milisecond of the second\n-     */\n-    public void setDateTime(int year,\n-                            int monthOfYear,\n-                            int dayOfMonth,\n-                            int hourOfDay,\n-                            int minuteOfHour,\n-                            int secondOfMinute,\n-                            int millisOfSecond)\n-    {\n-        // Do not modify this object until method completion\n-        Chronology c = getChronology();\n-        long workVal = 0;\n-        workVal = c.year().set( workVal, year );\n-        workVal = c.monthOfYear().set( workVal, monthOfYear );\n-        workVal = c.dayOfMonth().set( workVal, dayOfMonth );\n-        workVal = c.hourOfDay().set( workVal, hourOfDay );\n-        workVal = c.minuteOfHour().set( workVal, minuteOfHour );\n-        workVal = c.secondOfMinute().set( workVal, secondOfMinute );\n-        workVal = c.millisOfSecond().set( workVal, millisOfSecond );\n-        iMillis = workVal;\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setDateTime(\n+            final int year,\n+            final int monthOfYear,\n+            final int dayOfMonth,\n+            final int hourOfDay,\n+            final int minuteOfHour,\n+            final int secondOfMinute,\n+            final int millisOfSecond) {\n+        long instant = getChronology().getDateTimeMillis(\n+            year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        setDateTime(instant);\n     }\n \n     // Date properties\n-    //-----------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the era property.\n+     * \n+     * @return the era property\n+     */\n+    public MutableDateTimeFieldProperty era() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().era());\n+    }\n+\n+    /**\n+     * Get the century of era property.\n+     * \n+     * @return the year of era property\n+     */\n+    public MutableDateTimeFieldProperty centuryOfEra() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().centuryOfEra());\n+    }\n+\n+    /**\n+     * Get the year of century property.\n+     * \n+     * @return the year of era property\n+     */\n+    public MutableDateTimeFieldProperty yearOfCentury() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().yearOfCentury());\n+    }\n+\n+    /**\n+     * Get the year of era property.\n+     * \n+     * @return the year of era property\n+     */\n+    public MutableDateTimeFieldProperty yearOfEra() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().yearOfEra());\n+    }\n+\n+    /**\n+     * Get the year property.\n+     * \n+     * @return the year property\n+     */\n+    public MutableDateTimeFieldProperty year() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().year());\n+    }\n+\n+    /**\n+     * Get the year of a week based year property.\n+     * \n+     * @return the year of a week based year property\n+     */\n+    public MutableDateTimeFieldProperty weekyear() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().weekyear());\n+    }\n+\n+    /**\n+     * Get the month of year property.\n+     * \n+     * @return the month of year property\n+     */\n+    public MutableDateTimeFieldProperty monthOfYear() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().monthOfYear());\n+    }\n+\n+    /**\n+     * Get the week of a week based year property.\n+     * \n+     * @return the week of a week based year property\n+     */\n+    public MutableDateTimeFieldProperty weekOfWeekyear() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().weekOfWeekyear());\n+    }\n+\n+    /**\n+     * Get the day of year property.\n+     * \n+     * @return the day of year property\n+     */\n+    public MutableDateTimeFieldProperty dayOfYear() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().dayOfYear());\n+    }\n+\n+    /**\n+     * Get the day of month property.\n+     * <p>\n+     * The values for day of month are defined in {@link DateTimeConstants}.\n+     * \n+     * @return the day of month property\n+     */\n+    public MutableDateTimeFieldProperty dayOfMonth() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().dayOfMonth());\n+    }\n \n     /**\n      * Get the day of week property.\n         return new MutableDateTimeFieldProperty(this, getChronology().dayOfWeek());\n     }\n \n-    /**\n-     * Get the day of month property.\n-     * \n-     * @return the day of month property\n-     */\n-    public MutableDateTimeFieldProperty dayOfMonth() {\n-        return new MutableDateTimeFieldProperty(this, getChronology().dayOfMonth());\n-    }\n-\n-    /**\n-     * Get the day of year property.\n-     * \n-     * @return the day of year property\n-     */\n-    public MutableDateTimeFieldProperty dayOfYear() {\n-        return new MutableDateTimeFieldProperty(this, getChronology().dayOfYear());\n-    }\n-\n-    /**\n-     * Get the week of a week based year property.\n-     * \n-     * @return the week of a week based year property\n-     */\n-    public MutableDateTimeFieldProperty weekOfWeekyear() {\n-        return new MutableDateTimeFieldProperty(this, getChronology().weekOfWeekyear());\n-    }\n-\n-    /**\n-     * Get the year of a week based year property.\n-     * \n-     * @return the year of a week based year property\n-     */\n-    public MutableDateTimeFieldProperty weekyear() {\n-        return new MutableDateTimeFieldProperty(this, getChronology().weekyear());\n-    }\n-\n-    /**\n-     * Get the month of year property.\n-     * \n-     * @return the month of year property\n-     */\n-    public MutableDateTimeFieldProperty monthOfYear() {\n-        return new MutableDateTimeFieldProperty(this, getChronology().monthOfYear());\n-    }\n-\n-    /**\n-     * Get the year property.\n-     * \n-     * @return the year property\n-     */\n-    public MutableDateTimeFieldProperty year() {\n-        return new MutableDateTimeFieldProperty(this, getChronology().year());\n-    }\n-\n-    /**\n-     * Get the year of era property.\n-     * \n-     * @return the year of era property\n-     */\n-    public MutableDateTimeFieldProperty yearOfEra() {\n-        return new MutableDateTimeFieldProperty(this, getChronology().yearOfEra());\n-    }\n-\n-    /**\n-     * Get the year of century property.\n-     * \n-     * @return the year of era property\n-     */\n-    public MutableDateTimeFieldProperty yearOfCentury() {\n-        return new MutableDateTimeFieldProperty(this, getChronology().yearOfCentury());\n-    }\n-\n-    /**\n-     * Get the century of era property.\n-     * \n-     * @return the year of era property\n-     */\n-    public MutableDateTimeFieldProperty centuryOfEra() {\n-        return new MutableDateTimeFieldProperty(this, getChronology().centuryOfEra());\n-    }\n-\n-    /**\n-     * Get the era property.\n-     * \n-     * @return the era property\n-     */\n-    public MutableDateTimeFieldProperty era() {\n-        return new MutableDateTimeFieldProperty(this, getChronology().era());\n-    }\n-\n     // Time properties\n-    //-----------------------------------------------------------\n-    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day field property\n+     * \n+     * @return the hour of day property\n+     */\n+    public MutableDateTimeFieldProperty hourOfDay() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().hourOfDay());\n+    }\n+\n+    /**\n+     * Get the minute of day property\n+     * \n+     * @return the minute of day property\n+     */\n+    public MutableDateTimeFieldProperty minuteOfDay() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().minuteOfDay());\n+    }\n+\n+    /**\n+     * Get the minute of hour field property\n+     * \n+     * @return the minute of hour property\n+     */\n+    public MutableDateTimeFieldProperty minuteOfHour() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().minuteOfHour());\n+    }\n+\n+    /**\n+     * Get the second of day property\n+     * \n+     * @return the second of day property\n+     */\n+    public MutableDateTimeFieldProperty secondOfDay() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().secondOfDay());\n+    }\n+\n+    /**\n+     * Get the second of minute field property\n+     * \n+     * @return the second of minute property\n+     */\n+    public MutableDateTimeFieldProperty secondOfMinute() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().secondOfMinute());\n+    }\n+\n+    /**\n+     * Get the millis of day property\n+     * \n+     * @return the millis of day property\n+     */\n+    public MutableDateTimeFieldProperty millisOfDay() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().millisOfDay());\n+    }\n+\n     /**\n      * Get the millis of second property\n      * \n         return new MutableDateTimeFieldProperty(this, getChronology().millisOfSecond());\n     }\n \n-    /**\n-     * Get the millis of day property\n-     * \n-     * @return the millis of day property\n-     */\n-    public MutableDateTimeFieldProperty millisOfDay() {\n-        return new MutableDateTimeFieldProperty(this, getChronology().millisOfDay());\n-    }\n-\n-    /**\n-     * Get the second of minute field property\n-     * \n-     * @return the second of minute property\n-     */\n-    public MutableDateTimeFieldProperty secondOfMinute() {\n-        return new MutableDateTimeFieldProperty(this, getChronology().secondOfMinute());\n-    }\n-\n-    /**\n-     * Get the second of day property\n-     * \n-     * @return the second of day property\n-     */\n-    public MutableDateTimeFieldProperty secondOfDay() {\n-        return new MutableDateTimeFieldProperty(this, getChronology().secondOfDay());\n-    }\n-\n-    /**\n-     * Get the minute of hour field property\n-     * \n-     * @return the minute of hour property\n-     */\n-    public MutableDateTimeFieldProperty minuteOfHour() {\n-        return new MutableDateTimeFieldProperty(this, getChronology().minuteOfHour());\n-    }\n-\n-    /**\n-     * Get the minute of day property\n-     * \n-     * @return the minute of day property\n-     */\n-    public MutableDateTimeFieldProperty minuteOfDay() {\n-        return new MutableDateTimeFieldProperty(this, getChronology().minuteOfDay());\n-    }\n-\n-    /**\n-     * Get the hour of day field property\n-     * \n-     * @return the hour of day property\n-     */\n-    public MutableDateTimeFieldProperty hourOfDay() {\n-        return new MutableDateTimeFieldProperty(this, getChronology().hourOfDay());\n-    }\n-\n     // Misc\n-    //-----------------------------------------------------------\n-\n-    /**\n-     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZ).\n-     * \n-     * @return ISO8601 time formatted string.\n-     */\n-    public String toString() {\n-        return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);\n-    }\n-\n+    //-----------------------------------------------------------------------\n     /**\n      * Clone this object without having to cast the returned object.\n      *\n      * @return a clone of the this object.\n      */\n     public MutableDateTime copy() {\n-        try {\n-            return (MutableDateTime)super.clone();\n-        } catch (CloneNotSupportedException ex) {\n-            throw new InternalError(\"Clone error\");\n-        }\n+        return (MutableDateTime)clone();\n     }\n \n     /**\n     }\n \n     /**\n-     * Extracts a long datetime value from an object.\n-     *\n-     * @param object  an input object\n-     * @return a long date-time value\n-     * @throws IllegalArgumentException if the object is null, or the string invalid\n-     * @throws ClassCastException if the object type is not supported\n-     */\n-    protected long getDateTimeMillisFromObject(Object object) {\n-        if (object instanceof ReadableInstant) {\n-            return ((ReadableInstant) object).getMillis();\n-\n-        } else if (object instanceof Date) {\n-            return ((Date) object).getTime();\n-\n-        } else if (object instanceof Calendar) {\n-            return ((Calendar) object).getTime().getTime();\n-\n-        } else if (object instanceof Long) {\n-            return ((Long) object).longValue();\n-\n-        } else if (object instanceof String) {\n-            try {\n-                Instant instant = new Instant((String) object);\n-                return instant.getMillis();\n-\n-            } catch (ParseException ex) {\n-                throw new IllegalArgumentException(\"String '\" + object + \"' is an invalid date format\");\n-            }\n-        } else if (object == null) {\n-            throw new IllegalArgumentException(\"<null> cannot be converted to a datetime\");\n-        } else {\n-            throw new ClassCastException(\"Class '\" + object.getClass().getName() + \"' cannot be converted to a datetime\");\n-        }\n-    }\n-\n-    /**\n-     * Extracts a fixed millisecond duration from an object.\n-     * \n-     * @param object  Long or String\n-     * @throws IllegalArgumentException if the object is null, or the string invalid\n-     * @throws ClassCastException if the object type is not supported\n-     */\n-    protected long getDurationMillisFromObject(Object object) {\n-        if (object instanceof Long) {\n-            Long other = (Long) object;\n-            return other.longValue();\n-        /* TODO } else if (object instanceof String) {\n-            try {\n-                TimePeriod other = new TimePeriod((String) object);\n-                return other.getMillis();\n-            } catch (ParseException ex) {\n-                throw new IllegalArgumentException\n-                    (\"String '\" + object + \"' is an invalid time period format\");\n-            }*/\n-        } else {\n-            String type;\n-            if (object == null) {\n-                type = \"<null>\";\n-            } else {\n-                type = \"Object of type \\\"\" + object.getClass().getName() + '\"';\n-            }\n-            throw new IllegalArgumentException(type + \" cannot be converted to a duration\");\n-        }\n-    }\n-    \n+     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZ).\n+     * \n+     * @return ISO8601 time formatted string.\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);\n+    }\n+\n }\n--- a/JodaTime/src/java/org/joda/time/MutableDateTimeFieldProperty.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDateTimeFieldProperty.java\n import java.util.Locale;\n \n /**\n- * MutableDateTimeFieldProperty binds a ReadWritableInstant to a DateTimeField.\n+ * MutableDateTimeFieldProperty binds a MutableDateTime to a DateTimeField\n+ * allowing powerful datetime functionality to be easily accessed.\n  * <p>\n- * MutableDateTimeFieldProperty allows the date and time manipulation code to\n- * be field based yet still easy to use.\n+ * The example below shows how to use the property to change the value of a\n+ * MutableDateTime object.\n+ * <pre>\n+ * MutableDateTime dt = new MutableDateTime(1972, 12, 3, 0, 0, 0, 0);\n+ * dt.year().add(20);\n+ * dt.second().roundFloor();\n+ * dt.minute().set(10);\n+ * </pre>\n+ * <p>\n+ * MutableDateTimeFieldPropery itself is thread-safe and immutable, but the\n+ * MutableDateTime being operated on may not be thread-safe.\n  *\n  * @see ReadWritableInstant\n  * @see DateTimeField\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public class MutableDateTimeFieldProperty extends DateTimeFieldProperty {\n+public class MutableDateTimeFieldProperty extends AbstractDateTimeFieldProperty {\n+\n+    static final long serialVersionUID = -4481126543819298617L;\n+\n+    /** The instant this property is working against */\n+    private final MutableDateTime iInstant;\n+    /** The field this property is working against */\n+    private final DateTimeField iField;\n \n     /**\n      * Constructor.\n-     *\n+     * \n      * @param instant  the instant to set\n      * @param field  the field to use\n      */\n-    public MutableDateTimeFieldProperty(ReadWritableInstant instant, DateTimeField field) {\n-        super(instant, field);\n-    }\n-\n+    public MutableDateTimeFieldProperty(MutableDateTime instant, DateTimeField field) {\n+        super();\n+        iInstant = instant;\n+        iField = field;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field being used.\n+     * \n+     * @return the field\n+     */\n+    public DateTimeField getField() {\n+        return iField;\n+    }\n+\n+    /**\n+     * Gets the instant being used.\n+     * \n+     * @return the instant\n+     */\n+    public ReadableDateTime getInstant() {\n+        return iInstant;\n+    }\n+\n+    /**\n+     * Gets the instant being used.\n+     * \n+     * @return the instant\n+     */\n+    public MutableDateTime getMutableDateTime() {\n+        return iInstant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Adds a value to the millis value.\n      * \n-     * @param value  the value to add.\n+     * @param value  the value to add\n      * @see DateTimeField#add(long,int)\n      */\n     public void add(int value) {\n-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n-        instant.setMillis(getField().add(instant.getMillis(), value));\n+        iInstant.setMillis(getField().add(iInstant.getMillis(), value));\n     }\n \n     /**\n      * Adds a value to the millis value.\n      * \n-     * @param value  the value to add.\n+     * @param value  the value to add\n      * @see DateTimeField#add(long,long)\n      */\n     public void add(long value) {\n-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n-        instant.setMillis(getField().add(instant.getMillis(), value));\n+        iInstant.setMillis(getField().add(iInstant.getMillis(), value));\n     }\n \n     /**\n      * Adds a value, possibly wrapped, to the millis value.\n      * \n-     * @param value  the value to add.\n+     * @param value  the value to add\n      * @see DateTimeField#addWrapped\n      */\n     public void addWrapped(int value) {\n-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n-        instant.setMillis(getField().addWrapped(instant.getMillis(), value));\n-    }\n-\n+        iInstant.setMillis(getField().addWrapped(iInstant.getMillis(), value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Sets a value.\n      * \n      * @see DateTimeField#set(long,int)\n      */\n     public void set(int value) {\n-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n-        instant.setMillis(getField().set(instant.getMillis(), value));\n+        iInstant.setMillis(getField().set(iInstant.getMillis(), value));\n     }\n \n     /**\n      * @see DateTimeField#set(long,java.lang.String,java.util.Locale)\n      */\n     public void set(String text, Locale locale) {\n-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n-        instant.setMillis(getField().set(instant.getMillis(), text, locale));\n+        iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale));\n     }\n \n     /**\n         set(text, null);\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Round to the lowest whole unit of this field.\n      *\n      * @see DateTimeField#roundFloor\n      */\n     public void roundFloor() {\n-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n-        instant.setMillis(getField().roundFloor(instant.getMillis()));\n+        iInstant.setMillis(getField().roundFloor(iInstant.getMillis()));\n     }\n \n     /**\n      * @see DateTimeField#roundCeiling\n      */\n     public void roundCeiling() {\n-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n-        instant.setMillis(getField().roundCeiling(instant.getMillis()));\n+        iInstant.setMillis(getField().roundCeiling(iInstant.getMillis()));\n     }\n \n     /**\n      * @see DateTimeField#roundHalfFloor\n      */\n     public void roundHalfFloor() {\n-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n-        instant.setMillis(getField().roundHalfFloor(instant.getMillis()));\n+        iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis()));\n     }\n \n     /**\n      * @see DateTimeField#roundHalfCeiling\n      */\n     public void roundHalfCeiling() {\n-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n-        instant.setMillis(getField().roundHalfCeiling(instant.getMillis()));\n+        iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis()));\n     }\n \n     /**\n      * Round to the nearest whole unit of this field. If halfway, the ceiling\n-     * is favored the floor only if it makes this field's value even.\n+     * is favored over the floor only if it makes this field's value even.\n      *\n      * @see DateTimeField#roundHalfEven\n      */\n     public void roundHalfEven() {\n-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n-        instant.setMillis(getField().roundHalfEven(instant.getMillis()));\n-    }\n-\n-    /**\n-     * Retains only the fractional units of this field.\n-     *\n-     * @see DateTimeField#remainder\n-     */\n-    public void remainder() {\n-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n-        instant.setMillis(getField().remainder(instant.getMillis()));\n-    }\n+        iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis()));\n+    }\n+\n }\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/MutableDuration.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Standard mutable duration implementation.\n+ * <p>\n+ * MutableDuration is mutable and not thread-safe, unless concurrent threads\n+ * are not invoking mutator methods.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ * @see Duration\n+ */\n+public class MutableDuration extends AbstractDuration\n+    implements ReadWritableDuration, Cloneable, Serializable {\n+\n+    static final long serialVersionUID = 3436451121567212165L;\n+\n+    /**\n+     * Copies another duration to this one.\n+     *\n+     * @throws UnsupportedOperationException if an unsupported field's value is\n+     * non-zero\n+     */\n+    public MutableDuration(ReadableDuration duration) {\n+        super(duration);\n+    }\n+\n+    /**\n+     * Copies another duration to this one.\n+     *\n+     * @param type use a different DurationType\n+     * @throws UnsupportedOperationException if an unsupported field's value is\n+     * non-zero\n+     */\n+    public MutableDuration(DurationType type, ReadableDuration duration) {\n+        super(type, duration);\n+    }\n+\n+    /**\n+     * Create a duration from a set of field values.\n+     *\n+     * @param type determines which set of fields this duration supports\n+     * @param years amount of years in this duration, which must be zero if\n+     * unsupported.\n+     * @param months amount of months in this duration, which must be zero if\n+     * unsupported.\n+     * @param weeks amount of weeks in this duration, which must be zero if\n+     * unsupported.\n+     * @param days amount of days in this duration, which must be zero if\n+     * unsupported.\n+     * @param hours amount of hours in this duration, which must be zero if\n+     * unsupported.\n+     * @param minutes amount of minutes in this duration, which must be zero if\n+     * unsupported.\n+     * @param seconds amount of seconds in this duration, which must be zero if\n+     * unsupported.\n+     * @param millis amount of milliseconds in this duration, which must be\n+     * zero if unsupported.\n+     * @throws UnsupportedOperationException if an unsupported field's value is\n+     * non-zero\n+     */\n+    public MutableDuration(DurationType type,\n+                           int years, int months, int weeks, int days,\n+                           int hours, int minutes, int seconds, int millis) {\n+        super(type, years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param type determines which set of fields this duration supports\n+     * @param startInstant interval start, in milliseconds\n+     * @param endInstant interval end, in milliseconds\n+     */\n+    public MutableDuration(DurationType type, long startInstant, long endInstant) {\n+        super(type, startInstant, endInstant);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param type determines which set of fields this duration supports\n+     * @param startInstant interval start\n+     * @param endInstant interval end\n+     */\n+    public MutableDuration(DurationType type,\n+                           ReadableInstant startInstant, ReadableInstant endInstant) {\n+        super(type, startInstant, endInstant);\n+    }\n+\n+    /**\n+     * Creates a duration from the given millisecond duration. If any supported\n+     * fields are imprecise, an UnsupportedOperationException is thrown. The\n+     * exception to this is when the specified duration is zero.\n+     *\n+     * @param type determines which set of fields this duration supports\n+     * @param duration  the duration, in milliseconds\n+     * @throws UnsupportedOperationException if any fields are imprecise\n+     */\n+    public MutableDuration(DurationType type, long duration) {\n+        super(type, duration);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from another ReadableDuration.\n+     * \n+     * @param duration  the duration to set\n+     * @throws IllegalArgumentException if duration is null\n+     * @throws UnsupportedOperationException if an unsupported field's value is\n+     * non-zero\n+     */\n+    public void setDuration(ReadableDuration duration) {\n+        super.setDuration(duration);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go.\n+     * \n+     * @param years amount of years in this duration, which must be zero if\n+     * unsupported.\n+     * @param months amount of months in this duration, which must be zero if\n+     * unsupported.\n+     * @param weeks amount of weeks in this duration, which must be zero if\n+     * unsupported.\n+     * @param days amount of days in this duration, which must be zero if\n+     * unsupported.\n+     * @param hours amount of hours in this duration, which must be zero if\n+     * unsupported.\n+     * @param minutes amount of minutes in this duration, which must be zero if\n+     * unsupported.\n+     * @param seconds amount of seconds in this duration, which must be zero if\n+     * unsupported.\n+     * @param millis amount of milliseconds in this duration, which must be\n+     * zero if unsupported.\n+     * @throws UnsupportedOperationException if an unsupported field's value is\n+     * non-zero\n+     */\n+    public void setDuration(int years, int months, int weeks, int days,\n+                            int hours, int minutes, int seconds, int millis) {\n+        super.setDuration(years, months, weeks, days,\n+                          hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond interval.\n+     * \n+     * @param startInstant interval start, in milliseconds\n+     * @param endInstant interval end, in milliseconds\n+     */\n+    public void setTotalMillis(long startInstant, long endInstant) {\n+        super.setTotalMillis(startInstant, endInstant);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond duration. If any\n+     * supported fields are imprecise, an UnsupportedOperationException is\n+     * thrown. The exception to this is when the specified duration is zero.\n+     * \n+     * @param duration  the duration, in milliseconds\n+     * @throws UnsupportedOperationException if any fields are imprecise\n+     */\n+    public void setTotalMillis(long duration) {\n+        super.setTotalMillis(duration);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a millisecond duration to this one.\n+     * \n+     * @param duration  the duration to add, in milliseconds\n+     * @throws IllegalStateException if the duration is imprecise\n+     */\n+    public void add(long duration) {\n+        super.add(duration);\n+    }\n+    \n+    /**\n+     * Adds a duration to this one.\n+     * \n+     * @param duration  the duration to add\n+     * @throws IllegalArgumentException if the duration is null\n+     * @throws IllegalStateException if the duration is imprecise\n+     */\n+    public void add(ReadableDuration duration) {\n+        super.add(duration);\n+    }\n+    \n+    /**\n+     * Normalizes all the field values in this duration.\n+     *\n+     * @throws IllegalStateException if this duration is imprecise\n+     */\n+    public void normalize() {\n+        super.normalize();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of years of the duration.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setYears(int years) {\n+        super.setYears(years);\n+    }\n+\n+    /**\n+     * Adds the specified years to the number of years in the duration.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void addYears(int years) {\n+        super.addYears(years);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of months of the duration.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setMonths(int months) {\n+        super.setMonths(months);\n+    }\n+\n+    /**\n+     * Adds the specified months to the number of months in the duration.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void addMonths(int months) {\n+        super.addMonths(months);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of weeks of the duration.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setWeeks(int weeks) {\n+        super.setWeeks(weeks);\n+    }\n+\n+    /**\n+     * Adds the specified weeks to the number of weeks in the duration.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void addWeeks(int weeks) {\n+        super.addWeeks(weeks);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of days of the duration.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setDays(int days) {\n+        super.setDays(days);\n+    }\n+\n+    /**\n+     * Adds the specified days to the number of days in the duration.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void addDays(int days) {\n+        super.addDays(days);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of hours of the duration.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setHours(int hours) {\n+        super.setHours(hours);\n+    }\n+\n+    /**\n+     * Adds the specified hours to the number of hours in the duration.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void addHours(int hours) {\n+        super.addHours(hours);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of minutes of the duration.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setMinutes(int minutes) {\n+        super.setMinutes(minutes);\n+    }\n+\n+    /**\n+     * Adds the specified minutes to the number of minutes in the duration.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void addMinutes(int minutes) {\n+        super.addMinutes(minutes);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of seconds of the duration.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setSeconds(int seconds) {\n+        super.setSeconds(seconds);\n+    }\n+\n+    /**\n+     * Adds the specified seconds to the number of seconds in the duration.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void addSeconds(int seconds) {\n+        super.addSeconds(seconds);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of millis of the duration.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setMillis(int millis) {\n+        super.setMillis(millis);\n+    }\n+\n+    /**\n+     * Adds the specified millis to the number of millis in the duration.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void addMillis(int millis) {\n+        super.addMillis(millis);\n+    }\n+\n+    // Misc\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clone this object without having to cast the returned object.\n+     *\n+     * @return a clone of the this object.\n+     */\n+    public MutableDuration copy() {\n+        return (MutableDuration)clone();\n+    }\n+\n+    /**\n+     * Clone this object.\n+     *\n+     * @return a clone of this object.\n+     */\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (CloneNotSupportedException ex) {\n+            throw new InternalError(\"Clone error\");\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/PartialInstant.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Defines an instant that does not support every datetime field.\n+ * A PartialInstant supports a range of fields, specified by lower and\n+ * upper bounding fields.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public interface PartialInstant extends ReadableInstant {\n+\n+    /**\n+     * Get the value as the number of milliseconds since the epoch,\n+     * 1970-01-01T00:00:00Z, with unsupported field values reset.\n+     *\n+     * @return the value as milliseconds\n+     */\n+    long getMillis();\n+\n+    /**\n+     * Get the value as the number of milliseconds since the epoch,\n+     * 1970-01-01T00:00:00Z, with unsupported field values and time zone filled\n+     * in by the given base instant.\n+     *\n+     * @param base  source of missing fields\n+     * @return the value as milliseconds\n+     */\n+    long getMillis(ReadableInstant base);\n+\n+    /**\n+     * Get the value as the number of milliseconds since the epoch,\n+     * 1970-01-01T00:00:00Z, with unsupported field values filled in by the\n+     * given base instant.\n+     *\n+     * @param base  source of missing fields\n+     * @param zone  override the base time zone, null implies override with no\n+     * time zone\n+     * @return the value as milliseconds\n+     */\n+    long getMillis(ReadableInstant base, DateTimeZone zone);\n+\n+    /**\n+     * Gets the chronology of the instant, null if not applicable. The time\n+     * zone of the chronology is either null or UTC.\n+     * <p>\n+     * The {@link Chronology} provides conversion from the millisecond\n+     * value to meaningful fields in a particular calendar system.\n+     * \n+     * @return the Chronology\n+     */\n+    Chronology getChronology();\n+\n+    /**\n+     * Returns the lower limiting field, where the lower limit field itself is\n+     * supported. In other words, for the range described by the lower and\n+     * upper limits, the lower limit is inclusive.\n+     *\n+     * @return lower limit or null if none\n+     */\n+    DateTimeField getLowerLimit();\n+\n+    /**\n+     * Returns the upper limiting field, where the upper limit field itself is\n+     * not supported. In other words, for the range described by the lower and\n+     * upper limits, the upper limit is exclusive.\n+     *\n+     * @return upper limit or null if none\n+     */\n+    DateTimeField getUpperLimit();\n+\n+    /**\n+     * Returns true if the given instant is a PartialDateTime that supports the\n+     * same exact set of fields. Implementations may simply do the following:\n+     * <pre>\n+     *     return instant instanceof &lt;this class&gt;;\n+     * </pre>\n+     *\n+     * @param instant  the instant to compare to\n+     * @return true if instant is same type as this\n+     */\n+    boolean isMatchingType(ReadableInstant instant);\n+\n+    /**\n+     * Returns the given instant, except with lower and upper limits\n+     * applied. Field values are reset below the lower limit and at or above\n+     * the upper limit.\n+     *\n+     * @param instant milliseconds from 1970-01-01T00:00:00\n+     * @return the adjusted millisecond instant\n+     */\n+    long resetUnsupportedFields(long instant);\n+\n+    /**\n+     * Returns the given instant, except with lower and upper limits\n+     * applied. Field values are reset below the upper limit and at or above\n+     * the lower limit.\n+     *\n+     * @param instant milliseconds from 1970-01-01T00:00:00\n+     * @return the adjusted millisecond instant\n+     */\n+    long resetSupportedFields(long instant);\n+\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the millisecond instant, the Chronology, and the limiting fields.\n+     * <p>\n+     * To compare two instants for absolute time (ie. UTC milliseconds ignoring\n+     * the chronology), use {@link #isEqual(ReadableInstant)} or\n+     * {@link #compareTo(Object)}.\n+     *\n+     * @param readableInstant  a readable instant to check against\n+     * @return true if millisecond and chronology are equal, false if\n+     *  not or the instant is null or of an incorrect type\n+     */\n+    boolean equals(Object readableInstant);\n+\n+    /**\n+     * Gets a hash code for the instant that is compatable with the \n+     * equals method.\n+     *\n+     * @return a suitable hash code\n+     */\n+    int hashCode();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value as a String in a recognisable ISO8601 format, only\n+     * displaying supported fields.\n+     * <p>\n+     * The string output is in ISO8601 format to enable the String\n+     * constructor to correctly parse it.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    String toString();\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/ReadWritableDateTime.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+// Import for @link support\n+import org.joda.time.convert.ConverterManager;\n+\n+/**\n+ * Defines an instant in time that can be queried and modified using datetime fields.\n+ * <p>\n+ * The implementation of this interface will be mutable.\n+ * It may provide more advanced methods than those in the interface.\n+ * <p>\n+ * Methods in your application should be defined using <code>ReadWritableDateTime</code>\n+ * as a parameter if the method wants to manipulate and change a date in simple ways.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ */\n+public interface ReadWritableDateTime extends ReadableDateTime, ReadWritableInstant {\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the year to the specified value.\n+     *\n+     * @param year  the year\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setYear(int year);\n+\n+    /**\n+     * Add a number of years to the date.\n+     *\n+     * @param years  the years to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void addYears(int years);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the week of the year to the specified value.\n+     *\n+     * @param weekyear  the weekyear\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setWeekyear(int weekyear);\n+\n+    /**\n+     * Add a number of weekyears to the date.\n+     *\n+     * @param weekyears  the weekyears to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void addWeekyears(int weekyears);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the month of the year to the specified value.\n+     *\n+     * @param monthOfYear  the month of the year\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setMonthOfYear(int monthOfYear);\n+\n+    /**\n+     * Add a number of months to the date.\n+     *\n+     * @param months  the months to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void addMonths(int months);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the week of weekyear to the specified value.\n+     *\n+     * @param weekOfWeekyear the week of the weekyear\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setWeekOfWeekyear(int weekOfWeekyear);\n+\n+    /**\n+     * Add a number of weeks to the date.\n+     *\n+     * @param weeks  the weeks to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void addWeeks(int weeks);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the day of year to the specified value.\n+     *\n+     * @param dayOfYear the day of the year\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setDayOfYear(int dayOfYear);\n+\n+    /**\n+     * Set the day of the month to the specified value.\n+     *\n+     * @param dayOfMonth  the day of the month\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setDayOfMonth(int dayOfMonth);\n+\n+    /**\n+     * Set the day of week to the specified value.\n+     *\n+     * @param dayOfWeek  the day of the week\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setDayOfWeek(int dayOfWeek);\n+\n+    /**\n+     * Add a number of days to the date.\n+     *\n+     * @param days  the days to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void addDays(int days);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the hour of the day to the specified value.\n+     *\n+     * @param hourOfDay  the hour of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setHourOfDay(int hourOfDay);\n+\n+    /**\n+     * Add a number of hours to the date.\n+     *\n+     * @param hours  the hours to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void addHours(int hours);\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the minute of the day to the specified value.\n+     *\n+     * @param minuteOfDay  the minute of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setMinuteOfDay(int minuteOfDay);\n+\n+    /**\n+     * Set the minute of the hour to the specified value.\n+     *\n+     * @param minuteOfHour  the minute of hour\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setMinuteOfHour(int minuteOfHour);\n+\n+    /**\n+     * Add a number of minutes to the date.\n+     *\n+     * @param minutes  the minutes to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void addMinutes(int minutes);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the second of the day to the specified value.\n+     *\n+     * @param secondOfDay  the second of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setSecondOfDay(int secondOfDay);\n+\n+    /**\n+     * Set the second of the minute to the specified value.\n+     *\n+     * @param secondOfMinute  the second of minute\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setSecondOfMinute(int secondOfMinute);\n+\n+    /**\n+     * Add a number of seconds to the date.\n+     *\n+     * @param seconds  the seconds to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void addSeconds(int seconds);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the millis of the day to the specified value.\n+     *\n+     * @param millisOfDay  the millis of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setMillisOfDay(int millisOfDay);\n+\n+    /**\n+     * Set the millis of the second to the specified value.\n+     *\n+     * @param millisOfSecond  the millis of second\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setMillisOfSecond(int millisOfSecond);\n+\n+    /**\n+     * Add a number of milliseconds to the date. The implementation of this\n+     * method differs from the {@link #add(long)} method in that a\n+     * DateTimeField performs the addition.\n+     *\n+     * @param millis  the milliseconds to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void addMillis(int millis);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the date from milliseconds.\n+     * The time part of this object will be unaffected.\n+     *\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z, time part ignored\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setDate(long instant);\n+\n+    /**\n+     * Set the date from an object representing an instant.\n+     * The time part of this object will be unaffected.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  an object representing an instant, time part ignored\n+     * @throws IllegalArgumentException if the object is null or invalid\n+     */\n+    void setDate(Object instant);\n+\n+    /**\n+     * Set the date from fields.\n+     * The time part of this object will be unaffected.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setDate(int year, int monthOfYear, int dayOfMonth);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the time from milliseconds.\n+     * The date part of this object will be unaffected.\n+     *\n+     * @param millis milliseconds from T00:00:00Z, date part ignored\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setTime(long millis);\n+\n+    /**\n+     * Set the date from an object representing an instant.\n+     * The date part of this object will be unaffected.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  an object representing an instant, date part ignored\n+     * @throws IllegalArgumentException if the object is null or invalid\n+     */\n+    void setTime(Object instant);\n+\n+    /**\n+     * Set the time from fields.\n+     * The date part of this object will be unaffected.\n+     *\n+     * @param hour  the hour\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the milisecond of the second\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setTime(int hour, int minuteOfHour, int secondOfMinute, int millisOfSecond);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the date and time from milliseconds.\n+     * This method is a synonm for {@link #setMillis(long)}.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setDateTime(long instant);\n+\n+    /**\n+     * Set the date and time from an object representing an instant.\n+     * This method is a synonm for {@link #setMillis(Object)}.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  an object representing an instant\n+     * @throws IllegalArgumentException if the object is null or invalid\n+     */\n+    void setDateTime(Object instant);\n+\n+    /**\n+     * Set the date and time from fields.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the milisecond of the second\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setDateTime(\n+        int year, int monthOfYear, int dayOfMonth,\n+        int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond);\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/ReadWritableDuration.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Defines a duration of time that can be queried and modified using datetime fields.\n+ * <p>\n+ * The implementation of this interface will be mutable.\n+ * It may provide more advanced methods than those in the interface.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface ReadWritableDuration extends ReadableDuration {\n+\n+    /**\n+     * Sets all the fields in one go from another ReadableDuration.\n+     * \n+     * @param duration  the duration to set\n+     * @throws IllegalArgumentException if duration is null\n+     * @throws UnsupportedOperationException if an unsupported field's value is\n+     * non-zero\n+     */\n+    void setDuration(ReadableDuration duration);\n+\n+    /**\n+     * Sets all the fields in one go.\n+     * \n+     * @param years amount of years in this duration, which must be zero if\n+     * unsupported.\n+     * @param months amount of months in this duration, which must be zero if\n+     * unsupported.\n+     * @param weeks amount of weeks in this duration, which must be zero if\n+     * unsupported.\n+     * @param days amount of days in this duration, which must be zero if\n+     * unsupported.\n+     * @param hours amount of hours in this duration, which must be zero if\n+     * unsupported.\n+     * @param minutes amount of minutes in this duration, which must be zero if\n+     * unsupported.\n+     * @param seconds amount of seconds in this duration, which must be zero if\n+     * unsupported.\n+     * @param millis amount of milliseconds in this duration, which must be\n+     * zero if unsupported.\n+     * @throws UnsupportedOperationException if an unsupported field's value is\n+     * non-zero\n+     */\n+    void setDuration(int years, int months, int weeks, int days,\n+                     int hours, int minutes, int seconds, int millis);\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond interval.\n+     * \n+     * @param startInstant interval start, in milliseconds\n+     * @param endInstant interval end, in milliseconds\n+     */\n+    void setTotalMillis(long startInstant, long endInstant);\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond duration.\n+     * \n+     * @param duration  the duration, in milliseconds\n+     * @throws UnsupportedOperationException if any fields are imprecise\n+     */\n+    void setTotalMillis(long duration);\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a millisecond duration to this one.\n+     * \n+     * @param duration  the duration to add, in milliseconds\n+     * @throws IllegalStateException if the duration is imprecise\n+     */\n+    void add(long duration);\n+    \n+    /**\n+     * Adds a duration to this one.\n+     * \n+     * @param duration  the duration to add\n+     * @throws IllegalArgumentException if the duration is null\n+     * @throws IllegalStateException if the duration is imprecise\n+     */\n+    void add(ReadableDuration duration);\n+    \n+    /**\n+     * Normalizes all the field values in this duration.\n+     *\n+     * @throws IllegalStateException if this duration is imprecise\n+     */\n+    void normalize();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of years of the duration.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setYears(int years);\n+\n+    /**\n+     * Adds the specified years to the number of years in the duration.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void addYears(int years);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of months of the duration.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setMonths(int months);\n+\n+    /**\n+     * Adds the specified months to the number of months in the duration.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void addMonths(int months);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of weeks of the duration.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setWeeks(int weeks);\n+\n+    /**\n+     * Adds the specified weeks to the number of weeks in the duration.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void addWeeks(int weeks);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of days of the duration.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setDays(int days);\n+\n+    /**\n+     * Adds the specified days to the number of days in the duration.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void addDays(int days);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of hours of the duration.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setHours(int hours);\n+\n+    /**\n+     * Adds the specified hours to the number of hours in the duration.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void addHours(int hours);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of minutes of the duration.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setMinutes(int minutes);\n+\n+    /**\n+     * Adds the specified minutes to the number of minutes in the duration.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void addMinutes(int minutes);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of seconds of the duration.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setSeconds(int seconds);\n+\n+    /**\n+     * Adds the specified seconds to the number of seconds in the duration.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void addSeconds(int seconds);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of millis of the duration.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setMillis(int millis);\n+\n+    /**\n+     * Adds the specified millis to the number of millis in the duration.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void addMillis(int millis);\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/ReadWritableInstant.java\n+++ b/JodaTime/src/java/org/joda/time/ReadWritableInstant.java\n  */\n package org.joda.time;\n \n+// Import for @link support\n+import org.joda.time.convert.ConverterManager;\n+\n /**\n- * Writable interface for an instant in the datetime continuum. \n+ * Defines an instant in the datetime continuum that can be queried and modified.\n+ * This interface expresses the datetime as milliseconds from 1970-01-01T00:00:00Z.\n  * <p>\n- * This interface expresses the datetime as milliseconds from \n- * 1970-01-01T00:00:00Z.\n+ * The implementation of this interface will be mutable.\n+ * It may provide more advanced methods than those in the interface.\n  *\n  * @author Stephen Colebourne\n  * @since 1.0\n     /**\n      * Set the value as the number of miliseconds since\n      * the epoch, 1970-01-01T00:00:00Z.\n-     *\n-     * @return the value as milliseconds\n-     */\n-    void setMillis(long millis);\n-\n-    /**\n-     * Set the value from Date, Calendar, DateTime etc.\n-     *\n-     * @return the value as a Calendar\n-     */\n-    void setMillis(Object obj);\n+     * \n+     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the\n+     * instant to\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setMillis(long instant);\n+\n+    /**\n+     * Set the value from an Object representing an instant.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * \n+     * @param instant  an object representing an instant\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setMillis(Object instant);\n+\n+    /**\n+     * Set the chronology of the datetime, which has no effect if not\n+     * applicable.\n+     * \n+     * @param chronology  the chronology to use, null means ISOChronology in default zone\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setChronology(Chronology chronology);\n+\n+    /**\n+     * Sets the time zone of the datetime via the chronology, which has no\n+     * effect if not applicable. Setting the time zone does not affect the\n+     * millisecond value of this instant.\n+     *\n+     * @param zone  the time zone to use, null means default zone\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @see #moveDateTimeZone\n+     */\n+    void setDateTimeZone(DateTimeZone zone);\n+\n+    /**\n+     * Moves the time zone of the datetime via the chronology, which has no\n+     * effect if not applicable. Moving the time zone alters the millisecond\n+     * value of this instant such that it is relative to the new time zone.\n+     *\n+     * @param zone  the time zone to use, null means default zone\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @see #setDateTimeZone\n+     */\n+    void moveDateTimeZone(DateTimeZone zone);\n \n     //-----------------------------------------------------------------------\n-    /**\n-     * Add an amount of time.\n-     * <p>\n-     * If the resulting value is too large for the implementation,\n-     * an exception is thrown.\n-     *\n-     * @param duration duration to add.\n-     */\n-    //void add(ReadableDuration duration);\n-\n-    /**\n-     * Add an amount of time.\n-     * <p>\n-     * If the resulting value is too large for the implementation,\n-     * an exception is thrown.\n-     *\n-     * @param duration duration to add.\n-     * @param scalar direction and amount to add, which may be negative\n-     */\n-    //void add(ReadableDuration duration, int scalar);\n-\n-    /**\n-     * Add an amount of time, either a ReadableDuration or Long (millis).\n-     * <p>\n-     * If the resulting value is too large for the implementation,\n-     * an exception is thrown.\n-     *\n-     * @param object  an object evaluating to an a period of time to\n-     *  add.\n-     */\n-    void add(Object object);\n-\n     /**\n      * Add a number of millis to the value.\n      * <p>\n      * will change and so on unless it is too large for the\n      * implementation, when an exception is thrown.\n      *\n-     * @param millis  the millis to add\n-     */\n-    void addMillis(long millis);\n+     * @param duration  the millis to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void add(long duration);\n+\n+    /**\n+     * Add an amount of time.\n+     * <p>\n+     * If the resulting value is too large for the implementation,\n+     * an exception is thrown.\n+     *\n+     * @param duration  duration to add.\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void add(ReadableDuration duration);\n+\n+    /**\n+     * Add an amount of time.\n+     * <p>\n+     * If the resulting value is too large for the implementation,\n+     * an exception is thrown.\n+     *\n+     * @param duration  duration to add.\n+     * @param scalar direction and amount to add, which may be negative\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void add(ReadableDuration duration, int scalar);\n+\n+    /**\n+     * Add an amount of time, either a ReadableDuration or Long (millis).\n+     * <p>\n+     * If the resulting value is too large for the implementation,\n+     * an exception is thrown.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableDuration, String and Long.\n+     *\n+     * @param duration  an object representing a duration\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void add(Object duration);\n \n     //-----------------------------------------------------------------------\n     /**\n      *\n      * @param field  a DateTimeField instance, usually obtained from a Chronology\n      * @param value  the value of that field for the millis set in the implementation\n+     * @throws IllegalArgumentException if the value is invalid\n      */\n     void set(DateTimeField field, int value);\n     \n      *\n      * @param field  a DateTimeField instance, usually obtained from a Chronology\n      * @param value  the value of that field for the millis set in the implementation\n+     * @throws IllegalArgumentException if the value is invalid\n      */\n     void add(DateTimeField field, int value);\n     \n      *\n      * @param field  a DateTimeField instance, usually obtained from a Chronology\n      * @param value  the value of that field for the millis set in the implementation\n+     * @throws IllegalArgumentException if the value is invalid\n      */\n     void addWrapped(DateTimeField field, int value);\n     \n--- a/JodaTime/src/java/org/joda/time/ReadableDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableDateTime.java\n import java.util.Locale;\n \n /**\n- * Extends the ReadableInstant interface to support specific datetime fields.\n+ * Defines an instant in time that can be queried using datetime fields.\n+ * <p>\n+ * The implementation of this interface may be mutable or immutable.\n+ * This interface only gives access to retrieve data, never to change it.\n+ * <p>\n+ * Methods in your application should be defined using <code>ReadableDateTime</code>\n+ * as a parameter if the method only wants to read the datetime, and not perform\n+ * any advanced manipulations.\n  *\n  * @author Stephen Colebourne\n  * @author Brian S O'Neill\n \n     /**\n      * Get this object as a DateTime.\n-     * \n-     * @return a DateTime using the same millis\n+     * <p>\n+     * If the implementation of the interface is a DateTime, it is returned directly.\n+     * \n+     * @return a DateTime using the same millis, unless partially specified\n      */\n     DateTime toDateTime();\n \n     /**\n      * Get this object as a DateTime.\n-     * \n-     * @param zone time zone to apply\n-     * @return a DateTime using the same millis\n+     * <p>\n+     * If the implementation of the interface is a DateTime in the correct zone,\n+     * it is returned directly.\n+     * \n+     * @param zone  time zone to apply\n+     * @return a DateTime using the same millis, unless partially specified\n      * @throws IllegalArgumentException if the time zone is null\n      */\n     DateTime toDateTime(DateTimeZone zone);\n \n     /**\n      * Get this object as a DateTime.\n+     * <p>\n+     * If the implementation of the interface is a DateTime in the correct chronology,\n+     * it is returned directly.\n+     * \n+     * @param chronology  chronology to apply\n+     * @return a DateTime using the same millis, unless partially specified\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    DateTime toDateTime(Chronology chronology);\n+\n+    /**\n+     * Get this object as a MutableDateTime, always returning a new instance.\n+     * \n+     * @return a MutableDateTime using the same millis, unless partially specified\n+     */\n+    MutableDateTime toMutableDateTime();\n+\n+    /**\n+     * Get this object as a MutableDateTime, always returning a new instance.\n+     * \n+     * @param zone  time zone to apply\n+     * @return a MutableDateTime using the same millis, unless partially specified\n+     * @throws IllegalArgumentException if the time zone is null\n+     */\n+    MutableDateTime toMutableDateTime(DateTimeZone zone);\n+\n+    /**\n+     * Get this object as a MutableDateTime, always returning a new instance.\n+     * \n+     * @param chronology  chronology to apply\n+     * @return a MutableDateTime using the same millis, unless partially specified\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    MutableDateTime toMutableDateTime(Chronology chronology);\n+\n+    /**\n+     * Get this object as a DateOnly.\n+     * \n+     * @return a DateOnly using the same millis, unless partially specified\n+     */\n+    DateOnly toDateOnly();\n+\n+    /**\n+     * Get this object as a DateOnly.\n      * \n      * @param chronology chronology to apply\n-     * @return a DateTime using the same millis\n+     * @return a DateOnly using the same millis, unless partially specified\n      * @throws IllegalArgumentException if the chronology is null\n      */\n-    DateTime toDateTime(Chronology chronology);\n-\n-    /**\n-     * Get this object as a MutableDateTime.\n-     * \n-     * @return a MutableDateTime using the same millis\n-     */\n-    MutableDateTime toMutableDateTime();\n-\n-    /**\n-     * Get this object as a MutableDateTime.\n-     * \n-     * @param zone time zone to apply\n-     * @return a MutableDateTime using the same millis\n-     * @throws IllegalArgumentException if the time zone is null\n-     */\n-    MutableDateTime toMutableDateTime(DateTimeZone zone);\n-\n-    /**\n-     * Get this object as a MutableDateTime.\n+    DateOnly toDateOnly(Chronology chronology);\n+\n+    /**\n+     * Get this object as a TimeOnly.\n+     * \n+     * @return a TimeOnly using the same millis, unless partially specified\n+     */\n+    TimeOnly toTimeOnly();\n+\n+    /**\n+     * Get this object as a TimeOnly.\n      * \n      * @param chronology chronology to apply\n-     * @return a MutableDateTime using the same millis\n+     * @return a TimeOnly using the same millis, unless partially specified\n      * @throws IllegalArgumentException if the chronology is null\n      */\n-    MutableDateTime toMutableDateTime(Chronology chronology);\n-\n-    /**\n-     * Get this object as a DateOnly.\n-     * \n-     * @return a DateOnly using the same millis\n-     */\n-    //DateOnly toDateOnly();\n-\n-    /**\n-     * Get this object as a DateOnly.\n-     * \n-     * @param chronology chronology to apply\n-     * @return a DateOnly using the same millis\n-     * @throws IllegalArgumentException if the chronology is null\n-     */\n-    //DateOnly toDateOnly(Chronology chronology);\n-\n-    /**\n-     * Get this object as a TimeOnly.\n-     * \n-     * @return a TimeOnly using the same millis\n-     */\n-    //TimeOnly toTimeOnly();\n-\n-    /**\n-     * Get this object as a TimeOnly.\n-     * \n-     * @param chronology chronology to apply\n-     * @return a TimeOnly using the same millis\n-     * @throws IllegalArgumentException if the chronology is null\n-     */\n-    //TimeOnly toTimeOnly(Chronology chronology);\n+    TimeOnly toTimeOnly(Chronology chronology);\n \n     /**\n      * Output the instant using the specified format pattern.\n      *\n-     * @param pattern pattern specification\n-     * @see org.joda.time.format.DateTimeFormatterBuilder#appendPattern(java.lang.String)\n+     * @param pattern  pattern specification\n+     * @throws IllegalArgumentException  if pattern is invalid\n+     * @see  org.joda.time.format.DateTimeFormat\n      */\n     String toString(String pattern) throws IllegalArgumentException;\n \n     /**\n      * Output the instant using the specified format pattern.\n      *\n-     * @param pattern pattern specification\n-     * @param locale Locale to use, must not be null\n-     * @see org.joda.time.format.DateTimeFormatterBuilder#appendPattern(java.lang.String)\n-     * @throws IllegalArgumentException if the locale is null\n+     * @param pattern  pattern specification\n+     * @param locale  Locale to use, or null for default\n+     * @throws IllegalArgumentException  if pattern is invalid\n+     * @see  org.joda.time.format.DateTimeFormat\n      */\n     String toString(String pattern, Locale locale) throws IllegalArgumentException;\n     \n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/ReadableDuration.java\n+/* \n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Defines a duration of time that can be queried using fields.\n+ * <p>\n+ * Durations can be split up into multiple fields, but implementations are not\n+ * required to evenly distribute the values across the fields. Nor are they\n+ * required to normalize the fields nor match the signs.\n+ * <p>\n+ * For example, an implementation can represent a duration of \"4 days, 6 hours\"\n+ * as \"102 hours\", \"1 day, 78 hours\", \"367200000 milliseconds\", or even\n+ * \"3 days, -8 hours, 2275 minutes, 298 seconds, 2000 milliseconds\".\n+ *\n+ * @see ReadableInterval\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface ReadableDuration extends Comparable {\n+\n+    /**\n+     * Returns the object which defines which fields this duration supports.\n+     */\n+    DurationType getDurationType();\n+\n+    /**\n+     * Gets the total length of this duration in milliseconds, \n+     * failing if the duration is imprecise.\n+     *\n+     * @return the total length of the time duration in milliseconds.\n+     * @throws IllegalStateException if the duration is imprecise\n+     */\n+    long getTotalMillis();\n+\n+    /**\n+     * Is this duration a precise length of time, or descriptive.\n+     * <p>\n+     * A precise duration could include millis, seconds, minutes or hours.\n+     * However, days, weeks, months and years can vary in length, resulting in\n+     * an imprecise duration.\n+     * <p>\n+     * An imprecise duration can be made precise by pairing it with a\n+     * date in a {@link ReadableInterval}.\n+     *\n+     * @return true if the duration is precise\n+     */\n+    boolean isPrecise();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds this duration to the given instant, returning a new value.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scaler of minus one.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n+     * duration to\n+     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @return milliseconds value plus this duration times scalar\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    long addTo(long instant, int scalar);\n+\n+    /**\n+     * Adds this duration to the given instant, returning a new value.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scaler of minus one.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n+     * duration to\n+     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @param chrono  override the duration's chronology, unless null is passed in\n+     * @return milliseconds value plus this duration times scalar\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    long addTo(long instant, int scalar, Chronology chrono);\n+\n+    /**\n+     * Adds this duration to the given instant, returning a new Instant.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scaler of minus one.\n+     *\n+     * @param instant  the instant to add the duration to\n+     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @return instant with the original value plus this duration times scalar\n+     * @throws IllegalArgumentException if the instant is null\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    ReadableInstant addTo(ReadableInstant instant, int scalar);\n+\n+    /**\n+     * Adds this duration into the given mutable instant.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scaler of minus one.\n+     *\n+     * @param instant  the instant to update with the added duration\n+     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @throws IllegalArgumentException if the instant is null\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    void addInto(ReadWritableInstant instant, int scalar);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the years field part of the duration.\n+     * \n+     * @return the number of years in the duration, zero if unsupported\n+     */\n+    int getYears();\n+\n+    /**\n+     * Gets the months field part of the duration.\n+     * \n+     * @return the number of months in the duration, zero if unsupported\n+     */\n+    int getMonths();\n+\n+    /**\n+     * Gets the weeks field part of the duration.\n+     * \n+     * @return the number of weeks in the duration, zero if unsupported\n+     */\n+    int getWeeks();\n+\n+    /**\n+     * Gets the days field part of the duration.\n+     * \n+     * @return the number of days in the duration, zero if unsupported\n+     */\n+    int getDays();\n+\n+    /**\n+     * Gets the hours field part of the duration.\n+     * \n+     * @return the number of hours in the duration, zero if unsupported\n+     */\n+    int getHours();\n+\n+    /**\n+     * Gets the minutes field part of the duration.\n+     * \n+     * @return the number of minutes in the duration, zero if unsupported\n+     */\n+    int getMinutes();\n+\n+    /**\n+     * Gets the seconds field part of the duration.\n+     * \n+     * @return the number of seconds in the duration, zero if unsupported\n+     */\n+    int getSeconds();\n+\n+    /**\n+     * Gets the millis field part of the duration.\n+     * \n+     * @return the number of millis in the duration, zero if unsupported\n+     */\n+    int getMillis();\n+\n+    /**\n+     * Get this object as an immutable Duration. This can be useful if you\n+     * don't trust the implementation of the interface to be well-behaved, or\n+     * to get a guaranteed immutable object.\n+     * \n+     * @return a Duration using the same field set and values\n+     */\n+    Duration toDuration();\n+\n+    /**\n+     * Get this object as a MutableDuration.\n+     * \n+     * @return a MutableDuration using the same field set and values\n+     */\n+    MutableDuration toMutableDuration();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this duration with the specified duration, which can only be\n+     * performed if both are precise.\n+     *\n+     * @param obj  a precise duration to check against\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the given object is not supported\n+     * @throws IllegalStateException if either duration is imprecise\n+     */\n+    int compareTo(Object obj);\n+\n+    /**\n+     * Is the length of this duration equal to the duration passed in.\n+     * Both durations must be precise.\n+     *\n+     * @param duration  another duration to compare to\n+     * @return true if this duration is equal to than the duration passed in\n+     * @throws IllegalArgumentException if the duration is null\n+     * @throws IllegalStateException if either duration is imprecise\n+     */\n+    boolean isEqual(ReadableDuration duration);\n+\n+    /**\n+     * Is the length of this duration longer than the duration passed in.\n+     * Both durations must be precise.\n+     *\n+     * @param duration  another duration to compare to\n+     * @return true if this duration is equal to than the duration passed in\n+     * @throws IllegalArgumentException if the duration is null\n+     * @throws IllegalStateException if either duration is imprecise\n+     */\n+    boolean isLongerThan(ReadableDuration duration);\n+\n+    /**\n+     * Is the length of this duration shorter than the duration passed in.\n+     * Both durations must be precise.\n+     *\n+     * @param duration  another duration to compare to\n+     * @return true if this duration is equal to than the duration passed in\n+     * @throws IllegalArgumentException if the duration is null\n+     * @throws IllegalStateException if either duration is imprecise\n+     */\n+    boolean isShorterThan(ReadableDuration duration);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the value of each field. All ReadableDuration instances are accepted.\n+     * <p>\n+     * To compare two durations for absolute duration (ie. millisecond duration\n+     * ignoring the fields), use {@link #isEqual(ReadableDuration)} or\n+     * {@link #compareTo(Object)}.\n+     *\n+     * @param readableDuration  a readable duration to check against\n+     * @return true if all the field values are equal, false if\n+     *  not or the duration is null or of an incorrect type\n+     */\n+    boolean equals(Object readableDuration);\n+\n+    /**\n+     * Gets a hash code for the duration that is compatable with the \n+     * equals method.\n+     *\n+     * @return a hash code\n+     */\n+    int hashCode();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"P6H3M5S\" represents 6 hours, 3 minutes, 5 seconds.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    String toString();\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/ReadableInstant.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableInstant.java\n package org.joda.time;\n \n /**\n- * Readable interface for an instant in the datetime continuum. \n+ * Defines an instant in the datetime continuum.\n+ * This interface expresses the datetime as milliseconds from 1970-01-01T00:00:00Z.\n  * <p>\n- * This interface expresses the datetime as milliseconds from \n- * 1970-01-01T00:00:00Z.\n+ * The implementation of this interface may be mutable or immutable.\n+ * This interface only gives access to retrieve data, never to change it.\n+ * <p>\n+ * Methods in your application should be defined using <code>ReadableInstant</code>\n+ * as a parameter if the method only wants to read the instant without needing to know\n+ * the specific datetime fields.\n  *\n  * @author Stephen Colebourne\n  * @since 1.0\n public interface ReadableInstant extends Comparable {\n \n     /**\n-     * Get the value as the number of miliseconds since\n+     * Get the value as the number of milliseconds since\n      * the epoch, 1970-01-01T00:00:00Z.\n      *\n      * @return the value as milliseconds\n      */\n     long getMillis();\n+\n+    /**\n+     * Get the value as the number of milliseconds since the epoch,\n+     * 1970-01-01T00:00:00Z, with unsupported field values filled in by the\n+     * given base instant.\n+     * <p>\n+     * This method is useful for ReadableInstants that only partially describe\n+     * the instant. The base supplies missing information, including time\n+     * zone. Instants that are complete simply return the same value as for\n+     * getMillis(), ignoring the given base.\n+     *\n+     * @param base optional source of missing fields\n+     * @return the value as milliseconds\n+     */\n+    long getMillis(ReadableInstant base);\n+\n+    /**\n+     * Get the value as the number of milliseconds since the epoch,\n+     * 1970-01-01T00:00:00Z, with unsupported field values filled in by the\n+     * given base instant.\n+     * <p>\n+     * This method is useful for ReadableInstants that only partially describe\n+     * the instant. The base supplies missing information, excluding time\n+     * zone. Instants that are complete simply return the same value as for\n+     * getMillis(), ignoring the given base.\n+     *\n+     * @param base source of missing fields\n+     * @param zone override the base time zone, null implies override with no\n+     * time zone\n+     * @return the value as milliseconds\n+     */\n+    long getMillis(ReadableInstant base, DateTimeZone zone);\n \n     /**\n      * Gets the chronology of the instant, null if not applicable.\n      * All ReadableInstant instances are accepted.\n      *\n      * @param readableInstant  a readable instant to check against\n-     * @return -1 if this is less, 0 if equal or +1 if greater\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n      * @throws NullPointerException if the object is null\n      * @throws ClassCastException if the object type is not supported\n      */\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/TimeOnly.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.chrono.iso.ISOChronology;\n+// Import for @link support\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/*\n+ * <p>Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getHourOfDay()</code>\n+ * <li><code>hourOfDay().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value\n+ * <li>text value\n+ * <li>short text value\n+ * <li>maximum value\n+ * <li>minimum value\n+ * </ul>\n+ */\n+\n+/**\n+ * TimeOnly is the basic implementation of a time only class supporting\n+ * chronologies. It holds the time as milliseconds from T00:00:00. The date\n+ * component and time zone is fixed at 1970-01-01TZ.\n+ * <p>\n+ * TimeOnly is thread-safe and immutable, provided that the Chronology is as\n+ * well. All standard Chronology classes supplied are thread-safe and\n+ * immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see DateOnly\n+ * @see DateTime\n+ */\n+public class TimeOnly extends AbstractPartialInstant implements Serializable {\n+\n+    static final long serialVersionUID = -8414446947366046476L;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a TimeOnly to the current time in the default time zone.\n+     */\n+    public TimeOnly() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a TimeOnly to the current time in the given time zone.\n+     *\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public TimeOnly(DateTimeZone zone) {\n+        super(zone);\n+    }\n+\n+    /**\n+     * Constructs a TimeOnly to the current time in the time zone of the given\n+     * chronology.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public TimeOnly(Chronology chronology) {\n+        super(chronology);\n+    }\n+\n+    /**\n+     * Constructs a TimeOnly set to the milliseconds from 1970-01-01T00:00:00Z.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public TimeOnly(long instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs a TimeOnly set to the milliseconds from\n+     * 1970-01-01T00:00:00Z. If the time zone of the given chronology is not\n+     * null or UTC, then the instant is converted to local time.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology\n+     */\n+    public TimeOnly(long instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a time.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public TimeOnly(Object instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a time, using the\n+     * specified chronology.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @param chronology  the chronology, must not be null\n+     * @throws IllegalArgumentException if the date or chronology is null\n+     */\n+    public TimeOnly(Object instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs an instance from time field values using\n+     * <code>ISOChronology</code>.\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the milisecond of the second\n+     */\n+    public TimeOnly(\n+            final int hourOfDay,\n+            final int minuteOfHour,\n+            final int secondOfMinute,\n+            final int millisOfSecond) {\n+\n+        super(ISOChronology.getInstanceUTC()\n+              .getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond),\n+              ISOChronology.getInstanceUTC());\n+    }\n+\n+    /**\n+     * Constructs an instance from time field values\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * is used.\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the milisecond of the second\n+     * @param chronology  the chronology, null means ISOChronology\n+     */\n+    public TimeOnly(\n+            final int hourOfDay,\n+            final int minuteOfHour,\n+            final int secondOfMinute,\n+            final int millisOfSecond,\n+            Chronology chronology) {\n+\n+        super((chronology == null ? (chronology = ISOChronology.getInstanceUTC()) : chronology)\n+              .getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond),\n+              chronology);\n+    }\n+\n+    /**\n+     * Returns the lower limiting field, null.\n+     *\n+     * @return null.\n+     */\n+    public final DateTimeField getLowerLimit() {\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the upper limiting field, dayOfYear.\n+     *\n+     * @return dayOfYear field\n+     */\n+    public final DateTimeField getUpperLimit() {\n+        return getChronology().dayOfYear();\n+    }\n+\n+    public final boolean isMatchingType(ReadableInstant instant) {\n+        return instant instanceof TimeOnly;\n+    }\n+\n+    // Time field access\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day field value.\n+     *\n+     * @return the hour of day\n+     */\n+    public final int getHourOfDay() {\n+        return getChronology().hourOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the minute of day field value.\n+     *\n+     * @return the minute of day\n+     */\n+    public final int getMinuteOfDay() {\n+        return getChronology().minuteOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the minute of hour field value.\n+     *\n+     * @return the minute of hour\n+     */\n+    public final int getMinuteOfHour() {\n+        return getChronology().minuteOfHour().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the second of day field value.\n+     *\n+     * @return the second of day\n+     */\n+    public final int getSecondOfDay() {\n+        return getChronology().secondOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the second of minute field value.\n+     *\n+     * @return the second of minute\n+     */\n+    public final int getSecondOfMinute() {\n+        return getChronology().secondOfMinute().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the millis of day field value.\n+     *\n+     * @return the millis of day\n+     */\n+    public final int getMillisOfDay() {\n+        return getChronology().millisOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the millis of second field value.\n+     *\n+     * @return the millis of second\n+     */\n+    public final int getMillisOfSecond() {\n+        return getChronology().millisOfSecond().get(getMillis());\n+    }\n+\n+    // TODO: DateTimeFieldProperty cannot be constructed with anything but\n+    // DateTime.\n+\n+    // Properties\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day field property\n+     * \n+     * @return the hour of day property\n+     * /\n+    public final DateTimeFieldProperty hourOfDay() {\n+        return new DateTimeFieldProperty(this, getChronology().hourOfDay());\n+    }\n+\n+    /**\n+     * Get the minute of day property\n+     * \n+     * @return the minute of day property\n+     * /\n+    public final DateTimeFieldProperty minuteOfDay() {\n+        return new DateTimeFieldProperty(this, getChronology().minuteOfDay());\n+    }\n+\n+    /**\n+     * Get the minute of hour field property\n+     * \n+     * @return the minute of hour property\n+     * /\n+    public final DateTimeFieldProperty minuteOfHour() {\n+        return new DateTimeFieldProperty(this, getChronology().minuteOfHour());\n+    }\n+\n+    /**\n+     * Get the second of day property\n+     * \n+     * @return the second of day property\n+     * /\n+    public final DateTimeFieldProperty secondOfDay() {\n+        return new DateTimeFieldProperty(this, getChronology().secondOfDay());\n+    }\n+\n+    /**\n+     * Get the second of minute field property\n+     * \n+     * @return the second of minute property\n+     * /\n+    public final DateTimeFieldProperty secondOfMinute() {\n+        return new DateTimeFieldProperty(this, getChronology().secondOfMinute());\n+    }\n+\n+    /**\n+     * Get the millis of day property\n+     * \n+     * @return the millis of day property\n+     * /\n+    public final DateTimeFieldProperty millisOfDay() {\n+        return new DateTimeFieldProperty(this, getChronology().millisOfDay());\n+    }\n+\n+    /**\n+     * Get the millis of second property\n+     * \n+     * @return the millis of second property\n+     * /\n+    public final DateTimeFieldProperty millisOfSecond() {\n+        return new DateTimeFieldProperty(this, getChronology().millisOfSecond());\n+    }\n+    */\n+\n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the time in ISO8601 date only format (hh:mm:ss.SSS).\n+     * \n+     * @return ISO8601 date formatted string\n+     */\n+    public final String toString() {\n+        return ISODateTimeFormat.getInstance(getChronology())\n+            .hourMinuteSecondFraction().print(getMillis());\n+    }\n+\n+    protected ReadableInstant create(long millis, Chronology chronology) {\n+        if (chronology == null) {\n+            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+        }\n+        if (millis == getMillis() && chronology == getChronology()) {\n+            return this;\n+        }\n+        return new TimeOnly(millis, chronology);\n+    }\n+    \n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void setMillis(long millis) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void setChronology(Chronology chronology) {\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * AbstractDateTimeField provides the common behaviour for DateTimeField\n+ * implementations. \n+ * <p>\n+ * This class should generally not be used directly by API users. The\n+ * DateTimeField interface should be used when different kinds of DateTimeField\n+ * objects are to be referenced.\n+ * <p>\n+ * AbstractDateTimeField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see DecoratedDateTimeField\n+ */\n+public abstract class AbstractDateTimeField implements DateTimeField, Serializable {\n+\n+    static final long serialVersionUID = -4388055220581798589L;\n+\n+    /** A desriptive name for the field */\n+    private final String iName;\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractDateTimeField(String name) {\n+        super();\n+        if (name == null) {\n+            throw new IllegalArgumentException(\"The name must not be null\");\n+        }\n+        iName = name;\n+    }\n+    \n+    public final String getName() {\n+        return iName;\n+    }\n+\n+    /**\n+     * @return true always\n+     */\n+    public final boolean isSupported() {\n+        return true;\n+    }\n+\n+    // Main access API\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get the value of this field from the milliseconds.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the value of the field, in the units of the field\n+     */\n+    public abstract int get(long instant);\n+\n+    /**\n+     * Get the human-readable, text value of this field from the milliseconds.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns Integer.toString(get(instant)).\n+     * <p>\n+     * Note: subclasses that override this method should also override\n+     * getMaximumTextLength.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @param locale the locale to use for selecting a text symbol, null for\n+     * default\n+     * @return the text value of the field\n+     */\n+    public String getAsText(long instant, Locale locale) {\n+        return Integer.toString(get(instant));\n+    }\n+\n+    /**\n+     * Get the human-readable, text value of this field from the milliseconds.\n+     * This implementation returns getAsText(instant, null).\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the text value of the field\n+     */\n+    public final String getAsText(long instant) {\n+        return getAsText(instant, null);\n+    }\n+\n+    /**\n+     * Get the human-readable, short text value of this field from the\n+     * milliseconds.  If the specified locale is null, the default locale is\n+     * used.\n+     * <p>\n+     * The default implementation returns getAsText(instant, locale).\n+     * <p>\n+     * Note: subclasses that override this method should also override\n+     * getMaximumShortTextLength.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @param locale the locale to use for selecting a text symbol, null for\n+     * default\n+     * @return the short text value of the field\n+     */\n+    public String getAsShortText(long instant, Locale locale) {\n+        return getAsText(instant, locale);\n+    }\n+\n+    /**\n+     * Get the human-readable, short text value of this field from the\n+     * milliseconds.  This implementation returns getAsShortText(instant, null).\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the short text value of the field\n+     */\n+    public final String getAsShortText(long instant) {\n+        return getAsShortText(instant, null);\n+    }\n+\n+    /**\n+     * Adds a value (which may be negative) to the instant value,\n+     * overflowing into larger fields if necessary.\n+     * <p>\n+     * The value will be added to this field. If the value is too large to be\n+     * added solely to this field, larger fields will increase as required.\n+     * Smaller fields should be unaffected, except where the result would be\n+     * an invalid value for a smaller field. In this case the smaller field is\n+     * adjusted to be in range.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 2000-08-20 add six months is 2001-02-20<br>\n+     * 2000-08-20 add twenty months is 2002-04-20<br>\n+     * 2000-08-20 add minus nine months is 1999-11-20<br>\n+     * 2001-01-31 add one month  is 2001-02-28<br>\n+     * 2001-01-31 add two months is 2001-03-31<br>\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the value to add, in the units of the field\n+     * @return the updated milliseconds\n+     */\n+    public long add(long instant, int value) {\n+        return getDurationField().add(instant, value);\n+    }\n+\n+    /**\n+     * Adds a value (which may be negative) to the instant value,\n+     * overflowing into larger fields if necessary.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the long value to add, in the units of the field\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if value is too large\n+     * @see #add(long,int)\n+     */\n+    public long add(long instant, long value) {\n+        return getDurationField().add(instant, value);\n+    }\n+\n+    /**\n+     * Adds a value (which may be negative) to the instant value,\n+     * wrapping within this field.\n+     * <p>\n+     * The value will be added to this field. If the value is too large to be\n+     * added solely to this field then it wraps. Larger fields are always\n+     * unaffected. Smaller fields should be unaffected, except where the\n+     * result would be an invalid value for a smaller field. In this case the\n+     * smaller field is adjusted to be in range.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 2000-08-20 addWrapped six months is 2000-02-20<br>\n+     * 2000-08-20 addWrapped twenty months is 2000-04-20<br>\n+     * 2000-08-20 addWrapped minus nine months is 2000-11-20<br>\n+     * 2001-01-31 addWrapped one month  is 2001-02-28<br>\n+     * 2001-01-31 addWrapped two months is 2001-03-31<br>\n+     * <p>\n+     * The default implementation internally calls set. Subclasses are\n+     * encouraged to provide a more efficient implementation.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the value to add, in the units of the field\n+     * @return the updated milliseconds\n+     */\n+    public long addWrapped(long instant, int value) {\n+        int current = get(instant);\n+        int wrapped = Utils.getWrappedValue\n+            (current, value, getMinimumValue(instant), getMaximumValue(instant));\n+        return set(instant, wrapped);\n+    }\n+\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * int v = ...\n+     * int age = getDifference(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getDurationField().getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * long v = ...\n+     * long age = getDifferenceAsLong(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    /**\n+     * Sets a value in the milliseconds supplied.\n+     * <p>\n+     * The value of this field will be set. If the value is invalid, an\n+     * exception if thrown. Other fields are always unaffected.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param value  the value to set, in the units of the field\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public abstract long set(long instant, int value);\n+\n+    /**\n+     * Sets a value in the milliseconds supplied from a human-readable, text\n+     * value. If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns set(instant,\n+     * Integer.parseInt(instant)).\n+     * <p>\n+     * Note: subclasses that override this method should also override\n+     * getAsText.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param text  the text value to set\n+     * @param locale the locale to use for selecting a text symbol, null for\n+     * default\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if the text value is invalid\n+     */\n+    public long set(long instant, String text, Locale locale) {\n+        try {\n+            return set(instant, Integer.parseInt(text));\n+        } catch (NumberFormatException ex) {\n+            throw new IllegalArgumentException(\"Invalid \" + getName() + \" text: \" + text);\n+        }\n+    }\n+\n+    /**\n+     * Sets a value in the milliseconds supplied from a human-readable, text\n+     * value. This implementation returns set(instant, text, null).\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param text  the text value to set\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if the text value is invalid\n+     */\n+    public final long set(long instant, String text) {\n+        return set(instant, text, null);\n+    }\n+\n+    // Extra information API\n+    //------------------------------------------------------------------------\n+    /**\n+     * Returns the duration per unit value of this field. For example, if this\n+     * field represents \"hour of day\", then the unit duration is an hour.\n+     *\n+     * @return the duration of this field, or UnsupportedDurationField if field\n+     * has no duration\n+     */\n+    public abstract DurationField getDurationField();\n+\n+    /**\n+     * Returns the range duration of this field. For example, if this field\n+     * represents \"hour of day\", then the range duration is a day.\n+     *\n+     * @return the range duration of this field, or null if field has no range\n+     */\n+    public abstract DurationField getRangeDurationField();\n+\n+    /**\n+     * Returns whether this field is 'leap' for the specified instant.\n+     * <p>\n+     * For example, a leap year would return true, a non leap year would return\n+     * false.\n+     * <p>\n+     * This implementation returns false.\n+     * \n+     * @return true if the field is 'leap'\n+     */\n+    public boolean isLeap(long instant) {\n+        return false;\n+    }\n+\n+    /**\n+     * Gets the amount by which this field is 'leap' for the specified instant.\n+     * <p>\n+     * For example, a leap year would return one, a non leap year would return\n+     * zero.\n+     * <p>\n+     * This implementation returns zero.\n+     */\n+    public int getLeapAmount(long instant) {\n+        return 0;\n+    }\n+\n+    /**\n+     * If this field were to leap, then it would be in units described by the\n+     * returned duration. If this field doesn't ever leap, null is returned.\n+     * <p>\n+     * This implementation returns null.\n+     */\n+    public DurationField getLeapDurationField() {\n+        return null;\n+    }\n+\n+    /**\n+     * Get the minimum allowable value for this field.\n+     * \n+     * @return the minimum valid value for this field, in the units of the\n+     * field\n+     */\n+    public abstract int getMinimumValue();\n+\n+    /**\n+     * Get the minimum value for this field evaluated at the specified time.\n+     * <p>\n+     * This implementation returns the same as {@link #getMinimumValue()}.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the minimum value for this field, in the units of the field\n+     */\n+    public int getMinimumValue(long instant) {\n+        return getMinimumValue();\n+    }\n+\n+    /**\n+     * Get the maximum allowable value for this field.\n+     * \n+     * @return the maximum valid value for this field, in the units of the\n+     * field\n+     */\n+    public abstract int getMaximumValue();\n+\n+    /**\n+     * Get the maximum value for this field evaluated at the specified time.\n+     * <p>\n+     * This implementation returns the same as {@link #getMaximumValue()}.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the maximum value for this field, in the units of the field\n+     */\n+    public int getMaximumValue(long instant) {\n+        return getMaximumValue();\n+    }\n+\n+    /**\n+     * Get the maximum text value for this field. The default implementation\n+     * returns the equivalent of Integer.toString(getMaximumValue()).length().\n+     * \n+     * @param locale  the locale to use for selecting a text symbol\n+     * @return the maximum text length\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        int max = getMaximumValue();\n+        if (max >= 0) {\n+            if (max < 10) {\n+                return 1;\n+            } else if (max < 100) {\n+                return 2;\n+            } else if (max < 1000) {\n+                return 3;\n+            }\n+        }\n+        return Integer.toString(max).length();\n+    }\n+\n+    /**\n+     * Get the maximum short text value for this field. The default\n+     * implementation returns getMaximumTextLength().\n+     * \n+     * @param locale  the locale to use for selecting a text symbol\n+     * @return the maximum short text length\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return getMaximumTextLength(locale);\n+    }\n+\n+    // Calculation API\n+    //------------------------------------------------------------------------\n+    /**\n+     * Round to the lowest whole unit of this field. After rounding, the value\n+     * of this field and all fields of a higher magnitude are retained. The\n+     * fractional millis that cannot be expressed in whole increments of this\n+     * field are set to minimum.\n+     * <p>\n+     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the\n+     * lowest whole hour is 2002-11-02T23:00:00.000.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public abstract long roundFloor(long instant);\n+\n+    /**\n+     * Round to the highest whole unit of this field. The value of this field\n+     * and all fields of a higher magnitude may be incremented in order to\n+     * achieve this result. The fractional millis that cannot be expressed in\n+     * whole increments of this field are set to minimum.\n+     * <p>\n+     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the\n+     * highest whole hour is 2002-11-03T00:00:00.000.\n+     * <p>\n+     * The default implementation calls roundFloor, and if the instant is\n+     * modified as a result, adds one field unit. Subclasses are encouraged to\n+     * provide a more efficient implementation.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public long roundCeiling(long instant) {\n+        long newInstant = roundFloor(instant);\n+        if (newInstant != instant) {\n+            instant = add(newInstant, 1);\n+        }\n+        return instant;\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field. If the given millisecond\n+     * value is closer to the floor or is exactly halfway, this function\n+     * behaves like roundFloor. If the millisecond value is closer to the\n+     * ceiling, this function behaves like roundCeiling.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public long roundHalfFloor(long instant) {\n+        long floor = roundFloor(instant);\n+        long ceiling = roundCeiling(instant);\n+\n+        long diffFromFloor = instant - floor;\n+        long diffToCeiling = ceiling - instant;\n+\n+        if (diffFromFloor <= diffToCeiling) {\n+            // Closer to the floor, or halfway - round floor\n+            return floor;\n+        } else {\n+            return ceiling;\n+        }\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field. If the given millisecond\n+     * value is closer to the floor, this function behaves like roundFloor. If\n+     * the millisecond value is closer to the ceiling or is exactly halfway,\n+     * this function behaves like roundCeiling.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public long roundHalfCeiling(long instant) {\n+        long floor = roundFloor(instant);\n+        long ceiling = roundCeiling(instant);\n+\n+        long diffFromFloor = instant - floor;\n+        long diffToCeiling = ceiling - instant;\n+\n+        if (diffToCeiling <= diffFromFloor) {\n+            // Closer to the ceiling, or halfway - round ceiling\n+            return ceiling;\n+        } else {\n+            return floor;\n+        }\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field. If the given millisecond\n+     * value is closer to the floor, this function behaves like roundFloor. If\n+     * the millisecond value is closer to the ceiling, this function behaves\n+     * like roundCeiling.\n+     * <p>\n+     * If the millisecond value is exactly halfway between the floor and\n+     * ceiling, the ceiling is chosen over the floor only if it makes this\n+     * field's value even.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public long roundHalfEven(long instant) {\n+        long floor = roundFloor(instant);\n+        long ceiling = roundCeiling(instant);\n+\n+        long diffFromFloor = instant - floor;\n+        long diffToCeiling = ceiling - instant;\n+\n+        if (diffFromFloor < diffToCeiling) {\n+            // Closer to the floor - round floor\n+            return floor;\n+        } else if (diffToCeiling < diffFromFloor) {\n+            // Closer to the ceiling - round ceiling\n+            return ceiling;\n+        } else {\n+            // Round to the instant that makes this field even. If both values\n+            // make this field even (unlikely), favor the ceiling.\n+            if ((get(ceiling) & 1) == 0) {\n+                return ceiling;\n+            }\n+            return floor;\n+        }\n+    }\n+\n+    /**\n+     * Returns the fractional duration milliseconds of this field. In other\n+     * words, calling remainder returns the duration that roundFloor would\n+     * subtract.\n+     * <p>\n+     * For example, on a datetime of 2002-11-02T23:34:56.789, the remainder by\n+     * hour is 34 minutes and 56.789 seconds.\n+     * <p>\n+     * The default implementation computes\n+     * <code>instant - roundFloor(instant)</code>. Subclasses are encouraged to\n+     * provide a more efficient implementation.\n+     *\n+     * @param instant the milliseconds from 1970-01-01T00:00:00Z to get the\n+     * remainder\n+     * @return remainder duration, in milliseconds\n+     */\n+    public long remainder(long instant) {\n+        return instant - roundFloor(instant);\n+    }\n+\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return \"DateTimeField[\" + getName() + ']';\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractDurationField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.io.Serializable;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * AbstractDurationField provides the common behaviour for DurationField\n+ * implementations.\n+ * <p>\n+ * This class should generally not be used directly by API users. The\n+ * DurationField interface should be used when different kinds of DurationField\n+ * objects are to be referenced.\n+ * <p>\n+ * AbstractDurationField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @see DecoratedDurationField\n+ */\n+public abstract class AbstractDurationField implements DurationField, Serializable {\n+\n+    static final long serialVersionUID = -2554245107589433218L;\n+\n+    /** A desriptive name for the field */\n+    private final String iName;\n+\n+    protected AbstractDurationField(String name) {\n+        super();\n+        if (name == null) {\n+            throw new IllegalArgumentException(\"The name must not be null\");\n+        }\n+        iName = name;\n+    }\n+\n+    public final String getName() {\n+        return iName;\n+    }\n+\n+    /**\n+     * @return true always\n+     */\n+    public final boolean isSupported() {\n+        return true;\n+    }\n+\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get the value of this field from the milliseconds, which is approximate\n+     * if this field is imprecise.\n+     *\n+     * @param duration  the milliseconds to query, which may be negative\n+     * @return the value of the field, in the units of the field, which may be\n+     * negative\n+     */\n+    public int getValue(long duration) {\n+        return Utils.safeToInt(getValueAsLong(duration));\n+    }\n+\n+    /**\n+     * Get the value of this field from the milliseconds, which is approximate\n+     * if this field is imprecise.\n+     *\n+     * @param duration  the milliseconds to query, which may be negative\n+     * @return the value of the field, in the units of the field, which may be\n+     * negative\n+     */\n+    public long getValueAsLong(long duration) {\n+        return duration / getUnitMillis();\n+    }\n+\n+    /**\n+     * Get the value of this field from the milliseconds relative to an\n+     * instant.\n+     *\n+     * <p>If the milliseconds is positive, then the instant is treated as a\n+     * \"start instant\". If negative, the instant is treated as an \"end\n+     * instant\".\n+     *\n+     * <p>The default implementation returns\n+     * <code>Utils.safeToInt(getAsLong(millisDuration, instant))</code>.\n+     * \n+     * @param duration  the milliseconds to query, which may be negative\n+     * @param instant  the start instant to calculate relative to\n+     * @return the value of the field, in the units of the field, which may be\n+     * negative\n+     */\n+    public int getValue(long duration, long instant) {\n+        return Utils.safeToInt(getValueAsLong(duration, instant));\n+    }\n+\n+    /**\n+     * Get the millisecond duration of this field from its value, which is\n+     * approximate if this field is imprecise.\n+     * \n+     * @param value  the value of the field, which may be negative\n+     * @return the milliseconds that the field represents, which may be\n+     * negative\n+     */\n+    public long getMillis(int value) {\n+        return value * getUnitMillis();\n+    }\n+\n+    /**\n+     * Get the millisecond duration of this field from its value, which is\n+     * approximate if this field is imprecise.\n+     * \n+     * @param value  the value of the field, which may be negative\n+     * @return the milliseconds that the field represents, which may be\n+     * negative\n+     */\n+    public long getMillis(long value) {\n+        return value * getUnitMillis();\n+    }\n+\n+    // Calculation API\n+    //------------------------------------------------------------------------\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return Utils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));\n+    }\n+\n+    //------------------------------------------------------------------------\n+    public int compareTo(Object durationField) {\n+        DurationField otherField = (DurationField) durationField;\n+        long otherMillis = otherField.getUnitMillis();\n+        long thisMillis = getUnitMillis();\n+        // cannot do (thisMillis - otherMillis) as can overflow\n+        if (thisMillis == otherMillis) {\n+            return 0;\n+        }\n+        if (thisMillis < otherMillis) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return \"DurationField[\" + getName() + ']';\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/DecoratedChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * <code>DecoratedChronology</code> extends {@link Chronology}, implementing\n+ * only the minimum required set of methods. These implemented methods delegate\n+ * to a wrapped field. The withUTC, withDateTimeZone, and toString methods are\n+ * exceptions, and are left abstract.\n+ * <p>\n+ * This design allows new Chronology types to be defined that piggyback on top\n+ * of another, inheriting all the safe method implementations from\n+ * Chronology. Should any method require pure delegation to the wrapped field,\n+ * simply override and use the provided getWrappedChronology method.\n+ * <p>\n+ * DecoratedChronology is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see DelegatedChronology\n+ */\n+public abstract class DecoratedChronology extends Chronology {\n+\n+    static final long serialVersionUID = 7094038875466049631L;\n+\n+    /** The Chronology being wrapped */\n+    private final Chronology iChronology;\n+    \n+    /**\n+     * Create a DecoratedChronology for any chronology.\n+     *\n+     * @param chrono the chronology\n+     * @throws IllegalArgumentException if chronology is null\n+     */\n+    protected DecoratedChronology(Chronology chrono) {\n+        if (chrono == null) {\n+            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+        }\n+        iChronology = chrono;\n+    }\n+    \n+    /**\n+     * Gets the wrapped chronology.\n+     * \n+     * @return the wrapped Chronology\n+     */\n+    protected Chronology getWrappedChronology() {\n+        return iChronology;\n+    }\n+\n+    /**\n+     * Get the Chronology in the UTC time zone.\n+     * \n+     * @return Chronology in UTC\n+     */\n+    public abstract Chronology withUTC();\n+\n+    /**\n+     * Get the Chronology in the any time zone.\n+     * \n+     * @return Chronology in ant time zone\n+     */\n+    public abstract Chronology withDateTimeZone(DateTimeZone zone);\n+\n+    /**\n+     * Gets the time zone that this chronology is using.\n+     * \n+     * @return the DateTimeZone\n+     */\n+    public DateTimeZone getDateTimeZone() {\n+        return iChronology.getDateTimeZone();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/DecoratedDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * <code>DecoratedDateTimeField</code> extends {@link AbstractDateTimeField},\n+ * implementing only the minimum required set of methods. These implemented\n+ * methods delegate to a wrapped field.\n+ * <p>\n+ * This design allows new DateTimeField types to be defined that piggyback on\n+ * top of another, inheriting all the safe method implementations from\n+ * AbstractDateTimeField. Should any method require pure delegation to the\n+ * wrapped field, simply override and use the provided getWrappedField method.\n+ * <p>\n+ * DecoratedDateTimeField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see DelegatedDateTimeField\n+ */\n+public class DecoratedDateTimeField extends AbstractDateTimeField {\n+\n+    static final long serialVersionUID = 203115783733757597L;\n+\n+    /** The DateTimeField being wrapped */\n+    private final DateTimeField iField;\n+\n+    /**\n+     * @param name allow name to be overridden\n+     */\n+    public DecoratedDateTimeField(DateTimeField field, String name) {\n+        super(name);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (!field.isSupported()) {\n+            throw new IllegalArgumentException(\"The field must be supported\");\n+        }\n+        iField = field;\n+    }\n+\n+    /**\n+     * Gets the wrapped date time field.\n+     * \n+     * @return the wrapped DateTimeField\n+     */\n+    public final DateTimeField getWrappedField() {\n+        return iField;\n+    }\n+\n+    public boolean isLenient() {\n+        return iField.isLenient();\n+    }\n+\n+    public int get(long instant) {\n+        return iField.get(instant);\n+    }\n+\n+    public long set(long instant, int value) {\n+        return iField.set(instant, value);\n+    }\n+\n+    public DurationField getDurationField() {\n+        return iField.getDurationField();\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iField.getRangeDurationField();\n+    }\n+\n+    public int getMinimumValue() {\n+        return iField.getMinimumValue();\n+    }\n+\n+    public int getMaximumValue() {\n+        return iField.getMaximumValue();\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return iField.roundFloor(instant);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/DecoratedDurationField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DurationField;\n+\n+/**\n+ * <code>DecoratedDurationField</code> extends {@link AbstractDurationField},\n+ * implementing only the minimum required set of methods. These implemented\n+ * methods delegate to a wrapped field.\n+ * <p>\n+ * This design allows new DurationField types to be defined that piggyback on\n+ * top of another, inheriting all the safe method implementations from\n+ * AbstractDurationField. Should any method require pure delegation to the\n+ * wrapped field, simply override and use the provided getWrappedField method.\n+ * <p>\n+ * DecoratedDurationField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @see DelegatedDurationField\n+ */\n+public class DecoratedDurationField extends AbstractDurationField {\n+\n+    static final long serialVersionUID = 8019982251647420015L;\n+\n+    /** The DurationField being wrapped */\n+    private final DurationField iField;\n+\n+    /**\n+     * @param name allow name to be overridden\n+     */\n+    public DecoratedDurationField(DurationField field, String name) {\n+        super(name);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (!field.isSupported()) {\n+            throw new IllegalArgumentException(\"The field must be supported\");\n+        }\n+        iField = field;\n+    }\n+\n+    /**\n+     * Gets the wrapped duration field.\n+     * \n+     * @return the wrapped DurationField\n+     */\n+    public final DurationField getWrappedField() {\n+        return iField;\n+    }\n+\n+    public boolean isPrecise() {\n+        return iField.isPrecise();\n+    }\n+\n+    public long getValueAsLong(long duration, long instant) {\n+        return iField.getValueAsLong(duration, instant);\n+    }\n+\n+    public long getMillis(int value, long instant) {\n+        return iField.getMillis(value, instant);\n+    }\n+\n+    public long getMillis(long value, long instant) {\n+        return iField.getMillis(value, instant);\n+    }\n+\n+    public long add(long instant, int value) {\n+        return iField.add(instant, value);\n+    }\n+\n+    public long add(long instant, long value) {\n+        return iField.add(instant, value);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long getUnitMillis() {\n+        return iField.getUnitMillis();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/DelegatedChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * <code>DelegatedChronology</code> delegates each method call to the\n+ * chronology it wraps.\n+ * <p>\n+ * DelegatedChronology is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see DecoratedChronology\n+ */\n+public abstract class DelegatedChronology extends Chronology {\n+    \n+    static final long serialVersionUID = 216867504527676612L;\n+\n+    /** The Chronology being wrapped */\n+    private final Chronology iChronology;\n+    \n+    /**\n+     * Create a DelegatedChronology for any chronology.\n+     *\n+     * @param chrono the chronology\n+     * @throws IllegalArgumentException if chronology is null\n+     */\n+    protected DelegatedChronology(Chronology chrono) {\n+        if (chrono == null) {\n+            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+        }\n+        iChronology = chrono;\n+    }\n+    \n+    /**\n+     * Gets the wrapped chronology.\n+     * \n+     * @return the wrapped Chronology\n+     */\n+    protected Chronology getWrappedChronology() {\n+        return iChronology;\n+    }\n+\n+    /**\n+     * Get the Chronology in the UTC time zone.\n+     * \n+     * @return Chronology in UTC\n+     */\n+    public abstract Chronology withUTC();\n+\n+    /**\n+     * Get the Chronology in the any time zone.\n+     * \n+     * @return Chronology in ant time zone\n+     */\n+    public abstract Chronology withDateTimeZone(DateTimeZone zone);\n+\n+    /**\n+     * Gets the time zone that this chronolog is using.\n+     * \n+     * @return the DateTimeZone\n+     */\n+    public DateTimeZone getDateTimeZone() {\n+        return iChronology.getDateTimeZone();\n+    }\n+\n+    public long getDateOnlyMillis(long instant) {\n+        return iChronology.getDateOnlyMillis(instant);\n+    }\n+\n+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException\n+    {\n+        return iChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);\n+    }\n+\n+    public long getTimeOnlyMillis(long instant) {\n+        return iChronology.getTimeOnlyMillis(instant);\n+    }\n+\n+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return iChronology.getTimeOnlyMillis\n+            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    public long getDateTimeMillis(long instant,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return iChronology.getDateTimeMillis\n+            (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        return iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return iChronology.getDateTimeMillis\n+            (year, monthOfYear, dayOfMonth,\n+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    // Millis\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the millis duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField millis() {\n+        return iChronology.millis();\n+    }\n+\n+    /**\n+     * Get the millis of second field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField millisOfSecond() {\n+        return iChronology.millisOfSecond();\n+    }\n+\n+    /**\n+     * Get the millis of day field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField millisOfDay() {\n+        return iChronology.millisOfDay();\n+    }\n+\n+    // Seconds\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the seconds duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField seconds() {\n+        return iChronology.seconds();\n+    }\n+\n+    /**\n+     * Get the second of minute field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField secondOfMinute() {\n+        return iChronology.secondOfMinute();\n+    }\n+\n+    /**\n+     * Get the second of day field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField secondOfDay() {\n+        return iChronology.secondOfDay();\n+    }\n+\n+    // Minutes\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the minutes duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField minutes() {\n+        return iChronology.minutes();\n+    }\n+\n+    /**\n+     * Get the minute of hour field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField minuteOfHour() {\n+        return iChronology.minuteOfHour();\n+    }\n+\n+    /**\n+     * Get the minute of day field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField minuteOfDay() {\n+        return iChronology.minuteOfDay();\n+    }\n+\n+    // Hours\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the hours duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField hours() {\n+        return iChronology.hours();\n+    }\n+\n+    /**\n+     * Get the hour of day (0-23) field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField hourOfDay() {\n+        return iChronology.hourOfDay();\n+    }\n+\n+    /**\n+     * Get the hour of day (offset to 1-24) field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField clockhourOfDay() {\n+        return iChronology.clockhourOfDay();\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (0-11) field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField hourOfHalfday() {\n+        return iChronology.hourOfHalfday();\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (offset to 1-12) field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField clockhourOfHalfday() {\n+        return iChronology.clockhourOfHalfday();\n+    }\n+\n+    /**\n+     * Get the AM(0) PM(1) field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField halfdayOfDay() {\n+        return iChronology.halfdayOfDay();\n+    }\n+\n+    // Day\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the days duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField days() {\n+        return iChronology.days();\n+    }\n+\n+    /**\n+     * Get the day of week field for this chronology.\n+     *\n+     * @return DateTimeField\n+     */\n+    public DateTimeField dayOfWeek() {\n+        return iChronology.dayOfWeek();\n+    }\n+\n+    /**\n+     * Get the day of month field for this chronology.\n+     *\n+     * @return DateTimeField\n+     */\n+    public DateTimeField dayOfMonth() {\n+        return iChronology.dayOfMonth();\n+    }\n+\n+    /**\n+     * Get the day of year field for this chronology.\n+     *\n+     * @return DateTimeField\n+     */\n+    public DateTimeField dayOfYear() {\n+        return iChronology.dayOfYear();\n+    }\n+\n+    // Week\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the weeks duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField weeks() {\n+        return iChronology.weeks();\n+    }\n+\n+    /**\n+     * Get the week of a week based year field for this chronology.\n+     *\n+     * @return DateTimeField\n+     */\n+    public DateTimeField weekOfWeekyear() {\n+        return iChronology.weekOfWeekyear();\n+    }\n+\n+    /**\n+     * Get the weekyears duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField weekyears() {\n+        return iChronology.weekyears();\n+    }\n+\n+    /**\n+     * Get the year of a week based year field for this chronology.\n+     *\n+     * @return DateTimeField\n+     */\n+    public DateTimeField weekyear() {\n+        return iChronology.weekyear();\n+    }\n+\n+    // Month\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the months duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField months() {\n+        return iChronology.months();\n+    }\n+\n+    /**\n+     * Get the month of year field for this chronology.\n+     *\n+     * @return DateTimeField\n+     */\n+    public DateTimeField monthOfYear() {\n+        return iChronology.monthOfYear();\n+    }\n+\n+    // Year\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the years duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField years() {\n+        return iChronology.years();\n+    }\n+\n+    /**\n+     * Get the year field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField year() {\n+        return iChronology.year();\n+    }\n+\n+    /**\n+     * Get the year of era field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField yearOfEra() {\n+        return iChronology.yearOfEra();\n+    }\n+\n+    /**\n+     * Get the year field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField yearOfCentury() {\n+        return iChronology.yearOfCentury();\n+    }\n+\n+    /**\n+     * Get the centuries duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField centuries() {\n+        return iChronology.centuries();\n+    }\n+\n+    /**\n+     * Get the century of era field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField centuryOfEra() {\n+        return iChronology.centuryOfEra();\n+    }\n+\n+    /**\n+     * Get the eras duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField eras() {\n+        return iChronology.eras();\n+    }\n+\n+    /**\n+     * Get the era field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField era() {\n+        return iChronology.era();\n+    }\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/DelegatedDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * <code>DelegatedDateTimeField</code> delegates each method call to the\n+ * date time field it wraps.\n+ * <p>\n+ * DelegatedDateTimeField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see DecoratedDateTimeField\n+ */\n+public class DelegatedDateTimeField implements DateTimeField, Serializable {\n+\n+    static final long serialVersionUID = -4730164440214502503L;\n+\n+    /** The DateTimeField being wrapped */\n+    private final DateTimeField iField;\n+    /** A desriptive name for the field */\n+    private final String iName;\n+\n+    protected DelegatedDateTimeField(DateTimeField field) {\n+        this(field, null);\n+    }\n+\n+    protected DelegatedDateTimeField(DateTimeField field, String name) {\n+        super();\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        iField = field;\n+        iName = name;\n+    }\n+\n+    /**\n+     * Gets the wrapped date time field.\n+     * \n+     * @return the wrapped DateTimeField\n+     */\n+    public final DateTimeField getWrappedField() {\n+        return iField;\n+    }\n+\n+    public String getName() {\n+        return (iName == null) ? iField.getName() : iName;\n+    }\n+\n+    public boolean isSupported() {\n+        return iField.isSupported();\n+    }\n+\n+    public boolean isLenient() {\n+        return iField.isLenient();\n+    }\n+\n+    public int get(long instant) {\n+        return iField.get(instant);\n+    }\n+\n+    public String getAsText(long instant, Locale locale) {\n+        return iField.getAsText(instant, locale);\n+    }\n+\n+    public String getAsText(long instant) {\n+        return iField.getAsText(instant);\n+    }\n+\n+    public String getAsShortText(long instant, Locale locale) {\n+        return iField.getAsShortText(instant, locale);\n+    }\n+\n+    public String getAsShortText(long instant) {\n+        return iField.getAsShortText(instant);\n+    }\n+\n+    public long add(long instant, int value) {\n+        return iField.add(instant, value);\n+    }\n+\n+    public long add(long instant, long value) {\n+        return iField.add(instant, value);\n+    }\n+\n+    public long addWrapped(long instant, int value) {\n+        return iField.addWrapped(instant, value);\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return iField.getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long set(long instant, int value) {\n+        return iField.set(instant, value);\n+    }\n+\n+    public long set(long instant, String text, Locale locale) {\n+        return iField.set(instant, text, locale);\n+    }\n+\n+    public long set(long instant, String text) {\n+        return iField.set(instant, text);\n+    }\n+\n+    public DurationField getDurationField() {\n+        return iField.getDurationField();\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iField.getRangeDurationField();\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return iField.isLeap(instant);\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        return iField.getLeapAmount(instant);\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return iField.getLeapDurationField();\n+    }\n+\n+    public int getMinimumValue() {\n+        return iField.getMinimumValue();\n+    }\n+\n+    public int getMinimumValue(long instant) {\n+        return iField.getMinimumValue(instant);\n+    }\n+\n+    public int getMaximumValue() {\n+        return iField.getMaximumValue();\n+    }\n+\n+    public int getMaximumValue(long instant) {\n+        return iField.getMaximumValue(instant);\n+    }\n+\n+    public int getMaximumTextLength(Locale locale) {\n+        return iField.getMaximumTextLength(locale);\n+    }\n+\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return iField.getMaximumShortTextLength(locale);\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return iField.roundFloor(instant);\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        return iField.roundCeiling(instant);\n+    }\n+\n+    public long roundHalfFloor(long instant) {\n+        return iField.roundHalfFloor(instant);\n+    }\n+\n+    public long roundHalfCeiling(long instant) {\n+        return iField.roundHalfCeiling(instant);\n+    }\n+\n+    public long roundHalfEven(long instant) {\n+        return iField.roundHalfEven(instant);\n+    }\n+\n+    public long remainder(long instant) {\n+        return iField.remainder(instant);\n+    }\n+\n+    public String toString() {\n+        return (iName == null) ? iField.toString() :\n+            (\"DateTimeField[\" + iName + ']');\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/DelegatedDurationField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.chrono;\n+\n+import java.io.Serializable;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * <code>DelegatedDurationField</code> delegates each method call to the\n+ * duration field it wraps.\n+ * <p>\n+ * DelegatedDurationField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @see DecoratedDurationField\n+ */\n+public class DelegatedDurationField implements DurationField, Serializable {\n+\n+    static final long serialVersionUID = -5576443481242007829L;\n+\n+    /** The DurationField being wrapped */\n+    private final DurationField iField;\n+    /** A desriptive name for the field */\n+    private final String iName;\n+\n+    protected DelegatedDurationField(DurationField field) {\n+        this(field, null);\n+    }\n+\n+    /**\n+     * @param name allow name to be overridden\n+     */\n+    protected DelegatedDurationField(DurationField field, String name) {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        iField = field;\n+        iName = name;\n+    }\n+\n+    /**\n+     * Gets the wrapped duration field.\n+     * \n+     * @return the wrapped DurationField\n+     */\n+    public final DurationField getWrappedField() {\n+        return iField;\n+    }\n+\n+    public String getName() {\n+        return (iName == null) ? iField.getName() : iName;\n+    }\n+\n+    /**\n+     * Returns true if this field is supported.\n+     */\n+    public boolean isSupported() {\n+        return iField.isSupported();\n+    }\n+\n+    public boolean isPrecise() {\n+        return iField.isPrecise();\n+    }\n+    \n+    public int getValue(long duration) {\n+        return iField.getValue(duration);\n+    }\n+\n+    public long getValueAsLong(long duration) {\n+        return iField.getValueAsLong(duration);\n+    }\n+\n+    public int getValue(long duration, long instant) {\n+        return iField.getValue(duration, instant);\n+    }\n+\n+    public long getValueAsLong(long duration, long instant) {\n+        return iField.getValueAsLong(duration, instant);\n+    }\n+\n+    public long getMillis(int value) {\n+        return iField.getMillis(value);\n+    }\n+\n+    public long getMillis(long value) {\n+        return iField.getMillis(value);\n+    }\n+\n+    public long getMillis(int value, long instant) {\n+        return iField.getMillis(value, instant);\n+    }\n+\n+    public long getMillis(long value, long instant) {\n+        return iField.getMillis(value, instant);\n+    }\n+\n+    public long add(long instant, int value) {\n+        return iField.add(instant, value);\n+    }\n+\n+    public long add(long instant, long value) {\n+        return iField.add(instant, value);\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return iField.getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long getUnitMillis() {\n+        return iField.getUnitMillis();\n+    }\n+\n+    public int compareTo(Object durationField) {\n+        return iField.compareTo(durationField);\n+    }\n+\n+    public String toString() {\n+        return (iName == null) ? iField.toString() :\n+            (\"DurationField[\" + iName + ']');\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/chrono/DividedDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/DividedDateTimeField.java\n package org.joda.time.chrono;\n \n import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n \n /**\n- * Generic division datetime field.\n+ * Divides a DateTimeField such that the retrieved values are reduced by a\n+ * fixed divisor. The field's unit duration is scaled accordingly, but the\n+ * range duration is unchanged.\n+ * <p>\n+ * DividedDateTimeField is thread-safe and immutable.\n  *\n  * @see RemainderDateTimeField\n  * \n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public class DividedDateTimeField extends DateTimeField {\n-\n-    /** The field to divide */\n-    private final DateTimeField iField;\n-    /** The amount to divide by in the correct units */\n-    private final int iUnitDivisor;\n+public class DividedDateTimeField extends DecoratedDateTimeField {\n+\n+    static final long serialVersionUID = 8318475124230605365L;\n+\n+    // Shared with RemainderDateTimeField.\n+    final int iDivisor;\n+    final DurationField iDurationField;\n \n     private final int iMin;\n     private final int iMax;\n \n     /**\n-     * Constructor\n-     * \n+     * Constructor.\n+     * \n+     * @param field  the field to wrap, like \"year()\".\n      * @param name  short, descriptive name, like \"century\".\n-     * @param field  the field to wrap, like \"year()\".\n-     * @param unitDivisor  divisor in units, such as 100 years in a century\n-     * @throws IllegalArgumentException if unit is less than two\n-     */\n-    public DividedDateTimeField(String name, DateTimeField field, int unitDivisor) {\n-        super(name);\n+     * @param durationName  short, descriptive name, like \"centuries\".\n+     * @param divisor  divisor, such as 100 years in a century\n+     * @throws IllegalArgumentException if divisor is less than two\n+     */\n+    public DividedDateTimeField(DateTimeField field,\n+                                String name, String durationName, int divisor) {\n+        super(field, name);\n                 \n-        if (field == null) {\n-            throw new IllegalArgumentException(\"The field must not be null\");\n-        }\n-        if (unitDivisor < 2) {\n-            throw new IllegalArgumentException(\"The unit divisor must be at least 2\");\n-        }\n-        iField = field;\n-        iUnitDivisor = unitDivisor;\n-\n-        int i = iField.getMinimumValue();\n-        int min = (i >= 0) ? i / unitDivisor : ((i + 1) / unitDivisor - 1);\n-\n-        int j = iField.getMaximumValue();\n-        int max = (j >= 0) ? j / unitDivisor : ((j + 1) / unitDivisor - 1);\n+        if (divisor < 2) {\n+            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n+        }\n+\n+        DurationField unitField = field.getDurationField();\n+        if (unitField == null) {\n+            iDurationField = null;\n+        } else {\n+            iDurationField = new ScaledDurationField(unitField, durationName, divisor);\n+        }\n+\n+        iDivisor = divisor;\n+\n+        int i = field.getMinimumValue();\n+        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);\n+\n+        int j = field.getMaximumValue();\n+        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);\n \n         iMin = min;\n         iMax = max;\n     }\n \n     /**\n-     * Get the amount of divided units from the specified time instant.\n-     * \n-     * @param millis  the time instant in millis to query.\n-     * @return the amount of divided units extracted from the input.\n-     */\n-    public int get(long millis) {\n-        int value = iField.get(millis);\n+     * Construct a DividedDateTimeField that compliments the given\n+     * RemainderDateTimeField.\n+     *\n+     * @param remainderField  complimentary remainder field, like \"yearOfCentury()\".\n+     * @param name  short, descriptive name, like \"century\".\n+     */\n+    public DividedDateTimeField(RemainderDateTimeField remainderField, String name) {\n+        super(remainderField.getWrappedField(), name);\n+        int divisor = iDivisor = remainderField.iDivisor;\n+        iDurationField = remainderField.iRangeField;\n+\n+        DateTimeField field = getWrappedField();\n+        int i = field.getMinimumValue();\n+        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);\n+\n+        int j = field.getMaximumValue();\n+        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);\n+\n+        iMin = min;\n+        iMax = max;\n+    }\n+\n+    /**\n+     * Get the amount of scaled units from the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to query.\n+     * @return the amount of scaled units extracted from the input.\n+     */\n+    public int get(long instant) {\n+        int value = getWrappedField().get(instant);\n         if (value >= 0) {\n-            return value / iUnitDivisor;\n+            return value / iDivisor;\n         } else {\n-            return ((value + 1) / iUnitDivisor) - 1;\n-        }\n-    }\n-\n-    /**\n-     * Add the specified amount of divided units to the specified time\n+            return ((value + 1) / iDivisor) - 1;\n+        }\n+    }\n+\n+    /**\n+     * Add the specified amount of scaled units to the specified time\n      * instant. The amount added may be negative.\n      * \n-     * @param millis  the time instant in millis to update.\n-     * @param amount  the amount of divided units to add (can be negative).\n-     * @return the updated time instant.\n-     */\n-    public long add(long millis, int amount) {\n-        return iField.add(millis, amount * iUnitDivisor);\n-    }\n-\n-    /**\n-     * Add the specified amount of divided units to the specified time\n+     * @param instant  the time instant in millis to update.\n+     * @param amount  the amount of scaled units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, int amount) {\n+        return getWrappedField().add(instant, amount * iDivisor);\n+    }\n+\n+    /**\n+     * Add the specified amount of scaled units to the specified time\n      * instant. The amount added may be negative.\n      * \n-     * @param millis  the time instant in millis to update.\n-     * @param amount  the amount of divided units to add (can be negative).\n-     * @return the updated time instant.\n-     */\n-    public long add(long millis, long amount) {\n-        return iField.add(millis, amount * iUnitDivisor);\n-    }\n-\n-    /**\n-     * Add to the divided component of the specified time instant,\n+     * @param instant  the time instant in millis to update.\n+     * @param amount  the amount of scaled units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, long amount) {\n+        return getWrappedField().add(instant, amount * iDivisor);\n+    }\n+\n+    /**\n+     * Add to the scaled component of the specified time instant,\n      * wrapping around within that component if necessary.\n      * \n-     * @param millis  the time instant in millis to update.\n-     * @param amount  the amount of divided units to add (can be negative).\n-     * @return the updated time instant.\n-     */\n-    public long addWrapped(long millis, int amount) {\n-        return set(millis, getWrappedValue(get(millis), amount, iMin, iMax));\n-    }\n-\n-    public long getDifference(long minuendMillis, long subtrahendMillis) {\n-        return iField.getDifference(minuendMillis, subtrahendMillis) / iUnitDivisor;\n-    }\n-\n-    /**\n-     * Set the specified amount of divided units to the specified time instant.\n-     * \n-     * @param millis  the time instant in millis to update.\n-     * @param value  value of divided units to set.\n+     * @param instant  the time instant in millis to update.\n+     * @param amount  the amount of scaled units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long instant, int amount) {\n+        return set(instant, Utils.getWrappedValue(get(instant), amount, iMin, iMax));\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant) / iDivisor;\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant) / iDivisor;\n+    }\n+\n+    /**\n+     * Set the specified amount of scaled units to the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param value  value of scaled units to set.\n      * @return the updated time instant.\n      * @throws IllegalArgumentException if value is too large or too small.\n      */\n-    public long set(long millis, int value) {\n-        verifyValueBounds(value, iMin, iMax);\n-        int remainder = getRemainder(iField.get(millis));\n-        return iField.set(millis, value * iUnitDivisor + remainder);\n-    }\n-\n-    /**\n-     * Returns the wrapped field's unit size multiplied by the unit divisor.\n-     */\n-    public long getUnitMillis() {\n-        return iField.getUnitMillis() * iUnitDivisor;\n-    }\n-\n-    /**\n-     * Returns the wrapped field's range.\n-     */\n-    public long getRangeMillis() {\n-        return iField.getRangeMillis();\n+    public long set(long instant, int value) {\n+        Utils.verifyValueBounds(this, value, iMin, iMax);\n+        int remainder = getRemainder(getWrappedField().get(instant));\n+        return getWrappedField().set(instant, value * iDivisor + remainder);\n+    }\n+\n+    /**\n+     * Returns a scaled version of the wrapped field's unit duration field.\n+     */\n+    public DurationField getDurationField() {\n+        return iDurationField;\n     }\n \n     /**\n     public int getMaximumValue() {\n         return iMax;\n     }\n-    \n-    public long roundFloor(long millis) {\n-        return iField.roundFloor(iField.set(millis, get(millis) * iUnitDivisor));\n-    }\n-\n-    public long remainder(long millis) {\n-        return set(millis, get(iField.remainder(millis)));\n-    }\n-\n-    /**\n-     * Returns the DateTimeField being wrapped.\n-     * \n-     * @return field\n-     */\n-    public DateTimeField getField() {\n-        return iField;\n-    }\n-\n-    /**\n-     * Returns the divisor to apply to the field in the field's units.\n+\n+    public long roundFloor(long instant) {\n+        DateTimeField field = getWrappedField();\n+        return field.roundFloor(field.set(instant, get(instant) * iDivisor));\n+    }\n+\n+    public long remainder(long instant) {\n+        return set(instant, get(getWrappedField().remainder(instant)));\n+    }\n+\n+    /**\n+     * Returns the divisor applied, in the field's units.\n      * \n      * @return the divisor\n      */\n-    public int getUnitDivisor() {\n-        return iUnitDivisor;\n+    public int getDivisor() {\n+        return iDivisor;\n     }\n \n     private int getRemainder(int value) {\n         if (value >= 0) {\n-            return value % iUnitDivisor;\n+            return value % iDivisor;\n         } else {\n-            return (iUnitDivisor - 1) + ((value + 1) % iUnitDivisor);\n+            return (iDivisor - 1) + ((value + 1) % iDivisor);\n         }\n     }\n \n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/ImpreciseDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Abstract datetime field class that defines its own DurationField, which\n+ * delegates back into this ImpreciseDateTimeField.\n+ * <p>\n+ * This DateTimeField is useful for defining DateTimeFields that are composed\n+ * of imprecise durations. If both duration fields are precise, then a\n+ * {@link PreciseDateTimeField} should be used instead.\n+ * <p>\n+ * When defining imprecise DateTimeFields where a matching DurationField is\n+ * already available, just extend AbstractDateTimeField directly so as not to\n+ * create redundant DurationField instances.\n+ * <p>\n+ * ImpreciseDateTimeField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @see PreciseDateTimeField\n+ */\n+public abstract class ImpreciseDateTimeField extends AbstractDateTimeField {\n+\n+    static final long serialVersionUID = 7190739608550251860L;\n+\n+    final long iUnitMillis;\n+    private final DurationField iDurationField;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param name  short, descriptive name, like \"monthOfYear\".\n+     * @param durationName  short, descriptive name, like \"months\".\n+     * @param unitMillis  the average duration unit milliseconds\n+     */\n+    public ImpreciseDateTimeField(String name, String durationName, long unitMillis) {\n+        super(name);\n+        iUnitMillis = unitMillis;\n+        iDurationField = new LinkedDurationField(durationName);\n+    }\n+\n+    public abstract int get(long instant);\n+\n+    public abstract long set(long instant, int value);\n+\n+    public abstract long add(long instant, int value);\n+\n+    public abstract long add(long instant, long value);\n+\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * int v = ...\n+     * int age = getDifference(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     * <p>\n+     * The default implementation call getDifferenceAsLong and converts the\n+     * return value to an int.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return Utils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));\n+    }\n+\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * long v = ...\n+     * long age = getDifferenceAsLong(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     * <p>\n+     * The default implementation performs a guess-and-check algorithm using\n+     * getDurationField().getUnitMillis() and the add() method. Subclasses are\n+     * encouraged to provide a more efficient implementation.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        if (minuendInstant < subtrahendInstant) {\n+            return -getDifferenceAsLong(subtrahendInstant, minuendInstant);\n+        }\n+        \n+        long difference = (minuendInstant - subtrahendInstant) / iUnitMillis;\n+        if (add(subtrahendInstant, difference) < minuendInstant) {\n+            do {\n+                difference++;\n+            } while (add(subtrahendInstant, difference) <= minuendInstant);\n+            difference--;\n+        } else if (add(subtrahendInstant, difference) > minuendInstant) {\n+            do {\n+                difference--;\n+            } while (add(subtrahendInstant, difference) > minuendInstant);\n+        }\n+        return difference;\n+    }\n+\n+    public final DurationField getDurationField() {\n+        return iDurationField;\n+    }\n+\n+    public abstract DurationField getRangeDurationField();\n+\n+    public abstract long roundFloor(long instant);\n+\n+    protected final long getDurationUnitMillis() {\n+        return iUnitMillis;\n+    }\n+\n+    private final class LinkedDurationField extends AbstractDurationField {\n+        static final long serialVersionUID = -203813474600094134L;\n+\n+        LinkedDurationField(String name) {\n+            super(name);\n+        }\n+    \n+        public boolean isPrecise() {\n+            return false;\n+        }\n+    \n+        public long getUnitMillis() {\n+            return iUnitMillis;\n+        }\n+\n+        public int getValue(long duration, long instant) {\n+            return ImpreciseDateTimeField.this\n+                .getDifference(instant + duration, instant);\n+        }\n+\n+        public long getValueAsLong(long duration, long instant) {\n+            return ImpreciseDateTimeField.this\n+                .getDifferenceAsLong(instant + duration, instant);\n+        }\n+        \n+        public long getMillis(int value, long instant) {\n+            return ImpreciseDateTimeField.this.add(instant, value) - instant;\n+        }\n+\n+        public long getMillis(long value, long instant) {\n+            return ImpreciseDateTimeField.this.add(instant, value) - instant;\n+        }\n+\n+        public long add(long instant, int value) {\n+            return ImpreciseDateTimeField.this.add(instant, value);\n+        }\n+        \n+        public long add(long instant, long value) {\n+            return ImpreciseDateTimeField.this.add(instant, value);\n+        }\n+        \n+        public int getDifference(long minuendInstant, long subtrahendInstant) {\n+            return ImpreciseDateTimeField.this\n+                .getDifference(minuendInstant, subtrahendInstant);\n+        }\n+        \n+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+            return ImpreciseDateTimeField.this\n+                .getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * Wraps another chronology, ensuring all the fields are lenient.\n+ * <p>\n+ * LenientChronology is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @see LenientDateTimeField\n+ * @see StrictChronology\n+ */\n+public class LenientChronology extends DelegatedChronology {\n+\n+    static final long serialVersionUID = -3148237568046877177L;\n+\n+    private transient DateTimeField iYearField;\n+    private transient DateTimeField iYearOfEraField;\n+    private transient DateTimeField iYearOfCenturyField;\n+    private transient DateTimeField iCenturyOfEraField;\n+    private transient DateTimeField iEraField;\n+    private transient DateTimeField iDayOfWeekField;\n+    private transient DateTimeField iDayOfMonthField;\n+    private transient DateTimeField iDayOfYearField;\n+    private transient DateTimeField iMonthOfYearField;\n+    private transient DateTimeField iWeekOfWeekyearField;\n+    private transient DateTimeField iWeekyearField;\n+\n+    private transient DateTimeField iMillisOfSecondField;\n+    private transient DateTimeField iMillisOfDayField;\n+    private transient DateTimeField iSecondOfMinuteField;\n+    private transient DateTimeField iSecondOfDayField;\n+    private transient DateTimeField iMinuteOfHourField;\n+    private transient DateTimeField iMinuteOfDayField;\n+    private transient DateTimeField iHourOfDayField;\n+    private transient DateTimeField iHourOfHalfdayField;\n+    private transient DateTimeField iClockhourOfDayField;\n+    private transient DateTimeField iClockhourOfHalfdayField;\n+    private transient DateTimeField iHalfdayOfDayField;\n+\n+    private transient Chronology iWithUTC;\n+\n+    /**\n+     * Create a LenientChronology for any chronology.\n+     *\n+     * @param chrono the chronology\n+     * @throws IllegalArgumentException if chronology is null\n+     */\n+    public LenientChronology(Chronology chrono) {\n+        super(chrono);\n+    }\n+\n+    public Chronology withUTC() {\n+        if (iWithUTC == null) {\n+            iWithUTC = new LenientChronology(getWrappedChronology().withUTC());\n+        }\n+        return iWithUTC;\n+    }\n+\n+    public Chronology withDateTimeZone(DateTimeZone zone) {\n+        return new LenientChronology(getWrappedChronology().withDateTimeZone(zone));\n+    }\n+\n+    /**\n+     * Overridden to ensure lenient fields are used.\n+     */\n+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException\n+    {\n+        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n+    }\n+\n+    /**\n+     * Overridden to ensure lenient fields are used.\n+     */\n+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        long instant = hourOfDay().set(0, hourOfDay);\n+        instant = minuteOfHour().set(instant, minuteOfHour);\n+        instant = secondOfMinute().set(instant, secondOfMinute);\n+        return millisOfSecond().set(instant, millisOfSecond);\n+    }\n+\n+    /**\n+     * Overridden to ensure lenient fields are used.\n+     */\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        long instant = year().set(0, year);\n+        instant = monthOfYear().set(instant, monthOfYear);\n+        instant = dayOfMonth().set(instant, dayOfMonth);\n+        return millisOfDay().set(instant, millisOfDay);\n+    }\n+\n+    /**\n+     * Overridden to ensure lenient fields are used.\n+     */\n+    public long getDateTimeMillis(long instant,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        instant = hourOfDay().set(instant, hourOfDay);\n+        instant = minuteOfHour().set(instant, minuteOfHour);\n+        instant = secondOfMinute().set(instant, secondOfMinute);\n+        return millisOfSecond().set(instant, millisOfSecond);\n+    }\n+\n+    /**\n+     * Overridden to ensure lenient fields are used.\n+     */\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        long instant = year().set(0, year);\n+        instant = monthOfYear().set(instant, monthOfYear);\n+        instant = dayOfMonth().set(instant, dayOfMonth);\n+        instant = hourOfDay().set(instant, hourOfDay);\n+        instant = minuteOfHour().set(instant, minuteOfHour);\n+        instant = secondOfMinute().set(instant, secondOfMinute);\n+        return millisOfSecond().set(instant, millisOfSecond);\n+    }\n+\n+    // Milliseconds\n+    //------------------------------------------------------------\n+\n+    public DateTimeField millisOfSecond() {\n+        if (iMillisOfDayField == null) {\n+            iMillisOfSecondField = LenientDateTimeField.getInstance(super.millisOfSecond());\n+        }\n+        return iMillisOfSecondField;\n+    }\n+\n+    public DateTimeField millisOfDay() {\n+        if (iMillisOfDayField == null) {\n+            iMillisOfDayField = LenientDateTimeField.getInstance(super.millisOfDay());\n+        }\n+        return iMillisOfDayField;\n+    }\n+\n+    // Seconds\n+    //------------------------------------------------------------\n+\n+    public DateTimeField secondOfMinute() {\n+        if (iSecondOfMinuteField == null) {\n+            iSecondOfMinuteField = LenientDateTimeField.getInstance(super.secondOfMinute());\n+        }\n+        return iSecondOfMinuteField;\n+    }\n+\n+    public DateTimeField secondOfDay() {\n+        if (iSecondOfDayField == null) {\n+            iSecondOfDayField = LenientDateTimeField.getInstance(super.secondOfDay());\n+        }\n+        return iSecondOfDayField;\n+    }\n+\n+    // Minutes\n+    //------------------------------------------------------------\n+\n+    public DateTimeField minuteOfHour() {\n+        if (iMinuteOfHourField == null) {\n+            iMinuteOfHourField = LenientDateTimeField.getInstance(super.minuteOfHour());\n+        }\n+        return iMinuteOfHourField;\n+    }\n+\n+    public DateTimeField minuteOfDay() {\n+        if (iMinuteOfDayField == null) {\n+            iMinuteOfDayField = LenientDateTimeField.getInstance(super.minuteOfDay());\n+        }\n+        return iMinuteOfDayField;\n+    }\n+\n+    // Hours\n+    //------------------------------------------------------------\n+\n+    public DateTimeField hourOfDay() {\n+        if (iHourOfDayField == null) {\n+            iHourOfDayField = LenientDateTimeField.getInstance(super.hourOfDay());\n+        }\n+        return iHourOfDayField;\n+    }\n+\n+    public DateTimeField clockhourOfDay() {\n+        if (iClockhourOfDayField == null) {\n+            iClockhourOfDayField = LenientDateTimeField.getInstance(super.clockhourOfDay());\n+        }\n+        return iClockhourOfDayField;\n+    }\n+\n+    public DateTimeField hourOfHalfday() {\n+        if (iHourOfHalfdayField == null) {\n+            iHourOfHalfdayField = LenientDateTimeField.getInstance(super.hourOfHalfday());\n+        }\n+        return iHourOfHalfdayField;\n+    }\n+\n+    public DateTimeField clockhourOfHalfday() {\n+        if (iClockhourOfHalfdayField == null) {\n+            iClockhourOfHalfdayField =\n+                LenientDateTimeField.getInstance(super.clockhourOfHalfday());\n+        }\n+        return iClockhourOfHalfdayField;\n+    }\n+\n+    public DateTimeField halfdayOfDay() {\n+        if (iHalfdayOfDayField == null) {\n+            iHalfdayOfDayField = LenientDateTimeField.getInstance(super.halfdayOfDay());\n+        }\n+        return iHalfdayOfDayField;\n+    }\n+\n+    // Day\n+    //------------------------------------------------------------\n+\n+    public DateTimeField dayOfWeek() {\n+        if (iDayOfWeekField == null) {\n+            iDayOfWeekField = LenientDateTimeField.getInstance(super.dayOfWeek());\n+        }\n+        return iDayOfWeekField;\n+    }\n+\n+    public DateTimeField dayOfMonth() {\n+        if (iDayOfMonthField == null) {\n+            iDayOfMonthField = LenientDateTimeField.getInstance(super.dayOfMonth());\n+        }\n+        return iDayOfMonthField;\n+    }\n+\n+    public DateTimeField dayOfYear() {\n+        if (iDayOfYearField == null) {\n+            iDayOfYearField = LenientDateTimeField.getInstance(super.dayOfYear());\n+        }\n+        return iDayOfYearField;\n+    }\n+\n+    // Week\n+    //------------------------------------------------------------\n+\n+    public DateTimeField weekOfWeekyear() {\n+        if (iWeekOfWeekyearField == null) {\n+            iWeekOfWeekyearField = LenientDateTimeField.getInstance(super.weekOfWeekyear());\n+        }\n+        return iWeekOfWeekyearField;\n+    }\n+\n+    public DateTimeField weekyear() {\n+        if (iWeekyearField == null) {\n+            iWeekyearField = LenientDateTimeField.getInstance(super.weekyear());\n+        }\n+        return iWeekyearField;\n+    }\n+\n+    // Month\n+    //------------------------------------------------------------\n+\n+    public DateTimeField monthOfYear() {\n+        if (iMonthOfYearField == null) {\n+            iMonthOfYearField = LenientDateTimeField.getInstance(super.monthOfYear());\n+        }\n+        return iMonthOfYearField;\n+    }\n+\n+    // Year\n+    //------------------------------------------------------------\n+\n+    public DateTimeField year() {\n+        if (iYearField == null) {\n+            iYearField = LenientDateTimeField.getInstance(super.year());\n+        }\n+        return iYearField;\n+    }\n+\n+    public DateTimeField yearOfEra() {\n+        if (iYearOfEraField == null) {\n+            iYearOfEraField = LenientDateTimeField.getInstance(super.yearOfEra());\n+        }\n+        return iYearOfEraField;\n+    }\n+\n+    public DateTimeField yearOfCentury() {\n+        if (iYearOfCenturyField == null) {\n+            iYearOfCenturyField = LenientDateTimeField.getInstance(super.yearOfCentury());\n+        }\n+        return iYearOfCenturyField;\n+    }\n+\n+    public DateTimeField centuryOfEra() {\n+        if (iCenturyOfEraField == null) {\n+            iCenturyOfEraField = LenientDateTimeField.getInstance(super.centuryOfEra());\n+        }\n+        return iCenturyOfEraField;\n+    }\n+\n+    public DateTimeField era() {\n+        if (iEraField == null) {\n+            iEraField = LenientDateTimeField.getInstance(super.era());\n+        }\n+        return iEraField;\n+    }\n+\n+    public String toString() {\n+        return \"LenientChronology[\" + getWrappedChronology().toString() + ']';\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/LenientDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Converts a strict DateTimeField into a lenient one. By being lenient, the\n+ * set method accepts out of bounds values, performing an addition instead.\n+ * <p>\n+ * LenientDateTimeField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @see StrictDateTimeField\n+ */\n+public class LenientDateTimeField extends DelegatedDateTimeField {\n+\n+    static final long serialVersionUID = 8714085824173290599L;\n+\n+    /**\n+     * Returns a lenient version of the given field. If it is already lenient,\n+     * then it is returned as-is. Otherwise, a new LenientDateTimeField is\n+     * returned.\n+     */\n+    public static DateTimeField getInstance(DateTimeField field) {\n+        if (field == null) {\n+            return null;\n+        }\n+        if (field instanceof StrictDateTimeField) {\n+            field = ((StrictDateTimeField)field).getWrappedField();\n+        }\n+        if (field.isLenient()) {\n+            return field;\n+        }\n+        return new LenientDateTimeField(field);\n+    }\n+\n+    protected LenientDateTimeField(DateTimeField field) {\n+        super(field);\n+    }\n+\n+    public final boolean isLenient() {\n+        return true;\n+    }\n+\n+    /**\n+     * Set values which may be out of bounds. If the value is out of bounds,\n+     * the instant is first set to the minimum allowed value, and then the\n+     * difference is added.\n+     */\n+    public long set(long instant, int value) {\n+        int min = getMinimumValue(instant);\n+        if (value >= min && value < getMaximumValue(instant)) {\n+            return super.set(instant, value);\n+        }\n+        return add(super.set(instant, min), value - min);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.Serializable;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadableDateTime;\n+import org.joda.time.format.DateTimePrinter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * Imposes limits on the range of instants that the fields within a Chronology\n+ * may support. The limits are applied to both DateTimeFields and\n+ * DurationFields.\n+ * <p>\n+ * Methods in DateTimeField and DurationField throw an IllegalArgumentException\n+ * whenever given an input instant that is outside the limits or when an\n+ * attempt is made to move an instant outside the limits.\n+ * <p>\n+ * LimitChronology is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public class LimitChronology extends Chronology {\n+\n+    static final long serialVersionUID = 7670866536893052522L;\n+\n+    private final Chronology iChronology;\n+\n+    final DateTime iLowerLimit;\n+    final DateTime iUpperLimit;\n+\n+    private transient LimitChronology iWithUTC;\n+\n+    private transient DurationField iErasField;\n+    private transient DurationField iCenturiesField;\n+    private transient DurationField iYearsField;\n+    private transient DurationField iMonthsField;\n+    private transient DurationField iWeekyearsField;\n+    private transient DurationField iWeeksField;\n+    private transient DurationField iDaysField;\n+\n+    private transient DurationField iHoursField;\n+    private transient DurationField iMinutesField;\n+    private transient DurationField iSecondsField;\n+    private transient DurationField iMillisField;\n+\n+    private transient DateTimeField iYearField;\n+    private transient DateTimeField iYearOfEraField;\n+    private transient DateTimeField iYearOfCenturyField;\n+    private transient DateTimeField iCenturyOfEraField;\n+    private transient DateTimeField iEraField;\n+    private transient DateTimeField iDayOfWeekField;\n+    private transient DateTimeField iDayOfMonthField;\n+    private transient DateTimeField iDayOfYearField;\n+    private transient DateTimeField iMonthOfYearField;\n+    private transient DateTimeField iWeekOfWeekyearField;\n+    private transient DateTimeField iWeekyearField;\n+\n+    private transient DateTimeField iMillisOfSecondField;\n+    private transient DateTimeField iMillisOfDayField;\n+    private transient DateTimeField iSecondOfMinuteField;\n+    private transient DateTimeField iSecondOfDayField;\n+    private transient DateTimeField iMinuteOfHourField;\n+    private transient DateTimeField iMinuteOfDayField;\n+    private transient DateTimeField iHourOfDayField;\n+    private transient DateTimeField iHourOfHalfdayField;\n+    private transient DateTimeField iClockhourOfDayField;\n+    private transient DateTimeField iClockhourOfHalfdayField;\n+    private transient DateTimeField iHalfdayOfDayField;\n+\n+    /**\n+     * Wraps another chronology, with datetime limits. When withUTC or\n+     * withDateTimeZone is called, the returned LimitChronology instance has\n+     * the same limits, except they are time zone adjusted.\n+     *\n+     * @param lowerLimit  inclusive lower limit, or null if none\n+     * @param upperLimit  exclusive upper limit, or null if none\n+     * @throws IllegalArgumentException if chronology is null or limits are invalid\n+     */\n+    public LimitChronology(Chronology chrono,\n+                           ReadableDateTime lowerLimit, ReadableDateTime upperLimit) {\n+        if (chrono == null) {\n+            throw new IllegalArgumentException(\"Must supply a chronology\");\n+        }\n+\n+        iChronology = chrono;\n+\n+        iLowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime();\n+        iUpperLimit = upperLimit == null ? null : upperLimit.toDateTime();\n+\n+        if (iLowerLimit != null && iUpperLimit != null) {\n+            if (!iLowerLimit.isBefore(iUpperLimit)) {\n+                throw new IllegalArgumentException\n+                    (\"The lower limit must be come before than the upper limit\");\n+            }\n+        }\n+\n+        setFields();\n+    }\n+\n+    private void setFields() {\n+        Chronology c = iChronology;\n+\n+        // Keep a local cache of converted fields so as not to create redundant\n+        // objects.\n+        HashMap converted = new HashMap();\n+\n+        // Convert duration fields...\n+\n+        iErasField = convertField(c.eras(), converted);\n+        iCenturiesField = convertField(c.centuries(), converted);\n+        iYearsField = convertField(c.years(), converted);\n+        iMonthsField = convertField(c.months(), converted);\n+        iWeekyearsField = convertField(c.weekyears(), converted);\n+        iWeeksField = convertField(c.weeks(), converted);\n+        iDaysField = convertField(c.days(), converted);\n+\n+        iHoursField = convertField(c.hours(), converted);\n+        iMinutesField = convertField(c.minutes(), converted);\n+        iSecondsField = convertField(c.seconds(), converted);\n+        iMillisField = convertField(c.millis(), converted);\n+\n+        // Convert datetime fields...\n+\n+        iYearField = convertField(c.year(), converted);\n+        iYearOfEraField = convertField(c.yearOfEra(), converted);\n+        iYearOfCenturyField = convertField(c.yearOfCentury(), converted);\n+        iCenturyOfEraField = convertField(c.centuryOfEra(), converted);\n+        iEraField = convertField(c.era(), converted);\n+        iDayOfWeekField = convertField(c.dayOfWeek(), converted);\n+        iDayOfMonthField = convertField(c.dayOfMonth(), converted);\n+        iDayOfYearField = convertField(c.dayOfYear(), converted);\n+        iMonthOfYearField = convertField(c.monthOfYear(), converted);\n+        iWeekOfWeekyearField = convertField(c.weekOfWeekyear(), converted);\n+        iWeekyearField = convertField(c.weekyear(), converted);\n+\n+        iMillisOfSecondField = convertField(c.millisOfSecond(), converted);\n+        iMillisOfDayField = convertField(c.millisOfDay(), converted);\n+        iSecondOfMinuteField = convertField(c.secondOfMinute(), converted);\n+        iSecondOfDayField = convertField(c.secondOfDay(), converted);\n+        iMinuteOfHourField = convertField(c.minuteOfHour(), converted);\n+        iMinuteOfDayField = convertField(c.minuteOfDay(), converted);\n+        iHourOfDayField = convertField(c.hourOfDay(), converted);\n+        iHourOfHalfdayField = convertField(c.hourOfHalfday(), converted);\n+        iClockhourOfDayField = convertField(c.clockhourOfDay(), converted);\n+        iClockhourOfHalfdayField = convertField(c.clockhourOfHalfday(), converted);\n+        iHalfdayOfDayField = convertField(c.halfdayOfDay(), converted);\n+    }\n+\n+    private DurationField convertField(DurationField field, HashMap converted) {\n+        if (field == null || !field.isSupported()) {\n+            return field;\n+        }\n+        if (converted.containsKey(field)) {\n+            return (DurationField)converted.get(field);\n+        }\n+        LimitDurationField limitField = new LimitDurationField(field);\n+        converted.put(field, limitField);\n+        return limitField;\n+    }\n+\n+    private DateTimeField convertField(DateTimeField field, HashMap converted) {\n+        if (field == null || !field.isSupported()) {\n+            return field;\n+        }\n+        if (converted.containsKey(field)) {\n+            return (DateTimeField)converted.get(field);\n+        }\n+        LimitDateTimeField limitField =\n+            new LimitDateTimeField(field,\n+                                   convertField(field.getDurationField(), converted),\n+                                   convertField(field.getRangeDurationField(), converted),\n+                                   convertField(field.getLeapDurationField(), converted));\n+        converted.put(field, limitField);\n+        return limitField;\n+    }\n+\n+    /**\n+     * Returns the inclusive lower limit instant.\n+     * \n+     * @return lower limit\n+     */\n+    public DateTime getLowerLimit() {\n+        return iLowerLimit;\n+    }\n+\n+    /**\n+     * Returns the inclusive upper limit instant.\n+     * \n+     * @return upper limit\n+     */\n+    public DateTime getUpperBound() {\n+        return iUpperLimit;\n+    }\n+\n+    /**\n+     * Gets the wrapped chronology.\n+     * \n+     * @return the wrapped Chronology\n+     */\n+    protected Chronology getWrappedChronology() {\n+        return iChronology;\n+    }\n+\n+    /**\n+     * If this LimitChronology is already UTC, then this is\n+     * returned. Otherwise, a new instance is returned, with the limits\n+     * adjusted to the new time zone.\n+     */\n+    public Chronology withUTC() {\n+        return withDateTimeZone(DateTimeZone.UTC);\n+    }\n+\n+    /**\n+     * If this LimitChronology has the same time zone as the one given, then\n+     * this is returned. Otherwise, a new instance is returned, with the limits\n+     * adjusted to the new time zone.\n+     */\n+    public Chronology withDateTimeZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getDateTimeZone()) {\n+            return this;\n+        }\n+\n+        if (zone == DateTimeZone.UTC && iWithUTC != null) {\n+            return iWithUTC;\n+        }\n+\n+        DateTime lowerLimit = iLowerLimit;\n+        if (lowerLimit != null) {\n+            MutableDateTime mdt = lowerLimit.toMutableDateTime();\n+            mdt.moveDateTimeZone(zone);\n+            lowerLimit = mdt.toDateTime();\n+        }\n+\n+        DateTime upperLimit = iUpperLimit;\n+        if (upperLimit != null) {\n+            MutableDateTime mdt = upperLimit.toMutableDateTime();\n+            mdt.moveDateTimeZone(zone);\n+            upperLimit = mdt.toDateTime();\n+        }\n+        \n+        LimitChronology chrono = new LimitChronology\n+            (iChronology.withDateTimeZone(zone), lowerLimit, upperLimit);\n+\n+        if (zone == DateTimeZone.UTC) {\n+            iWithUTC = chrono;\n+        }\n+\n+        return chrono;\n+    }\n+\n+    public DateTimeZone getDateTimeZone() {\n+        return iChronology.getDateTimeZone();\n+    }\n+\n+    public long getDateOnlyMillis(long instant) {\n+        checkLimits(instant, null);\n+        instant = iChronology.getDateOnlyMillis(instant);\n+        checkLimits(instant, \"resulting\");\n+        return instant;\n+    }\n+\n+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException\n+    {\n+        long instant = iChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);\n+        checkLimits(instant, \"resulting\");\n+        return instant;\n+    }\n+\n+    public long getTimeOnlyMillis(long instant) {\n+        checkLimits(instant, null);\n+        instant = iChronology.getTimeOnlyMillis(instant);\n+        checkLimits(instant, \"resulting\");\n+        return instant;\n+    }\n+\n+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        long instant = iChronology.getTimeOnlyMillis\n+            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        checkLimits(instant, \"resulting\");\n+        return instant;\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        long instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n+        checkLimits(instant, \"resulting\");\n+        return instant;\n+    }\n+\n+    public long getDateTimeMillis(long instant,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        checkLimits(instant, null);\n+        instant = iChronology.getDateTimeMillis\n+            (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        checkLimits(instant, \"resulting\");\n+        return instant;\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        long instant = iChronology.getDateTimeMillis\n+            (year, monthOfYear, dayOfMonth,\n+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        checkLimits(instant, \"resulting\");\n+        return instant;\n+    }\n+\n+    // Milliseconds\n+    //------------------------------------------------------------\n+\n+    public DurationField millis() {\n+        return iMillisField;\n+    }\n+\n+    public DateTimeField millisOfSecond() {\n+        return iMillisOfSecondField;\n+    }\n+\n+    public DateTimeField millisOfDay() {\n+        return iMillisOfDayField;\n+    }\n+\n+    // Seconds\n+    //------------------------------------------------------------\n+\n+    public DurationField seconds() {\n+        return iSecondsField;\n+    }\n+\n+    public DateTimeField secondOfMinute() {\n+        return iSecondOfMinuteField;\n+    }\n+\n+    public DateTimeField secondOfDay() {\n+        return iSecondOfDayField;\n+    }\n+\n+    // Minutes\n+    //------------------------------------------------------------\n+\n+    public DurationField minutes() {\n+        return iMinutesField;\n+    }\n+\n+    public DateTimeField minuteOfHour() {\n+        return iMinuteOfHourField;\n+    }\n+\n+    public DateTimeField minuteOfDay() {\n+        return iMinuteOfDayField;\n+    }\n+\n+    // Hours\n+    //------------------------------------------------------------\n+\n+    public DurationField hours() {\n+        return iHoursField;\n+    }\n+\n+    public DateTimeField hourOfDay() {\n+        return iHourOfDayField;\n+    }\n+\n+    public DateTimeField clockhourOfDay() {\n+        return iClockhourOfDayField;\n+    }\n+\n+    public DateTimeField hourOfHalfday() {\n+        return iHourOfHalfdayField;\n+    }\n+\n+    public DateTimeField clockhourOfHalfday() {\n+        return iClockhourOfHalfdayField;\n+    }\n+\n+    public DateTimeField halfdayOfDay() {\n+        return iHalfdayOfDayField;\n+    }\n+\n+    // Day\n+    //------------------------------------------------------------\n+\n+    public DurationField days() {\n+        return iDaysField;\n+    }\n+\n+    public DateTimeField dayOfWeek() {\n+        return iDayOfWeekField;\n+    }\n+\n+    public DateTimeField dayOfMonth() {\n+        return iDayOfMonthField;\n+    }\n+\n+    public DateTimeField dayOfYear() {\n+        return iDayOfYearField;\n+    }\n+\n+    // Week\n+    //------------------------------------------------------------\n+\n+    public DurationField weeks() {\n+        return iWeeksField;\n+    }\n+\n+    public DateTimeField weekOfWeekyear() {\n+        return iWeekOfWeekyearField;\n+    }\n+\n+    public DurationField weekyears() {\n+        return iWeekyearsField;\n+    }\n+\n+    public DateTimeField weekyear() {\n+        return iWeekyearField;\n+    }\n+\n+    // Month\n+    //------------------------------------------------------------\n+\n+    public DurationField months() {\n+        return iMonthsField;\n+    }\n+\n+    public DateTimeField monthOfYear() {\n+        return iMonthOfYearField;\n+    }\n+\n+    // Year\n+    //------------------------------------------------------------\n+\n+    public DurationField years() {\n+        return iYearsField;\n+    }\n+\n+    public DateTimeField year() {\n+        return iYearField;\n+    }\n+\n+    public DateTimeField yearOfEra() {\n+        return iYearOfEraField;\n+    }\n+\n+    public DateTimeField yearOfCentury() {\n+        return iYearOfCenturyField;\n+    }\n+\n+    public DurationField centuries() {\n+        return iCenturiesField;\n+    }\n+\n+    public DateTimeField centuryOfEra() {\n+        return iCenturyOfEraField;\n+    }\n+\n+    public DurationField eras() {\n+        return iErasField;\n+    }\n+\n+    public DateTimeField era() {\n+        return iEraField;\n+    }\n+\n+    public String toString() {\n+        return iChronology.toString();\n+    }\n+\n+    private void readObject(ObjectInputStream in)\n+        throws IOException, ClassNotFoundException\n+    {\n+        in.defaultReadObject();\n+        setFields();\n+    }\n+\n+    void checkLimits(long instant, String desc) {\n+        DateTime limit;\n+        if ((limit = iLowerLimit) != null && instant < limit.getMillis()) {\n+            throw new LimitException(desc, true);\n+        }\n+        if ((limit = iUpperLimit) != null && instant >= limit.getMillis()) {\n+            throw new LimitException(desc, false);\n+        }\n+    }\n+\n+    /**\n+     * Extends IllegalArgumentException such that the exception message is not\n+     * generated unless it is actually requested.\n+     */\n+    private class LimitException extends IllegalArgumentException {\n+        static final long serialVersionUID = -5924689995607498581L;\n+\n+        private final boolean iIsLow;\n+\n+        LimitException(String desc, boolean isLow) {\n+            super(desc);\n+            iIsLow = isLow;\n+        }\n+\n+        public String getMessage() {\n+            StringBuffer buf = new StringBuffer(85);\n+            buf.append(\"The\");\n+            String desc = super.getMessage();\n+            if (desc != null) {\n+                buf.append(' ');\n+                buf.append(desc);\n+            }\n+            buf.append(\" instant is \");\n+\n+            DateTimePrinter p = ISODateTimeFormat.getInstance(getWrappedChronology()).dateTime();\n+\n+            if (iIsLow) {\n+                buf.append(\"below the supported minimum of \");\n+                p.printTo(buf, iLowerLimit);\n+            } else {\n+                buf.append(\"above the supported maximum of \");\n+                p.printTo(buf, iUpperLimit);\n+            }\n+            \n+            buf.append(\" (\");\n+            buf.append(getWrappedChronology());\n+            buf.append(')');\n+\n+            return buf.toString();\n+        }\n+\n+        public String toString() {\n+            return \"IllegalArgumentException: \" + getMessage();\n+        }\n+    }\n+\n+    private class LimitDurationField extends DecoratedDurationField {\n+        static final long serialVersionUID = 8049297699408782284L;\n+\n+        LimitDurationField(DurationField field) {\n+            super(field, field.getName());\n+        }\n+\n+        public int getValue(long duration, long instant) {\n+            checkLimits(instant, null);\n+            return getWrappedField().getValue(duration, instant);\n+        }\n+\n+        public long getValueAsLong(long duration, long instant) {\n+            checkLimits(instant, null);\n+            return getWrappedField().getValueAsLong(duration, instant);\n+        }\n+\n+        public long getMillis(int value, long instant) {\n+            checkLimits(instant, null);\n+            return getWrappedField().getMillis(value, instant);\n+        }\n+\n+        public long getMillis(long value, long instant) {\n+            checkLimits(instant, null);\n+            return getWrappedField().getMillis(value, instant);\n+        }\n+\n+        public long add(long instant, int amount) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().add(instant, amount);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+\n+        public long add(long instant, long amount) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().add(instant, amount);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+\n+        public int getDifference(long minuendInstant, long subtrahendInstant) {\n+            checkLimits(minuendInstant, \"minuend\");\n+            checkLimits(subtrahendInstant, \"subtrahend\");\n+            return getWrappedField().getDifference(minuendInstant, subtrahendInstant);\n+        }\n+\n+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+            checkLimits(minuendInstant, \"minuend\");\n+            checkLimits(subtrahendInstant, \"subtrahend\");\n+            return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+        }\n+\n+    }\n+\n+    private class LimitDateTimeField extends DecoratedDateTimeField {\n+        static final long serialVersionUID = -2435306746995699312L;\n+\n+        private final DurationField iDurationField;\n+        private final DurationField iRangeDurationField;\n+        private final DurationField iLeapDurationField;\n+\n+        LimitDateTimeField(DateTimeField field,\n+                           DurationField durationField,\n+                           DurationField rangeDurationField,\n+                           DurationField leapDurationField) {\n+            super(field, field.getName());\n+            iDurationField = durationField;\n+            iRangeDurationField = rangeDurationField;\n+            iLeapDurationField = leapDurationField;\n+        }\n+\n+        public int get(long instant) {\n+            checkLimits(instant, null);\n+            return getWrappedField().get(instant);\n+        }\n+        \n+        public String getAsText(long instant, Locale locale) {\n+            checkLimits(instant, null);\n+            return getWrappedField().getAsText(instant, locale);\n+        }\n+        \n+        public String getAsShortText(long instant, Locale locale) {\n+            checkLimits(instant, null);\n+            return getWrappedField().getAsShortText(instant, locale);\n+        }\n+        \n+        public long add(long instant, int amount) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().add(instant, amount);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+\n+        public long add(long instant, long amount) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().add(instant, amount);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+\n+        public long addWrapped(long instant, int amount) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().addWrapped(instant, amount);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+        \n+        public int getDifference(long minuendInstant, long subtrahendInstant) {\n+            checkLimits(minuendInstant, \"minuend\");\n+            checkLimits(subtrahendInstant, \"subtrahend\");\n+            return getWrappedField().getDifference(minuendInstant, subtrahendInstant);\n+        }\n+        \n+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+            checkLimits(minuendInstant, \"minuend\");\n+            checkLimits(subtrahendInstant, \"subtrahend\");\n+            return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+        }\n+        \n+        public long set(long instant, int value) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().set(instant, value);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+        \n+        public long set(long instant, String text, Locale locale) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().set(instant, text, locale);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+        \n+        public final DurationField getDurationField() {\n+            return iDurationField;\n+        }\n+\n+        public final DurationField getRangeDurationField() {\n+            return iRangeDurationField;\n+        }\n+\n+        public boolean isLeap(long instant) {\n+            checkLimits(instant, null);\n+            return getWrappedField().isLeap(instant);\n+        }\n+        \n+        public int getLeapAmount(long instant) {\n+            checkLimits(instant, null);\n+            return getWrappedField().getLeapAmount(instant);\n+        }\n+        \n+        public final DurationField getLeapDurationField() {\n+            return iLeapDurationField;\n+        }\n+        \n+        public long roundFloor(long instant) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().roundFloor(instant);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+        \n+        public long roundCeiling(long instant) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().roundCeiling(instant);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+        \n+        public long roundHalfFloor(long instant) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().roundHalfFloor(instant);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+        \n+        public long roundHalfCeiling(long instant) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().roundHalfCeiling(instant);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+        \n+        public long roundHalfEven(long instant) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().roundHalfEven(instant);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+        \n+        public long remainder(long instant) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().remainder(instant);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+\n+        public int getMinimumValue(long instant) {\n+            checkLimits(instant, null);\n+            return getWrappedField().getMinimumValue(instant);\n+        }\n+\n+        public int getMaximumValue(long instant) {\n+            checkLimits(instant, null);\n+            return getWrappedField().getMaximumValue(instant);\n+        }\n+\n+        public int getMaximumTextLength(Locale locale) {\n+            return getWrappedField().getMaximumTextLength(locale);\n+        }\n+\n+        public int getMaximumShortTextLength(Locale locale) {\n+            return getWrappedField().getMaximumShortTextLength(locale);\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/MillisDurationField.java\n+/* \n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.io.Serializable;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Duration field class representing a field with a fixed unit length of one\n+ * millisecond.\n+ * <p>\n+ * MillisDurationField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public final class MillisDurationField implements DurationField, Serializable {\n+    \n+    static final long serialVersionUID = 2656707858124633367L;\n+\n+    public static final DurationField INSTANCE = new MillisDurationField();\n+\n+    private MillisDurationField() {\n+    }\n+    \n+    //------------------------------------------------------------------------\n+    public String getName() {\n+        return \"millis\";\n+    }\n+\n+    /**\n+     * @return true always\n+     */\n+    public boolean isSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * This field is precise.\n+     * \n+     * @return true always\n+     */\n+    public final boolean isPrecise() {\n+        return true;\n+    }\n+    \n+    /**\n+     * Returns the amount of milliseconds per unit value of this field.\n+     *\n+     * @return one always\n+     */\n+    public final long getUnitMillis() {\n+        return 1;\n+    }\n+\n+    //------------------------------------------------------------------------\n+    public int getValue(long duration) {\n+        return Utils.safeToInt(duration);\n+    }\n+\n+    public long getValueAsLong(long duration) {\n+        return duration;\n+    }\n+\n+    public int getValue(long duration, long instant) {\n+        return Utils.safeToInt(duration);\n+    }\n+\n+    public long getValueAsLong(long duration, long instant) {\n+        return duration;\n+    }\n+\n+    public long getMillis(int value) {\n+        return value;\n+    }\n+\n+    public long getMillis(long value) {\n+        return value;\n+    }\n+\n+    public long getMillis(int value, long instant) {\n+        return value;\n+    }\n+\n+    public long getMillis(long value, long instant) {\n+        return value;\n+    }\n+\n+    public long add(long instant, int value) {\n+        return instant + value;\n+    }\n+\n+    public long add(long instant, long value) {\n+        return instant + value;\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return Utils.safeToInt(minuendInstant - subtrahendInstant);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return minuendInstant - subtrahendInstant;\n+    }\n+\n+    //------------------------------------------------------------------------\n+    public int compareTo(Object durationField) {\n+        DurationField otherField = (DurationField) durationField;\n+        long otherMillis = otherField.getUnitMillis();\n+        long thisMillis = getUnitMillis();\n+        // cannot do (thisMillis - otherMillis) as can overflow\n+        if (thisMillis == otherMillis) {\n+            return 0;\n+        }\n+        if (thisMillis < otherMillis) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return \"DurationField[\" + getName() + ']';\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/chrono/NonZeroDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/NonZeroDateTimeField.java\n package org.joda.time.chrono;\n \n import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n \n /**\n  * Wraps another field such that zero values are replaced with one more than\n  * it's maximum. This is particularly useful for implementing an clockhourOfDay\n  * field, where the midnight value of 0 is replaced with 24.\n+ * <p>\n+ * NonZeroDateTimeField is thread-safe and immutable.\n  *\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public final class NonZeroDateTimeField extends DateTimeField {\n-    private final DateTimeField iField;\n+public final class NonZeroDateTimeField extends DecoratedDateTimeField {\n+\n+    static final long serialVersionUID = 961749798233026866L;\n \n     /**\n      * @param name  short, descriptive name, like \"clockhourOfDay\".\n      * @throws IllegalArgumentException if wrapped field's minimum value is not zero\n      */\n-    public NonZeroDateTimeField(String name, DateTimeField field) {\n-        super(name);\n-        if (field == null) {\n-            throw new IllegalArgumentException(\"The field must not be null\");\n-        }\n+    public NonZeroDateTimeField(DateTimeField field, String name) {\n+        super(field, name);\n         if (field.getMinimumValue() != 0) {\n             throw new IllegalArgumentException(\"Wrapped field's minumum value must be zero\");\n         }\n-        iField = field;\n     }\n \n-    public int get(long millis) {\n-        int value = iField.get(millis);\n+    public int get(long instant) {\n+        int value = getWrappedField().get(instant);\n         if (value == 0) {\n             value = getMaximumValue();\n         }\n         return value;\n     }\n \n-    public long add(long millis, int amount) {\n-        return iField.add(millis, amount);\n+    public long add(long instant, int value) {\n+        return getWrappedField().add(instant, value);\n     }\n \n-    public long add(long millis, long amount) {\n-        return iField.add(millis, amount);\n+    public long add(long instant, long value) {\n+        return getWrappedField().add(instant, value);\n     }\n \n-    public long addWrapped(long millis, int amount) {\n-        return iField.addWrapped(millis, amount);\n-    }\n-    \n-    public long getDifference(long minuendMillis, long subtrahendMillis) {\n-        return iField.getDifference(minuendMillis, subtrahendMillis);\n+    public long addWrapped(long instant, int value) {\n+        return getWrappedField().addWrapped(instant, value);\n     }\n \n-    public long set(long millis, int value) {\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long set(long instant, int value) {\n         int max = getMaximumValue();\n-        verifyValueBounds(value, 1, max);\n+        Utils.verifyValueBounds(this, value, 1, max);\n         if (value == max) {\n             value = 0;\n         }\n-        return iField.set(millis, value);\n+        return getWrappedField().set(instant, value);\n     }\n \n-    public long getUnitMillis() {\n-        return iField.getUnitMillis();\n+    public boolean isLeap(long instant) {\n+        return getWrappedField().isLeap(instant);\n     }\n \n-    public long getRangeMillis() {\n-        return iField.getRangeMillis();\n+    public int getLeapAmount(long instant) {\n+        return getWrappedField().getLeapAmount(instant);\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return getWrappedField().getLeapDurationField();\n     }\n \n     /**\n      * \n      * @return the minimum value of 1\n      */\n-    public int getMinimumValue(long millis) {\n+    public int getMinimumValue(long instant) {\n         return 1;\n     }\n \n      * @return the maximum value\n      */\n     public int getMaximumValue() {\n-        return iField.getMaximumValue() + 1;\n+        return getWrappedField().getMaximumValue() + 1;\n     }\n \n     /**\n      * \n      * @return the maximum value\n      */\n-    public int getMaximumValue(long millis) {\n-        return iField.getMaximumValue(millis) + 1;\n+    public int getMaximumValue(long instant) {\n+        return getWrappedField().getMaximumValue(instant) + 1;\n     }\n \n-    public long roundFloor(long millis) {\n-        return iField.roundFloor(millis);\n+    public long roundFloor(long instant) {\n+        return getWrappedField().roundFloor(instant);\n     }\n \n-    public long roundCeiling(long millis) {\n-        return iField.roundCeiling(millis);\n+    public long roundCeiling(long instant) {\n+        return getWrappedField().roundCeiling(instant);\n     }\n \n-    public long remainder(long millis) {\n-        return iField.remainder(millis);\n+    public long roundHalfFloor(long instant) {\n+        return getWrappedField().roundHalfFloor(instant);\n     }\n \n-    /**\n-     * Returns the DateTimeField being wrapped.\n-     * \n-     * @return field\n-     */\n-    public DateTimeField getField() {\n-        return iField;\n+    public long roundHalfCeiling(long instant) {\n+        return getWrappedField().roundHalfCeiling(instant);\n     }\n+\n+    public long roundHalfEven(long instant) {\n+        return getWrappedField().roundHalfEven(instant);\n+    }\n+\n+    public long remainder(long instant) {\n+        return getWrappedField().remainder(instant);\n+    }\n+\n }\n--- a/JodaTime/src/java/org/joda/time/chrono/OffsetDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/OffsetDateTimeField.java\n package org.joda.time.chrono;\n \n import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n \n /**\n  * Generic offset adjusting datetime field.\n+ * <p>\n+ * OffsetDateTimeField is thread-safe and immutable.\n  * \n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public class OffsetDateTimeField extends DateTimeField {\n-    /** The field to adjust */\n-    private final DateTimeField iField;\n+public class OffsetDateTimeField extends DecoratedDateTimeField {\n+    static final long serialVersionUID = 3145790132623583142L;\n+\n     private final int iOffset;\n \n     private final int iMin;\n     /**\n      * Constructor\n      * \n+     * @param field  the field to wrap, like \"year()\".\n      * @param name  short, descriptive name, like \"offsetYear\".\n-     * @param field  the field to wrap, like \"year()\".\n      * @param offset  offset to add to field values\n      * @throws IllegalArgumentException if offset is zero\n      */\n-    public OffsetDateTimeField(String name, DateTimeField field, int offset) {\n-        this(name, field, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n+    public OffsetDateTimeField(DateTimeField field, String name, int offset) {\n+        this(field, name, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n     }\n \n     /**\n      * Constructor\n      * \n+     * @param field  the field to wrap, like \"year()\".\n      * @param name  short, descriptive name, like \"offsetYear\".\n-     * @param field  the field to wrap, like \"year()\".\n      * @param offset  offset to add to field values\n      * @param minValue  minimum allowed value\n      * @param maxValue  maximum allowed value\n      * @throws IllegalArgumentException if offset is zero\n      */\n-    public OffsetDateTimeField(String name, DateTimeField field, int offset,\n+    public OffsetDateTimeField(DateTimeField field, String name, int offset,\n                                int minValue, int maxValue) {\n-        super(name);\n+        super(field, name);\n                 \n-        if (field == null) {\n-            throw new IllegalArgumentException(\"The field must not be null\");\n-        }\n         if (offset == 0) {\n             throw new IllegalArgumentException(\"The offset cannot be zero\");\n         }\n \n-        iField = field;\n         iOffset = offset;\n \n-        if (minValue < (iField.getMinimumValue() + offset)) {\n-            iMin = iField.getMinimumValue() + offset;\n+        if (minValue < (field.getMinimumValue() + offset)) {\n+            iMin = field.getMinimumValue() + offset;\n         } else {\n             iMin = minValue;\n         }\n-        if (maxValue > (iField.getMaximumValue() + offset)) {\n-            iMax = iField.getMaximumValue() + offset;\n+        if (maxValue > (field.getMaximumValue() + offset)) {\n+            iMax = field.getMaximumValue() + offset;\n         } else {\n             iMax = maxValue;\n         }\n     /**\n      * Get the amount of offset units from the specified time instant.\n      * \n-     * @param millis  the time instant in millis to query.\n+     * @param instant  the time instant in millis to query.\n      * @return the amount of units extracted from the input.\n      */\n-    public int get(long millis) {\n-        return iField.get(millis) + iOffset;\n+    public int get(long instant) {\n+        return super.get(instant) + iOffset;\n     }\n \n     /**\n      * Add the specified amount of offset units to the specified time\n      * instant. The amount added may be negative.\n      * \n-     * @param millis  the time instant in millis to update.\n+     * @param instant  the time instant in millis to update.\n      * @param amount  the amount of units to add (can be negative).\n      * @return the updated time instant.\n      */\n-    public long add(long millis, int amount) {\n-        millis = iField.add(millis, amount);\n-        verifyValueBounds(get(millis), iMin, iMax);\n-        return millis;\n+    public long add(long instant, int amount) {\n+        instant = super.add(instant, amount);\n+        Utils.verifyValueBounds(this, get(instant), iMin, iMax);\n+        return instant;\n     }\n \n     /**\n      * Add the specified amount of offset units to the specified time\n      * instant. The amount added may be negative.\n      * \n-     * @param millis  the time instant in millis to update.\n+     * @param instant  the time instant in millis to update.\n      * @param amount  the amount of units to add (can be negative).\n      * @return the updated time instant.\n      */\n-    public long add(long millis, long amount) {\n-        millis = iField.add(millis, amount);\n-        verifyValueBounds(get(millis), iMin, iMax);\n-        return millis;\n+    public long add(long instant, long amount) {\n+        instant = super.add(instant, amount);\n+        Utils.verifyValueBounds(this, get(instant), iMin, iMax);\n+        return instant;\n     }\n \n     /**\n      * Add to the offset component of the specified time instant,\n      * wrapping around within that component if necessary.\n      * \n-     * @param millis  the time instant in millis to update.\n+     * @param instant  the time instant in millis to update.\n      * @param amount  the amount of units to add (can be negative).\n      * @return the updated time instant.\n      */\n-    public long addWrapped(long millis, int amount) {\n-        return set(millis, getWrappedValue(get(millis), amount, iMin, iMax));\n-    }\n-\n-    public long getDifference(long minuendMillis, long subtrahendMillis) {\n-        return iField.getDifference(minuendMillis, subtrahendMillis);\n+    public long addWrapped(long instant, int amount) {\n+        return set(instant, Utils.getWrappedValue(get(instant), amount, iMin, iMax));\n     }\n \n     /**\n      * Set the specified amount of offset units to the specified time instant.\n      * \n-     * @param millis  the time instant in millis to update.\n+     * @param instant  the time instant in millis to update.\n      * @param value  value of units to set.\n      * @return the updated time instant.\n      * @throws IllegalArgumentException if value is too large or too small.\n      */\n-    public long set(long millis, int value) {\n-        verifyValueBounds(value, iMin, iMax);\n-        return iField.set(millis, value - iOffset);\n-    }\n-\n-    public long getUnitMillis() {\n-        return iField.getUnitMillis();\n-    }\n-\n-    public long getRangeMillis() {\n-        return iField.getRangeMillis();\n+    public long set(long instant, int value) {\n+        Utils.verifyValueBounds(this, value, iMin, iMax);\n+        return super.set(instant, value - iOffset);\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return getWrappedField().isLeap(instant);\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        return getWrappedField().getLeapAmount(instant);\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return getWrappedField().getLeapDurationField();\n     }\n \n     /**\n         return iMax;\n     }\n     \n-    public long roundFloor(long millis) {\n-        return iField.roundFloor(millis);\n-    }\n-\n-    public long roundCeiling(long millis) {\n-        return iField.roundCeiling(millis);\n-    }\n-\n-    public long roundHalfFloor(long millis) {\n-        return iField.roundHalfFloor(millis);\n-    }\n-\n-    public long remainder(long millis) {\n-        return iField.remainder(millis);\n-    }\n-\n-    /**\n-     * Returns the DateTimeField being wrapped.\n-     * \n-     * @return field\n-     */\n-    public DateTimeField getField() {\n-        return iField;\n+    public long roundFloor(long instant) {\n+        return getWrappedField().roundFloor(instant);\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        return getWrappedField().roundCeiling(instant);\n+    }\n+\n+    public long roundHalfFloor(long instant) {\n+        return getWrappedField().roundHalfFloor(instant);\n+    }\n+\n+    public long roundHalfCeiling(long instant) {\n+        return getWrappedField().roundHalfCeiling(instant);\n+    }\n+\n+    public long roundHalfEven(long instant) {\n+        return getWrappedField().roundHalfEven(instant);\n+    }\n+\n+    public long remainder(long instant) {\n+        return getWrappedField().remainder(instant);\n     }\n \n     /**\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/PreciseDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Precise datetime field, composed of two precise duration fields.\n+ * <p>\n+ * This DateTimeField is useful for defining DateTimeFields that are composed\n+ * of precise durations, like time of day fields. If either duration field is\n+ * imprecise, then an {@link ImpreciseDateTimeField} may be used instead.\n+ * <p>\n+ * PreciseDateTimeField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ * @see ImpreciseDateTimeField\n+ */\n+public class PreciseDateTimeField extends PreciseDurationDateTimeField {\n+\n+    static final long serialVersionUID = -5586801265774496376L;\n+\n+    /** The maximum range in the correct units */\n+    private final int iRange;\n+\n+    private final DurationField iRangeField;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param name  short, descriptive name, like \"secondOfMinute\".\n+     * @param unit  precise unit duration, like \"seconds()\".\n+     * @param range precise range duration, preferably a multiple of the unit,\n+     * like \"minutes()\".\n+     * @throws IllegalArgumentException if either duration field is imprecise\n+     * @throws IllegalArgumentException if unit milliseconds is less than one\n+     * or effective value range is less than two.\n+     */\n+    public PreciseDateTimeField(String name,\n+                                DurationField unit, DurationField range) {\n+        super(name, unit);\n+\n+        if (!range.isPrecise()) {\n+            throw new IllegalArgumentException(\"Range duration field must be precise\");\n+        }\n+\n+        long rangeMillis = range.getUnitMillis();\n+        iRange = (int)(rangeMillis / getUnitMillis());\n+        if (iRange < 2) {\n+            throw new IllegalArgumentException(\"The effective range must be at least 2\");\n+        }\n+\n+        iRangeField = range;\n+    }\n+\n+    /**\n+     * Get the amount of fractional units from the specified time instant.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the amount of fractional units extracted from the input.\n+     */\n+    public int get(long instant) {\n+        if (instant >= 0) {\n+            return (int) ((instant / getUnitMillis()) % iRange);\n+        } else {\n+            return iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange);\n+        }\n+    }\n+\n+    /**\n+     * Add to the component of the specified time instant, wrapping around\n+     * within that component if necessary.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param amount  the amount of units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long instant, int amount) {\n+        int thisValue = get(instant);\n+        int wrappedValue = Utils.getWrappedValue\n+            (thisValue, amount, getMinimumValue(), getMaximumValue());\n+        // copy code from set() to avoid repeat call to get()\n+        return instant + (wrappedValue - thisValue) * getUnitMillis();\n+    }\n+\n+    /**\n+     * Returns the range duration of this field. For example, if this field\n+     * represents \"minute of hour\", then the range duration field is an hours.\n+     *\n+     * @return the range duration of this field, or null if field has no range\n+     */\n+    public DurationField getRangeDurationField() {\n+        return iRangeField;\n+    }\n+\n+    /**\n+     * Get the maximum value for the field.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue() {\n+        return iRange - 1;\n+    }\n+    \n+    /**\n+     * Returns the range of the field in the field's units.\n+     * <p>\n+     * For example, 60 for seconds per minute. The field is allowed values\n+     * from 0 to range - 1.\n+     * \n+     * @return unit range\n+     */\n+    public int getRange() {\n+        return iRange;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Precise datetime field, which has a precise unit duration field.\n+ * <p>\n+ * PreciseDurationDateTimeField is thread-safe and immutable, and its\n+ * subclasses must be as well.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public abstract class PreciseDurationDateTimeField extends AbstractDateTimeField {\n+\n+    static final long serialVersionUID = 5004523158306266035L;\n+\n+    /** The fractional unit in millis */\n+    private final long iUnitMillis;\n+\n+    private final DurationField iUnitField;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param name  short, descriptive name, like \"dayOfMonth\".\n+     * @param unit  precise unit duration, like \"days()\".\n+     * @throws IllegalArgumentException if duration field is imprecise\n+     * @throws IllegalArgumentException if unit milliseconds is less than one\n+     */\n+    public PreciseDurationDateTimeField(String name, DurationField unit) {\n+        super(name);\n+\n+        if (!unit.isPrecise()) {\n+            throw new IllegalArgumentException(\"Unit duration field must be precise\");\n+        }\n+\n+        iUnitMillis = unit.getUnitMillis();\n+        if (iUnitMillis < 1) {\n+            throw new IllegalArgumentException(\"The unit milliseconds must be at least 1\");\n+        }\n+\n+        iUnitField = unit;\n+    }\n+\n+    /**\n+     * Returns false by default.\n+     */\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    /**\n+     * Add the specified amount of units to the specified time instant. The\n+     * amount added may be negative.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param amount  the amount of units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, int amount) {\n+        return instant + amount * iUnitMillis;\n+    }\n+\n+    /**\n+     * Add the specified amount of units to the specified time instant. The\n+     * amount added may be negative.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param amount  the amount of units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, long amount) {\n+        return instant + amount * iUnitMillis;\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return Utils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return (minuendInstant - subtrahendInstant) / iUnitMillis;\n+    }\n+\n+    /**\n+     * Set the specified amount of units to the specified time instant.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param value  value of units to set.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException if value is too large or too small.\n+     */\n+    public long set(long instant, int value) {\n+        Utils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());\n+        return instant + (value - get(instant)) * iUnitMillis;\n+    }\n+\n+    /**\n+     * This method assumes that this field is properly rounded on\n+     * 1970-01-01T00:00:00. If the rounding alignment differs, override this\n+     * method as follows:\n+     * <pre>\n+     * return super.roundFloor(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;\n+     * </pre>\n+     */\n+    public long roundFloor(long instant) {\n+        if (instant >= 0) {\n+            return instant - instant % iUnitMillis;\n+        } else {\n+            instant += 1;\n+            return instant - instant % iUnitMillis - iUnitMillis;\n+        }\n+    }\n+\n+    /**\n+     * This method assumes that this field is properly rounded on\n+     * 1970-01-01T00:00:00. If the rounding alignment differs, override this\n+     * method as follows:\n+     * <pre>\n+     * return super.roundCeiling(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;\n+     * </pre>\n+     */\n+    public long roundCeiling(long instant) {\n+        if (instant >= 0) {\n+            instant -= 1;\n+            return instant - instant % iUnitMillis + iUnitMillis;\n+        } else {\n+            return instant - instant % iUnitMillis;\n+        }\n+    }\n+\n+    /**\n+     * This method assumes that this field is properly rounded on\n+     * 1970-01-01T00:00:00. If the rounding alignment differs, override this\n+     * method as follows:\n+     * <pre>\n+     * return super.remainder(instant + ALIGNMENT_MILLIS);\n+     * </pre>\n+     */\n+    public long remainder(long instant) {\n+        if (instant >= 0) {\n+            return instant % iUnitMillis;\n+        } else {\n+            return (instant + 1) % iUnitMillis + iUnitMillis - 1;\n+        }\n+    }\n+\n+    /**\n+     * Returns the duration per unit value of this field. For example, if this\n+     * field represents \"minute of hour\", then the duration field is minutes.\n+     *\n+     * @return the duration of this field, or UnsupportedDurationField if field\n+     * has no duration\n+     */\n+    public DurationField getDurationField() {\n+        return iUnitField;\n+    }\n+\n+    /**\n+     * Get the minimum value for the field.\n+     * \n+     * @return the minimum value\n+     */\n+    public int getMinimumValue() {\n+        return 0;\n+    }\n+\n+    public final long getUnitMillis() {\n+        return iUnitMillis;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/PreciseDurationField.java\n+/* \n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+/**\n+ * Duration field class representing a field with a fixed unit length.\n+ * <p>\n+ * PreciseDurationField is thread-safe and immutable.\n+ * \n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class PreciseDurationField extends AbstractDurationField {\n+    \n+    static final long serialVersionUID = -8346152187724495365L;\n+\n+    /** The size of the unit */\n+    private final long iUnitMillis;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param name  the name of the field, like \"seconds\"\n+     * @param unitMillis  the unit milliseconds\n+     */    \n+    public PreciseDurationField(String name, long unitMillis) {\n+        super(name);\n+        iUnitMillis = unitMillis;\n+    }\n+    \n+    //------------------------------------------------------------------------\n+    /**\n+     * This field is precise.\n+     * \n+     * @return true always\n+     */\n+    public final boolean isPrecise() {\n+        return true;\n+    }\n+    \n+    /**\n+     * Returns the amount of milliseconds per unit value of this field.\n+     *\n+     * @return the unit size of this field, in milliseconds\n+     */\n+    public final long getUnitMillis() {\n+        return iUnitMillis;\n+    }\n+\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get the value of this field from the milliseconds.\n+     * \n+     * @param duration  the milliseconds to query, which may be negative\n+     * @param instant  ignored\n+     * @return the value of the field, in the units of the field, which may be\n+     * negative\n+     */\n+    public long getValueAsLong(long duration, long instant) {\n+        return duration / iUnitMillis;\n+    }\n+\n+    /**\n+     * Get the millisecond duration of this field from its value.\n+     * \n+     * @param value  the value of the field, which may be negative\n+     * @param instant  ignored\n+     * @return the milliseconds that the field represents, which may be\n+     * negative\n+     */\n+    public long getMillis(int value, long instant) {\n+        return value * iUnitMillis;\n+    }\n+\n+    /**\n+     * Get the millisecond duration of this field from its value.\n+     * \n+     * @param value  the value of the field, which may be negative\n+     * @param instant  ignored\n+     * @return the milliseconds that the field represents, which may be\n+     * negative\n+     */\n+    public long getMillis(long value, long instant) {\n+        return value * iUnitMillis;\n+    }\n+\n+    public long add(long instant, int value) {\n+        return instant + value * iUnitMillis;\n+    }\n+\n+    public long add(long instant, long value) {\n+        return instant + value * iUnitMillis;\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return (minuendInstant - subtrahendInstant) / iUnitMillis;\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/chrono/RemainderDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/RemainderDateTimeField.java\n package org.joda.time.chrono;\n \n import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n \n /**\n- * Generic remainder datetime field.\n- * \n+ * Counterpart remainder datetime field to {@link DividedDateTimeField}. The\n+ * field's unit duration is unchanged, but the range duration is scaled\n+ * accordingly.\n+ * <p>\n+ * RemainderDateTimeField is thread-safe and immutable.\n+ *\n  * @see DividedDateTimeField\n- * \n+ *\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public class RemainderDateTimeField extends DateTimeField {\n-    /** The field to get the remainder */\n-    private final DateTimeField iField;\n-    /** The amount to divide by in the correct units */\n-    private final int iUnitDivisor;\n-\n-    /**\n-     * Constructor\n-     * \n+public class RemainderDateTimeField extends DecoratedDateTimeField {\n+\n+    static final long serialVersionUID = 5708241235177666790L;\n+\n+    // Shared with DividedDateTimeField.\n+    final int iDivisor;\n+    final DurationField iRangeField;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param field  the field to wrap, like \"year()\".\n      * @param name  short, descriptive name, like \"yearOfCentury\".\n-     * @param field  the field to wrap, like \"year()\".\n-     * @param unitDivisor  divisor in units, such as 100 years in a century\n-     * @throws IllegalArgumentException if unit is less than two\n-     */\n-    public RemainderDateTimeField(String name, DateTimeField field, int unitDivisor) {\n-        super(name);\n-                \n-        if (field == null) {\n-            throw new IllegalArgumentException(\"The field must not be null\");\n-        }\n-        if (unitDivisor < 2) {\n-            throw new IllegalArgumentException(\"The unit divisor must be at least 2\");\n-        }\n-        iField = field;\n-        iUnitDivisor = unitDivisor;\n+     * @param rangeName  short, descriptive name, like \"centuries\".\n+     * @param divisor  divisor, such as 100 years in a century\n+     * @throws IllegalArgumentException if divisor is less than two\n+     */\n+    public RemainderDateTimeField(DateTimeField field,\n+                                  String name, String rangeName, int divisor) {\n+        super(field, name);\n+\n+        if (divisor < 2) {\n+            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n+        }\n+\n+        DurationField rangeField = field.getDurationField();\n+        if (rangeField == null) {\n+            iRangeField = null;\n+        } else {\n+            iRangeField = new ScaledDurationField(rangeField, rangeName, divisor);\n+        }\n+\n+        iDivisor = divisor;\n+    }\n+\n+    /**\n+     * Construct a RemainderDateTimeField that compliments the given\n+     * DividedDateTimeField.\n+     *\n+     * @param dividedField  complimentary divided field, like \"century()\".\n+     * @param name  short, descriptive name, like \"yearOfCentury\".\n+     */\n+    public RemainderDateTimeField(DividedDateTimeField dividedField, String name) {\n+        super(dividedField.getWrappedField(), name);\n+        iDivisor = dividedField.iDivisor;\n+        iRangeField = dividedField.iDurationField;\n     }\n \n     /**\n      * Get the remainder from the specified time instant.\n      * \n-     * @param millis  the time instant in millis to query.\n+     * @param instant  the time instant in millis to query.\n      * @return the remainder extracted from the input.\n      */\n-    public int get(long millis) {\n-        int value = iField.get(millis);\n+    public int get(long instant) {\n+        int value = getWrappedField().get(instant);\n         if (value >= 0) {\n-            return value % iUnitDivisor;\n+            return value % iDivisor;\n         } else {\n-            return (iUnitDivisor - 1) + ((value + 1) % iUnitDivisor);\n-        }\n-    }\n-    \n-    /**\n-     * Add the specified amount to the specified time instant. The amount added\n-     * may be negative.\n-     * \n-     * @param millis  the time instant in millis to update.\n-     * @param amount  the amount to add (can be negative).\n-     * @return the updated time instant.\n-     */\n-    public long add(long millis, int amount) {\n-        return iField.add(millis, amount);\n-    }\n-    \n-    /**\n-     * Add the specified amount to the specified time instant. The amount added\n-     * may be negative.\n-     * \n-     * @param millis  the time instant in millis to update.\n-     * @param amount  the amount to add (can be negative).\n-     * @return the updated time instant.\n-     */\n-    public long add(long millis, long amount) {\n-        return iField.add(millis, amount);\n+            return (iDivisor - 1) + ((value + 1) % iDivisor);\n+        }\n     }\n \n     /**\n      * within the remainder range if necessary. The amount added may be\n      * negative.\n      * \n-     * @param millis  the time instant in millis to update.\n+     * @param instant  the time instant in millis to update.\n      * @param amount  the amount to add (can be negative).\n      * @return the updated time instant.\n      */\n-    public long addWrapped(long millis, int amount) {\n-        return set(millis, getWrappedValue(get(millis), amount, 0, iUnitDivisor - 1));\n-    }\n-    \n-    public long getDifference(long minuendMillis, long subtrahendMillis) {\n-        return iField.getDifference(minuendMillis, subtrahendMillis);\n+    public long addWrapped(long instant, int amount) {\n+        return set(instant, Utils.getWrappedValue(get(instant), amount, 0, iDivisor - 1));\n     }\n \n     /**\n      * Set the specified amount of remainder units to the specified time instant.\n      * \n-     * @param millis  the time instant in millis to update.\n+     * @param instant  the time instant in millis to update.\n      * @param value  value of remainder units to set.\n      * @return the updated time instant.\n      * @throws IllegalArgumentException if value is too large or too small.\n      */\n-    public long set(long millis, int value) {\n-        verifyValueBounds(value, 0, iUnitDivisor - 1);\n-        int divided = getDivided(iField.get(millis));\n-        return iField.set(millis, divided * iUnitDivisor + value);\n-    }\n-    \n-    public long getUnitMillis() {\n-        return iField.getUnitMillis();\n-    }\n-\n-    /**\n-     * Returns the wrapped field's unit size multiplied by the unit divisor.\n-     */\n-    public long getRangeMillis() {\n-        return iField.getUnitMillis() * iUnitDivisor;\n+    public long set(long instant, int value) {\n+        Utils.verifyValueBounds(this, value, 0, iDivisor - 1);\n+        int divided = getDivided(getWrappedField().get(instant));\n+        return getWrappedField().set(instant, divided * iDivisor + value);\n+    }\n+\n+    /**\n+     * Returns a scaled version of the wrapped field's unit duration field.\n+     */\n+    public DurationField getRangeDurationField() {\n+        return iRangeField;\n     }\n \n     /**\n     public int getMinimumValue() {\n         return 0;\n     }\n-    \n+\n     /**\n      * Get the maximum value for the field, which is always one less than the\n-     * unit divisor.\n+     * divisor.\n      * \n      * @return the maximum value\n      */\n     public int getMaximumValue() {\n-        return iUnitDivisor - 1;\n-    }\n-    \n-    public long roundFloor(long millis) {\n-        return iField.roundFloor(millis);\n-    }\n-\n-    public long roundCeiling(long millis) {\n-        return iField.roundCeiling(millis);\n-    }\n-\n-    public long remainder(long millis) {\n-        return iField.remainder(millis);\n-    }\n-\n-    /**\n-     * Returns the DateTimeField being wrapped.\n-     * \n-     * @return field\n-     */\n-    public DateTimeField getField() {\n-        return iField;\n-    }\n-\n-    /**\n-     * Returns the divisor to apply to the field in the field's units.\n+        return iDivisor - 1;\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return getWrappedField().roundFloor(instant);\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        return getWrappedField().roundCeiling(instant);\n+    }\n+\n+    public long roundHalfFloor(long instant) {\n+        return getWrappedField().roundHalfFloor(instant);\n+    }\n+\n+    public long roundHalfCeiling(long instant) {\n+        return getWrappedField().roundHalfCeiling(instant);\n+    }\n+\n+    public long roundHalfEven(long instant) {\n+        return getWrappedField().roundHalfEven(instant);\n+    }\n+\n+    public long remainder(long instant) {\n+        return getWrappedField().remainder(instant);\n+    }\n+\n+    /**\n+     * Returns the divisor applied, in the field's units.\n      * \n      * @return the divisor\n      */\n-    public int getUnitDivisor() {\n-        return iUnitDivisor;\n+    public int getDivisor() {\n+        return iDivisor;\n     }\n \n     private int getDivided(int value) {\n         if (value >= 0) {\n-            return value / iUnitDivisor;\n+            return value / iDivisor;\n         } else {\n-            return ((value + 1) / iUnitDivisor) - 1;\n+            return ((value + 1) / iDivisor) - 1;\n         }\n     }\n \n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/ScaledDurationField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Scales a DurationField such that it's unit millis becomes larger in\n+ * magnitude.\n+ * <p>\n+ * ScaledDurationField is thread-safe and immutable.\n+ *\n+ * @see PreciseDurationField\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public class ScaledDurationField extends DecoratedDurationField {\n+\n+    static final long serialVersionUID = -3205227092378684157L;\n+\n+    private final int iScalar;\n+\n+    /**\n+     * Constructor\n+     * \n+     * @param field  the field to wrap, like \"year()\".\n+     * @param name  short, descriptive name, like \"centuries\".\n+     * @param scalar  scalar, such as 100 years in a century\n+     * @throws IllegalArgumentException if scalar is zero or one.\n+     */\n+    public ScaledDurationField(DurationField field, String name, int scalar) {\n+        super(field, name);\n+        if (scalar == 0 || scalar == 1) {\n+            throw new IllegalArgumentException(\"The scalar must not be 0 or 1\");\n+        }\n+        iScalar = scalar;\n+    }\n+\n+    public int getValue(long duration) {\n+        return getWrappedField().getValue(duration) / iScalar;\n+    }\n+\n+    public long getValueAsLong(long duration) {\n+        return getWrappedField().getValueAsLong(duration) / iScalar;\n+    }\n+\n+    public int getValue(long duration, long instant) {\n+        return getWrappedField().getValue(duration, instant) / iScalar;\n+    }\n+\n+    public long getValueAsLong(long duration, long instant) {\n+        return getWrappedField().getValueAsLong(duration, instant) / iScalar;\n+    }\n+\n+    public long getMillis(int value) {\n+        return getWrappedField().getMillis(value * iScalar);\n+    }\n+\n+    public long getMillis(long value) {\n+        return getWrappedField().getMillis(value * iScalar);\n+    }\n+\n+    public long getMillis(int value, long instant) {\n+        return getWrappedField().getMillis(value * iScalar, instant);\n+    }\n+\n+    public long getMillis(long value, long instant) {\n+        return getWrappedField().getMillis(value * iScalar, instant);\n+    }\n+\n+    public long add(long instant, int value) {\n+        return getWrappedField().add(instant, value * iScalar);\n+    }\n+\n+    public long add(long instant, long value) {\n+        return getWrappedField().add(instant, value * iScalar);\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant) / iScalar;\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant) / iScalar;\n+    }\n+\n+    public long getUnitMillis() {\n+        return getWrappedField().getUnitMillis() * iScalar;\n+    }\n+\n+    /**\n+     * Returns the scalar applied, in the field's units.\n+     * \n+     * @return the scalar\n+     */\n+    public int getScalar() {\n+        return iScalar;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * Wraps another chronology, ensuring all the fields are strict.\n+ * <p>\n+ * StrictChronology is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @see StrictDateTimeField\n+ * @see LenientChronology\n+ */\n+public class StrictChronology extends DelegatedChronology {\n+\n+    static final long serialVersionUID = 6633006628097111960L;\n+\n+    private transient DateTimeField iYearField;\n+    private transient DateTimeField iYearOfEraField;\n+    private transient DateTimeField iYearOfCenturyField;\n+    private transient DateTimeField iCenturyOfEraField;\n+    private transient DateTimeField iEraField;\n+    private transient DateTimeField iDayOfWeekField;\n+    private transient DateTimeField iDayOfMonthField;\n+    private transient DateTimeField iDayOfYearField;\n+    private transient DateTimeField iMonthOfYearField;\n+    private transient DateTimeField iWeekOfWeekyearField;\n+    private transient DateTimeField iWeekyearField;\n+\n+    private transient DateTimeField iMillisOfSecondField;\n+    private transient DateTimeField iMillisOfDayField;\n+    private transient DateTimeField iSecondOfMinuteField;\n+    private transient DateTimeField iSecondOfDayField;\n+    private transient DateTimeField iMinuteOfHourField;\n+    private transient DateTimeField iMinuteOfDayField;\n+    private transient DateTimeField iHourOfDayField;\n+    private transient DateTimeField iHourOfHalfdayField;\n+    private transient DateTimeField iClockhourOfDayField;\n+    private transient DateTimeField iClockhourOfHalfdayField;\n+    private transient DateTimeField iHalfdayOfDayField;\n+\n+    private transient Chronology iWithUTC;\n+\n+    /**\n+     * Create a StrictChronology for any chronology.\n+     *\n+     * @param chrono the chronology\n+     * @throws IllegalArgumentException if chronology is null\n+     */\n+    public StrictChronology(Chronology chrono) {\n+        super(chrono);\n+    }\n+\n+    public Chronology withUTC() {\n+        if (iWithUTC == null) {\n+            iWithUTC = new StrictChronology(getWrappedChronology().withUTC());\n+        }\n+        return iWithUTC;\n+    }\n+\n+    public Chronology withDateTimeZone(DateTimeZone zone) {\n+        return new StrictChronology(getWrappedChronology().withDateTimeZone(zone));\n+    }\n+\n+    /**\n+     * Overridden to ensure strict fields are used.\n+     */\n+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException\n+    {\n+        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n+    }\n+\n+    /**\n+     * Overridden to ensure strict fields are used.\n+     */\n+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        long instant = hourOfDay().set(0, hourOfDay);\n+        instant = minuteOfHour().set(instant, minuteOfHour);\n+        instant = secondOfMinute().set(instant, secondOfMinute);\n+        return millisOfSecond().set(instant, millisOfSecond);\n+    }\n+\n+    /**\n+     * Overridden to ensure strict fields are used.\n+     */\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        long instant = year().set(0, year);\n+        instant = monthOfYear().set(instant, monthOfYear);\n+        instant = dayOfMonth().set(instant, dayOfMonth);\n+        return millisOfDay().set(instant, millisOfDay);\n+    }\n+\n+    /**\n+     * Overridden to ensure strict fields are used.\n+     */\n+    public long getDateTimeMillis(long instant,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        instant = hourOfDay().set(instant, hourOfDay);\n+        instant = minuteOfHour().set(instant, minuteOfHour);\n+        instant = secondOfMinute().set(instant, secondOfMinute);\n+        return millisOfSecond().set(instant, millisOfSecond);\n+    }\n+\n+    /**\n+     * Overridden to ensure strict fields are used.\n+     */\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        long instant = year().set(0, year);\n+        instant = monthOfYear().set(instant, monthOfYear);\n+        instant = dayOfMonth().set(instant, dayOfMonth);\n+        instant = hourOfDay().set(instant, hourOfDay);\n+        instant = minuteOfHour().set(instant, minuteOfHour);\n+        instant = secondOfMinute().set(instant, secondOfMinute);\n+        return millisOfSecond().set(instant, millisOfSecond);\n+    }\n+\n+    // Milliseconds\n+    //------------------------------------------------------------\n+\n+    public DateTimeField millisOfSecond() {\n+        if (iMillisOfDayField == null) {\n+            iMillisOfSecondField = StrictDateTimeField.getInstance(super.millisOfSecond());\n+        }\n+        return iMillisOfSecondField;\n+    }\n+\n+    public DateTimeField millisOfDay() {\n+        if (iMillisOfDayField == null) {\n+            iMillisOfDayField = StrictDateTimeField.getInstance(super.millisOfDay());\n+        }\n+        return iMillisOfDayField;\n+    }\n+\n+    // Seconds\n+    //------------------------------------------------------------\n+\n+    public DateTimeField secondOfMinute() {\n+        if (iSecondOfMinuteField == null) {\n+            iSecondOfMinuteField = StrictDateTimeField.getInstance(super.secondOfMinute());\n+        }\n+        return iSecondOfMinuteField;\n+    }\n+\n+    public DateTimeField secondOfDay() {\n+        if (iSecondOfDayField == null) {\n+            iSecondOfDayField = StrictDateTimeField.getInstance(super.secondOfDay());\n+        }\n+        return iSecondOfDayField;\n+    }\n+\n+    // Minutes\n+    //------------------------------------------------------------\n+\n+    public DateTimeField minuteOfHour() {\n+        if (iMinuteOfHourField == null) {\n+            iMinuteOfHourField = StrictDateTimeField.getInstance(super.minuteOfHour());\n+        }\n+        return iMinuteOfHourField;\n+    }\n+\n+    public DateTimeField minuteOfDay() {\n+        if (iMinuteOfDayField == null) {\n+            iMinuteOfDayField = StrictDateTimeField.getInstance(super.minuteOfDay());\n+        }\n+        return iMinuteOfDayField;\n+    }\n+\n+    // Hours\n+    //------------------------------------------------------------\n+\n+    public DateTimeField hourOfDay() {\n+        if (iHourOfDayField == null) {\n+            iHourOfDayField = StrictDateTimeField.getInstance(super.hourOfDay());\n+        }\n+        return iHourOfDayField;\n+    }\n+\n+    public DateTimeField clockhourOfDay() {\n+        if (iClockhourOfDayField == null) {\n+            iClockhourOfDayField = StrictDateTimeField.getInstance(super.clockhourOfDay());\n+        }\n+        return iClockhourOfDayField;\n+    }\n+\n+    public DateTimeField hourOfHalfday() {\n+        if (iHourOfHalfdayField == null) {\n+            iHourOfHalfdayField = StrictDateTimeField.getInstance(super.hourOfHalfday());\n+        }\n+        return iHourOfHalfdayField;\n+    }\n+\n+    public DateTimeField clockhourOfHalfday() {\n+        if (iClockhourOfHalfdayField == null) {\n+            iClockhourOfHalfdayField =\n+                StrictDateTimeField.getInstance(super.clockhourOfHalfday());\n+        }\n+        return iClockhourOfHalfdayField;\n+    }\n+\n+    public DateTimeField halfdayOfDay() {\n+        if (iHalfdayOfDayField == null) {\n+            iHalfdayOfDayField = StrictDateTimeField.getInstance(super.halfdayOfDay());\n+        }\n+        return iHalfdayOfDayField;\n+    }\n+\n+    // Day\n+    //------------------------------------------------------------\n+\n+    public DateTimeField dayOfWeek() {\n+        if (iDayOfWeekField == null) {\n+            iDayOfWeekField = StrictDateTimeField.getInstance(super.dayOfWeek());\n+        }\n+        return iDayOfWeekField;\n+    }\n+\n+    public DateTimeField dayOfMonth() {\n+        if (iDayOfMonthField == null) {\n+            iDayOfMonthField = StrictDateTimeField.getInstance(super.dayOfMonth());\n+        }\n+        return iDayOfMonthField;\n+    }\n+\n+    public DateTimeField dayOfYear() {\n+        if (iDayOfYearField == null) {\n+            iDayOfYearField = StrictDateTimeField.getInstance(super.dayOfYear());\n+        }\n+        return iDayOfYearField;\n+    }\n+\n+    // Week\n+    //------------------------------------------------------------\n+\n+    public DateTimeField weekOfWeekyear() {\n+        if (iWeekOfWeekyearField == null) {\n+            iWeekOfWeekyearField = StrictDateTimeField.getInstance(super.weekOfWeekyear());\n+        }\n+        return iWeekOfWeekyearField;\n+    }\n+\n+    public DateTimeField weekyear() {\n+        if (iWeekyearField == null) {\n+            iWeekyearField = StrictDateTimeField.getInstance(super.weekyear());\n+        }\n+        return iWeekyearField;\n+    }\n+\n+    // Month\n+    //------------------------------------------------------------\n+\n+    public DateTimeField monthOfYear() {\n+        if (iMonthOfYearField == null) {\n+            iMonthOfYearField = StrictDateTimeField.getInstance(super.monthOfYear());\n+        }\n+        return iMonthOfYearField;\n+    }\n+\n+    // Year\n+    //------------------------------------------------------------\n+\n+    public DateTimeField year() {\n+        if (iYearField == null) {\n+            iYearField = StrictDateTimeField.getInstance(super.year());\n+        }\n+        return iYearField;\n+    }\n+\n+    public DateTimeField yearOfEra() {\n+        if (iYearOfEraField == null) {\n+            iYearOfEraField = StrictDateTimeField.getInstance(super.yearOfEra());\n+        }\n+        return iYearOfEraField;\n+    }\n+\n+    public DateTimeField yearOfCentury() {\n+        if (iYearOfCenturyField == null) {\n+            iYearOfCenturyField = StrictDateTimeField.getInstance(super.yearOfCentury());\n+        }\n+        return iYearOfCenturyField;\n+    }\n+\n+    public DateTimeField centuryOfEra() {\n+        if (iCenturyOfEraField == null) {\n+            iCenturyOfEraField = StrictDateTimeField.getInstance(super.centuryOfEra());\n+        }\n+        return iCenturyOfEraField;\n+    }\n+\n+    public DateTimeField era() {\n+        if (iEraField == null) {\n+            iEraField = StrictDateTimeField.getInstance(super.era());\n+        }\n+        return iEraField;\n+    }\n+\n+    public String toString() {\n+        return \"StrictChronology[\" + getWrappedChronology().toString() + ']';\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/StrictDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Converts a lenient DateTimeField into a strict one. By being strict, the set\n+ * throws an IllegalArgumentException if the value is out of bounds.\n+ * <p>\n+ * StrictDateTimeField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @see LenientDateTimeField\n+ */\n+public class StrictDateTimeField extends DelegatedDateTimeField {\n+\n+    static final long serialVersionUID = 3154803964207950910L;\n+\n+    /**\n+     * Returns a strict version of the given field. If it is already strict,\n+     * then it is returned as-is. Otherwise, a new StrictDateTimeField is\n+     * returned.\n+     */\n+    public static DateTimeField getInstance(DateTimeField field) {\n+        if (field == null) {\n+            return null;\n+        }\n+        if (field instanceof LenientDateTimeField) {\n+            field = ((LenientDateTimeField)field).getWrappedField();\n+        }\n+        if (!field.isLenient()) {\n+            return field;\n+        }\n+        return new StrictDateTimeField(field);\n+    }\n+\n+    protected StrictDateTimeField(DateTimeField field) {\n+        super(field);\n+    }\n+\n+    public final boolean isLenient() {\n+        return false;\n+    }\n+\n+    /**\n+     * Does a bounds check before setting the value.\n+     *\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public long set(long instant, int value) {\n+        Utils.verifyValueBounds\n+            (this, value, getMinimumValue(instant), getMaximumValue(instant));\n+        return super.set(instant, value);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/UnsupportedDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.chrono;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * A placeholder implementation to use when a datetime field is not supported.\n+ * <p>\n+ * UnsupportedDateTimeField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public final class UnsupportedDateTimeField implements DateTimeField, Serializable {\n+\n+    static final long serialVersionUID = -1934618396111902255L;\n+\n+    /**\n+     * Instance with the name \"unsupported\".\n+     */\n+    public static final UnsupportedDateTimeField INSTANCE =\n+        getInstance(\"unsupported\", UnsupportedDurationField.INSTANCE);\n+\n+    private static HashMap cCache;\n+\n+    /**\n+     * @throws IllegalArgumentException if durationField is null\n+     */\n+    public static synchronized UnsupportedDateTimeField getInstance\n+        (String name, DurationField durationField) {\n+\n+        UnsupportedDateTimeField field;\n+        if (cCache == null) {\n+            cCache = new HashMap(7);\n+            field = null;\n+        } else {\n+            field = (UnsupportedDateTimeField)cCache.get(name);\n+            if (field != null && field.getDurationField() != durationField) {\n+                field = null;\n+            }\n+        }\n+        if (field == null) {\n+            field = new UnsupportedDateTimeField(name, durationField);\n+            cCache.put(name, field);\n+        }\n+        return field;\n+    }\n+\n+    private final String iName;\n+    private final DurationField iDurationField;\n+\n+    private UnsupportedDateTimeField(String name, DurationField durationField) {\n+        if (durationField == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        iName = name;\n+        iDurationField = durationField;\n+    }\n+\n+    // Design note: Simple accessors return a suitable value, but methods\n+    // intended to perform calculations throw an UnsupportedOperationException.\n+\n+    public String getName() {\n+        return iName;\n+    }\n+\n+    /**\n+     * This field is not supported.\n+     *\n+     * @return false always\n+     */\n+    public boolean isSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * This field is not lenient.\n+     *\n+     * @return false always\n+     */\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int get(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public String getAsText(long instant, Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public String getAsText(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public String getAsShortText(long instant, Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public String getAsShortText(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Delegates to the duration field.\n+     *\n+     * @throws UnsupportedOperationException if the duration is unsupported\n+     */\n+    public long add(long instant, int value) {\n+        return getDurationField().add(instant, value);\n+    }\n+\n+    /**\n+     * Delegates to the duration field.\n+     *\n+     * @throws UnsupportedOperationException if the duration is unsupported\n+     */\n+    public long add(long instant, long value) {\n+        return getDurationField().add(instant, value);\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long addWrapped(long instant, int value) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Delegates to the duration field.\n+     *\n+     * @throws UnsupportedOperationException if the duration is unsupported\n+     */\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getDurationField().getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    /**\n+     * Delegates to the duration field.\n+     *\n+     * @throws UnsupportedOperationException if the duration is unsupported\n+     */\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long set(long instant, int value) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long set(long instant, String text, Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long set(long instant, String text) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Even though this DateTimeField is unsupported, the duration field might\n+     * be supported.\n+     *\n+     * @return a possibly supported DurationField\n+     */\n+    public DurationField getDurationField() {\n+        return iDurationField;\n+    }\n+\n+    /**\n+     * Always returns null.\n+     *\n+     * @return null always\n+     */\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public boolean isLeap(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getLeapAmount(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always returns null.\n+     *\n+     * @return null always\n+     */\n+    public DurationField getLeapDurationField() {\n+        return null;\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMinimumValue() {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMinimumValue(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMaximumValue() {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMaximumValue(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long roundFloor(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long roundCeiling(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long roundHalfFloor(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long roundHalfCeiling(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long roundHalfEven(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long remainder(long instant) {\n+        throw unsupported();\n+    }\n+\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return \"UnsupportedDateTimeField\";\n+    }\n+\n+    /**\n+     * Ensure proper singleton serialization\n+     */\n+    private Object readResolve() {\n+        return getInstance(iName, iDurationField);\n+    }\n+\n+    private UnsupportedOperationException unsupported() {\n+        return new UnsupportedOperationException(iName + \" field is unsupported\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/UnsupportedDurationField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.chrono;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * A placeholder implementation to use when a duration field is not supported.\n+ * <p>\n+ * UnsupportedDurationField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public final class UnsupportedDurationField implements DurationField, Serializable {\n+\n+    static final long serialVersionUID = -6390301302770925357L;\n+\n+    /**\n+     * Instance with the name \"unsupported\".\n+     */\n+    public static final UnsupportedDurationField INSTANCE = getInstance(\"unsupported\");\n+\n+    private static HashMap cCache;\n+\n+    public static synchronized UnsupportedDurationField getInstance(String name) {\n+        UnsupportedDurationField field;\n+        if (cCache == null) {\n+            cCache = new HashMap(7);\n+            field = null;\n+        } else {\n+            field = (UnsupportedDurationField)cCache.get(name);\n+        }\n+        if (field == null) {\n+            field = new UnsupportedDurationField(name);\n+            cCache.put(name, field);\n+        }\n+        return field;\n+    }\n+\n+    private final String iName;\n+\n+    private UnsupportedDurationField(String name) {\n+        iName = name;\n+    }\n+\n+    // Design note: Simple Accessors return a suitable value, but methods\n+    // intended to perform calculations throw an UnsupportedOperationException.\n+\n+    public String getName() {\n+        return iName;\n+    }\n+\n+    /**\n+     * This field is not supported.\n+     *\n+     * @return false always\n+     */\n+    public boolean isSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * This field is precise.\n+     * \n+     * @return true always\n+     */\n+    public boolean isPrecise() {\n+        return true;\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getValue(long duration) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getValueAsLong(long duration) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getValue(long duration, long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getValueAsLong(long duration, long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getMillis(int value) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getMillis(long value) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getMillis(int value, long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getMillis(long value, long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long add(long instant, int value) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long add(long instant, long value) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always returns zero.\n+     *\n+     * @return zero always\n+     */\n+    public long getUnitMillis() {\n+        return 0;\n+    }\n+\n+    /**\n+     * Always returns zero, indicating that sort order is not relevent.\n+     *\n+     * @return zero always\n+     */\n+    public int compareTo(Object durationField) {\n+        return 0;\n+    }\n+\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return \"UnsupportedDurationField\";\n+    }\n+\n+    /**\n+     * Ensure proper singleton serialization\n+     */\n+    private Object readResolve() {\n+        return getInstance(iName);\n+    }\n+\n+    private UnsupportedOperationException unsupported() {\n+        return new UnsupportedOperationException(iName + \" field is unsupported\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/Utils.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * General utilities that don't fit elsewhere.\n+ * <p>\n+ * Utils is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public class Utils {\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private Utils() {\n+        super();\n+    }\n+    \n+    //------------------------------------------------------------------------\n+    /**\n+     * Add two values throwing an exception if overflow occurs.\n+     * \n+     * @param val1  the first value\n+     * @param val2  the second value\n+     * @return the new total\n+     */\n+    public static long safeAdd(long val1, long val2) {\n+        long total = val1 + val2;\n+        if (val1 > 0 && val2 > 0 && total < 0) {\n+            throw new ArithmeticException(\"The calculation caused an overflow: \" + val1 +\" + \" + val2);\n+        }\n+        if (val1 < 0 && val2 < 0 && total > 0) {\n+            throw new ArithmeticException(\"The calculation caused an overflow: \" + val1 +\" + \" + val2);\n+        }\n+        return total;\n+    }\n+    \n+    /**\n+     * Multiply two values throwing an exception if overflow occurs.\n+     * \n+     * @param val1  the first value\n+     * @param val2  the second value\n+     * @return the new total\n+     */\n+    public static long safeMultiply(long val1, long val2) {\n+        if (val1 == 0  || val2 == 0) {\n+            return 0L;\n+        }\n+        long total = val1 * val2;\n+        if (total / val2 != val1) {\n+            throw new ArithmeticException(\"The calculation caused an overflow: \" + val1 +\" * \" + val2);\n+        }\n+        return total;\n+    }\n+    \n+    /**\n+     * Casts to an int throwing an exception if overflow occurs.\n+     * \n+     * @param value  the value\n+     * @return the value as an int\n+     */\n+    public static int safeToInt(long value) {\n+        if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {\n+            return (int) value;\n+        }\n+        throw new ArithmeticException(\"Value cannot fit in an int: \" + value);\n+    }\n+\n+    /**\n+     * Verify that input values are within specified bounds.\n+     * \n+     * @param value  the value to check\n+     * @param lowerBound  the lower bound allowed for value\n+     * @param upperBound  the upper bound allowed for value\n+     * @throws IllegalArgumentException if value is not in the specified bounds\n+     */\n+    public static void verifyValueBounds(DateTimeField field, \n+                                         int value, int lowerBound, int upperBound) {\n+        if ((value < lowerBound) || (value > upperBound)) {\n+            throw new IllegalArgumentException(\n+                \"Value: \"\n+                    + value\n+                    + \" for \"\n+                    + field.getName()\n+                    + \" must be in the range (\"\n+                    + lowerBound\n+                    + ','\n+                    + upperBound\n+                    + ')');\n+        }\n+    }\n+\n+    /**\n+     * Verify that input values are within specified bounds.\n+     * \n+     * @param value  the value to check\n+     * @param lowerBound  the lower bound allowed for value\n+     * @param upperBound  the upper bound allowed for value\n+     * @throws IllegalArgumentException if value is not in the specified bounds\n+     */\n+    public static void verifyValueBounds(String fieldName,\n+                                         int value, int lowerBound, int upperBound) {\n+        if ((value < lowerBound) || (value > upperBound)) {\n+            throw new IllegalArgumentException(\n+                \"Value: \"\n+                    + value\n+                    + \" for \"\n+                    + fieldName\n+                    + \" must be in the range (\"\n+                    + lowerBound\n+                    + ','\n+                    + upperBound\n+                    + ')');\n+        }\n+    }\n+\n+    /**\n+     * Utility method used by addWrapped implementations to ensure the new\n+     * value lies within the field's legal value range.\n+     *\n+     * @param currentValue the current value of the data, which may lie outside\n+     * the wrapped value range\n+     * @param wrapValue  the value to add to current value before\n+     *  wrapping.  This may be negative.\n+     * @param minValue the wrap range minimum value.\n+     * @param maxValue the wrap range maximum value.  This must be\n+     *  greater than minValue (checked by the method).\n+     * @return the wrapped value\n+     * @throws IllegalArgumentException if minValue is greater\n+     *  than or equal to maxValue\n+     */\n+    public static int getWrappedValue(int currentValue, int wrapValue,\n+                                      int minValue, int maxValue) {\n+        return getWrappedValue(currentValue + wrapValue, minValue, maxValue);\n+    }\n+\n+    /**\n+     * Utility method that ensures the given value lies within the field's\n+     * legal value range.\n+     * \n+     * @param value  the value to fit into the wrapped value range\n+     * @param minValue the wrap range minimum value.\n+     * @param maxValue the wrap range maximum value.  This must be\n+     *  greater than minValue (checked by the method).\n+     * @return the wrapped value\n+     * @throws IllegalArgumentException if minValue is greater\n+     *  than or equal to maxValue\n+     */\n+    public static int getWrappedValue(int value, int minValue, int maxValue) {\n+        if (minValue >= maxValue) {\n+            throw new IllegalArgumentException(\"MIN > MAX\");\n+        }\n+\n+        int wrapRange = maxValue - minValue + 1;\n+        value -= minValue;\n+\n+        if (value >= 0) {\n+            return (value % wrapRange) + minValue;\n+        }\n+\n+        int remByRange = (-value) % wrapRange;\n+\n+        if (remByRange == 0) {\n+            return 0 + minValue;\n+        }\n+        return (wrapRange - remByRange) + minValue;\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n import java.io.IOException;\n import java.io.ObjectInputStream;\n \n+import java.util.HashMap;\n import java.util.Locale;\n \n import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n \n /**\n  * Wraps another Chronology for supporting time zones.\n+ * <p>\n+ * ZonedChronology is thread-safe and immutable.\n  *\n  * @author Brian S O'Neill\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n public class ZonedChronology extends Chronology {\n+\n+    static final long serialVersionUID = -1079258847191166848L;\n+\n+    static boolean useTimeArithmetic(DurationField field) {\n+        // Use time of day arithmetic rules for unit durations less than\n+        // typical time zone offsets.\n+        return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;\n+    }\n+\n     private final Chronology iChronology;\n     private final DateTimeZone iZone;\n+\n+    private transient DurationField iErasField;\n+    private transient DurationField iCenturiesField;\n+    private transient DurationField iYearsField;\n+    private transient DurationField iMonthsField;\n+    private transient DurationField iWeekyearsField;\n+    private transient DurationField iWeeksField;\n+    private transient DurationField iDaysField;\n+\n+    private transient DurationField iHoursField;\n+    private transient DurationField iMinutesField;\n+    private transient DurationField iSecondsField;\n+    private transient DurationField iMillisField;\n \n     private transient DateTimeField iYearField;\n     private transient DateTimeField iYearOfEraField;\n \n     private void setFields() {\n         Chronology c = iChronology;\n-        DateTimeZone z = iZone;\n-\n-        iYearField = new ZonedDateField(c.year(), z);\n-        iYearOfEraField = new ZonedDateField(c.yearOfEra(), z);\n-        iYearOfCenturyField = new ZonedDateField(c.yearOfCentury(), z);\n-        iCenturyOfEraField = new ZonedDateField(c.centuryOfEra(), z);\n-        iEraField = new ZonedDateField(c.era(), z);\n-        iDayOfMonthField = new ZonedDateField(c.dayOfMonth(), z);\n-        iDayOfWeekField = new ZonedDateField(c.dayOfWeek(), z);\n-        iDayOfYearField = new ZonedDateField(c.dayOfYear(), z);\n-        iMonthOfYearField = new ZonedDateField(c.monthOfYear(), z);\n-        iWeekOfWeekyearField = new ZonedDateField(c.weekOfWeekyear(), z);\n-        iWeekyearField = new ZonedDateField(c.weekyear(), z);\n-        \n-        iMillisOfSecondField = new ZonedTimeField(c.millisOfSecond(), z);\n-        iMillisOfDayField = new ZonedTimeField(c.millisOfDay(), z);\n-        iSecondOfMinuteField = new ZonedTimeField(c.secondOfMinute(), z);\n-        iSecondOfDayField = new ZonedTimeField(c.secondOfDay(), z);\n-        iMinuteOfHourField = new ZonedTimeField(c.minuteOfHour(), z);\n-        iMinuteOfDayField = new ZonedTimeField(c.minuteOfDay(), z);\n-        iHourOfDayField = new ZonedTimeField(c.hourOfDay(), z);\n-        iHourOfHalfdayField = new ZonedTimeField(c.hourOfHalfday(), z);\n-        iClockhourOfDayField = new ZonedTimeField(c.clockhourOfDay(), z);\n-        iClockhourOfHalfdayField = new ZonedTimeField(c.clockhourOfHalfday(), z);\n-\n-        // Treat halfday as a date field for adds.\n-        iHalfdayOfDayField = new ZonedDateField(c.halfdayOfDay(), z);\n+\n+        // Keep a local cache of converted fields so as not to create redundant\n+        // objects.\n+        HashMap converted = new HashMap();\n+\n+        // Convert duration fields...\n+\n+        iErasField = convertField(c.eras(), converted);\n+        iCenturiesField = convertField(c.centuries(), converted);\n+        iYearsField = convertField(c.years(), converted);\n+        iMonthsField = convertField(c.months(), converted);\n+        iWeekyearsField = convertField(c.weekyears(), converted);\n+        iWeeksField = convertField(c.weeks(), converted);\n+        iDaysField = convertField(c.days(), converted);\n+\n+        iHoursField = convertField(c.hours(), converted);\n+        iMinutesField = convertField(c.minutes(), converted);\n+        iSecondsField = convertField(c.seconds(), converted);\n+        iMillisField = convertField(c.millis(), converted);\n+\n+        // Convert datetime fields...\n+\n+        iYearField = convertField(c.year(), converted);\n+        iYearOfEraField = convertField(c.yearOfEra(), converted);\n+        iYearOfCenturyField = convertField(c.yearOfCentury(), converted);\n+        iCenturyOfEraField = convertField(c.centuryOfEra(), converted);\n+        iEraField = convertField(c.era(), converted);\n+        iDayOfWeekField = convertField(c.dayOfWeek(), converted);\n+        iDayOfMonthField = convertField(c.dayOfMonth(), converted);\n+        iDayOfYearField = convertField(c.dayOfYear(), converted);\n+        iMonthOfYearField = convertField(c.monthOfYear(), converted);\n+        iWeekOfWeekyearField = convertField(c.weekOfWeekyear(), converted);\n+        iWeekyearField = convertField(c.weekyear(), converted);\n+\n+        iMillisOfSecondField = convertField(c.millisOfSecond(), converted);\n+        iMillisOfDayField = convertField(c.millisOfDay(), converted);\n+        iSecondOfMinuteField = convertField(c.secondOfMinute(), converted);\n+        iSecondOfDayField = convertField(c.secondOfDay(), converted);\n+        iMinuteOfHourField = convertField(c.minuteOfHour(), converted);\n+        iMinuteOfDayField = convertField(c.minuteOfDay(), converted);\n+        iHourOfDayField = convertField(c.hourOfDay(), converted);\n+        iHourOfHalfdayField = convertField(c.hourOfHalfday(), converted);\n+        iClockhourOfDayField = convertField(c.clockhourOfDay(), converted);\n+        iClockhourOfHalfdayField = convertField(c.clockhourOfHalfday(), converted);\n+        iHalfdayOfDayField = convertField(c.halfdayOfDay(), converted);\n+    }\n+\n+    private DurationField convertField(DurationField field, HashMap converted) {\n+        if (field == null || !field.isSupported()) {\n+            return field;\n+        }\n+        if (converted.containsKey(field)) {\n+            return (DurationField)converted.get(field);\n+        }\n+        ZonedDurationField zonedField = new ZonedDurationField(field, iZone);\n+        converted.put(field, zonedField);\n+        return zonedField;\n+    }\n+\n+    private DateTimeField convertField(DateTimeField field, HashMap converted) {\n+        if (field == null || !field.isSupported()) {\n+            return field;\n+        }\n+        if (converted.containsKey(field)) {\n+            return (DateTimeField)converted.get(field);\n+        }\n+        ZonedDateTimeField zonedField =\n+            new ZonedDateTimeField(field, iZone,\n+                                   convertField(field.getDurationField(), converted),\n+                                   convertField(field.getRangeDurationField(), converted),\n+                                   convertField(field.getLeapDurationField(), converted));\n+        converted.put(field, zonedField);\n+        return zonedField;\n     }\n \n     public DateTimeZone getDateTimeZone() {\n \n     public Chronology withDateTimeZone(DateTimeZone zone) {\n         if (zone == null) {\n-            throw new IllegalArgumentException(\"The DateTimeZone must not be null\");\n+            zone = DateTimeZone.getDefault();\n         }\n         if (zone == iZone) {\n             return this;\n         return new ZonedChronology(iChronology, zone);\n     }\n \n+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException\n+    {\n+        return localToUTC(iChronology.getDateOnlyMillis\n+                          (year, monthOfYear, dayOfMonth));\n+    }\n+\n+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return localToUTC(iChronology.getTimeOnlyMillis\n+                          (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        return localToUTC(iChronology.getDateTimeMillis\n+                          (year, monthOfYear, dayOfMonth, millisOfDay));\n+    }\n+\n+    public long getDateTimeMillis(long instant,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return localToUTC(iChronology.getDateTimeMillis\n+                          (instant + iZone.getOffset(instant),\n+                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return localToUTC(iChronology.getDateTimeMillis\n+                          (year, monthOfYear, dayOfMonth, \n+                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n+    }\n+\n+    /**\n+     * @param instant instant from 1970-01-01T00:00:00 local time\n+     */\n+    private long localToUTC(long instant) {\n+        int offset = iZone.getOffsetFromLocal(instant);\n+        instant -= offset;\n+        if (offset != iZone.getOffset(instant)) {\n+            throw new IllegalArgumentException\n+                (\"Illegal instant due to time zone offset transition\");\n+        }\n+        return instant;\n+    }\n+\n     // Milliseconds\n     //------------------------------------------------------------\n \n+    public DurationField millis() {\n+        return iMillisField;\n+    }\n+\n     public DateTimeField millisOfSecond() {\n         return iMillisOfSecondField;\n     }\n     // Seconds\n     //------------------------------------------------------------\n \n+    public DurationField seconds() {\n+        return iSecondsField;\n+    }\n+\n     public DateTimeField secondOfMinute() {\n         return iSecondOfMinuteField;\n     }\n     // Minutes\n     //------------------------------------------------------------\n \n+    public DurationField minutes() {\n+        return iMinutesField;\n+    }\n+\n     public DateTimeField minuteOfHour() {\n         return iMinuteOfHourField;\n     }\n     // Hours\n     //------------------------------------------------------------\n \n+    public DurationField hours() {\n+        return iHoursField;\n+    }\n+\n     public DateTimeField hourOfDay() {\n         return iHourOfDayField;\n     }\n \n     // Day\n     //------------------------------------------------------------\n-    \n+\n+    public DurationField days() {\n+        return iDaysField;\n+    }\n+\n     public DateTimeField dayOfWeek() {\n         return iDayOfWeekField;\n     }\n \n     // Week\n     //------------------------------------------------------------\n-    \n+\n+    public DurationField weeks() {\n+        return iWeeksField;\n+    }\n+\n     public DateTimeField weekOfWeekyear() {\n         return iWeekOfWeekyearField;\n     }\n \n+    public DurationField weekyears() {\n+        return iWeekyearsField;\n+    }\n+\n     public DateTimeField weekyear() {\n         return iWeekyearField;\n     }\n \n     // Month\n     //------------------------------------------------------------\n-    \n+\n+    public DurationField months() {\n+        return iMonthsField;\n+    }\n+\n     public DateTimeField monthOfYear() {\n         return iMonthOfYearField;\n     }\n \n     // Year\n     //------------------------------------------------------------\n-    \n+\n+    public DurationField years() {\n+        return iYearsField;\n+    }\n+\n     public DateTimeField year() {\n         return iYearField;\n     }\n         return iYearOfCenturyField;\n     }\n \n+    public DurationField centuries() {\n+        return iCenturiesField;\n+    }\n+\n     public DateTimeField centuryOfEra() {\n         return iCenturyOfEraField;\n     }\n \n+    public DurationField eras() {\n+        return iErasField;\n+    }\n+\n     public DateTimeField era() {\n         return iEraField;\n+    }\n+\n+    public String toString() {\n+        return iChronology.toString();\n     }\n \n     private void readObject(ObjectInputStream in)\n         setFields();\n     }\n \n+    /*\n+     * Because time durations are typically smaller than time zone offsets, the\n+     * arithmetic methods subtract the original offset. This produces a more\n+     * expected behavior when crossing time zone offset transitions. For dates,\n+     * the new offset is subtracted off. This behavior, if applied to time\n+     * fields, can nullify or reverse an add when crossing a transition.\n+     */\n+\n+    static class ZonedDurationField extends AbstractDurationField {\n+        static final long serialVersionUID = -485345310999208286L;\n+\n+        final DurationField iField;\n+        final boolean iTimeField;\n+        final DateTimeZone iZone;\n+\n+        ZonedDurationField(DurationField field, DateTimeZone zone) {\n+            super(field.getName());\n+            if (!field.isSupported()) {\n+                throw new IllegalArgumentException();\n+            }\n+            iField = field;\n+            iTimeField = useTimeArithmetic(field);\n+            this.iZone = zone;\n+        }\n+\n+        public boolean isPrecise() {\n+            return iTimeField ? iField.isPrecise() : iZone.isFixed();\n+        }\n+\n+        public long getUnitMillis() {\n+            return iField.getUnitMillis();\n+        }\n+\n+        public int getValue(long duration, long instant) {\n+            return iField.getValue(duration, instant + this.iZone.getOffset(instant));\n+        }\n+\n+        public long getValueAsLong(long duration, long instant) {\n+            return iField.getValueAsLong(duration, instant + this.iZone.getOffset(instant));\n+        }\n+\n+        public long getMillis(int value, long instant) {\n+            return iField.getMillis(value, instant + this.iZone.getOffset(instant));\n+        }\n+\n+        public long getMillis(long value, long instant) {\n+            return iField.getMillis(value, instant + this.iZone.getOffset(instant));\n+        }\n+\n+        public long add(long instant, int value) {\n+            int offset = this.iZone.getOffset(instant);\n+            instant = iField.add(instant + offset, value);\n+            return instant - (iTimeField ? offset : this.iZone.getOffsetFromLocal(instant));\n+        }\n+\n+        public long add(long instant, long value) {\n+            int offset = this.iZone.getOffset(instant);\n+            instant = iField.add(instant + offset, value);\n+            return instant - (iTimeField ? offset : this.iZone.getOffsetFromLocal(instant));\n+        }\n+\n+        public int getDifference(long minuendInstant, long subtrahendInstant) {\n+            int offset = this.iZone.getOffset(subtrahendInstant);\n+            return iField.getDifference\n+                (minuendInstant + (iTimeField ? offset : this.iZone.getOffset(minuendInstant)),\n+                 subtrahendInstant + offset);\n+        }\n+\n+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+            int offset = this.iZone.getOffset(subtrahendInstant);\n+            return iField.getDifferenceAsLong\n+                (minuendInstant + (iTimeField ? offset : this.iZone.getOffset(minuendInstant)),\n+                 subtrahendInstant + offset);\n+        }\n+    }\n+\n     /**\n      * A DateTimeField that decorates another to add timezone behaviour.\n      * <p>\n-     * This class converts passed in millis to local wall millis, and \n-     * vice versa on output.\n+     * This class converts passed in instants to local wall time, and vice\n+     * versa on output.\n      */\n-    static class ZonedDateField extends DateTimeField {\n+    static final class ZonedDateTimeField extends AbstractDateTimeField {\n+        static final long serialVersionUID = -3968986277775529794L;\n+\n         final DateTimeField iField;\n         final DateTimeZone iZone;\n-        \n-        ZonedDateField(DateTimeField field, DateTimeZone zone) {\n+        final DurationField iDurationField;\n+        final boolean iTimeField;\n+        final DurationField iRangeDurationField;\n+        final DurationField iLeapDurationField;\n+\n+        ZonedDateTimeField(DateTimeField field,\n+                           DateTimeZone zone,\n+                           DurationField durationField,\n+                           DurationField rangeDurationField,\n+                           DurationField leapDurationField) {\n             super(field.getName());\n+            if (!field.isSupported()) {\n+                throw new IllegalArgumentException();\n+            }\n             iField = field;\n             this.iZone = zone;\n-        }\n-        \n-        public int get(long millis) {\n-            return iField.get(millis + this.iZone.getOffset(millis));\n-        }\n-        \n-        public String getAsText(long millis, Locale locale) {\n-            return iField.getAsText(millis + this.iZone.getOffset(millis), locale);\n-        }\n-        \n-        public String getAsShortText(long millis, Locale locale) {\n-            return iField.getAsShortText(millis + this.iZone.getOffset(millis), locale);\n-        }\n-        \n-        public long add(long millis, int value) {\n-            millis = iField.add(millis + this.iZone.getOffset(millis), value);\n-            return millis - this.iZone.getOffsetFromLocal(millis);\n-        }\n-        \n-        public long add(long millis, long value) {\n-            millis = iField.add(millis + this.iZone.getOffset(millis), value);\n-            return millis - this.iZone.getOffsetFromLocal(millis);\n-        }\n-\n-        public long addWrapped(long millis, int value) {\n-            millis = iField.addWrapped(millis + this.iZone.getOffset(millis), value);\n-            return millis - this.iZone.getOffsetFromLocal(millis);\n-        }\n-\n-        public long getDifference(long minuendMillis, long subtrahendMillis) {\n-            return iField.getDifference(minuendMillis + this.iZone.getOffset(minuendMillis),\n-                                        subtrahendMillis + this.iZone.getOffset(subtrahendMillis));\n-        }\n-\n-        public long set(long millis, int value) {\n-            long offset = this.iZone.getOffset(millis);\n-            \n-            millis = iField.set(millis + offset, value);\n-            long offsetFromLocal = this.iZone.getOffsetFromLocal(millis);\n-            millis -= offsetFromLocal;\n-            \n+            iDurationField = durationField;\n+            iTimeField = useTimeArithmetic(durationField);\n+            iRangeDurationField = rangeDurationField;\n+            iLeapDurationField = leapDurationField;\n+        }\n+\n+        public boolean isLenient() {\n+            return iField.isLenient();\n+        }\n+\n+        public int get(long instant) {\n+            return iField.get(instant + this.iZone.getOffset(instant));\n+        }\n+\n+        public String getAsText(long instant, Locale locale) {\n+            return iField.getAsText(instant + this.iZone.getOffset(instant), locale);\n+        }\n+\n+        public String getAsShortText(long instant, Locale locale) {\n+            return iField.getAsShortText(instant + this.iZone.getOffset(instant), locale);\n+        }\n+\n+        public long add(long instant, int value) {\n+            int offset = this.iZone.getOffset(instant);\n+            instant = iField.add(instant + offset, value);\n+            return instant - (iTimeField ? offset : this.iZone.getOffsetFromLocal(instant));\n+        }\n+\n+        public long add(long instant, long value) {\n+            int offset = this.iZone.getOffset(instant);\n+            instant = iField.add(instant + offset, value);\n+            return instant - (iTimeField ? offset : this.iZone.getOffsetFromLocal(instant));\n+        }\n+\n+        public long addWrapped(long instant, int value) {\n+            int offset = this.iZone.getOffset(instant);\n+            instant = iField.addWrapped(instant + offset, value);\n+            return instant - (iTimeField ? offset : this.iZone.getOffsetFromLocal(instant));\n+        }\n+\n+        public long set(long instant, int value) {\n+            long offset = this.iZone.getOffset(instant);\n+\n+            instant = iField.set(instant + offset, value);\n+            long offsetFromLocal = this.iZone.getOffsetFromLocal(instant);\n+            instant -= offsetFromLocal;\n+\n             if (offset != offsetFromLocal) {\n-                if (get(millis) != value) {\n+                if (get(instant) != value) {\n                     throw new IllegalArgumentException\n                         (\"Illegal value for \" + iField.getName() + \": \" + value);\n                 }\n             }\n-            \n-            return millis;\n-        }\n-        \n-        public long set(long millis, String text, Locale locale) {\n-            millis = iField.set(millis + this.iZone.getOffset(millis), text, locale);\n+\n+            return instant;\n+        }\n+\n+        public long set(long instant, String text, Locale locale) {\n+            instant = iField.set(instant + this.iZone.getOffset(instant), text, locale);\n             // Cannot verify that new value stuck because set may be lenient.\n-            return millis - this.iZone.getOffsetFromLocal(millis);\n-        }\n-        \n-        public boolean isLeap(long millis) {\n-            return iField.isLeap(millis + this.iZone.getOffset(millis));\n-        }\n-\n-        public int getLeapAmount(long millis) {\n-            return iField.getLeapAmount(millis + this.iZone.getOffset(millis));\n-        }\n-        \n-        public long getUnitMillis() {\n-            return iField.getUnitMillis();\n-        }\n-\n-        public long getRangeMillis() {\n-            return iField.getRangeMillis();\n+            return instant - this.iZone.getOffsetFromLocal(instant);\n+        }\n+\n+        public int getDifference(long minuendInstant, long subtrahendInstant) {\n+            int offset = this.iZone.getOffset(subtrahendInstant);\n+            return iField.getDifference\n+                (minuendInstant + (iTimeField ? offset : this.iZone.getOffset(minuendInstant)),\n+                 subtrahendInstant + offset);\n+        }\n+\n+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+            int offset = this.iZone.getOffset(subtrahendInstant);\n+            return iField.getDifferenceAsLong\n+                (minuendInstant + (iTimeField ? offset : this.iZone.getOffset(minuendInstant)),\n+                 subtrahendInstant + offset);\n+        }\n+\n+        public final DurationField getDurationField() {\n+            return iDurationField;\n+        }\n+\n+        public final DurationField getRangeDurationField() {\n+            return iRangeDurationField;\n+        }\n+\n+        public boolean isLeap(long instant) {\n+            return iField.isLeap(instant + this.iZone.getOffset(instant));\n+        }\n+\n+        public int getLeapAmount(long instant) {\n+            return iField.getLeapAmount(instant + this.iZone.getOffset(instant));\n+        }\n+\n+        public final DurationField getLeapDurationField() {\n+            return iLeapDurationField;\n+        }\n+\n+        public long roundFloor(long instant) {\n+            int offset = this.iZone.getOffset(instant);\n+            instant = iField.roundFloor(instant + offset);\n+            return instant - (iTimeField ? offset : this.iZone.getOffsetFromLocal(instant));\n+        }\n+\n+        public long roundCeiling(long instant) {\n+            int offset = this.iZone.getOffset(instant);\n+            instant = iField.roundCeiling(instant + offset);\n+            return instant - (iTimeField ? offset : this.iZone.getOffsetFromLocal(instant));\n+        }\n+\n+        public long remainder(long instant) {\n+            return iField.remainder(instant + this.iZone.getOffset(instant));\n         }\n \n         public int getMinimumValue() {\n             return iField.getMinimumValue();\n         }\n-        \n-        public int getMinimumValue(long millis) {\n-            return iField.getMinimumValue(millis + this.iZone.getOffset(millis));\n-        }\n-        \n+\n+        public int getMinimumValue(long instant) {\n+            return iField.getMinimumValue(instant + this.iZone.getOffset(instant));\n+        }\n+\n         public int getMaximumValue() {\n             return iField.getMaximumValue();\n         }\n-        \n-        public int getMaximumValue(long millis) {\n-            return iField.getMaximumValue(millis + this.iZone.getOffset(millis));\n-        }\n-        \n-        public long roundFloor(long millis) {\n-            millis = iField.roundFloor(millis + this.iZone.getOffset(millis));\n-            return millis - this.iZone.getOffsetFromLocal(millis);\n-        }\n-        \n-        public long roundCeiling(long millis) {\n-            millis = iField.roundCeiling(millis + this.iZone.getOffset(millis));\n-            return millis - this.iZone.getOffsetFromLocal(millis);\n-        }\n-\n-        public long remainder(long millis) {\n-            millis = iField.remainder(millis + this.iZone.getOffset(millis));\n-            return millis - this.iZone.getOffsetFromLocal(millis);\n+\n+        public int getMaximumValue(long instant) {\n+            return iField.getMaximumValue(instant + this.iZone.getOffset(instant));\n         }\n \n         public int getMaximumTextLength(Locale locale) {\n             return iField.getMaximumTextLength(locale);\n         }\n-        \n+\n         public int getMaximumShortTextLength(Locale locale) {\n             return iField.getMaximumShortTextLength(locale);\n         }\n     }\n \n-    static class ZonedTimeField extends ZonedDateField {\n-        ZonedTimeField(DateTimeField field, DateTimeZone zone) {\n-            super(field, zone);\n-        }\n-\n-        // Because time fields are smaller than time zone offsets, override the\n-        // arithmetic methods to follow more expected behavior when crossing\n-        // time zone offset transitions. The original add method can nullify or\n-        // reverse an add when crossing a transition.\n-\n-        public long add(long millis, int value) {\n-            int offset = this.iZone.getOffset(millis);\n-            return iField.add(millis + offset, value) - offset;\n-        }\n-        \n-        public long add(long millis, long value) {\n-            int offset = this.iZone.getOffset(millis);\n-            return iField.add(millis + offset, value) - offset;\n-        }\n-\n-        public long addWrapped(long millis, int value) {\n-            int offset = this.iZone.getOffset(millis);\n-            return iField.addWrapped(millis + offset, value) - offset;\n-        }\n-\n-        public long getDifference(long minuendMillis, long subtrahendMillis) {\n-            int offset = this.iZone.getOffset(subtrahendMillis);\n-            return iField.getDifference(minuendMillis + offset, subtrahendMillis + offset);\n-        }\n-    }\n }\n--- a/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistChronology.java\n import java.util.Map;\n \n import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.chrono.DelegateChronology;\n+import org.joda.time.DurationField;\n+import org.joda.time.chrono.DecoratedChronology;\n+import org.joda.time.chrono.DividedDateTimeField;\n+import org.joda.time.chrono.LimitChronology;\n import org.joda.time.chrono.OffsetDateTimeField;\n+import org.joda.time.chrono.RemainderDateTimeField;\n import org.joda.time.chrono.gj.GJChronology;\n \n /**\n  * in the year. This class is compatable with the BuddhistCalendar class \n  * supplied by Sun.\n  * <p>\n- * At present the century fields are unsupported.\n+ * BuddhistChronology is thread-safe and immutable.\n  *\n  * @author Stephen Colebourne\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public final class BuddhistChronology extends DelegateChronology {\n+public final class BuddhistChronology extends DecoratedChronology {\n     \n+    static final long serialVersionUID = -3474595157769370126L;\n+\n     /**\n      * Constant value for 'Buddhist Era', equivalent to the value returned\n      * for AD/CE.\n     /** Number of years difference in calendars. */\n     private static final int BUDDHIST_OFFSET = 543;\n \n-    /** UTC instance of the chronology */\n-    private static final BuddhistChronology INSTANCE_UTC =\n-        new BuddhistChronology(GJChronology.getInstance(DateTimeZone.UTC, null, false));\n-\n     /** Cache of zone to chronology */\n     private static final Map cCache = new HashMap();\n-    static {\n-        cCache.put(DateTimeZone.UTC, INSTANCE_UTC);\n-    }\n+\n+    /** UTC instance of the chronology */\n+    private static final BuddhistChronology INSTANCE_UTC = getInstance(DateTimeZone.UTC);\n \n     /**\n      * Standard instance of a Buddhist Chronology, that matches\n      * GregorianJulian calendar rules with a cutover date.\n      *\n      * @param zone  the time zone to use, null is default\n-     * @throws IllegalArgumentException if the zone is null\n      */\n     public static synchronized BuddhistChronology getInstance(DateTimeZone zone) {\n         if (zone == null) {\n         }\n         return chrono;\n     }\n-    \n+\n     // Constructors and instance variables\n     //-----------------------------------------------------------------------\n     // Fields are transient because readResolve will always return a cached instance.\n     private transient DateTimeField iYearField;\n     private transient DateTimeField iWeekyearField;\n+    private transient DateTimeField iYearOfCenturyField;\n+    private transient DateTimeField iCenturyOfEraField;\n     \n     /**\n      * Restricted constructor.\n      */\n-    private BuddhistChronology(GJChronology gjChronology) {\n-        super(gjChronology);\n-        DateTimeField field = gjChronology.year();\n-        iYearField = new OffsetDateTimeField(field.getName(), field, BUDDHIST_OFFSET);\n-        field = gjChronology.weekyear();\n-        iWeekyearField = new OffsetDateTimeField(field.getName(), field, BUDDHIST_OFFSET);\n+    private BuddhistChronology(Chronology chronology) {\n+        this(chronology, false);\n+    }\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private BuddhistChronology(Chronology chronology, boolean unlimited) {\n+        // BuddhistChronology is constructed in three magic steps:\n+        //\n+        // 1. Wrap a BuddhistChronology with proper offset, but no range limits\n+        // 2. Wrap a LimitChronology, which will copy and wrap all the fields\n+        // 3. Wrap a BuddhistChronology which purely delegates to LimitChronology\n+        //\n+        // Why is it done this way? So that the LimitChronology error message\n+        // shows the limit printed using BuddhistChronology fields. This extra\n+        // wrapping does not impose any additional overhead when accessing\n+        // fields because LimitChronology copies them.\n+        //\n+        // Is this a good design? No.\n+\n+        super(unlimited ? chronology : limitChronology(chronology));\n+\n+        DateTimeField field = getWrappedChronology().year();\n+        if (unlimited) {\n+            field = new OffsetDateTimeField(field, field.getName(), BUDDHIST_OFFSET);\n+        }\n+        iYearField = field;\n+            \n+        field = getWrappedChronology().weekyear();\n+        if (unlimited) {\n+            field = new OffsetDateTimeField(field, field.getName(), BUDDHIST_OFFSET);\n+        }\n+        iWeekyearField = field;\n+\n         // All other fields delegated to GJ\n     }\n+\n+    /**\n+     * Returns a LimitChronology that wraps an unlimited BuddhistChronology\n+     * that wraps the given Chronology.\n+     */    \n+    private static Chronology limitChronology(Chronology chrono) {\n+        chrono = new BuddhistChronology(chrono, true);\n+        DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n+        return new LimitChronology(chrono, lowerLimit, null);\n+    }\n     \n     /**\n      * Serialization singleton\n      */\n     private Object readResolve() {\n-        return getInstance(getChronology().getDateTimeZone());\n+        return getInstance(getWrappedChronology().getDateTimeZone());\n     }\n \n     // Conversion\n         return getInstance(zone);\n     }\n \n+    // Millis\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the millis duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField millis() {\n+        return getWrappedChronology().millis();\n+    }\n+\n+    /**\n+     * Get the millis of second field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField millisOfSecond() {\n+        return getWrappedChronology().millisOfSecond();\n+    }\n+\n+    /**\n+     * Get the millis of day field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField millisOfDay() {\n+        return getWrappedChronology().millisOfDay();\n+    }\n+\n+    // Seconds\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the seconds duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField seconds() {\n+        return getWrappedChronology().seconds();\n+    }\n+\n+    /**\n+     * Get the second of minute field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField secondOfMinute() {\n+        return getWrappedChronology().secondOfMinute();\n+    }\n+\n+    /**\n+     * Get the second of day field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField secondOfDay() {\n+        return getWrappedChronology().secondOfDay();\n+    }\n+\n+    // Minutes\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the minutes duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField minutes() {\n+        return getWrappedChronology().minutes();\n+    }\n+\n+    /**\n+     * Get the minute of hour field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField minuteOfHour() {\n+        return getWrappedChronology().minuteOfHour();\n+    }\n+\n+    /**\n+     * Get the minute of day field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField minuteOfDay() {\n+        return getWrappedChronology().minuteOfDay();\n+    }\n+\n+    // Hours\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the hours duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField hours() {\n+        return getWrappedChronology().hours();\n+    }\n+\n+    /**\n+     * Get the hour of day (0-23) field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField hourOfDay() {\n+        return getWrappedChronology().hourOfDay();\n+    }\n+\n+    /**\n+     * Get the hour of day (offset to 1-24) field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField clockhourOfDay() {\n+        return getWrappedChronology().clockhourOfDay();\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (0-11) field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField hourOfHalfday() {\n+        return getWrappedChronology().hourOfHalfday();\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (offset to 1-12) field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField clockhourOfHalfday() {\n+        return getWrappedChronology().clockhourOfHalfday();\n+    }\n+\n+    /**\n+     * Get the AM(0) PM(1) field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField halfdayOfDay() {\n+        return getWrappedChronology().halfdayOfDay();\n+    }\n+\n+    // Day\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the days duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField days() {\n+        return getWrappedChronology().days();\n+    }\n+\n+    /**\n+     * Get the day of week field for this chronology.\n+     *\n+     * @return DateTimeField\n+     */\n+    public DateTimeField dayOfWeek() {\n+        return getWrappedChronology().dayOfWeek();\n+    }\n+\n+    /**\n+     * Get the day of month field for this chronology.\n+     *\n+     * @return DateTimeField\n+     */\n+    public DateTimeField dayOfMonth() {\n+        return getWrappedChronology().dayOfMonth();\n+    }\n+\n+    /**\n+     * Get the day of year field for this chronology.\n+     *\n+     * @return DateTimeField\n+     */\n+    public DateTimeField dayOfYear() {\n+        return getWrappedChronology().dayOfYear();\n+    }\n+\n     // Week\n-    //-----------------------------------------------------------------------\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the weeks duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField weeks() {\n+        return getWrappedChronology().weeks();\n+    }\n+\n+    /**\n+     * Get the week of a week based year field for this chronology.\n+     *\n+     * @return DateTimeField\n+     */\n+    public DateTimeField weekOfWeekyear() {\n+        return getWrappedChronology().weekOfWeekyear();\n+    }\n+\n+    /**\n+     * Get the weekyears duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField weekyears() {\n+        return getWrappedChronology().weekyears();\n+    }\n+\n     /**\n      * Get the year of a week based year field for this chronology.\n      *\n         return iWeekyearField;\n     }\n \n+    // Month\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the months duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField months() {\n+        return getWrappedChronology().months();\n+    }\n+\n+    /**\n+     * Get the month of year field for this chronology.\n+     *\n+     * @return DateTimeField\n+     */\n+    public DateTimeField monthOfYear() {\n+        return getWrappedChronology().monthOfYear();\n+    }\n+\n     // Year\n-    //-----------------------------------------------------------------------\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the years duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField years() {\n+        return getWrappedChronology().years();\n+    }\n+\n     /**\n      * Get the year field for this chronology.\n      * \n      * @return DateTimeField\n      */\n     public DateTimeField year() {\n-        // TODO block negative years\n         return iYearField;\n     }\n \n      * @return DateTimeField\n      */\n     public DateTimeField yearOfEra() {\n-        // TODO block negative years\n         return iYearField;\n     }\n \n      * Get the year of century field for this chronology.\n      * \n      * @return DateTimeField\n-     * @throws UnsupportedOperationException always\n      */\n     public DateTimeField yearOfCentury() {\n-        // TODO\n-        throw new UnsupportedOperationException(\"yearOfCentury is unsupported for \" + getClass().getName());\n+        if (iYearOfCenturyField == null) {\n+            DateTimeField tempField = new RemainderDateTimeField\n+                ((DividedDateTimeField)centuryOfEra(), \"\");\n+            iYearOfCenturyField = new OffsetDateTimeField(tempField, \"yearOfCentury\", 1);\n+        }\n+        return iYearOfCenturyField;\n+    }\n+\n+    /**\n+     * Get the centuries duration field for this chronology.\n+     * \n+     * @return DurationField\n+     */\n+    public DurationField centuries() {\n+        return getWrappedChronology().centuries();\n     }\n \n     /**\n      * Get the century of era field for this chronology.\n      * \n      * @return DateTimeField\n-     * @throws UnsupportedOperationException always\n      */\n     public DateTimeField centuryOfEra() {\n-        // TODO\n-        throw new UnsupportedOperationException(\"centuryOfEra is unsupported for \" + getClass().getName());\n-    }\n-\n-    // Misc\n-    //-----------------------------------------------------------------------\n+        if (iCenturyOfEraField == null) {\n+            DateTimeField tempField = new OffsetDateTimeField(yearOfEra(), \"\", 99);\n+            iCenturyOfEraField = new DividedDateTimeField\n+                (tempField, \"centuryOfEra\", \"centuries\", 100);\n+        }\n+        return iCenturyOfEraField;\n+    }\n+\n     /**\n      * Get the era field for this chronology.\n      * \n     public DateTimeField era() {\n         return BuddhistEraDateTimeField.INSTANCE;\n     }\n-    \n+\n     // Output\n     //-----------------------------------------------------------------------\n     /**\n      * @return a debugging string\n      */\n     public String toString() {\n+        String str = \"BuddhistChronology\";\n         DateTimeZone zone = getDateTimeZone();\n-        return \"BuddhistChronology[\" + (zone == null ? \"\" : zone.getID()) + \"]\";\n+        if (zone != null) {\n+            str = str + '[' + zone.getID() + ']';\n+        }\n+        return str;\n     }\n    \n }\n--- a/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistEraDateTimeField.java\n import java.util.Locale;\n \n import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.chrono.AbstractDateTimeField;\n+import org.joda.time.chrono.UnsupportedDurationField;\n+import org.joda.time.chrono.Utils;\n \n /**\n  * Provides time calculations for the buddhist era component of time.\n  *\n  * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n  * @since 1.0\n  */\n-final class BuddhistEraDateTimeField extends DateTimeField {\n+final class BuddhistEraDateTimeField extends AbstractDateTimeField {\n     \n+    static final long serialVersionUID = -9175876774456816364L;\n+\n     /**\n      * Singleton instance of BuddhistYearDateTimeField\n      */\n         return INSTANCE;\n     }\n \n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n     /**\n      * Get the Era component of the specified time instant.\n      * \n      * @param millis  the time instant in millis to query.\n      * @return the era extracted from the input.\n      */\n-    public int get(long millis) {\n+    public int get(long instant) {\n         return BuddhistChronology.BE;\n-    }\n-\n-    /**\n-     * Unsupported - add the specified eras to the specified time instant.\n-     * \n-     * @param millis  the time instant in millis to update.\n-     * @param years  the years to add (can be negative).\n-     * @return the updated time instant.\n-     */\n-    public long add(long millis, int era) {\n-        throw new UnsupportedOperationException(\"Adding to Era field is unsupported\");\n-    }\n-\n-    /**\n-     * Unsupported - add the specified eras to the specified time instant.\n-     * \n-     * @param millis  the time instant in millis to update.\n-     * @param years  the years to add (can be negative).\n-     * @return the updated time instant.\n-     */\n-    public long add(long millis, long era) {\n-        throw new UnsupportedOperationException(\"Adding to Era field is unsupported\");\n-    }\n-\n-    /**\n-     * Unsupported - add the specified eras to the specified time instant.\n-     * \n-     * @param millis  the time instant in millis to update.\n-     * @param era  the era to add (can be negative).\n-     * @return the updated time instant.\n-     */\n-    public long addWrapped(long millis, int era) {\n-        throw new UnsupportedOperationException(\"Adding to Era field is unsupported\");\n-    }\n-\n-    public long getDifference(long minuendMillis, long subtrahendMillis) {\n-        throw new UnsupportedOperationException(\"Era field difference is unsupported\");\n     }\n \n     /**\n      * Set the Era component of the specified time instant.\n      * \n      * @param millis  the time instant in millis to update.\n-     * @param era  the era (BuddhistChonology.BE) to update the time to.\n+     * @param era  the era (BuddhistChronology.BE) to update the time to.\n      * @return the updated time instant.\n      * @throws IllegalArgumentException  if era is invalid.\n      */\n-    public long set(long millis, int era) {\n-        super.verifyValueBounds(era, getMinimumValue(), getMaximumValue());\n+    public long set(long instant, int era) {\n+        Utils.verifyValueBounds(this, era, getMinimumValue(), getMaximumValue());\n \n-        return millis;\n+        return instant;\n     }\n \n-    public long getUnitMillis() {\n-        // Should actually be double this, but that is not possible since Java\n-        // doesn't support unsigned types.\n+    /**\n+     * @see org.joda.time.DateTimeField#set(long, String, Locale)\n+     */\n+    public long set(long instant, String text, Locale locale) {\n+        if (\"BE\".equals(text) == false) {\n+            throw new IllegalArgumentException(\"Invalid era text: \" + text);\n+        }\n+        return instant;\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return Long.MIN_VALUE;\n+    }\n+\n+    public long roundCeiling(long instant) {\n         return Long.MAX_VALUE;\n     }\n \n-    public long getRangeMillis() {\n-        // Should actually be double this, but that is not possible since Java\n-        // doesn't support unsigned types.\n-        return Long.MAX_VALUE;\n+    public long roundHalfFloor(long instant) {\n+        return Long.MIN_VALUE;\n+    }\n+\n+    public long roundHalfCeiling(long instant) {\n+        return Long.MIN_VALUE;\n+    }\n+\n+    public long roundHalfEven(long instant) {\n+        return Long.MIN_VALUE;\n+    }\n+\n+    public DurationField getDurationField() {\n+        return UnsupportedDurationField.INSTANCE;\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return null;\n     }\n \n     public int getMinimumValue() {\n     /**\n      * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)\n      */\n-    public String getAsShortText(long millis, Locale locale) {\n+    public String getAsShortText(long instant, Locale locale) {\n         return \"BE\";\n     }\n     \n     /**\n      * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)\n      */\n-    public String getAsText(long millis, Locale locale) {\n+    public String getAsText(long instant, Locale locale) {\n         return \"BE\";\n     }\n \n         return 2;\n     }\n \n-    /**\n-     * @see org.joda.time.DateTimeField#set(long, String, Locale)\n-     */\n-    public long set(long millis, String text, Locale locale) {\n-        if (\"BE\".equals(text) == false) {\n-            throw new IllegalArgumentException(\"Invalid era text: \" + text);\n-        }\n-        return millis;    \n-    }\n-    \n-\n-    /**\n-     * Unsupported.\n-     * @throws UnsupportedOperationException always\n-     */\n-    public long roundFloor(long millis) {\n-        throw new UnsupportedOperationException(\"Rounding an Era field is unsupported\");\n-    }\n-\n-    /**\n-     * Unsupported.\n-     * @throws UnsupportedOperationException always\n-     */\n-    public long remainder(long millis) {\n-        throw new UnsupportedOperationException(\"Calculating remainder from Era field is unsupported\");\n-    }\n }\n--- a/JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n+import org.joda.time.chrono.AbstractDateTimeField;\n+import org.joda.time.chrono.DecoratedDurationField;\n \n /**\n  * Chronology for supporting the cutover from the Julian calendar to the\n  * @since 1.0\n  */\n final class CutoverChronology extends GJChronology {\n+\n+    static final long serialVersionUID = -2545574827706931671L;\n+\n     /**\n      * Convert a datetime from one chronology to another.\n      */\n-    private static long convert(long millis, Chronology from, Chronology to) {\n-        if (from == to) {\n-            return millis;\n-        }\n-\n-        int year = from.year().get(millis);\n-        int monthOfYear = from.monthOfYear().get(millis);\n-        int dayOfMonth = from.dayOfMonth().get(millis);\n-        int millisOfDay = from.millisOfDay().get(millis);\n-\n-        millis = to.year().set(0, year);\n-        millis = to.monthOfYear().set(millis, monthOfYear);\n-        millis = to.dayOfMonth().set(millis, dayOfMonth);\n-        millis = to.millisOfDay().set(millis, millisOfDay);\n-\n-        return millis;\n+    private static long convert(long instant, Chronology from, Chronology to) {\n+        return to.getDateTimeMillis\n+            (from.year().get(instant),\n+             from.monthOfYear().get(instant),\n+             from.dayOfMonth().get(instant),\n+             from.millisOfDay().get(instant));\n     }\n \n     private static void checkUTC(Chronology chrono) {\n     private final GJChronology iJulianChronology;\n     private final GJChronology iGregorianChronology;\n \n-    final long iCutoverMillis;\n-    transient final long iGapMillis;\n+    final long iCutoverInstant;\n+    transient final long iGapDuration;\n \n     /**\n      * @param julian chronology used before the cutover instant\n      * @param gregorian chronology used at and after the cutover instant\n-     * @param cutoverMillis instant when the gregorian chronology began\n+     * @param cutoverInstant instant when the gregorian chronology began\n      */\n-    CutoverChronology(JulianChronology julian, GregorianChronology gregorian, long cutoverMillis) {\n+    CutoverChronology(JulianChronology julian, GregorianChronology gregorian, long cutoverInstant) {\n         checkUTC(julian);\n         checkUTC(gregorian);\n \n \n         iJulianChronology = julian;\n         iGregorianChronology = gregorian;\n-        iCutoverMillis = cutoverMillis;\n+        iCutoverInstant = cutoverInstant;\n \n         // Compute difference between the chronologies at the cutover instant\n-        iGapMillis = cutoverMillis - julianToGregorian(cutoverMillis);\n+        iGapDuration = cutoverInstant - julianToGregorian(cutoverInstant);\n \n         // Begin field definitions.\n \n+        // First just copy all the Gregorian fields and then override those\n+        // that need special attention.\n+        copyFields(gregorian);\n+        \n         // Assuming cutover is at midnight, all time of day fields can be\n         // gregorian since they are unaffected by cutover.\n-        iMillisOfSecondField = gregorian.millisOfSecond();\n-        iMillisOfDayField = gregorian.millisOfDay();\n-        iSecondOfMinuteField = gregorian.secondOfMinute();\n-        iSecondOfDayField = gregorian.secondOfDay();\n-        iMinuteOfHourField = gregorian.minuteOfHour();\n-        iMinuteOfDayField = gregorian.minuteOfDay();\n-        iHourOfDayField = gregorian.hourOfDay();\n-        iHourOfHalfdayField = gregorian.hourOfHalfday();\n-        iClockhourOfDayField = gregorian.clockhourOfDay();\n-        iClockhourOfHalfdayField = gregorian.clockhourOfHalfday();\n-        iHalfdayOfDayField = gregorian.halfdayOfDay();\n \n         // Verify assumption.\n-        if (gregorian.millisOfDay().get(cutoverMillis) == 0) {\n+        if (gregorian.millisOfDay().get(cutoverInstant) == 0) {\n             // Cutover is sometime in the day, so cutover fields are required\n             // for time of day.\n \n         }\n \n         // These fields just require basic cutover support.\n-        iEraField = new CutoverField(julian.era(), gregorian.era());\n-        iDayOfMonthField = new CutoverField(julian.dayOfMonth(), gregorian.dayOfMonth());\n-\n-        // These fields require special attention when add is called since they\n-        // internally call set.\n-        iYearField = new CutoverVarField(julian.year(), gregorian.year());\n-        iYearOfEraField = new CutoverVarField(julian.yearOfEra(), gregorian.yearOfEra());\n-        iYearOfCenturyField = new CutoverVarField(julian.yearOfCentury(), gregorian.yearOfCentury());\n-        iCenturyOfEraField = new CutoverVarField(julian.centuryOfEra(), gregorian.centuryOfEra());\n-        iMonthOfYearField = new CutoverVarField(julian.monthOfYear(), gregorian.monthOfYear());\n-        iWeekyearField = new CutoverVarField(julian.weekyear(), gregorian.weekyear());\n+        {\n+            iEraField = new CutoverField(julian.era(), gregorian.era());\n+            iDayOfMonthField = new CutoverField(julian.dayOfMonth(), gregorian.dayOfMonth());\n+        }\n \n         // DayOfYear and weekOfWeekyear require special handling since cutover\n         // year has fewer days and weeks. Extend the cutover to the start of\n         // the cutover year.\n \n         {\n-            long cutover = gregorian.year().roundCeiling(iCutoverMillis);\n+            long cutover = gregorian.year().roundCeiling(iCutoverInstant);\n             iDayOfYearField = new CutoverField\n                 (julian.dayOfYear(), gregorian.dayOfYear(), cutover);\n         }\n \n         {\n-            long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);\n+            long cutover = gregorian.weekyear().roundCeiling(iCutoverInstant);\n             iWeekOfWeekyearField = new CutoverField\n                 (julian.weekOfWeekyear(), gregorian.weekOfWeekyear(), cutover);\n         }\n \n-        // Day of week is unaffected by cutover. Either julian or gregorian will work.\n-        iDayOfWeekField = gregorian.dayOfWeek();\n+        // These fields are special because they have imprecise durations. The\n+        // family of addition methods need special attention. Override affected\n+        // duration fields as well.\n+        {\n+            iYearField = new ImpreciseCutoverField(julian.year(), gregorian.year());\n+            iYearsField = iYearField.getDurationField();\n+            iYearOfEraField = new ImpreciseCutoverField\n+                (julian.yearOfEra(), gregorian.yearOfEra(), iYearsField);\n+            iYearOfCenturyField = new ImpreciseCutoverField\n+                (julian.yearOfCentury(), gregorian.yearOfCentury(), iYearsField);\n+            \n+            iCenturyOfEraField = new ImpreciseCutoverField(julian.centuryOfEra(), gregorian.centuryOfEra());\n+            iCenturiesField = iCenturyOfEraField.getDurationField();\n+            \n+            iMonthOfYearField = new ImpreciseCutoverField(julian.monthOfYear(), gregorian.monthOfYear());\n+            iMonthsField = iMonthOfYearField.getDurationField();\n+            \n+            iWeekyearField = new ImpreciseCutoverField(julian.weekyear(), gregorian.weekyear());\n+            iWeekyearsField = iWeekyearField.getDurationField();\n+        }\n     }\n \n     public Chronology withUTC() {\n         return this;\n     }\n \n+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException\n+    {\n+        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n+    }\n+\n+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        // Time fields are same for Julian and Gregorian.\n+        return iGregorianChronology.getTimeOnlyMillis\n+            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        // Assume date is Gregorian.\n+        long instant = iGregorianChronology.getDateTimeMillis\n+            (year, monthOfYear, dayOfMonth, millisOfDay);\n+        if (instant < iCutoverInstant) {\n+            // Maybe it's Julian.\n+            instant = iJulianChronology.getDateTimeMillis\n+                (year, monthOfYear, dayOfMonth, millisOfDay);\n+            if (instant >= iCutoverInstant) {\n+                // Okay, it's in the illegal cutover gap.\n+                throw new IllegalArgumentException(\"Specified date does not exist\");\n+            }\n+        }\n+        return instant;\n+    }\n+\n+    public long getDateTimeMillis(long instant,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return getDateOnlyMillis(instant)\n+            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0)\n+            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n     public long getGregorianJulianCutoverMillis() {\n-        return iCutoverMillis;\n+        return iCutoverInstant;\n     }\n \n     public boolean isCenturyISO() {\n         return iGregorianChronology.getMinimumDaysInFirstWeek();\n     }\n \n-    long julianToGregorian(long millis) {\n-        return convert(millis, iJulianChronology, iGregorianChronology);\n-    }\n-\n-    long gregorianToJulian(long millis) {\n-        return convert(millis, iGregorianChronology, iJulianChronology);\n+    long julianToGregorian(long instant) {\n+        return convert(instant, iJulianChronology, iGregorianChronology);\n+    }\n+\n+    long gregorianToJulian(long instant) {\n+        return convert(instant, iGregorianChronology, iJulianChronology);\n     }\n \n     /**\n      * This basic cutover field adjusts calls to 'get' and 'set' methods, and\n      * assumes that calls to add and addWrapped are unaffected by the cutover.\n      */\n-    private class CutoverField extends DateTimeField {\n+    private class CutoverField extends AbstractDateTimeField {\n+        static final long serialVersionUID = 3528501219481026402L;\n+\n         final DateTimeField iJulianField;\n         final DateTimeField iGregorianField;\n         final long iCutover;\n+\n+        protected DurationField iDurationField;\n \n         /**\n          * @param julianField field from the chronology used before the cutover instant\n          * @param gregorianField field from the chronology used at and after the cutover\n          */\n         CutoverField(DateTimeField julianField, DateTimeField gregorianField) {\n+            this(julianField, gregorianField, iCutoverInstant);\n+        }\n+\n+        CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverInstant) {\n             super(gregorianField.getName());\n             iJulianField = julianField;\n             iGregorianField = gregorianField;\n-            iCutover = iCutoverMillis;\n-        }\n-\n-        CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\n-            super(gregorianField.getName());\n-            iJulianField = julianField;\n-            iGregorianField = gregorianField;\n-            iCutover = cutoverMillis;\n-        }\n-\n-        public int get(long millis) {\n-            if (millis >= iCutover) {\n-                return iGregorianField.get(millis);\n-            } else {\n-                return iJulianField.get(millis);\n-            }\n-        }\n-\n-        public String getAsText(long millis, Locale locale) {\n-            if (millis >= iCutover) {\n-                return iGregorianField.getAsText(millis, locale);\n-            } else {\n-                return iJulianField.getAsText(millis, locale);\n-            }\n-        }\n-\n-        public String getAsShortText(long millis, Locale locale) {\n-            if (millis >= iCutover) {\n-                return iGregorianField.getAsShortText(millis, locale);\n-            } else {\n-                return iJulianField.getAsShortText(millis, locale);\n-            }\n-        }\n-\n-        public long add(long millis, int value) {\n-            return iGregorianField.add(millis, value);\n-        }\n-\n-        public long add(long millis, long value) {\n-            return iGregorianField.add(millis, value);\n-        }\n-\n-        public long addWrapped(long millis, int value) {\n-            return iGregorianField.addWrapped(millis, value);\n-        }\n-\n-        public long getDifference(long minuendMillis, long subtrahendMillis) {\n-            return iGregorianField.getDifference(minuendMillis, subtrahendMillis);\n-        }\n-\n-        public long set(long millis, int value) {\n-            if (millis >= iCutover) {\n-                millis = iGregorianField.set(millis, value);\n-                if (millis < iCutover) {\n-                    // Only adjust if gap fully crossed.\n-                    if (millis + iGapMillis < iCutover) {\n-                        millis = gregorianToJulian(millis);\n+            iCutover = cutoverInstant;\n+            // Although average length of Julian and Gregorian years differ,\n+            // use the Gregorian duration field because it is more accurate.\n+            iDurationField = gregorianField.getDurationField();\n+        }\n+\n+        public boolean isLenient() {\n+            return false;\n+        }\n+\n+        public int get(long instant) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.get(instant);\n+            } else {\n+                return iJulianField.get(instant);\n+            }\n+        }\n+\n+        public String getAsText(long instant, Locale locale) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.getAsText(instant, locale);\n+            } else {\n+                return iJulianField.getAsText(instant, locale);\n+            }\n+        }\n+\n+        public String getAsShortText(long instant, Locale locale) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.getAsShortText(instant, locale);\n+            } else {\n+                return iJulianField.getAsShortText(instant, locale);\n+            }\n+        }\n+\n+        public long add(long instant, int value) {\n+            return iGregorianField.add(instant, value);\n+        }\n+\n+        public long add(long instant, long value) {\n+            return iGregorianField.add(instant, value);\n+        }\n+\n+        public int getDifference(long minuendInstant, long subtrahendInstant) {\n+            return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n+        }\n+\n+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+            return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+        }\n+\n+        public long set(long instant, int value) {\n+            if (instant >= iCutover) {\n+                instant = iGregorianField.set(instant, value);\n+                if (instant < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant + iGapDuration < iCutover) {\n+                        instant = gregorianToJulian(instant);\n                     }\n                     // Verify that new value stuck.\n-                    if (get(millis) != value) {\n+                    if (get(instant) != value) {\n                         throw new IllegalArgumentException\n                             (\"Illegal value for \" + iGregorianField.getName() + \": \" + value);\n                     }\n                 }\n             } else {\n-                millis = iJulianField.set(millis, value);\n-                if (millis >= iCutover) {\n-                    // Only adjust if gap fully crossed.\n-                    if (millis - iGapMillis >= iCutover) {\n-                        millis = julianToGregorian(millis);\n+                instant = iJulianField.set(instant, value);\n+                if (instant >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant - iGapDuration >= iCutover) {\n+                        instant = julianToGregorian(instant);\n                     }\n                     // Verify that new value stuck.\n-                    if (get(millis) != value) {\n+                    if (get(instant) != value) {\n                         throw new IllegalArgumentException\n                             (\"Illegal value for \" + iJulianField.getName() + \": \" + value);\n                     }\n                 }\n             }\n-            return millis;\n-        }\n-\n-        public long set(long millis, String text, Locale locale) {\n-            if (millis >= iCutover) {\n-                millis = iGregorianField.set(millis, text, locale);\n-                if (millis < iCutover) {\n-                    // Only adjust if gap fully crossed.\n-                    if (millis + iGapMillis < iCutover) {\n-                        millis = gregorianToJulian(millis);\n+            return instant;\n+        }\n+\n+        public long set(long instant, String text, Locale locale) {\n+            if (instant >= iCutover) {\n+                instant = iGregorianField.set(instant, text, locale);\n+                if (instant < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant + iGapDuration < iCutover) {\n+                        instant = gregorianToJulian(instant);\n                     }\n                     // Cannot verify that new value stuck because set may be lenient.\n                 }\n             } else {\n-                millis = iJulianField.set\n-                    (millis, text, locale);\n-                if (millis >= iCutover) {\n-                    // Only adjust if gap fully crossed.\n-                    if (millis - iGapMillis >= iCutover) {\n-                        millis = julianToGregorian(millis);\n+                instant = iJulianField.set(instant, text, locale);\n+                if (instant >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant - iGapDuration >= iCutover) {\n+                        instant = julianToGregorian(instant);\n                     }\n                     // Cannot verify that new value stuck because set may be lenient.\n                 }\n             }\n-            return millis;\n-        }\n-\n-        public boolean isLeap(long millis) {\n-            if (millis >= iCutover) {\n-                return iGregorianField.isLeap(millis);\n-            } else {\n-                return iJulianField.isLeap(millis);\n-            }\n-        }\n-\n-        public int getLeapAmount(long millis) {\n-            if (millis >= iCutover) {\n-                return iGregorianField.getLeapAmount(millis);\n-            } else {\n-                return iJulianField.getLeapAmount(millis);\n-            }\n-        }\n-\n-        public long getUnitMillis() {\n-            // Since getUnitSize doesn't accept a millis argument, return\n-            // Gregorian unit size because it is more accurate.\n-            return iGregorianField.getUnitMillis();\n-        }\n-\n-        public long getRangeMillis() {\n-            return iGregorianField.getRangeMillis();\n-        }\n-\n-        // Note on getMinimumValue and getMaximumValue: For all fields but\n-        // year, yearOfEra, and centuryOfEra, the Julian and Gregorian limits\n-        // are identical. The Julian limit is returned for getMaximumValue\n-        // because it is smaller than the Gregorian limit. This is to prevent\n-        // calling a field mutator that advances so far beyond the gap that the\n-        // Julian calendar overflows.\n+            return instant;\n+        }\n+\n+        public DurationField getDurationField() {\n+            return iDurationField;\n+        }\n+\n+        public DurationField getRangeDurationField() {\n+            DurationField rangeField = iGregorianField.getRangeDurationField();\n+            if (rangeField == null) {\n+                rangeField = iJulianField.getRangeDurationField();\n+            }\n+            return rangeField;\n+        }\n+\n+        public boolean isLeap(long instant) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.isLeap(instant);\n+            } else {\n+                return iJulianField.isLeap(instant);\n+            }\n+        }\n+\n+        public int getLeapAmount(long instant) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.getLeapAmount(instant);\n+            } else {\n+                return iJulianField.getLeapAmount(instant);\n+            }\n+        }\n+\n+        public DurationField getLeapDurationField() {\n+            return iGregorianField.getLeapDurationField();\n+        }\n+\n \n         public int getMinimumValue() {\n+            // For all precise fields, the Julian and Gregorian limits are\n+            // identical. Choose Julian to tighten up the year limits.\n             return iJulianField.getMinimumValue();\n         }\n         \n-        public int getMinimumValue(long millis) {\n-            if (millis >= iCutover) {\n-                return iGregorianField.getMinimumValue(millis);\n-            } else {\n-                return iJulianField.getMinimumValue(millis);\n-            }\n+        public int getMinimumValue(long instant) {\n+            if (instant < iCutover) {\n+                return iJulianField.getMinimumValue(instant);\n+            }\n+\n+            int min = iGregorianField.getMinimumValue(instant);\n+\n+            // Because the cutover may reduce the length of this field, verify\n+            // the minimum by setting it.\n+            instant = iGregorianField.set(instant, min);\n+            if (instant < iCutover) {\n+                min = iGregorianField.get(iCutover);\n+            }\n+\n+            return min;\n         }\n \n         public int getMaximumValue() {\n-            return iJulianField.getMaximumValue();\n-        }\n-\n-        public int getMaximumValue(long millis) {\n-            if (millis >= iCutover) {\n-                return iGregorianField.getMaximumValue(millis);\n-            } else {\n-                return iJulianField.getMaximumValue(millis);\n-            }\n-        }\n-\n-        public long roundFloor(long millis) {\n-            if (millis >= iCutover) {\n-                millis = iGregorianField.roundFloor(millis);\n-                if (millis < iCutover) {\n-                    // Only adjust if gap fully crossed.\n-                    if (millis + iGapMillis < iCutover) {\n-                        millis = gregorianToJulian(millis);\n-                    }\n-                }\n-            } else {\n-                millis = iJulianField.roundFloor(millis);\n-            }\n-            return millis;\n-        }\n-\n-        public long roundCeiling(long millis) {\n-            if (millis >= iCutover) {\n-                millis = iGregorianField.roundCeiling(millis);\n-            } else {\n-                millis = iJulianField.roundCeiling(millis);\n-                if (millis >= iCutover) {\n-                    // Only adjust if gap fully crossed.\n-                    if (millis - iGapMillis >= iCutover) {\n-                        millis = julianToGregorian(millis);\n-                    }\n-                }\n-            }\n-            return millis;\n-        }\n-\n-        public long remainder(long millis) {\n-            if (millis >= iCutover) {\n-                millis = iGregorianField.remainder(millis);\n-                if (millis < iCutover) {\n-                    // Only adjust if gap fully crossed.\n-                    if (millis + iGapMillis < iCutover) {\n-                        millis = gregorianToJulian(millis);\n-                    }\n-                }\n-            } else {\n-                millis = iJulianField.remainder(millis);\n-                if (millis >= iCutover) {\n-                    // Only adjust if gap fully crossed.\n-                    if (millis - iGapMillis >= iCutover) {\n-                        millis = julianToGregorian(millis);\n-                    }\n-                }\n-            }\n-            return millis;\n+            // For all precise fields, the Julian and Gregorian limits are\n+            // identical.\n+            return iGregorianField.getMaximumValue();\n+        }\n+\n+        public int getMaximumValue(long instant) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.getMaximumValue(instant);\n+            }\n+\n+            int max = iJulianField.getMaximumValue(instant);\n+\n+            // Because the cutover may reduce the length of this field, verify\n+            // the maximum by setting it.\n+            instant = iJulianField.set(instant, max);\n+            if (instant >= iCutover) {\n+                max = iJulianField.get(iJulianField.add(iCutover, -1));\n+            }\n+\n+            return max;\n+        }\n+\n+        public long roundFloor(long instant) {\n+            if (instant >= iCutover) {\n+                instant = iGregorianField.roundFloor(instant);\n+                if (instant < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant + iGapDuration < iCutover) {\n+                        instant = gregorianToJulian(instant);\n+                    }\n+                }\n+            } else {\n+                instant = iJulianField.roundFloor(instant);\n+            }\n+            return instant;\n+        }\n+\n+        public long roundCeiling(long instant) {\n+            if (instant >= iCutover) {\n+                instant = iGregorianField.roundCeiling(instant);\n+            } else {\n+                instant = iJulianField.roundCeiling(instant);\n+                if (instant >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant - iGapDuration >= iCutover) {\n+                        instant = julianToGregorian(instant);\n+                    }\n+                }\n+            }\n+            return instant;\n         }\n \n         public int getMaximumTextLength(Locale locale) {\n      * set must be applied to add and addWrapped. Knowing when to use this\n      * field requires specific knowledge of how the GJ fields are implemented.\n      */\n-    private class CutoverVarField extends CutoverField {\n-        CutoverVarField(DateTimeField julianField, DateTimeField gregorianField) {\n+    private final class ImpreciseCutoverField extends CutoverField {\n+        static final long serialVersionUID = 3410248757173576441L;\n+\n+        /**\n+         * Creates a duration field that links back to this.\n+         */\n+        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField) {\n+            this(julianField, gregorianField, null);\n+        }\n+\n+        /**\n+         * Uses a shared duration field rather than creating a new one.\n+         *\n+         * @param durationField shared duration field\n+         */\n+        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n+                              DurationField durationField)\n+        {\n             super(julianField, gregorianField);\n-        }\n-\n-        public long add(long millis, int value) {\n-            if (millis >= iCutover) {\n-                millis = iGregorianField.add(millis, value);\n-                if (millis < iCutover) {\n-                    // Only adjust if gap fully crossed.\n-                    if (millis + iGapMillis < iCutover) {\n-                        millis = gregorianToJulian(millis);\n-                    }\n-                }\n-            } else {\n-                millis = iJulianField.add(millis, value);\n-                if (millis >= iCutover) {\n-                    // Only adjust if gap fully crossed.\n-                    if (millis - iGapMillis >= iCutover) {\n-                        millis = julianToGregorian(millis);\n-                    }\n-                }\n-            }\n-            return millis;\n+            if (durationField == null) {\n+                durationField = new LinkedDurationField(iDurationField, this);\n+            }\n+            iDurationField = durationField;\n+        }\n+\n+        public long add(long instant, int value) {\n+            if (instant >= iCutover) {\n+                instant = iGregorianField.add(instant, value);\n+                if (instant < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant + iGapDuration < iCutover) {\n+                        instant = gregorianToJulian(instant);\n+                    }\n+                }\n+            } else {\n+                instant = iJulianField.add(instant, value);\n+                if (instant >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant - iGapDuration >= iCutover) {\n+                        instant = julianToGregorian(instant);\n+                    }\n+                }\n+            }\n+            return instant;\n         }\n         \n-        public long add(long millis, long value) {\n-            if (millis >= iCutover) {\n-                millis = iGregorianField.add(millis, value);\n-                if (millis < iCutover) {\n-                    // Only adjust if gap fully crossed.\n-                    if (millis + iGapMillis < iCutover) {\n-                        millis = gregorianToJulian(millis);\n-                    }\n-                }\n-            } else {\n-                millis = iJulianField.add(millis, value);\n-                if (millis >= iCutover) {\n-                    // Only adjust if gap fully crossed.\n-                    if (millis - iGapMillis >= iCutover) {\n-                        millis = julianToGregorian(millis);\n-                    }\n-                }\n-            }\n-            return millis;\n-        }\n-\n-        public long addWrapped(long millis, int value) {\n-            if (millis >= iCutover) {\n-                millis = iGregorianField.addWrapped(millis, value);\n-                if (millis < iCutover) {\n-                    // Only adjust if gap fully crossed.\n-                    if (millis + iGapMillis < iCutover) {\n-                        millis = gregorianToJulian(millis);\n-                    }\n-                }\n-            } else {\n-                millis = iJulianField.addWrapped(millis, value);\n-                if (millis >= iCutover) {\n-                    // Only adjust if gap fully crossed.\n-                    if (millis - iGapMillis >= iCutover) {\n-                        millis = julianToGregorian(millis);\n-                    }\n-                }\n-            }\n-            return millis;\n-        }\n-\n-        public long getDifference(long minuendMillis, long subtrahendMillis) {\n-            if (minuendMillis >= iCutover) {\n-                if (subtrahendMillis >= iCutover) {\n-                    return iGregorianField.getDifference(minuendMillis, subtrahendMillis);\n+        public long add(long instant, long value) {\n+            if (instant >= iCutover) {\n+                instant = iGregorianField.add(instant, value);\n+                if (instant < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant + iGapDuration < iCutover) {\n+                        instant = gregorianToJulian(instant);\n+                    }\n+                }\n+            } else {\n+                instant = iJulianField.add(instant, value);\n+                if (instant >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant - iGapDuration >= iCutover) {\n+                        instant = julianToGregorian(instant);\n+                    }\n+                }\n+            }\n+            return instant;\n+        }\n+\n+        public int getDifference(long minuendInstant, long subtrahendInstant) {\n+            if (minuendInstant >= iCutover) {\n+                if (subtrahendInstant >= iCutover) {\n+                    return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n                 }\n                 // Remember, the add is being reversed. Since subtrahend is\n                 // Julian, convert minuend to Julian to match.\n-                minuendMillis = gregorianToJulian(minuendMillis);\n-                return iJulianField.getDifference(minuendMillis, subtrahendMillis);\n-            } else {\n-                if (subtrahendMillis < iCutover) {\n-                    return iJulianField.getDifference(minuendMillis, subtrahendMillis);\n+                minuendInstant = gregorianToJulian(minuendInstant);\n+                return iJulianField.getDifference(minuendInstant, subtrahendInstant);\n+            } else {\n+                if (subtrahendInstant < iCutover) {\n+                    return iJulianField.getDifference(minuendInstant, subtrahendInstant);\n                 }\n                 // Remember, the add is being reversed. Since subtrahend is\n                 // Gregorian, convert minuend to Gregorian to match.\n-                minuendMillis = julianToGregorian(minuendMillis);\n-                return iGregorianField.getDifference(minuendMillis, subtrahendMillis);\n-            }\n+                minuendInstant = julianToGregorian(minuendInstant);\n+                return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n+            }\n+        }\n+\n+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+            if (minuendInstant >= iCutover) {\n+                if (subtrahendInstant >= iCutover) {\n+                    return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+                }\n+                // Remember, the add is being reversed. Since subtrahend is\n+                // Julian, convert minuend to Julian to match.\n+                minuendInstant = gregorianToJulian(minuendInstant);\n+                return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+            } else {\n+                if (subtrahendInstant < iCutover) {\n+                    return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+                }\n+                // Remember, the add is being reversed. Since subtrahend is\n+                // Gregorian, convert minuend to Gregorian to match.\n+                minuendInstant = julianToGregorian(minuendInstant);\n+                return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+            }\n+        }\n+\n+        // Since the imprecise fields have durations longer than the gap\n+        // duration, keep these methods simple. The inherited implementations\n+        // produce incorrect results.\n+        //\n+        // Degenerate case: If this field is a month, and the cutover is set\n+        // far into the future, then the gap duration may be so large as to\n+        // reduce the number of months in a year. If the missing month(s) are\n+        // at the beginning or end of the year, then the minimum and maximum\n+        // values are not 1 and 12. I don't expect this case to ever occur.\n+\n+        public int getMinimumValue(long instant) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.getMinimumValue(instant);\n+            } else {\n+                return iJulianField.getMinimumValue(instant);\n+            }\n+        }\n+\n+        public int getMaximumValue(long instant) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.getMaximumValue(instant);\n+            } else {\n+                return iJulianField.getMaximumValue(instant);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Links the duration back to a ImpreciseCutoverField.\n+     */\n+    private static class LinkedDurationField extends DecoratedDurationField {\n+        static final long serialVersionUID = 4097975388007713084L;\n+\n+        private final ImpreciseCutoverField iField;\n+\n+        LinkedDurationField(DurationField durationField, ImpreciseCutoverField dateTimeField) {\n+            super(durationField, durationField.getName());\n+            iField = dateTimeField;\n+        }\n+\n+        public long add(long instant, int value) {\n+            return iField.add(instant, value);\n+        }\n+\n+        public long add(long instant, long value) {\n+            return iField.add(instant, value);\n+        }\n+\n+        public int getDifference(long minuendInstant, long subtrahendInstant) {\n+            return iField.getDifference(minuendInstant, subtrahendInstant);\n+        }\n+\n+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+            return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n         }\n     }\n }\n--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJCenturyChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJCenturyChronology.java\n import org.joda.time.DateTimeZone;\n import org.joda.time.chrono.OffsetDateTimeField;\n import org.joda.time.chrono.DividedDateTimeField;\n-import org.joda.time.chrono.NonZeroDateTimeField;\n+import org.joda.time.chrono.RemainderDateTimeField;\n \n /**\n  * Chronology for supporting GJ style centuries. Century 1 begin on year 1, and\n- * century of year ranges from 1 to 100.\n+ * year of century ranges from 1 to 100.\n  *\n  * @author Brian S O'Neill\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n class GJCenturyChronology extends GJChronology {\n+\n+    static final long serialVersionUID = -8572000567534692411L;\n+\n     private final GJChronology iChronology;\n \n     /**\n         }\n \n         iChronology = chrono;\n+        copyFields(chrono);\n \n-        iYearField = chrono.year();\n-        iYearOfEraField = chrono.yearOfEra();\n-        iEraField = chrono.era();\n-        iDayOfMonthField = chrono.dayOfMonth();\n-        iDayOfWeekField = chrono.dayOfWeek();\n-        iDayOfYearField = chrono.dayOfYear();\n-        iMonthOfYearField = chrono.monthOfYear();\n-        iWeekOfWeekyearField = chrono.weekOfWeekyear();\n-        iWeekyearField = chrono.weekyear();\n+        DateTimeField tempField = new OffsetDateTimeField(iYearOfEraField, \"\", 99);\n+        iCenturyOfEraField = new DividedDateTimeField\n+            (tempField, \"centuryOfEra\", \"centuries\", 100);\n \n-        iMillisOfSecondField = chrono.millisOfSecond();\n-        iMillisOfDayField = chrono.millisOfDay();\n-        iSecondOfMinuteField = chrono.secondOfMinute();\n-        iSecondOfDayField = chrono.secondOfDay();\n-        iMinuteOfHourField = chrono.minuteOfHour();\n-        iMinuteOfDayField = chrono.minuteOfDay();\n-        iHourOfDayField = chrono.hourOfDay();\n-        iHourOfHalfdayField = chrono.hourOfHalfday();\n-        iClockhourOfDayField = chrono.clockhourOfDay();\n-        iClockhourOfHalfdayField = chrono.clockhourOfHalfday();\n-        iHalfdayOfDayField = chrono.halfdayOfDay();\n-\n-        DateTimeField offsetYear =\n-            new OffsetDateTimeField(\"yearOfEra\", iYearOfEraField, 99);\n-        iCenturyOfEraField =\n-            new DividedDateTimeField(\"centuryOfEra\", offsetYear, 100);\n-        iYearOfCenturyField =\n-            new NonZeroDateTimeField(\"yearOfCentury\", chrono.yearOfCentury());\n+        tempField = new RemainderDateTimeField\n+            ((DividedDateTimeField)iCenturyOfEraField, \"\");\n+        iYearOfCenturyField = new OffsetDateTimeField(tempField, \"yearOfCentury\", 1);\n     }\n \n     public Chronology withUTC() {\n         return this;\n+    }\n+\n+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException\n+    {\n+        return iChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);\n+    }\n+\n+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return iChronology.getTimeOnlyMillis\n+            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        return iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n+    }\n+\n+    public long getDateTimeMillis(long instant,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return iChronology.getDateTimeMillis\n+            (instant,\n+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return iChronology.getDateTimeMillis\n+            (year, monthOfYear, dayOfMonth,\n+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n     }\n \n     public long getGregorianJulianCutoverMillis() {\n--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJChronology.java\n import java.util.HashMap;\n \n import org.joda.time.Chronology;\n+// Import for @link support\n+import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n import org.joda.time.Instant;\n import org.joda.time.ReadableInstant;\n+import org.joda.time.format.DateTimePrinter;\n+import org.joda.time.format.ISODateTimeFormat;\n \n /**\n  * GJChronology provides access to the individual date time fields \n  * A pure proleptic Gregorian chronology is obtained by specifying a cutover of\n  * Long.MIN_VALUE. Likewise, a pure Julian chronology is obtained with a\n  * cutover of Long.MAX_VALUE.\n+ * <p>\n+ * GJChronology is thread-safe and immutable.\n  *\n  * @author Stephen Colebourne\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n public abstract class GJChronology extends Chronology {\n+\n+    static final long serialVersionUID = 3258844765135550418L;\n+\n     /**\n      * The default GregorianJulian cutover point\n      */\n \n     // Cache that maps DateTimeZones to Factory instances.\n     private static HashMap cZonesToFactories = new HashMap();\n+\n+    transient DurationField iYearsField;\n+    transient DurationField iCenturiesField;\n+    transient DurationField iMonthsField;\n+    transient DurationField iWeekyearsField;\n+\n+    transient DurationField iMillisField;\n+    transient DurationField iSecondsField;\n+    transient DurationField iMinutesField;\n+    transient DurationField iHoursField;\n+    transient DurationField iDaysField;\n+    transient DurationField iWeeksField;\n \n     transient DateTimeField iYearField;\n     transient DateTimeField iYearOfEraField;\n                                                         boolean centuryISO,\n                                                         int minDaysInFirstWeek)\n     {\n-        long millis;\n+        long cutover;\n         if (gregorianCutover != null) {\n-            millis = gregorianCutover.getMillis();\n+            cutover = gregorianCutover.getMillis();\n         } else {\n-            millis = DEFAULT_CUTOVER;\n-        }\n-        return getInstance(zone, millis, centuryISO, minDaysInFirstWeek);\n+            cutover = DEFAULT_CUTOVER;\n+        }\n+        return getInstance(zone, cutover, centuryISO, minDaysInFirstWeek);\n     }\n \n     /**\n \n     public Chronology withDateTimeZone(DateTimeZone zone) {\n         if (zone == null) {\n-            throw new IllegalArgumentException(\"The DateTimeZone must not be null\");\n+            zone = DateTimeZone.getDefault();\n         }\n         if (zone == getDateTimeZone()) {\n             return this;\n     // Milliseconds\n     //------------------------------------------------------------\n \n+    public DurationField millis() {\n+        return iMillisField;\n+    }\n+\n     public DateTimeField millisOfSecond() {\n         return iMillisOfSecondField;\n     }\n     // Seconds\n     //------------------------------------------------------------\n \n+    public DurationField seconds() {\n+        return iSecondsField;\n+    }\n+\n     public DateTimeField secondOfMinute() {\n         return iSecondOfMinuteField;\n     }\n         return iSecondOfDayField;\n     }\n \n+    // Minutes\n+    //------------------------------------------------------------\n+\n+    public DurationField minutes() {\n+        return iMinutesField;\n+    }\n+\n     public DateTimeField minuteOfHour() {\n         return iMinuteOfHourField;\n     }\n \n     // Hours\n     //------------------------------------------------------------\n+\n+    public DurationField hours() {\n+        return iHoursField;\n+    }\n \n     public DateTimeField hourOfDay() {\n         return iHourOfDayField;\n     // Day\n     //------------------------------------------------------------\n     \n+    public DurationField days() {\n+        return iDaysField;\n+    }\n+\n     public DateTimeField dayOfWeek() {\n         return iDayOfWeekField;\n     }\n     // Week\n     //------------------------------------------------------------\n     \n+    public DurationField weeks() {\n+        return iWeeksField;\n+    }\n+\n     public DateTimeField weekOfWeekyear() {\n         return iWeekOfWeekyearField;\n+    }\n+\n+    public DurationField weekyears() {\n+        return iWeekyearsField;\n     }\n \n     public DateTimeField weekyear() {\n     // Month\n     //------------------------------------------------------------\n     \n+    public DurationField months() {\n+        return iMonthsField;\n+    }\n+\n     public DateTimeField monthOfYear() {\n         return iMonthOfYearField;\n     }\n     // Year\n     //------------------------------------------------------------\n     \n+    public DurationField years() {\n+        return iYearsField;\n+    }\n+\n     public DateTimeField year() {\n         return iYearField;\n     }\n         return iYearOfCenturyField;\n     }\n \n+    public DurationField centuries() {\n+        return iCenturiesField;\n+    }\n+\n     public DateTimeField centuryOfEra() {\n         return iCenturyOfEraField;\n     }\n \n     public DateTimeField era() {\n         return iEraField;\n+    }\n+\n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging toString.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        StringBuffer sb = new StringBuffer(50);\n+        sb.append(\"GJChronology\");\n+        sb.append('[');\n+        sb.append(getDateTimeZone().getID());\n+        sb.append(\", \");\n+\n+        long cutover = getGregorianJulianCutoverMillis();\n+        if (cutover == Long.MAX_VALUE) {\n+            sb.append(\"julian\");\n+        } else if (cutover == Long.MIN_VALUE) {\n+            sb.append(\"gregorian\");\n+        } else {\n+            sb.append(\"cutover=\");\n+            ISODateTimeFormat format = ISODateTimeFormat.getInstance(withUTC());\n+            DateTimePrinter printer;\n+            if (withUTC().getTimeOnlyMillis(cutover) == 0) {\n+                printer = format.date();\n+            } else {\n+                printer = format.dateTime();\n+            }\n+            printer.printTo(sb, cutover);\n+        }\n+\n+        sb.append(\", century=\");\n+        sb.append(isCenturyISO() ? \"iso\" : \"gj\");\n+\n+        sb.append(\", mdfw=\");\n+        sb.append(getMinimumDaysInFirstWeek());\n+        sb.append(']');\n+\n+        return sb.toString();\n     }\n \n     /**\n                         getMinimumDaysInFirstWeek());\n     }\n \n+    /**\n+     * Used by subclass constructors to copy all the fields of another\n+     * chronology into this one.\n+     */\n+    void copyFields(Chronology chrono) {\n+        iYearsField = chrono.years();\n+        iCenturiesField = chrono.centuries();\n+        iMonthsField = chrono.months();\n+        iWeekyearsField = chrono.weekyears();\n+\n+        iMillisField = chrono.millis();\n+        iSecondsField = chrono.seconds();\n+        iMinutesField = chrono.minutes();\n+        iHoursField = chrono.hours();\n+        iDaysField = chrono.days();\n+        iWeeksField = chrono.weeks();\n+\n+        iYearField = chrono.year();\n+        iYearOfEraField = chrono.yearOfEra();\n+        iYearOfCenturyField = chrono.yearOfCentury();\n+        iCenturyOfEraField = chrono.centuryOfEra();\n+        iEraField = chrono.era();\n+        iDayOfWeekField = chrono.dayOfWeek();\n+        iDayOfMonthField = chrono.dayOfMonth();\n+        iDayOfYearField = chrono.dayOfYear();\n+        iMonthOfYearField = chrono.monthOfYear();\n+        iWeekOfWeekyearField = chrono.weekOfWeekyear();\n+        iWeekyearField = chrono.weekyear();\n+\n+        iMillisOfSecondField = chrono.millisOfSecond();\n+        iMillisOfDayField = chrono.millisOfDay();\n+        iSecondOfMinuteField = chrono.secondOfMinute();\n+        iSecondOfDayField = chrono.secondOfDay();\n+        iMinuteOfHourField = chrono.minuteOfHour();\n+        iMinuteOfDayField = chrono.minuteOfDay();\n+        iHourOfDayField = chrono.hourOfDay();\n+        iHourOfHalfdayField = chrono.hourOfHalfday();\n+        iClockhourOfDayField = chrono.clockhourOfDay();\n+        iClockhourOfHalfdayField = chrono.clockhourOfHalfday();\n+        iHalfdayOfDayField = chrono.halfdayOfDay();\n+    }\n+\n     private static final class Stub implements Serializable {\n+        static final long serialVersionUID = -1220272966668670015L;\n+\n         private transient DateTimeZone iZone;\n         private transient long iCutover;\n         private transient boolean iCenturyISO;\n                 }\n             }\n \n-            if (gregorianCutover == Long.MAX_VALUE) {\n-                chrono = new JulianChronology(minDaysInFirstWeek);\n-            } else if (gregorianCutover == Long.MIN_VALUE) {\n-                chrono = new GregorianChronology(minDaysInFirstWeek);\n+            if (iZone != DateTimeZone.UTC) {\n+                chrono = GJChronology.getInstance\n+                    (DateTimeZone.UTC, gregorianCutover, centuryISO, minDaysInFirstWeek);\n+                chrono = new GJZonedChronology(chrono, iZone);\n             } else {\n-                JulianChronology julian_utc = (JulianChronology)GJChronology.getInstance\n-                    (DateTimeZone.UTC, Long.MAX_VALUE, true, minDaysInFirstWeek);\n-                GregorianChronology gregorian_utc = (GregorianChronology)GJChronology.getInstance\n-                    (DateTimeZone.UTC, Long.MIN_VALUE, true, minDaysInFirstWeek);\n-\n-                chrono = new CutoverChronology(julian_utc, gregorian_utc, gregorianCutover);\n-            }\n-\n-            if (!centuryISO) {\n-                chrono = new GJCenturyChronology(chrono);\n+                if (gregorianCutover == Long.MAX_VALUE) {\n+                    chrono = new JulianChronology(minDaysInFirstWeek);\n+                } else if (gregorianCutover == Long.MIN_VALUE) {\n+                    chrono = new GregorianChronology(minDaysInFirstWeek);\n+                } else {\n+                    JulianChronology julian_utc = (JulianChronology)GJChronology.getInstance\n+                        (DateTimeZone.UTC, Long.MAX_VALUE, true, minDaysInFirstWeek);\n+                    GregorianChronology gregorian_utc = (GregorianChronology)GJChronology.getInstance\n+                        (DateTimeZone.UTC, Long.MIN_VALUE, true, minDaysInFirstWeek);\n+                    \n+                    chrono = new CutoverChronology(julian_utc, gregorian_utc, gregorianCutover);\n+                }\n+\n+                if (!centuryISO) {\n+                    chrono = new GJCenturyChronology(chrono);\n+                }\n             }\n             \n-            if (iZone != DateTimeZone.UTC) {\n-                chrono = new GJZonedChronology(chrono, iZone);\n-            }\n-\n             cache.add(new SoftReference(chrono));\n             return chrono;\n         }\n--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java\n package org.joda.time.chrono.gj;\n \n import org.joda.time.DateTimeConstants;\n-import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.chrono.PreciseDurationDateTimeField;\n+import org.joda.time.chrono.Utils;\n \n /**\n  * Provides time calculations for the day of the month component of time.\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-final class GJDayOfMonthDateTimeField extends DateTimeField {\n+final class GJDayOfMonthDateTimeField extends PreciseDurationDateTimeField {\n+\n+    static final long serialVersionUID = -4677223814028011723L;\n \n     private final ProlepticChronology iChronology;\n \n     /**\n-     * Restricted constructor\n+     * Restricted constructor.\n      */\n-    GJDayOfMonthDateTimeField(ProlepticChronology chronology) {\n-        super(\"dayOfMonth\");\n+    GJDayOfMonthDateTimeField(ProlepticChronology chronology, DurationField days) {\n+        super(\"dayOfMonth\", days);\n         iChronology = chronology;\n     }\n \n     /**\n      * Get the day of the month component of the specified time instant.\n      * \n-     * @param millis  the time instant in millis to query.\n+     * @param instant  the time instant in millis to query.\n      * @return the day of the month extracted from the input.\n      */\n-    public int get(long millis) {\n-        return iChronology.getDayOfMonth(millis);\n+    public int get(long instant) {\n+        return iChronology.getDayOfMonth(instant);\n     }\n \n-    /**\n-     * Add the specified day of the month to the specified time instant.\n-     * The amount added may be negative.\n-     * \n-     * @param millis  the time instant in millis to update.\n-     * @param days  the days to add to add (can be negative).\n-     * @return the updated time instant.\n-     */\n-    public long add(long millis, int days) {\n-        return millis + days * (long)DateTimeConstants.MILLIS_PER_DAY;\n-    }\n-\n-    public long add(long millis, long days) {\n-        return millis + days * DateTimeConstants.MILLIS_PER_DAY;\n-    }\n-\n-    /**\n-     * Add to the day of the month component of the specified time instant\n-     * wrapping around within that component if necessary.\n-     * The amount added may be negative.\n-     * \n-     * @param millis  the time instant in millis to update.\n-     * @param days  the days to add (can be negative).\n-     * @return the updated time instant.\n-     */\n-    public long addWrapped(long millis, int days) {\n-        // This method deviates from the normal logic found in\n-        // concrete subclasses of DateTimeField.\n-        // This is because the maximum allowed day for a given\n-        // month must be calculated at run time.\n-        int thisYear = iChronology.year().get(millis);\n-        int thisMonth = iChronology.getMonthOfYear(millis, thisYear);\n-        int thisDom = iChronology.getDayOfMonth(millis, thisYear, thisMonth);\n-        int wrappedDom = getWrappedValue\n-            (thisDom, days, 1, iChronology.getDaysInYearMonth(thisYear, thisMonth));\n-        return set(millis, wrappedDom);\n-    }\n-\n-    public long getDifference(long minuendMillis, long subtrahendMillis) {\n-        return (minuendMillis - subtrahendMillis) / DateTimeConstants.MILLIS_PER_DAY;\n-    }\n-\n-    /**\n-     * Set the day of the month component of the specified time instant.\n-     * \n-     * @param millis  the time instant in millis to update.\n-     * @param year  the day (1,28-31) to update the time to.\n-     * @return the updated time instant.\n-     * @throws IllegalArgumentException  if day is is invalid for this year and month.\n-     */\n-    public long set(long millis, int day) {\n-        int thisYear = iChronology.year().get(millis);\n-        int thisMonth = iChronology.getMonthOfYear(millis, thisYear);\n-        verifyValueBounds(day, 1, iChronology.getDaysInYearMonth(thisYear, thisMonth));\n-        int thisDom = iChronology.getDayOfMonth(millis, thisYear, thisMonth);\n-        return millis + (day - thisDom) * (long)DateTimeConstants.MILLIS_PER_DAY;\n-    }\n-\n-    public long getUnitMillis() {\n-        return DateTimeConstants.MILLIS_PER_DAY;\n-    }\n-\n-    public long getRangeMillis() {\n-        return iChronology.getRoughMillisPerMonth();\n+    public DurationField getRangeDurationField() {\n+        return iChronology.months();\n     }\n \n     public int getMinimumValue() {\n         return 31;\n     }\n \n-    public int getMaximumValue(long millis) {\n-        int thisYear = iChronology.year().get(millis);\n-        int thisMonth = iChronology.getMonthOfYear(millis, thisYear);\n+    public int getMaximumValue(long instant) {\n+        int thisYear = iChronology.year().get(instant);\n+        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n         return iChronology.getDaysInYearMonth(thisYear, thisMonth);\n-    }\n-\n-    public long roundFloor(long millis) {\n-        if (millis >= 0) {\n-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY;\n-        } else {\n-            millis += 1;\n-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY - DateTimeConstants.MILLIS_PER_DAY;\n-        }\n-    }\n-\n-    public long roundCeiling(long millis) {\n-        if (millis >= 0) {\n-            millis -= 1;\n-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY + DateTimeConstants.MILLIS_PER_DAY;\n-        } else {\n-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY;\n-        }\n-    }\n-\n-    public long remainder(long millis) {\n-        if (millis >= 0) {\n-            return millis % DateTimeConstants.MILLIS_PER_DAY;\n-        } else {\n-            return (millis + 1) % DateTimeConstants.MILLIS_PER_DAY + DateTimeConstants.MILLIS_PER_DAY - 1;\n-        }\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfWeekDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfWeekDateTimeField.java\n import java.util.Locale;\n \n import org.joda.time.DateTimeConstants;\n-import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.chrono.PreciseDurationDateTimeField;\n+import org.joda.time.chrono.Utils;\n \n /**\n  * GJDayOfWeekDateTimeField provides time calculations for the\n  * @author Stephen Colebourne\n  * @author Brian S O'Neill\n  */\n-final class GJDayOfWeekDateTimeField extends DateTimeField {\n+final class GJDayOfWeekDateTimeField extends PreciseDurationDateTimeField {\n     \n-    private static final int MIN = DateTimeConstants.MONDAY;\n-    private static final int MAX = DateTimeConstants.SUNDAY;\n-    \n+    static final long serialVersionUID = -3857947176719041436L;\n+\n     private final ProlepticChronology iChronology;\n \n     /**\n      * Restricted constructor.\n      */\n-    GJDayOfWeekDateTimeField(ProlepticChronology chronology) {\n-        super(\"dayOfWeek\");\n+    GJDayOfWeekDateTimeField(ProlepticChronology chronology, DurationField days) {\n+        super(\"dayOfWeek\", days);\n         iChronology = chronology;\n     }\n \n     /**\n      * Get the value of the specified time instant.\n      * \n-     * @param millis  the time instant in millis to query\n+     * @param instant  the time instant in millis to query\n      * @return the day of the week extracted from the input\n      */\n-    public int get(long millis) {\n+    public int get(long instant) {\n         // 1970-01-01 is day of week 4, Thursday.\n \n         long daysSince19700101;\n-        if (millis >= 0) {\n-            daysSince19700101 = millis / DateTimeConstants.MILLIS_PER_DAY;\n+        if (instant >= 0) {\n+            daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY;\n         } else {\n-            daysSince19700101 = (millis - (DateTimeConstants.MILLIS_PER_DAY - 1))\n+            daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1))\n                 / DateTimeConstants.MILLIS_PER_DAY;\n             if (daysSince19700101 < -3) {\n                 return 7 + (int) ((daysSince19700101 + 4) % 7);\n     /**\n      * Get the textual value of the specified time instant.\n      * \n-     * @param millis  the time instant in millis to query\n+     * @param instant  the time instant in millis to query\n      * @param locale  the locale to use\n      * @return the day of the week, such as 'Monday'\n      */\n-    public String getAsText(long millis, Locale locale) {\n-        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(millis));\n+    public String getAsText(long instant, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(instant));\n     }\n \n     /**\n      * Get the abbreviated textual value of the specified time instant.\n      * \n-     * @param millis  the time instant in millis to query\n+     * @param instant  the time instant in millis to query\n      * @param locale  the locale to use\n      * @return the day of the week, such as 'Mon'\n      */\n-    public String getAsShortText(long millis, Locale locale) {\n-        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToShortText(get(millis));\n-    }\n-\n-    /**\n-     * Add to the value of the specified time instant.\n-     * The amount added may be negative.\n-     * \n-     * @param millis  the time instant in millis to update\n-     * @param day  the day of the week to add (can be negative)\n-     * @return the updated time instant\n-     */\n-    public long add(long millis, int days) {\n-        return millis + days * (long)DateTimeConstants.MILLIS_PER_DAY;\n-    }\n-\n-    public long add(long millis, long days) {\n-        return millis + days * DateTimeConstants.MILLIS_PER_DAY;\n-    }\n-\n-    /**\n-     * Add to the value of the specified time instant wrapping around\n-     * within that component if necessary.\n-     * The amount added may be negative.\n-     * \n-     * @param millis  the time instant in millis to update\n-     * @param day  the day of the week to add (can be negative)\n-     * @return the updated time instant.\n-     */\n-    public long addWrapped(long millis, int days) {\n-        int thisDow = get(millis);\n-        int wrappedDow = getWrappedValue(thisDow, days, MIN, MAX);\n-        // copy code from set() to avoid repeat call to get()\n-        return millis + (wrappedDow - thisDow) * (long)DateTimeConstants.MILLIS_PER_DAY;\n-    }\n-\n-    public long getDifference(long minuendMillis, long subtrahendMillis) {\n-        return (minuendMillis - subtrahendMillis) / DateTimeConstants.MILLIS_PER_DAY;\n-    }\n-\n-    /**\n-     * Set the value of the specified time instant.\n-     * \n-     * @param millis  the time instant in millis to update\n-     * @param day  the day of the week (1,7) to update the time to\n-     * @return the updated time instant\n-     * @throws IllegalArgumentException  if day is invalid\n-     */\n-    public long set(long millis, int day) {\n-        verifyValueBounds(day, MIN, MAX);\n-        int thisDow = get(millis);\n-        return millis + (day - thisDow) * (long)DateTimeConstants.MILLIS_PER_DAY;\n+    public String getAsShortText(long instant, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToShortText(get(instant));\n     }\n \n     /**\n      * Set the value of the specified time instant from text.\n      * \n-     * @param millis  the time instant in millis to update\n+     * @param instant  the time instant in millis to update\n      * @param text  the text to set from\n      * @param locale  the locale to use\n      * @return the updated millis\n      */\n-    public long set(long millis, String text, Locale locale) {\n-        return set(millis, GJLocaleSymbols.forLocale(locale).dayOfWeekTextToValue(text));\n+    public long set(long instant, String text, Locale locale) {\n+        return set(instant, GJLocaleSymbols.forLocale(locale).dayOfWeekTextToValue(text));\n     }\n \n-    public long getUnitMillis() {\n-        return DateTimeConstants.MILLIS_PER_DAY;\n-    }\n-\n-    public long getRangeMillis() {\n-        return DateTimeConstants.MILLIS_PER_WEEK;\n+    public DurationField getRangeDurationField() {\n+        return iChronology.weeks();\n     }\n \n     /**\n      * @return the field's minimum value\n      */\n     public int getMinimumValue() {\n-        return MIN;\n+        return DateTimeConstants.MONDAY;\n     }\n \n     /**\n      * @return the field's maximum value\n      */\n     public int getMaximumValue() {\n-        return MAX;\n+        return DateTimeConstants.SUNDAY;\n     }\n \n     /**\n     public int getMaximumShortTextLength(Locale locale) {\n         return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxShortTextLength();\n     }\n-    \n-    public long roundFloor(long millis) {\n-        if (millis >= 0) {\n-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY;\n-        } else {\n-            millis += 1;\n-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY - DateTimeConstants.MILLIS_PER_DAY;\n-        }\n-    }\n-\n-    public long roundCeiling(long millis) {\n-        if (millis >= 0) {\n-            millis -= 1;\n-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY + DateTimeConstants.MILLIS_PER_DAY;\n-        } else {\n-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY;\n-        }\n-    }\n-\n-    public long remainder(long millis) {\n-        if (millis >= 0) {\n-            return millis % DateTimeConstants.MILLIS_PER_DAY;\n-        } else {\n-            return (millis + 1) % DateTimeConstants.MILLIS_PER_DAY + (DateTimeConstants.MILLIS_PER_DAY - 1);\n-        }\n-    }\n \n     /**\n      * Serialization singleton\n--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java\n package org.joda.time.chrono.gj;\n \n import org.joda.time.DateTimeConstants;\n-import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.chrono.PreciseDurationDateTimeField;\n+import org.joda.time.chrono.Utils;\n \n /**\n  * Provides time calculations for the day of the year component of time.\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-final class GJDayOfYearDateTimeField extends DateTimeField {\n+final class GJDayOfYearDateTimeField extends PreciseDurationDateTimeField {\n+\n+    static final long serialVersionUID = -6821236822336841037L;\n+\n     private final ProlepticChronology iChronology;\n \n     /**\n      * Restricted constructor\n      */\n-    GJDayOfYearDateTimeField(ProlepticChronology chronology) {\n-        super(\"dayOfYear\");\n+    GJDayOfYearDateTimeField(ProlepticChronology chronology, DurationField days) {\n+        super(\"dayOfYear\", days);\n         iChronology = chronology;\n     }\n \n     /**\n      * Get the day of the year component of the specified time instant.\n      * \n-     * @param millis  the time instant in millis to query.\n+     * @param instant  the time instant in millis to query.\n      * @return the day of the year extracted from the input.\n      */\n-    public int get(long millis) {\n-        long dateMillis = iChronology.year().roundFloor(millis);\n-        return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n+    public int get(long instant) {\n+        long dateInstant = iChronology.year().roundFloor(instant);\n+        return (int) ((instant - dateInstant) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n     }\n \n-    /**\n-     * Add the specified day of the year to the specified time instant.\n-     * The amount added may be negative.\n-     * \n-     * @param millis  the time instant in millis to update.\n-     * @param days  the days to add (can be negative).\n-     * @return the updated time instant.\n-     */\n-    public long add(long millis, int days) {\n-        return millis + days * (long)DateTimeConstants.MILLIS_PER_DAY;\n-    }\n-\n-    public long add(long millis, long days) {\n-        return millis + days * DateTimeConstants.MILLIS_PER_DAY;\n-    }\n-\n-    /**\n-     * Add to the day of the year component of the specified time instant\n-     * wrapping around within that component if necessary.\n-     * \n-     * @param millis  the time instant in millis to update.\n-     * @param years  the years to add (can be negative).\n-     * @return the updated time instant.\n-     */\n-    public long addWrapped(long millis, int days) {\n-        int thisDoy = get(millis);\n-        int wrappedDoy = getWrappedValue(thisDoy, days, getMinimumValue(millis), getMaximumValue(millis));\n-        // avoid recalculating fields in set\n-        return millis + (wrappedDoy - thisDoy) * (long)DateTimeConstants.MILLIS_PER_DAY;\n-    }\n-\n-    public long getDifference(long minuendMillis, long subtrahendMillis) {\n-        return (minuendMillis - subtrahendMillis) / DateTimeConstants.MILLIS_PER_DAY;\n-    }\n-\n-    /**\n-     * Set the day of the year component of the specified time instant.\n-     * \n-     * @param millis  the time instant in millis to update.\n-     * @param day  the day of the year (1,365/366) to update the time to.\n-     * @return the updated time instant.\n-     * @throws IllegalArgumentException  if year is invalid.\n-    */\n-    public long set(long millis, int day) {\n-        verifyValueBounds(day, getMinimumValue(millis), getMaximumValue(millis));\n-        int thisDoy = get(millis);\n-        return millis + (day - thisDoy) * (long)DateTimeConstants.MILLIS_PER_DAY;\n-    }\n-\n-    public long getUnitMillis() {\n-        return DateTimeConstants.MILLIS_PER_DAY;\n-    }\n-\n-    public long getRangeMillis() {\n-        return iChronology.getRoughMillisPerYear();\n+    public DurationField getRangeDurationField() {\n+        return iChronology.years();\n     }\n \n     public int getMinimumValue() {\n         return 366;\n     }\n \n-    public int getMaximumValue(long millis) {\n-        int thisYear = iChronology.year().get(millis);\n+    public int getMaximumValue(long instant) {\n+        int thisYear = iChronology.year().get(instant);\n         return iChronology.getDaysInYear(thisYear);\n-    }\n-\n-    public long roundFloor(long millis) {\n-        if (millis >= 0) {\n-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY;\n-        } else {\n-            millis += 1;\n-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY - DateTimeConstants.MILLIS_PER_DAY;\n-        }\n-    }\n-\n-    public long roundCeiling(long millis) {\n-        if (millis >= 0) {\n-            millis -= 1;\n-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY + DateTimeConstants.MILLIS_PER_DAY;\n-        } else {\n-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY;\n-        }\n-    }\n-\n-    public long remainder(long millis) {\n-        if (millis >= 0) {\n-            return millis % DateTimeConstants.MILLIS_PER_DAY;\n-        } else {\n-            return (millis + 1) % DateTimeConstants.MILLIS_PER_DAY + (DateTimeConstants.MILLIS_PER_DAY - 1);\n-        }\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJEraDateTimeField.java\n import java.util.Locale;\n \n import org.joda.time.DateTimeConstants;\n-import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.chrono.AbstractDateTimeField;\n+import org.joda.time.chrono.UnsupportedDurationField;\n+import org.joda.time.chrono.Utils;\n \n /**\n  * Provides time calculations for the era component of time.\n  * @version 1.0\n  * @since 1.0\n  */\n-final class GJEraDateTimeField extends DateTimeField {\n+final class GJEraDateTimeField extends AbstractDateTimeField {\n     \n+    static final long serialVersionUID = 4240986525305515528L;\n+\n     private final ProlepticChronology iChronology;\n \n     /**\n         iChronology = chronology;\n     }\n \n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n     /**\n      * Get the Era component of the specified time instant.\n      * \n-     * @param millis  the time instant in millis to query.\n+     * @param instant  the time instant in millis to query.\n      */\n-    public int get(long millis) {\n-        if (iChronology.year().get(millis) <= 0) {\n+    public int get(long instant) {\n+        if (iChronology.year().get(instant) <= 0) {\n             return DateTimeConstants.BCE;\n         } else {\n             return DateTimeConstants.CE;\n         }\n     }\n \n-    public String getAsText(long millis, Locale locale) {\n-        return GJLocaleSymbols.forLocale(locale).eraValueToText(get(millis));\n-    }\n-\n-    /**\n-     * Unsupported - add the specified eras to the specified time instant.\n-     * \n-     * @param millis  the time instant in millis to update.\n-     * @param eras  \n-     * @return the updated time instant.\n-     */\n-    public long add(long millis, int eras) {\n-        throw new UnsupportedOperationException(\"Adding to Era field is unsupported\");\n-    }\n-\n-    public long add(long millis, long value) {\n-        throw new UnsupportedOperationException(\"Adding to Era field is unsupported\");\n-    }\n-\n-    /**\n-     * Unsupported - add the specified eras to the specified time instant.\n-     * \n-     * @param millis  the time instant in millis to update.\n-     * @param eras\n-     * @return the updated time instant.\n-     */\n-    public long addWrapped(long millis, int years) {\n-        throw new UnsupportedOperationException(\"Adding to Era field is unsupported\");\n-    }\n-\n-    public long getDifference(long minuendMillis, long subtrahendMillis) {\n-        throw new UnsupportedOperationException(\"Era field difference is unsupported\");\n+    public String getAsText(long instant, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).eraValueToText(get(instant));\n     }\n \n     /**\n      * Set the Era component of the specified time instant.\n      * \n-     * @param millis  the time instant in millis to update.\n+     * @param instant  the time instant in millis to update.\n      * @param era  the era to update the time to.\n      * @return the updated time instant.\n      * @throws IllegalArgumentException  if era is invalid.\n      */\n-    public long set(long millis, int era) {\n-        super.verifyValueBounds(era, DateTimeConstants.BCE, DateTimeConstants.CE);\n+    public long set(long instant, int era) {\n+        Utils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE);\n             \n-        int oldEra = get(millis);\n+        int oldEra = get(instant);\n         if (oldEra != era) {\n-            int year = iChronology.year().get(millis);\n-            return iChronology.year().set(millis, -year);\n+            int year = iChronology.year().get(instant);\n+            return iChronology.year().set(instant, -year);\n         } else {\n-            return millis;\n+            return instant;\n         }\n     }\n \n-    public long set(long millis, String text, Locale locale) {\n-        return set(millis, GJLocaleSymbols.forLocale(locale).eraTextToValue(text));\n+    public long set(long instant, String text, Locale locale) {\n+        return set(instant, GJLocaleSymbols.forLocale(locale).eraTextToValue(text));\n     }\n \n-    public long getUnitMillis() {\n-        return Long.MAX_VALUE;\n+    public long roundFloor(long instant) {\n+        if (get(instant) == DateTimeConstants.CE) {\n+            return iChronology.year().set(0, 1);\n+        } else {\n+            return Long.MIN_VALUE;\n+        }\n     }\n \n-    public long getRangeMillis() {\n-        // Should actually be double this, but that is not possible since Java\n-        // doesn't support unsigned types.\n-        return Long.MAX_VALUE;\n+    public long roundCeiling(long instant) {\n+        if (get(instant) == DateTimeConstants.BCE) {\n+            return iChronology.year().set(0, 1);\n+        } else {\n+            return Long.MAX_VALUE;\n+        }\n+    }\n+\n+    public long roundHalfFloor(long instant) {\n+        // In reality, the era is infinite, so there is no halfway point.\n+        return roundFloor(instant);\n+    }\n+\n+    public long roundHalfCeiling(long instant) {\n+        // In reality, the era is infinite, so there is no halfway point.\n+        return roundFloor(instant);\n+    }\n+\n+    public long roundHalfEven(long instant) {\n+        // In reality, the era is infinite, so there is no halfway point.\n+        return roundFloor(instant);\n+    }\n+\n+    public DurationField getDurationField() {\n+        return UnsupportedDurationField.INSTANCE;\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return null;\n     }\n \n     public int getMinimumValue() {\n     }\n \n     /**\n-     * Unsupported.\n-     */\n-    public long roundFloor(long millis) {\n-        throw new UnsupportedOperationException(\"Rounding an Era field is unsupported\");\n-    }\n-\n-    /**\n-     * Unsupported.\n-     */\n-    public long remainder(long millis) {\n-        throw new UnsupportedOperationException(\"Calculating remainder from Era field is unsupported\");\n-    }\n-\n-    /**\n      * Serialization singleton\n      */\n     private Object readResolve() {\n--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJLocaleSymbols.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJLocaleSymbols.java\n \n package org.joda.time.chrono.gj;\n \n+import java.lang.ref.WeakReference;\n import java.text.DateFormatSymbols;\n-import java.util.HashMap;\n+import java.util.WeakHashMap;\n import java.util.Locale;\n \n /**\n  * @author Brian S O'Neill\n  */\n class GJLocaleSymbols {\n-    private static HashMap cCache = new HashMap();\n-\n-    public static synchronized GJLocaleSymbols forLocale(Locale locale) {\n-        GJLocaleSymbols symbols = (GJLocaleSymbols)cCache.get(locale);\n-        if (symbols == null) {\n-            symbols = new GJLocaleSymbols(locale);\n-            cCache.put(locale, symbols);\n-        }\n+    private static final int FAST_CACHE_SIZE = 64;\n+\n+    private static final GJLocaleSymbols[] cFastCache = new GJLocaleSymbols[FAST_CACHE_SIZE];\n+\n+    private static WeakHashMap cCache = new WeakHashMap();\n+\n+    public static GJLocaleSymbols forLocale(Locale locale) {\n+        int index = System.identityHashCode(locale) & (FAST_CACHE_SIZE - 1);\n+        GJLocaleSymbols symbols = cFastCache[index];\n+        if (symbols != null && symbols.iLocale.get() == locale) {\n+            return symbols;\n+        }\n+        synchronized (cCache) {\n+            symbols = (GJLocaleSymbols) cCache.get(locale);\n+            if (symbols == null) {\n+                symbols = new GJLocaleSymbols(locale);\n+                cCache.put(locale, symbols);\n+            }\n+        }\n+        cFastCache[index] = symbols;\n         return symbols;\n     }\n \n         return max;\n     }\n \n+    private final WeakReference iLocale;\n+\n     private final String[] iEras;\n     private final String[] iDaysOfWeek;\n     private final String[] iShortDaysOfWeek;\n         if (locale == null) {\n             locale = Locale.getDefault();\n         }\n+\n+        iLocale = new WeakReference(locale);\n+\n         DateFormatSymbols dfs = new DateFormatSymbols(locale);\n \n         iEras = dfs.getEras();\n--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJMonthOfYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJMonthOfYearDateTimeField.java\n \n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.chrono.ImpreciseDateTimeField;\n+import org.joda.time.chrono.Utils;\n \n /**\n  * Provides time calculations for the month of the year component of time.\n  * @version 1.0\n  * @since 1.0\n  */\n-final class GJMonthOfYearDateTimeField extends DateTimeField {\n+final class GJMonthOfYearDateTimeField extends ImpreciseDateTimeField {\n+\n+    static final long serialVersionUID = -4748157875845286249L;\n+\n     private static final int MIN = DateTimeConstants.JANUARY;\n     private static final int MAX = DateTimeConstants.DECEMBER;\n \n      * Restricted constructor\n      */\n     GJMonthOfYearDateTimeField(ProlepticChronology chronology) {\n-        super(\"monthOfYear\");\n+        super(\"monthOfYear\", \"months\", chronology.getRoughMillisPerMonth());\n         iChronology = chronology;\n+    }\n+\n+    public boolean isLenient() {\n+        return false;\n     }\n \n     /**\n      *\n      * @see org.joda.time.DateTimeField#get(long)\n      * @see org.joda.time.ReadableDateTime#getMonthOfYear()\n-     * @param millis  the time instant in millis to query.\n+     * @param instant  the time instant in millis to query.\n      * @return the month extracted from the input.\n      */\n-    public int get(long millis) {\n-        return iChronology.getMonthOfYear(millis);\n-    }\n-\n-    public String getAsText(long millis, Locale locale) {\n-        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToText(get(millis));\n-    }\n-\n-    public String getAsShortText(long millis, Locale locale) {\n-        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToShortText(get(millis));\n+    public int get(long instant) {\n+        return iChronology.getMonthOfYear(instant);\n+    }\n+\n+    public String getAsText(long instant, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToText(get(instant));\n+    }\n+\n+    public String getAsShortText(long instant, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToShortText(get(instant));\n     }\n \n     /**\n      * \n      * @see org.joda.time.DateTimeField#add\n      * @see org.joda.time.ReadWritableDateTime#addMonths(int)\n-     * @param millis  the time instant in millis to update.\n+     * @param instant  the time instant in millis to update.\n      * @param months  the months to add (can be negative).\n      * @return the updated time instant.\n      */\n-    public long add(long millis, int months) {\n+    public long add(long instant, int months) {\n         if (months == 0) {\n-            return millis; // the easy case\n+            return instant; // the easy case\n         }\n         //\n         // Save time part first.\n         //\n-        long timePart = iChronology.millisOfDay().get(millis);\n+        long timePart = iChronology.millisOfDay().get(instant);\n         //\n         //\n         // Get this year and month.\n         //\n-        int thisYear = iChronology.year().get(millis);\n-        int thisMonth = iChronology.getMonthOfYear(millis, thisYear);\n+        int thisYear = iChronology.year().get(instant);\n+        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n         // ----------------------------------------------------------\n         //\n         // Do not refactor without careful consideration.\n         //\n         // Quietly force DOM to nearest sane value.\n         //\n-        int dayToUse = iChronology.getDayOfMonth(millis, thisYear, thisMonth);\n+        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n         int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);\n         if (dayToUse > maxDay) {\n             dayToUse = maxDay;\n         return datePart + timePart;\n     }\n \n-    public long add(long millis, long months) {\n+    public long add(long instant, long months) {\n         int i_months = (int)months;\n         if (i_months == months) {\n-            return add(millis, i_months);\n+            return add(instant, i_months);\n         }\n \n         // Copied from add(long, int) and modified slightly:\n \n-        long timePart = iChronology.millisOfDay().get(millis);\n-\n-        int thisYear = iChronology.year().get(millis);\n-        int thisMonth = iChronology.getMonthOfYear(millis, thisYear);\n+        long timePart = iChronology.millisOfDay().get(instant);\n+\n+        int thisYear = iChronology.year().get(instant);\n+        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n \n         long yearToUse;\n         long monthToUse = thisMonth - 1 + months;\n         int i_yearToUse = (int)yearToUse;\n         int i_monthToUse = (int)monthToUse;\n \n-        int dayToUse = iChronology.getDayOfMonth(millis, thisYear, thisMonth);\n+        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n         int maxDay = iChronology.getDaysInYearMonth(i_yearToUse, i_monthToUse);\n         if (dayToUse > maxDay) {\n             dayToUse = maxDay;\n      * \n      * @see org.joda.time.DateTimeField#addWrapped\n      * @see org.joda.time.ReadWritableDateTime#addWrappedMonthOfYear(int)\n-     * @param millis  the time instant in millis to update.\n+     * @param instant  the time instant in millis to update.\n      * @param months  the months to add (can be negative).\n      * @return the updated time instant.\n      */\n-    public long addWrapped(long millis, int months) {\n-        return set(millis, getWrappedValue(get(millis), months, MIN, MAX));\n-    }\n-\n-    public long getDifference(long minuendMillis, long subtrahendMillis) {\n-        if (minuendMillis < subtrahendMillis) {\n-            return -getDifference(subtrahendMillis, minuendMillis);\n+    public long addWrapped(long instant, int months) {\n+        return set(instant, Utils.getWrappedValue(get(instant), months, MIN, MAX));\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        if (minuendInstant < subtrahendInstant) {\n+            return -getDifference(subtrahendInstant, minuendInstant);\n         }\n \n         DateTimeField yearField = iChronology.year();\n-        int minuendYear = yearField.get(minuendMillis);\n-        int minuendMonth = iChronology.getMonthOfYear(minuendMillis, minuendYear);\n-        int subtrahendYear = yearField.get(subtrahendMillis);\n-        int subtrahendMonth = iChronology.getMonthOfYear(subtrahendMillis, subtrahendYear);\n+        int minuendYear = yearField.get(minuendInstant);\n+        int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear);\n+        int subtrahendYear = yearField.get(subtrahendInstant);\n+        int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear);\n \n         long difference = (minuendYear - subtrahendYear) * 12L + minuendMonth - subtrahendMonth;\n \n         // Before adjusting for remainder, account for special case of add\n         // where the day-of-month is forced to the nearest sane value.\n         int minuendDom = iChronology.getDayOfMonth\n-            (minuendMillis, minuendYear, minuendMonth);\n+            (minuendInstant, minuendYear, minuendMonth);\n         if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) {\n             // Last day of the minuend month...\n             int subtrahendDom = iChronology.getDayOfMonth\n-                (subtrahendMillis, subtrahendYear, subtrahendMonth);\n+                (subtrahendInstant, subtrahendYear, subtrahendMonth);\n             if (subtrahendDom > minuendDom) {\n                 // ...and day of subtrahend month is larger.\n-                subtrahendMillis = iChronology.dayOfMonth().set(subtrahendMillis, minuendDom);\n+                subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom);\n             }\n         }\n \n         // Inlined remainder method to avoid duplicate calls.\n-        long minuendRem = minuendMillis\n+        long minuendRem = minuendInstant\n             - iChronology.getYearMonthMillis(minuendYear, minuendMonth);\n-        long subtrahendRem = subtrahendMillis\n+        long subtrahendRem = subtrahendInstant\n             - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth);\n \n         if (minuendRem < subtrahendRem) {\n      * 07-31 to month 6 = 06-30<p>\n      * 03-31 to month 2 = 02-28 or 02-29 depending<p>\n      * \n-     * @param millis  the time instant in millis to update.\n+     * @param instant  the time instant in millis to update.\n      * @param month  the month (1,12) to update the time to.\n      * @return the updated time instant.\n      * @throws IllegalArgumentException  if month is invalid\n      */\n-    public long set(long millis, int month) {\n-        super.verifyValueBounds(month, MIN, MAX);\n-        //\n-        int thisYear = iChronology.year().get(millis);\n-        //\n-        int thisDom = iChronology.getDayOfMonth(millis, thisYear);\n+    public long set(long instant, int month) {\n+        Utils.verifyValueBounds(this, month, MIN, MAX);\n+        //\n+        int thisYear = iChronology.year().get(instant);\n+        //\n+        int thisDom = iChronology.getDayOfMonth(instant, thisYear);\n         int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n         if (thisDom > maxDom) {\n             // Quietly force DOM to nearest sane value.\n         }\n         // Return newly calculated millis value\n         return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n-            iChronology.millisOfDay().get(millis);\n-    }\n-\n-    public long set(long millis, String text, Locale locale) {\n-        return set(millis, GJLocaleSymbols.forLocale(locale).monthOfYearTextToValue(text));\n-    }\n-\n-    public long getUnitMillis() {\n-        return iChronology.getRoughMillisPerMonth();\n-    }\n-\n-    public long getRangeMillis() {\n-        return iChronology.getRoughMillisPerYear();\n+            iChronology.millisOfDay().get(instant);\n+    }\n+\n+    public long set(long instant, String text, Locale locale) {\n+        return set(instant, GJLocaleSymbols.forLocale(locale).monthOfYearTextToValue(text));\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.years();\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        int thisYear = iChronology.year().get(instant);\n+        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n+        if (thisMonth != 2) {\n+            return false;\n+        } else {\n+            return 29 == iChronology.getDaysInYearMonth(thisYear, thisMonth);\n+        }\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        return isLeap(instant) ? 1 : 0;\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return iChronology.days();\n     }\n \n     public int getMinimumValue() {\n         return GJLocaleSymbols.forLocale(locale).getMonthMaxShortTextLength();\n     }\n \n-    public long roundFloor(long millis) {\n-        int year = iChronology.year().get(millis);\n-        int month = iChronology.getMonthOfYear(millis, year);\n+    public long roundFloor(long instant) {\n+        int year = iChronology.year().get(instant);\n+        int month = iChronology.getMonthOfYear(instant, year);\n         return iChronology.getYearMonthMillis(year, month);\n     }\n \n-    public long remainder(long millis) {\n-        return millis - roundFloor(millis);\n+    public long remainder(long instant) {\n+        return instant - roundFloor(instant);\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java\n \n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.chrono.PreciseDurationDateTimeField;\n+import org.joda.time.chrono.Utils;\n \n /**\n  * Provides time calculations for the week of a week based year component of time.\n  * @version 1.0\n  * @since 1.0\n  */\n-final class GJWeekOfWeekyearDateTimeField extends DateTimeField {\n+final class GJWeekOfWeekyearDateTimeField extends PreciseDurationDateTimeField {\n \n-    private static final int MIN = 1;\n-    private static final int MAX = 53;\n+    static final long serialVersionUID = -1587436826395135328L;\n \n     private final ProlepticChronology iChronology;\n \n     /**\n      * Restricted constructor\n      */\n-    GJWeekOfWeekyearDateTimeField(ProlepticChronology chronology) {\n-        super(\"weekOfWeekyear\");\n+    GJWeekOfWeekyearDateTimeField(ProlepticChronology chronology, DurationField weeks) {\n+        super(\"weekOfWeekyear\", weeks);\n         iChronology = chronology;\n     }\n \n      * Get the week of a week based year component of the specified time instant.\n      * \n      * @see org.joda.time.DateTimeField#get(long)\n-     * @param millis  the time instant in millis to query.\n+     * @param instant  the time instant in millis to query.\n      * @return the week of the year extracted from the input.\n      */\n-    public int get(long millis) {\n-        int year = iChronology.year().get(millis);\n+    public int get(long instant) {\n+        int year = iChronology.year().get(instant);\n         //\n         long firstWeekMillis1 = iChronology.getFirstWeekOfYearMillis(year);\n-        if (millis < firstWeekMillis1) {\n+        if (instant < firstWeekMillis1) {\n             return iChronology.getWeeksInYear(year - 1);\n         }\n         long firstWeekMillis2 = iChronology.getFirstWeekOfYearMillis(year + 1);\n-        if (millis >= firstWeekMillis2) {\n+        if (instant >= firstWeekMillis2) {\n             return 1;\n         }\n-        return (int) ((millis - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;\n+        return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;\n     }\n \n-    /**\n-     * Add the specified weeks to the specified time instant.\n-     * <p>\n-     * The amount added may be negative.\n-     * \n-     * @see org.joda.time.DateTimeField#add\n-     * @param millis  the time instant in millis to update.\n-     * @param weeks  the weeks to add (can be negative).\n-     * @return the updated time instant.\n-     */\n-    public long add(long millis, int weeks) {\n-        // Return newly calculated millis value\n-        return millis + (weeks * (long)DateTimeConstants.MILLIS_PER_WEEK);\n+    public DurationField getRangeDurationField() {\n+        return iChronology.weekyears();\n     }\n \n-    public long add(long millis, long weeks) {\n-        // Return newly calculated millis value\n-        return millis + (weeks * DateTimeConstants.MILLIS_PER_WEEK);\n+    // 1970-01-01 is day of week 4, Thursday. The rounding methods need to\n+    // apply a corrective alignment since weeks begin on day of week 1, Monday.\n+\n+    public long roundFloor(long instant) {\n+        return super.roundFloor(instant + 3 * DateTimeConstants.MILLIS_PER_DAY)\n+            - 3 * DateTimeConstants.MILLIS_PER_DAY;\n     }\n \n-    /**\n-     * Add to the week component of the specified time instant\n-     * wrapping around within that component if necessary.\n-     * \n-     * @see org.joda.time.DateTimeField#addWrapped\n-     * @param millis  the time instant in millis to update.\n-     * @param years  the years to add (can be negative).\n-     * @return the updated time instant.\n-     */\n-    public long addWrapped(long millis, int weeks) {\n-        int thisWeek = get(millis);\n-        int wrappedWeek = getWrappedValue(thisWeek, weeks, 1, getMaximumValue(millis));\n-        return millis + (wrappedWeek - thisWeek) * (long)DateTimeConstants.MILLIS_PER_WEEK;\n+    public long roundCeiling(long instant) {\n+        return super.roundCeiling(instant + 3 * DateTimeConstants.MILLIS_PER_DAY)\n+            - 3 * DateTimeConstants.MILLIS_PER_DAY;\n     }\n \n-    public long getDifference(long minuendMillis, long subtrahendMillis) {\n-        return (minuendMillis - subtrahendMillis) / DateTimeConstants.MILLIS_PER_WEEK;\n-    }\n-\n-    /**\n-     * Set the week of a week based year component of the specified time instant.\n-     * \n-     * @see org.joda.time.DateTimeField#set\n-     * @param millis  the time instant in millis to update.\n-     * @param week  the week (1,53) to update the time to.\n-     * @return the updated time instant.\n-     * @throws IllegalArgumentException  if week is invalid.\n-     */\n-    public long set(long millis, int week) {\n-        verifyValueBounds(week, 1, getMaximumValue(millis));\n-        int thisWeek = get(millis);\n-        return millis + (week - thisWeek) * (long)DateTimeConstants.MILLIS_PER_WEEK;\n-    }\n-\n-    public long getUnitMillis() {\n-        return DateTimeConstants.MILLIS_PER_WEEK;\n-    }\n-\n-    public long getRangeMillis() {\n-        return iChronology.getRoughMillisPerYear();\n+    public long remainder(long instant) {\n+        return super.remainder(instant + 3 * DateTimeConstants.MILLIS_PER_DAY);\n     }\n \n     public int getMinimumValue() {\n-        return MIN;\n+        return 1;\n     }\n \n     public int getMaximumValue() {\n-        return MAX;\n+        return 53;\n     }\n \n-    public int getMaximumValue(long millis) {\n-        int thisYear = iChronology.weekyear().get(millis);\n+    public int getMaximumValue(long instant) {\n+        int thisYear = iChronology.weekyear().get(instant);\n         return iChronology.getWeeksInYear(thisYear);\n-    }\n-\n-    public long roundFloor(long millis) {\n-        DateTimeField dowField = iChronology.dayOfWeek();\n-        millis = dowField.roundFloor(millis);\n-        int dow = dowField.get(millis);\n-        if (dow > 1) {\n-            millis = dowField.add(millis, 1 - dow);\n-        }\n-        return millis;\n-    }\n-\n-    public long remainder(long millis) {\n-        return millis - roundFloor(millis);\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekyearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekyearDateTimeField.java\n \n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.chrono.ImpreciseDateTimeField;\n+import org.joda.time.chrono.Utils;\n \n /**\n  * Provides time calculations for the week of the weekyear component of time.\n  * @since 1.0\n  * @see org.joda.time.DateTimeField\n  */\n-final class GJWeekyearDateTimeField extends DateTimeField {\n+final class GJWeekyearDateTimeField extends ImpreciseDateTimeField {\n     \n+    static final long serialVersionUID = 6215066916806820644L;\n+\n     private static final long WEEK_53 = (53L - 1) * DateTimeConstants.MILLIS_PER_WEEK;\n \n     private final ProlepticChronology iChronology;\n      * Restricted constructor\n      */\n     GJWeekyearDateTimeField(ProlepticChronology chronology) {\n-        super(\"weekyear\");\n+        super(\"weekyear\", \"weekyears\", chronology.getRoughMillisPerYear());\n         iChronology = chronology;\n+    }\n+\n+    public boolean isLenient() {\n+        return false;\n     }\n \n     /**\n      * Get the Year of a week based year component of the specified time instant.\n      * \n      * @see org.joda.time.DateTimeField#get\n-     * @param millis  the time instant in millis to query.\n+     * @param instant  the time instant in millis to query.\n      * @return the year extracted from the input.\n      */\n-    public int get(long millis) {\n-        int week = iChronology.weekOfWeekyear().get(millis);\n+    public int get(long instant) {\n+        int week = iChronology.weekOfWeekyear().get(instant);\n         if (week == 1) {\n-            return iChronology.year().get(millis + DateTimeConstants.MILLIS_PER_WEEK);\n+            return iChronology.year().get(instant + DateTimeConstants.MILLIS_PER_WEEK);\n         } else if (week > 51) {\n-            return iChronology.year().get(millis - (2 * DateTimeConstants.MILLIS_PER_WEEK));\n+            return iChronology.year().get(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK));\n         } else {\n-            return iChronology.year().get(millis);\n+            return iChronology.year().get(instant);\n         }\n     }\n \n      * Add the specified years to the specified time instant.\n      * \n      * @see org.joda.time.DateTimeField#add\n-     * @param millis  the time instant in millis to update.\n+     * @param instant  the time instant in millis to update.\n      * @param years  the years to add (can be negative).\n      * @return the updated time instant.\n      */\n-    public long add(long millis, int years) {\n+    public long add(long instant, int years) {\n         if (years == 0) {\n-            return millis;\n-        }\n-        return set(millis, get(millis) + years);\n-    }\n-\n-    public long add(long millis, long value) {\n-        return addLong(millis, value);\n+            return instant;\n+        }\n+        return set(instant, get(instant) + years);\n+    }\n+\n+    public long add(long instant, long value) {\n+        return add(instant, Utils.safeToInt(value));\n     }\n \n     /**\n      * wrapping around within that component if necessary.\n      * \n      * @see org.joda.time.DateTimeField#addWrapped\n-     * @param millis  the time instant in millis to update.\n+     * @param instant  the time instant in millis to update.\n      * @param years  the years to add (can be negative).\n      * @return the updated time instant.\n      */\n-    public long addWrapped(long millis, int years) {\n-        return add(millis, years);\n-    }\n-\n-    public long getDifference(long minuendMillis, long subtrahendMillis) {\n-        if (minuendMillis < subtrahendMillis) {\n-            return -getDifference(subtrahendMillis, minuendMillis);\n-        }\n-\n-        int minuendWeekyear = get(minuendMillis);\n-        int subtrahendWeekyear = get(subtrahendMillis);\n-\n-        long minuendRem = remainder(minuendMillis);\n-        long subtrahendRem = remainder(subtrahendMillis);\n+    public long addWrapped(long instant, int years) {\n+        return add(instant, years);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        if (minuendInstant < subtrahendInstant) {\n+            return -getDifference(subtrahendInstant, minuendInstant);\n+        }\n+\n+        int minuendWeekyear = get(minuendInstant);\n+        int subtrahendWeekyear = get(subtrahendInstant);\n+\n+        long minuendRem = remainder(minuendInstant);\n+        long subtrahendRem = remainder(subtrahendInstant);\n \n         // Balance leap weekyear differences on remainders.\n         if (subtrahendRem >= WEEK_53 && iChronology.getWeeksInYear(minuendWeekyear) <= 52) {\n      * Set the Year of a week based year component of the specified time instant.\n      *\n      * @see org.joda.time.DateTimeField#set\n-     * @param millis  the time instant in millis to update.\n+     * @param instant  the time instant in millis to update.\n      * @param year  the year (-9999,9999) to set the date to.\n      * @return the updated DateTime.\n      * @throws IllegalArgumentException  if year is invalid.\n      */\n-    public long set(long millis, int year) {\n-        super.verifyValueBounds(Math.abs(year),\n+    public long set(long instant, int year) {\n+        Utils.verifyValueBounds(this, Math.abs(year),\n                                 iChronology.getMinYear(), iChronology.getMaxYear());\n         //\n         // Do nothing if no real change is requested.\n         //\n-        int thisWeekyear = get( millis );\n+        int thisWeekyear = get( instant );\n         if ( thisWeekyear == year ) {\n-            return millis;\n+            return instant;\n         }\n         //\n         // Calculate the DayOfWeek (to be preserved).\n         //\n-        int thisDow = iChronology.dayOfWeek().get( millis );\n+        int thisDow = iChronology.dayOfWeek().get( instant );\n         //\n         // Calculate the maximum weeks in the target year.\n         //\n         // for the target weekyear.  In that case it is adjusted\n         // to the maximum possible.\n         //\n-        int setToWeek = iChronology.weekOfWeekyear().get( millis );\n+        int setToWeek = iChronology.weekOfWeekyear().get( instant );\n         if ( setToWeek > maxOutWeeks ) {\n             setToWeek = maxOutWeeks;\n         }\n         // Get a wroking copy of the current date-time.\n         // This can be a convenience for debugging.\n         //\n-        long workMillis = millis; // Get a copy\n+        long workInstant = instant; // Get a copy\n         //\n         // Attempt to get close to the proper weekyear.\n         // Note - we cannot currently call ourself, so we just call\n         // set for the year.  This at least gets us close.\n         //\n-        workMillis = iChronology.year().set( workMillis, year );\n+        workInstant = iChronology.year().set( workInstant, year );\n         //\n         // Calculate the weekyear number for the get close to value\n         // (which might not be equal to the year just set).\n         //\n-        int workWoyYear = iChronology.weekyear().get( workMillis );\n-\n-        // *TEMP Debugging\n-        /*\n-        MutableDateTime temp = new MutableDateTime(workMillis,\n-            ISOChronology.getInstance());\n-        System.out.println(\"Current mdt value 01: \"\n-            + temp\n-            + \" \" + workWoyYear\n-        );\n-        System.out.println(\"->Temp: \" + temp.toString()\n-            + \" WOYYr=\" + temp.getWeekyear()\n-            + \" WOYWk=\" + temp.getWeekOfWeekyear()\n-            + \" DoW=\" + temp.getDayOfWeek()\n-        );\n-        */\n+        int workWoyYear = iChronology.weekyear().get( workInstant );\n \n         //\n         // At most we are off by one year, which can be \"fixed\" by\n         // adding/subtracting a week.\n         //\n         if ( workWoyYear < year ) {\n-            // System.out.println(\"Year: Adding \"+workWoyYear+\" \"+year);\n-            workMillis += DateTimeConstants.MILLIS_PER_WEEK;\n+            workInstant += DateTimeConstants.MILLIS_PER_WEEK;\n         } else if ( workWoyYear > year ) {\n-            // System.out.println(\"Year: Subing \"+workWoyYear+\" \"+year);\n-            workMillis -= DateTimeConstants.MILLIS_PER_WEEK;\n+            workInstant -= DateTimeConstants.MILLIS_PER_WEEK;\n         }\n         //\n         // Set the proper week in the current weekyear.\n         //\n \n         // BEGIN: possible set WeekOfWeekyear logic.\n-        int currentWoyWeek = iChronology.weekOfWeekyear().get( workMillis );\n+        int currentWoyWeek = iChronology.weekOfWeekyear().get( workInstant );\n         // No range check required (we already know it is OK).\n-        workMillis = workMillis + (setToWeek - currentWoyWeek)\n+        workInstant = workInstant + (setToWeek - currentWoyWeek)\n             * (long)DateTimeConstants.MILLIS_PER_WEEK;\n         // END: possible set WeekOfWeekyear logic.\n \n         //\n         // Reset DayOfWeek to previous value.\n         //\n-        workMillis = iChronology.dayOfWeek().set( workMillis, thisDow );\n+        workInstant = iChronology.dayOfWeek().set( workInstant, thisDow );\n         //\n         // Return result.\n         //\n-        return workMillis;\n-    }\n-\n-    public long getUnitMillis() {\n-        return iChronology.getRoughMillisPerYear();\n-    }\n-\n-    public long getRangeMillis() {\n-        // Should actually be double this, but that is not possible since Java\n-        // doesn't support unsigned types.\n-        return Long.MAX_VALUE;\n+        return workInstant;\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return iChronology.weekOfWeekyear().getMaximumValue(instant) > 52;\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        return iChronology.weekOfWeekyear().getMaximumValue(instant) - 52;\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return iChronology.weeks();\n     }\n \n     public int getMinimumValue() {\n         return iChronology.getMaxYear();\n     }\n \n-    public long roundFloor(long millis) {\n+    public long roundFloor(long instant) {\n         DateTimeField wowField = iChronology.weekOfWeekyear();\n-        millis = wowField.roundFloor(millis);\n-        int wow = wowField.get(millis);\n+        instant = wowField.roundFloor(instant);\n+        int wow = wowField.get(instant);\n         if (wow > 1) {\n-            millis = wowField.add(millis, 1 - wow);\n-        }\n-        return millis;\n-    }\n-\n-    public long remainder(long millis) {\n-        return millis - roundFloor(millis);\n+            instant = wowField.add(instant, 1 - wow);\n+        }\n+        return instant;\n+    }\n+\n+    public long remainder(long instant) {\n+        return instant - roundFloor(instant);\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJYearDateTimeField.java\n package org.joda.time.chrono.gj;\n \n import org.joda.time.DateTimeConstants;\n-import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.chrono.ImpreciseDateTimeField;\n+import org.joda.time.chrono.Utils;\n \n /**\n  * Provides time calculations for the year component of time.\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-final class GJYearDateTimeField extends DateTimeField {\n+final class GJYearDateTimeField extends ImpreciseDateTimeField {\n+\n+    static final long serialVersionUID = -679076949530018869L;\n \n     private static final long FEB_29 = (31L + 29 - 1) * DateTimeConstants.MILLIS_PER_DAY;\n \n     private final ProlepticChronology iChronology;\n-    private final transient long iRoughMillisPerYear;\n \n     /**\n      * Restricted constructor\n      */\n     GJYearDateTimeField(ProlepticChronology chronology) {\n-        super(\"year\");\n+        super(\"year\", \"years\", chronology.getRoughMillisPerYear());\n         iChronology = chronology;\n-        iRoughMillisPerYear = chronology.getRoughMillisPerYear();\n+    }\n+\n+    public boolean isLenient() {\n+        return false;\n     }\n \n     /**\n      * Get the Year component of the specified time instant.\n      * \n-     * @param millis  the time instant in millis to query.\n+     * @param instant  the time instant in millis to query.\n      * @return the year extracted from the input.\n      */\n-    public int get(long millis) {\n-        // Get an initial estimate of the year, and the millis value\n-        // that represents the start of that year.\n-        int year = 1970 + (int) (millis / iRoughMillisPerYear);\n-        long yearStartMillis = iChronology.getYearMillis(year);\n-\n-        if (millis > yearStartMillis) {\n-            for (;;) {\n-                // Actual year may be greater than what we estimated. Check if\n-                // year should advance.\n-                if (iChronology.isLeapYear(year)) {\n-                    yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 366L;\n-                } else {\n-                    yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 365L;\n-                }\n-                if (millis < yearStartMillis) {\n-                    // Year was correct, no need to advance.\n-                    break;\n-                }\n+    public int get(long instant) {\n+        // Get an initial estimate of the year, and the millis value that\n+        // represents the start of that year. Then verify estimate and fix if\n+        // necessary.\n+\n+        int year;\n+\n+        long unitMillis = getDurationUnitMillis();\n+        if (instant >= 0) {\n+            year = 1970 + (int) (instant / unitMillis);\n+        } else {\n+            year = 1970 + (int) ((instant - unitMillis + 1) / unitMillis);\n+        }\n+\n+        long yearStart = iChronology.getYearMillis(year);\n+        if ((yearStart ^ instant) < 0) {\n+            // Sign mismatch, operation overflowed.\n+            return getOverflow(instant);\n+        }\n+\n+        long diff = instant - yearStart;\n+\n+        if (diff < 0) {\n+            // Subtract one year to fix estimate.\n+            year--;\n+        } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {\n+            // One year may need to be added to fix estimate.\n+            long oneYear;\n+            if (iChronology.isLeapYear(year)) {\n+                oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;\n+            } else {\n+                oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;\n+            }\n+\n+            yearStart += oneYear;\n+            if ((yearStart ^ instant) < 0) {\n+                // Sign mismatch, operation overflowed.\n+                return getOverflow(instant);\n+            }\n+\n+            if (yearStart <= instant) {\n+                // Didn't go too far, so actually add one year.\n                 year++;\n-                if (millis == yearStartMillis) {\n-                    // Millis is at start of year; year is now correct, so no\n-                    // need to check anymore.\n-                    break;\n-                }\n-                if ((millis ^ yearStartMillis) < 0) {\n-                    // Sign mismatch, operation overflowed.\n-                    return getOverflow(millis);\n-                }\n-            }\n-        } else if (millis < yearStartMillis) {\n-            for (;;) {\n-                // Actual year less than what we estimated. Go to previous year\n-                // and check.\n-                year--;\n-                if (iChronology.isLeapYear(year)) {\n-                    yearStartMillis -= DateTimeConstants.MILLIS_PER_DAY * 366L;\n-                } else {\n-                    yearStartMillis -= DateTimeConstants.MILLIS_PER_DAY * 365L;\n-                }\n-                if (millis >= yearStartMillis) {\n-                    // Year is now correct.\n-                    break;\n-                }\n-                if ((millis ^ yearStartMillis) < 0) {\n-                    // Sign mismatch, operation overflowed.\n-                    return getOverflow(millis);\n-                }\n             }\n         }\n \n         return year;\n     }\n \n-    private int getOverflow(long millis) {\n-        if (millis > 0) {\n+    private int getOverflow(long instant) {\n+        if (instant > 0) {\n             int year = iChronology.getMaxYear();\n             long yearStartMillis = iChronology.getYearMillis(year);\n             if (iChronology.isLeapYear(year)) {\n             }\n             long yearEndMillis = yearStartMillis - 1;\n \n-            if (millis <= yearEndMillis) {\n+            if (instant <= yearEndMillis) {\n                 return year;\n             }\n \n             throw new IllegalArgumentException\n-                (\"Instant too large: \" + millis + \" > \" + yearEndMillis);\n+                (\"Instant too large: \" + instant + \" > \" + yearEndMillis);\n         } else {\n             int year = iChronology.getMinYear();\n             long yearStartMillis = iChronology.getYearMillis(year);\n-            if (millis >= yearStartMillis) {\n+            if (instant >= yearStartMillis) {\n                 return year;\n             }\n \n             throw new IllegalArgumentException\n-                (\"Instant too small: \" + millis + \" < \" + yearStartMillis);\n+                (\"Instant too small: \" + instant + \" < \" + yearStartMillis);\n         }\n     }\n \n      * Add the specified year to the specified time instant.\n      * The amount added may be negative.\n      * \n-     * @param millis  the time instant in millis to update.\n+     * @param instant  the time instant in millis to update.\n      * @param years  the years to add (can be negative).\n      * @return the updated time instant.\n      */\n-    public long add(long millis, int years) {\n+    public long add(long instant, int years) {\n         if (years == 0) {\n-            return millis;\n-        }\n-        int thisYear = get(millis);\n+            return instant;\n+        }\n+        int thisYear = get(instant);\n         int newYear = thisYear + years;\n-        return set(millis, newYear);\n-    }\n-\n-    public long add(long millis, long years) {\n-        return addLong(millis, years);\n+        return set(instant, newYear);\n+    }\n+\n+    public long add(long instant, long years) {\n+        return add(instant, Utils.safeToInt(years));\n     }\n \n     /**\n      * Add to the Year component of the specified time instant\n      * wrapping around within that component if necessary.\n      * \n-     * @param millis  the time instant in millis to update.\n+     * @param instant  the time instant in millis to update.\n      * @param years  the years to add (can be negative).\n      * @return the updated time instant.\n      */\n-    public long addWrapped(long millis, int years) {\n+    public long addWrapped(long instant, int years) {\n         if (years == 0) {\n-            return millis;\n+            return instant;\n         }\n         // Return newly calculated millis value\n-        int thisYear = iChronology.year().get(millis);\n-        int wrappedYear = getWrappedValue\n+        int thisYear = iChronology.year().get(instant);\n+        int wrappedYear = Utils.getWrappedValue\n             (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear());\n-        return set(millis, wrappedYear);\n-    }\n-\n-    public long getDifference(long minuendMillis, long subtrahendMillis) {\n-        if (minuendMillis < subtrahendMillis) {\n-            return -getDifference(subtrahendMillis, minuendMillis);\n-        }\n-\n-        int minuendYear = get(minuendMillis);\n-        int subtrahendYear = get(subtrahendMillis);\n+        return set(instant, wrappedYear);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        if (minuendInstant < subtrahendInstant) {\n+            return -getDifference(subtrahendInstant, minuendInstant);\n+        }\n+\n+        int minuendYear = get(minuendInstant);\n+        int subtrahendYear = get(subtrahendInstant);\n \n         // Inlined remainder method to avoid duplicate calls to get.\n-        long minuendRem = minuendMillis - iChronology.getYearMillis(minuendYear);\n-        long subtrahendRem = subtrahendMillis - iChronology.getYearMillis(subtrahendYear);\n+        long minuendRem = minuendInstant - iChronology.getYearMillis(minuendYear);\n+        long subtrahendRem = subtrahendInstant - iChronology.getYearMillis(subtrahendYear);\n \n         // Balance leap year differences on remainders.\n         if (subtrahendRem >= FEB_29) {\n     /**\n      * Set the Year component of the specified time instant.\n      * \n-     * @param millis  the time instant in millis to update.\n+     * @param instant  the time instant in millis to update.\n      * @param year  the year (-292269055,292278994) to update the time to.\n      * @return the updated time instant.\n      * @throws IllegalArgumentException  if year is invalid.\n      */\n-    public long set(long millis, int year) {\n-        super.verifyValueBounds(year, iChronology.getMinYear(), iChronology.getMaxYear());\n-\n-        int dayOfYear = iChronology.dayOfYear().get(millis);\n-        int millisOfDay = iChronology.millisOfDay().get(millis);\n+    public long set(long instant, int year) {\n+        Utils.verifyValueBounds\n+            (this, year, iChronology.getMinYear(), iChronology.getMaxYear());\n+\n+        int dayOfYear = iChronology.dayOfYear().get(instant);\n+        int millisOfDay = iChronology.millisOfDay().get(instant);\n \n         if (dayOfYear > (31 + 28)) { // after Feb 28\n-            if (isLeap(millis)) {\n+            if (isLeap(instant)) {\n                 // Old date is Feb 29 or later.\n                 if (!iChronology.isLeapYear(year)) {\n                     // Moving to a non-leap year, Feb 29 does not exist.\n             }\n         }\n \n-        millis = iChronology.getYearMonthDayMillis(year, 1, dayOfYear);\n-        millis += millisOfDay;\n-\n-        return millis;\n-    }\n-\n-    public boolean isLeap(long millis) {\n-        return iChronology.isLeapYear(get(millis));\n-    }\n-\n-    public int getLeapAmount(long millis) {\n-        if (iChronology.isLeapYear(get(millis))) {\n+        instant = iChronology.getYearMonthDayMillis(year, 1, dayOfYear);\n+        instant += millisOfDay;\n+\n+        return instant;\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return iChronology.isLeapYear(get(instant));\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        if (iChronology.isLeapYear(get(instant))) {\n             return 1;\n         } else {\n             return 0;\n         }\n     }\n \n-    public long getUnitMillis() {\n-        return iRoughMillisPerYear;\n-    }\n-\n-    public long getRangeMillis() {\n-        // Should actually be double this, but that is not possible since Java\n-        // doesn't support unsigned types.\n-        return Long.MAX_VALUE;\n+    public DurationField getLeapDurationField() {\n+        return iChronology.days();\n     }\n \n     public int getMinimumValue() {\n         return iChronology.getMaxYear();\n     }\n \n-    public long roundFloor(long millis) {\n-        return iChronology.getYearMillis(get(millis));\n-    }\n-\n-    public long roundCeiling(long millis) {\n-        int year = get(millis);\n+    public long roundFloor(long instant) {\n+        return iChronology.getYearMillis(get(instant));\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        int year = get(instant);\n         long yearStartMillis = iChronology.getYearMillis(year);\n-        if (millis != yearStartMillis) {\n+        if (instant != yearStartMillis) {\n             // Bump up to start of next year.\n-            millis = iChronology.getYearMillis(year + 1);\n-        }\n-        return millis;\n-    }\n-\n-    public long remainder(long millis) {\n-        return millis - roundFloor(millis);\n+            instant = iChronology.getYearMillis(year + 1);\n+        }\n+        return instant;\n+    }\n+\n+    public long remainder(long instant) {\n+        return instant - roundFloor(instant);\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJYearOfEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJYearOfEraDateTimeField.java\n \n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.DecoratedDateTimeField;\n+import org.joda.time.chrono.Utils;\n \n /**\n  * Provides time calculations for the year of era component of time.\n  * \n  * @author Brian S O'Neill\n  */\n-final class GJYearOfEraDateTimeField extends DateTimeField {\n+final class GJYearOfEraDateTimeField extends DecoratedDateTimeField {\n+\n+    static final long serialVersionUID = -5961050944769862059L;\n+\n     private final ProlepticChronology iChronology;\n \n     /**\n-     * Restricted constructor\n+     * Restricted constructor.\n      */\n-    GJYearOfEraDateTimeField(ProlepticChronology chronology) {\n-        super(\"yearOfEra\");\n+    GJYearOfEraDateTimeField(DateTimeField yearField, ProlepticChronology chronology) {\n+        super(yearField, \"yearOfEra\");\n         iChronology = chronology;\n     }\n \n     /**\n      * Get the year of era component of the specified time instant.\n      * \n-     * @param millis  the time instant in millis to query.\n+     * @param instant  the time instant in millis to query.\n      * @return the year of era extracted from the input.\n      */\n-    public int get(long millis) {\n-        int year = iChronology.year().get(millis);\n+    public int get(long instant) {\n+        int year = getWrappedField().get(instant);\n         if (year <= 0) {\n             year = 1 - year;\n         }\n      * Add the specified year to the specified time instant.\n      * The amount added may be negative.\n      * \n-     * @param millis  the time instant in millis to update.\n+     * @param instant  the time instant in millis to update.\n      * @param years  the years to add (can be negative).\n      * @return the updated time instant.\n      */\n-    public long add(long millis, int years) {\n-        return iChronology.year().add(millis, years);\n+    public long add(long instant, int years) {\n+        return getWrappedField().add(instant, years);\n     }\n \n-    public long add(long millis, long years) {\n-        return addLong(millis, years);\n+    public long add(long instant, long years) {\n+        return getWrappedField().add(instant, years);\n     }\n \n     /**\n      * Add to the year component of the specified time instant\n      * wrapping around within that component if necessary.\n      * \n-     * @param millis  the time instant in millis to update.\n+     * @param instant  the time instant in millis to update.\n      * @param years  the years to add (can be negative).\n      * @return the updated time instant.\n      */\n-    public long addWrapped(long millis, int years) {\n-        return iChronology.year().addWrapped(millis, years);\n+    public long addWrapped(long instant, int years) {\n+        return getWrappedField().addWrapped(instant, years);\n     }\n \n-    public long getDifference(long minuendMillis, long subtrahendMillis) {\n-        return iChronology.year().getDifference(minuendMillis, subtrahendMillis);\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n     }\n \n     /**\n      * Set the year component of the specified time instant.\n      * \n-     * @param millis  the time instant in millis to update.\n+     * @param instant  the time instant in millis to update.\n      * @param year  the year (0,292278994) to update the time to.\n      * @return the updated time instant.\n      * @throws IllegalArgumentException  if year is invalid.\n      */\n-    public long set(long millis, int year) {\n-        super.verifyValueBounds(year, 1, iChronology.getMaxYear());\n-        if (iChronology.era().get(millis) == DateTimeConstants.BCE) {\n-            return iChronology.year().set(millis, 1 - year);\n+    public long set(long instant, int year) {\n+        Utils.verifyValueBounds(this, year, 1, getMaximumValue());\n+        if (iChronology.era().get(instant) == DateTimeConstants.BCE) {\n+            return super.set(instant, 1 - year);\n         } else {\n-            return iChronology.year().set(millis, year);\n+            return super.set(instant, year);\n         }\n-    }\n-\n-    public long getUnitMillis() {\n-        return iChronology.getRoughMillisPerYear();\n-    }\n-\n-    public long getRangeMillis() {\n-        return Long.MAX_VALUE;\n     }\n \n     public int getMinimumValue() {\n     }\n \n     public int getMaximumValue() {\n-        return iChronology.getMaxYear();\n+        return getWrappedField().getMaximumValue();\n     }\n \n-    public long roundFloor(long millis) {\n-        return iChronology.year().roundFloor(millis);\n+    public long roundFloor(long instant) {\n+        return getWrappedField().roundFloor(instant);\n     }\n \n-    public long roundCeiling(long millis) {\n-        return iChronology.year().roundCeiling(millis);\n+    public long roundCeiling(long instant) {\n+        return getWrappedField().roundCeiling(instant);\n     }\n \n-    public long remainder(long millis) {\n-        return iChronology.year().remainder(millis);\n+    public long remainder(long instant) {\n+        return getWrappedField().remainder(instant);\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJZonedChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJZonedChronology.java\n import org.joda.time.chrono.ZonedChronology;\n \n /**\n- * A specialism of zoned chronology for the GJ chronology.\n+ * A special zoned chronology for the GJ chronology.\n  * \n  * @author Brian S O'Neill\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-class GJZonedChronology extends GJChronology {\n+final class GJZonedChronology extends GJChronology {\n+\n+    static final long serialVersionUID = -4148749408058922172L;\n+\n     private final GJChronology iChronology;\n     private final DateTimeZone iZone;\n+    private final ZonedChronology iZonedChronology;\n \n     GJZonedChronology(GJChronology chrono, DateTimeZone zone) {\n         iChronology = chrono;\n         iZone = zone;\n-\n-        Chronology zc = new ZonedChronology(chrono, zone);\n-\n-        iYearField = zc.year();\n-        iYearOfEraField = zc.yearOfEra();\n-        iYearOfCenturyField = zc.yearOfCentury();\n-        iCenturyOfEraField = zc.centuryOfEra();\n-        iEraField = zc.era();\n-        iDayOfMonthField = zc.dayOfMonth();\n-        iDayOfWeekField = zc.dayOfWeek();\n-        iDayOfYearField = zc.dayOfYear();\n-        iMonthOfYearField = zc.monthOfYear();\n-        iWeekOfWeekyearField = zc.weekOfWeekyear();\n-        iWeekyearField = zc.weekyear();\n-        \n-        iMillisOfSecondField = zc.millisOfSecond();\n-        iMillisOfDayField = zc.millisOfDay();\n-        iSecondOfMinuteField = zc.secondOfMinute();\n-        iSecondOfDayField = zc.secondOfDay();\n-        iMinuteOfHourField = zc.minuteOfHour();\n-        iMinuteOfDayField = zc.minuteOfDay();\n-        iHourOfDayField = zc.hourOfDay();\n-        iHourOfHalfdayField = zc.hourOfHalfday();\n-        iClockhourOfDayField = zc.clockhourOfDay();\n-        iClockhourOfHalfdayField = zc.clockhourOfHalfday();\n-        iHalfdayOfDayField = zc.halfdayOfDay();\n+        copyFields(iZonedChronology = new ZonedChronology(chrono, zone));\n     }\n \n     public DateTimeZone getDateTimeZone() {\n \n     public Chronology withUTC() {\n         return iChronology;\n+    }\n+\n+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException\n+    {\n+        return iZonedChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);\n+    }\n+\n+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n+                                        int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return iZonedChronology.getTimeOnlyMillis\n+            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                        int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        return iZonedChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n+    }\n+\n+    public long getDateTimeMillis(long instant,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return iZonedChronology.getDateTimeMillis\n+            (instant,\n+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return iZonedChronology.getDateTimeMillis\n+            (year, monthOfYear, dayOfMonth,\n+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n     }\n \n     public long getGregorianJulianCutoverMillis() {\n--- a/JodaTime/src/java/org/joda/time/chrono/gj/GregorianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GregorianChronology.java\n  * @author Brian S O'Neill\n  */\n final class GregorianChronology extends ProlepticChronology {\n+\n+    static final long serialVersionUID = 3691407383323710523L;\n+\n     GregorianChronology(int minDaysInFirstWeek) {\n         super(minDaysInFirstWeek);\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/gj/JulianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/JulianChronology.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeField;\n-import org.joda.time.chrono.DelegateDateTimeField;\n+import org.joda.time.chrono.DelegatedDateTimeField;\n+import org.joda.time.chrono.Utils;\n \n /**\n  * Year zero is dropped from the year and weekyear fields.\n  * @author Brian S O'Neill\n  */\n final class JulianChronology extends GJChronology {\n+\n+    static final long serialVersionUID = -8731039522547897247L;\n+\n     private final JulianWithYearZeroChronology iChronology;\n \n     /**\n         JulianWithYearZeroChronology chrono =\n             new JulianWithYearZeroChronology(minDaysInFirstWeek);\n         iChronology = chrono;\n+        copyFields(chrono);\n+\n+        // Override only the fields that differ.\n \n         iYearField = new NoYearZeroField(chrono.year());\n-        iYearOfEraField = chrono.yearOfEra();\n-        iYearOfCenturyField = chrono.yearOfCentury();\n-        iCenturyOfEraField = chrono.centuryOfEra();\n-        iEraField = chrono.era();\n-        iDayOfMonthField = chrono.dayOfMonth();\n-        iDayOfWeekField = chrono.dayOfWeek();\n-        iDayOfYearField = chrono.dayOfYear();\n-        iMonthOfYearField = chrono.monthOfYear();\n-        iWeekOfWeekyearField = chrono.weekOfWeekyear();\n         iWeekyearField = new NoWeekyearZeroField(chrono.weekyear());\n-        \n-        iMillisOfSecondField = chrono.millisOfSecond();\n-        iMillisOfDayField = chrono.millisOfDay();\n-        iSecondOfMinuteField = chrono.secondOfMinute();\n-        iSecondOfDayField = chrono.secondOfDay();\n-        iMinuteOfHourField = chrono.minuteOfHour();\n-        iMinuteOfDayField = chrono.minuteOfDay();\n-        iHourOfDayField = chrono.hourOfDay();\n-        iHourOfHalfdayField = chrono.hourOfHalfday();\n-        iClockhourOfDayField = chrono.clockhourOfDay();\n-        iClockhourOfHalfdayField = chrono.clockhourOfHalfday();\n-        iHalfdayOfDayField = chrono.halfdayOfDay();\n     }\n \n     public Chronology withUTC() {\n         return this;\n     }\n \n+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException\n+    {\n+        year = adjustYearForSet(year);\n+        return iChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);\n+    }\n+\n+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return iChronology.getTimeOnlyMillis\n+            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        year = adjustYearForSet(year);\n+        return iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n+    }\n+\n+    public long getDateTimeMillis(long instant,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return iChronology.getDateTimeMillis\n+            (instant,\n+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        year = adjustYearForSet(year);\n+        return iChronology.getDateTimeMillis\n+            (year, monthOfYear, dayOfMonth,\n+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n     public long getGregorianJulianCutoverMillis() {\n         return iChronology.getGregorianJulianCutoverMillis();\n     }\n         return iChronology.getMinimumDaysInFirstWeek();\n     }\n \n-    private class NoYearZeroField extends DelegateDateTimeField {\n+    int adjustYearForSet(int year) {\n+        if (year <= 0) {\n+            if (year == 0) {\n+                throw new IllegalArgumentException(\"Invalid year: \" + year);\n+            }\n+            year++;\n+        }\n+        return year;\n+    }\n+\n+    private class NoYearZeroField extends DelegatedDateTimeField {\n+        static final long serialVersionUID = -8869148464118507846L;\n+\n         private transient int iMinYear;\n \n         NoYearZeroField(DateTimeField field) {\n         }\n \n         public long set(long millis, int year) {\n-            super.verifyValueBounds(year, iMinYear, getMaximumValue());\n-            if (year <= 0) {\n-                if (year == 0) {\n-                    throw new IllegalArgumentException(\"Invalid year: \" + year);\n-                }\n-                year++;\n-            }\n-            return super.set(millis, year);\n+            Utils.verifyValueBounds(this, year, iMinYear, getMaximumValue());\n+            return super.set(millis, adjustYearForSet(year));\n         }\n \n         public int getMinimumValue() {\n     }\n \n     private final class NoWeekyearZeroField extends NoYearZeroField {\n+        static final long serialVersionUID = -5013429014495501104L;\n+\n         NoWeekyearZeroField(DateTimeField field) {\n             super(field);\n         }\n--- a/JodaTime/src/java/org/joda/time/chrono/gj/JulianWithYearZeroChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/JulianWithYearZeroChronology.java\n  * @author Stephen Colebourne\n  */\n final class JulianWithYearZeroChronology extends ProlepticChronology {\n+\n+    static final long serialVersionUID = 9044685826106463217L;\n+\n     JulianWithYearZeroChronology(int minDaysInFirstWeek) {\n         super(minDaysInFirstWeek);\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/gj/ProlepticChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/ProlepticChronology.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n import org.joda.time.chrono.DividedDateTimeField;\n-import org.joda.time.chrono.FractionalDateTimeField;\n-//import org.joda.time.chrono.OneBasedFractionalDateTimeField;\n+import org.joda.time.chrono.MillisDurationField;\n import org.joda.time.chrono.NonZeroDateTimeField;\n import org.joda.time.chrono.RemainderDateTimeField;\n+import org.joda.time.chrono.PreciseDateTimeField;\n+import org.joda.time.chrono.PreciseDurationField;\n+import org.joda.time.chrono.Utils;\n \n /**\n  * ProlepticChronology uses a consistent set of rules for all dates and\n  * @since 1.0\n  */\n abstract class ProlepticChronology extends GJChronology {\n+\n+    static final long serialVersionUID = 541866437970475456L;\n+\n     static final long MILLIS_1970_TO_2000 = 946684800000L;\n \n     // These arrays are NOT public. We trust ourselves not to alter the array.\n \n     private static final long[] MIN_TOTAL_MILLIS_BY_MONTH_ARRAY;\n     private static final long[] MAX_TOTAL_MILLIS_BY_MONTH_ARRAY;\n+\n+    private static final DurationField cMillisField;\n+    private static final DurationField cSecondsField;\n+    private static final DurationField cMinutesField;\n+    private static final DurationField cHoursField;\n+    private static final DurationField cHalfdaysField;\n+    private static final DurationField cDaysField;\n+    private static final DurationField cWeeksField;\n \n     private static final DateTimeField cMillisOfSecondField;\n     private static final DateTimeField cMillisOfDayField;\n             MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[i] = maxSum;\n         }\n \n-        cMillisOfSecondField = new FractionalDateTimeField\n-            (\"millisOfSecond\",\n-             1,\n-             DateTimeConstants.MILLIS_PER_SECOND);\n-\n-        cMillisOfDayField = new FractionalDateTimeField\n-            (\"millisOfDay\",\n-             1,\n-             DateTimeConstants.MILLIS_PER_DAY);\n-\n-        cSecondOfMinuteField = new FractionalDateTimeField\n-            (\"secondOfMinute\", \n-             DateTimeConstants.MILLIS_PER_SECOND, \n-             DateTimeConstants.SECONDS_PER_MINUTE);\n-\n-        cSecondOfDayField = new FractionalDateTimeField\n-            (\"secondOfDay\",\n-             DateTimeConstants.MILLIS_PER_SECOND,\n-             DateTimeConstants.SECONDS_PER_DAY);\n-\n-        cMinuteOfHourField = new FractionalDateTimeField\n-            (\"minuteOfHour\",\n-             DateTimeConstants.MILLIS_PER_MINUTE,\n-             DateTimeConstants.MINUTES_PER_HOUR);\n-\n-        cMinuteOfDayField = new FractionalDateTimeField\n-            (\"minuteOfDay\",\n-             DateTimeConstants.MILLIS_PER_MINUTE,\n-             DateTimeConstants.MINUTES_PER_DAY);\n-\n-        cHourOfDayField = new FractionalDateTimeField\n-            (\"hourOfDay\",\n-             DateTimeConstants.MILLIS_PER_HOUR,\n-             DateTimeConstants.HOURS_PER_DAY);\n-\n-        cHourOfHalfdayField = new FractionalDateTimeField\n-            (\"hourOfHalfday\",\n-             DateTimeConstants.MILLIS_PER_HOUR,\n-             DateTimeConstants.HOURS_PER_DAY / 2);\n+        cMillisField = MillisDurationField.INSTANCE;\n+        cSecondsField = new PreciseDurationField\n+            (\"seconds\", DateTimeConstants.MILLIS_PER_SECOND);\n+        cMinutesField = new PreciseDurationField\n+            (\"minutes\", DateTimeConstants.MILLIS_PER_MINUTE);\n+        cHoursField = new PreciseDurationField\n+            (\"hours\", DateTimeConstants.MILLIS_PER_HOUR);\n+        cHalfdaysField = new PreciseDurationField\n+            (\"halfdays\", DateTimeConstants.MILLIS_PER_DAY / 2);\n+        cDaysField = new PreciseDurationField\n+            (\"days\", DateTimeConstants.MILLIS_PER_DAY);\n+        cWeeksField = new PreciseDurationField\n+            (\"weeks\", DateTimeConstants.MILLIS_PER_WEEK);\n+\n+        cMillisOfSecondField = new PreciseDateTimeField\n+            (\"millisOfSecond\", cMillisField, cSecondsField);\n+\n+        cMillisOfDayField = new PreciseDateTimeField\n+            (\"millisOfDay\", cMillisField, cDaysField);\n+             \n+        cSecondOfMinuteField = new PreciseDateTimeField\n+            (\"secondOfMinute\", cSecondsField, cMinutesField);\n+\n+        cSecondOfDayField = new PreciseDateTimeField\n+            (\"secondOfDay\", cSecondsField, cDaysField);\n+\n+        cMinuteOfHourField = new PreciseDateTimeField\n+            (\"minuteOfHour\", cMinutesField, cHoursField);\n+\n+        cMinuteOfDayField = new PreciseDateTimeField\n+            (\"minuteOfDay\", cMinutesField, cDaysField);\n+\n+        cHourOfDayField = new PreciseDateTimeField\n+            (\"hourOfDay\", cHoursField, cDaysField);\n+\n+        cHourOfHalfdayField = new PreciseDateTimeField\n+            (\"hourOfHalfday\", cHoursField, cHalfdaysField);\n \n         cClockhourOfDayField = new NonZeroDateTimeField\n-            (\"clockhourOfDay\", cHourOfDayField);\n+            (cHourOfDayField, \"clockhourOfDay\");\n \n         cClockhourOfHalfdayField = new NonZeroDateTimeField\n-            (\"clockhourOfHalfday\", cHourOfHalfdayField);\n+            (cHourOfHalfdayField, \"clockhourOfHalfday\");\n \n         cHalfdayOfDayField = new HalfdayField();\n     }\n         super();\n         iMinDaysInFirstWeek = minDaysInFirstWeek;\n \n-        Integer i = Integer.getInteger(\"org.joda.time.gj.ProlepticChronology.yearInfoCacheSize\");\n-        int cacheSize = (i == null) ? 1024 : i.intValue();\n-        // Ensure cache size is even power of 2.\n-        cacheSize--;\n-        int shift = 0;\n-        while (cacheSize > 0) {\n-            shift++;\n-            cacheSize >>= 1;\n-        }\n-        cacheSize = 1 << shift;\n+        Integer i;\n+        try {\n+            i = Integer.getInteger(\"org.joda.time.gj.ProlepticChronology.yearInfoCacheSize\");\n+        } catch (SecurityException e) {\n+            i = null;\n+        }\n+\n+        int cacheSize;\n+        if (i == null) {\n+            cacheSize = 1024; // (1 << 10)\n+        } else {\n+            cacheSize = i.intValue();\n+            // Ensure cache size is even power of 2.\n+            cacheSize--;\n+            int shift = 0;\n+            while (cacheSize > 0) {\n+                shift++;\n+                cacheSize >>= 1;\n+            }\n+            cacheSize = 1 << shift;\n+        }\n+\n         iYearInfoCache = new YearInfo[cacheSize];\n         iYearInfoCacheMask = cacheSize - 1;\n \n-        iYearField = new GJYearDateTimeField(this);\n-        iYearOfEraField = new GJYearOfEraDateTimeField(this);\n-\n-        iCenturyOfEraField = new DividedDateTimeField(\"centuryOfEra\", iYearOfEraField, 100);\n-        iYearOfCenturyField = new RemainderDateTimeField(\"yearOfCentury\", iYearOfEraField, 100);\n-\n-        iEraField = new GJEraDateTimeField(this);\n-        iDayOfWeekField = new GJDayOfWeekDateTimeField(this);\n-        iDayOfMonthField = new GJDayOfMonthDateTimeField(this);\n-        iDayOfYearField = new GJDayOfYearDateTimeField(this);\n-        iMonthOfYearField = new GJMonthOfYearDateTimeField(this);\n-        iWeekOfWeekyearField = new GJWeekOfWeekyearDateTimeField(this);\n-        iWeekyearField = new GJWeekyearDateTimeField(this);\n+        // First copy fields that are the same for all Gregorian and Julian\n+        // chronologies.\n+\n+        iMillisField = cMillisField;\n+        iSecondsField = cSecondsField;\n+        iMinutesField = cMinutesField;\n+        iHoursField = cHoursField;\n+        //iHalfdaysField = cHalfdaysField;  Doesn't exist in public interface\n+        iDaysField = cDaysField;\n+        iWeeksField = cWeeksField;\n \n         iMillisOfSecondField = cMillisOfSecondField;\n         iMillisOfDayField = cMillisOfDayField;\n         iClockhourOfDayField = cClockhourOfDayField;\n         iClockhourOfHalfdayField = cClockhourOfHalfdayField;\n         iHalfdayOfDayField = cHalfdayOfDayField;\n+\n+        // Now create fields that have unique behavior for Gregorian and Julian\n+        // chronologies.\n+\n+        iYearField = new GJYearDateTimeField(this);\n+        iYearOfEraField = new GJYearOfEraDateTimeField(iYearField, this);\n+\n+        iCenturyOfEraField = new DividedDateTimeField\n+            (iYearOfEraField, \"centuryOfEra\", \"centuries\", 100);\n+        iYearOfCenturyField = new RemainderDateTimeField\n+            ((DividedDateTimeField)iCenturyOfEraField, \"yearOfCentury\");\n+\n+        iEraField = new GJEraDateTimeField(this);\n+        iDayOfWeekField = new GJDayOfWeekDateTimeField(this, iDaysField);\n+        iDayOfMonthField = new GJDayOfMonthDateTimeField(this, iDaysField);\n+        iDayOfYearField = new GJDayOfYearDateTimeField(this, iDaysField);\n+        iMonthOfYearField = new GJMonthOfYearDateTimeField(this);\n+        iWeekyearField = new GJWeekyearDateTimeField(this);\n+        iWeekOfWeekyearField = new GJWeekOfWeekyearDateTimeField(this, iWeeksField);\n+\n+        // The remaining (imprecise) durations are available from the newly\n+        // created datetime fields.\n+\n+        iYearsField = iYearField.getDurationField();\n+        iCenturiesField = iCenturyOfEraField.getDurationField();\n+        iMonthsField = iMonthOfYearField.getDurationField();\n+        iWeekyearsField = iWeekyearField.getDurationField();\n     }\n \n     public Chronology withUTC() {\n         return this;\n+    }\n+\n+    /**\n+     * Override the default implementation\n+     */\n+    public final long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException\n+    {\n+        boolean isLeap = isLeapYear(year);\n+\n+        Utils.verifyValueBounds(\"monthOfYear\", monthOfYear, 1, 12);\n+        Utils.verifyValueBounds(\"dayOfMonth\", dayOfMonth, 1,\n+                                (isLeap ? MAX_DAYS_PER_MONTH_ARRAY : MIN_DAYS_PER_MONTH_ARRAY)\n+                                [monthOfYear - 1]);\n+\n+        long instant = getYearMillis(year);\n+\n+        if (monthOfYear > 1) {\n+            instant += \n+                (isLeap ? MAX_TOTAL_MILLIS_BY_MONTH_ARRAY : MIN_TOTAL_MILLIS_BY_MONTH_ARRAY)\n+                [monthOfYear - 2];\n+        }\n+\n+        if (dayOfMonth != 1) {\n+            instant += (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n+        }\n+\n+        return instant;\n+    }\n+\n+    /**\n+     * Override the default implementation\n+     */\n+    public final long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n+                                        int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+\n+        Utils.verifyValueBounds(\"hourOfDay\", hourOfDay, 0, 23);\n+        Utils.verifyValueBounds(\"minuteOfHour\", minuteOfHour, 0, 59);\n+        Utils.verifyValueBounds(\"secondOfMinute\", secondOfMinute, 0, 59);\n+        Utils.verifyValueBounds(\"millisOfSecond\", millisOfSecond, 0, 999);\n+\n+        return hourOfDay * DateTimeConstants.MILLIS_PER_HOUR\n+            + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE\n+            + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND\n+            + millisOfSecond;\n+    }\n+\n+    /**\n+     * Override the default implementation\n+     */\n+    public final long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                        int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        Utils.verifyValueBounds(\"millisOfDay\", millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY);\n+        return getDateOnlyMillis(year, monthOfYear, dayOfMonth) + millisOfDay;\n+    }\n+\n+    /**\n+     * Override the default implementation\n+     */\n+    public final long getDateTimeMillis(long instant,\n+                                        int hourOfDay, int minuteOfHour,\n+                                        int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return getDateOnlyMillis(instant)\n+            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    /**\n+     * Override the default implementation\n+     */\n+    public final long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                        int hourOfDay, int minuteOfHour,\n+                                        int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return getDateOnlyMillis(year, monthOfYear, dayOfMonth)\n+            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n     }\n \n     public final boolean isCenturyISO() {\n         return info;\n     }\n \n-    private static class HalfdayField extends FractionalDateTimeField {\n+    private static class HalfdayField extends PreciseDateTimeField {\n+        static final long serialVersionUID = 581601443656929254L;\n+\n         HalfdayField() {\n-            super(\"halfdayOfDay\", DateTimeConstants.MILLIS_PER_HOUR * 12, 2);\n+            super(\"halfdayOfDay\", cHalfdaysField, cDaysField);\n         }\n \n         public String getAsText(long millis, Locale locale) {\n--- a/JodaTime/src/java/org/joda/time/chrono/iso/ISOChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/iso/ISOChronology.java\n  */\n package org.joda.time.chrono.iso;\n \n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n import java.util.HashMap;\n import java.util.Map;\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.chrono.DelegateChronology;\n+import org.joda.time.chrono.DelegatedChronology;\n import org.joda.time.chrono.gj.GJChronology;\n \n /**\n  * for the ISO8601 defined chronological calendar system. When ISO \n  * does not define a field, but it can be determined (such as AM/PM)\n  * it is included.\n+ * <p>\n+ * ISOChronology is thread-safe and immutable.\n  *\n  * @author Stephen Colebourne\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public final class ISOChronology extends DelegateChronology {\n+public final class ISOChronology extends DelegatedChronology {\n     \n+    static final long serialVersionUID = -6212696554273812441L;\n+\n     /** Singleton instance of a UTC ISOChronology */\n     private static final ISOChronology INSTANCE_UTC =\n         new ISOChronology(GJChronology.getInstance(DateTimeZone.UTC, Long.MIN_VALUE, true));\n         \n+    private static final int FAST_CACHE_SIZE = 64;\n+\n+    /** Fast cache of zone to chronology */\n+    private static final ISOChronology[] cFastCache = new ISOChronology[FAST_CACHE_SIZE];\n+\n     /** Cache of zone to chronology */\n     private static final Map cCache = new HashMap();\n     static {\n      * @param zone  the time zone to get the chronology in, null is default\n      * @return a chronology in the specified time zone\n      */\n-    public static synchronized ISOChronology getInstance(DateTimeZone zone) {\n+    public static ISOChronology getInstance(DateTimeZone zone) {\n         if (zone == null) {\n             zone = DateTimeZone.getDefault();\n         }\n-        ISOChronology chrono = (ISOChronology) cCache.get(zone);\n-        if (chrono == null) {\n-            chrono = new ISOChronology(GJChronology.getInstance(zone, Long.MIN_VALUE, true));\n-            cCache.put(zone, chrono);\n-        }\n+        int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\n+        ISOChronology chrono = cFastCache[index];\n+        if (chrono != null && chrono.getDateTimeZone() == zone) {\n+            return chrono;\n+        }\n+        synchronized (cCache) {\n+            chrono = (ISOChronology) cCache.get(zone);\n+            if (chrono == null) {\n+                chrono = new ISOChronology\n+                    (GJChronology.getInstance(zone, Long.MIN_VALUE, true));\n+                cCache.put(zone, chrono);\n+            }\n+        }\n+        cFastCache[index] = chrono;\n         return chrono;\n     }\n \n     }\n \n     /**\n-     * Serialization singleton\n-     */\n-    private Object readResolve() {\n-        return getInstance(getChronology().getDateTimeZone());\n+     * Serialize ISOChronology instances using a small stub. This reduces the\n+     * serialized size, and deserialized instances come from the cache.\n+     */\n+    private Object writeReplace() {\n+        return new Stub(getDateTimeZone());\n     }\n \n     // Conversion\n      * @return a debugging string\n      */\n     public String toString() {\n+        String str = \"ISOChronology\";\n         DateTimeZone zone = getDateTimeZone();\n-        return \"ISOChronology[\" + (zone == null ? \"\" : zone.getID()) + \"]\";\n-    }\n-   \n+        if (zone != null) {\n+            str = str + '[' + zone.getID() + ']';\n+        }\n+        return str;\n+    }\n+\n+    private static final class Stub implements Serializable {\n+        static final long serialVersionUID = -6212696554273812441L;\n+\n+        private transient DateTimeZone iZone;\n+\n+        Stub(DateTimeZone zone) {\n+            iZone = zone;\n+        }\n+\n+        private Object readResolve() {\n+            return ISOChronology.getInstance(iZone);\n+        }\n+\n+        private void writeObject(ObjectOutputStream out) throws IOException {\n+            out.writeObject(iZone);\n+        }\n+\n+        private void readObject(ObjectInputStream in)\n+            throws IOException, ClassNotFoundException\n+        {\n+            iZone = (DateTimeZone)in.readObject();\n+        }\n+    }\n+\n }\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * AbstractConverter simplifies the process of implementing a converter.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class AbstractConverter implements Converter {\n+    \n+    /**\n+     * Restricted constructor.\n+     */\n+    protected AbstractConverter() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Extracts the millis from an object of this convertor's type.\n+     * <p>\n+     * This implementation calls {@link #getInstantMillis(Object, DateTimeZone)}.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @return the millisecond value\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    public long getInstantMillis(Object object) {\n+        return getInstantMillis(object, (DateTimeZone) null);\n+    }\n+    \n+    /**\n+     * Extracts the millis from an object of this convertor's type.\n+     * <p>\n+     * This implementation calls {@link #getInstantMillis(Object)}.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @param zone  the zone to use, null means default zone\n+     * @return the millisecond value\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    public long getInstantMillis(Object object, DateTimeZone zone) {\n+        return getInstantMillis(object);\n+    }\n+    \n+    /**\n+     * Extracts the millis from an object of this convertor's type.\n+     * <p>\n+     * This implementation calls {@link #getInstantMillis(Object)}.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @param chrono  the chronology to use, null means ISOChronology\n+     * @return the millisecond value\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    public long getInstantMillis(Object object, Chronology chrono) {\n+        return getInstantMillis(object);\n+    }\n+    //-----------------------------------------------------------------------\n+    \n+    /**\n+     * Extracts the chronology from an object of this convertor's type.\n+     * <p>\n+     * This implementation returns the ISOChronology.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @return the chronology, never null\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    public Chronology getChronology(Object object) {\n+        return ISOChronology.getInstance();\n+    }\n+    \n+    /**\n+     * Extracts the chronology from an object of this convertor's type\n+     * where the time zone is specified.\n+     * <p>\n+     * This implementation returns the ISOChronology.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @param zone  the specified zone to use, null means default zone\n+     * @return the chronology, never null\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    public Chronology getChronology(Object object, DateTimeZone zone) {\n+        return ISOChronology.getInstance(zone);\n+    }\n+    \n+    /**\n+     * Extracts the chronology from an object of this convertor's type\n+     * where the chronology is specified.\n+     * <p>\n+     * This implementation returns the chronology specified, or the\n+     * ISOChronology in the default zone if null passed in.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @param chrono  the chronology to use, null means ISOChronology\n+     * @return the chronology, never null\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    public Chronology getChronology(Object object, Chronology chrono) {\n+        if (chrono == null) {\n+            return ISOChronology.getInstance();\n+        }\n+        return chrono;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.convert;\n+\n+import java.util.Calendar;\n+import java.util.GregorianCalendar;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.chrono.buddhist.BuddhistChronology;\n+import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * CalendarConverter converts a java util Calendar to milliseconds in the\n+ * chronology that best matches the calendar.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+final class CalendarConverter extends AbstractConverter implements InstantConverter {\n+    \n+    /**\n+     * Singleton instance.\n+     */\n+    static final CalendarConverter INSTANCE = new CalendarConverter();\n+    \n+    /**\n+     * Restricted constructor.\n+     */\n+    protected CalendarConverter() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the millis, which is the Calendar millis value.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @return the millisecond value\n+     */\n+    public long getInstantMillis(Object object) {\n+        return ((Calendar) object).getTime().getTime();\n+    }\n+    \n+    /**\n+     * Gets the chronology, which is the GJChronology if a GregorianCalendar is used,\n+     * BuddhistChronology if a BuddhistCalendar is used or ISOChronology otherwise.\n+     * The time zone is extracted from the calendar if possible, default used if not.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @return the chronology, never null\n+     */\n+    public Chronology getChronology(Object object) {\n+        Calendar cal = (Calendar) object;\n+        DateTimeZone zone = null;\n+        try {\n+            zone = DateTimeZone.getInstance(cal.getTimeZone());\n+            \n+        } catch (IllegalArgumentException ex) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        return getChronology(cal, zone);\n+    }\n+    \n+    /**\n+     * Gets the chronology, which is the GJChronology if a GregorianCalendar is used,\n+     * BuddhistChronology if a BuddhistCalendar is used or ISOChronology otherwise.\n+     * The time zone specified is used in preference to that on the calendar.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @param zone  the specified zone to use, null means default zone\n+     * @return the chronology, never null\n+     */\n+    public Chronology getChronology(Object object, DateTimeZone zone) {\n+        if (object instanceof GregorianCalendar) {\n+            GregorianCalendar gc = (GregorianCalendar) object;\n+            return GJChronology.getInstance(zone, gc.getGregorianChange().getTime(), false);\n+            \n+        } else if (object.getClass().getName().endsWith(\".BuddhistCalendar\")) {\n+            return BuddhistChronology.getInstance(zone);\n+            \n+        } else {\n+            return ISOChronology.getInstance(zone);\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns Calendar.class.\n+     * \n+     * @return Calendar.class\n+     */\n+    public Class getSupportedType() {\n+        return Calendar.class;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/convert/Converter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.convert;\n+\n+/**\n+ * Basic converter interface for specifying what object type can be converted.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public interface Converter {\n+    /**\n+     * Returns the object type that this converter supports, which may\n+     * specified by a class, superclass, abstract class, interface, or null.\n+     * \n+     * @return the object type that this converter supports\n+     */\n+    Class getSupportedType();\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.convert;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * ConverterManager controls the date and time converters.\n+ * <p>\n+ * This class enables additional conversion classes to be added via\n+ * {@link #addInstantConverter(InstantConverter)}, which may replace an\n+ * existing converter. Similar methods exist for duration converters.\n+ * <p>\n+ * This class is threadsafe, so adding/removing converters can be done at any\n+ * time. Updating the set of convertors is relatively expensive, and so should\n+ * not be performed often.\n+ * <p>\n+ * The default instant converters are:\n+ * <ul>\n+ * <li>ReadableInstant\n+ * <li>PartialInstant\n+ * <li>String\n+ * <li>Calendar\n+ * <li>Date\n+ * <li>Long\n+ * </ul>\n+ * The default duration converters are:\n+ * <ul>\n+ * <li>ReadableDuration\n+ * <li>Long\n+ * </ul>\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class ConverterManager {\n+\n+    /**\n+     * Singleton instance, lazily loaded to avoid class loading.\n+     */\n+    private static ConverterManager INSTANCE;\n+\n+    public static ConverterManager getInstance() {\n+        if (INSTANCE == null) {\n+            INSTANCE = new ConverterManager();\n+        }\n+        return INSTANCE;\n+    }\n+    \n+    private ConverterSet iInstantConverters;\n+    private ConverterSet iDurationConverters;\n+    \n+    /**\n+     * Restricted constructor.\n+     */\n+    protected ConverterManager() {\n+        super();\n+\n+        iInstantConverters = new ConverterSet(new Converter[] {\n+            ReadableInstantConverter.INSTANCE,\n+            PartialInstantConverter.INSTANCE,\n+            StringConverter.INSTANCE,\n+            CalendarConverter.INSTANCE,\n+            DateConverter.INSTANCE,\n+            LongConverter.INSTANCE,\n+        });\n+\n+        iDurationConverters = new ConverterSet(new Converter[] {\n+            ReadableDurationConverter.INSTANCE,\n+            LongConverter.INSTANCE,\n+        });\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the best converter for the object specified.\n+     * \n+     * @param object  the object to convert\n+     * @return the converter to use\n+     * @throws IllegalArgumentException if no suitable converter\n+     * @throws IllegalStateException if multiple converters match the type\n+     * equally well\n+     */\n+    public InstantConverter getInstantConverter(Object object) {\n+        InstantConverter converter =\n+            (InstantConverter)iInstantConverters.select(object == null ? null : object.getClass());\n+        if (converter != null) {\n+            return converter;\n+        }\n+        throw new IllegalArgumentException(\"No instant converter found for type: \" +\n+            (object == null ? \"null\" : object.getClass().getName()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of the set of converters.\n+     * \n+     * @return the converters, a copy of the real data, never null\n+     */\n+    public InstantConverter[] getInstantConverters() {\n+        ConverterSet set = iInstantConverters;\n+        InstantConverter[] converters = new InstantConverter[set.size()];\n+        set.copyInto(converters);\n+        return converters;\n+    }\n+    \n+    /**\n+     * Adds a converter to the set of converters. If a matching converter is\n+     * already in the set, the given converter replaces it. If the converter is\n+     * exactly the same as one already in the set, no changes are made.\n+     * <p>\n+     * The order in which converters are added is not relevent. The best\n+     * converter is selected by examining the object hierarchy.\n+     * \n+     * @param converter  the converter to add, null ignored\n+     * @return replaced converter, or null\n+     */\n+    public InstantConverter addInstantConverter(InstantConverter converter) {\n+        if (converter == null) {\n+            return null;\n+        }\n+        InstantConverter[] removed = new InstantConverter[1];\n+        iInstantConverters = iInstantConverters.add(converter, removed);\n+        return removed[0];\n+    }\n+    \n+    /**\n+     * Removes a converter from the set of converters. If the converter was\n+     * not in the set, no changes are made.\n+     * \n+     * @param converter  the converter to remove, null ignored\n+     * @return replaced converter, or null\n+     */\n+    public InstantConverter removeInstantConverter(InstantConverter converter) {\n+        if (converter == null) {\n+            return null;\n+        }\n+        InstantConverter[] removed = new InstantConverter[1];\n+        iInstantConverters = iInstantConverters.remove(converter, removed);\n+        return removed[0];\n+    }\n+    \n+    /**\n+     * Removes a converter from the set of converters, by index.\n+     * \n+     * @param index  the index to remove\n+     * @return replaced converter, or null\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public InstantConverter removeInstantConverter(int index) {\n+        InstantConverter[] removed = new InstantConverter[1];\n+        iInstantConverters = iInstantConverters.remove(index, removed);\n+        return removed[0];\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the best converter for the object specified.\n+     * \n+     * @param object  the object to convert\n+     * @return the converter to use\n+     * @throws IllegalArgumentException if no suitable converter\n+     * @throws IllegalStateException if multiple converters match the type\n+     * equally well\n+     */\n+    public DurationConverter getDurationConverter(Object object) {\n+        DurationConverter converter =\n+            (DurationConverter)iDurationConverters.select(object == null ? null : object.getClass());\n+        if (converter != null) {\n+            return converter;\n+        }\n+        throw new IllegalArgumentException(\"No duration converter found for type: \" +\n+            (object == null ? \"null\" : object.getClass().getName()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of the list of converters.\n+     * \n+     * @return the converters, a copy of the real data, never null\n+     */\n+    public DurationConverter[] getDurationConverters() {\n+        ConverterSet set = iDurationConverters;\n+        DurationConverter[] converters = new DurationConverter[set.size()];\n+        set.copyInto(converters);\n+        return converters;\n+    }\n+    \n+    /**\n+     * Adds a converter to the set of converters. If a matching converter is\n+     * already in the set, the given converter replaces it. If the converter is\n+     * exactly the same as one already in the set, no changes are made.\n+     * <p>\n+     * The order in which converters are added is not relevent. The best\n+     * converter is selected by examining the object hierarchy.\n+     * \n+     * @param converter  the converter to add, null ignored\n+     * @return replaced converter, or null\n+     */\n+    public DurationConverter addDurationConverter(DurationConverter converter) {\n+        if (converter == null) {\n+            return null;\n+        }\n+        DurationConverter[] removed = new DurationConverter[1];\n+        iDurationConverters = iDurationConverters.add(converter, removed);\n+        return removed[0];\n+    }\n+    \n+    /**\n+     * Removes a converter from the set of converters. If the converter was\n+     * not in the set, no changes are made.\n+     * \n+     * @param converter  the converter to remove, null ignored\n+     * @return replaced converter, or null\n+     */\n+    public DurationConverter removeDurationConverter(DurationConverter converter) {\n+        if (converter == null) {\n+            return null;\n+        }\n+        DurationConverter[] removed = new DurationConverter[1];\n+        iDurationConverters = iDurationConverters.remove(converter, removed);\n+        return removed[0];\n+    }\n+    \n+    /**\n+     * Removes a converter from the set of converters, by index.\n+     * \n+     * @param index  the index to remove\n+     * @return replaced converter, or null\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DurationConverter removeDurationConverter(int index) {\n+        DurationConverter[] removed = new DurationConverter[1];\n+        iDurationConverters = iDurationConverters.remove(index, removed);\n+        return removed[0];\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debug representation of the object\n+     */\n+    public String toString() {\n+        return \"ConverterManager[\" +\n+            iInstantConverters.size() + \" instant converters,\" +\n+            iDurationConverters.size() + \" duration converters]\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/convert/ConverterSet.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.convert;\n+\n+/**\n+ * A set of converters, which allows exact converters to be quickly\n+ * selected. This class is threadsafe because it is (essentially) immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+class ConverterSet {\n+    private final Converter[] iConverters;\n+\n+    // A simple immutable hashtable: closed hashing, linear probing, sized\n+    // power of 2, at least one null slot.\n+    private Entry[] iSelectEntries;\n+\n+    ConverterSet(Converter[] converters) {\n+        // Since this is a package private constructor, we trust ourselves not\n+        // to alter the array outside this class.\n+        iConverters = converters;\n+        iSelectEntries = new Entry[1 << 4]; // 16\n+    }\n+\n+    /**\n+     * Returns the closest matching converter for the given type, or null if\n+     * none found.\n+     *\n+     * @param type type to select, which may be null\n+     * @throws IllegalStateException if multiple converters match the type\n+     * equally well\n+     */\n+    public Converter select(Class type) throws IllegalStateException {\n+        // Check the hashtable first.\n+        Entry[] entries = iSelectEntries;\n+        int length = entries.length;\n+        int index = type == null ? 0 : type.hashCode() & (length - 1);\n+\n+        Entry e;\n+        // This loop depends on there being at least one null slot.\n+        while ((e = entries[index]) != null) {\n+            if (e.iType == type) {\n+                return e.iConverter;\n+            }\n+            if (++index >= length) {\n+                index = 0;\n+            }\n+        }\n+\n+        // Not found in the hashtable, so do actual work.\n+\n+        Converter converter = selectSlow(this, type);\n+        e = new Entry(type, converter);\n+\n+        // Save the entry for future selects. This class must be threadsafe,\n+        // but there is no synchronization. Since the hashtable is being used\n+        // as a cache, it is okay to destroy existing entries. This isn't\n+        // likely to occur unless there is a high amount of concurrency. As\n+        // time goes on, cache updates will occur less often, and the cache\n+        // will fill with all the necessary entries.\n+\n+        // Do all updates on a copy: slots in iSelectEntries must not be\n+        // updated by multiple threads as this can allow all null slots to be\n+        // consumed.\n+        entries = (Entry[])entries.clone();\n+\n+        // Add new entry.\n+        entries[index] = e;\n+\n+        // Verify that at least one null slot exists!\n+        for (int i=0; i<length; i++) {\n+            if (entries[i] == null) {\n+                // Found a null slot, swap in new hashtable.\n+                iSelectEntries = entries;\n+                return converter;\n+            }\n+        }\n+\n+        // Double capacity and re-hash.\n+\n+        int newLength = length << 1;\n+        Entry[] newEntries = new Entry[newLength];\n+        for (int i=0; i<length; i++) {\n+            e = entries[i];\n+            type = e.iType;\n+            index = type == null ? 0 : type.hashCode() & (newLength - 1);\n+            while (newEntries[index] != null) {\n+                if (++index >= newLength) {\n+                    index = 0;\n+                }\n+            }\n+            newEntries[index] = e;\n+        }\n+\n+        // Swap in new hashtable.\n+        iSelectEntries = newEntries;\n+        return converter;\n+    }\n+\n+    /**\n+     * Returns the amount of converters in the set.\n+     */\n+    public int size() {\n+        return iConverters.length;\n+    }\n+\n+    /**\n+     * Copies all the converters in the set to the given array.\n+     */\n+    public void copyInto(Converter[] converters) {\n+        System.arraycopy(iConverters, 0, converters, 0, iConverters.length);\n+    }\n+\n+    /**\n+     * Returns a copy of this set, with the given converter added. If a\n+     * matching converter is already in the set, the given converter replaces\n+     * it. If the converter is exactly the same as one already in the set, the\n+     * original set is returned.\n+     *\n+     * @param converter converter to add\n+     * @param removed if not null, element 0 is set to the removed converter\n+     * @throws IllegalArgumentException if converter is null\n+     */\n+    public ConverterSet add(Converter converter, Converter[] removed) {\n+        if (converter == null) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        Converter[] converters = iConverters;\n+        int length = converters.length;\n+\n+        for (int i=0; i<length; i++) {\n+            Converter existing = converters[i];\n+            if (converter.equals(existing)) {\n+                // Already in the set.\n+                if (removed != null) {\n+                    removed[0] = null;\n+                }\n+                return this;\n+            }\n+            \n+            if (converter.getSupportedType() == existing.getSupportedType()) {\n+                // Replace the converter.\n+                Converter[] copy = new Converter[length];\n+                    \n+                for (int j=0; j<length; j++) {\n+                    if (j != i) {\n+                        copy[j] = converters[j];\n+                    } else {\n+                        copy[j] = converter;\n+                    }\n+                }\n+\n+                if (removed != null) {\n+                    removed[0] = existing;\n+                }\n+                return new ConverterSet(copy);\n+            }\n+        }\n+\n+        // Not found, so add it.\n+        Converter[] copy = new Converter[length + 1];\n+        System.arraycopy(converters, 0, copy, 0, length);\n+        copy[length] = converter;\n+        \n+        if (removed != null) {\n+            removed[0] = null;\n+        }\n+        return new ConverterSet(copy);\n+    }\n+\n+    /**\n+     * Returns a copy of this set, with the given converter removed. If the\n+     * converter was not in the set, the original set is returned.\n+     *\n+     * @param converter converter to remove\n+     * @param removed if not null, element 0 is set to the removed converter\n+     * @throws NullPointerException if converter is null\n+     */\n+    public ConverterSet remove(Converter converter, Converter[] removed) {\n+        Converter[] converters = iConverters;\n+        int length = converters.length;\n+\n+        for (int i=0; i<length; i++) {\n+            if (converter.equals(converters[i])) {\n+                return remove(i, removed);\n+            }\n+        }\n+\n+        // Not found.\n+        if (removed != null) {\n+            removed[0] = null;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Returns a copy of this set, with the converter at the given index\n+     * removed.\n+     *\n+     * @param converter converter to remove\n+     * @param removed if not null, element 0 is set to the removed converter\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public ConverterSet remove(final int index, Converter[] removed) {\n+        Converter[] converters = iConverters;\n+        int length = converters.length;\n+        if (index >= length) {\n+            throw new IndexOutOfBoundsException();\n+        }\n+\n+        if (removed != null) {\n+            removed[0] = converters[index];\n+        }\n+\n+        Converter[] copy = new Converter[length - 1];\n+                \n+        int j = 0;\n+        for (int i=0; i<length; i++) {\n+            if (i != index) {\n+                copy[j++] = converters[i];\n+            }\n+        }\n+        \n+        return new ConverterSet(copy);\n+    }\n+\n+    /**\n+     * Returns the closest matching converter for the given type, but not very\n+     * efficiently.\n+     */\n+    private static Converter selectSlow(ConverterSet set, Class type) {\n+        Converter[] converters = set.iConverters;\n+        int length = converters.length;\n+        Converter converter;\n+\n+        for (int i=length; --i>=0; ) {\n+            converter = converters[i];\n+            Class supportedType = converter.getSupportedType();\n+\n+            if (supportedType == type) {\n+                // Exact match.\n+                return converter;\n+            }\n+\n+            if (supportedType == null || (type != null && !supportedType.isAssignableFrom(type))) {\n+                // Eliminate the impossible.\n+                set = set.remove(i, null);\n+                converters = set.iConverters;\n+                length = converters.length;\n+            }\n+        }\n+\n+        // Haven't found exact match, so check what remains in the set.\n+\n+        if (type == null || length == 0) {\n+            return null;\n+        }\n+        if (length == 1) {\n+            // Found the one best match.\n+            return converters[0];\n+        }\n+\n+        // At this point, there exist multiple potential converters.\n+\n+        // Eliminate supertypes.\n+        for (int i=length; --i>=0; ) {\n+            converter = converters[i];\n+            Class supportedType = converter.getSupportedType();\n+            for (int j=length; --j>=0; ) {\n+                if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) {\n+                    // Eliminate supertype.\n+                    set = set.remove(j, null);\n+                    converters = set.iConverters;\n+                    length = converters.length;\n+                    i = length - 1;\n+                }\n+            }\n+        }        \n+        \n+        // Check what remains in the set.\n+\n+        if (length == 1) {\n+            // Found the one best match.\n+            return converters[0];\n+        }\n+\n+        // Class c implements a, b {}\n+        // Converters exist only for a and b. Which is better? Neither.\n+\n+        StringBuffer msg = new StringBuffer();\n+        msg.append(\"Unable to find best converter for type \\\"\");\n+        msg.append(type.getName());\n+        msg.append(\"\\\" from remaining set: \");\n+        for (int i=0; i<length; i++) {\n+            converter = converters[i];\n+            Class supportedType = converter.getSupportedType();\n+\n+            msg.append(converter.getClass().getName());\n+            msg.append('[');\n+            msg.append(supportedType == null ? null : supportedType.getName());\n+            msg.append(\"], \");\n+        }\n+\n+        throw new IllegalStateException(msg.toString());\n+    }\n+\n+    private static class Entry {\n+        public final Class iType;\n+        public final Converter iConverter;\n+\n+        Entry(Class type, Converter converter) {\n+            iType = type;\n+            iConverter = converter;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/convert/DateConverter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.convert;\n+\n+import java.util.Date;\n+\n+/**\n+ * DateConverter converts a java util Date to milliseconds in the ISOChronology.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+final class DateConverter extends AbstractConverter implements InstantConverter {\n+    \n+    /**\n+     * Singleton instance.\n+     */\n+    static final DateConverter INSTANCE = new DateConverter();\n+    \n+    /**\n+     * Restricted constructor.\n+     */\n+    protected DateConverter() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the millis, which is the Date millis value.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @return the millisecond value\n+     */\n+    public long getInstantMillis(Object object) {\n+        return ((Date) object).getTime();\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns Date.class.\n+     * \n+     * @return Date.class\n+     */\n+    public Class getSupportedType() {\n+        return Date.class;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/convert/DurationConverter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.convert;\n+\n+/**\n+ * DurationConverter defines how an object is converted to a millisecond duration.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface DurationConverter extends Converter {\n+\n+    /**\n+     * Extracts the millis from an object of this convertor's type.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @return the millisecond duration\n+     * @throws IllegalArgumentException if the object is invalid\n+     */\n+    long getDurationMillis(Object object);\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/convert/InstantConverter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * InstantConverter defines how an object is converted to milliseconds/chronology.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface InstantConverter extends Converter {\n+\n+    /**\n+     * Extracts the millis from an object of this convertor's type.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @return the millisecond instant\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    long getInstantMillis(Object object);\n+    \n+    /**\n+     * Extracts the millis from an object of this convertor's type. The zone\n+     * parameter is a hint to the converter, should it require a time zone to\n+     * aid in conversion.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @param zone  the zone to use, null means default zone\n+     * @return the millisecond instant\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    long getInstantMillis(Object object, DateTimeZone zone);\n+    \n+    /**\n+     * Extracts the millis from an object of this convertor's type. The chrono\n+     * parameter is a hint to the converter, should it require a chronology to\n+     * aid in conversion.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @param chrono  the chronology to use, null means ISOChronology\n+     * @return the millisecond instant\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    long getInstantMillis(Object object, Chronology chrono);\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Extracts the chronology from an object of this convertor's type.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @return the chronology, never null\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    Chronology getChronology(Object object);\n+    \n+    /**\n+     * Extracts the chronology from an object of this convertor's type\n+     * where the time zone is specified.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @param zone  the specified zone to use, null means default zone\n+     * @return the chronology, never null\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    Chronology getChronology(Object object, DateTimeZone zone);\n+    \n+    /**\n+     * Extracts the chronology from an object of this convertor's type\n+     * where the chronology is specified.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @param chrono  the chronology to use, null means ISOChronology\n+     * @return the chronology, never null\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    Chronology getChronology(Object object, Chronology chrono);\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/convert/LongConverter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.convert;\n+\n+\n+/**\n+ * LongConverter converts a Long to milliseconds in the ISOChronology.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+class LongConverter extends AbstractConverter implements InstantConverter, DurationConverter {\n+    \n+    /**\n+     * Singleton instance.\n+     */\n+    static final LongConverter INSTANCE = new LongConverter();\n+    \n+    /**\n+     * Restricted constructor.\n+     */\n+    protected LongConverter() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the millisecond instant, which is the Long value.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @return the millisecond instant\n+     */\n+    public long getInstantMillis(Object object) {\n+        return ((Long) object).longValue();\n+    }\n+    \n+    /**\n+     * Gets the millisecond duration, which is the Long value.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @return the millisecond duration\n+     */\n+    public long getDurationMillis(Object object) {\n+        return ((Long) object).longValue();\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns Long.class.\n+     * \n+     * @return Long.class\n+     */\n+    public Class getSupportedType() {\n+        return Long.class;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.PartialInstant;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * PartialInstantConverter extracts milliseconds and chronology from a\n+ * PartialInstant. Since supplying a time zone requires special attention, the\n+ * regular ReadableInstantConverter is not quite right.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+class PartialInstantConverter extends ReadableInstantConverter {\n+    /**\n+     * Singleton instance.\n+     */\n+    static final PartialInstantConverter INSTANCE = new PartialInstantConverter();\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    protected PartialInstantConverter() {\n+        super();\n+    }\n+\n+    /**\n+     * Extracts the millis from an object of this convertor's type.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @return the millisecond instant\n+     */\n+    public long getInstantMillis(Object object) {\n+        return getInstantMillis(object, (DateTimeZone) null);\n+    }\n+    \n+    /**\n+     * Extracts the millis from an object of this convertor's type.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @param zone  the zone to use, null means default zone\n+     * @return the millisecond instant\n+     */\n+    public long getInstantMillis(Object object, DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        long millis = ((PartialInstant) object).getMillis();\n+        return millis - zone.getOffsetFromLocal(millis);\n+    }\n+    \n+    /**\n+     * Extracts the millis from an object of this convertor's type.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @param chrono  the chronology to use, null means ISOChronology\n+     * @return the millisecond instant\n+     */\n+    public long getInstantMillis(Object object, Chronology chrono) {\n+        long millis = ((PartialInstant) object).getMillis();\n+        DateTimeZone zone;\n+        if (chrono == null) {\n+            zone = DateTimeZone.getDefault();\n+        } else {\n+            zone = chrono.getDateTimeZone();\n+        }\n+        if (zone != null) {\n+            millis -= zone.getOffsetFromLocal(millis);\n+        }\n+        return millis;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the chronology, which is taken from the PartialDateTime.  If the\n+     * chronology on the datetime is null, the ISOChronology in the default\n+     * time zone is used. Otherwise, the chronology is returned in the default\n+     * time zone.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @return the chronology, never null\n+     */\n+    public Chronology getChronology(Object object) {\n+        Chronology chrono = ((PartialInstant) object).getChronology();\n+        if (chrono == null) {\n+            return ISOChronology.getInstance();\n+        }\n+        return chrono.withDateTimeZone(DateTimeZone.getDefault());\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns PartialDateTime.class.\n+     * \n+     * @return PartialDateTime.class\n+     */\n+    public Class getSupportedType() {\n+        return PartialInstant.class;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.ReadableDuration;\n+\n+/**\n+ * ReadableDurationConverter extracts milliseconds and chronology from a ReadableDuration.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+class ReadableDurationConverter extends AbstractConverter implements DurationConverter {\n+    \n+    /**\n+     * Singleton instance.\n+     */\n+    static final ReadableDurationConverter INSTANCE = new ReadableDurationConverter();\n+    \n+    /**\n+     * Restricted constructor.\n+     */\n+    protected ReadableDurationConverter() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Extracts the millis from an object of this convertor's type.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @return the millisecond value\n+     */\n+    public long getDurationMillis(Object object) {\n+        return ((ReadableDuration) object).getTotalMillis();\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns ReadableDuration.class.\n+     * \n+     * @return ReadableDuration.class\n+     */\n+    public Class getSupportedType() {\n+        return ReadableDuration.class;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * ReadableInstantConverter extracts milliseconds and chronology from a ReadableInstant.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+class ReadableInstantConverter extends AbstractConverter implements InstantConverter {\n+    \n+    /**\n+     * Singleton instance.\n+     */\n+    static final ReadableInstantConverter INSTANCE = new ReadableInstantConverter();\n+    \n+    /**\n+     * Restricted constructor.\n+     */\n+    protected ReadableInstantConverter() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Extracts the millis from an object of this convertor's type.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @return the millisecond value\n+     */\n+    public long getInstantMillis(Object object) {\n+        return ((ReadableInstant) object).getMillis();\n+    }\n+    \n+    /**\n+     * Gets the chronology, which is taken from the ReadableInstant.\n+     * If the chronology on the instant is null, the ISOChronology in the\n+     * default time zone is used.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @return the chronology, never null\n+     */\n+    public Chronology getChronology(Object object) {\n+        Chronology chrono = ((ReadableInstant) object).getChronology();\n+        if (chrono == null) {\n+            return ISOChronology.getInstance();\n+        }\n+        return chrono;\n+    }\n+    \n+    /**\n+     * Gets the chronology, which is taken from the ReadableInstant.\n+     * If the chronology on the instant is null, the ISOChronology in the\n+     * specified time zone is used.\n+     * If the chronology on the instant is not in the specified zone, it is\n+     * adapted.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @param zone  the specified zone to use, null means default zone\n+     * @return the chronology, never null\n+     */\n+    public Chronology getChronology(Object object, DateTimeZone zone) {\n+        Chronology chrono = ((ReadableInstant) object).getChronology();\n+        if (chrono == null) {\n+            return ISOChronology.getInstance(zone);\n+        }\n+        DateTimeZone chronoZone = chrono.getDateTimeZone();\n+        if (chronoZone != zone) {\n+            chrono = chrono.withDateTimeZone(zone);\n+            if (chrono == null) {\n+                return ISOChronology.getInstance(zone);\n+            }\n+        }\n+        return chrono;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns ReadableInstant.class.\n+     * \n+     * @return ReadableInstant.class\n+     */\n+    public Class getSupportedType() {\n+        return ReadableInstant.class;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.format.DateTimeParser;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * StringConverter converts a String to milliseconds in the ISOChronology.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+class StringConverter extends AbstractConverter implements InstantConverter {\n+    \n+    /**\n+     * Singleton instance.\n+     */\n+    static final StringConverter INSTANCE = new StringConverter();\n+    \n+    /**\n+     * Restricted constructor.\n+     */\n+    protected StringConverter() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the millis, which is the ISO parsed string value.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @param zone  the zone to use, null means default zone\n+     * @return the millisecond value\n+     * @throws IllegalArgumentException if the value if invalid\n+     */\n+    public long getInstantMillis(Object object, DateTimeZone zone) {\n+        String str = (String) object;\n+        Chronology chrono = ISOChronology.getInstance(zone);\n+        DateTimeParser p = ISODateTimeFormat.getInstance(chrono).dateTimeParser();\n+        return p.parseMillis(str);\n+    }\n+    \n+    /**\n+     * Gets the millis, which is the ISO parsed string value.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @param chrono  the chronology to use, null means ISOChronology\n+     * @return the millisecond value\n+     * @throws IllegalArgumentException if the value if invalid\n+     */\n+    public long getInstantMillis(Object object, Chronology chrono) {\n+        String str = (String) object;\n+        chrono = getChronology(object, chrono);\n+        DateTimeParser p = ISODateTimeFormat.getInstance(chrono).dateTimeParser();\n+        return p.parseMillis(str);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns String.class.\n+     * \n+     * @return String.class\n+     */\n+    public Class getSupportedType() {\n+        return String.class;\n+    }\n+    \n+}\n--- a/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java\n+++ b/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java\n \n import java.io.IOException;\n import java.io.Writer;\n-import java.lang.reflect.Method;\n-import java.text.ParseException;\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n  * Likewise, the parse methods assume that your subclass has implemented\n  * DateTimeParser or DateTimeFormatter. If not, a ClassCastException is thrown\n  * when calling the parse methods.\n+ * <p>\n+ * AbstractDateTimeFormatter is thread-safe and immutable.\n  *\n  * @author Brian S O'Neill\n+ * @since 1.0\n  */\n public abstract class AbstractDateTimeFormatter {\n \n-    private static Method cInitCauseMethod;\n-\n-    static {\n-        // cope with JDK 1.4 enhancements\n-        Method initCauseMethod = null;\n-        try {\n-            initCauseMethod = Throwable.class.getMethod\n-                (\"initCause\", new Class[] {Throwable.class});\n-            \n-        } catch (NoSuchMethodException ex) {\n-            // ignore\n-        } catch (SecurityException ex) {\n-            // ignore\n-        }\n-        cInitCauseMethod = initCauseMethod;\n-    }\n-\n     // Accessed also by AbstractDurationFormatter.\n-    static String createErrorMessage(String text, int errorPos) {\n+    static String createErrorMessage(final String text, final int errorPos) {\n         int sampleLen = errorPos + 20;\n         String sampleText;\n         if (text.length() <= sampleLen) {\n             sampleText.substring(errorPos) + '\"';\n     }\n \n-    private static void setCause(ParseException pe, Throwable initCause) {\n-        if (cInitCauseMethod != null) {\n-            try {\n-                cInitCauseMethod.invoke(pe, new Object[]{initCause});\n-            } catch (Exception e) {\n-                cInitCauseMethod = null;\n-            }\n-        }\n-    }\n-\n     /**\n      * Returns the Chronology being used by the formatter, or null if none.\n      */\n     public abstract Chronology getChronology();\n \n-    public void printTo(StringBuffer buf, ReadableInstant instant) {\n+    /**\n+     * Returns the DateTimeZone from the formatter's Chronology, defaulting to\n+     * UTC if the Chronology or its DateTimeZone is null.\n+     */\n+    public DateTimeZone getDateTimeZone() {\n+        Chronology chrono = getChronology();\n+        if (chrono == null) {\n+            return DateTimeZone.UTC;\n+        }\n+        DateTimeZone zone = chrono.getDateTimeZone();\n+        return zone == null ? DateTimeZone.UTC : zone;\n+    }\n+\n+    public void printTo(final StringBuffer buf, final ReadableInstant instant) {\n         long millisUTC = instant.getMillis();\n         Chronology chrono;\n         if ((chrono = instant.getChronology()) != null) {\n             printTo(buf, millisUTC, chrono.getDateTimeZone());\n         } else {\n-            ((DateTimePrinter)this).printTo(buf, millisUTC, null, millisUTC);\n-        }\n-    }\n-\n-    public void printTo(Writer out, ReadableInstant instant) throws IOException {\n+            ((DateTimePrinter)this).printTo(buf, millisUTC, null);\n+        }\n+    }\n+\n+    public void printTo(final Writer out, final ReadableInstant instant) throws IOException {\n         long millisUTC = instant.getMillis();\n         Chronology chrono;\n         if ((chrono = instant.getChronology()) != null) {\n             printTo(out, millisUTC, chrono.getDateTimeZone());\n         } else {\n-            ((DateTimePrinter)this).printTo(out, millisUTC, null, millisUTC);\n-        }\n-    }\n-\n-    public void printTo(StringBuffer buf, long millisUTC) {\n-        printTo(buf, millisUTC, null);\n-    }\n-\n-    public void printTo(Writer out, long millisUTC) throws IOException {\n-        printTo(out, millisUTC, null);\n-    }\n-\n-    public void printTo(StringBuffer buf, long millisUTC, DateTimeZone zone) {\n-        if (zone != null) {\n-            ((DateTimePrinter)this).printTo\n-                (buf, millisUTC, zone, millisUTC + zone.getOffset(millisUTC));\n-        } else {\n-            ((DateTimePrinter)this).printTo(buf, millisUTC, null, millisUTC);\n-        }\n-    }\n-\n-    public void printTo(Writer out, long millisUTC, DateTimeZone zone) throws IOException {\n-        if (zone != null) {\n-            ((DateTimePrinter)this).printTo\n-                (out, millisUTC, zone, millisUTC + zone.getOffset(millisUTC));\n-        } else {\n-            ((DateTimePrinter)this).printTo(out, millisUTC, null, millisUTC);\n-        }\n-    }\n-\n-    public String print(ReadableInstant instant) {\n+            ((DateTimePrinter)this).printTo(out, millisUTC, null);\n+        }\n+    }\n+\n+    public void printTo(final StringBuffer buf, final long instant) {\n+        printTo(buf, instant, null);\n+    }\n+\n+    public void printTo(final Writer out, final long instant) throws IOException {\n+        printTo(out, instant, null);\n+    }\n+\n+    public void printTo(final StringBuffer buf, final long instant, DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = getDateTimeZone();\n+        }\n+        ((DateTimePrinter) this).printTo\n+            (buf, instant, zone, instant + zone.getOffset(instant));\n+    }\n+\n+    public void printTo(final Writer out, final long instant, DateTimeZone zone) throws IOException {\n+        if (zone == null) {\n+            zone = getDateTimeZone();\n+        }\n+        ((DateTimePrinter) this).printTo\n+            (out, instant, zone, instant + zone.getOffset(instant));\n+    }\n+\n+    public String print(final ReadableInstant instant) {\n         long millisUTC = instant.getMillis();\n         Chronology chrono;\n         if ((chrono = instant.getChronology()) != null) {\n             return print(millisUTC, chrono.getDateTimeZone());\n         } else {\n-            return print(millisUTC, null, millisUTC);\n-        }\n-    }\n-\n-    public String print(long millisUTC) {\n-        return print(millisUTC, null);\n-    }\n-\n-    public String print(long millisUTC, DateTimeZone zone) {\n-        if (zone != null) {\n-            return print\n-                (millisUTC, zone, millisUTC + zone.getOffset(millisUTC));\n-        } else {\n-            return print(millisUTC, null, millisUTC);\n-        }\n-    }\n-\n-    public String print(long millisUTC, DateTimeZone zone, long millisLocal) {\n+            return print(millisUTC, null);\n+        }\n+    }\n+\n+    public String print(final long instant) {\n+        return print(instant, null);\n+    }\n+\n+    public String print(final long instant, DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = getDateTimeZone();\n+        }\n+        return print(instant, zone, instant + zone.getOffset(instant));\n+    }\n+\n+    public String print(final long instant, final DateTimeZone zone, final long instantLocal) {\n         DateTimePrinter p = (DateTimePrinter)this;\n         StringBuffer buf = new StringBuffer(p.estimatePrintedLength());\n-        p.printTo(buf, millisUTC, zone, millisLocal);\n+        p.printTo(buf, instant, zone, instantLocal);\n         return buf.toString();\n     }\n \n-    public int parseInto(ReadWritableInstant instant, String text, int position) {\n+    public int parseInto(final ReadWritableInstant instant, final String text, final int position) {\n         DateTimeParser p = (DateTimeParser)this;\n \n         long millis = instant.getMillis();\n         }\n \n         DateTimeParserBucket bucket = createBucket(millis);\n-        position = p.parseInto(bucket, text, position);\n+        int resultPos = p.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis());\n-        return position;\n+        return resultPos;\n     }\n     \n-    public long parseMillis(String text) throws ParseException {\n+    public long parseMillis(final String text) {\n         return parseMillis(text, 0);\n     }\n \n-    public long parseMillis(String text, long millis) throws ParseException {\n+    public long parseMillis(final String text, final long instantLocal) {\n         DateTimeParser p = (DateTimeParser)this;\n-        DateTimeParserBucket bucket = createBucket(millis);\n+        DateTimeParserBucket bucket = createBucket(instantLocal);\n \n         int newPos = p.parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n-                try {\n-                    return bucket.computeMillis();\n-                } catch (IllegalArgumentException ex) {\n-                    ParseException pe = new ParseException(ex.getMessage(), 0);\n-                    setCause(pe, ex);\n-                    throw pe;\n-                }\n+                return bucket.computeMillis();\n             }\n         } else {\n             newPos = ~newPos;\n         }\n \n-        throw new ParseException(createErrorMessage(text, newPos), newPos);\n-    }\n-\n-    public DateTime parseDateTime(String text) throws ParseException {\n+        throw new IllegalArgumentException(createErrorMessage(text, newPos));\n+    }\n+\n+    public DateTime parseDateTime(final String text) {\n         return new DateTime(parseMillis(text), getChronology());\n     }\n \n-    public MutableDateTime parseMutableDateTime(String text) throws ParseException {\n+    public DateTime parseDateTime(final String text, final ReadableInstant instant) {\n+        return new DateTime(parseMillis(text, getInstantLocal(instant)), getChronology());\n+    }\n+\n+    public MutableDateTime parseMutableDateTime(final String text) {\n         return new MutableDateTime(parseMillis(text), getChronology());\n     }\n \n-    private DateTimeParserBucket createBucket(long millis) {\n+    public MutableDateTime parseMutableDateTime(final String text, final ReadableInstant instant) {\n+        return new MutableDateTime(parseMillis(text, getInstantLocal(instant)), getChronology());\n+    }\n+\n+    private long getInstantLocal(ReadableInstant instant) {\n+        long instantLocal;\n+        if (instant == null) {\n+            instantLocal = 0;\n+        } else {\n+            instantLocal = instant.getMillis();\n+            DateTimeZone zone = instant.getDateTimeZone();\n+            if (zone != null) {\n+                instantLocal += zone.getOffset(instantLocal);\n+            }\n+        }\n+        return instantLocal;\n+    }\n+\n+    private DateTimeParserBucket createBucket(final long millis) {\n         DateTimeParserBucket bucket = new DateTimeParserBucket(millis);\n         Chronology chrono = getChronology();\n         if (chrono != null) {\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/AbstractDurationFormatter.java\n+/**\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import org.joda.time.Duration;\n+import org.joda.time.DurationType;\n+import org.joda.time.MutableDuration;\n+import org.joda.time.ReadableDuration;\n+\n+/**\n+ * Abstract base class for implementing {@link DurationPrinter}s,\n+ * {@link DurationParser}s, and {@link DurationFormatter}s. This class\n+ * intentionally does not implement any of those interfaces. You can subclass\n+ * and implement only the interfaces that you need to.\n+ * <p>\n+ * The print methods assume that your subclass has implemented DurationPrinter or\n+ * DurationFormatter. If not, a ClassCastException is thrown when calling those\n+ * methods.\n+ * <p>\n+ * Likewise, the parse methods assume that your subclass has implemented\n+ * DurationParser or DurationFormatter. If not, a ClassCastException is thrown\n+ * when calling the parse methods.\n+ * \n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class AbstractDurationFormatter {\n+    \n+    public int countFieldsToPrint(ReadableDuration duration) {\n+        return ((DurationPrinter) this).countFieldsToPrint(duration, Integer.MAX_VALUE);\n+    }\n+\n+    public String print(ReadableDuration duration) {\n+        DurationPrinter p = (DurationPrinter) this;\n+        StringBuffer buf = new StringBuffer(p.calculatePrintedLength(duration));\n+        p.printTo(buf, duration);\n+        return buf.toString();\n+    }\n+\n+    public Duration parseDuration(DurationType type, String text) {\n+        return parseMutableDuration(type, text).toDuration();\n+    }\n+\n+    public MutableDuration parseMutableDuration(DurationType type, String text) {\n+        DurationParser p = (DurationParser) this;\n+        MutableDuration duration = new MutableDuration(type, 0);\n+\n+        int newPos = p.parseInto(duration, text, 0);\n+        if (newPos >= 0) {\n+            if (newPos >= text.length()) {\n+                return duration;\n+            }\n+        } else {\n+            newPos = ~newPos;\n+        }\n+\n+        throw new IllegalArgumentException(AbstractDateTimeFormatter\n+                                           .createErrorMessage(text, newPos));\n+    }\n+}\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n import java.io.IOException;\n import java.io.Writer;\n import java.text.DateFormat;\n-import java.text.ParseException;\n import java.text.SimpleDateFormat;\n import java.util.HashMap;\n import java.util.Locale;\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeZone;\n import org.joda.time.MutableDateTime;\n import org.joda.time.ReadWritableInstant;\n import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.RemainderDateTimeField;\n import org.joda.time.chrono.iso.ISOChronology;\n \n /**\n  * DateTimeFormat provides localized printing and parsing capabilities for all\n  * dates and times.\n+ * <p>\n+ * This class provides access to the actual DateTimeFormatter instances in two ways:\n+ * <ul>\n+ * <li>{@link #forPattern(String) Pattern} provides a DateTimeFormatter based on\n+ * a pattern string that is compatible with the JDK date patterns.\n+ * <li>{@link #forStyle(String) Style} provides a DateTimeFormatter based on a\n+ * two character style, representing short, medium, long and full.\n+ * </ul>\n+ * <p>\n+ * For example, to use a patterm:\n+ * <pre>\n+ * DateTime dt = new DateTime();\n+ * DateTimeFormatter fmt = DateTimeFormat.getInstance().forPattern(\"MMMM, yyyy\");\n+ * String str = fmt.print(dt);\n+ * </pre>\n+ *\n+ * The pattern syntax is compatible with java.text.SimpleDateFormat, but a few\n+ * more symbols are also supported. All ASCII letters are reserved as pattern\n+ * letters, which are defined as the following:\n+ * <blockquote>\n+ * <pre>\n+ * Symbol  Meaning                      Presentation  Examples\n+ * ------  -------                      ------------  -------\n+ * G       era                          text          AD\n+ * C       century of era (&gt;=0)         number        20\n+ * Y       year of era (&gt;=0)            year          1996\n+ *\n+ * x       weekyear                     year          1996\n+ * w       week of weekyear             number        27\n+ * e       day of week                  number        2\n+ * E       day of week                  text          Tuesday; Tue\n+ *\n+ * y       year                         year          1996\n+ * D       day of year                  number        189\n+ * M       month of year                month         July; Jul; 07\n+ * d       day of month                 number        10\n+ *\n+ * a       halfday of day               text          PM\n+ * K       hour of halfday (0~11)       number        0\n+ * h       clockhour of halfday (1~12)  number        12\n+ *\n+ * H       hour of day (0~23)           number        0\n+ * k       clockhour of day (1~24)      number        24\n+ * m       minute of hour               number        30\n+ * s       second of minute             number        55\n+ * S       fraction of second           number        978\n+ *\n+ * z       time zone                    text          Pacific Standard Time; PST\n+ * Z       time zone offset             text          -08:00; -0800\n+ *\n+ * '       escape for text              delimiter\n+ * ''      single quote                 literal       '\n+ * </pre>\n+ * </blockquote>\n+ * The count of pattern letters determine the format.\n+ * <p>\n+ * <strong>Text</strong>: If the number of pattern letters is 4 or more,\n+ * the full form is used; otherwise a short or abbreviated form is used if\n+ * available.\n+ * <p>\n+ * <strong>Number</strong>: The minimum number of digits. Shorter numbers\n+ * are zero-padded to this amount.\n+ * <p>\n+ * <strong>Year</strong>: Numeric presentation for year and weekyear fields\n+ * are handled specially. For example, if the count of 'y' is 2, the year\n+ * will be displayed as the zero-based year of the century, which is two\n+ * digits.\n+ * <p>\n+ * <strong>Month</strong>: 3 or over, use text, otherwise use number.\n+ * <p>\n+ * Any characters in the pattern that are not in the ranges of ['a'..'z']\n+ * and ['A'..'Z'] will be treated as quoted text. For instance, characters\n+ * like ':', '.', ' ', '#' and '@' will appear in the resulting time text\n+ * even they are not embraced within single quotes.\n+ * <p>\n+ * DateTimeFormat is thread-safe and immutable, and the formatters it returns\n+ * are as well.\n  *\n  * @author Brian S O'Neill\n+ * @since 1.0\n  * @see ISODateTimeFormat\n  * @see DateTimeFormatterBuilder\n  */\n public class DateTimeFormat {\n \n-    // Maps Chronology instances to maps that map Locales to DateTimeFormat instances.\n+    /**\n+     * Cache that maps Chronology instances to maps that map\n+     * Locales to DateTimeFormat instances.\n+     */\n     private static Map cInstanceCache = new HashMap(7);\n \n+    /**\n+     * Gets an instance of a formatter that works using the ISOChronology in UTC\n+     * in the default locale.\n+     * \n+     * @return a format provider\n+     */\n     public static DateTimeFormat getInstanceUTC() {\n         return getInstance(ISOChronology.getInstanceUTC(), Locale.getDefault());\n     }\n \n+    /**\n+     * Gets an instance of a formatter that works using the ISOChronology in the\n+     * default time zone and the default locale.\n+     * \n+     * @return a format provider\n+     */\n     public static DateTimeFormat getInstance() {\n         return getInstance(ISOChronology.getInstance(), Locale.getDefault());\n     }\n \n-    public static DateTimeFormat getInstance(DateTimeZone zone) {\n+    /**\n+     * Gets an instance of a formatter that works using the ISOChronology in the\n+     * specified time zone and the default locale.\n+     * \n+     * @param zone  the time zone to use, null for default zone\n+     * @return a format provider\n+     */\n+    public static DateTimeFormat getInstance(final DateTimeZone zone) {\n         return getInstance(ISOChronology.getInstance(zone), Locale.getDefault());\n     }\n \n-    public static DateTimeFormat getInstance(DateTimeZone zone, Locale locale) {\n+    /**\n+     * Gets an instance of a formatter that works using the ISOChronology in the\n+     * specified time zone and locale.\n+     * \n+     * @param zone  the time zone to use, null for default zone\n+     * @param locale  the Locale to use, null for default locale\n+     * @return a format provider\n+     */\n+    public static DateTimeFormat getInstance(final DateTimeZone zone, final Locale locale) {\n         return getInstance(ISOChronology.getInstance(zone), locale);\n     }\n \n     /**\n-     * @param chrono Chronology to use\n-     */\n-    public static DateTimeFormat getInstance(Chronology chrono) {\n+     * Gets an instance of a formatter that works using the specified chronology\n+     * in the default locale.\n+     * \n+     * @param chrono  the chronology to use, null means ISOChronology in the default time zone\n+     * @return a format provider\n+     */\n+    public static DateTimeFormat getInstance(final Chronology chrono) {\n         return getInstance(chrono, Locale.getDefault());\n     }\n \n     /**\n-     * @param chrono Chronology to use\n-     * @param locale Locale to use\n+     * Gets an instance of a formatter that works using the specified chronology\n+     * and locale.\n+     * \n+     * @param chrono  the chronology to use, null means ISOChronology in the default time zone\n+     * @param locale  the Locale to use, null for default locale\n+     * @return a format provider\n      */\n     public static synchronized DateTimeFormat getInstance(Chronology chrono, Locale locale) {\n         if (chrono == null) {\n-            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+            chrono = ISOChronology.getInstance();\n         }\n         if (locale == null) {\n-            throw new IllegalArgumentException(\"The Locale must not be null\");\n+            locale = Locale.getDefault();\n         }\n         Map map = (Map)cInstanceCache.get(chrono);\n         if (map == null) {\n         return dtf;\n     }\n \n+    /**\n+     * Parses the given pattern and appends the rules to the given\n+     * DateTimeFormatterBuilder.\n+     *\n+     * @param pattern  pattern specification\n+     * @throws IllegalArgumentException if the pattern is invalid\n+     * @see #forPattern\n+     */\n+    public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n+        int length = pattern.length();\n+        int[] indexRef = new int[1];\n+\n+        for (int i=0; i<length; i++) {\n+            indexRef[0] = i;\n+            String token = parseToken(pattern, indexRef);\n+            i = indexRef[0];\n+\n+            int tokenLen = token.length();\n+            if (tokenLen == 0) {\n+                break;\n+            }\n+            char c = token.charAt(0);\n+\n+            switch (c) {\n+            case 'G': // era designator (text)\n+                builder.appendEraText();\n+                break;\n+            case 'C': // century of era (number)\n+                builder.appendCenturyOfEra(tokenLen, tokenLen);\n+                break;\n+            case 'x': // weekyear (number)\n+            case 'y': // year (number)\n+            case 'Y': // year of era (number)\n+                if (tokenLen == 2) {\n+                    // Use a new RemainderDateTimeField to ensure that the year\n+                    // of century is zero-based.\n+                    DateTimeField field;\n+                    Chronology chronoUTC = builder.getChronology().withUTC();\n+                    switch (c) {\n+                    case 'x':\n+                        field = new RemainderDateTimeField\n+                            (chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n+                        break;\n+                    case 'y': default:\n+                        field = new RemainderDateTimeField\n+                            (chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n+                        break;\n+                    case 'Y':\n+                        field = new RemainderDateTimeField\n+                            (chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n+                        break;\n+                    }\n+                    builder.appendNumeric(field, 2, 2);\n+                } else {\n+                    // Try to support long year values.\n+                    int maxDigits = 9;\n+\n+                    // Peek ahead to next token.\n+                    if (i + 1 < length) {\n+                        indexRef[0]++;\n+                        if (isNumericToken(parseToken(pattern, indexRef))) {\n+                            // If next token is a number, cannot support long years.\n+                            maxDigits = tokenLen;\n+                        }\n+                        indexRef[0]--;\n+                    }\n+\n+                    switch (c) {\n+                    case 'x':\n+                        builder.appendWeekyear(tokenLen, maxDigits);\n+                        break;\n+                    case 'y':\n+                        builder.appendYear(tokenLen, maxDigits);\n+                        break;\n+                    case 'Y':\n+                        builder.appendYearOfEra(tokenLen, maxDigits);\n+                        break;\n+                    }\n+                }\n+                break;\n+            case 'M': // month of year (text and number)\n+                if (tokenLen >= 3) {\n+                    if (tokenLen >= 4) {\n+                        builder.appendMonthOfYearText();\n+                    } else {\n+                        builder.appendMonthOfYearShortText();\n+                    }\n+                } else {\n+                    builder.appendMonthOfYear(tokenLen);\n+                }\n+                break;\n+            case 'd': // day of month (number)\n+                builder.appendDayOfMonth(tokenLen);\n+                break;\n+            case 'h': // hour of day (number, 1..12)\n+                builder.appendClockhourOfHalfday(tokenLen);\n+                break;\n+            case 'H': // hour of day (number, 0..23)\n+                builder.appendHourOfDay(tokenLen);\n+                break;\n+            case 'm': // minute of hour (number)\n+                builder.appendMinuteOfHour(tokenLen);\n+                break;\n+            case 's': // second of minute (number)\n+                builder.appendSecondOfMinute(tokenLen);\n+                break;\n+            case 'S': // fraction of second (number)\n+                builder.appendFractionOfSecond(tokenLen, tokenLen);\n+                break;\n+            case 'e': // day of week (number)\n+                builder.appendDayOfWeek(tokenLen);\n+                break;\n+            case 'E': // dayOfWeek (text)\n+                if (tokenLen >= 4) {\n+                    builder.appendDayOfWeekText();\n+                } else {\n+                    builder.appendDayOfWeekShortText();\n+                }\n+                break;\n+            case 'D': // day of year (number)\n+                builder.appendDayOfYear(tokenLen);\n+                break;\n+            case 'w': // week of weekyear (number)\n+                builder.appendWeekOfWeekyear(tokenLen);\n+                break;\n+            case 'a': // am/pm marker (text)\n+                builder.appendHalfdayOfDayText();\n+                break;\n+            case 'k': // hour of day (1..24)\n+                builder.appendClockhourOfDay(tokenLen);\n+                break;\n+            case 'K': // hour of day (0..11)\n+                builder.appendClockhourOfHalfday(tokenLen);\n+                break;\n+            case 'z': // time zone (text)\n+                if (tokenLen >= 4) {\n+                    builder.appendTimeZoneName();\n+                } else {\n+                    builder.appendTimeZoneShortName();\n+                }\n+                break;\n+            case 'Z': // time zone offset\n+                if (tokenLen >= 4) {\n+                    builder.appendTimeZoneOffset(null, true, 2, 2);\n+                } else {\n+                    builder.appendTimeZoneOffset(null, false, 2, 2);\n+                }\n+                break;\n+            case '\\'': // literal text\n+                String sub = token.substring(1);\n+                if (sub.length() == 1) {\n+                    builder.appendLiteral(sub.charAt(0));\n+                } else {\n+                    // Create copy of sub since otherwise the temporary quoted\n+                    // string would still be referenced internally.\n+                    builder.appendLiteral(new String(sub));\n+                }\n+                break;\n+            default:\n+                throw new IllegalArgumentException\n+                    (\"Illegal pattern component: \" + token);\n+            }\n+        }\n+    }\n+\n+    private static String parseToken(final String pattern, final int[] indexRef) {\n+        StringBuffer buf = new StringBuffer();\n+\n+        int i = indexRef[0];\n+        int length = pattern.length();\n+\n+        char c = pattern.charAt(i);\n+        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n+            // Scan a run of the same character, which indicates a time\n+            // pattern.\n+            buf.append(c);\n+\n+            while (i + 1 < length) {\n+                char peek = pattern.charAt(i + 1);\n+                if (peek == c) {\n+                    buf.append(c);\n+                    i++;\n+                } else {\n+                    break;\n+                }\n+            }\n+        } else {\n+            // This will identify token as text.\n+            buf.append('\\'');\n+\n+            boolean inLiteral = false;\n+\n+            for (; i < length; i++) {\n+                c = pattern.charAt(i);\n+                \n+                if (c == '\\'') {\n+                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n+                        // '' is treated as escaped '\n+                        i++;\n+                        buf.append(c);\n+                    } else {\n+                        inLiteral = !inLiteral;\n+                    }\n+                } else if (!inLiteral &&\n+                           (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n+                    i--;\n+                    break;\n+                } else {\n+                    buf.append(c);\n+                }\n+            }\n+        }\n+\n+        indexRef[0] = i;\n+        return buf.toString();\n+    }\n+\n+    // Returns true if token should be parsed as a numeric field.\n+    private static boolean isNumericToken(final String token) {\n+        int tokenLen = token.length();\n+        if (tokenLen > 0) {\n+            char c = token.charAt(0);\n+            switch (c) {\n+            case 'c': // century (number)\n+            case 'C': // century of era (number)\n+            case 'x': // weekyear (number)\n+            case 'y': // year (number)\n+            case 'Y': // year of era (number)\n+            case 'd': // day of month (number)\n+            case 'h': // hour of day (number, 1..12)\n+            case 'H': // hour of day (number, 0..23)\n+            case 'm': // minute of hour (number)\n+            case 's': // second of minute (number)\n+            case 'S': // fraction of second (number)\n+            case 'e': // day of week (number)\n+            case 'D': // day of year (number)\n+            case 'F': // day of week in month (number)\n+            case 'w': // week of year (number)\n+            case 'W': // week of month (number)\n+            case 'k': // hour of day (1..24)\n+            case 'K': // hour of day (0..11)\n+                return true;\n+            case 'M': // month of year (text and number)\n+                if (tokenLen <= 2) {\n+                    return true;\n+                }\n+            }\n+        }\n+            \n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** The chronology to use */\n     private final Chronology iChrono;\n+    /** The locale to use */\n     private final Locale iLocale;\n \n-    // Maps patterns to formatters.\n-    private Map iPatternedCache = new HashMap(7);\n-\n-    // Maps styles to formatters.\n-    private Map iStyledCache = new HashMap(7);\n-\n-    private DateTimeFormat(Chronology chrono, Locale locale) {\n+    /** Maps patterns to formatters */\n+    private transient Map iPatternedCache = new HashMap(7);\n+\n+    /** Maps styles to formatters */\n+    private transient Map iStyledCache = new HashMap(7);\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param chrono  the chronology to use, must not be null\n+     * @param locale  the locale to use, must not be null\n+     */\n+    private DateTimeFormat(final Chronology chrono, final Locale locale) {\n+        super();\n         iChrono = chrono;\n         iLocale = locale;\n     }\n \n-    /**\n-     * Select a format from a custom {@link DateTimeFormatterBuilder#appendPattern pattern}.\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Select a format from a custom pattern.\n      *\n-     * @param pattern pattern specification\n-     * @throws IllegalArgumentException\n-     * @see DateTimeFormatterBuilder#appendPattern\n-     */\n-    public synchronized DateTimeFormatter forPattern(String pattern) {\n-        DateTimeFormatter formatter = (DateTimeFormatter)iPatternedCache.get(pattern);\n+     * @param pattern  pattern specification\n+     * @throws IllegalArgumentException if the pattern is invalid\n+     * @see #appendPatternTo\n+     */\n+    public synchronized DateTimeFormatter forPattern(final String pattern) {\n+        DateTimeFormatter formatter = (DateTimeFormatter) iPatternedCache.get(pattern);\n         if (formatter != null) {\n             return formatter;\n         }\n             throw new IllegalArgumentException(\"Invalid pattern specification\");\n         }\n \n-        DateTimeFormatterBuilder builder = \n-            new DateTimeFormatterBuilder(iChrono, iLocale).appendPattern(pattern);\n+        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(iChrono, iLocale);\n+        appendPatternTo(builder, pattern);\n \n         if (builder.canBuildFormatter()) {\n             formatter = builder.toFormatter();\n      * character of 'S' for short style, 'M' for medium, 'L' for long, and 'F'\n      * for full. A date or time may be ommitted by specifying a style character '-'.\n      *\n-     * @param style two characters from the set {\"S\", \"M\", \"L\", \"F\", \"-\"}\n-     * @throws IllegalArgumentException\n-     */\n-    public synchronized DateTimeFormatter forStyle(String style) {\n+     * @param style  two characters from the set {\"S\", \"M\", \"L\", \"F\", \"-\"}\n+     * @throws IllegalArgumentException if the style is invalid\n+     */\n+    public synchronized DateTimeFormatter forStyle(final String style) {\n         DateTimeFormatter formatter = (DateTimeFormatter)iStyledCache.get(style);\n         if (formatter == null) {\n             formatter = forPattern(getPatternForStyle(style));\n      * for long, and 'F' for full. A date or time may be ommitted by specifying\n      * a style character '-'.\n      *\n-     * @param style two characters from the set {\"S\", \"M\", \"L\", \"F\", \"-\"}\n-     * @throws IllegalArgumentException\n-     */\n-    public String getPatternForStyle(String style) {\n+     * @param style  two characters from the set {\"S\", \"M\", \"L\", \"F\", \"-\"}\n+     * @throws IllegalArgumentException if the style is invalid\n+     */\n+    public String getPatternForStyle(final String style) {\n         if (style == null || style.length() != 2) {\n             throw new IllegalArgumentException(\"Invalid style specification: \" + style);\n         }\n         }\n     }\n \n-    private String getDatePattern(char style) {\n+    private String getDatePattern(final char style) {\n         int istyle = selectStyle(style);\n         try {\n             return ((SimpleDateFormat)DateFormat.getDateInstance(istyle, iLocale)).toPattern();\n         }\n     }\n \n-    private String getTimePattern(char style) {\n+    private String getTimePattern(final char style) {\n         int istyle = selectStyle(style);\n         try {\n             return ((SimpleDateFormat)DateFormat.getTimeInstance(istyle, iLocale)).toPattern();\n         }\n     }\n \n-    private String getDateTimePattern(char dateStyle, char timeStyle) {\n+    private String getDateTimePattern(final char dateStyle, final char timeStyle) {\n         int idateStyle = selectStyle(dateStyle);\n         int itimeStyle = selectStyle(dateStyle);\n         try {\n         }\n     }\n \n-    private int selectStyle(char c) {\n+    private int selectStyle(final char c) {\n         switch (c) {\n         case 'S':\n             return DateFormat.SHORT;\n         }\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * A fake formatter that can only print.\n      */\n-    private static class FPrinter implements DateTimeFormatter {\n+    static class FPrinter implements DateTimeFormatter {\n         private final DateTimePrinter mPrinter;\n \n-        FPrinter(DateTimePrinter printer) {\n+        FPrinter(final DateTimePrinter printer) {\n+            super();\n             mPrinter = printer;\n         }\n \n             return mPrinter.estimatePrintedLength();\n         }\n \n-        public void printTo(StringBuffer buf, ReadableInstant instant) {\n+        public void printTo(final StringBuffer buf, final ReadableInstant instant) {\n             mPrinter.printTo(buf, instant);\n         }\n \n-        public void printTo(Writer out, ReadableInstant instant) throws IOException {\n+        public void printTo(final Writer out, final ReadableInstant instant) throws IOException {\n             mPrinter.printTo(out, instant);\n         }\n \n-        public void printTo(StringBuffer buf, long millisUTC) {\n-            mPrinter.printTo(buf, millisUTC);\n-        }\n-\n-        public void printTo(Writer out, long millisUTC) throws IOException {\n-            mPrinter.printTo(out, millisUTC);\n-        }\n-\n-        public void printTo(StringBuffer buf, long millisUTC, DateTimeZone zone) {\n-            mPrinter.printTo(buf, millisUTC, zone);\n-        }\n-\n-        public void printTo(Writer out, long millisUTC, DateTimeZone zone)\n+        public void printTo(final StringBuffer buf, final long instant) {\n+            mPrinter.printTo(buf, instant);\n+        }\n+\n+        public void printTo(final Writer out, final long instant) throws IOException {\n+            mPrinter.printTo(out, instant);\n+        }\n+\n+        public void printTo(final StringBuffer buf, final long instant, final DateTimeZone zone) {\n+            mPrinter.printTo(buf, instant, zone);\n+        }\n+\n+        public void printTo(final Writer out, final long instant, final DateTimeZone zone)\n             throws IOException {\n-            mPrinter.printTo(out, millisUTC, zone);\n-        }\n-\n-        public void printTo(StringBuffer buf, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) {\n-            mPrinter.printTo(buf, millisUTC, zone, millisLocal);\n-        }\n-\n-        public void printTo(Writer out, long millisUTC,\n-                            DateTimeZone zone, long millisLocal)\n+            mPrinter.printTo(out, instant, zone);\n+        }\n+\n+        public void printTo(final StringBuffer buf, final long instant,\n+                            final DateTimeZone zone, final long instantLocal) {\n+            mPrinter.printTo(buf, instant, zone, instantLocal);\n+        }\n+\n+        public void printTo(final Writer out, final long instant,\n+                            final DateTimeZone zone, final long instantLocal)\n             throws IOException {\n-            mPrinter.printTo(out, millisUTC, zone, millisLocal);\n-        }\n-\n-        public String print(ReadableInstant instant) {\n+            mPrinter.printTo(out, instant, zone, instantLocal);\n+        }\n+\n+        public String print(final ReadableInstant instant) {\n             return mPrinter.print(instant);\n         }\n \n-        public String print(long millisUTC) {\n-            return mPrinter.print(millisUTC);\n-        }\n-\n-        public String print(long millisUTC, DateTimeZone zone) {\n-            return mPrinter.print(millisUTC, zone);\n-        }\n-\n-        public String print(long millisUTC, DateTimeZone zone, long millisLocal) {\n-            return mPrinter.print(millisUTC, zone, millisLocal);\n+        public String print(final long instant) {\n+            return mPrinter.print(instant);\n+        }\n+\n+        public String print(final long instant, final DateTimeZone zone) {\n+            return mPrinter.print(instant, zone);\n+        }\n+\n+        public String print(final long instant, final DateTimeZone zone, final long instantLocal) {\n+            return mPrinter.print(instant, zone, instantLocal);\n         }\n \n         public int estimateParsedLength() {\n             return 0;\n         }\n \n-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n-            throw unsupported();\n-        }\n-\n-        public int parseInto(ReadWritableInstant instant, String text, int position) {\n-            throw unsupported();\n-        }\n-\n-        public long parseMillis(String text) throws ParseException {\n-            throw unsupported();\n-        }\n-\n-        public long parseMillis(String text, long millis) throws ParseException {\n-            throw unsupported();\n-        }\n-\n-        public DateTime parseDateTime(String text) throws ParseException {\n-            throw unsupported();\n-        }\n-\n-        public MutableDateTime parseMutableDateTime(String text) throws ParseException {\n+        public int parseInto(final DateTimeParserBucket bucket, final String text, final int position) {\n+            throw unsupported();\n+        }\n+\n+        public int parseInto(final ReadWritableInstant instant, final String text, final int position) {\n+            throw unsupported();\n+        }\n+\n+        public long parseMillis(final String text) {\n+            throw unsupported();\n+        }\n+\n+        public long parseMillis(final String text, final long instantLocal) {\n+            throw unsupported();\n+        }\n+\n+        public DateTime parseDateTime(final String text) {\n+            throw unsupported();\n+        }\n+\n+        public DateTime parseDateTime(final String text, final ReadableInstant instant) {\n+            throw unsupported();\n+        }\n+\n+        public MutableDateTime parseMutableDateTime(final String text) {\n+            throw unsupported();\n+        }\n+\n+        public MutableDateTime parseMutableDateTime(final String text,\n+                                                    final ReadableInstant instant) {\n             throw unsupported();\n         }\n \n         }\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * A fake formatter that can only parse.\n      */\n-    private static class FParser implements DateTimeFormatter {\n+    static class FParser implements DateTimeFormatter {\n         private final DateTimeParser mParser;\n \n-        FParser(DateTimeParser parser) {\n+        FParser(final DateTimeParser parser) {\n+            super();\n             mParser = parser;\n         }\n \n             return 0;\n         }\n \n-        public void printTo(StringBuffer buf, ReadableInstant instant) {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(Writer out, ReadableInstant instant) throws IOException {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(StringBuffer buf, long millisUTC) {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(Writer out, long millisUTC) throws IOException {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(StringBuffer buf, long millisUTC, DateTimeZone zone) {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(Writer out, long millisUTC, DateTimeZone zone) {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(StringBuffer buf, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(Writer out, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) {\n-            throw unsupported();\n-        }\n-\n-        public String print(ReadableInstant instant) {\n-            throw unsupported();\n-        }\n-\n-        public String print(long millisUTC) {\n-            throw unsupported();\n-        }\n-\n-        public String print(long millisUTC, DateTimeZone zone) {\n-            throw unsupported();\n-        }\n-\n-        public String print(long millisUTC, DateTimeZone zone, long millisLocal) {\n+        public void printTo(final StringBuffer buf, final ReadableInstant instant) {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(final Writer out, final ReadableInstant instant) throws IOException {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(final StringBuffer buf, final long instant) {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(final Writer out, final long instant) throws IOException {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(final StringBuffer buf, final long instant, final DateTimeZone zone) {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(final Writer out, final long instant, final DateTimeZone zone) {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(final StringBuffer buf, final long instant,\n+                            final DateTimeZone zone, final long instantLocal) {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(final Writer out, final long instant,\n+                            final DateTimeZone zone, final long instantLocal) {\n+            throw unsupported();\n+        }\n+\n+        public String print(final ReadableInstant instant) {\n+            throw unsupported();\n+        }\n+\n+        public String print(final long instant) {\n+            throw unsupported();\n+        }\n+\n+        public String print(final long instant, final DateTimeZone zone) {\n+            throw unsupported();\n+        }\n+\n+        public String print(final long instant, final DateTimeZone zone, final long instantLocal) {\n             throw unsupported();\n         }\n \n             return mParser.estimateParsedLength();\n         }\n \n-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+        public int parseInto(final DateTimeParserBucket bucket, final String text, final int position) {\n             return mParser.parseInto(bucket, text, position);\n         }\n \n-        public int parseInto(ReadWritableInstant instant, String text, int position) {\n+        public int parseInto(final ReadWritableInstant instant, final String text, final int position) {\n             return mParser.parseInto(instant, text, position);\n         }\n \n-        public long parseMillis(String text) throws ParseException {\n+        public long parseMillis(final String text) {\n             return mParser.parseMillis(text);\n         }\n \n-        public long parseMillis(String text, long millis) throws ParseException {\n-            return mParser.parseMillis(text, millis);\n-        }\n-\n-        public DateTime parseDateTime(String text) throws ParseException {\n+        public long parseMillis(final String text, final long instantLocal) {\n+            return mParser.parseMillis(text, instantLocal);\n+        }\n+\n+        public DateTime parseDateTime(final String text) {\n             return mParser.parseDateTime(text);\n         }\n \n-        public MutableDateTime parseMutableDateTime(String text) throws ParseException {\n+        public DateTime parseDateTime(final String text, final ReadableInstant instant) {\n+            return mParser.parseDateTime(text, instant);\n+        }\n+\n+        public MutableDateTime parseMutableDateTime(final String text) {\n             return mParser.parseMutableDateTime(text);\n+        }\n+\n+        public MutableDateTime parseMutableDateTime(final String text,\n+                                                    final ReadableInstant instant) {\n+            return mParser.parseMutableDateTime(text, instant);\n         }\n \n         private UnsupportedOperationException unsupported() {\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java\n  */\n package org.joda.time.format;\n \n-import java.io.IOException;\n-import java.io.Writer;\n-import java.text.ParseException;\n-\n-import org.joda.time.Chronology;\n-import org.joda.time.DateTime;\n-import org.joda.time.DateTimeZone;\n-import org.joda.time.MutableDateTime;\n-import org.joda.time.ReadWritableInstant;\n-import org.joda.time.ReadableInstant;\n-\n /**\n- * Combined interface for printing and parsing.\n+ * Defines a combined interface for printing and parsing.\n  *\n  * @author Brian S O'Neill\n  */\n public interface DateTimeFormatter extends DateTimePrinter, DateTimeParser {\n     \n-    /**\n-     * Returns the Chronology being used by the formatter, or null if none.\n-     */\n-    Chronology getChronology();\n-\n-    /**\n-     * Returns the expected maximum number of characters produced. The actual\n-     * amount should rarely exceed this estimate.\n-     */\n-    int estimatePrintedLength();\n-\n-    /**\n-     * Prints a ReadableInstant, attempting to use the DateTimeZone supplied by\n-     * the instant.\n-     *\n-     * @param buf formatted instant is appended to this buffer\n-     * @param instant instant to format\n-     */\n-    void printTo(StringBuffer buf, ReadableInstant instant);\n-\n-    /**\n-     * Prints a ReadableInstant, attempting to use the DateTimeZone supplied by\n-     * the instant.\n-     *\n-     * @param out formatted instant is written out\n-     * @param instant instant to format\n-     */\n-    void printTo(Writer out, ReadableInstant instant) throws IOException;\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * using the formatter's DateTimeZone.\n-     *\n-     * @param buf formatted instant is appended to this buffer\n-     * @param millisUTC millis since 1970-01-01T00:00:00Z\n-     */\n-    void printTo(StringBuffer buf, long millisUTC);\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * using the formatter's DateTimeZone.\n-     *\n-     * @param out formatted instant is written out\n-     * @param millisUTC millis since 1970-01-01T00:00:00Z\n-     */\n-    void printTo(Writer out, long millisUTC) throws IOException;\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * attempting to use the given DateTimeZone.\n-     *\n-     * @param buf formatted instant is appended to this buffer\n-     * @param millisUTC millis since 1970-01-01T00:00:00Z\n-     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n-     * not null\n-     */\n-    void printTo(StringBuffer buf, long millisUTC, DateTimeZone zone);\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * attempting to use the given DateTimeZone.\n-     *\n-     * @param out formatted instant is written out\n-     * @param millisUTC millis since 1970-01-01T00:00:00Z\n-     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n-     * not null\n-     */\n-    void printTo(Writer out, long millisUTC, DateTimeZone zone) throws IOException;\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * attempting to use the given DateTimeZone.\n-     *\n-     * @param buf formatted instant is appended to this buffer\n-     * @param millisUTC millis since 1970-01-01T00:00:00Z, used by time zone\n-     * printers\n-     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n-     * not null\n-     * @param millisLocal pre-calculated millis since 1970-01-01T00:00:00,\n-     * local time\n-     */\n-    void printTo(StringBuffer buf, long millisUTC,\n-                 DateTimeZone zone, long millisLocal);\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * attempting to use the given DateTimeZone.\n-     *\n-     * @param out formatted instant is written out\n-     * @param millisUTC millis since 1970-01-01T00:00:00Z, used by time zone\n-     * printers\n-     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n-     * not null\n-     * @param millisLocal pre-calculated millis since 1970-01-01T00:00:00,\n-     * local time\n-     */\n-    void printTo(Writer out, long millisUTC,\n-                 DateTimeZone zone, long millisLocal) throws IOException;\n-\n-    /**\n-     * Prints a ReadableInstant to a new String, attempting to use the\n-     * DateTimeZone supplied by the instant.\n-     *\n-     * @param instant instant to format\n-     * @return the printed result\n-     */\n-    String print(ReadableInstant instant);\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * using the formatter's DateTimeZone.\n-     *\n-     * @param millisUTC millis since 1970-01-01T00:00:00Z\n-     * @return the printed result\n-     */\n-    String print(long millisUTC);\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * attempting to use the given DateTimeZone.\n-     *\n-     * @param millisUTC millis since 1970-01-01T00:00:00Z\n-     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n-     * not null\n-     * @return the printed result\n-     */\n-    String print(long millisUTC, DateTimeZone zone);\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * attempting to use the given DateTimeZone.\n-     *\n-     * @param millisUTC millis since 1970-01-01T00:00:00Z\n-     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n-     * not null\n-     * @param millisLocal pre-calculated millis since 1970-01-01T00:00:00,\n-     * local time\n-     * @return the printed result\n-     */\n-    String print(long millisUTC, DateTimeZone zone, long millisLocal);\n-\n-    /**\n-     * Returns the expected maximum number of characters consumed. The actual\n-     * amount should rarely exceed this estimate.\n-     */\n-    int estimateParsedLength();\n-\n-    /**\n-     * Parse an element from the given text, saving any fields into the given\n-     * DateTimeParserBucket. If the parse succeeds, the return value is the new\n-     * text position. Note that the parse may succeed without fully reading the\n-     * text.\n-     * <p>\n-     * If it fails, the return value is negative. To determine the position\n-     * where the parse failed, apply the one's complement operator (~) on the\n-     * return value.\n-     *\n-     * @param bucket field are saved into this\n-     * @param text the text to parse\n-     * @param position position to start parsing from\n-     * @return new position, if negative, parse failed. Apply complement\n-     * operator (~) to get position of failure\n-     * @throws IllegalArgumentException if any field is out of range\n-     */\n-    int parseInto(DateTimeParserBucket bucket, String text, int position);\n-\n-    /**\n-     * Parses a datetime from the given text, at the given position, saving the\n-     * result into the fields of the given ReadWritableInstant. If the parse\n-     * succeeds, the return value is the new text position. Note that the parse\n-     * may succeed without fully reading the text.\n-     * <p>\n-     * If it fails, the return value is negative, but the instant may still be\n-     * modified. To determine the position where the parse failed, apply the\n-     * one's complement operator (~) on the return value.\n-     *\n-     * @param instant an instant that will be modified\n-     * @param text text to parse\n-     * @param position position to start parsing from\n-     * @return new position, if negative, parse failed. Apply complement\n-     * operator (~) to get position of failure\n-     * @throws IllegalArgumentException if any field is out of range\n-     */\n-    int parseInto(ReadWritableInstant instant, String text, int position);\n-\n-    /**\n-     * Parses a datetime from the given text, returning the number of\n-     * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n-     *\n-     * @param text text to parse\n-     * @return parsed value expressed in milliseconds since the epoch\n-     * @throws ParseException if any field is out of range\n-     */\n-    long parseMillis(String text) throws ParseException;\n-\n-    /**\n-     * Parses a datetime from the given text, at the given position, returning\n-     * the number of milliseconds since the epoch, 1970-01-01T00:00:00Z. An\n-     * initial millisecond value is passed in, which is relative to the epoch,\n-     * local time.\n-     *\n-     * @param text text to parse\n-     * @param millis initial value of millis, relative to the epoch, local time\n-     * @return parsed value expressed in milliseconds since the epoch, UTC\n-     * @throws ParseException if any field is out of range\n-     */\n-    long parseMillis(String text, long millis) throws ParseException;\n-\n-    /**\n-     * Parses a datetime from the given text, returning a new DateTime.\n-     *\n-     * @param text text to parse\n-     * @return parsed value in a DateTime object\n-     * @throws ParseException if any field is out of range\n-     */\n-    DateTime parseDateTime(String text) throws ParseException;\n-\n-    /**\n-     * Parses a datetime from the given text, returning a new MutableDateTime.\n-     *\n-     * @param text text to parse\n-     * @return parsed value in a MutabkeDateTime object\n-     * @throws ParseException if any field is out of range\n-     */\n-    MutableDateTime parseMutableDateTime(String text) throws ParseException;\n-    \n+    // Methods inherited\n }\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.ReadableInstant;\n-import org.joda.time.chrono.FractionalDateTimeField;\n-import org.joda.time.chrono.RemainderDateTimeField;\n+import org.joda.time.chrono.MillisDurationField;\n+import org.joda.time.chrono.PreciseDateTimeField;\n import org.joda.time.chrono.iso.ISOChronology;\n \n /**\n  * DateTimeFormatterBuilder is used for constructing {@link DateTimeFormatter}s.\n- * DateTimeFormatters can be built by appending specific fields, patterns, or\n- * other formatters.\n+ * DateTimeFormatters can be built by appending specific fields or other\n+ * formatters.\n  *\n  * <p>\n  * For example, a formatter that prints month and year, like \"January 1970\", can\n  *     .appendYear(4, 4)\n  *     .toFormatter();\n  * </pre>\n+ * <p>\n+ * DateTimeFormatterBuilder itself is mutable and not thread-safe, but the\n+ * formatters that it builds are thread-safe and immutable.\n  *\n  * @see DateTimeFormat\n  * @author Brian S O'Neill\n  */\n public class DateTimeFormatterBuilder {\n \n-    private static String parseToken(String pattern, int[] indexRef) {\n-        StringBuffer buf = new StringBuffer();\n-\n-        int i = indexRef[0];\n-        int length = pattern.length();\n-\n-        char c = pattern.charAt(i);\n-        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n-            // Scan a run of the same character, which indicates a time\n-            // pattern.\n-            buf.append(c);\n-\n-            while (i + 1 < length) {\n-                char peek = pattern.charAt(i + 1);\n-                if (peek == c) {\n-                    buf.append(c);\n-                    i++;\n-                } else {\n-                    break;\n-                }\n-            }\n-        } else {\n-            // This will identify token as text.\n-            buf.append('\\'');\n-\n-            boolean inLiteral = false;\n-\n-            for (; i < length; i++) {\n-                c = pattern.charAt(i);\n-                \n-                if (c == '\\'') {\n-                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n-                        // '' is treated as escaped '\n-                        i++;\n-                        buf.append(c);\n-                    } else {\n-                        inLiteral = !inLiteral;\n-                    }\n-                } else if (!inLiteral &&\n-                           (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n-                    i--;\n-                    break;\n-                } else {\n-                    buf.append(c);\n-                }\n-            }\n-        }\n-\n-        indexRef[0] = i;\n-        return buf.toString();\n-    }\n-\n     private final Chronology iChrono;\n     private final Chronology iChronoUTC;\n     private final Locale iLocale;\n      * Creates a DateTimeFormatterBuilder with {@link ISOChronology}, in the\n      * given time zone, with the default locale.\n      */\n-    public DateTimeFormatterBuilder(DateTimeZone zone) {\n+    public DateTimeFormatterBuilder(final DateTimeZone zone) {\n         this(ISOChronology.getInstance(zone));\n     }\n \n      * Creates a DateTimeFormatterBuilder with {@link ISOChronology}, in the\n      * given time zone, with any locale.\n      */\n-    public DateTimeFormatterBuilder(DateTimeZone zone, Locale locale) {\n+    public DateTimeFormatterBuilder(final DateTimeZone zone, final Locale locale) {\n         this(ISOChronology.getInstance(zone), locale);\n     }\n \n      *\n      * @param chrono Chronology to use\n      */\n-    public DateTimeFormatterBuilder(Chronology chrono) {\n+    public DateTimeFormatterBuilder(final Chronology chrono) {\n         this(chrono, Locale.getDefault());\n     }\n \n     /**\n      * Creates a DateTimeFormatterBuilder with any chronology and locale.\n      *\n-     * @param chrono Chronology to use\n-     * @param locale Locale to use\n+     * @param chrono Chronology to use, or null for default iso\n+     * @param locale Locale to use, or null for default\n      */\n     public DateTimeFormatterBuilder(Chronology chrono, Locale locale) {\n         if (chrono == null) {\n-            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+            chrono = ISOChronology.getInstance();\n         }\n         if (locale == null) {\n-            throw new IllegalArgumentException(\"The Locale must not be null\");\n+            locale = Locale.getDefault();\n         }\n         iChrono = chrono;\n         iChronoUTC = chrono.withUTC();\n      *\n      * @throws IllegalArgumentException if formatter is null\n      */\n-    public DateTimeFormatterBuilder append(DateTimeFormatter formatter)\n+    public DateTimeFormatterBuilder append(final DateTimeFormatter formatter)\n         throws IllegalArgumentException\n     {\n         if (formatter == null) {\n      *\n      * @throws IllegalArgumentException if printer is null\n      */\n-    public DateTimeFormatterBuilder append(DateTimePrinter printer)\n+    public DateTimeFormatterBuilder append(final DateTimePrinter printer)\n         throws IllegalArgumentException\n     {\n         if (printer == null) {\n      *\n      * @throws IllegalArgumentException if parser is null\n      */\n-    public DateTimeFormatterBuilder append(DateTimeParser parser) {\n+    public DateTimeFormatterBuilder append(final DateTimeParser parser) {\n         if (parser == null) {\n             throw new IllegalArgumentException(\"No parser supplied\");\n         }\n      *\n      * @throws IllegalArgumentException if printer or parser is null\n      */\n-    public DateTimeFormatterBuilder append(DateTimePrinter printer,\n-                                           DateTimeParser parser)\n+    public DateTimeFormatterBuilder append(final DateTimePrinter printer,\n+                                           final DateTimeParser parser)\n         throws IllegalArgumentException\n     {\n         if (printer == null) {\n      *\n      * @throws IllegalArgumentException if any parser element but the last is null\n      */\n-    public DateTimeFormatterBuilder append(DateTimePrinter printer,\n-                                           DateTimeParser[] parsers)\n+    public DateTimeFormatterBuilder append(final DateTimePrinter printer,\n+                                           final DateTimeParser[] parsers)\n         throws IllegalArgumentException\n     {\n         if (parsers == null) {\n      *\n      * @throws IllegalArgumentException if parser is null\n      */\n-    public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {\n+    public DateTimeFormatterBuilder appendOptional(final DateTimeParser parser) {\n         if (parser == null) {\n             throw new IllegalArgumentException(\"No parser supplied\");\n         }\n         return append0(null, new MatchingParser(iChrono, new DateTimeParser[] {parser, null}));\n     }\n \n-    private DateTimeFormatterBuilder append0(Object element) {\n+    private DateTimeFormatterBuilder append0(final Object element) {\n         iFormatter = null;\n         // Add the element as both a printer and parser.\n         iElementPairs.add(element);\n         return this;\n     }\n \n-    private DateTimeFormatterBuilder append0(DateTimePrinter printer,\n-                                             DateTimeParser parser)\n-    {\n+    private DateTimeFormatterBuilder append0(\n+            final DateTimePrinter printer, final DateTimeParser parser) {\n         iFormatter = null;\n         iElementPairs.add(printer);\n         iElementPairs.add(parser);\n      * Instructs the printer to emit a specific character, and the parser to\n      * expect it. The parser is case-insensitive.\n      */\n-    public DateTimeFormatterBuilder appendLiteral(char c) {\n+    public DateTimeFormatterBuilder appendLiteral(final char c) {\n         return append0(new CharacterLiteral(iChrono, c));\n     }\n \n     /**\n      * Instructs the printer to emit specific text, and the parser to expect\n      * it. The parser is case-insensitive.\n-     */\n-    public DateTimeFormatterBuilder appendLiteral(String text) {\n+     *\n+     * @throws IllegalArgumentException if text is null\n+     */\n+    public DateTimeFormatterBuilder appendLiteral(final String text) {\n+        if (text == null) {\n+            throw new IllegalArgumentException(\"Literal must not be null\");\n+        }\n         return append0(new StringLiteral(iChrono, text));\n     }\n \n      * @param minDigits minumum number of digits to <i>print</i>\n      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n-     */\n-    public DateTimeFormatterBuilder appendNumeric(DateTimeField field,\n-                                                  int minDigits, int maxDigits)\n-    {\n+     * @throws IllegalArgumentException if field is null\n+     */\n+    public DateTimeFormatterBuilder appendNumeric(\n+            DateTimeField field, int minDigits, int maxDigits) {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n         if (maxDigits < minDigits) {\n             maxDigits = minDigits;\n         }\n      * @param minDigits minumum number of digits to <i>print</i>\n      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n-     */\n-    public DateTimeFormatterBuilder appendSignedNumeric(DateTimeField field,\n-                                                        int minDigits, int maxDigits)\n-    {\n+     * @throws IllegalArgumentException if field is null\n+     */\n+    public DateTimeFormatterBuilder appendSignedNumeric(\n+            DateTimeField field, int minDigits, int maxDigits) {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n         if (maxDigits < minDigits) {\n             maxDigits = minDigits;\n         }\n      *\n      * @param field field should operate in UTC or be time zone agnostic\n      */\n-    public DateTimeFormatterBuilder appendText(DateTimeField field) {\n+    public DateTimeFormatterBuilder appendText(final DateTimeField field) {\n         return append0(new TextField(iChrono, field, iLocale, false));\n     }\n \n      *\n      * @param field field should operate in UTC or be time zone agnostic\n      */\n-    public DateTimeFormatterBuilder appendShortText(DateTimeField field) {\n+    public DateTimeFormatterBuilder appendShortText(final DateTimeField field) {\n         return append0(new TextField(iChrono, field, iLocale, true));\n     }\n \n     /**\n      * Instructs the printer to emit a remainder of time as a decimal fraction,\n-     * sans decimal point. For example, if the range is specified as 60000\n-     * (milliseconds in one minute) and the time is 12:30:45, the value printed\n-     * is 75. A decimal point is implied, so the fraction is 0.75, or three-quarters\n-     * of a minute.\n-     *\n+     * sans decimal point. For example, if the field is specified as\n+     * minuteOfHour and the time is 12:30:45, the value printed is 75. A\n+     * decimal point is implied, so the fraction is 0.75, or three-quarters of\n+     * a minute.\n+     *\n+     * @param field field should operate in UTC or be time zone agnostic\n      * @param minDigits minumum number of digits to print.\n      * @param maxDigits maximum number of digits to print or parse.\n-     * @param rangeInMillis range of values in fraction\n-     */\n-    public DateTimeFormatterBuilder appendFraction(int minDigits, int maxDigits,\n-                                                   int rangeInMillis)\n-    {\n+     * @throws IllegalArgumentException if field's duration is not precise\n+     */\n+    public DateTimeFormatterBuilder appendFraction(\n+            DateTimeField field, int minDigits, int maxDigits) {\n+        if (field.getDurationField().isPrecise() == false) {\n+            throw new IllegalArgumentException(\"Field duration must be precise\");\n+        }\n         if (maxDigits < minDigits) {\n             maxDigits = minDigits;\n         }\n         if (minDigits < 0 || maxDigits <= 0) {\n             throw new IllegalArgumentException();\n         }\n-        return append0(new Fraction(iChrono, minDigits, maxDigits, rangeInMillis));\n+        return append0(new Fraction(iChrono, field, minDigits, maxDigits));\n     }\n \n     /**\n      * @param minDigits minumum number of digits to print\n      * @param maxDigits maximum number of digits to print or parse\n      */\n-    public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\n-        return appendFraction(minDigits, maxDigits, DateTimeConstants.MILLIS_PER_SECOND);\n+    public DateTimeFormatterBuilder appendFractionOfSecond(final int minDigits, final int maxDigits) {\n+        return appendFraction(iChronoUTC.secondOfDay(), minDigits, maxDigits);\n     }\n \n     /**\n      * @param minDigits minumum number of digits to print\n      * @param maxDigits maximum number of digits to print or parse\n      */\n-    public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) {\n-        return appendFraction(minDigits, maxDigits, DateTimeConstants.MILLIS_PER_MINUTE);\n+    public DateTimeFormatterBuilder appendFractionOfMinute(final int minDigits, final int maxDigits) {\n+        return appendFraction(iChronoUTC.minuteOfDay(), minDigits, maxDigits);\n     }\n \n     /**\n      * @param minDigits minumum number of digits to print\n      * @param maxDigits maximum number of digits to print or parse\n      */\n-    public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) {\n-        return appendFraction(minDigits, maxDigits, DateTimeConstants.MILLIS_PER_HOUR);\n+    public DateTimeFormatterBuilder appendFractionOfHour(final int minDigits, final int maxDigits) {\n+        return appendFraction(iChronoUTC.hourOfDay(), minDigits, maxDigits);\n     }\n \n     /**\n      * @param minDigits minumum number of digits to print\n      * @param maxDigits maximum number of digits to print or parse\n      */\n-    public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) {\n-        return appendFraction\n-            (minDigits, maxDigits, DateTimeConstants.MILLIS_PER_DAY);\n+    public DateTimeFormatterBuilder appendFractionOfDay(final int minDigits, final int maxDigits) {\n+        return appendFraction(iChronoUTC.dayOfYear(), minDigits, maxDigits);\n     }\n \n     /**\n      *\n      * @param minDigits minumum number of digits to print\n      */\n-    public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {\n+    public DateTimeFormatterBuilder appendMillisOfSecond(final int minDigits) {\n         return appendNumeric(iChronoUTC.millisOfSecond(), minDigits, 3);\n     }\n \n      *\n      * @param minDigits minumum number of digits to print\n      */\n-    public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {\n+    public DateTimeFormatterBuilder appendMillisOfDay(final int minDigits) {\n         return appendNumeric(iChronoUTC.millisOfDay(), minDigits, 8);\n     }\n \n      *\n      * @param minDigits minumum number of digits to print\n      */\n-    public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\n+    public DateTimeFormatterBuilder appendSecondOfMinute(final int minDigits) {\n         return appendNumeric(iChronoUTC.secondOfMinute(), minDigits, 2);\n     }\n \n      *\n      * @param minDigits minumum number of digits to print\n      */\n-    public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {\n+    public DateTimeFormatterBuilder appendSecondOfDay(final int minDigits) {\n         return appendNumeric(iChronoUTC.secondOfDay(), minDigits, 5);\n     }\n \n      *\n      * @param minDigits minumum number of digits to print\n      */\n-    public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\n+    public DateTimeFormatterBuilder appendMinuteOfHour(final int minDigits) {\n         return appendNumeric(iChronoUTC.minuteOfHour(), minDigits, 2);\n     }\n \n      *\n      * @param minDigits minumum number of digits to print\n      */\n-    public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {\n+    public DateTimeFormatterBuilder appendMinuteOfDay(final int minDigits) {\n         return appendNumeric(iChronoUTC.minuteOfDay(), minDigits, 4);\n     }\n \n      *\n      * @param minDigits minumum number of digits to print\n      */\n-    public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\n+    public DateTimeFormatterBuilder appendHourOfDay(final int minDigits) {\n         return appendNumeric(iChronoUTC.hourOfDay(), minDigits, 2);\n     }\n \n      *\n      * @param minDigits minumum number of digits to print\n      */\n-    public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {\n+    public DateTimeFormatterBuilder appendClockhourOfDay(final int minDigits) {\n         return appendNumeric(iChronoUTC.clockhourOfDay(), minDigits, 2);\n     }\n \n      *\n      * @param minDigits minumum number of digits to print\n      */\n-    public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {\n+    public DateTimeFormatterBuilder appendHourOfHalfday(final int minDigits) {\n         return appendNumeric(iChronoUTC.hourOfHalfday(), minDigits, 2);\n     }\n \n      *\n      * @param minDigits minumum number of digits to print\n      */\n-    public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {\n+    public DateTimeFormatterBuilder appendClockhourOfHalfday(final int minDigits) {\n         return appendNumeric(iChronoUTC.clockhourOfHalfday(), minDigits, 2);\n     }\n \n      *\n      * @param minDigits minumum number of digits to print\n      */\n-    public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {\n+    public DateTimeFormatterBuilder appendDayOfWeek(final int minDigits) {\n         return appendNumeric(iChronoUTC.dayOfWeek(), minDigits, 1);\n     }\n \n      *\n      * @param minDigits minumum number of digits to print\n      */\n-    public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\n+    public DateTimeFormatterBuilder appendDayOfMonth(final int minDigits) {\n         return appendNumeric(iChronoUTC.dayOfMonth(), minDigits, 2);\n     }\n \n      *\n      * @param minDigits minumum number of digits to print\n      */\n-    public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {\n+    public DateTimeFormatterBuilder appendDayOfYear(final int minDigits) {\n         return appendNumeric(iChronoUTC.dayOfYear(), minDigits, 3);\n     }\n \n      *\n      * @param minDigits minumum number of digits to print\n      */\n-    public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\n+    public DateTimeFormatterBuilder appendWeekOfWeekyear(final int minDigits) {\n         return appendNumeric(iChronoUTC.weekOfWeekyear(), minDigits, 2);\n     }\n \n      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n      */\n-    public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {\n+    public DateTimeFormatterBuilder appendWeekyear(final int minDigits, final int maxDigits) {\n         return appendNumeric\n             (iChronoUTC.weekyear(), minDigits, maxDigits);\n     }\n      *\n      * @param minDigits minumum number of digits to print\n      */\n-    public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\n+    public DateTimeFormatterBuilder appendMonthOfYear(final int minDigits) {\n         return appendNumeric(iChronoUTC.monthOfYear(), minDigits, 2);\n     }\n \n      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n      */\n-    public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\n+    public DateTimeFormatterBuilder appendYear(final int minDigits, final int maxDigits) {\n         return appendSignedNumeric(iChronoUTC.year(), minDigits, maxDigits);\n     }\n \n      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n      */\n-    public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {\n+    public DateTimeFormatterBuilder appendYearOfEra(final int minDigits, final int maxDigits) {\n         return appendNumeric(iChronoUTC.yearOfEra(), minDigits, maxDigits);\n     }\n \n      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n      */\n-    public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {\n+    public DateTimeFormatterBuilder appendYearOfCentury(final int minDigits, final int maxDigits) {\n         return appendNumeric(iChronoUTC.yearOfCentury(), minDigits, maxDigits);\n     }\n \n      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n      */\n-    public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) {\n+    public DateTimeFormatterBuilder appendCenturyOfEra(final int minDigits, final int maxDigits) {\n         return appendSignedNumeric(iChronoUTC.centuryOfEra(), minDigits, maxDigits);\n     }\n \n      * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction\n      * @param maxFields maximum number of fields to print\n      */\n-    public DateTimeFormatterBuilder appendTimeZoneOffset(String zeroOffsetText,\n-                                                         boolean showSeparators,\n-                                                         int minFields, int maxFields)\n-    {\n+    public DateTimeFormatterBuilder appendTimeZoneOffset(\n+            final String zeroOffsetText, final boolean showSeparators,\n+            final int minFields, final int maxFields) {\n         return append0(new TimeZoneOffsetFormatter\n                        (iChrono, zeroOffsetText, showSeparators, minFields, maxFields));\n-    }\n-\n-    /**\n-     * The pattern syntax is compatible with java.text.SimpleDateFormat, but a\n-     * few more symbols are also supported.\n-     * <p>\n-     * To specify the time format use a <em>time pattern</em> string.\n-     * In this pattern, all ASCII letters are reserved as pattern letters,\n-     * which are defined as the following:\n-     * <blockquote>\n-     * <pre>\n-     * Symbol  Meaning                      Presentation  Examples\n-     * ------  -------                      ------------  -------\n-     * G       era                          text          AD\n-     * C       century of era (&gt;=0)         number        20\n-     * Y       year of era (&gt;=0)            year          1996\n-     *\n-     * x       weekyear                     year          1996\n-     * w       week of weekyear             number        27\n-     * e       day of week                  number        2\n-     * E       day of week                  text          Tuesday; Tue\n-     *\n-     * y       year                         year          1996\n-     * D       day of year                  number        189\n-     * M       month of year                month         July; Jul; 07\n-     * d       day of month                 number        10\n-     *\n-     * a       halfday of day               text          PM\n-     * K       hour of halfday (0~11)       number        0\n-     * h       clockhour of halfday (1~12)  number        12\n-     *\n-     * H       hour of day (0~23)           number        0\n-     * k       clockhour of day (1~24)      number        24\n-     * m       minute of hour               number        30\n-     * s       second of minute             number        55\n-     * S       fraction of second           number        978\n-     *\n-     * z       time zone                    text          Pacific Standard Time; PST\n-     * Z       RFC 822 time zone            text          -0800; -08:00\n-     *\n-     * '       escape for text              delimiter\n-     * ''      single quote                 literal       '\n-     * </pre>\n-     * </blockquote>\n-     * The count of pattern letters determine the format.\n-     * <p>\n-     * <strong>Text</strong>: If the number of pattern letters is 4 or more,\n-     * the full form is used; otherwise a short or abbreviated form is used if\n-     * available.\n-     * <p>\n-     * <strong>Number</strong>: The minimum number of digits. Shorter numbers\n-     * are zero-padded to this amount.\n-     * <p>\n-     * <strong>Year</strong>: Numeric presentation for year and weekyear fields\n-     * are handled specially. For example, if the count of 'y' is 2, the year\n-     * will be displayed as the zero-based year of the century, which is two\n-     * digits.\n-     * <p>\n-     * <strong>Month</strong>: 3 or over, use text, otherwise use number.\n-     * <p>\n-     * Any characters in the pattern that are not in the ranges of ['a'..'z']\n-     * and ['A'..'Z'] will be treated as quoted text. For instance, characters\n-     * like ':', '.', ' ', '#' and '@' will appear in the resulting time text\n-     * even they are not embraced within single quotes.\n-     */\n-    public DateTimeFormatterBuilder appendPattern(String pattern)\n-        throws IllegalArgumentException\n-    {\n-        int length = pattern.length();\n-        int[] indexRef = new int[1];\n-\n-        for (int i=0; i<length; i++) {\n-            indexRef[0] = i;\n-            String token = parseToken(pattern, indexRef);\n-            i = indexRef[0];\n-\n-            int tokenLen = token.length();\n-            if (tokenLen == 0) {\n-                break;\n-            }\n-            char c = token.charAt(0);\n-\n-            switch (c) {\n-            case 'G': // era designator (text)\n-                appendEraText();\n-                break;\n-            case 'C': // century of era (number)\n-                appendCenturyOfEra(tokenLen, tokenLen);\n-                break;\n-            case 'x': // weekyear (number)\n-            case 'y': // year (number)\n-            case 'Y': // year of era (number)\n-                if (tokenLen == 2) {\n-                    // Use a new RemainderDateTimeField to ensure that the year\n-                    // of century is zero-based.\n-                    DateTimeField field;\n-                    switch (c) {\n-                    case 'x':\n-                        field = new RemainderDateTimeField(\"weekyearOfCentury\", iChronoUTC.weekyear(), 100);\n-                        break;\n-                    case 'y': default:\n-                        field = new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.year(), 100);\n-                        break;\n-                    case 'Y':\n-                        field = new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.yearOfEra(), 100);\n-                        break;\n-                    }\n-                    appendNumeric(field, 2, 2);\n-                } else {\n-                    // Try to support long year values.\n-                    int maxDigits = 9;\n-\n-                    // Peek ahead to next token.\n-                    if (i + 1 < length) {\n-                        indexRef[0]++;\n-                        if (isNumericToken(parseToken(pattern, indexRef))) {\n-                            // If next token is a number, cannot support long years.\n-                            maxDigits = tokenLen;\n-                        }\n-                        indexRef[0]--;\n-                    }\n-\n-                    switch (c) {\n-                    case 'x':\n-                        appendWeekyear(tokenLen, maxDigits);\n-                        break;\n-                    case 'y':\n-                        appendYear(tokenLen, maxDigits);\n-                        break;\n-                    case 'Y':\n-                        appendYearOfEra(tokenLen, maxDigits);\n-                        break;\n-                    }\n-                }\n-                break;\n-            case 'M': // month of year (text and number)\n-                if (tokenLen >= 3) {\n-                    if (tokenLen >= 4) {\n-                        appendMonthOfYearText();\n-                    } else {\n-                        appendMonthOfYearShortText();\n-                    }\n-                } else {\n-                    appendMonthOfYear(tokenLen);\n-                }\n-                break;\n-            case 'd': // day of month (number)\n-                appendDayOfMonth(tokenLen);\n-                break;\n-            case 'h': // hour of day (number, 1..12)\n-                appendClockhourOfHalfday(tokenLen);\n-                break;\n-            case 'H': // hour of day (number, 0..23)\n-                appendHourOfDay(tokenLen);\n-                break;\n-            case 'm': // minute of hour (number)\n-                appendMinuteOfHour(tokenLen);\n-                break;\n-            case 's': // second of minute (number)\n-                appendSecondOfMinute(tokenLen);\n-                break;\n-            case 'S': // fraction of second (number)\n-                appendFractionOfSecond(tokenLen, tokenLen);\n-                break;\n-            case 'e': // day of week (number)\n-                appendDayOfWeek(tokenLen);\n-                break;\n-            case 'E': // dayOfWeek (text)\n-                if (tokenLen >= 4) {\n-                    appendDayOfWeekText();\n-                } else {\n-                    appendDayOfWeekShortText();\n-                }\n-                break;\n-            case 'D': // day of year (number)\n-                appendDayOfYear(tokenLen);\n-                break;\n-            case 'w': // week of weekyear (number)\n-                appendWeekOfWeekyear(tokenLen);\n-                break;\n-            case 'a': // am/pm marker (text)\n-                appendHalfdayOfDayText();\n-                break;\n-            case 'k': // hour of day (1..24)\n-                appendClockhourOfDay(tokenLen);\n-                break;\n-            case 'K': // hour of day (0..11)\n-                appendClockhourOfHalfday(tokenLen);\n-                break;\n-            case 'z': // time zone (text)\n-                if (tokenLen >= 4) {\n-                    appendTimeZoneName();\n-                } else {\n-                    appendTimeZoneShortName();\n-                }\n-                break;\n-            case 'Z': // RFC 822 time zone\n-                if (tokenLen >= 4) {\n-                    appendTimeZoneOffset(null, true, 2, 2);\n-                } else {\n-                    appendTimeZoneOffset(null, false, 2, 2);\n-                }\n-                break;\n-            case '\\'': // literal text\n-                String sub = token.substring(1);\n-                if (sub.length() == 1) {\n-                    appendLiteral(sub.charAt(0));\n-                } else {\n-                    // Create copy of sub since otherwise the temporary quoted\n-                    // string would still be referenced internally.\n-                    appendLiteral(new String(sub));\n-                }\n-                break;\n-            default:\n-                throw new IllegalArgumentException\n-                    (\"Illegal pattern component: \" + token);\n-            }\n-        }\n-\n-        return this;\n-    }\n-\n-    // Returns true if token should be parsed as a numeric field.\n-    private boolean isNumericToken(String token) {\n-        int tokenLen = token.length();\n-        if (tokenLen > 0) {\n-            char c = token.charAt(0);\n-            switch (c) {\n-            case 'c': // century (number)\n-            case 'C': // century of era (number)\n-            case 'x': // weekyear (number)\n-            case 'y': // year (number)\n-            case 'Y': // year of era (number)\n-            case 'd': // day of month (number)\n-            case 'h': // hour of day (number, 1..12)\n-            case 'H': // hour of day (number, 0..23)\n-            case 'm': // minute of hour (number)\n-            case 's': // second of minute (number)\n-            case 'S': // fraction of second (number)\n-            case 'e': // day of week (number)\n-            case 'D': // day of year (number)\n-            case 'F': // day of week in month (number)\n-            case 'w': // week of year (number)\n-            case 'W': // week of month (number)\n-            case 'k': // hour of day (1..24)\n-            case 'K': // hour of day (0..11)\n-                return true;\n-            case 'M': // month of year (text and number)\n-                if (tokenLen <= 2) {\n-                    return true;\n-                }\n-            }\n-        }\n-            \n-        return false;\n     }\n \n     private Object getFormatter() {\n         return f;\n     }\n \n-    private boolean isPrinter(Object f) {\n+    private boolean isPrinter(final Object f) {\n         if (f instanceof DateTimePrinter) {\n             if (f instanceof Composite) {\n                 return ((Composite)f).isPrinter();\n         return false;\n     }\n \n-    private boolean isParser(Object f) {\n+    private boolean isParser(final Object f) {\n         if (f instanceof DateTimeParser) {\n             if (f instanceof Composite) {\n                 return ((Composite)f).isParser();\n         return false;\n     }\n \n-    private boolean isFormatter(Object f) {\n+    private boolean isFormatter(final Object f) {\n         if (f instanceof DateTimeFormatter) {\n             if (f instanceof Composite) {\n                 return ((Composite)f).isPrinter()\n         public Chronology getChronology() {\n             return iChrono;\n         }\n-\n-        protected final DateTimeZone getDateTimeZone() {\n-            DateTimeZone zone = iChrono.getDateTimeZone();\n-            return zone == null ? DateTimeZone.UTC : zone;\n-        }\n     }\n \n     private static class CharacterLiteral extends AbstractFormatter\n             return 1;\n         }\n \n-        public void printTo(StringBuffer buf, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) {\n+        public void printTo(StringBuffer buf, long instant,\n+                            DateTimeZone zone, long instantLocal) {\n             buf.append(iValue);\n         }\n \n-        public void printTo(Writer out, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) throws IOException {\n+        public void printTo(Writer out, long instant,\n+                            DateTimeZone zone, long instantLocal) throws IOException {\n             out.write(iValue);\n         }\n \n-        public String print(long millisUTC, DateTimeZone zone, long millisLocal) {\n+        public String print(long instant, DateTimeZone zone, long instantLocal) {\n             return String.valueOf(iValue);\n         }\n \n             return iValue.length();\n         }\n \n-        public void printTo(StringBuffer buf, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) {\n+        public void printTo(StringBuffer buf, long instant,\n+                            DateTimeZone zone, long instantLocal) {\n             buf.append(iValue);\n         }\n \n-        public void printTo(Writer out, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) throws IOException {\n+        public void printTo(Writer out, long instant,\n+                            DateTimeZone zone, long instantLocal) throws IOException {\n             out.write(iValue);\n         }\n \n-        public String print(long millisUTC, DateTimeZone zone, long millisLocal) {\n+        public String print(long instant, DateTimeZone zone, long instantLocal) {\n             return iValue;\n         }\n \n         protected final int iMaxParsedDigits;\n         protected final boolean iSigned;\n \n-        NumberFormatter(Chronology chrono,\n-                        DateTimeField field, int maxParsedDigits,\n-                        boolean signed) {\n+        NumberFormatter(\n+                Chronology chrono, DateTimeField field,\n+                int maxParsedDigits, boolean signed) {\n             super(chrono);\n             iField = field;\n             iMaxParsedDigits = maxParsedDigits;\n     }\n \n     private static class UnpaddedNumber extends NumberFormatter {\n-        UnpaddedNumber(Chronology chrono,\n-                       DateTimeField field, int maxParsedDigits,\n-                       boolean signed)\n+        UnpaddedNumber(Chronology chrono, DateTimeField field,\n+                       int maxParsedDigits, boolean signed)\n         {\n             super(chrono, field, maxParsedDigits, signed);\n         }\n             return iMaxParsedDigits;\n         }\n \n-        public void printTo(StringBuffer buf, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) {\n-            FormatUtils.appendUnpaddedInteger(buf, iField.get(millisLocal));\n-        }\n-\n-        public void printTo(Writer out, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) throws IOException {\n-            FormatUtils.writeUnpaddedInteger(out, iField.get(millisLocal));\n+        public void printTo(StringBuffer buf, long instant,\n+                            DateTimeZone zone, long instantLocal) {\n+            try {\n+                FormatUtils.appendUnpaddedInteger(buf, iField.get(instantLocal));\n+            } catch (RuntimeException e) {\n+                buf.append('\\ufffd');\n+            }\n+        }\n+\n+        public void printTo(Writer out, long instant,\n+                            DateTimeZone zone, long instantLocal) throws IOException {\n+            try {\n+                FormatUtils.writeUnpaddedInteger(out, iField.get(instantLocal));\n+            } catch (RuntimeException e) {\n+                out.write('\\ufffd');\n+            }\n         }\n     }\n \n             return iMaxParsedDigits;\n         }\n \n-        public void printTo(StringBuffer buf, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) {\n-            FormatUtils.appendPaddedInteger\n-                (buf, iField.get(millisLocal), iMinPrintedDigits);\n-        }\n-\n-        public void printTo(Writer out, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) throws IOException {\n-            FormatUtils.writePaddedInteger\n-                (out, iField.get(millisLocal), iMinPrintedDigits);\n+        public void printTo(StringBuffer buf, long instant,\n+                            DateTimeZone zone, long instantLocal) {\n+            try {\n+                FormatUtils.appendPaddedInteger\n+                    (buf, iField.get(instantLocal), iMinPrintedDigits);\n+            } catch (RuntimeException e) {\n+                for (int i=iMinPrintedDigits; --i>=0; ) {\n+                    buf.append('\\ufffd');\n+                }\n+            }\n+        }\n+\n+        public void printTo(Writer out, long instant,\n+                            DateTimeZone zone, long instantLocal) throws IOException {\n+            try {\n+                FormatUtils.writePaddedInteger\n+                    (out, iField.get(instantLocal), iMinPrintedDigits);\n+            } catch (RuntimeException e) {\n+                for (int i=iMinPrintedDigits; --i>=0; ) {\n+                    out.write('\\ufffd');\n+                }\n+            }\n         }\n     }\n \n         private final Locale iLocale;\n         private final boolean iShort;\n \n-        TextField(Chronology chrono,\n-                  DateTimeField field, Locale locale, boolean isShort) {\n+        TextField(Chronology chrono, DateTimeField field,\n+                  Locale locale, boolean isShort) {\n             super(chrono);\n             iField = field;\n             iLocale = locale;\n         }\n \n         public int estimatePrintedLength() {\n+            try {\n+                if (iShort) {\n+                    return iField.getMaximumShortTextLength(iLocale);\n+                } else {\n+                    return iField.getMaximumTextLength(iLocale);\n+                }\n+            } catch (RuntimeException e) {\n+                return 1;\n+            }\n+        }\n+\n+        public void printTo(StringBuffer buf, long instant,\n+                            DateTimeZone zone, long instantLocal) {\n+            try {\n+                buf.append(print(instant, zone, instantLocal));\n+            } catch (RuntimeException e) {\n+                buf.append('\\ufffd');\n+            }\n+        }\n+    \n+        public void printTo(Writer out, long instant,\n+                            DateTimeZone zone, long instantLocal) throws IOException {\n+            try {\n+                out.write(print(instant, zone, instantLocal));\n+            } catch (RuntimeException e) {\n+                out.write('\\ufffd');\n+            }\n+        }\n+\n+        public final String print(long instant, DateTimeZone zone, long instantLocal) {\n             if (iShort) {\n-                return iField.getMaximumShortTextLength(iLocale);\n+                return iField.getAsShortText(instantLocal, iLocale);\n             } else {\n-                return iField.getMaximumTextLength(iLocale);\n-            }\n-        }\n-\n-        public void printTo(StringBuffer buf, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) {\n-            buf.append(print(millisUTC, zone, millisLocal));\n-        }\n-    \n-        public void printTo(Writer out, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) throws IOException {\n-            out.write(print(millisUTC, zone, millisLocal));\n-        }\n-\n-        public final String print(long millisUTC, DateTimeZone zone, long millisLocal) {\n-            if (iShort) {\n-                return iField.getAsShortText(millisLocal, iLocale);\n-            } else {\n-                return iField.getAsText(millisLocal, iLocale);\n+                return iField.getAsText(instantLocal, iLocale);\n             }\n         }\n \n     private static class Fraction extends AbstractFormatter\n         implements DateTimeFormatter\n     {\n+        private final DateTimeField iField;\n+        private final long iRangeMillis;\n         private final int iMinDigits;\n         private final int iMaxDigits;\n-        private final int iRange;\n \n         private final long iScaler;\n \n-        private transient DateTimeField iField;\n-\n-        Fraction(Chronology chrono,\n-                 int minDigits, int maxDigits, int rangeInMillis) {\n+        private transient DateTimeField iParseField;\n+\n+        Fraction(Chronology chrono, DateTimeField field,\n+                 int minDigits, int maxDigits) {\n             super(chrono);\n+            iField = field;\n+            iRangeMillis = field.getDurationField().getUnitMillis();\n \n             // Limit the precision requirements.\n             if (maxDigits > 18) {\n             }\n \n             iMinDigits = minDigits;\n-            iRange = rangeInMillis;\n \n             long scaler;\n             while (true) {\n                 case 17: scaler = 100000000000000000L; break;\n                 case 18: scaler = 1000000000000000000L; break;\n                 }\n-                if (((rangeInMillis * scaler) / scaler) == rangeInMillis) {\n+                if (((iRangeMillis * scaler) / scaler) == iRangeMillis) {\n                     break;\n                 }\n                 // Overflowed: scale down.\n             return iMaxDigits;\n         }\n \n-        public void printTo(StringBuffer buf, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) {\n+        public void printTo(StringBuffer buf, long instant,\n+                            DateTimeZone zone, long instantLocal) {\n             try {\n-                printTo(buf, null, millisLocal);\n+                printTo(buf, null, instantLocal);\n             } catch (IOException e) {\n                 // Not gonna happen.\n             }\n         }\n \n-        public void printTo(Writer out, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) throws IOException {\n-            printTo(null, out, millisLocal);\n-        }\n-\n-        private void printTo(StringBuffer buf, Writer out, long millis)\n+        public void printTo(Writer out, long instant,\n+                            DateTimeZone zone, long instantLocal) throws IOException {\n+            printTo(null, out, instantLocal);\n+        }\n+\n+        private void printTo(StringBuffer buf, Writer out, long instantLocal)\n             throws IOException\n         {\n+            int minDigits = iMinDigits;\n+\n             long fraction;\n-            if (millis >= 0) {\n-                fraction = millis % iRange;\n-            } else {\n-                fraction = iRange - 1 + (millis + 1) % iRange;\n-            }\n-\n-            int minDigits = iMinDigits;\n+            try {\n+                fraction = iField.remainder(instantLocal);\n+            } catch (RuntimeException e) {\n+                if (buf != null) {\n+                    while (--minDigits >= 0) {\n+                        buf.append('\\ufffd');\n+                    }\n+                } else {\n+                    while (--minDigits >= 0) {\n+                        out.write('\\ufffd');\n+                    }\n+                }\n+                return;\n+            }\n \n             if (fraction == 0) {\n                 if (buf != null) {\n             }\n \n             String str;\n-            long scaled = fraction * iScaler / iRange;\n+            long scaled = fraction * iScaler / iRangeMillis;\n             if ((scaled & 0x7fffffff) == scaled) {\n                 str = Integer.toString((int)scaled);\n             } else {\n             int limit = Math.min(iMaxDigits, text.length() - position);\n \n             long value = 0;\n-            long n = iRange;\n+            long n = iRangeMillis;\n             int length = 0;\n             while (length < limit) {\n                 char c = text.charAt(position + length);\n                 return ~position;\n             }\n \n-            if (iField == null) {\n-                iField = new FractionalDateTimeField(\"\", 1, iRange);\n-            }\n-\n-            bucket.saveField(iField, (int)value);\n+            if (iParseField == null) {\n+                iParseField = new PreciseDateTimeField\n+                    (\"\", MillisDurationField.INSTANCE, iField.getDurationField());\n+            }\n+\n+            bucket.saveField(iParseField, (int)value);\n \n             return position + length;\n         }\n             return est;\n         }\n         \n-        public void printTo(StringBuffer buf, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) {\n-            int offset = (int)(millisLocal - millisUTC);\n+        public void printTo(StringBuffer buf, long instant,\n+                            DateTimeZone zone, long instantLocal) {\n+            int offset = (int)(instantLocal - instant);\n \n             if (offset == 0 && iZeroOffsetText != null) {\n                 buf.append(iZeroOffsetText);\n             FormatUtils.appendPaddedInteger(buf, offset, 3);\n         }\n         \n-        public void printTo(Writer out, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) throws IOException {\n-            int offset = (int)(millisLocal - millisUTC);\n+        public void printTo(Writer out, long instant,\n+                            DateTimeZone zone, long instantLocal) throws IOException {\n+            int offset = (int)(instantLocal - instant);\n \n             if (offset == 0 && iZeroOffsetText != null) {\n                 out.write(iZeroOffsetText);\n             return iShortFormat ? 4 : 20;\n         }\n         \n-        public void printTo(StringBuffer buf, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) {\n+        public void printTo(StringBuffer buf, long instant,\n+                            DateTimeZone zone, long instantLocal) {\n             if (zone == null) {\n                 zone = getDateTimeZone();\n             }\n             if (iShortFormat) {\n-                buf.append(zone.getShortName(millisUTC, this.iLocale));\n+                buf.append(zone.getShortName(instant, this.iLocale));\n             } else {\n-                buf.append(zone.getName(millisUTC, this.iLocale));\n+                buf.append(zone.getName(instant, this.iLocale));\n             }\n         }\n         \n-        public void printTo(Writer out, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) throws IOException {\n+        public void printTo(Writer out, long instant,\n+                            DateTimeZone zone, long instantLocal) throws IOException {\n             if (zone == null) {\n                 zone = getDateTimeZone();\n             }\n             if (iShortFormat) {\n-                out.write(zone.getShortName(millisUTC, this.iLocale));\n+                out.write(zone.getShortName(instant, this.iLocale));\n             } else {\n-                out.write(zone.getName(millisUTC, this.iLocale));\n-            }\n-        }\n-\n-        public String print(long millisUTC, DateTimeZone zone, long millisLocal) {\n+                out.write(zone.getName(instant, this.iLocale));\n+            }\n+        }\n+\n+        public String print(long instant, DateTimeZone zone, long instantLocal) {\n             if (zone == null) {\n                 zone = getDateTimeZone();\n             }\n             if (iShortFormat) {\n-                return zone.getShortName(millisUTC, this.iLocale);\n+                return zone.getShortName(instant, this.iLocale);\n             } else {\n-                return zone.getName(millisUTC, this.iLocale);\n+                return zone.getName(instant, this.iLocale);\n             }\n         }\n     }\n             return iPrintedLengthEstimate;\n         }\n     \n-        public void printTo(StringBuffer buf, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) {\n+        public void printTo(StringBuffer buf, long instant,\n+                            DateTimeZone zone, long instantLocal) {\n             DateTimePrinter[] elements = iPrinters;\n \n             if (elements == null) {\n \n             int len = elements.length;\n             for (int i=0; i<len; i++) {\n-                elements[i].printTo(buf, millisUTC, zone, millisLocal);\n-            }\n-        }\n-\n-        public void printTo(Writer out, long millisUTC,\n-                            DateTimeZone zone, long millisLocal) throws IOException {\n+                elements[i].printTo(buf, instant, zone, instantLocal);\n+            }\n+        }\n+\n+        public void printTo(Writer out, long instant,\n+                            DateTimeZone zone, long instantLocal) throws IOException {\n             DateTimePrinter[] elements = iPrinters;\n \n             if (elements == null) {\n \n             int len = elements.length;\n             for (int i=0; i<len; i++) {\n-                elements[i].printTo(out, millisUTC, zone, millisLocal);\n+                elements[i].printTo(out, instant, zone, instantLocal);\n             }\n         }\n \n--- a/JodaTime/src/java/org/joda/time/format/DateTimeParser.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParser.java\n  */\n package org.joda.time.format;\n \n-import java.text.ParseException;\n-\n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadableInstant;\n import org.joda.time.ReadWritableInstant;\n \n /**\n- * Converts sequences of human-readable characters into datetimes.\n+ * Defines an interface for parsing textual representations of datetimes.\n  *\n  * @author Brian S O'Neill\n  * @see DateTimeFormatter\n \n     /**\n      * Returns the Chronology being used by the parser, or null if none.\n+     * \n+     * @return the chronology in use, may be null if none\n      */\n     Chronology getChronology();\n \n     /**\n      * Returns the expected maximum number of characters consumed. The actual\n      * amount should rarely exceed this estimate.\n+     * \n+     * @return the estimated length\n      */\n     int estimateParsedLength();\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Parse an element from the given text, saving any fields into the given\n      * DateTimeParserBucket. If the parse succeeds, the return value is the new\n      * where the parse failed, apply the one's complement operator (~) on the\n      * return value.\n      *\n-     * @param bucket field are saved into this\n-     * @param text the text to parse\n-     * @param position position to start parsing from\n-     * @return new position, if negative, parse failed. Apply complement\n-     * operator (~) to get position of failure\n+     * @param bucket  field are saved into this\n+     * @param text  the text to parse\n+     * @param position  position to start parsing from\n+     * @return new position, negative value means parse failed -\n+     *  apply complement operator (~) to get position of failure\n      * @throws IllegalArgumentException if any field is out of range\n      */\n     int parseInto(DateTimeParserBucket bucket, String text, int position);\n      * modified. To determine the position where the parse failed, apply the\n      * one's complement operator (~) on the return value.\n      *\n-     * @param instant an instant that will be modified\n-     * @param text text to parse\n-     * @param position position to start parsing from\n-     * @return new position, if negative, parse failed. Apply complement\n-     * operator (~) to get position of failure\n+     * @param instant  an instant that will be modified\n+     * @param text  text to parse\n+     * @param position  position to start parsing from\n+     * @return new position, negative value means parse failed -\n+     *  apply complement operator (~) to get position of failure\n      * @throws IllegalArgumentException if any field is out of range\n      */\n     int parseInto(ReadWritableInstant instant, String text, int position);\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Parses a datetime from the given text, returning the number of\n      * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n      *\n-     * @param text text to parse\n+     * @param text  text to parse\n      * @return parsed value expressed in milliseconds since the epoch\n-     * @throws ParseException if any field is out of range\n+     * @throws IllegalArgumentException if the text to parse is invalid\n      */\n-    long parseMillis(String text) throws ParseException;\n+    long parseMillis(String text);\n \n     /**\n      * Parses a datetime from the given text, at the given position, returning\n-     * the number of milliseconds since the epoch, 1970-01-01T00:00:00Z. An\n-     * initial millisecond value is passed in, which is relative to the epoch,\n+     * the number of milliseconds since the epoch, 1970-01-01T00:00:00Z.\n+     * An initial millisecond value is passed in, which is relative to the epoch,\n      * local time.\n      *\n-     * @param text text to parse\n-     * @param millis initial value of millis, relative to the epoch, local time\n+     * @param text  text to parse\n+     * @param instantLocal  initial value of instant, relative to the epoch, local time\n      * @return parsed value expressed in milliseconds since the epoch, UTC\n-     * @throws ParseException if any field is out of range\n+     * @throws IllegalArgumentException if the text to parse is invalid\n      */\n-    long parseMillis(String text, long millis) throws ParseException;\n+    long parseMillis(String text, long instantLocal);\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Parses a datetime from the given text, returning a new DateTime.\n      *\n-     * @param text text to parse\n+     * @param text  text to parse\n      * @return parsed value in a DateTime object\n-     * @throws ParseException if any field is out of range\n+     * @throws IllegalArgumentException if the text to parse is invalid\n      */\n-    DateTime parseDateTime(String text) throws ParseException;\n+    DateTime parseDateTime(String text);\n+\n+    /**\n+     * Parses a datetime from the given text, returning a new DateTime, using\n+     * the given instant to supply field values that were not parsed.\n+     *\n+     * @param text  text to parse\n+     * @param instant  initial value of DateTime\n+     * @return parsed value in a DateTime object\n+     * @throws IllegalArgumentException if the text to parse is invalid\n+     */\n+    DateTime parseDateTime(String text, ReadableInstant instant);\n \n     /**\n      * Parses a datetime from the given text, returning a new MutableDateTime.\n      *\n-     * @param text text to parse\n-     * @return parsed value in a MutabkeDateTime object\n-     * @throws ParseException if any field is out of range\n+     * @param text  text to parse\n+     * @return parsed value in a MutableDateTime object\n+     * @throws IllegalArgumentException if the text to parse is invalid\n      */\n-    MutableDateTime parseMutableDateTime(String text) throws ParseException;\n+    MutableDateTime parseMutableDateTime(String text);\n+\n+    /**\n+     * Parses a datetime from the given text, returning a new MutableDateTime,\n+     * using the given instant to supply field values that were not parsed.\n+     *\n+     * @param text  text to parse\n+     * @param instant  initial value of DateTime\n+     * @return parsed value in a MutableDateTime object\n+     * @throws IllegalArgumentException if the text to parse is invalid\n+     */\n+    MutableDateTime parseMutableDateTime(String text, ReadableInstant instant);\n+    \n }\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java\n /**\n  * Allows fields to be saved in any order, but physically set in a consistent\n  * order.\n+ * <p>\n+ * DateTimeParserBucket is mutable and not thread-safe.\n  *\n  * @author Brian S O'Neill\n  */\n     ArrayList iSavedFields = new ArrayList();\n \n     /**\n-     * @param millis the initial millis from 1970-01-01T00:00:00, local time\n-     */\n-    public DateTimeParserBucket(long millis) {\n-        iMillis = millis;\n+     * @param instantLocal the initial millis from 1970-01-01T00:00:00, local time\n+     */\n+    public DateTimeParserBucket(long instantLocal) {\n+        iMillis = instantLocal;\n     }\n \n     /**\n      * Returns the time zone offset used by computeMillis, unless\n      * getDateTimeZone doesn't return null.\n      */\n-    public long getOffset() {\n+    public int getOffset() {\n         return iOffset;\n     }\n \n         }\n \n         /**\n-         * The field with the larger range is ordered first. If the ranges\n-         * match, then the field with the larger unit is ordered first. This\n-         * ordering gives preference to more precise fields. For example,\n-         * dayOfYear is chosen over monthOfYear.\n+         * The field with the larger range is ordered first, where null is\n+         * considered infinite. If the ranges match, then the field with the\n+         * larger unit is ordered first. This ordering casues \"smaller\" fields\n+         * to be set last, and thus their value sticks. For example, dayOfMonth\n+         * takes precedence over monthOfYear, and dayOfWeek takes precedence\n+         * over dayOfMonth.\n          */\n         public int compareTo(Object obj) {\n             DateTimeField other = ((SavedField)obj).iField;\n-            long a = iField.getRangeMillis();\n-            long b = other.getRangeMillis();\n-            if (a > b) {\n+            int result = compareReverse\n+                (iField.getRangeDurationField(), other.getRangeDurationField());\n+            if (result != 0) {\n+                return result;\n+            }\n+            return compareReverse\n+                (iField.getDurationField(), other.getDurationField());\n+        }\n+\n+        private int compareReverse(Comparable a, Comparable b) {\n+            if (a == null) {\n+                if (b == null) {\n+                    return 0;\n+                }\n                 return -1;\n-            } else if (a < b) {\n+            }\n+            if (b == null) {\n                 return 1;\n             }\n-            a = iField.getUnitMillis();\n-            b = other.getUnitMillis();\n-            if (a > b) {\n-                return -1;\n-            } else if (a < b) {\n-                return 1;\n-            }\n-            return 0;\n+            return -a.compareTo(b);\n         }\n     }\n \n--- a/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java\n import org.joda.time.ReadableInstant;\n \n /**\n- * Converts datetimes into a sequence of human-readable characters.\n+ * Defines an interface for creating textual representations of datetimes.\n  *\n  * @author Brian S O'Neill\n  * @see DateTimeFormatter\n     \n     /**\n      * Returns the Chronology being used by the printer, or null if none.\n+     * \n+     * @return the chronology in use, may be null if none\n      */\n     Chronology getChronology();\n \n     /**\n      * Returns the expected maximum number of characters produced. The actual\n      * amount should rarely exceed this estimate.\n+     * \n+     * @return the estimated length\n      */\n     int estimatePrintedLength();\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Prints a ReadableInstant, attempting to use the DateTimeZone supplied by\n      * the instant.\n      *\n-     * @param buf formatted instant is appended to this buffer\n-     * @param instant instant to format\n+     * @param buf  formatted instant is appended to this buffer\n+     * @param instant  instant to format\n      */\n     void printTo(StringBuffer buf, ReadableInstant instant);\n \n      * Prints a ReadableInstant, attempting to use the DateTimeZone supplied by\n      * the instant.\n      *\n-     * @param out formatted instant is written out\n-     * @param instant instant to format\n+     * @param out  formatted instant is written out\n+     * @param instant  instant to format\n      */\n     void printTo(Writer out, ReadableInstant instant) throws IOException;\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n      * using the formatter's DateTimeZone.\n      *\n-     * @param buf formatted instant is appended to this buffer\n-     * @param millisUTC millis since 1970-01-01T00:00:00Z\n-     */\n-    void printTo(StringBuffer buf, long millisUTC);\n+     * @param buf  formatted instant is appended to this buffer\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     */\n+    void printTo(StringBuffer buf, long instant);\n \n     /**\n      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n      * using the formatter's DateTimeZone.\n      *\n-     * @param out formatted instant is written out\n-     * @param millisUTC millis since 1970-01-01T00:00:00Z\n-     */\n-    void printTo(Writer out, long millisUTC) throws IOException;\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * attempting to use the given DateTimeZone.\n-     *\n-     * @param buf formatted instant is appended to this buffer\n-     * @param millisUTC millis since 1970-01-01T00:00:00Z\n-     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n-     * not null\n-     */\n-    void printTo(StringBuffer buf, long millisUTC, DateTimeZone zone);\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * attempting to use the given DateTimeZone.\n-     *\n-     * @param out formatted instant is written out\n-     * @param millisUTC millis since 1970-01-01T00:00:00Z\n-     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n-     * not null\n-     */\n-    void printTo(Writer out, long millisUTC, DateTimeZone zone) throws IOException;\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * attempting to use the given DateTimeZone.\n-     *\n-     * @param buf formatted instant is appended to this buffer\n-     * @param millisUTC millis since 1970-01-01T00:00:00Z, used by time zone\n-     * printers\n-     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n-     * not null\n-     * @param millisLocal pre-calculated millis since 1970-01-01T00:00:00,\n-     * local time\n-     */\n-    void printTo(StringBuffer buf, long millisUTC,\n-                 DateTimeZone zone, long millisLocal);\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * attempting to use the given DateTimeZone.\n-     *\n-     * @param out formatted instant is written out\n-     * @param millisUTC millis since 1970-01-01T00:00:00Z, used by time zone\n-     * printers\n-     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n-     * not null\n-     * @param millisLocal pre-calculated millis since 1970-01-01T00:00:00,\n-     * local time\n-     */\n-    void printTo(Writer out, long millisUTC,\n-                 DateTimeZone zone, long millisLocal) throws IOException;\n-\n+     * @param out  formatted instant is written out\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     */\n+    void printTo(Writer out, long instant) throws IOException;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * attempting to use the given DateTimeZone.\n+     *\n+     * @param buf  formatted instant is appended to this buffer\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     * @param zone  DateTimeZone to use, overriding the formatter's own zone if not null\n+     */\n+    void printTo(StringBuffer buf, long instant, DateTimeZone zone);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * attempting to use the given DateTimeZone.\n+     *\n+     * @param out  formatted instant is written out\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     * @param zone  DateTimeZone to use, overriding the formatter's own zone if not null\n+     */\n+    void printTo(Writer out, long instant, DateTimeZone zone) throws IOException;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * attempting to use the given DateTimeZone.\n+     *\n+     * @param buf  formatted instant is appended to this buffer\n+     * @param instant  millis since 1970-01-01T00:00:00Z, used by time zone printers\n+     * @param zone  DateTimeZone to use, overriding the formatter's own zone if not null\n+     * @param instantLocal  pre-calculated millis since 1970-01-01T00:00:00, local time\n+     */\n+    void printTo(StringBuffer buf, long instant,\n+                 DateTimeZone zone, long instantLocal);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * attempting to use the given DateTimeZone.\n+     *\n+     * @param out  formatted instant is written out\n+     * @param instant millis  since 1970-01-01T00:00:00Z, used by time zone printers\n+     * @param zone  DateTimeZone to use, overriding the formatter's own zone if not null\n+     * @param instantLocal  pre-calculated millis since 1970-01-01T00:00:00, local time\n+     */\n+    void printTo(Writer out, long instant,\n+                 DateTimeZone zone, long instantLocal) throws IOException;\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Prints a ReadableInstant to a new String, attempting to use the\n      * DateTimeZone supplied by the instant.\n      *\n-     * @param instant instant to format\n+     * @param instant  instant to format\n      * @return the printed result\n      */\n     String print(ReadableInstant instant);\n      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n      * using the formatter's DateTimeZone.\n      *\n-     * @param millisUTC millis since 1970-01-01T00:00:00Z\n-     * @return the printed result\n-     */\n-    String print(long millisUTC);\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * attempting to use the given DateTimeZone.\n-     *\n-     * @param millisUTC millis since 1970-01-01T00:00:00Z\n-     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n-     * not null\n-     * @return the printed result\n-     */\n-    String print(long millisUTC, DateTimeZone zone);\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * attempting to use the given DateTimeZone.\n-     *\n-     * @param millisUTC millis since 1970-01-01T00:00:00Z\n-     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n-     * not null\n-     * @param millisLocal pre-calculated millis since 1970-01-01T00:00:00,\n-     * local time\n-     * @return the printed result\n-     */\n-    String print(long millisUTC, DateTimeZone zone, long millisLocal);\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     * @return the printed result\n+     */\n+    String print(long instant);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * attempting to use the given DateTimeZone.\n+     *\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     * @param zone  DateTimeZone to use, overriding the formatter's own zone if not null\n+     * @return the printed result\n+     */\n+    String print(long instant, DateTimeZone zone);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * attempting to use the given DateTimeZone.\n+     *\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     * @param zone  DateTimeZone to use, overriding the formatter's own zone if not null\n+     * @param instantLocal  pre-calculated millis since 1970-01-01T00:00:00, local time\n+     * @return the printed result\n+     */\n+    String print(long instant, DateTimeZone zone, long instantLocal);\n+    \n }\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/DurationFieldAffix.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Defines a formatted field's prefix or suffix text.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public interface DurationFieldAffix {\n+    int calculatePrintedLength(int value);\n+\n+    void printTo(StringBuffer buf, int value);\n+\n+    void printTo(Writer out, int value) throws IOException;\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/DurationFormatter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+/**\n+ * Combined interface for printing and parsing.\n+ * <p>\n+ * See each extended interface for details of the methods.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface DurationFormatter extends DurationPrinter, DurationParser {\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.joda.time.DurationField;\n+import org.joda.time.DurationType;\n+import org.joda.time.ReadableDuration;\n+\n+/**\n+ * \n+ *\n+ * @author Brian S O'Neill\n+ */\n+public class DurationFormatterBuilder {\n+    private static final int PRINT_ZERO_NEVER = 0;\n+    private static final int PRINT_ZERO_MAYBE = 1;\n+    private static final int PRINT_ZERO_ALWAYS = 2;\n+\n+    private int iMinPrintedDigits = 1;\n+    private int iPrintZeroSetting;\n+\n+    private DurationFieldAffix iPrefix;\n+\n+    // List of separate DurationFormatters.\n+    private List iFormatters;\n+\n+    public DurationFormatterBuilder() {\n+       iFormatters = new ArrayList();\n+    }\n+\n+    /**\n+     * Converts to a DurationPrinter that prints using all the appended\n+     * elements. Subsequent changes to this builder do not affect the returned\n+     * printer.\n+     */\n+    public DurationPrinter toPrinter() {\n+        return toPrinter(iFormatters);\n+    }\n+\n+    /**\n+     * Converts to a DurationPrinter that prints using all the appended\n+     * elements. Subsequent changes to this builder do not affect the returned\n+     * printer.\n+     *\n+     * @param alternate alternate text to print when printer emits no fields\n+     */\n+    public DurationPrinter toPrinter(String alternate) {\n+        DurationPrinter printer = toPrinter();\n+        if (alternate != null) {\n+            return new AlternateSelector(printer, new Literal(alternate));\n+        }\n+        return printer;\n+    }\n+\n+    /**\n+     * Converts to a DurationPrinter that prints using all the appended\n+     * elements. Subsequent changes to this builder do not affect the returned\n+     * printer.\n+     *\n+     * @param alternate alternate printer to use when printer emits no fields\n+     */\n+    public DurationPrinter toPrinter(DurationPrinter alternate) {\n+        DurationPrinter printer = toPrinter();\n+        if (alternate != null) {\n+            return new AlternateSelector(printer, alternate);\n+        }\n+        return printer;\n+    }\n+\n+    private static DurationPrinter toPrinter(List formatters) {\n+        int size = formatters.size();\n+        if (size >= 2 && formatters.get(1) instanceof Separator) {\n+            DurationPrinter before = (DurationPrinter) formatters.get(0);\n+            if (size == 2) {\n+                // Separator at the end would never print anything.\n+                return before;\n+            }\n+            return ((Separator) formatters.get(1)).finish\n+                (before, toPrinter(formatters.subList(2, size)));\n+        }\n+        return createComposite(formatters);\n+    }\n+\n+    /**\n+     * Depending on what rules are applied, a parser may not be buildable due\n+     * to ambiguities that may arise during parsing.\n+     */\n+    /*\n+    public boolean canBuildParser() {\n+        // TODO\n+        return true;\n+    }\n+    */\n+\n+    /**\n+     * Clears out all the appended elements, allowing this builder to be\n+     * reused.\n+     */\n+    public void clear() {\n+        iMinPrintedDigits = 1;\n+        iPrintZeroSetting = PRINT_ZERO_NEVER;\n+        iPrefix = null;\n+        iFormatters.clear();\n+    }\n+\n+    /**\n+     * Appends just a printer. With no matching parser, a parser cannot be\n+     * built from this DurationFormatterBuilder.\n+     */\n+    public DurationFormatterBuilder append(DurationPrinter printer)\n+        throws IllegalArgumentException\n+    {\n+        if (printer == null) {\n+            throw new IllegalArgumentException(\"No printer supplied\");\n+        }\n+        clearPrefix();\n+        iFormatters.add(printer);\n+        return this;\n+    }\n+\n+    /**\n+     * Instructs the printer to emit specific text, and the parser to expect\n+     * it. The parser is case-insensitive.\n+     *\n+     * @throws IllegalArgumentException if text is null\n+     */\n+    public DurationFormatterBuilder appendLiteral(String text) {\n+        if (text == null) {\n+            throw new IllegalArgumentException(\"Literal must not be null\");\n+        }\n+        clearPrefix();\n+        iFormatters.add(new Literal(text));\n+        return this;\n+    }\n+\n+    /**\n+     * Set the minimum digits printed for the next and following appended\n+     * fields. By default, the minimum digits printed is one. If the field value\n+     * is zero, it is not printed unless a printZero rule is applied.\n+     */\n+    public DurationFormatterBuilder minimumPrintedDigits(int minDigits) {\n+        iMinPrintedDigits = minDigits;\n+        return this;\n+    }\n+\n+    /**\n+     * Set the maximum digits parsed for the next and following appended\n+     * fields. By default, the maximum digits parsed is ten.\n+     */\n+    public DurationFormatterBuilder maximumParsedDigits(int maxDigits) {\n+        // TODO\n+        return this;\n+    }\n+\n+    /**\n+     * Reject signed values when parsing the next and following appended fields.\n+     */\n+    public DurationFormatterBuilder rejectSignedValues() {\n+        // TODO\n+        return this;\n+    }\n+\n+    /**\n+     * Never print zero values for the next and following appended fields. This\n+     * is the default setting.\n+     */\n+    public DurationFormatterBuilder printZeroNever() {\n+        iPrintZeroSetting = PRINT_ZERO_NEVER;\n+        return this;\n+    }\n+\n+    /**\n+     * Print zero values for the next and following appened fields only if the\n+     * duration supports it.\n+     */\n+    public DurationFormatterBuilder printZeroMaybe() {\n+        iPrintZeroSetting = PRINT_ZERO_MAYBE;\n+        return this;\n+    }\n+\n+    /**\n+     * Always print zero values for the next and following appended fields,\n+     * even if the duration doesn't support it.\n+     */\n+    public DurationFormatterBuilder printZeroAlways() {\n+        iPrintZeroSetting = PRINT_ZERO_ALWAYS;\n+        return this;\n+    }\n+\n+    /**\n+     * Append a field prefix which applies only to the next appended field. If\n+     * the field is not printed, neither is the prefix.\n+     *\n+     * @param text text to print before field only if field is printed\n+     * @see #appendSuffix\n+     */\n+    public DurationFormatterBuilder appendPrefix(String text) {\n+        if (text == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        return appendPrefix(new SingularAffix(text));\n+    }\n+\n+    /**\n+     * Append a field prefix which applies only to the next appended field. If\n+     * the field is not printed, neither is the prefix.\n+     * <p>\n+     * During parsing, the singular and plural versions are accepted whether\n+     * or not the actual value matches plurality.\n+     *\n+     * @param singularText text to print if field value is one\n+     * @param pluralText text to print if field value is not one\n+     * @see #appendSuffix\n+     */\n+    public DurationFormatterBuilder appendPrefix(String singularText,\n+                                                 String pluralText) {\n+        if (singularText == null || pluralText == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        return appendPrefix(new PluralAffix(singularText, pluralText));\n+    }\n+\n+    /**\n+     * Append a field prefix which applies only to the next appended field. If\n+     * the field is not printed, neither is the prefix.\n+     *\n+     * @param prefix custom prefix\n+     * @see #appendSuffix\n+     */\n+    public DurationFormatterBuilder appendPrefix(DurationFieldAffix prefix) {\n+        if (prefix == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (iPrefix != null) {\n+            prefix = new CompositeAffix(iPrefix, prefix);\n+        }\n+        iPrefix = prefix;\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit a numeric years field, if supported.\n+     */\n+    public DurationFormatterBuilder appendYears() {\n+        appendField(1);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit a numeric years field, if supported.\n+     */\n+    public DurationFormatterBuilder appendMonths() {\n+        appendField(2);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit a numeric weeks field, if supported.\n+     */\n+    public DurationFormatterBuilder appendWeeks() {\n+        appendField(3);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit a numeric days field, if supported.\n+     */\n+    public DurationFormatterBuilder appendDays() {\n+        appendField(4);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit a numeric hours field, if supported.\n+     */\n+    public DurationFormatterBuilder appendHours() {\n+        appendField(5);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit a numeric minutes field, if supported.\n+     */\n+    public DurationFormatterBuilder appendMinutes() {\n+        appendField(6);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit a numeric seconds field, if supported.\n+     */\n+    public DurationFormatterBuilder appendSeconds() {\n+        appendField(7);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit a numeric millis field, if supported.\n+     */\n+    public DurationFormatterBuilder appendMillis() {\n+        appendField(8);\n+        return this;\n+    }\n+\n+    private void appendField(int type) {\n+        iFormatters.add(new FieldFormatter(iMinPrintedDigits, iPrintZeroSetting,\n+                                           type, iPrefix, null));\n+        iPrefix = null;\n+    }\n+\n+    /**\n+     * Append a field suffix which applies only to the last appended field. If\n+     * the field is not printed, neither is the suffix.\n+     *\n+     * @param text text to print after field only if field is printed\n+     * @throws IllegalStateException if no field exists to append to\n+     * @see #appendPrefix\n+     */\n+    public DurationFormatterBuilder appendSuffix(String text) {\n+        if (text == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        return appendSuffix(new SingularAffix(text));\n+    }\n+\n+    /**\n+     * Append a field suffix which applies only to the last appended field. If\n+     * the field is not printed, neither is the suffix.\n+     * <p>\n+     * During parsing, the singular and plural versions are accepted whether or\n+     * not the actual value matches plurality.\n+     *\n+     * @param singularText text to print if field value is one\n+     * @param pluralText text to print if field value is not one\n+     * @throws IllegalStateException if no field exists to append to\n+     * @see #appendPrefix\n+     */\n+    public DurationFormatterBuilder appendSuffix(String singularText,\n+                                                 String pluralText) {\n+        if (singularText == null || pluralText == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        return appendSuffix(new PluralAffix(singularText, pluralText));\n+    }\n+\n+    /**\n+     * Append a field suffix which applies only to the last appended field. If\n+     * the field is not printed, neither is the suffix.\n+     *\n+     * @param suffix custom suffix\n+     * @throws IllegalStateException if no field exists to append to\n+     * @see #appendPrefix\n+     */\n+    public DurationFormatterBuilder appendSuffix(DurationFieldAffix suffix) {\n+        Object f = null;\n+        if (iFormatters.size() > 0) {\n+            f = iFormatters.get(iFormatters.size() - 1);\n+        }\n+        if (!(f instanceof FieldFormatter)) {\n+            throw new IllegalStateException(\"No field to apply suffix to\");\n+        }\n+        clearPrefix();\n+        f = new FieldFormatter((FieldFormatter) f, suffix);\n+        iFormatters.set(iFormatters.size() - 1, f);\n+        return this;\n+    }\n+\n+    /**\n+     * During printing, separators are only printed if fields are printed\n+     * following the latest one.\n+     * <p>\n+     * Note: appending a separator discontinues any further work on the latest\n+     * appended field.\n+     */\n+    public DurationFormatterBuilder appendSeparator(String text) {\n+        return appendSeparator(text, text);\n+    }\n+\n+    /**\n+     * During printing, separators are only printed if fields are printed\n+     * following the latest one.\n+     * <p>\n+     * During parsing, either text parameter is accepted, and is\n+     * case-insensitive.\n+     * <p>\n+     * Note: appending a separator discontinues any further work on the latest\n+     * appended field.\n+     *\n+     * @param finalText alternate used if this is the final separator\n+     * printed\n+     */\n+    public DurationFormatterBuilder appendSeparator(String text,\n+                                                    String finalText) {\n+        if (text == null || finalText == null) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        clearPrefix();\n+\n+        List formatters = iFormatters;\n+\n+        if (formatters.size() == 0) {\n+            // Separator at the beginning would never print anything.\n+            return this;\n+        }\n+\n+        // Create a composite over all the fields between separators.\n+        int i;\n+        Separator lastSeparator = null;\n+        for (i=formatters.size(); --i>=0; ) {\n+            if (formatters.get(i) instanceof Separator) {\n+                lastSeparator = (Separator) formatters.get(i);\n+                formatters = formatters.subList(i + 1, formatters.size());\n+                break;\n+            }\n+        }\n+\n+        if (lastSeparator != null && formatters.size() == 0) {\n+            // Merge two adjacent separators together.\n+            iFormatters.set(i, lastSeparator.merge(text, finalText));\n+        } else {\n+            DurationPrinter composite = createComposite(formatters);\n+            formatters.clear();\n+            formatters.add(composite);\n+            \n+            // The separator will be finished later.\n+            formatters.add(new Separator(text, finalText));\n+        }\n+            \n+        return this;\n+    }\n+\n+    private void clearPrefix() throws IllegalStateException {\n+        if (iPrefix != null) {\n+            throw new IllegalStateException(\"Prefix not followed by field\");\n+        }\n+        iPrefix = null;\n+    }\n+\n+    private static DurationPrinter createComposite(List formatters) {\n+        if (formatters.size() == 1) {\n+            return (DurationPrinter)formatters.get(0);\n+        } else {\n+            return new Composite(formatters);\n+        }\n+    }\n+\n+    private static final class SingularAffix implements DurationFieldAffix {\n+        private final String iText;\n+\n+        SingularAffix(String text) {\n+            iText = text;\n+        }\n+\n+        public int calculatePrintedLength(int value) {\n+            return iText.length();\n+        }\n+\n+        public void printTo(StringBuffer buf, int value) {\n+            buf.append(iText);\n+        }\n+\n+        public void printTo(Writer out, int value) throws IOException {\n+            out.write(iText);\n+        }\n+    }\n+\n+    private static final class PluralAffix implements DurationFieldAffix {\n+        private final String iSingularText;\n+        private final String iPluralText;\n+\n+        PluralAffix(String singularText, String pluralText) {\n+            iSingularText = singularText;\n+            iPluralText = pluralText;\n+        }\n+\n+        public int calculatePrintedLength(int value) {\n+            return (value == 1 ? iSingularText : iPluralText).length();\n+        }\n+\n+        public void printTo(StringBuffer buf, int value) {\n+            buf.append(value == 1 ? iSingularText : iPluralText);\n+        }\n+\n+        public void printTo(Writer out, int value) throws IOException {\n+            out.write(value == 1 ? iSingularText : iPluralText);\n+        }\n+    }\n+\n+    private static final class CompositeAffix implements DurationFieldAffix {\n+        private final DurationFieldAffix iLeft;\n+        private final DurationFieldAffix iRight;\n+\n+        CompositeAffix(DurationFieldAffix left, DurationFieldAffix right) {\n+            iLeft = left;\n+            iRight = right;\n+        }\n+\n+        public int calculatePrintedLength(int value) {\n+            return iLeft.calculatePrintedLength(value)\n+                + iRight.calculatePrintedLength(value);\n+        }\n+\n+        public void printTo(StringBuffer buf, int value) {\n+            iLeft.printTo(buf, value);\n+            iRight.printTo(buf, value);\n+        }\n+\n+        public void printTo(Writer out, int value) throws IOException {\n+            iLeft.printTo(out, value);\n+            iRight.printTo(out, value);\n+        }\n+    }\n+\n+    private static final class FieldFormatter extends AbstractDurationFormatter\n+        implements DurationPrinter\n+    {\n+        private final int iMinPrintedDigits;\n+        private final int iPrintZeroSetting;\n+\n+        private final int iFieldType;\n+\n+        private final DurationFieldAffix iPrefix;\n+        private final DurationFieldAffix iSuffix;\n+\n+        FieldFormatter(int minPrintedDigits, int printZeroSetting,\n+                       int fieldType, DurationFieldAffix prefix, DurationFieldAffix suffix) {\n+            iMinPrintedDigits = minPrintedDigits;\n+            iPrintZeroSetting = printZeroSetting;\n+            iFieldType = fieldType;\n+            iPrefix = prefix;\n+            iSuffix = suffix;\n+        }\n+\n+        FieldFormatter(FieldFormatter field, DurationFieldAffix suffix) {\n+            iMinPrintedDigits = field.iMinPrintedDigits;\n+            iPrintZeroSetting = field.iPrintZeroSetting;\n+            iFieldType = field.iFieldType;\n+            iPrefix = field.iPrefix;\n+            if (field.iSuffix != null) {\n+                suffix = new CompositeAffix(field.iSuffix, suffix);\n+            }\n+            iSuffix = suffix;\n+        }\n+\n+        public int countFieldsToPrint(ReadableDuration duration) {\n+            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(duration) >= 0) {\n+                return 1;\n+            }\n+            return 0;\n+        }\n+\n+        public int countFieldsToPrint(ReadableDuration duration, int stopAt) {\n+            return stopAt <= 0 ? 0 : countFieldsToPrint(duration);\n+        }\n+\n+        public int calculatePrintedLength(ReadableDuration duration) {\n+            long valueLong = getFieldValue(duration);\n+            if (valueLong < 0) {\n+                return 0;\n+            }\n+\n+            int value = (int)valueLong;\n+\n+            int sum = Math.max\n+                (FormatUtils.calculateDigitCount(value), iMinPrintedDigits);\n+            if (value < 0) {\n+                // Account for sign character\n+                sum++;\n+            }\n+\n+            DurationFieldAffix affix;\n+            if ((affix = iPrefix) != null) {\n+                sum += affix.calculatePrintedLength(value);\n+            }\n+            if ((affix = iSuffix) != null) {\n+                sum += affix.calculatePrintedLength(value);\n+            }\n+\n+            return sum;\n+        }\n+        \n+        public void printTo(StringBuffer buf, ReadableDuration duration) {\n+            long valueLong = getFieldValue(duration);\n+            if (valueLong < 0) {\n+                return;\n+            }\n+            int value = (int)valueLong;\n+\n+            DurationFieldAffix affix;\n+            if ((affix = iPrefix) != null) {\n+                affix.printTo(buf, value);\n+            }\n+            int minDigits = iMinPrintedDigits;\n+            if (minDigits <= 1) {\n+                FormatUtils.appendUnpaddedInteger(buf, value);\n+            } else {\n+                FormatUtils.appendPaddedInteger(buf, value, minDigits);\n+            }\n+            if ((affix = iSuffix) != null) {\n+                affix.printTo(buf, value);\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadableDuration duration) throws IOException {\n+            long valueLong = getFieldValue(duration);\n+            if (valueLong < 0) {\n+                return;\n+            }\n+            int value = (int)valueLong;\n+\n+            DurationFieldAffix affix;\n+            if ((affix = iPrefix) != null) {\n+                affix.printTo(out, value);\n+            }\n+            int minDigits = iMinPrintedDigits;\n+            if (minDigits <= 1) {\n+                FormatUtils.writeUnpaddedInteger(out, value);\n+            } else {\n+                FormatUtils.writePaddedInteger(out, value, minDigits);\n+            }\n+            if ((affix = iSuffix) != null) {\n+                affix.printTo(out, value);\n+            }\n+        }\n+\n+        /**\n+         * @return negative value if nothing to print, otherwise lower 32 bits\n+         * is signed int value.\n+         */\n+        long getFieldValue(ReadableDuration duration) {\n+            DurationType type;\n+            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n+                type = null; // Don't need to check if supported.\n+            } else {\n+                type = duration.getDurationType();\n+            }\n+\n+            int value;\n+\n+            switch (iFieldType) {\n+            default:\n+                return -1;\n+            case 1:\n+                if (type != null && type.years().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = duration.getYears();\n+                break;\n+            case 2:\n+                if (type != null && type.months().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = duration.getMonths();\n+                break;\n+            case 3:\n+                if (type != null && type.weeks().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = duration.getWeeks();\n+                break;\n+            case 4:\n+                if (type != null && type.days().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = duration.getDays();\n+                break;\n+            case 5:\n+                if (type != null && type.hours().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = duration.getHours();\n+                break;\n+            case 6:\n+                if (type != null && type.minutes().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = duration.getMinutes();\n+                break;\n+            case 7:\n+                if (type != null && type.seconds().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = duration.getSeconds();\n+                break;\n+            case 8:\n+                if (type != null && type.millis().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = duration.getMillis();\n+                break;\n+            }\n+\n+            if (value == 0 && iPrintZeroSetting == PRINT_ZERO_NEVER) {\n+                return -1;\n+            }\n+\n+            return value & 0xffffffffL;\n+        }\n+    }\n+\n+    private static final class Literal extends AbstractDurationFormatter\n+        implements DurationPrinter\n+    {\n+        private final String iText;\n+\n+        Literal(String text) {\n+            iText = text;\n+        }\n+\n+        public int countFieldsToPrint(ReadableDuration duration, int stopAt) {\n+            return 0;\n+        }\n+\n+        public int calculatePrintedLength(ReadableDuration duration) {\n+            return iText.length();\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadableDuration duration) {\n+            buf.append(iText);\n+        }\n+\n+        public void printTo(Writer out, ReadableDuration duration) throws IOException {\n+            out.write(iText);\n+        }\n+    }\n+\n+    private static final class Separator extends AbstractDurationFormatter\n+        implements DurationPrinter\n+    {\n+        private final String iText;\n+        private final String iFinalText;\n+\n+        private final DurationPrinter iBefore;\n+        private final DurationPrinter iAfter;\n+\n+        Separator(String text, String finalText) {\n+            this(text, finalText, null, null);\n+        }\n+\n+        Separator(String text, String finalText,\n+                  DurationPrinter before, DurationPrinter after) {\n+            iText = text;\n+            iFinalText = finalText;\n+            iBefore = before;\n+            iAfter = after;\n+        }\n+\n+        public int countFieldsToPrint(ReadableDuration duration, int stopAt) {\n+            int sum = iBefore.countFieldsToPrint(duration, stopAt);\n+            if (sum < stopAt) {\n+                sum += iAfter.countFieldsToPrint(duration, stopAt);\n+            }\n+            return sum;\n+        }\n+\n+        public int calculatePrintedLength(ReadableDuration duration) {\n+            int sum = iBefore.calculatePrintedLength(duration)\n+                + iAfter.calculatePrintedLength(duration);\n+\n+            if (iBefore.countFieldsToPrint(duration, 1) > 0) {\n+                int afterCount = iAfter.countFieldsToPrint(duration, 2);\n+                if (afterCount > 0) {\n+                    sum += (afterCount > 1 ? iText : iFinalText).length();\n+                }\n+            }\n+\n+            return sum;\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadableDuration duration) {\n+            DurationPrinter before = iBefore;\n+            DurationPrinter after = iAfter;\n+\n+            before.printTo(buf, duration);\n+\n+            if (before.countFieldsToPrint(duration, 1) > 0) {\n+                int afterCount = after.countFieldsToPrint(duration, 2);\n+                if (afterCount > 0) {\n+                    buf.append(afterCount > 1 ? iText : iFinalText);\n+                }\n+            }\n+\n+            after.printTo(buf, duration);\n+        }\n+\n+        public void printTo(Writer out, ReadableDuration duration) throws IOException {\n+            DurationPrinter before = iBefore;\n+            DurationPrinter after = iAfter;\n+\n+            before.printTo(out, duration);\n+\n+            if (before.countFieldsToPrint(duration, 1) > 0) {\n+                int afterCount = after.countFieldsToPrint(duration, 2);\n+                if (afterCount > 0) {\n+                    out.write(afterCount > 1 ? iText : iFinalText);\n+                }\n+            }\n+\n+            after.printTo(out, duration);\n+        }\n+\n+        Separator merge(String text, String finalText) {\n+            return new Separator(iText + text, iFinalText + finalText, iBefore, iAfter);\n+        }\n+\n+        Separator finish(DurationPrinter before, DurationPrinter after) {\n+            return new Separator(iText, iFinalText, before, after);\n+        }\n+    }\n+\n+    private static final class Composite extends AbstractDurationFormatter\n+        implements DurationPrinter\n+    {\n+        private final DurationPrinter[] iFormatters;\n+\n+        Composite(List formatters) {\n+            iFormatters = (DurationPrinter[])formatters.toArray\n+                (new DurationPrinter[formatters.size()]);\n+        }\n+\n+        public int countFieldsToPrint(ReadableDuration duration, int stopAt) {\n+            int sum = 0;\n+            DurationPrinter[] printers = iFormatters;\n+            for (int i=printers.length; sum < stopAt && --i>=0; ) {\n+                sum += printers[i].countFieldsToPrint(duration);\n+            }\n+            return sum;\n+        }\n+\n+        public int calculatePrintedLength(ReadableDuration duration) {\n+            int sum = 0;\n+            DurationPrinter[] printers = iFormatters;\n+            for (int i=printers.length; --i>=0; ) {\n+                sum += printers[i].calculatePrintedLength(duration);\n+            }\n+            return sum;\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadableDuration duration) {\n+            DurationPrinter[] printers = iFormatters;\n+            int len = printers.length;\n+            for (int i=0; i<len; i++) {\n+                printers[i].printTo(buf, duration);\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadableDuration duration) throws IOException {\n+            DurationPrinter[] printers = iFormatters;\n+            int len = printers.length;\n+            for (int i=0; i<len; i++) {\n+                printers[i].printTo(out, duration);\n+            }\n+        }\n+    }\n+\n+    private static final class AlternateSelector extends AbstractDurationFormatter\n+        implements DurationPrinter\n+    {\n+        private final DurationPrinter iPrimary;\n+        private final DurationPrinter iAlternate;\n+\n+        AlternateSelector(DurationPrinter primary, DurationPrinter alternate) {\n+            iPrimary = primary;\n+            iAlternate = alternate;\n+        }\n+\n+        public int countFieldsToPrint(ReadableDuration duration, int stopAt) {\n+            int count = iPrimary.countFieldsToPrint(duration, stopAt);\n+            if (count <= 0) {\n+                count = iAlternate.countFieldsToPrint(duration, stopAt);\n+            }\n+            return count;\n+        }\n+\n+        public int calculatePrintedLength(ReadableDuration duration) {\n+            if (iPrimary.countFieldsToPrint(duration, 1) > 0) {\n+                return iPrimary.calculatePrintedLength(duration);\n+            } else {\n+                return iAlternate.calculatePrintedLength(duration);\n+            }\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadableDuration duration) {\n+            if (iPrimary.countFieldsToPrint(duration, 1) > 0) {\n+                iPrimary.printTo(buf, duration);\n+            } else {\n+                iAlternate.printTo(buf, duration);\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadableDuration duration) throws IOException {\n+            if (iPrimary.countFieldsToPrint(duration, 1) > 0) {\n+                iPrimary.printTo(out, duration);\n+            } else {\n+                iAlternate.printTo(out, duration);\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/DurationParser.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import org.joda.time.Duration;\n+import org.joda.time.DurationType;\n+import org.joda.time.MutableDuration;\n+import org.joda.time.ReadWritableDuration;\n+\n+/**\n+ * Converts sequences of human-readable characters into durations.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public interface DurationParser {\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Parses a duration from the given text, at the given position, saving the\n+     * result into the fields of the given ReadWritableDuration. If the parse\n+     * succeeds, the return value is the new text position. Note that the parse\n+     * may succeed without fully reading the text.\n+     * <p>\n+     * If it fails, the return value is negative, but the duration may still be\n+     * modified. To determine the position where the parse failed, apply the\n+     * one's complement operator (~) on the return value.\n+     *\n+     * @param duration  a duration that will be modified\n+     * @param durationStr  text to parse\n+     * @param position position to start parsing from\n+     * @return new position, if negative, parse failed. Apply complement\n+     * operator (~) to get position of failure\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    int parseInto(ReadWritableDuration duration, String durationStr, int position);\n+\n+    /**\n+     * Parses a duration from the given text, returning a new Duration.\n+     *\n+     * @param type  defines which fields may be parsed\n+     * @param durationStr  text to parse\n+     * @return parsed value in a Duration object\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    Duration parseDuration(DurationType type, String durationStr);\n+\n+    /**\n+     * Parses a duration from the given text, returning a new MutableDuration.\n+     *\n+     * @param type  defines which fields may be parsed\n+     * @param durationStr  text to parse\n+     * @return parsed value in a MutableDuration object\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    MutableDuration parseMutableDuration(DurationType type, String durationStr);\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/DurationPrinter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import org.joda.time.ReadableDuration;\n+\n+/**\n+ * Converts durations into a sequence of human-readable characters.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public interface DurationPrinter {\n+\n+    /**\n+     * Returns the amount of fields from the given duration that this printer\n+     * will print.\n+     * \n+     * @param duration duration to use\n+     * @return amount of fields printed\n+     */\n+    int countFieldsToPrint(ReadableDuration duration);\n+\n+    /**\n+     * Returns the amount of fields from the given duration that this printer\n+     * will print.\n+     * \n+     * @param duration duration to use\n+     * @param stopAt stop counting at this value\n+     * @return amount of fields printed\n+     */\n+    int countFieldsToPrint(ReadableDuration duration, int stopAt);\n+\n+    /**\n+     * Returns the exact number of characters produced for the given duration.\n+     * \n+     * @param duration duration to use\n+     * @return the estimated length\n+     */\n+    int calculatePrintedLength(ReadableDuration duration);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints a ReadableDuration to a StringBuffer.\n+     *\n+     * @param buf  the formatted duration is appended to this buffer\n+     * @param duration  duration to format\n+     */\n+    void printTo(StringBuffer buf, ReadableDuration duration);\n+\n+    /**\n+     * Prints a ReadableDuration to a Writer.\n+     *\n+     * @param out  the formatted duration is written out\n+     * @param duration  duration to format\n+     */\n+    void printTo(Writer out, ReadableDuration duration) throws IOException;\n+\n+    /**\n+     * Prints a ReadableDuration to a new String.\n+     *\n+     * @param duration  duration to format\n+     * @return the printed result\n+     */\n+    String print(ReadableDuration duration);\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/format/FormatUtils.java\n+++ b/JodaTime/src/java/org/joda/time/format/FormatUtils.java\n \n /**\n  * Utility methods used by formatters.\n+ * <p>\n+ * FormatUtils is thread-safe and immutable.\n  *\n  * @author Brian S O'Neill\n  */\n-public class FormatUtils {\n-    private static final double LOG_10 = Math.log(10);\n+// Note: Use strictfp and StrictMath to ensure consistent results on all VMs.\n+public strictfp class FormatUtils {\n+    private static final double LOG_10 = StrictMath.log(10);\n \n     private FormatUtils() {\n     }\n             } else if (value < 10000) {\n                 digits = 4;\n             } else {\n-                digits = (int)(Math.log(value) / LOG_10) + 1;\n+                digits = (int)(StrictMath.log(value) / LOG_10) + 1;\n             }\n             for (; size > digits; size--) {\n                 buf.append('0');\n                     return;\n                 }\n             }\n-            int digits = (int)(Math.log(value) / LOG_10) + 1;\n+            int digits = (int)(StrictMath.log(value) / LOG_10) + 1;\n             for (; size > digits; size--) {\n                 buf.append('0');\n             }\n             } else if (value < 10000) {\n                 digits = 4;\n             } else {\n-                digits = (int)(Math.log(value) / LOG_10) + 1;\n+                digits = (int)(StrictMath.log(value) / LOG_10) + 1;\n             }\n             for (; size > digits; size--) {\n                 out.write('0');\n                     return;\n                 }\n             }\n-            int digits = (int)(Math.log(value) / LOG_10) + 1;\n+            int digits = (int)(StrictMath.log(value) / LOG_10) + 1;\n             for (; size > digits; size--) {\n                 out.write('0');\n             }\n         }\n     }\n \n+    /**\n+     * Calculates the number of decimal digits for the given value, ignoring\n+     * sign.\n+     */\n+    public static int calculateDigitCount(int value) {\n+        if (value < 0) {\n+            if (value != Integer.MIN_VALUE) {\n+                value = -value;\n+            } else {\n+                return 10;\n+            }\n+        }\n+        return \n+            (value < 10 ? 1 :\n+             (value < 100 ? 2 :\n+              (value < 1000 ? 3 :\n+               (value < 10000 ? 4 :\n+                ((int)(StrictMath.log(value) / LOG_10) + 1)))));\n+    }\n+\n     static int parseTwoDigits(String text, int position) {\n         int value = text.charAt(position) - '0';\n         return ((value << 3) + (value << 1)) + text.charAt(position + 1) - '0';\n--- a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java\n import org.joda.time.chrono.iso.ISOChronology;\n \n /**\n- * Factory methods for many ISO8601 formats (the ISO standard is a framework\n- * for outputting data, but not an absolute standard). The most common formats\n- * are date, time, and dateTime.\n- * \n+ * ISODateTimeFormat provides factory methods for the ISO8601 standard.\n+ * <p>\n+ * ISO8601 is the international standard for data interchange. It defines a\n+ * framework, rather than an absolute standard. As a result this provider has a\n+ * number of methods that represent common uses of the framework. The most common\n+ * formats are {@link #date() date}, {@link #time() time}, and {@link #dateTime() dateTime}.\n+ * <p>\n+ * For example, to format a date time in ISO format:\n+ * <pre>\n+ * DateTime dt = new DateTime();\n+ * DateTimeFormatter fmt = DateTimeFormat.getInstance().dateTime();\n+ * String str = fmt.print(dt);\n+ * </pre>\n+ * <p>\n+ * ISODateTimeFormat is thread-safe and immutable, and the formatters it\n+ * returns are as well.\n+ *\n  * @author Brian S O'Neill\n+ * @since 1.0\n  * @see DateTimeFormat\n  * @see DateTimeFormatterBuilder\n  */\n public class ISODateTimeFormat {\n \n-    // Maps Chronology instances to instances.\n+    /**\n+     * Cache that maps Chronology instances to instances.\n+     */\n     private static Map cCache = new HashMap(7);\n \n+    /**\n+     * Gets an instance of a format provider that uses the ISOChronology in UTC.\n+     * \n+     * @return a format provider\n+     */\n     public static ISODateTimeFormat getInstanceUTC() {\n         return getInstance(ISOChronology.getInstanceUTC());\n     }\n \n+    /**\n+     * Gets an instance of a format provider that uses the ISOChronology\n+     * in the default time zone.\n+     * \n+     * @return a format provider\n+     */\n     public static ISODateTimeFormat getInstance() {\n         return getInstance(ISOChronology.getInstance());\n     }\n \n-    public static ISODateTimeFormat getInstance(DateTimeZone zone) {\n+    /**\n+     * Gets an instance of a format provider that uses the ISOChronology\n+     * in the specified time zone.\n+     * \n+     * @return a format provider\n+     */\n+    public static ISODateTimeFormat getInstance(final DateTimeZone zone) {\n         return getInstance(ISOChronology.getInstance(zone));\n     }\n \n     /**\n-     * @param chrono Chronology to use\n+     * Gets an instance of a format provider that uses the specified chronology.\n+     * \n+     * @param chrono  the chronology to use, null means default chronology\n+     * @return a format provider\n      */\n     public static synchronized ISODateTimeFormat getInstance(Chronology chrono) {\n         if (chrono == null) {\n-            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+            chrono = ISOChronology.getInstance();\n         }\n         ISODateTimeFormat instance = (ISODateTimeFormat)cCache.get(chrono);\n         if (instance == null) {\n         return instance;\n     }\n \n+    //-----------------------------------------------------------------------\n     private final Chronology iChrono;\n \n     private transient DateTimeFormatter\n         tp, // time parser\n         dtp; // date time parser\n \n-    private ISODateTimeFormat(Chronology chrono) {\n+    /**\n+     * Restricted constructor.\n+     * \n+     * @param chrono  the chronology to use, must not be null\n+     */\n+    private ISODateTimeFormat(final Chronology chrono) {\n         iChrono = chrono;\n     }\n \n-    /**\n-     * Returns a generic ISO date parser that accepts formats described by\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a generic ISO date parser. It accepts formats described by\n      * the following syntax:\n      * <pre>\n      * date         = date-element ['T' offset]\n     }\n \n     /**\n-     * Returns a generic ISO date parser that accepts formats described by\n+     * Returns a generic ISO date parser. It accepts formats described by\n      * the following syntax:\n      * <pre>\n      * date-element = yyyy ['-' MM ['-' dd]]\n     }\n \n     /**\n-     * Returns a generic ISO time parser that accepts formats described by\n+     * Returns a generic ISO time parser. It accepts formats described by\n      * the following syntax:\n      * <pre>\n      * time         = ['T'] time-element [offset]\n     }\n \n     /**\n-     * Returns a generic ISO time parser that accepts formats described by\n+     * Returns a generic ISO time parser. It accepts formats described by\n      * the following syntax:\n      * <pre>\n      * time-element = HH [':' mm [':' ss ['.' SSS]]]\n     }\n \n     /**\n-     * Returns a generic ISO datetime parser that accepts formats described by\n+     * Returns a generic ISO datetime parser. It accepts formats described by\n      * the following syntax:\n      * <pre>\n      * datetime     = time | (date-element [time | ('T' offset)])\n         return dtp;\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Returns a formatter for a full date as four digit year, two digit month\n      * of year, and two digit day of month. (yyyy-MM-dd)\n         return dt;\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Returns a basic formatter for a full date as four digit year, two digit\n      * month of year, and two digit day of month. (yyyyMMdd)\n     public DateTimeFormatter basicDate() {\n         if (bd == null) {\n             bd = new DateTimeFormatterBuilder(iChrono)\n-                .appendPattern(\"yyyyMMdd\")\n+                .appendYear(4, 4)\n+                .appendMonthOfYear(2)\n+                .appendDayOfMonth(2)\n                 .toFormatter();\n         }\n         return bd;\n     public DateTimeFormatter basicTime() {\n         if (bt == null) {\n             bt = new DateTimeFormatterBuilder(iChrono)\n-                .appendPattern(\"HHmmss\")\n+                .appendHourOfDay(2)\n+                .appendMinuteOfHour(2)\n+                .appendSecondOfMinute(2)\n                 .appendTimeZoneOffset(\"\", false, 1, 2)\n                 .toFormatter();\n         }\n         return bdt;\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Returns a formatter for a four digit year. (yyyy)\n      */\n         return dhmsf;\n     }\n \n+    //-----------------------------------------------------------------------\n     private DateTimeFormatter yearElement() {\n         if (ye == null) {\n             ye = new DateTimeFormatterBuilder(iChrono)\n--- a/JodaTime/src/java/org/joda/time/tz/CachedDateTimeZone.java\n+++ b/JodaTime/src/java/org/joda/time/tz/CachedDateTimeZone.java\n  * Improves the performance of requesting time zone offsets and name keys by\n  * caching the results. Time zones that have simple rules or are fixed should\n  * not be cached, as it is unlikely to improve performance.\n+ * <p>\n+ * CachedDateTimeZone is thread-safe and immutable.\n  * \n  * @author Brian S O'Neill\n  */\n     private static final int cInfoCacheMask;\n \n     static {\n-        Integer i = Integer.getInteger(\"org.joda.time.tz.CachedDateTimeZone.size\");\n-\n-        // With a cache size of 512, dates that lie within any 69.7 year period\n-        // have no cache collisions.\n-        int cacheSize = (i == null) ? 512 : i.intValue();\n-\n-        // Ensure cache size is even power of 2.\n-        cacheSize--;\n-        int shift = 0;\n-        while (cacheSize > 0) {\n-            shift++;\n-            cacheSize >>= 1;\n-        }\n-        cacheSize = 1 << shift;\n+        Integer i;\n+        try {\n+            i = Integer.getInteger(\"org.joda.time.tz.CachedDateTimeZone.size\");\n+        } catch (SecurityException e) {\n+            i = null;\n+        }\n+\n+        int cacheSize;\n+        if (i == null) {\n+            // With a cache size of 512, dates that lie within any 69.7 year\n+            // period have no cache collisions.\n+            cacheSize = 512; // (1 << 9)\n+        } else {\n+            cacheSize = i.intValue();\n+            // Ensure cache size is even power of 2.\n+            cacheSize--;\n+            int shift = 0;\n+            while (cacheSize > 0) {\n+                shift++;\n+                cacheSize >>= 1;\n+            }\n+            cacheSize = 1 << shift;\n+        }\n \n         cInfoCacheMask = cacheSize - 1;\n     }\n         return iZone;\n     }\n \n-    public String getNameKey(long millis) {\n-        return getInfo(millis).getNameKey(millis);\n-    }\n-\n-    public int getOffset(long millis) {\n-        return getInfo(millis).getOffset(millis);\n-    }\n-\n-    public int getStandardOffset(long millis) {\n-        return getInfo(millis).getStandardOffset(millis);\n-    }\n-\n-    public long nextTransition(long millis) {\n-        return iZone.nextTransition(millis);\n-    }\n-\n-    public long previousTransition(long millis) {\n-        return iZone.previousTransition(millis);\n+    public String getNameKey(long instant) {\n+        return getInfo(instant).getNameKey(instant);\n+    }\n+\n+    public int getOffset(long instant) {\n+        return getInfo(instant).getOffset(instant);\n+    }\n+\n+    public int getStandardOffset(long instant) {\n+        return getInfo(instant).getStandardOffset(instant);\n+    }\n+\n+    public boolean isFixed() {\n+        return iZone.isFixed();\n+    }\n+\n+    public long nextTransition(long instant) {\n+        return iZone.nextTransition(instant);\n+    }\n+\n+    public long previousTransition(long instant) {\n+        return iZone.previousTransition(instant);\n     }\n \n     public int hashCode() {\n--- a/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java\n  * creating a new DateTimeZone this way is a relatively expensive operation,\n  * built zones can be written to a file. Reading back the encoded data is a\n  * quick operation.\n+ * <p>\n+ * DateTimeZoneBuilder itself is mutable and not thread-safe, but the\n+ * DateTimeZone objects that it builds are thread-safe and immutable.\n  *\n  * @author Brian S O'Neill\n  * @see ZoneInfoCompiler\n         /**\n          * @param standardOffset standard offset just before next recurrence\n          */\n-        public long next(long millis, int standardOffset, int saveMillis) {\n+        public long next(long instant, int standardOffset, int saveMillis) {\n             int offset;\n             if (iMode == 'w') {\n                 offset = standardOffset + saveMillis;\n             }\n \n             // Convert from UTC to local time.\n-            millis += offset;\n+            instant += offset;\n \n             Chronology chrono = ISOChronology.getInstanceUTC();\n-            long next = chrono.monthOfYear().set(millis, iMonthOfYear);\n-            next = chrono.millisOfDay().set(next, iMillisOfDay);\n+            long next = chrono.monthOfYear().set(instant, iMonthOfYear);\n+            // Be lenient with millisOfDay.\n+            next = chrono.millisOfDay().set(next, 0);\n+            next = chrono.millisOfDay().add(next, iMillisOfDay);\n             next = setDayOfMonthNext(chrono, next);\n \n             if (iDayOfWeek == 0) {\n-                if (next <= millis) {\n+                if (next <= instant) {\n                     next = chrono.year().add(next, 1);\n                     next = setDayOfMonthNext(chrono, next);\n                 }\n             } else {\n                 next = setDayOfWeek(chrono, next);\n-                if (next <= millis) {\n+                if (next <= instant) {\n                     next = chrono.year().add(next, 1);\n                     next = chrono.monthOfYear().set(next, iMonthOfYear);\n                     next = setDayOfMonthNext(chrono, next);\n         /**\n          * @param standardOffset standard offset just before previous recurrence\n          */\n-        public long previous(long millis, int standardOffset, int saveMillis) {\n+        public long previous(long instant, int standardOffset, int saveMillis) {\n             int offset;\n             if (iMode == 'w') {\n                 offset = standardOffset + saveMillis;\n             }\n \n             // Convert from UTC to local time.\n-            millis += offset;\n+            instant += offset;\n \n             Chronology chrono = ISOChronology.getInstanceUTC();\n-            long prev = chrono.monthOfYear().set(millis, iMonthOfYear);\n-            prev = chrono.millisOfDay().set(prev, iMillisOfDay);\n+            long prev = chrono.monthOfYear().set(instant, iMonthOfYear);\n+            // Be lenient with millisOfDay.\n+            prev = chrono.millisOfDay().set(prev, 0);\n+            prev = chrono.millisOfDay().add(prev, iMillisOfDay);\n             prev = setDayOfMonthPrevious(chrono, prev);\n \n             if (iDayOfWeek == 0) {\n-                if (prev >= millis) {\n+                if (prev >= instant) {\n                     prev = chrono.year().add(prev, -1);\n                     prev = setDayOfMonthPrevious(chrono, prev);\n                 }\n             } else {\n                 prev = setDayOfWeek(chrono, prev);\n-                if (prev >= millis) {\n+                if (prev >= instant) {\n                     prev = chrono.year().add(prev, -1);\n                     prev = chrono.monthOfYear().set(prev, iMonthOfYear);\n                     prev = setDayOfMonthPrevious(chrono, prev);\n             return prev;\n         }\n \n-        private long setDayOfMonth(Chronology chrono, long millis) {\n+        private long setDayOfMonth(Chronology chrono, long instant) {\n             if (iDayOfMonth >= 0) {\n-                millis = chrono.dayOfMonth().set(millis, iDayOfMonth);\n+                instant = chrono.dayOfMonth().set(instant, iDayOfMonth);\n             } else {\n-                millis = chrono.dayOfMonth().set(millis, 1);\n-                millis = chrono.monthOfYear().add(millis, 1);\n-                millis = chrono.dayOfMonth().add(millis, iDayOfMonth);\n-            }\n-            return millis;\n-        }\n-\n-        private long setDayOfWeek(Chronology chrono, long millis) {\n-            int dayOfWeek = chrono.dayOfWeek().get(millis);\n+                instant = chrono.dayOfMonth().set(instant, 1);\n+                instant = chrono.monthOfYear().add(instant, 1);\n+                instant = chrono.dayOfMonth().add(instant, iDayOfMonth);\n+            }\n+            return instant;\n+        }\n+\n+        private long setDayOfWeek(Chronology chrono, long instant) {\n+            int dayOfWeek = chrono.dayOfWeek().get(instant);\n             int daysToAdd = iDayOfWeek - dayOfWeek;\n             if (daysToAdd != 0) {\n                 if (iAdvance) {\n                         daysToAdd -= 7;\n                     }\n                 }\n-                millis = chrono.dayOfWeek().add(millis, daysToAdd);\n-            }\n-            return millis;\n+                instant = chrono.dayOfWeek().add(instant, daysToAdd);\n+            }\n+            return instant;\n         }\n     }\n \n         /**\n          * @param standardOffset standard offset just before next recurrence\n          */\n-        public long next(long millis, int standardOffset, int saveMillis) {\n-            return iOfYear.next(millis, standardOffset, saveMillis);\n+        public long next(long instant, int standardOffset, int saveMillis) {\n+            return iOfYear.next(instant, standardOffset, saveMillis);\n         }\n \n         /**\n          * @param standardOffset standard offset just before previous recurrence\n          */\n-        public long previous(long millis, int standardOffset, int saveMillis) {\n-            return iOfYear.previous(millis, standardOffset, saveMillis);\n+        public long previous(long instant, int standardOffset, int saveMillis) {\n+            return iOfYear.previous(instant, standardOffset, saveMillis);\n         }\n \n         public String getNameKey() {\n             return iRecurrence.getSaveMillis();\n         }\n \n-        public long next(final long millis, int standardOffset, int saveMillis) {\n+        public long next(final long instant, int standardOffset, int saveMillis) {\n             Chronology chrono = ISOChronology.getInstanceUTC();\n \n             final int wallOffset = standardOffset + saveMillis;\n-            long testMillis = millis;\n+            long testInstant = instant;\n \n             int year;\n-            if (millis == Long.MIN_VALUE) {\n+            if (instant == Long.MIN_VALUE) {\n                 year = Integer.MIN_VALUE;\n             } else {\n-                year = chrono.year().get(millis + wallOffset);\n+                year = chrono.year().get(instant + wallOffset);\n             }\n \n             if (year < iFromYear) {\n-                // First advance millis to start of from year.\n-                testMillis = chrono.year().set(0, iFromYear) - wallOffset;\n+                // First advance instant to start of from year.\n+                testInstant = chrono.year().set(0, iFromYear) - wallOffset;\n                 // Back off one millisecond to account for next recurrence\n                 // being exactly at the beginning of the year.\n-                testMillis -= 1;\n-            }\n-\n-            long next = iRecurrence.next(testMillis, standardOffset, saveMillis);\n-\n-            if (next > millis) {\n+                testInstant -= 1;\n+            }\n+\n+            long next = iRecurrence.next(testInstant, standardOffset, saveMillis);\n+\n+            if (next > instant) {\n                 year = chrono.year().get(next + wallOffset);\n                 if (year > iToYear) {\n                     // Out of range, return original value.\n-                    next = millis;\n+                    next = instant;\n                 }\n             }\n \n          *\n          * @param saveMillis savings before next transition\n          */\n-        public Transition nextTransition(final long millis, final int saveMillis) {\n+        public Transition nextTransition(final long instant, final int saveMillis) {\n             Chronology chrono = ISOChronology.getInstanceUTC();\n \n             // Find next matching rule.\n             Iterator it = iRules.iterator();\n             while (it.hasNext()) {\n                 Rule rule = (Rule)it.next();\n-                long next = rule.next(millis, iStandardOffset, saveMillis);\n-                if (next <= millis) {\n+                long next = rule.next(instant, iStandardOffset, saveMillis);\n+                if (next <= instant) {\n                     it.remove();\n                     continue;\n                 }\n             iEndRecurrence = endRecurrence;\n         }\n \n-        public String getNameKey(long millis) {\n-            return findMatchingRecurrence(millis).getNameKey();\n-        }\n-\n-        public int getOffset(long millis) {\n-            return iStandardOffset + findMatchingRecurrence(millis).getSaveMillis();\n-        }\n-\n-        public int getStandardOffset(long millis) {\n+        public String getNameKey(long instant) {\n+            return findMatchingRecurrence(instant).getNameKey();\n+        }\n+\n+        public int getOffset(long instant) {\n+            return iStandardOffset + findMatchingRecurrence(instant).getSaveMillis();\n+        }\n+\n+        public int getStandardOffset(long instant) {\n             return iStandardOffset;\n         }\n \n-        public long nextTransition(long millis) {\n+        public boolean isFixed() {\n+            return false;\n+        }\n+\n+        public long nextTransition(long instant) {\n             int standardOffset = iStandardOffset;\n             Recurrence startRecurrence = iStartRecurrence;\n             Recurrence endRecurrence = iEndRecurrence;\n \n-            long start = startRecurrence.next\n-                (millis, standardOffset, endRecurrence.getSaveMillis());\n-            long end = endRecurrence.next\n-                (millis, standardOffset, startRecurrence.getSaveMillis());\n+            long start, end;\n+\n+            try {\n+                start = startRecurrence.next\n+                    (instant, standardOffset, endRecurrence.getSaveMillis());\n+            } catch (IllegalArgumentException e) {\n+                // Overflowed.\n+                start = instant;\n+            }\n+\n+            try {\n+                end = endRecurrence.next\n+                    (instant, standardOffset, startRecurrence.getSaveMillis());\n+            } catch (IllegalArgumentException e) {\n+                // Overflowed.\n+                end = instant;\n+            }\n \n             return (start > end) ? end : start;\n         }\n \n-        public long previousTransition(long millis) {\n-            // Increment in order to handle the case where millis is exactly at\n+        public long previousTransition(long instant) {\n+            // Increment in order to handle the case where instant is exactly at\n             // a transition.\n-            millis++;\n+            instant++;\n \n             int standardOffset = iStandardOffset;\n             Recurrence startRecurrence = iStartRecurrence;\n             Recurrence endRecurrence = iEndRecurrence;\n \n-            long start = startRecurrence.previous\n-                (millis, standardOffset, endRecurrence.getSaveMillis());\n-            long end = endRecurrence.previous\n-                (millis, standardOffset, startRecurrence.getSaveMillis());\n+            long start, end;\n+\n+            try {\n+                start = startRecurrence.previous\n+                    (instant, standardOffset, endRecurrence.getSaveMillis());\n+            } catch (IllegalArgumentException e) {\n+                // Overflowed.\n+                start = instant;\n+            }\n+\n+            try {\n+                end = endRecurrence.previous\n+                    (instant, standardOffset, startRecurrence.getSaveMillis());\n+            } catch (IllegalArgumentException e) {\n+                // Overflowed.\n+                end = instant;\n+            }\n \n             return ((start > end) ? start : end) - 1;\n         }\n             iEndRecurrence.writeTo(out);\n         }\n \n-        private Recurrence findMatchingRecurrence(long millis) {\n+        private Recurrence findMatchingRecurrence(long instant) {\n             int standardOffset = iStandardOffset;\n             Recurrence startRecurrence = iStartRecurrence;\n             Recurrence endRecurrence = iEndRecurrence;\n \n-            long start = startRecurrence.next\n-                (millis, standardOffset, endRecurrence.getSaveMillis());\n-            long end = endRecurrence.next\n-                (millis, standardOffset, startRecurrence.getSaveMillis());\n+            long start, end;\n+\n+            try {\n+                start = startRecurrence.next\n+                    (instant, standardOffset, endRecurrence.getSaveMillis());\n+            } catch (IllegalArgumentException e) {\n+                // Overflowed.\n+                start = instant;\n+            }\n+\n+            try {\n+                end = endRecurrence.next\n+                    (instant, standardOffset, startRecurrence.getSaveMillis());\n+            } catch (IllegalArgumentException e) {\n+                // Overflowed.\n+                end = instant;\n+            }\n \n             return (start > end) ? startRecurrence : endRecurrence;\n         }\n             iTailZone = tailZone;\n         }\n \n-        public String getNameKey(long millis) {\n+        public String getNameKey(long instant) {\n             long[] transitions = iTransitions;\n-            int i = Arrays.binarySearch(transitions, millis);\n+            int i = Arrays.binarySearch(transitions, instant);\n             if (i >= 0) {\n                 return iNameKeys[i];\n             }\n             if (iTailZone == null) {\n                 return iNameKeys[i - 1];\n             }\n-            return iTailZone.getNameKey(millis);\n-        }\n-\n-        public int getOffset(long millis) {\n+            return iTailZone.getNameKey(instant);\n+        }\n+\n+        public int getOffset(long instant) {\n             long[] transitions = iTransitions;\n-            int i = Arrays.binarySearch(transitions, millis);\n+            int i = Arrays.binarySearch(transitions, instant);\n             if (i >= 0) {\n                 return iWallOffsets[i];\n             }\n             if (iTailZone == null) {\n                 return iWallOffsets[i - 1];\n             }\n-            return iTailZone.getOffset(millis);\n-        }\n-\n-        public int getStandardOffset(long millis) {\n+            return iTailZone.getOffset(instant);\n+        }\n+\n+        public int getStandardOffset(long instant) {\n             long[] transitions = iTransitions;\n-            int i = Arrays.binarySearch(transitions, millis);\n+            int i = Arrays.binarySearch(transitions, instant);\n             if (i >= 0) {\n                 return iStandardOffsets[i];\n             }\n             if (iTailZone == null) {\n                 return iStandardOffsets[i - 1];\n             }\n-            return iTailZone.getStandardOffset(millis);\n-        }\n-\n-        public long nextTransition(long millis) {\n+            return iTailZone.getStandardOffset(instant);\n+        }\n+\n+        public boolean isFixed() {\n+            return false;\n+        }\n+\n+        public long nextTransition(long instant) {\n             long[] transitions = iTransitions;\n-            int i = Arrays.binarySearch(transitions, millis);\n+            int i = Arrays.binarySearch(transitions, instant);\n             i = (i >= 0) ? (i + 1) : ~i;\n             if (i < transitions.length) {\n                 return transitions[i];\n             }\n             if (iTailZone == null) {\n-                return millis;\n+                return instant;\n             }\n             long end = transitions[transitions.length - 1];\n-            if (millis < end) {\n-                millis = end;\n-            }\n-            return iTailZone.nextTransition(millis);\n-        }\n-\n-        public long previousTransition(long millis) {\n+            if (instant < end) {\n+                instant = end;\n+            }\n+            return iTailZone.nextTransition(instant);\n+        }\n+\n+        public long previousTransition(long instant) {\n             long[] transitions = iTransitions;\n-            int i = Arrays.binarySearch(transitions, millis);\n+            int i = Arrays.binarySearch(transitions, instant);\n             if (i >= 0) {\n-                if (millis > Long.MIN_VALUE) {\n-                    return millis - 1;\n-                }\n-                return millis;\n+                if (instant > Long.MIN_VALUE) {\n+                    return instant - 1;\n+                }\n+                return instant;\n             }\n             i = ~i;\n             if (i < transitions.length) {\n                         return prev - 1;\n                     }\n                 }\n-                return millis;\n+                return instant;\n             }\n             if (iTailZone != null) {\n-                long prev = iTailZone.previousTransition(millis);\n-                if (prev < millis) {\n+                long prev = iTailZone.previousTransition(instant);\n+                if (prev < instant) {\n                     return prev;\n                 }\n             }\n             if (prev > Long.MIN_VALUE) {\n                 return prev - 1;\n             }\n-            return millis;\n+            return instant;\n         }\n \n         public boolean equals(Object obj) {\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/tz/DateTimeZonePermission.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.tz;\n+\n+/**\n+ * DateTimeZonePermission allows global settings of DateTimeZone to be changed.\n+ * The following permission target names are supported:\n+ * <pre>\n+ * setDefault        Allows a default DateTimeZone to be set\n+ * setProvider       Allows a provider of DateTimeZone instances to be set\n+ * setNameProvider   Allows a provider of DateTimeZone names to be set\n+ * </pre>\n+ * <p>\n+ * DateTimeZonePermission is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public class DateTimeZonePermission extends java.security.BasicPermission {\n+    public DateTimeZonePermission(String name) {\n+        super(name);\n+    }\n+\n+    public DateTimeZonePermission(String name, String actions) {\n+        super(name, actions);\n+    }\n+}\n--- a/JodaTime/src/java/org/joda/time/tz/DefaultNameProvider.java\n+++ b/JodaTime/src/java/org/joda/time/tz/DefaultNameProvider.java\n /**\n  * The default name provider acquires localized names from\n  * {@link DateFormatSymbols java.text.DateFormatSymbols}.\n+ * <p>\n+ * DefaultNameProvider is thread-safe and immutable.\n  *\n  * @author Brian S O'Neill\n  */\n--- a/JodaTime/src/java/org/joda/time/tz/FixedDateTimeZone.java\n+++ b/JodaTime/src/java/org/joda/time/tz/FixedDateTimeZone.java\n \n /**\n  * Basic DateTimeZone implementation that has a fixed name key and offsets.\n+ * <p>\n+ * FixedDateTimeZone is thread-safe and immutable.\n  * \n  * @author Brian S O'Neill\n  */\n         iStandardOffset = standardOffset;\n     }\n \n-    public String getNameKey(long millis) {\n+    public String getNameKey(long instant) {\n         return iNameKey;\n     }\n \n-    public int getOffset(long millis) {\n+    public int getOffset(long instant) {\n         return iWallOffset;\n     }\n \n-    public int getStandardOffset(long millis) {\n+    public int getStandardOffset(long instant) {\n         return iStandardOffset;\n     }\n \n-    public int getOffsetFromLocal(long millisLocal) {\n+    public int getOffsetFromLocal(long instantLocal) {\n         return iWallOffset;\n     }\n \n-    public long nextTransition(long millis) {\n-        return millis;\n+    public boolean isFixed() {\n+        return true;\n     }\n \n-    public long previousTransition(long millis) {\n-        return millis;\n+    public long nextTransition(long instant) {\n+        return instant;\n+    }\n+\n+    public long previousTransition(long instant) {\n+        return instant;\n     }\n \n     public boolean equals(Object obj) {\n--- a/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java\n+++ b/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java\n package org.joda.time.tz;\n \n import java.io.BufferedReader;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileOutputStream;\n import java.io.FileReader;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.io.ObjectOutputStream;\n import java.io.OutputStream;\n import java.util.ArrayList;\n import java.util.HashMap;\n import org.joda.time.MutableDateTime;\n import org.joda.time.format.DateTimeParser;\n import org.joda.time.format.ISODateTimeFormat;\n+import org.joda.time.chrono.LenientChronology;\n import org.joda.time.chrono.iso.ISOChronology;\n \n /**\n  * in the database. {@link DateTimeZoneBuilder} is used to construct and encode\n  * compiled data files. {@link ZoneInfoProvider} loads the encoded files and\n  * converts them back into {@link DateTimeZone} objects.\n- *\n- * <p>Although this tool is similar to zic, the binary formats are not\n+ * <p>\n+ * Although this tool is similar to zic, the binary formats are not\n  * compatible. The latest Olson database files may be obtained\n  * <a href=\"http://www.twinsun.com/tz/tz-link.htm\">here</a>.\n+ * <p>\n+ * ZoneInfoCompiler is mutable and not thread-safe, although the main method\n+ * may be safely invoked by multiple threads.\n  *\n  * @author Brian S O'Neill\n  */\n     private static void printUsage() {\n         System.out.println\n             (\"Usage: java ZoneInfoCompiler [-d outputDirectory] sourceFile ...\");\n+    }\n+\n+    /**\n+     * @param zimap maps string ids to DateTimeZone objects.\n+     */\n+    static void writeZoneInfoMap(DataOutputStream dout, Map zimap) throws IOException {\n+        // Build the string pool.\n+        Map idToIndex = new HashMap(zimap.size());\n+        TreeMap indexToId = new TreeMap();\n+\n+        Iterator it = zimap.entrySet().iterator();\n+        short count = 0;\n+        while (it.hasNext()) {\n+            Map.Entry entry = (Map.Entry)it.next();\n+            String id = (String)entry.getKey();\n+            if (!idToIndex.containsKey(id)) {\n+                Short index = new Short(count);\n+                idToIndex.put(id, index);\n+                indexToId.put(index, id);\n+                if (++count == 0) {\n+                    throw new InternalError(\"Too many time zone ids\");\n+                }\n+            }\n+            id = ((DateTimeZone)entry.getValue()).getID();\n+            if (!idToIndex.containsKey(id)) {\n+                Short index = new Short(count);\n+                idToIndex.put(id, index);\n+                indexToId.put(index, id);\n+                if (++count == 0) {\n+                    throw new InternalError(\"Too many time zone ids\");\n+                }\n+            }\n+        }\n+\n+        // Write the string pool, ordered by index.\n+        dout.writeShort(indexToId.size());\n+        it = indexToId.values().iterator();\n+        while (it.hasNext()) {\n+            dout.writeUTF((String)it.next());\n+        }\n+\n+        // Write the mappings.\n+        dout.writeShort(zimap.size());\n+        it = zimap.entrySet().iterator();\n+        while (it.hasNext()) {\n+            Map.Entry entry = (Map.Entry)it.next();\n+            String id = (String)entry.getKey();\n+            dout.writeShort(((Short)idToIndex.get(id)).shortValue());\n+            id = ((DateTimeZone)entry.getValue()).getID();\n+            dout.writeShort(((Short)idToIndex.get(id)).shortValue());\n+        }\n+    }\n+\n+    /**\n+     * @param zimap gets filled with string id to string id mappings\n+     */\n+    static void readZoneInfoMap(DataInputStream din, Map zimap) throws IOException {\n+        // Read the string pool.\n+        int size = din.readUnsignedShort();\n+        String[] pool = new String[size];\n+        for (int i=0; i<size; i++) {\n+            pool[i] = din.readUTF().intern();\n+        }\n+\n+        // Read the mappings.\n+        size = din.readUnsignedShort();\n+        for (int i=0; i<size; i++) {\n+            try {\n+                zimap.put(pool[din.readUnsignedShort()], pool[din.readUnsignedShort()]);\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                throw new IOException(\"Corrupt zone info map\");\n+            }\n+        }\n     }\n \n     static int parseYear(String str, int def) {\n     }\n \n     static int parseTime(String str) {\n-        Chronology chrono = ISOChronology.getInstanceUTC();\n+        Chronology chrono = new LenientChronology(ISOChronology.getInstanceUTC());\n         DateTimeParser p = ISODateTimeFormat\n             .getInstance(chrono)\n             .hourMinuteSecondFraction();\n         }\n \n         if (dir != null) {\n-            Map zimap = new TreeMap();\n-            Iterator it = map.entrySet().iterator();\n-            while (it.hasNext()) {\n-                Map.Entry entry = (Map.Entry)it.next();\n-                String id = (String)entry.getKey();\n-                DateTimeZone tz = (DateTimeZone)entry.getValue();\n-                zimap.put(id, tz.getID());\n-            }\n-\n             System.out.println(\"Writing ZoneInfoMap\");\n             File file = new File(dir, \"ZoneInfoMap\");\n             if (!file.getParentFile().exists()) {\n                 file.getParentFile().mkdirs();\n             }\n+\n             OutputStream out = new FileOutputStream(file);\n-            ObjectOutputStream oout = new ObjectOutputStream(out);\n-            oout.writeObject(zimap);\n-            oout.close();\n+            DataOutputStream dout = new DataOutputStream(out);\n+            // Sort and filter out any duplicates that match case.\n+            Map zimap = new TreeMap(String.CASE_INSENSITIVE_ORDER);\n+            zimap.putAll(map);\n+            writeZoneInfoMap(dout, zimap);\n+            dout.close();\n         }\n \n         return map;\n--- a/JodaTime/src/java/org/joda/time/tz/ZoneInfoProvider.java\n+++ b/JodaTime/src/java/org/joda/time/tz/ZoneInfoProvider.java\n \n package org.joda.time.tz;\n \n+import java.io.DataInputStream;\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.io.ObjectInputStream;\n import java.lang.ref.SoftReference;\n import java.util.Collections;\n import java.util.Map;\n import java.util.Set;\n+import java.util.TreeMap;\n \n import org.joda.time.DateTimeZone;\n \n /**\n  * ZoneInfoProvider loads compiled data files as generated by\n  * {@link ZoneInfoCompiler}.\n+ * <p>\n+ * ZoneInfoProvider is thread-safe and publicly immutable.\n  *\n  * @author Brian S O'Neill\n  */\n public class ZoneInfoProvider implements Provider {\n     private static Map loadZoneInfoMap(InputStream in) throws IOException {\n-        ObjectInputStream oin = new ObjectInputStream(in);\n-        Map map;\n+        Map map = new TreeMap(String.CASE_INSENSITIVE_ORDER);\n+        DataInputStream din = new DataInputStream(in);\n         try {\n-            map = (Map)oin.readObject();\n-        } catch (ClassNotFoundException e) {\n-            throw new IOException(e.toString());\n+            ZoneInfoCompiler.readZoneInfoMap(din, map);\n         } finally {\n             try {\n-                oin.close();\n+                din.close();\n             } catch (IOException e) {\n             }\n         }\n \n     private final File iFileDir;\n     private final String iResourcePath;\n-    private ClassLoader iLoader;\n+    private final ClassLoader iLoader;\n \n     // Maps ids to strings or SoftReferences to DateTimeZones.\n     private final Map iZoneInfoMap;\n \n         iFileDir = fileDir;\n         iResourcePath = null;\n+        iLoader = null;\n \n         iZoneInfoMap = loadZoneInfoMap(openResource(\"ZoneInfoMap\"));\n     }\n      * @throws IOException if directory or map file cannot be read\n      */\n     public ZoneInfoProvider(String resourcePath) throws IOException {\n-        this(resourcePath, null);\n-        iLoader = getClass().getClassLoader();\n+        this(resourcePath, null, false);\n     }\n \n     /**\n     public ZoneInfoProvider(String resourcePath, ClassLoader loader)\n         throws IOException\n     {\n+        this(resourcePath, loader, true);\n+    }\n+\n+    /**\n+     * @param favorSystemLoader when true, use the system class loader if\n+     * loader null. When false, use the current class loader if loader is null.\n+     */\n+    private ZoneInfoProvider(String resourcePath,\n+                             ClassLoader loader, boolean favorSystemLoader) \n+        throws IOException\n+    {\n         if (resourcePath == null) {\n             throw new IllegalArgumentException(\"No resource path provided\");\n         }\n \n         iFileDir = null;\n         iResourcePath = resourcePath;\n+\n+        if (loader == null && !favorSystemLoader) {\n+            loader = getClass().getClassLoader();\n+        }\n+\n         iLoader = loader;\n \n         iZoneInfoMap = loadZoneInfoMap(openResource(\"ZoneInfoMap\"));\n                 in = ClassLoader.getSystemResourceAsStream(path);\n             }\n             if (in == null) {\n-                throw new IOException(\"Resource not found: \" + path);\n+                StringBuffer buf = new StringBuffer(40);\n+                buf.append(\"Resource not found: \\\"\");\n+                buf.append(path);\n+                buf.append(\"\\\" ClassLoader: \");\n+                buf.append(iLoader != null ? iLoader.toString() : \"system\");\n+                throw new IOException(buf.toString());\n             }\n         }\n         return in;\n--- a/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java\n+++ b/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java\n  */\n package org.joda.test.time;\n \n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n import java.util.Calendar;\n import java.util.Date;\n-import java.util.GregorianCalendar;\n import java.util.TimeZone;\n \n import org.joda.time.Chronology;\n--- a/JodaTime/src/test/org/joda/test/time/BulkTest.java\n+++ b/JodaTime/src/test/org/joda/test/time/BulkTest.java\n  */\n package org.joda.test.time ;\n //\n-import junit.framework.Test;\n-import junit.framework.TestCase;\n-import junit.framework.TestSuite;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.ArrayList;\n-import java.util.List;\n import java.util.Calendar;\n import java.util.GregorianCalendar;\n-import java.text.ParseException;\n-import org.joda.time.* ;\n-import org.joda.time.chrono.iso.* ;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.chrono.iso.ISOChronology;\n /**\n  *  A {@link TestCase} that can define both simple and bulk test methods.<P>\n  *\n             retVal = new MutableDateTime( s,\n                 ISOChronology.getInstanceUTC() );\n         }\n-        catch(ParseException pe)\n+        catch(IllegalArgumentException pe)\n         {\n-            System.err.println(\"ParseException Detected\");\n+            System.err.println(\"IllegalArgumentException Detected\");\n             pe.printStackTrace();\n         }\n         return retVal;\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/ClassLoadTest.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+import org.joda.time.AbstractDateTime;\n+import org.joda.time.AbstractInstant;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadableDateTime;\n+\n+/**\n+ * This class is a Junit unit test base class for\n+ * Instant implementations.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class ClassLoadTest {\n+\n+    // run using JVM -verbose:class\n+    public static void main(String[] args) {\n+        System.out.println(\"-----------------------------------------------\");\n+        System.out.println(\"-----------AbstractInstant---------------------\");\n+        Class cls = AbstractInstant.class;\n+        System.out.println(\"-----------ReadableDateTime--------------------\");\n+        cls = ReadableDateTime.class;\n+        System.out.println(\"-----------AbstractDateTime--------------------\");\n+        cls = AbstractDateTime.class;\n+        System.out.println(\"-----------DateTime----------------------------\");\n+        cls = DateTime.class;\n+        System.out.println(\"-----------DateTimeZone------------------------\");\n+        cls = DateTimeZone.class;\n+        System.out.println(\"-----------new DateTime()----------------------\");\n+        DateTime dt = new DateTime();\n+        System.out.println(\"-----------new DateTime(ReadableInstant)-------\");\n+        dt = new DateTime(dt);\n+        System.out.println(\"-----------new DateTime(Long)------------------\");\n+        dt = new DateTime(new Long(0));\n+        System.out.println(\"-----------------------------------------------\");\n+    }\n+    \n+}\n--- a/JodaTime/src/test/org/joda/test/time/TestConstructors.java\n+++ b/JodaTime/src/test/org/joda/test/time/TestConstructors.java\n  */\n package org.joda.test.time;\n //\n-import java.text.ParseException;\n import java.io.PrintStream;\n-//\n+\n import junit.framework.TestSuite;\n-//\n+\n import org.joda.time.DateTime;\n-//import org.joda.time.DateOnly;\n-//import org.joda.time.TimeOnly;\n import org.joda.time.ReadableInstant;\n-import org.joda.time.DateTimeFieldProperty;\n //\n /**\n  * This class is a Junit unit test for the\n- * constructors of various ISODateTime, ISODateOnly, and\n- * ISOTimeOnly objects.\n+ * constructors of various DateTime, DateOnly, and\n+ * TimeOnly objects.\n  *\n  * @author Guy Allard\n  *\n         super.tearDown();\n     }\n     /**\n-     * Test the <code>ISODateOnly</code> constructors.\n-     * @see org.joda.time.iso.ISODateOnly\n+     * Test the <code>DateOnly</code> constructors.\n+     * @see org.joda.time.DateOnly\n      */\n     public void testDateOnlyConstructors() {\n         dateOnly = true;\n         tt.showResults();\n     }\n     /**\n-     * Test the <code>ISOTimeOnly</code> constructors.\n-     * @see org.joda.time.iso.ISOTimeOnly\n+     * Test the <code>TimeOnly</code> constructors.\n+     * @see org.joda.time.TimeOnly\n      */\n     public void testTimeOnlyConstructors() {\n         dateOnly = false;\n         tt.showResults();\n     }\n     /**\n-     * Test the <code>ISODateTime</code> constructors.\n-     * @see org.joda.time.iso.ISODateTime\n+     * Test the <code>DateTime</code> constructors.\n+     * @see org.joda.time.DateTime\n      */\n     public void testDateTimeConstructors() {\n         dateTimes = true;\n                     }\n                     */\n                 }\n-                catch(ParseException pe)\n+                catch(IllegalArgumentException pe)\n                 {\n                     ss.bumpFailedTests();\n                     tt.bumpFailedTests();\n--- a/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java\n+++ b/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java\n  */\n package org.joda.test.time;\n \n-import java.util.*;\n-import java.text.* ;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.List;\n+\n import junit.framework.TestSuite;\n-import org.joda.time.*;\n-import org.joda.time.chrono.iso.*;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeComparator;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.iso.ISOChronology;\n /**\n  * This class is a Junit unit test for the\n  * org.joda.time.DateTimeComparator class.\n         {\n             retDT = new DateTime( s, DateTimeZone.UTC );\n         }\n-        catch(ParseException pe)\n+        catch(IllegalArgumentException pe)\n         {\n             pe.printStackTrace();\n         }\n                 newList.add( new DateTime( someStrs[i], DateTimeZone.UTC ) );\n             } // end of the for\n         }\n-        catch(ParseException pe)\n+        catch(IllegalArgumentException pe)\n         {\n             pe.printStackTrace();\n         }\n--- a/JodaTime/src/test/org/joda/test/time/TestDateTimeFormat.java\n+++ b/JodaTime/src/test/org/joda/test/time/TestDateTimeFormat.java\n  */\n public class TestDateTimeFormat extends BulkTest {\n \n-\t/**\n-\t * This is the main class for this test suite.\n-\t * @param args command line arguments.\n-\t */\n-\tpublic static void main(String[] args) {\n-\t\tjunit.textui.TestRunner.run(suite());\n-\t}\n-\t/**\n-\t * TestSuite is a junit required method.\n-\t */\n-\tpublic static TestSuite suite() {\n-\t\treturn BulkTest.makeSuite(TestDateTimeFormat.class);\n-\t}\n-\t/**\n-\t * TestDateTimeField constructor.\n-\t * @param name\n-\t */\n-\tpublic TestDateTimeFormat(String name) {\n-\t\tsuper(name);\n-\t}\n-\t// Class Name: org.joda.time.format.DateTimeFormat\n-\t/**\n-\t * Junit <code>setUp()</code> method.\n-\t */\n-\tpublic void setUp() /* throws Exception */ {\n-\t\t// super.setUp();\n-\t}\n-\t/**\n-\t * Junit <code>tearDown()</code> method.\n-\t */\n-\tprotected void tearDown() /* throws Exception */ {\n-\t\t// super.tearDown();\n-\t}\n-\t/**\n-\t * Test the <code>getInstance()</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#getInstance()\n-\t */\n-\tprotected void testGetInstance() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>getInstance(java.lang.String)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#getInstance(java.lang.String)\n-\t */\n-\tpublic void testGetInstanceString() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>getInstance(java.lang.String, java.util.TimeZone)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#getInstance(java.lang.String, java.util.TimeZone)\n-\t */\n-\tpublic void testGetInstanceSTZ() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>getInstance(java.lang.String, java.util.TimeZone, java.util.Locale)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#getInstance(java.lang.String, java.util.TimeZone, java.util.Locale)\n-\t */\n-\tpublic void testGetInstanceSTZL() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>getInstance(java.lang.String, org.joda.time.Chronology)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#getInstance(java.lang.String, org.joda.time.Chronology)\n-\t */\n-\tpublic void testGetInstanceSC() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>getInstance(java.lang.String, org.joda.time.Chronology, java.util.TimeZone)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#getInstance(java.lang.String, org.joda.time.Chronology, java.util.TimeZone)\n-\t */\n-\tpublic void testGetInstanceSCT() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>getInstance(java.lang.String, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#getInstance(java.lang.String, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)\n-\t */\n-\tpublic void testGetInstanceSCTL() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>getDateInstance(java.lang.Object, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#getDateInstance(java.lang.Object, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)\n-\t */\n-\tpublic void testGetDateInstance() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>getTimeInstance(java.lang.Object, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#getTimeInstance(java.lang.Object, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)\n-\t */\n-\tpublic void testGetTimeInstance() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>getDateTimeInstance(java.lang.Object, java.lang.Object, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#getDateTimeInstance(java.lang.Object, java.lang.Object, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)\n-\t */\n-\tpublic void testGetDateTimeInstance() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>getPattern()</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#getPattern()\n-\t */\n-\tpublic void testGetPattern() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>getChronology()</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#getChronology()\n-\t */\n-\tpublic void testGetChronology() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>getTimeZone()</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#getTimeZone()\n-\t */\n-\tpublic void testGetTimeZone() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>getLocale()</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#getLocale()\n-\t */\n-\tpublic void testGetLocale() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>getPrinter()</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#getPrinter()\n-\t */\n-\tpublic void testGetPrinter() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>getParser()</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#getParser()\n-\t */\n-\tpublic void testGetParser() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>estimatePrintedLength()</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#estimatePrintedLength()\n-\t */\n-\tpublic void testEstimatePrintedLength() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>printTo(java.lang.StringBuffer, long, long)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#printTo(java.lang.StringBuffer, long, long)\n-\t */\n-\tpublic void testPrintToSLL() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>printTo(java.io.Writer, long, long)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#printTo(java.io.Writer, long, long)\n-\t */\n-\tpublic void testPrintToWLL() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)\n-\t */\n-\tpublic void testPrintToSBRI() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>printTo(java.lang.StringBuffer, long)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#printTo(java.lang.StringBuffer, long)\n-\t */\n-\tpublic void testPrintToSBL() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>printTo(java.io.Writer, org.joda.time.ReadableInstant)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#printTo(java.io.Writer, org.joda.time.ReadableInstant)\n-\t */\n-\tpublic void testPrintToWRI() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>printTo(java.io.Writer, long)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#printTo(java.io.Writer, long)\n-\t */\n-\tpublic void testPrintToWL() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>print(org.joda.time.ReadableInstant)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#print(org.joda.time.ReadableInstant)\n-\t */\n-\tpublic void testPrintRI() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>print(long)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#print(long)\n-\t */\n-\tpublic void testPrintL() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>estimateParsedLength()</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#estimateParsedLength()\n-\t */\n-\tpublic void testEstimateParsedLength() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)\n-\t */\n-\tpublic void testParseIntoPBSI() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>parseInto(org.joda.time.ReadWritableInstant, java.lang.String)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#parseInto(org.joda.time.ReadWritableInstant, java.lang.String)\n-\t */\n-\tpublic void testParseIntoRWIS() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)\n-\t */\n-\tpublic void testParseIntoRWISI() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>parse(java.lang.String)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#parse(java.lang.String)\n-\t */\n-\tpublic void testParseS() {\n-\t\tfail(\"TBD\");\n-\t}\n-\t/**\n-\t * Test the <code>parse(java.lang.String, int, long)</code> method.\n-\t * @see org.joda.time.format.DateTimeFormat#parse(java.lang.String, int, long)\n-\t */\n-\tpublic void testParseSL() {\n-\t\tfail(\"TBD\");\n-\t}\n+    /**\n+     * This is the main class for this test suite.\n+     * @param args command line arguments.\n+     */\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    /**\n+     * TestSuite is a junit required method.\n+     */\n+    public static TestSuite suite() {\n+        return BulkTest.makeSuite(TestDateTimeFormat.class);\n+    }\n+    /**\n+     * TestDateTimeField constructor.\n+     * @param name\n+     */\n+    public TestDateTimeFormat(String name) {\n+        super(name);\n+    }\n+    // Class Name: org.joda.time.format.DateTimeFormat\n+    /**\n+     * Junit <code>setUp()</code> method.\n+     */\n+    public void setUp() /* throws Exception */ {\n+        // super.setUp();\n+    }\n+    /**\n+     * Junit <code>tearDown()</code> method.\n+     */\n+    protected void tearDown() /* throws Exception */ {\n+        // super.tearDown();\n+    }\n+    /**\n+     * Test the <code>getInstanceUTC()</code> method.\n+     * @see org.joda.time.format.DateTimeFormat#getInstanceUTC()\n+     */\n+    protected void testGetInstanceUTC() {\n+        fail(\"TBD\");\n+    }\n+    /**\n+     * Test the <code>getInstance()</code> method.\n+     * @see org.joda.time.format.DateTimeFormat#getInstance()\n+     */\n+    protected void testGetInstance() {\n+        fail(\"TBD\");\n+    }\n+    /**\n+     * Test the <code>getInstance(org.joda.time.DateTimeZone)</code> method.\n+     * @see org.joda.time.format.DateTimeFormat#getInstance(org.joda.time.DateTimeZone)\n+     */\n+    public void testGetInstanceTZ() {\n+        fail(\"TBD\");\n+    }\n+    /**\n+     * Test the <code>getInstance(org.joda.time.DateTimeZone, java.util.Locale)</code> method.\n+     * @see org.joda.time.format.DateTimeFormat#getInstance(org.joda.time.DateTimeZone, java.util.Locale)\n+     */\n+    public void testGetInstanceTZL() {\n+        fail(\"TBD\");\n+    }\n+    /**\n+     * Test the <code>getInstance(org.joda.time.Chronology)</code> method.\n+     * @see org.joda.time.format.DateTimeFormat#getInstance(org.joda.time.Chronology)\n+     */\n+    public void testGetInstanceC() {\n+        fail(\"TBD\");\n+    }\n+    /**\n+     * Test the <code>getInstance(org.joda.time.Chronology, java.util.Locale)</code> method.\n+     * @see org.joda.time.format.DateTimeFormat#getInstance(org.joda.time.Chronology, java.util.Locale)\n+     */\n+    public void testGetInstanceCL() {\n+        fail(\"TBD\");\n+    }\n+    /**\n+     * Test the <code>forPattern(String)</code> method.\n+     * @see org.joda.time.format.DateTimeFormat#forPattern(String)\n+     */\n+    public void testForPattern() {\n+        fail(\"TBD\");\n+    }\n+    /**\n+     * Test the <code>forStyle(String)</code> method.\n+     * @see org.joda.time.format.DateTimeFormat#forStyle(String)\n+     */\n+    public void testForStyle() {\n+        fail(\"TBD\");\n+    }\n+    /**\n+     * Test the <code>getPatternForStyle()</code> method.\n+     * @see org.joda.time.format.DateTimeFormat#getPatternForStyle(String)\n+     */\n+    public void testGetPatternForStyle() {\n+        fail(\"TBD\");\n+    }\n \n }\n--- a/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java\n+++ b/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java\n  */\n package org.joda.test.time;\n \n-import java.util.*;\n-import java.text.* ;\n-import java.io.*;\n+import java.io.PrintStream;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.SimpleTimeZone;\n+import java.util.TimeZone;\n \n import junit.framework.TestSuite;\n \n-import org.joda.time.*;\n-import org.joda.time.chrono.iso.* ;\n+import org.joda.time.Chronology;\n+import org.joda.time.Instant;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.iso.ISOChronology;\n /**\n  * This class is a Junit unit test for the\n  * org.joda.time.MutableDateTime class.\n \n     /**\n      * Test the <code>addMillis(long)</code> method.\n-     * @see org.joda.time.MutableDateTime#addMillis(long)\n+     * @see org.joda.time.MutableDateTime#add(long)\n      */\n     public void testAddMillis() {\n         fail(\"TBD\");\n         {\n             mdt = new MutableDateTime( isoString, ISOChronology.getInstanceUTC() );\n         }\n-        catch(ParseException pe)\n+        catch(IllegalArgumentException pe)\n         {\n-            ewtr.println(\"ParseException Detected: \" + isoString);\n+            ewtr.println(\"IllegalArgumentException Detected: \" + isoString);\n             ewtr.println( pe.getMessage() );\n             ewtr.flush();\n         }\n--- a/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java\n+++ b/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java\n  */\n package org.joda.test.time;\n \n-import java.util.*;\n-import java.text.* ;\n-import java.io.*;\n+import java.io.PrintStream;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.SimpleTimeZone;\n+import java.util.TimeZone;\n \n import junit.framework.TestSuite;\n \n-import org.joda.time.*;\n-import org.joda.time.chrono.iso.* ;\n+import org.joda.time.Chronology;\n+import org.joda.time.Instant;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.iso.ISOChronology;\n /**\n  * This class is a Junit unit test for the\n  * org.joda.time.MutableDateTime class.\n         {\n             mdt = new MutableDateTime( isoString, ISOChronology.getInstanceUTC() );\n         }\n-        catch(ParseException pe)\n+        catch(IllegalArgumentException pe)\n         {\n-            ewtr.println(\"ParseException Detected: \" + isoString);\n+            ewtr.println(\"IllegalArgumentException Detected: \" + isoString);\n             ewtr.println( pe.getMessage() );\n             ewtr.flush();\n         }\n--- a/JodaTime/src/test/org/joda/test/time/TestMDTGet.java\n+++ b/JodaTime/src/test/org/joda/test/time/TestMDTGet.java\n  */\n package org.joda.test.time;\n \n-import java.util.*;\n-import java.text.* ;\n-import java.io.*;\n+import java.io.PrintStream;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.SimpleTimeZone;\n+import java.util.TimeZone;\n \n import junit.framework.TestSuite;\n \n-import org.joda.time.*;\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.MutableDateTime;\n import org.joda.time.chrono.iso.ISOChronology;\n /**\n  * This class is a Junit unit test for the\n     }\n     /**\n      * Test the <code>getWeekOfYearWeek()</code> method.\n-     * @see org.joda.time.MutableDateTime#getWeekOfYearWeek()\n+     * @see org.joda.time.MutableDateTime#getWeekOfWeekyear()\n      */\n     public void testGetWeekOfWeekyear() {\n         for (int ngc = 0; ngc < gcals.length; ++ngc) {\n     }\n     /**\n      * Test the <code>getWeekOfYearYear()</code> method.\n-     * @see org.joda.time.MutableDateTime#getWeekOfYearYear()\n+     * @see org.joda.time.MutableDateTime#getWeekOfWeekyear()\n      */\n     public void testGetYearOfWeekyear() {\n         for (int ngc = 0; ngc < gcals.length; ++ngc) {\n     }\n     /**\n      * Test the <code>weekOfYearWeek()</code> method.\n-     * @see org.joda.time.MutableDateTime#weekOfYearWeek()\n+     * @see org.joda.time.MutableDateTime#weekOfWeekyear()\n      */\n     public void testWeekOfWeekyear() {\n         for (int ngc = 0; ngc < gcals.length; ++ngc) {\n     }\n     /**\n      * Test the <code>weekOfYearYear()</code> method.\n-     * @see org.joda.time.MutableDateTime#weekOfYearYear()\n-     */\n-    public void testYearOfWeekyear() {\n+     * @see org.joda.time.MutableDateTime#weekyear()\n+     */\n+    public void testWeekyear() {\n         for (int ngc = 0; ngc < gcals.length; ++ngc) {\n             prepTest( ngc );\n             assertEquals(\"DWOYY1:\"+isoString, expected_woyy,\n         {\n             mdt = new MutableDateTime( isoString, ISOChronology.getInstanceUTC() );\n         }\n-        catch(ParseException pe)\n+        catch(IllegalArgumentException pe)\n         {\n-            ewtr.println(\"ParseException Detected: \" + isoString);\n+            ewtr.println(\"IllegalArgumentException Detected: \" + isoString);\n             ewtr.println( pe.getMessage() );\n             ewtr.flush();\n         }\n--- a/JodaTime/src/test/org/joda/test/time/TestMDTSet.java\n+++ b/JodaTime/src/test/org/joda/test/time/TestMDTSet.java\n  */\n package org.joda.test.time;\n \n-import java.util.*;\n-import java.text.* ;\n-import java.io.*;\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.SimpleTimeZone;\n+import java.util.TimeZone;\n \n import junit.framework.TestSuite;\n \n-import org.joda.time.*;\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.Instant;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadableInstant;\n import org.joda.time.chrono.iso.ISOChronology;\n /**\n  * This class is a Junit unit test for the\n     }\n     /**\n      * Test the <code>setWeekOfYear(int, int)</code> method.\n-     * @see org.joda.time.MutableDateTime#setWeekOfYear(int, int)\n+     * @see org.joda.time.MutableDateTime#setWeekOfWeekyear(int)\n      */\n     public void testSetWeekOfYear() {\n         ewtr.println(\"testSetWeekOfYear needs enhancement\");\n         {\n             mdt = new MutableDateTime( isoString, ISOChronology.getInstanceUTC() );\n         }\n-        catch(ParseException pe)\n+        catch(IllegalArgumentException pe)\n         {\n-            ewtr.println(\"ParseException Detected: \" + isoString);\n+            ewtr.println(\"IllegalArgumentException Detected: \" + isoString);\n             ewtr.println( pe.getMessage() );\n             ewtr.flush();\n         }\n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java\n     {\n         int a, b;\n         long x, y;\n+        boolean m, n;\n \n         // get test\n         a = fieldA.get(millis);\n             System.out.println(\"Test datetime 2: \" + makeDatetime(millis2));\n             throw e;\n         }\n+\n+        // isLeap test\n+        m = fieldA.isLeap(millis);\n+        n = fieldB.isLeap(millis);\n+        testBoolean(fieldA, fieldB, \"isLeap\", millis, m, n);\n+\n+        // getLeapAmount test\n+        a = fieldA.getLeapAmount(millis);\n+        b = fieldB.getLeapAmount(millis);\n+        testValue(fieldA, fieldB, \"getLeapAmount\", millis, a, b);\n     }\n \n     private int getWrappedValue(int value, int minValue, int maxValue) {\n                             int valueA, int valueB) {\n         if (millisA != millisB) {\n             failMillis(fieldA, fieldB, method, millis, millisA, millisB, valueA, valueB);\n+        }\n+    }\n+\n+    private void testBoolean(DateTimeField fieldA, DateTimeField fieldB,\n+                             String method, long millis, boolean boolA, boolean boolB) {\n+        if (boolA != boolB) {\n+            failBoolean(fieldA, fieldB, method, millis, boolA, boolB);\n         }\n     }\n \n         throw new RuntimeException();\n     }\n \n+    private void failBoolean(DateTimeField fieldA, DateTimeField fieldB,\n+                             String method, long millis, boolean boolA, boolean boolB) {\n+        System.out.println(\"Failure on \" + makeName(fieldA, fieldB) + \".\" + method);\n+        System.out.println(fieldA.getClass().getName() + \"\\n\\tvs. \"\n+                           + fieldB.getClass().getName());\n+        System.out.println(\"Datetime: \" + makeDatetime(millis));\n+        System.out.println(\"Millis from 1970: \" + millis);\n+        System.out.println(boolA + \" != \" + boolB);\n+        throw new RuntimeException();\n+    }\n+\n     private String makeName(DateTimeField fieldA, DateTimeField fieldB) {\n         if (fieldA.getName().equals(fieldB.getName())) {\n             return fieldA.getName();\n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n \n /**\n  * A reference Gregorian/Julian chronology implementation, intended for testing\n         return millis - mod(millis, MILLIS_PER_DAY);\n     }\n \n+    public DurationField days() {\n+        return dayOfWeek().getDurationField();\n+    }\n+\n     public DateTimeField dayOfWeek() {\n         return new TestGJDayOfWeekField(this);\n     }\n         return new TestGJDayOfYearField(this);\n     }\n \n+    public DurationField weeks() {\n+        return weekOfWeekyear().getDurationField();\n+    }\n+\n     public DateTimeField weekOfWeekyear() {\n         return new TestGJWeekOfWeekyearField(this);\n     }\n \n+    public DurationField weekyears() {\n+        return weekyear().getDurationField();\n+    }\n+\n     public DateTimeField weekyear() {\n         return new TestGJWeekyearField(this);\n     }\n \n+    public DurationField months() {\n+        return monthOfYear().getDurationField();\n+    }\n+\n     public DateTimeField monthOfYear() {\n         return new TestGJMonthOfYearField(this);\n     }\n \n+    public DurationField years() {\n+        return year().getDurationField();\n+    }\n+\n     public DateTimeField year() {\n         return new TestGJYearField(this);\n     }\n+\n+    abstract long millisPerYear();\n+\n+    abstract long millisPerMonth();\n \n     abstract boolean isLeapYear(int year);\n \n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java\n \n package org.joda.test.time.chrono.gj;\n \n-import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.ImpreciseDateTimeField;\n+import org.joda.time.chrono.Utils;\n \n /**\n  * \n  * @author Brian S O'Neill\n  */\n-abstract class TestGJDateTimeField extends DateTimeField {\n+abstract class TestGJDateTimeField extends ImpreciseDateTimeField {\n     protected final TestGJChronology iChronology;\n \n-    public TestGJDateTimeField(String name, TestGJChronology chrono) {\n-        super(name);\n+    public TestGJDateTimeField(String name, String duratioName,\n+                               long unitMillis, TestGJChronology chrono) {\n+        super(name, duratioName, unitMillis);\n         iChronology = chrono;\n     }\n \n-    // Redeclare to work around compiler bug.\n-    public abstract long add(long millis, int value);\n+    public boolean isLenient() {\n+        return false;\n+    }\n \n-    public long add(long millis, long value) {\n-        return addLong(millis, value);\n+    public long add(long instant, int value) {\n+        return add(instant, (long)value);\n     }\n+\n+    public abstract long add(long instant, long value);\n+\n }\n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfMonthField.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfMonthField.java\n \n package org.joda.test.time.chrono.gj;\n \n+import org.joda.time.DurationField;\n+\n /**\n  * \n  * @author Brian S O'Neill\n  */\n class TestGJDayOfMonthField extends TestGJDateTimeField {\n     public TestGJDayOfMonthField(TestGJChronology chrono) {\n-        super(\"dayOfMonth\", chrono);\n+        super(\"dayOfMonth\", \"days\", chrono.MILLIS_PER_DAY, chrono);\n     }\n \n     public int get(long millis) {\n         return iChronology.gjFromMillis(millis)[2];\n-    }\n-\n-    public long add(long millis, int value) {\n-        return millis + value * iChronology.MILLIS_PER_DAY;\n     }\n \n     public long set(long millis, int value) {\n             + iChronology.millisFromGJ(ymd[0], ymd[1], value);\n     }\n \n-    public long getUnitMillis() {\n-        return iChronology.MILLIS_PER_DAY;\n+    public long add(long millis, long value) {\n+        return millis + value * iChronology.MILLIS_PER_DAY;\n     }\n \n-    public long getRangeMillis() {\n-        return (long)(365.2425 * iChronology.MILLIS_PER_DAY / 12);\n+    public DurationField getRangeDurationField() {\n+        return iChronology.months();\n     }\n \n     public int getMinimumValue() {\n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfWeekField.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfWeekField.java\n \n package org.joda.test.time.chrono.gj;\n \n+import org.joda.time.DurationField;\n+\n /**\n  * \n  * @author Brian S O'Neill\n  */\n class TestGJDayOfWeekField extends TestGJDateTimeField {\n     public TestGJDayOfWeekField(TestGJChronology chrono) {\n-        super(\"dayOfWeek\", chrono);\n+        super(\"dayOfWeek\", \"days\", chrono.MILLIS_PER_DAY, chrono);\n     }\n \n     public int get(long millis) {\n-\t\tint dayOfWeek = (int)iChronology.mod(iChronology.fixedFromMillis(millis), 7);\n-\t\tif (dayOfWeek == 0) {\n-\t\t\tdayOfWeek = 7;\n-\t\t}\n-\t\treturn dayOfWeek;\n+        int dayOfWeek = (int)iChronology.mod(iChronology.fixedFromMillis(millis), 7);\n+        if (dayOfWeek == 0) {\n+            dayOfWeek = 7;\n+        }\n+        return dayOfWeek;\n     }\n \n-    public long add(long millis, int value) {\n+    public long set(long millis, int value) {\n+        return add(millis, (long) value - get(millis));\n+    }\n+\n+    public long add(long millis, long value) {\n         return millis + value * iChronology.MILLIS_PER_DAY;\n     }\n \n-    public long set(long millis, int value) {\n-        return add(millis, value - get(millis));\n-    }\n-\n-    public long getUnitMillis() {\n-        return iChronology.MILLIS_PER_DAY;\n-    }\n-\n-    public long getRangeMillis() {\n-        return iChronology.MILLIS_PER_DAY * 7;\n+    public DurationField getRangeDurationField() {\n+        return iChronology.weeks();\n     }\n \n     public int getMinimumValue() {\n     }\n \n     public long roundFloor(long millis) {\n-\t\treturn iChronology.getDateOnlyMillis(millis);\n+        return iChronology.getDateOnlyMillis(millis);\n     }\n }\n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfYearField.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfYearField.java\n \n package org.joda.test.time.chrono.gj;\n \n+import org.joda.time.DurationField;\n+\n /**\n  * \n  * @author Brian S O'Neill\n  */\n class TestGJDayOfYearField extends TestGJDateTimeField {\n     public TestGJDayOfYearField(TestGJChronology chrono) {\n-        super(\"dayOfYear\", chrono);\n+        super(\"dayOfYear\", \"days\", chrono.MILLIS_PER_DAY, chrono);\n     }\n \n     public int get(long millis) {\n                      - iChronology.fixedFromGJ(year, 1, 1)) + 1;\n     }\n \n-    public long add(long millis, int value) {\n+    public long set(long millis, int value) {\n+        return add(millis, (long) value - get(millis));\n+    }\n+\n+    public long add(long millis, long value) {\n         return millis + value * iChronology.MILLIS_PER_DAY;\n     }\n \n-    public long set(long millis, int value) {\n-        return add(millis, value - get(millis));\n-    }\n-\n-    public long getUnitMillis() {\n-        return iChronology.MILLIS_PER_DAY;\n-    }\n-\n-    public long getRangeMillis() {\n-        return (long)(365.2425 * iChronology.MILLIS_PER_DAY);\n+    public DurationField getRangeDurationField() {\n+        return iChronology.years();\n     }\n \n     public int getMinimumValue() {\n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJMonthOfYearField.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJMonthOfYearField.java\n \n package org.joda.test.time.chrono.gj;\n \n+import org.joda.time.DurationField;\n+\n /**\n  * \n  * @author Brian S O'Neill\n  */\n class TestGJMonthOfYearField extends TestGJDateTimeField {\n     public TestGJMonthOfYearField(TestGJChronology chrono) {\n-        super(\"monthOfYear\", chrono);\n+        super(\"monthOfYear\", \"months\", chrono.millisPerMonth(), chrono);\n     }\n \n     public int get(long millis) {\n         return iChronology.gjFromMillis(millis)[1];\n     }\n \n-    public long add(long millis, int value) {\n+    public long set(long millis, int value) {\n+        long timeOnlyMillis = iChronology.getTimeOnlyMillis(millis);\n+        int[] ymd = iChronology.gjFromMillis(millis);\n+        // First set to start of month...\n+        millis = iChronology.millisFromGJ(ymd[0], value, 1);\n+        // ...and use dayOfMonth field to check range.\n+        int maxDay = iChronology.dayOfMonth().getMaximumValue(millis);\n+        if (ymd[2] > maxDay) {\n+            ymd[2] = maxDay;\n+        }\n+        return timeOnlyMillis + iChronology.millisFromGJ(ymd[0], value, ymd[2]);\n+    }\n+\n+    public long add(long millis, long value) {\n         int newYear = iChronology.year().get(millis)\n             + (int)iChronology.div(value, 12);\n         int newMonth = get(millis) + (int)iChronology.mod(value, 12);\n         return millis;\n     }\n \n-    public long set(long millis, int value) {\n-        long timeOnlyMillis = iChronology.getTimeOnlyMillis(millis);\n+    public boolean isLeap(long millis) {\n         int[] ymd = iChronology.gjFromMillis(millis);\n-        // First set to start of month...\n-        millis = iChronology.millisFromGJ(ymd[0], value, 1);\n-        // ...and use dayOfMonth field to check range.\n-        int maxDay = iChronology.dayOfMonth().getMaximumValue(millis);\n-        if (ymd[2] > maxDay) {\n-            ymd[2] = maxDay;\n-        }\n-        return timeOnlyMillis + iChronology.millisFromGJ(ymd[0], value, ymd[2]);\n+        return ymd[1] == 2 && iChronology.isLeapYear(ymd[0]);\n     }\n \n-    public long getUnitMillis() {\n-        return (long)(365.2425 * iChronology.MILLIS_PER_DAY / 12);\n+    public int getLeapAmount(long millis) {\n+        return isLeap(millis) ? 1 : 0;\n     }\n \n-    public long getRangeMillis() {\n-        return (long)(365.2425 * iChronology.MILLIS_PER_DAY);\n+    public DurationField getLeapDurationField() {\n+        return iChronology.days();\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.years();\n     }\n \n     public int getMinimumValue() {\n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekOfWeekyearField.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekOfWeekyearField.java\n \n package org.joda.test.time.chrono.gj;\n \n+import org.joda.time.DurationField;\n+\n /**\n  * \n  * @author Brian S O'Neill\n  */\n class TestGJWeekOfWeekyearField extends TestGJDateTimeField {\n     public TestGJWeekOfWeekyearField(TestGJChronology chrono) {\n-        super(\"weekOfWeekyear\", chrono);\n+        super(\"weekOfWeekyear\", \"weeks\",\n+              (long)(chrono.MILLIS_PER_DAY * 7), chrono);\n     }\n \n     public int get(long millis) {\n         return iChronology.isoFromMillis(millis)[1];\n-    }\n-\n-    public long add(long millis, int value) {\n-        return iChronology.dayOfYear().add(millis, value * 7);\n     }\n \n     public long set(long millis, int value) {\n             + iChronology.millisFromISO(wwd[0], value, wwd[2]);\n     }\n \n-    public long getUnitMillis() {\n-        return (long)(iChronology.MILLIS_PER_DAY * 7);\n+    public long add(long millis, long value) {\n+        return iChronology.dayOfYear().add(millis, value * 7);\n     }\n \n-    public long getRangeMillis() {\n-        return (long)(365.2425 * iChronology.MILLIS_PER_DAY);\n+    public DurationField getRangeDurationField() {\n+        return iChronology.weeks();\n     }\n \n     public int getMinimumValue() {\n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekyearField.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekyearField.java\n \n package org.joda.test.time.chrono.gj;\n \n+import org.joda.time.DurationField;\n+\n /**\n  * \n  * @author Brian S O'Neill\n  */\n class TestGJWeekyearField extends TestGJDateTimeField {\n     public TestGJWeekyearField(TestGJChronology chrono) {\n-        super(\"weekyear\", chrono);\n+        super(\"weekyear\", \"weekyears\", chrono.millisPerYear(), chrono);\n     }\n \n     public int get(long millis) {\n         return iChronology.isoFromMillis(millis)[0];\n-    }\n-\n-    public long add(long millis, int value) {\n-        return set(millis, get(millis) + value);\n     }\n \n     public long set(long millis, int value) {\n         return millis;\n     }\n \n-    public long getUnitMillis() {\n-        return (long)(365.2425 * iChronology.MILLIS_PER_DAY);\n+    public long add(long millis, long value) {\n+        return set(millis, (int)(get(millis) + value));\n     }\n \n-    public long getRangeMillis() {\n-        return Long.MAX_VALUE;\n+    public DurationField getRangeDurationField() {\n+        return null;\n     }\n \n     public int getMinimumValue() {\n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJYearField.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJYearField.java\n \n package org.joda.test.time.chrono.gj;\n \n+import org.joda.time.DurationField;\n+\n /**\n  * \n  * @author Brian S O'Neill\n  */\n class TestGJYearField extends TestGJDateTimeField {\n     public TestGJYearField(TestGJChronology chrono) {\n-        super(\"year\", chrono);\n+        super(\"year\", \"years\", chrono.millisPerYear(), chrono);\n     }\n \n     public int get(long millis) {\n         return iChronology.gjYearFromMillis(millis);\n-    }\n-\n-    public long add(long millis, int value) {\n-        return set(millis, get(millis) + value);\n     }\n \n     public long set(long millis, int value) {\n         return millis;\n     }\n \n+    public long add(long millis, long value) {\n+        return set(millis, (int)(get(millis) + value));\n+    }\n+\n     public boolean isLeap(long millis) {\n         return iChronology.isLeapYear(get(millis));\n     }\n         return isLeap(millis) ? 1 : 0;\n     }\n \n-    public long getUnitMillis() {\n-        return (long)(365.2425 * iChronology.MILLIS_PER_DAY);\n+    public DurationField getLeapDurationField() {\n+        return iChronology.days();\n     }\n \n-    public long getRangeMillis() {\n-        return Long.MAX_VALUE;\n+    public DurationField getRangeDurationField() {\n+        return null;\n     }\n \n     public int getMinimumValue() {\n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGregorianChronology.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGregorianChronology.java\n \n     public TestGregorianChronology(int epochYear, int epochMonth, int epochDay) {\n         super(epochYear, epochMonth, epochDay);\n+    }\n+\n+    public String toString() {\n+        return \"TestGregorianChronology\";\n+    }\n+\n+    long millisPerYear() {\n+        return (long)(365.2425 * MILLIS_PER_DAY);\n+    }\n+\n+    long millisPerMonth() {\n+        return (long)(365.2425 * MILLIS_PER_DAY / 12);\n     }\n \n     boolean isLeapYear(int year) {\n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianChronology.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianChronology.java\n         return new TestJulianYearField(this);\n     }\n \n+    public String toString() {\n+        return \"TestJulianChronology\";\n+    }\n+\n+    long millisPerYear() {\n+        return (long)(365.25 * MILLIS_PER_DAY);\n+    }\n+\n+    long millisPerMonth() {\n+        return (long)(365.25 * MILLIS_PER_DAY / 12);\n+    }\n+\n     boolean isLeapYear(int year) {\n         if (year == 0) {\n             throw new IllegalArgumentException(\"Illegal year: \" + year);\n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianDayOfMonthField.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianDayOfMonthField.java\n     }\n \n     public long getRangeMillis() {\n-        return (long)(365.25 * iChronology.MILLIS_PER_DAY / 12);\n+        return iChronology.millisPerMonth();\n     }\n }\n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianMonthOfYearField.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianMonthOfYearField.java\n         return iChronology.gjFromMillis(millis)[1];\n     }\n \n-    public long add(long millis, int value) {\n-\t\tint year = iChronology.year().get(millis);\n+    public long add(long millis, long value) {\n+        int year = iChronology.year().get(millis);\n         int newYear = year + (int)iChronology.div(value, 12);\n         if (year < 0) {\n             if (newYear >= 0) {\n         }\n         int newMonth = get(millis) + (int)iChronology.mod(value, 12);\n         if (newMonth > 12) {\n-\t\t\tif (newYear == -1) {\n-\t\t\t\tnewYear = 1;\n-\t\t\t} else {\n-\t\t\t\tnewYear++;\n-\t\t\t}\n+            if (newYear == -1) {\n+                newYear = 1;\n+            } else {\n+                newYear++;\n+            }\n             newMonth -= 12;\n         }\n         int newDay = iChronology.dayOfMonth().get(millis);\n         }\n         return millis;\n     }\n-\n-    public long getUnitMillis() {\n-        return (long)(365.25 * iChronology.MILLIS_PER_DAY / 12);\n-    }\n-\n-    public long getRangeMillis() {\n-        return (long)(365.25 * iChronology.MILLIS_PER_DAY);\n-    }\n }\n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java\n \n package org.joda.test.time.chrono.gj;\n \n+import org.joda.time.chrono.Utils;\n+\n /**\n  * \n  * @author Brian S O'Neill\n \n     public long addWrapped(long millis, int value) {\n         int weekyear = get(millis);\n-        int wrapped = getWrappedValue\n+        int wrapped = Utils.getWrappedValue\n             (weekyear, value, getMinimumValue(), getMaximumValue());\n-        return add(millis, wrapped - weekyear);\n+        return add(millis, (long) wrapped - weekyear);\n     }\n \n-    public long add(long millis, int value) {\n+    public long add(long millis, long value) {\n         int weekyear = get(millis);\n-        int newWeekyear = weekyear + value;\n+        int newWeekyear = weekyear + Utils.safeToInt(value);\n         if (weekyear < 0) {\n             if (newWeekyear >= 0) {\n                 newWeekyear++;\n         return set(millis, newWeekyear);\n     }\n \n-    public long getUnitMillis() {\n-        return (long)(365.25 * iChronology.MILLIS_PER_DAY);\n-    }\n-\n     public int getMinimumValue() {\n         return -100000000;\n     }\n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java\n \n package org.joda.test.time.chrono.gj;\n \n+import org.joda.time.chrono.Utils;\n+\n /**\n  * \n  * @author Brian S O'Neill\n \n     public long addWrapped(long millis, int value) {\n         int year = get(millis);\n-        int wrapped = getWrappedValue\n+        int wrapped = Utils.getWrappedValue\n             (year, value, getMinimumValue(), getMaximumValue());\n-        return add(millis, wrapped - year);\n+        return add(millis, (long) wrapped - year);\n     }\n \n-    public long add(long millis, int value) {\n+    public long add(long millis, long value) {\n         int year = get(millis);\n-        int newYear = year + value;\n+        int newYear = year + Utils.safeToInt(value);\n         if (year < 0) {\n             if (newYear >= 0) {\n                 newYear++;\n         return set(millis, newYear);\n     }\n \n-    public long getUnitMillis() {\n-        return (long)(365.25 * iChronology.MILLIS_PER_DAY);\n-    }\n-\n     public int getMinimumValue() {\n         return -100000000;\n     }\n--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java\n         return -292269053;\n     }\n     protected int getMaximumValue() {\n-        return 292272992;\n+        return 292278993;\n     }\n     protected int getCalendarValue(long millis) {\n         millis = millis + getZone().getOffset(millis);\n--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java\n         return 1;\n     }\n     protected int getMaximumValue() {\n-        return 292272992;\n+        return 292278993;\n     }\n     protected int getCalendarValue(long millis) {\n         iDate.setTime(millis);", "timestamp": 1071799656, "metainfo": ""}