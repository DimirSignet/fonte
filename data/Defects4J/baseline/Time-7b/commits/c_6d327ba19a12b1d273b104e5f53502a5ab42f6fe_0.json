{"sha": "6d327ba19a12b1d273b104e5f53502a5ab42f6fe", "log": "Fix API and Javadoc via testing   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/AbstractDuration.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractDuration.java\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Converts this duration to a TimePeriod instance using the PreciseAll type.\n-     * <p>\n-     * The PreciseAll type fixes days at 24 hours, months ay 30 days and years at 365 days\n-     * thus the time period will be precise. As a result there is no loss of precision\n-     * with regards the length of the duration and the following code will work:\n-     * <pre>\n-     * Duration dur = new Duration(123456789L);\n-     * TimePeriod period = d.toTimePeriod();\n-     * Duration dur2 = period.toDuration();\n-     * // dur.getMillis() == dur2.getMillis()\n-     * </pre>\n+     * Converts this duration to a TimePeriod instance using the All type.\n+     * <p>\n+     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If the duration is larger then the years and months fields will remain as zero,\n+     * with the duration allocated to the weeks and days fields.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n      * \n      * @return a TimePeriod created using the millisecond duration from this instance\n      */\n     public final TimePeriod toTimePeriod() {\n-        return new TimePeriod(this, DurationType.getPreciseAllType());\n+        return new TimePeriod(this, DurationType.getAllType());\n     }\n \n     /**\n      * Converts this duration to a TimePeriod instance specifying a duration type\n      * to control how the duration is split into fields.\n      * <p>\n-     * If a non-precise duration type is used, the resulting time period will only\n-     * represent an approximation of the duration. As a result it will not be\n-     * possible to call {@link TimePeriod#toDuration()} to get the duration back.\n+     * The exact impact of this method is determined by the duration type.\n+     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If the duration type is PreciseAll then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the duration type is All then the years and months fields will remain as zero,\n+     * with the duration allocated to the weeks and days fields.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n      * \n      * @param type  the duration type determining how to split the duration into fields\n      * @return a TimePeriod created using the millisecond duration from this instance\n--- a/JodaTime/src/java/org/joda/time/AbstractTimePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractTimePeriod.java\n     }\n \n     /**\n+     * Adds to each field of this period.\n+     * \n+     * @param years  amount of years to add to this period, which must be zero if unsupported\n+     * @param months  amount of months to add to this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks to add to this period, which must be zero if unsupported\n+     * @param days  amount of days to add to this period, which must be zero if unsupported\n+     * @param hours  amount of hours to add to this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes to add to this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds to add to this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds to add to this period, which must be zero if unsupported\n+     * @throws IllegalArgumentException if the period being added contains a field\n+     * not supported by this period\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void add(int years, int months, int weeks, int days,\n+                       int hours, int minutes, int seconds, int millis) {\n+        setTimePeriod(\n+            FieldUtils.safeAdd(getYears(), years),\n+            FieldUtils.safeAdd(getMonths(), months),\n+            FieldUtils.safeAdd(getWeeks(), weeks),\n+            FieldUtils.safeAdd(getDays(), days),\n+            FieldUtils.safeAdd(getHours(), hours),\n+            FieldUtils.safeAdd(getMinutes(), minutes),\n+            FieldUtils.safeAdd(getSeconds(), seconds),\n+            FieldUtils.safeAdd(getMillis(), millis)\n+        );\n+    }\n+\n+    /**\n      * Adds an interval to this one by dividing the interval into\n      * fields and calling {@link #add(ReadableTimePeriod)}.\n      * \n      */\n     protected void add(ReadableDuration duration) {\n         if (duration != null) {\n-            add(new TimePeriod(duration.getMillis()));\n+            add(new TimePeriod(duration.getMillis(), getDurationType()));\n         }\n     }\n \n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n      */\n     protected void add(long duration) {\n-        add(new TimePeriod(duration));\n+        add(new TimePeriod(duration, getDurationType()));\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/MutableTimePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/MutableTimePeriod.java\n     /**\n      * Creates a period from the given millisecond duration using AllType.\n      * <p>\n-     * The millisecond duration will be split to fields using a UTC version of\n-     * the duration type. This ensures that there are no odd effects caused by\n-     * time zones. The add methods will still use the time zone specific version\n-     * of the duration type.\n+     * The exact impact of this constructor is determined by the duration type.\n+     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If this period uses the PreciseAll duration type then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the period uses the All duration type then the years and months fields\n+     * will remain as zero, with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     /**\n      * Creates a period from the given millisecond duration.\n      * <p>\n-     * The millisecond duration will be split to fields using a UTC version of\n-     * the duration type. This ensures that there are no odd effects caused by\n-     * time zones. The add methods will still use the time zone specific version\n-     * of the duration type.\n+     * The exact impact of this constructor is determined by the duration type.\n+     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If this period uses the PreciseAll duration type then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the period uses the All duration type then the years and months fields\n+     * will remain as zero, with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n      *\n      * @param duration  the duration, in milliseconds\n      * @param type  which set of fields this duration supports\n     /**\n      * Sets all the fields in one go from a duration dividing the\n      * fields using the duration type.\n+     * <p>\n+     * The exact impact of this method is determined by the duration type.\n+     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If this period uses the PreciseAll duration type then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the period uses the All duration type then the years and months fields\n+     * will remain as zero, with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n      * \n      * @param duration  the duration to set, null means zero length\n      */\n     /**\n      * Sets all the fields in one go from a millisecond duration dividing the\n      * fields using the duration type.\n+     * <p>\n+     * The exact impact of this method is determined by the duration type.\n+     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If this period uses the PreciseAll duration type then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the period uses the All duration type then the years and months fields\n+     * will remain as zero, with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n      * \n      * @param duration  the duration, in milliseconds\n      */\n     }\n \n     /**\n+     * Adds to each field of this period.\n+     * \n+     * @param years  amount of years to add to this period, which must be zero if unsupported\n+     * @param months  amount of months to add to this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks to add to this period, which must be zero if unsupported\n+     * @param days  amount of days to add to this period, which must be zero if unsupported\n+     * @param hours  amount of hours to add to this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes to add to this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds to add to this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds to add to this period, which must be zero if unsupported\n+     * @throws IllegalArgumentException if the period being added contains a field\n+     * not supported by this period\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void add(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis) {\n+        super.add(years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n      * Adds an interval to this one by converting it to a period using the same\n      * duration type and then adding each field in turn.\n      * \n     /**\n      * Adds a duration to this one by dividing the duration into\n      * fields and then adding each field in turn.\n+     * <p>\n+     * The exact impact of this method is determined by the duration type.\n+     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If this period uses the PreciseAll duration type then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the period uses the All duration type then the years and months fields\n+     * will remain as zero, with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n      * \n      * @param duration  the duration to add, null means add nothing\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n     /**\n      * Adds a duration to this one by dividing the duration into\n      * fields and then adding each field in turn.\n+     * <p>\n+     * The exact impact of this method is determined by the duration type.\n+     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If this period uses the PreciseAll duration type then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the period uses the All duration type then the years and months fields\n+     * will remain as zero, with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n      * \n      * @param duration  the duration to add\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n--- a/JodaTime/src/java/org/joda/time/ReadWritableTimePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/ReadWritableTimePeriod.java\n     /**\n      * Sets all the fields in one go from a duration dividing the\n      * fields using the duration type.\n+     * <p>\n+     * The exact impact of this method is determined by the duration type.\n+     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If this period uses the PreciseAll duration type then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the period uses the All duration type then the years and months fields\n+     * will remain as zero, with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n      * \n      * @param duration  the duration to set, null means zero length\n      */\n     /**\n      * Sets all the fields in one go from a millisecond duration dividing the\n      * fields using the duration type.\n+     * <p>\n+     * The exact impact of this method is determined by the duration type.\n+     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If this period uses the PreciseAll duration type then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the period uses the All duration type then the years and months fields\n+     * will remain as zero, with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n      * \n      * @param duration  the duration, in milliseconds\n      */\n     void add(ReadableTimePeriod period);\n \n     /**\n+     * Adds to each field of this period.\n+     * \n+     * @param years  amount of years to add to this period, which must be zero if unsupported\n+     * @param months  amount of months to add to this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks to add to this period, which must be zero if unsupported\n+     * @param days  amount of days to add to this period, which must be zero if unsupported\n+     * @param hours  amount of hours to add to this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes to add to this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds to add to this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds to add to this period, which must be zero if unsupported\n+     * @throws IllegalArgumentException if the period being added contains a field\n+     * not supported by this period\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void add(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis);\n+\n+    /**\n      * Adds an interval to this one by dividing the interval into\n      * fields and then adding each field in turn.\n      * \n     /**\n      * Adds a duration to this one by dividing the duration into\n      * fields and then adding each field in turn.\n+     * <p>\n+     * The exact impact of this method is determined by the duration type.\n+     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If this period uses the PreciseAll duration type then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the period uses the All duration type then the years and months fields\n+     * will remain as zero, with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n      * \n      * @param duration  the duration to add, null means add nothing\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n     /**\n      * Adds a duration to this one by dividing the duration into\n      * fields and then adding each field in turn.\n+     * <p>\n+     * The exact impact of this method is determined by the duration type.\n+     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If this period uses the PreciseAll duration type then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the period uses the All duration type then the years and months fields\n+     * will remain as zero, with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n      * \n      * @param duration  the duration to add\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n--- a/JodaTime/src/java/org/joda/time/ReadableDuration.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableDuration.java\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Converts this duration to a TimePeriod instance using the PreciseAll type.\n-     * <p>\n-     * The PreciseAll type fixes days at 24 hours, months ay 30 days and years at 365 days\n-     * thus the time period will be precise. As a result there is no loss of precision\n-     * with regards the length of the duration and the following code will work:\n-     * <pre>\n-     * Duration dur = new Duration(123456789L);\n-     * TimePeriod period = d.toTimePeriod();\n-     * Duration dur2 = period.toDuration();\n-     * // dur.getMillis() == dur2.getMillis()\n-     * </pre>\n+     * Converts this duration to a TimePeriod instance using the All type.\n+     * <p>\n+     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If the duration is larger then the years and months fields will remain as zero,\n+     * with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n      * \n      * @return a TimePeriod created using the millisecond duration from this instance\n      */\n      * Converts this duration to a TimePeriod instance specifying a duration type\n      * to control how the duration is split into fields.\n      * <p>\n-     * If a non-precise duration type is used, the resulting time period will only\n-     * represent an approximation of the duration. As a result it will not be\n-     * possible to call {@link TimePeriod#toDuration()} to get the duration back.\n+     * The exact impact of this method is determined by the duration type.\n+     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If the duration type is PreciseAll then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the duration type is All then the years and months fields will remain as zero,\n+     * with the duration allocated to the weeks and days fields.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n      * \n      * @param type  the duration type determining how to split the duration into fields\n      * @return a TimePeriod created using the millisecond duration from this instance\n--- a/JodaTime/src/test/org/joda/time/TestMutablePeriod_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutablePeriod_Constructors.java\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.toDurationMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    public void testConstructor_long2() throws Throwable {\n+        long length =\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        MutableTimePeriod test = new MutableTimePeriod(length);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n         assertEquals(true, test.isPrecise());\n         assertEquals(length, test.toDurationMillis());\n     }\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.toDurationMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.toDurationMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_long_DurationType2() throws Throwable {\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.toDurationMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.toDurationMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_long_DurationType4() throws Throwable {\n-        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+        long length =\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n-        assertEquals(4, test.getDays());\n+        assertEquals(0, test.getDays());\n         assertEquals(5, test.getHours());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.toDurationMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_long_long2() throws Throwable {\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.toDurationMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.toDurationMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_long_long_DurationType2() throws Throwable {\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.toDurationMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_long_long_DurationType3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n-        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n+        DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);\n         MutableTimePeriod test = new MutableTimePeriod(dt1.getMillis(), dt2.getMillis(), DurationType.getAllType().withMillisRemoved());\n         assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.toDurationMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_RI_RI1() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n+        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(1, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(1, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(1, test.getMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.toDurationMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    public void testConstructor_RI_RI2() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n+        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         assertEquals(1, test.getHours());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.toDurationMillis());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testConstructor_RI_RI1() throws Throwable {\n-        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n-        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n-        assertEquals(1, test.getYears());\n-        assertEquals(1, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(1, test.getDays());\n-        assertEquals(1, test.getHours());\n-        assertEquals(1, test.getMinutes());\n-        assertEquals(1, test.getSeconds());\n-        assertEquals(1, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());\n-    }\n-\n-    public void testConstructor_RI_RI2() throws Throwable {\n-        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n-        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n-        assertEquals(1, test.getYears());\n-        assertEquals(1, test.getMonths());\n-        assertEquals(1, test.getWeeks());\n-        assertEquals(1, test.getDays());\n-        assertEquals(1, test.getHours());\n-        assertEquals(1, test.getMinutes());\n-        assertEquals(1, test.getSeconds());\n-        assertEquals(1, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());\n+        assertEquals(1, test.getMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.toDurationMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_RI_RI3() throws Throwable {\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(dt2.getMillis() - TEST_TIME_NOW, test.toDurationMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.toDurationMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_RI_RI4() throws Throwable {\n+        DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n+        DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n+        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(-3, test.getYears());\n+        assertEquals(-1, test.getMonths());\n+        assertEquals(-1, test.getWeeks());\n+        assertEquals(-1, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(-1, test.getMinutes());\n+        assertEquals(-1, test.getSeconds());\n+        assertEquals(-1, test.getMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.toDurationMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    public void testConstructor_RI_RI5() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n         MutableTimePeriod test = new MutableTimePeriod(dt1, dt2);\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.toDurationMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_RI_RI_DurationType2() throws Throwable {\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.toDurationMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_RI_RI_DurationType3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n-        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n+        DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);\n         MutableTimePeriod test = new MutableTimePeriod(dt1, dt2, DurationType.getAllType().withMillisRemoved());\n         assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n-        assertEquals(1, test.getYears());\n-        assertEquals(1, test.getMonths());\n-        assertEquals(1, test.getWeeks());\n-        assertEquals(1, test.getDays());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n         assertEquals(1, test.getHours());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(dt2.getMillis() - TEST_TIME_NOW, test.toDurationMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.toDurationMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_RI_RI_DurationType5() throws Throwable {\n     }\n \n     public void testConstructor_Object4() throws Throwable {\n-        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n-        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        TimePeriod base = new TimePeriod(dt1, dt2);  // AllType and precise\n+        TimePeriod base = new TimePeriod(1, 1, 0, 1, 1, 1, 1, 1, DurationType.getAllType());\n         MutableTimePeriod test = new MutableTimePeriod(base);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.toDurationMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Test constructor (Object)\n+     * Test constructor (Object,DurationType)\n      */\n     public void testConstructor_Object_DurationType1() throws Throwable {\n         MutableTimePeriod test = new MutableTimePeriod(\"P1Y2M3D\", DurationType.getYearMonthType());\n--- a/JodaTime/src/test/org/joda/time/TestMutablePeriod_Updates.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutablePeriod_Updates.java\n     }\n \n     public void testSetTimePeriod_long2() {\n+        MutableTimePeriod test = new MutableTimePeriod();\n+        test.setTimePeriod(\n+            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L);\n+            System.err.println(test);  // TODO\n+        assertEquals(1, test.getYears());  // 365\n+        assertEquals(2, test.getMonths()); // 31 + 30 (Jan + Feb)\n+        assertEquals(3, test.getWeeks());  // 3 * 7\n+        assertEquals(3, test.getDays());   // 3 left (one given to months)\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+    }\n+\n+    public void testSetTimePeriod_long3() {\n         MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearMonthType());\n         test.setTimePeriod(\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n         assertEquals(8, test.getMillis());\n     }\n \n-    public void testSetTimePeriod_long3() {\n+    public void testSetTimePeriod_long4() {\n         MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearWeekType());\n         test.setTimePeriod(\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n     }\n \n     //-----------------------------------------------------------------------\n+    public void testAdd_8ints1() {\n+        MutableTimePeriod test = new MutableTimePeriod(100L);\n+        test.add(1, 2, 3, 4, 5, 6, 7, 8);\n+        assertEquals(1, test.getYears());\n+        assertEquals(2, test.getMonths());\n+        assertEquals(3, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(108, test.getMillis());\n+    }\n+\n+    public void testAdd_8ints2() {\n+        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getYearMonthType());\n+        try {\n+            test.add(1, 2, 3, 4, 5, 6, 7, 8);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(100, test.getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testAdd_long1() {\n         MutableTimePeriod test = new MutableTimePeriod(100L);\n         test.add(100L);\n         test.add(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getWeeks());  // checks that YearMonth type is used in conversion\n         assertEquals(25, test.getDays());\n         assertEquals(5, test.getHours());\n         assertEquals(6, test.getMinutes());\n \n     public void testAdd_long4() {\n         MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        try {\n-            test.add(100L);\n-            fail();\n-        } catch (IllegalStateException ex) {}\n+        test.add(2100L);\n+        assertEquals(1, test.getYears());\n+        assertEquals(2, test.getMonths());\n+        assertEquals(3, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(9, test.getSeconds());\n+        assertEquals(108, test.getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAdd_RD1() {\n+        MutableTimePeriod test = new MutableTimePeriod(100L);\n+        test.add(new Duration(100L));\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(200, test.getMillis());\n+        assertEquals(200L, test.toDurationMillis());\n+    }\n+\n+    public void testAdd_RD2() {\n+        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getPreciseYearMonthType());\n+        long ms =\n+            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n+        test.add(new Duration(ms));\n+        assertEquals(1, test.getYears());\n+        assertEquals(2, test.getMonths());\n+        assertEquals(0, test.getWeeks());  // checks that YearMonth type is used in conversion\n+        assertEquals(25, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(108, test.getMillis());\n+        assertEquals(ms + 100L, test.toDurationMillis());\n+    }\n+\n+    public void testAdd_RD3() {\n+        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getPreciseYearMonthType());\n+        long ms =0L;\n+        test.add(new Duration(ms));\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(100, test.getMillis());\n+        assertEquals(100L, test.toDurationMillis());\n+    }\n+\n+    public void testAdd_RD4() {\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test.add(new Duration(2100L));\n+        assertEquals(1, test.getYears());\n+        assertEquals(2, test.getMonths());\n+        assertEquals(3, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(9, test.getSeconds());\n+        assertEquals(108, test.getMillis());\n+    }\n+\n+    public void testAdd_RD5() {\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test.add((ReadableDuration) null);\n+        assertEquals(1, test.getYears());\n+        assertEquals(2, test.getMonths());\n+        assertEquals(3, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n     }\n \n     //-----------------------------------------------------------------------\n     }\n \n     public void testAdd_RP2() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getPreciseYearMonthType());\n-        test.add(new TimePeriod(1, 0, 12, 1, 5, 6, 7, 8, DurationType.getPreciseYearWeekType()));\n-        assertEquals(1, test.getYears());\n-        assertEquals(2, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(25, test.getDays());\n+        MutableTimePeriod test = new MutableTimePeriod(100L);  // All type\n+        test.add(new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getPreciseAllType()));\n+        assertEquals(1, test.getYears());  // add field value, ignore different types\n+        assertEquals(2, test.getMonths());  // add field value, ignore different types\n+        assertEquals(3, test.getWeeks());  // add field value, ignore different types\n+        assertEquals(4, test.getDays());  // add field value, ignore different types\n         assertEquals(5, test.getHours());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n     }\n \n     public void testAdd_RP4() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 0, 4, 5, 6, 7, 8, DurationType.getYearMonthType());\n         try {\n-            test.add(new TimePeriod(100L));\n+            test.add(new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8));  // cannot set weeks\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (IllegalArgumentException ex) {}\n+        assertEquals(1, test.getYears());\n+        assertEquals(2, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n     }\n \n     public void testAdd_RP5() {\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test.add((ReadableTimePeriod) null);\n+        assertEquals(1, test.getYears());\n+        assertEquals(2, test.getMonths());\n+        assertEquals(3, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAdd_RInterval1() {\n         MutableTimePeriod test = new MutableTimePeriod(100L);\n-        try {\n-            test.add(new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8));\n-            fail();\n-        } catch (IllegalStateException ex) {}\n-    }\n-\n-    public void testAdd_RP6() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        test.add((ReadableTimePeriod) null);\n+        test.add(new Interval(100L, 200L));\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(200, test.getMillis());\n+        assertEquals(200L, test.toDurationMillis());\n+    }\n+\n+    public void testAdd_RInterval2() {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 12, 18, 0, 0, 0, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(100L);  // All type\n+        test.add(new Interval(dt1, dt2));\n+        assertEquals(1, test.getYears());  // add field value from interval\n+        assertEquals(6, test.getMonths());  // add field value from interval\n+        assertEquals(1, test.getWeeks());  // add field value from interval\n+        assertEquals(2, test.getDays());  // add field value from interval\n+        assertEquals(0, test.getHours());  // time zone OK\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(108, test.getMillis());\n+    }\n+\n+    public void testAdd_RInterval3() {\n+        DateTime dt1 = new DateTime(2005, 12, 18, 0, 0, 0, 8);\n+        DateTime dt2 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        MutableTimePeriod test = new MutableTimePeriod(100L);  // All type\n+        test.add(new Interval(dt1, dt2));\n+        assertEquals(-1, test.getYears());  // add field value from interval\n+        assertEquals(-6, test.getMonths());  // add field value from interval\n+        assertEquals(-1, test.getWeeks());  // add field value from interval\n+        assertEquals(-2, test.getDays());  // add field value from interval\n+        assertEquals(0, test.getHours());  // time zone OK\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(92, test.getMillis());\n+    }\n+\n+    public void testAdd_RInterval4() {\n+        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getPreciseYearMonthType());\n+        test.add(new Interval(0L, 0L));\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(100, test.getMillis());\n+    }\n+\n+    public void testAdd_RInterval5() {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 7, 17, 0, 0, 0, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getYearMonthType());\n+        test.add(new Interval(dt1, dt2));\n+        assertEquals(1, test.getYears());\n+        assertEquals(1, test.getMonths());\n+        assertEquals(0, test.getWeeks());  // no weeks\n+        assertEquals(8, test.getDays());  // week added to days\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(108, test.getMillis());\n+    }\n+\n+    public void testAdd_RInterval6() {\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test.add((ReadableInterval) null);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(3, test.getWeeks());", "timestamp": 1091817517, "metainfo": ""}