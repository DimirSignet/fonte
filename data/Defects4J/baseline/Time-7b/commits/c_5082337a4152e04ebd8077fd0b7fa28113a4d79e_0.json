{"sha": "5082337a4152e04ebd8077fd0b7fa28113a4d79e", "log": "Refactor DateTime formatting to use decoration pattern   ", "commit": "\n--- a/JodaTime/src/example/org/joda/example/time/TimeZoneTable.java\n+++ b/JodaTime/src/example/org/joda/example/time/TimeZoneTable.java\n             while (iZone.getOffset(millis) != iZone.getStandardOffset(millis)) {\n                 millis = iZone.nextTransition(millis);\n             }\n-            return cOffsetFormatter.print(millis, iZone);\n+            return cOffsetFormatter.withZone(iZone).print(millis);\n         }\n \n         public int compareTo(Object obj) {\n--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java\n             };\n         }\n \n-        return -(int) offsetFormatter().parseMillis(str, chrono);\n+        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java\n      * @return ISO8601 time formatted string.\n      */\n     public String toString() {\n-        return ISODateTimeFormat.getInstance().dateTime().print(this);\n+        return ISODateTimeFormat.dateTime().print(this);\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/TimeOfDay.java\n+++ b/JodaTime/src/java/org/joda/time/TimeOfDay.java\n      * @return ISO8601 formatted string\n      */\n     public String toString() {\n-        return ISODateTimeFormat.getInstance().tTime().print(this);\n+        return ISODateTimeFormat.tTime().print(this);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/YearMonthDay.java\n+++ b/JodaTime/src/java/org/joda/time/YearMonthDay.java\n      * @return ISO8601 formatted string\n      */\n     public String toString() {\n-        return ISODateTimeFormat.getInstance().yearMonthDay().print(this);\n+        return ISODateTimeFormat.yearMonthDay().print(this);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/base/AbstractDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractDateTime.java\n         if (pattern == null) {\n             return toString();\n         }\n-        return DateTimeFormat.getInstance().forPattern(pattern).print(this);\n+        return DateTimeFormat.forPattern(pattern).print(this);\n     }\n \n     /**\n         if (pattern == null) {\n             return toString();\n         }\n-        return DateTimeFormat.getInstance(locale).forPattern(pattern).print(this);\n+        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/base/AbstractInstant.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractInstant.java\n      * @return ISO8601 time formatted string.\n      */\n     public String toString() {\n-        return ISODateTimeFormat.getInstance().dateTime().print(this);\n+        return ISODateTimeFormat.dateTime().print(this);\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/base/AbstractInterval.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractInterval.java\n import org.joda.time.ReadableInstant;\n import org.joda.time.ReadableInterval;\n import org.joda.time.field.FieldUtils;\n-import org.joda.time.format.DateTimePrinter;\n+import org.joda.time.format.DateTimeFormatter;\n import org.joda.time.format.ISODateTimeFormat;\n \n /**\n      * @return re-parsable string\n      */\n     public String toString() {\n-        DateTimePrinter printer = ISODateTimeFormat.getInstance().dateHourMinuteSecondFraction();\n+        DateTimeFormatter printer = ISODateTimeFormat.dateHourMinuteSecondFraction();\n+        printer = printer.withChronology(getChronology());\n         StringBuffer buf = new StringBuffer(48);\n-        printer.printTo(buf, getStartMillis(), getChronology());\n+        printer.printTo(buf, getStartMillis());\n         buf.append('/');\n-        printer.printTo(buf, getEndMillis(), getChronology());\n+        printer.printTo(buf, getEndMillis());\n         return buf.toString();\n     }\n \n--- a/JodaTime/src/java/org/joda/time/base/BasePartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/BasePartial.java\n         if (pattern == null) {\n             return toString();\n         }\n-        return DateTimeFormat.getInstance().forPattern(pattern).print(this);\n+        return DateTimeFormat.forPattern(pattern).print(this);\n     }\n \n     /**\n         if (pattern == null) {\n             return toString();\n         }\n-        return DateTimeFormat.getInstance(locale).forPattern(pattern).print(this);\n+        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n import org.joda.time.ReadableInstant;\n import org.joda.time.field.BaseDateTimeField;\n import org.joda.time.field.DecoratedDurationField;\n-import org.joda.time.format.DateTimePrinter;\n+import org.joda.time.format.DateTimeFormatter;\n import org.joda.time.format.ISODateTimeFormat;\n \n /**\n         \n         if (iCutoverMillis != DEFAULT_CUTOVER.getMillis()) {\n             sb.append(\",cutover=\");\n-            DateTimePrinter printer;\n+            DateTimeFormatter printer;\n             if (withUTC().dayOfYear().remainder(iCutoverMillis) == 0) {\n-                printer = ISODateTimeFormat.getInstance().date();\n-            } else {\n-                printer = ISODateTimeFormat.getInstance().dateTime();\n-            }\n-            printer.printTo(sb, iCutoverMillis, withUTC());\n+                printer = ISODateTimeFormat.date();\n+            } else {\n+                printer = ISODateTimeFormat.dateTime();\n+            }\n+            printer.withChronology(withUTC()).printTo(sb, iCutoverMillis);\n         }\n         \n         if (getMinimumDaysInFirstWeek() != 4) {\n--- a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java\n import org.joda.time.ReadableDateTime;\n import org.joda.time.field.DecoratedDateTimeField;\n import org.joda.time.field.DecoratedDurationField;\n-import org.joda.time.format.DateTimePrinter;\n+import org.joda.time.format.DateTimeFormatter;\n import org.joda.time.format.ISODateTimeFormat;\n \n /**\n             }\n             buf.append(\" instant is \");\n \n-            DateTimePrinter p = ISODateTimeFormat.getInstance().dateTime();\n-\n+            DateTimeFormatter p = ISODateTimeFormat.dateTime();\n+            p = p.withChronology(getBase());\n             if (iIsLow) {\n                 buf.append(\"below the supported minimum of \");\n-                p.printTo(buf, getLowerLimit().getMillis(), getBase());\n+                p.printTo(buf, getLowerLimit().getMillis());\n             } else {\n                 buf.append(\"above the supported maximum of \");\n-                p.printTo(buf, getUpperLimit().getMillis(), getBase());\n+                p.printTo(buf, getUpperLimit().getMillis());\n             }\n             \n             buf.append(\" (\");\n--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n import org.joda.time.ReadWritableInterval;\n import org.joda.time.ReadWritablePeriod;\n import org.joda.time.field.FieldUtils;\n-import org.joda.time.format.DateTimeParser;\n+import org.joda.time.format.DateTimeFormatter;\n import org.joda.time.format.ISODateTimeFormat;\n import org.joda.time.format.ISOPeriodFormat;\n import org.joda.time.format.PeriodFormatter;\n      */\n     public long getInstantMillis(Object object, Chronology chrono) {\n         String str = (String) object;\n-        DateTimeParser p = ISODateTimeFormat.getInstance().dateTimeParser();\n-        return p.parseMillis(str, chrono);\n+        DateTimeFormatter p = ISODateTimeFormat.dateTimeParser();\n+        return p.withChronology(chrono).parseMillis(str);\n     }\n \n     //-----------------------------------------------------------------------\n             throw new IllegalArgumentException(\"Format invalid: \" + str);\n         }\n \n-        DateTimeParser dateTimeParser = ISODateTimeFormat.getInstance().dateTimeParser();\n+        DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser();\n+        dateTimeParser = dateTimeParser.withChronology(chrono);\n         PeriodFormatter periodParser = ISOPeriodFormat.getInstance().standard();\n         long startInstant = 0, endInstant = 0;\n         Period period = null;\n         if (c == 'P' || c == 'p') {\n             period = periodParser.parsePeriod(getPeriodType(leftStr), leftStr);\n         } else {\n-            DateTime start = dateTimeParser.parseDateTime(leftStr, chrono);\n+            DateTime start = dateTimeParser.parseDateTime(leftStr);\n             startInstant = start.getMillis();\n             parsedChrono = start.getChronology();\n         }\n             chrono = (chrono != null ? chrono : parsedChrono);\n             endInstant = chrono.add(period, startInstant, 1);\n         } else {\n-            DateTime end = dateTimeParser.parseDateTime(rightStr, chrono);\n+            DateTime end = dateTimeParser.parseDateTime(rightStr);\n             endInstant = end.getMillis();\n             parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology());\n             chrono = (chrono != null ? chrono : parsedChrono);\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n import java.util.Map;\n \n import org.joda.time.Chronology;\n-import org.joda.time.DateTime;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeZone;\n import org.joda.time.DurationFieldType;\n-import org.joda.time.MutableDateTime;\n-import org.joda.time.ReadWritableInstant;\n-import org.joda.time.ReadableInstant;\n import org.joda.time.ReadablePartial;\n import org.joda.time.field.RemainderDateTimeField;\n \n  */\n public class DateTimeFormat {\n \n-    /**\n-     * Cache that maps Chronology instances to maps that map\n-     * Locales to DateTimeFormat instances.\n-     */\n-    private static Map cInstanceCache = new HashMap(7);\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets an instance of the formatter provider that works with the default locale.\n-     * \n-     * @return a format provider\n+    /** Style constant for FULL. */\n+    static final int FULL = 0;  // DateFormat.FULL\n+    /** Style constant for LONG. */\n+    static final int LONG = 1;  // DateFormat.LONG\n+    /** Style constant for MEDIUM. */\n+    static final int MEDIUM = 2;  // DateFormat.MEDIUM\n+    /** Style constant for SHORT. */\n+    static final int SHORT = 3;  // DateFormat.SHORT\n+    /** Style constant for NONE. */\n+    static final int NONE = 4;\n+\n+    /** Type constant for DATE only. */\n+    static final int DATE = 0;\n+    /** Type constant for TIME only. */\n+    static final int TIME = 1;\n+    /** Type constant for DATETIME. */\n+    static final int DATETIME = 2;\n+\n+    /** Maps patterns to formatters, patterns don't vary by locale. */\n+    private static final Map cPatternedCache = new HashMap(7);\n+    /** Maps patterns to formatters, patterns don't vary by locale. */\n+    private static final DateTimeFormatter[] cStyleCache = new DateTimeFormatter[25];\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Factory to create a formatter from a pattern string.\n+     * The pattern string is encoded as per SimpleDateFormat.\n+     *\n+     * @param pattern  pattern specification\n+     * @return the formatter\n+     * @throws IllegalArgumentException if the pattern is invalid\n+     */\n+    public static DateTimeFormatter forPattern(String pattern) {\n+        return createFormatterForPattern(pattern);\n+    }\n+\n+    /**\n+     * Factory to create a format from a two character style pattern.\n+     * <p>\n+     * The first character is the date style, and the second character is the\n+     * time style. Specify a character of 'S' for short style, 'M' for medium,\n+     * 'L' for long, and 'F' for full.\n+     * A date or time may be ommitted by specifying a style character '-'.\n+     * <p>\n+     * The returned formatter will dynamically adjust to the locale that\n+     * the print/parse takes place in. Thus you just call\n+     * {@link DateTimeFormatter#withLocale(Locale)} and the Short/Medium/Long/Full\n+     * style for that locale will be output.\n+     *\n+     * @param style  two characters from the set {\"S\", \"M\", \"L\", \"F\", \"-\"}\n+     * @return the formatter\n+     * @throws IllegalArgumentException if the style is invalid\n+     */\n+    public static DateTimeFormatter forStyle(String style) {\n+        return createFormatterForStyle(style);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a format that outputs a short date format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter shortDate() {\n+        return createFormatterForStyleIndex(SHORT, NONE);\n+    }\n+\n+    /**\n+     * Creates a format that outputs a medium date format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter mediumDate() {\n+        return createFormatterForStyleIndex(MEDIUM, NONE);\n+    }\n+\n+    /**\n+     * Creates a format that outputs a long date format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter longDate() {\n+        return createFormatterForStyleIndex(LONG, NONE);\n+    }\n+\n+    /**\n+     * Creates a format that outputs a full date format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter fullDate() {\n+        return createFormatterForStyleIndex(FULL, NONE);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a format that outputs a short time format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter shortTime() {\n+        return createFormatterForStyleIndex(NONE, SHORT);\n+    }\n+\n+    /**\n+     * Creates a format that outputs a medium time format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter mediumTime() {\n+        return createFormatterForStyleIndex(NONE, MEDIUM);\n+    }\n+\n+    /**\n+     * Creates a format that outputs a long time format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter longTime() {\n+        return createFormatterForStyleIndex(NONE, LONG);\n+    }\n+\n+    /**\n+     * Creates a format that outputs a full time format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter fullTime() {\n+        return createFormatterForStyleIndex(NONE, FULL);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a format that outputs a short datetime format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter shortDateTime() {\n+        return createFormatterForStyleIndex(SHORT, SHORT);\n+    }\n+\n+    /**\n+     * Creates a format that outputs a medium datetime format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter mediumDateTime() {\n+        return createFormatterForStyleIndex(MEDIUM, MEDIUM);\n+    }\n+\n+    /**\n+     * Creates a format that outputs a long datetime format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter longDateTime() {\n+        return createFormatterForStyleIndex(LONG, LONG);\n+    }\n+\n+    /**\n+     * Creates a format that outputs a full datetime format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter fullDateTime() {\n+        return createFormatterForStyleIndex(FULL, FULL);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Parses the given pattern and appends the rules to the given\n+     * DateTimeFormatterBuilder.\n+     *\n+     * @param pattern  pattern specification\n+     * @throws IllegalArgumentException if the pattern is invalid\n+     */\n+    static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n+        parsePatternTo(builder, pattern);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Deprecated, methods on DateTimeFormat are now static.\n+     * \n+     * @deprecated remove this call as the methods are now static\n      */\n     public static DateTimeFormat getInstance() {\n-        return getInstance(Locale.getDefault());\n-    }\n-\n-    /**\n-     * Gets an instance of the formatter provider that works with the given locale.\n-     * \n-     * @param locale  the Locale to use, null for default locale\n-     * @return a format provider\n-     */\n-    public synchronized static DateTimeFormat getInstance(Locale locale) {\n-        if (locale == null) {\n-            locale = Locale.getDefault();\n-        }\n-        DateTimeFormat dtf = (DateTimeFormat) cInstanceCache.get(locale);\n-        if (dtf == null) {\n-            dtf = new DateTimeFormat(locale);\n-            cInstanceCache.put(locale, dtf);\n-        }\n-        return dtf;\n+        return new DateTimeFormat();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     */\n+    private DateTimeFormat() {\n+        super();\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws IllegalArgumentException if the pattern is invalid\n      * @see #forPattern\n      */\n-    public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n+    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n         int length = pattern.length();\n         int[] indexRef = new int[1];\n \n         }\n     }\n \n-    private static String parseToken(final String pattern, final int[] indexRef) {\n+    /**\n+     * Parses an individual token.\n+     * \n+     * @param pattern  the pattern string\n+     * @param indexRef  a single element array, where the input is the start\n+     *  location and the output is the location after parsing the token\n+     * @return the parsed token\n+     */\n+    private static String parseToken(String pattern, int[] indexRef) {\n         StringBuffer buf = new StringBuffer();\n \n         int i = indexRef[0];\n         return buf.toString();\n     }\n \n-    // Returns true if token should be parsed as a numeric field.\n-    private static boolean isNumericToken(final String token) {\n+    /**\n+     * Returns true if token should be parsed as a numeric field.\n+     * \n+     * @param token  the token to parse\n+     * @return true if numeric field\n+     */\n+    private static boolean isNumericToken(String token) {\n         int tokenLen = token.length();\n         if (tokenLen > 0) {\n             char c = token.charAt(0);\n     }\n \n     //-----------------------------------------------------------------------\n-    /** The locale to use */\n-    private final Locale iLocale;\n-\n-    /** Maps patterns to formatters */\n-    private transient Map iPatternedCache = new HashMap(7);\n-\n-    /** Maps styles to formatters */\n-    private transient Map iStyledCache = new HashMap(7);\n-\n-    /**\n-     * Constructor.\n-     * \n-     * @param locale  the locale to use, must not be null\n-     */\n-    private DateTimeFormat(final Locale locale) {\n-        super();\n-        iLocale = locale;\n-    }\n-\n-    //-----------------------------------------------------------------------\n     /**\n      * Select a format from a custom pattern.\n      *\n      * @throws IllegalArgumentException if the pattern is invalid\n      * @see #appendPatternTo\n      */\n-    public synchronized DateTimeFormatter forPattern(final String pattern) {\n-        DateTimeFormatter formatter = (DateTimeFormatter) iPatternedCache.get(pattern);\n-        if (formatter != null) {\n-            return formatter;\n-        }\n-\n+    private static DateTimeFormatter createFormatterForPattern(String pattern) {\n         if (pattern == null) {\n             throw new IllegalArgumentException(\"Invalid pattern specification\");\n         }\n-\n-        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(iLocale);\n-        appendPatternTo(builder, pattern);\n-\n-        if (builder.canBuildFormatter()) {\n-            formatter = builder.toFormatter();\n-        } else if (builder.canBuildPrinter()) {\n-            formatter = new FPrinter(builder.toPrinter());\n-        } else if (builder.canBuildParser()) {\n-            // I don't expect this case to ever occur.\n-            formatter = new FParser(builder.toParser());\n-        } else {\n-            throw new UnsupportedOperationException(\"Pattern unsupported: \" + pattern);\n-        }\n-\n-        iPatternedCache.put(pattern, formatter);\n+        DateTimeFormatter formatter = null;\n+        synchronized (cPatternedCache) {\n+            formatter = (DateTimeFormatter) cPatternedCache.get(pattern);\n+            if (formatter == null) {\n+                DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n+                parsePatternTo(builder, pattern);\n+                formatter = builder.toFormatter();\n+\n+                cPatternedCache.put(pattern, formatter);\n+            }\n+        }\n         return formatter;\n     }\n \n      * @param style  two characters from the set {\"S\", \"M\", \"L\", \"F\", \"-\"}\n      * @throws IllegalArgumentException if the style is invalid\n      */\n-    public synchronized DateTimeFormatter forStyle(final String style) {\n-        DateTimeFormatter formatter = (DateTimeFormatter)iStyledCache.get(style);\n-        if (formatter == null) {\n-            formatter = forPattern(getPatternForStyle(style));\n-            iStyledCache.put(style, formatter);\n-        }\n-        return formatter;\n-    }\n-\n-    /**\n-     * Returns a pattern specification from a two character style. The first\n-     * character is the date style, and the second character is the time\n-     * style. Specify a character of 'S' for short style, 'M' for medium, 'L'\n-     * for long, and 'F' for full. A date or time may be ommitted by specifying\n-     * a style character '-'.\n-     *\n-     * @param style  two characters from the set {\"S\", \"M\", \"L\", \"F\", \"-\"}\n-     * @throws IllegalArgumentException if the style is invalid\n-     */\n-    public String getPatternForStyle(final String style) {\n+    private static DateTimeFormatter createFormatterForStyle(String style) {\n         if (style == null || style.length() != 2) {\n             throw new IllegalArgumentException(\"Invalid style specification: \" + style);\n         }\n-\n-        if (style.charAt(1) == '-') {\n-            // date only\n-            return getDatePattern(style.charAt(0));\n-        } else if (style.charAt(0) == '-') {\n-            // time only\n-            return getTimePattern(style.charAt(1));\n-        } else {\n-            // datetime\n-            return getDateTimePattern(style.charAt(0), style.charAt(1));\n-        }\n-    }\n-\n-    private String getDatePattern(final char style) {\n-        int istyle = selectStyle(style);\n-        try {\n-            return ((SimpleDateFormat)DateFormat.getDateInstance(istyle, iLocale)).toPattern();\n-        } catch (ClassCastException e) {\n-            throw new IllegalArgumentException(\"No date pattern for locale: \" + iLocale);\n-        }\n-    }\n-\n-    private String getTimePattern(final char style) {\n-        int istyle = selectStyle(style);\n-        try {\n-            return ((SimpleDateFormat)DateFormat.getTimeInstance(istyle, iLocale)).toPattern();\n-        } catch (ClassCastException e) {\n-            throw new IllegalArgumentException(\"No time pattern for locale: \" + iLocale);\n-        }\n-    }\n-\n-    private String getDateTimePattern(final char dateStyle, final char timeStyle) {\n-        int idateStyle = selectStyle(dateStyle);\n-        int itimeStyle = selectStyle(timeStyle);\n-        try {\n-            return ((SimpleDateFormat)DateFormat.getDateTimeInstance\n-                    (idateStyle, itimeStyle, iLocale)).toPattern();\n-        } catch (ClassCastException e) {\n-            throw new IllegalArgumentException(\"No datetime pattern for locale: \" + iLocale);\n-        }\n-    }\n-\n-    private int selectStyle(final char c) {\n-        switch (c) {\n+        int dateStyle = selectStyle(style.charAt(0));\n+        int timeStyle = selectStyle(style.charAt(1));\n+        if (dateStyle == NONE && timeStyle == NONE) {\n+            throw new IllegalArgumentException(\"Style '--' is invalid\");\n+        }\n+        return createFormatterForStyleIndex(dateStyle, timeStyle);\n+    }\n+\n+    /**\n+     * Gets the formatter for the specified style.\n+     * \n+     * @param dateStyle  the date style\n+     * @param timeStyle  the time style\n+     * @return the formatter\n+     */\n+    private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle) {\n+        int index = dateStyle * 5 + timeStyle;\n+        DateTimeFormatter f = null;\n+        synchronized (cStyleCache) {\n+            f = cStyleCache[index];\n+            if (f == null) {\n+                int type = DATETIME;\n+                if (dateStyle == NONE) {\n+                    type = TIME;\n+                } else if (timeStyle == NONE) {\n+                    type = DATE;\n+                }\n+                LengthLocaleFormatter llf = new LengthLocaleFormatter(\n+                        dateStyle, timeStyle, type);\n+                f = new DateTimeFormatter(llf, llf);\n+                cStyleCache[index] = f;\n+            }\n+        }\n+        return f;\n+    }\n+\n+    /**\n+     * Gets the JDK style code from the Joda code.\n+     * \n+     * @param ch  the Joda style code\n+     * @return the JDK style code\n+     */\n+    private static int selectStyle(char ch) {\n+        switch (ch) {\n         case 'S':\n-            return DateFormat.SHORT;\n+            return SHORT;\n         case 'M':\n-            return DateFormat.MEDIUM;\n+            return MEDIUM;\n         case 'L':\n-            return DateFormat.LONG;\n+            return LONG;\n         case 'F':\n-            return DateFormat.FULL;\n+            return FULL;\n+        case '-':\n+            return NONE;\n         default:\n-            throw new IllegalArgumentException(\"Invalid style character: \" + c);\n+            throw new IllegalArgumentException(\"Invalid style character: \" + ch);\n         }\n     }\n \n         }\n     }\n \n-    /**\n-     * A fake formatter that can only print.\n-     */\n-    static class FPrinter implements DateTimeFormatter {\n-        private final DateTimePrinter iPrinter;\n-\n-        FPrinter(DateTimePrinter printer) {\n+    //-----------------------------------------------------------------------\n+    static class LengthLocaleFormatter\n+            implements DateTimePrinter, DateTimeParser {\n+\n+        private static final Map cCache = new HashMap();  // manual sync\n+        \n+        private final int iDateStyle;\n+        private final int iTimeStyle;\n+        private final int iType;\n+\n+        LengthLocaleFormatter(int dateStyle, int timeStyle, int type) {\n             super();\n-            iPrinter = printer;\n+            iDateStyle = dateStyle;\n+            iTimeStyle = timeStyle;\n+            iType = type;\n         }\n \n         public int estimatePrintedLength() {\n-            return iPrinter.estimatePrintedLength();\n-        }\n-\n-        public void printTo(StringBuffer buf, ReadableInstant instant) {\n-            iPrinter.printTo(buf, instant);\n-        }\n-\n-        public void printTo(Writer out, ReadableInstant instant) throws IOException {\n-            iPrinter.printTo(out, instant);\n-        }\n-\n-        public void printTo(StringBuffer buf, long instant) {\n-            iPrinter.printTo(buf, instant);\n-        }\n-\n-        public void printTo(Writer out, long instant) throws IOException {\n-            iPrinter.printTo(out, instant);\n-        }\n-\n-        public void printTo(StringBuffer buf, long instant, DateTimeZone zone) {\n-            iPrinter.printTo(buf, instant, zone);\n-        }\n-\n-        public void printTo(Writer out, long instant, DateTimeZone zone)\n-            throws IOException {\n-            iPrinter.printTo(out, instant, zone);\n-        }\n-\n-        public void printTo(StringBuffer buf, long instant, Chronology chrono) {\n-            iPrinter.printTo(buf, instant, chrono);\n-        }\n-\n-        public void printTo(Writer out, long instant, Chronology chrono) throws IOException {\n-            iPrinter.printTo(out, instant, chrono);\n-        }\n-\n-        public void printTo(StringBuffer buf, long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) {\n-            iPrinter.printTo(buf, instant, chrono, displayOffset, displayZone);\n-        }\n-\n-        public void printTo(Writer out, long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) throws IOException {\n-            iPrinter.printTo(out, instant, chrono, displayOffset, displayZone);\n-        }\n-\n-        public void printTo(StringBuffer buf, ReadablePartial instant) {\n-            iPrinter.printTo(buf, instant);\n-        }\n-\n-        public void printTo(Writer out, ReadablePartial instant) throws IOException {\n-            iPrinter.printTo(out, instant);\n-        }\n-\n-        public String print(ReadableInstant instant) {\n-            return iPrinter.print(instant);\n-        }\n-\n-        public String print(long instant) {\n-            return iPrinter.print(instant);\n-        }\n-\n-        public String print(long instant, DateTimeZone zone) {\n-            return iPrinter.print(instant, zone);\n-        }\n-\n-        public String print(long instant, Chronology chrono) {\n-            return iPrinter.print(instant, chrono);\n-        }\n-\n-        public String print(long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) {\n-            return iPrinter.print(instant, chrono, displayOffset, displayZone);\n-        }\n-\n-        public String print(ReadablePartial partial) {\n-            return iPrinter.print(partial);\n+            return 40;  // guess\n+        }\n+\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n+            DateTimePrinter p = getFormatter(locale).getPrinter();\n+            p.printTo(buf, instant, chrono, displayOffset, displayZone, locale);\n+        }\n+\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n+            DateTimePrinter p = getFormatter(locale).getPrinter();\n+            p.printTo(out, instant, chrono, displayOffset, displayZone, locale);\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n+            DateTimePrinter p = getFormatter(locale).getPrinter();\n+            p.printTo(buf, partial, locale);\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n+            DateTimePrinter p = getFormatter(locale).getPrinter();\n+            p.printTo(out, partial, locale);\n         }\n \n         public int estimateParsedLength() {\n-            return 0;\n+            return 40;  // guess\n         }\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n-            throw unsupported();\n-        }\n-\n-        public int parseInto(ReadWritableInstant instant, String text, int position) {\n-            throw unsupported();\n-        }\n-\n-        public long parseMillis(String text) {\n-            throw unsupported();\n-        }\n-\n-        public long parseMillis(String text, Chronology chrono) {\n-            throw unsupported();\n-        }\n-\n-        public long parseMillis(String text, long instantLocal) {\n-            throw unsupported();\n-        }\n-\n-        public long parseMillis(String text, long instant, Chronology chrono) {\n-            throw unsupported();\n-        }\n-\n-        public DateTime parseDateTime(String text) {\n-            throw unsupported();\n-        }\n-\n-        public DateTime parseDateTime(String text, Chronology chrono) {\n-            throw unsupported();\n-        }\n-\n-        public DateTime parseDateTime(String text, ReadableInstant instant) {\n-            throw unsupported();\n-        }\n-\n-        public MutableDateTime parseMutableDateTime(String text) {\n-            throw unsupported();\n-        }\n-\n-        public MutableDateTime parseMutableDateTime(String text, Chronology chrono) {\n-            throw unsupported();\n-        }\n-\n-        public MutableDateTime parseMutableDateTime(String text,\n-                                                    ReadableInstant instant) {\n-            throw unsupported();\n-        }\n-\n-        private UnsupportedOperationException unsupported() {\n-            return new UnsupportedOperationException(\"Parsing not supported\");\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * A fake formatter that can only parse.\n-     */\n-    static class FParser implements DateTimeFormatter {\n-        private final DateTimeParser iParser;\n-\n-        FParser(DateTimeParser parser) {\n-            super();\n-            iParser = parser;\n-        }\n-\n-        public int estimatePrintedLength() {\n-            return 0;\n-        }\n-\n-        public void printTo(StringBuffer buf, ReadableInstant instant) {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(Writer out, ReadableInstant instant) throws IOException {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(StringBuffer buf, long instant) {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(Writer out, long instant) throws IOException {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(StringBuffer buf, long instant, DateTimeZone zone) {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(Writer out, long instant, DateTimeZone zone) {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(StringBuffer buf, long instant, Chronology chrono) {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(Writer out, long instant, Chronology chrono) throws IOException {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(StringBuffer buf, long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(Writer out, long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) throws IOException {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(StringBuffer buf, ReadablePartial instant) {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(Writer out, ReadablePartial instant) throws IOException {\n-            throw unsupported();\n-        }\n-\n-        public String print(ReadableInstant instant) {\n-            throw unsupported();\n-        }\n-\n-        public String print(long instant) {\n-            throw unsupported();\n-        }\n-\n-        public String print(long instant, DateTimeZone zone) {\n-            throw unsupported();\n-        }\n-\n-        public String print(long instant, Chronology chrono) {\n-            throw unsupported();\n-        }\n-\n-        public String print(long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) {\n-            throw unsupported();\n-        }\n-\n-        public String print(ReadablePartial partial) {\n-            throw unsupported();\n-        }\n-\n-        public int estimateParsedLength() {\n-            return iParser.estimateParsedLength();\n-        }\n-\n-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n-            return iParser.parseInto(bucket, text, position);\n-        }\n-\n-        public int parseInto(ReadWritableInstant instant, String text, int position) {\n-            return iParser.parseInto(instant, text, position);\n-        }\n-\n-        public long parseMillis(String text) {\n-            return iParser.parseMillis(text);\n-        }\n-\n-        public long parseMillis(String text, Chronology chrono) {\n-            return iParser.parseMillis(text, chrono);\n-        }\n-\n-        public long parseMillis(String text, long instant) {\n-            return iParser.parseMillis(text, instant);\n-        }\n-\n-        public long parseMillis(String text, long instant, Chronology chrono) {\n-            return iParser.parseMillis(text, instant, chrono);\n-        }\n-\n-        public DateTime parseDateTime(String text) {\n-            return iParser.parseDateTime(text);\n-        }\n-\n-        public DateTime parseDateTime(String text, Chronology chrono) {\n-            return iParser.parseDateTime(text, chrono);\n-        }\n-\n-        public DateTime parseDateTime(String text, ReadableInstant instant) {\n-            return iParser.parseDateTime(text, instant);\n-        }\n-\n-        public MutableDateTime parseMutableDateTime(String text) {\n-            return iParser.parseMutableDateTime(text);\n-        }\n-\n-        public MutableDateTime parseMutableDateTime(String text, Chronology chrono) {\n-            return iParser.parseMutableDateTime(text, chrono);\n-        }\n-\n-        public MutableDateTime parseMutableDateTime(String text, ReadableInstant instant) {\n-            return iParser.parseMutableDateTime(text, instant);\n-        }\n-\n-        private UnsupportedOperationException unsupported() {\n-            return new UnsupportedOperationException(\"Printing not supported\");\n-        }\n-    }\n+            DateTimeParser p = getFormatter(bucket.getLocale()).getParser();\n+            return p.parseInto(bucket, text, position);\n+        }\n+\n+        private DateTimeFormatter getFormatter(Locale locale) {\n+            String key = Integer.toString(iType + iDateStyle << 4 + iTimeStyle << 8) + locale.toString();\n+            DateTimeFormatter f = null;\n+            synchronized (cCache) {\n+                f = (DateTimeFormatter) cCache.get(key);\n+                if (f == null) {\n+                    String pattern = getPattern(locale);\n+                    f = DateTimeFormat.forPattern(pattern);\n+                    cCache.put(key, f);\n+                }\n+            }\n+            return f;\n+        }\n+\n+        private String getPattern(Locale locale) {\n+            DateFormat f = null;\n+            switch (iType) {\n+                case DATE:\n+                    f = DateFormat.getDateInstance(iDateStyle, locale);\n+                    break;\n+                case TIME:\n+                    f = DateFormat.getTimeInstance(iTimeStyle, locale);\n+                    break;\n+                case DATETIME:\n+                    f = DateFormat.getDateTimeInstance(iDateStyle, iTimeStyle, locale);\n+                    break;\n+            }\n+            if (f instanceof SimpleDateFormat == false) {\n+                throw new IllegalArgumentException(\"No datetime pattern for locale: \" + locale);\n+            }\n+            return ((SimpleDateFormat) f).toPattern();\n+        }\n+    }\n+\n }\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java\n  */\n package org.joda.time.format;\n \n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.Locale;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadWritableInstant;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadablePartial;\n+\n /**\n- * Combined interface for printing and parsing.\n+ * Controls the printing and parsing of a datetime to and from a string.\n  * <p>\n- * See each extended interface for details of the methods.\n- *\n+ * This class is the main API for printing and parsing used by most applications.\n+ * Instances of this class are created via one of three factory classes:\n+ * <ul>\n+ * <li>{@link DateTimeFormat} - formats by pattern and style</li>\n+ * <li>{@link ISODateTimeFormat} - ISO8601 formats</li>\n+ * <li>{@link DateTimeFormatterBuilder} - complex formats created via method calls</li>\n+ * </ul>\n+ * <p>\n+ * An instance of this class holds a reference internally to one printer and\n+ * one parser. It is possible that one of these may be null, in which case the\n+ * formatter cannot print/parse. This can be checked via the {@link #isPrinter()}\n+ * and {@link #isParser()} methods.\n+ * <p>\n+ * The underlying printer/parser can be altered to behave exactly as required\n+ * by using one of the decorator modifiers:\n+ * <ul>\n+ * <li>{@link #withLocale(Locale)} - returns a new formatter that uses the specified locale</li>\n+ * <li>{@link #withZone(DateTimeZone)} - returns a new formatter that uses the specified time zone</li>\n+ * <li>{@link #withChronology(Chronology)} - returns a new formatter that uses the specified chronology</li>\n+ * <li>{@link #withOffsetParsed()} - returns a new formatter that returns the parsed time zone offset</li>\n+ * </ul>\n+ * Each of these returns a new formatter (instances of this class are immutable).\n+ * <p>\n+ * The main methods of the class are the <code>printXxx</code> and\n+ * <code>parseXxx</code> methods. These are used as follows:\n+ * <pre>\n+ * // print using the defaults (default locale, chronology/zone of the datetime)\n+ * String dateStr = formatter.print(dt);\n+ * // print using the French locale\n+ * String dateStr = formatter.withLocale(Locale.FRENCH).print(dt);\n+ * // print using the UTC zone\n+ * String dateStr = formatter.withZone(DateTimeZone.UTC).print(dt);\n+ * \n+ * // parse using the Paris zone\n+ * DateTime date = formatter.withZone(DateTimeZone.forID(\"Europe/Paris\")).parseDateTime(str);\n+ * </pre>\n+ * \n  * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public interface DateTimeFormatter extends DateTimePrinter, DateTimeParser {\n-    \n-    // Methods inherited\n+public class DateTimeFormatter {\n+\n+    /** The internal printer used to output the datetime. */\n+    private final DateTimePrinter iPrinter;\n+    /** The internal parser used to output the datetime. */\n+    private final DateTimeParser iParser;\n+    /** The locale to use for printing and parsing. */\n+    private final Locale iLocale;\n+    /** Whether the offset is parsed. */\n+    private final boolean iOffsetParsed;\n+    /** The chronology to use as an override. */\n+    private final Chronology iChrono;\n+    /** The zone to use as an override. */\n+    private final DateTimeZone iZone;\n+\n+    /**\n+     * Creates a new formatter, however you will normally use the factory\n+     * or the builder.\n+     * \n+     * @param printer  the internal printer, null if cannot print\n+     * @param parser  the internal parser, null if cannot parse\n+     */\n+    public DateTimeFormatter(\n+            DateTimePrinter printer, DateTimeParser parser) {\n+        super();\n+        iPrinter = printer;\n+        iParser = parser;\n+        iLocale = null;\n+        iOffsetParsed = false;\n+        iChrono = null;\n+        iZone = null;\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    private DateTimeFormatter(\n+            DateTimePrinter printer, DateTimeParser parser,\n+            Locale locale, boolean offsetParsed,\n+            Chronology chrono, DateTimeZone zone) {\n+        super();\n+        iPrinter = printer;\n+        iParser = parser;\n+        iLocale = locale;\n+        iOffsetParsed = offsetParsed;\n+        iChrono = chrono;\n+        iZone = zone;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this formatter capable of printing.\n+     * \n+     * @return true if this is a printer\n+     */\n+    public boolean isPrinter() {\n+        return (iPrinter != null);\n+    }\n+\n+    /**\n+     * Gets the internal printer object that performs the real printing work.\n+     * \n+     * @return the internal printer\n+     */\n+    public DateTimePrinter getPrinter() {\n+        return iPrinter;\n+    }\n+\n+    /**\n+     * Is this formatter capable of parsing.\n+     * \n+     * @return true if this is a parser\n+     */\n+    public boolean isParser() {\n+        return (iParser != null);\n+    }\n+\n+    /**\n+     * Gets the internal parser object that performs the real parsing work.\n+     * \n+     * @return the internal parser\n+     */\n+    public DateTimeParser getParser() {\n+        return iParser;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new formatter with a different locale that will be used\n+     * for printing and parsing.\n+     * <p>\n+     * A DateTimeFormatter is immutable, so a new instance is returned,\n+     * and the original is unaltered and still usable.\n+     * \n+     * @param locale  the locale to use\n+     * @return the new formatter\n+     */\n+    public DateTimeFormatter withLocale(Locale locale) {\n+        locale = (locale == null ? Locale.getDefault() : locale);\n+        if (locale.equals(getLocale())) {\n+            return this;\n+        }\n+        return new DateTimeFormatter(iPrinter, iParser, locale, iOffsetParsed, iChrono, iZone);\n+    }\n+\n+    /**\n+     * Gets the locale that will be used for printing and parsing.\n+     * \n+     * @return the locale to use\n+     */\n+    public Locale getLocale() {\n+        return iLocale;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new formatter that will create a datetime with a time zone\n+     * equal to that of the offset of the parsed string.\n+     * <p>\n+     * After calling this method, a string '2004-06-09T10:20:30-08:00' will\n+     * create a datetime with a zone of -08:00 (a fixed zone, with no daylight\n+     * savings rules). If the parsed string represents a local time (no zone\n+     * offset) the parsed datetime will be in the default zone.\n+     * <p>\n+     * Calling this method sets the override zone to null.\n+     * Calling the override zone method sets this flag off.\n+     * \n+     * @param locale  the locale to use\n+     * @return the new formatter\n+     */\n+    public DateTimeFormatter withOffsetParsed() {\n+        if (iOffsetParsed == true) {\n+            return this;\n+        }\n+        return new DateTimeFormatter(iPrinter, iParser, iLocale, true, iChrono, null);\n+    }\n+\n+    /**\n+     * Checks whether the offset from the string is used as the zone of\n+     * the parsed datetime.\n+     * \n+     * @return true if the offset from the string is used as the zone\n+     */\n+    public boolean isOffsetParsed() {\n+        return iOffsetParsed;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new formatter that will use the specified chronology in\n+     * preference to that of the printed object, or ISO on a parse.\n+     * <p>\n+     * When printing, this chronolgy will be used in preference to the chronology\n+     * from the datetime that would otherwise be used.\n+     * <p>\n+     * When parsing, this chronology will be set on the parsed datetime.\n+     * <p>\n+     * A null zone means of no-override.\n+     * If both an override chronology and an override zone are set, the\n+     * override zone will take precedence over the zone in the chronology.\n+     * \n+     * @param zone  the zone to use as an override\n+     * @return the new formatter\n+     */\n+    public DateTimeFormatter withChronology(Chronology chrono) {\n+        if (iChrono == chrono) {\n+            return this;\n+        }\n+        return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, chrono, iZone);\n+    }\n+\n+    /**\n+     * Gets the chronology to use as an override.\n+     * \n+     * @return the chronology to use as an override\n+     */\n+    public Chronology getChronolgy() {\n+        return iChrono;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new formatter that will use the specified zone in preference\n+     * to the zone of the printed object, or default zone on a parse.\n+     * <p>\n+     * When printing, this zone will be used in preference to the zone\n+     * from the datetime that would otherwise be used.\n+     * <p>\n+     * When parsing, this zone will be set on the parsed datetime.\n+     * <p>\n+     * A null zone means of no-override.\n+     * If both an override chronology and an override zone are set, the\n+     * override zone will take precedence over the zone in the chronology.\n+     * \n+     * @param zone  the zone to use as an override\n+     * @return the new formatter\n+     */\n+    public DateTimeFormatter withZone(DateTimeZone zone) {\n+        if (iZone == zone) {\n+            return this;\n+        }\n+        return new DateTimeFormatter(iPrinter, iParser, iLocale, false, iChrono, zone);\n+    }\n+\n+    /**\n+     * Gets the zone to use as an override.\n+     * \n+     * @return the zone to use as an override\n+     */\n+    public DateTimeZone getZone() {\n+        return iZone;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints a ReadableInstant, using the chronology supplied by the instant.\n+     *\n+     * @param buf  formatted instant is appended to this buffer\n+     * @param instant  instant to format, null means now\n+     */\n+    public void printTo(StringBuffer buf, ReadableInstant instant) {\n+        checkPrinter();\n+        \n+        long millis = DateTimeUtils.getInstantMillis(instant);\n+        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n+        printTo(buf, millis, chrono);\n+    }\n+\n+    /**\n+     * Prints a ReadableInstant, using the chronology supplied by the instant.\n+     *\n+     * @param out  formatted instant is written out\n+     * @param instant  instant to format, null means now\n+     */\n+    public void printTo(Writer out, ReadableInstant instant) throws IOException {\n+        checkPrinter();\n+        \n+        long millis = DateTimeUtils.getInstantMillis(instant);\n+        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n+        printTo(out, millis, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * using ISO chronology in the default DateTimeZone.\n+     *\n+     * @param buf  formatted instant is appended to this buffer\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     */\n+    public void printTo(StringBuffer buf, long instant) {\n+        checkPrinter();\n+        \n+        printTo(buf, instant, null);\n+    }\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * using ISO chronology in the default DateTimeZone.\n+     *\n+     * @param out  formatted instant is written out\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     */\n+    public void printTo(Writer out, long instant) throws IOException {\n+        checkPrinter();\n+        \n+        printTo(out, instant, null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints a ReadablePartial.\n+     * <p>\n+     * Neither the override chronology nor the override zone are used\n+     * by this method.\n+     *\n+     * @param buf  formatted partial is appended to this buffer\n+     * @param partial  partial to format\n+     */\n+    public void printTo(StringBuffer buf, ReadablePartial partial) {\n+        checkPrinter();\n+        if (partial == null) {\n+            throw new IllegalArgumentException(\"The partial must not be null\");\n+        }\n+        \n+        iPrinter.printTo(buf, partial, iLocale);\n+    }\n+\n+    /**\n+     * Prints a ReadablePartial.\n+     * <p>\n+     * Neither the override chronology nor the override zone are used\n+     * by this method.\n+     *\n+     * @param out  formatted partial is written out\n+     * @param partial  partial to format\n+     */\n+    public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+        checkPrinter();\n+        if (partial == null) {\n+            throw new IllegalArgumentException(\"The partial must not be null\");\n+        }\n+        \n+        iPrinter.printTo(out, partial, iLocale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints a ReadableInstant to a String.\n+     * <p>\n+     * This method will use the override zone and the override chronololgy if\n+     * they are set. Otherwise it will use the chronology and zone of the instant.\n+     *\n+     * @param instant  instant to format, null means now\n+     * @return the printed result\n+     */\n+    public String print(ReadableInstant instant) {\n+        checkPrinter();\n+        \n+        StringBuffer buf = new StringBuffer(iPrinter.estimatePrintedLength());\n+        printTo(buf, instant);\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Prints a millisecond instant to a String.\n+     * <p>\n+     * This method will use the override zone and the override chronololgy if\n+     * they are set. Otherwise it will use the ISO chronology and default zone.\n+     *\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     * @return the printed result\n+     */\n+    public String print(long instant) {\n+        checkPrinter();\n+        \n+        StringBuffer buf = new StringBuffer(iPrinter.estimatePrintedLength());\n+        printTo(buf, instant);\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Prints a ReadablePartial to a new String.\n+     * <p>\n+     * Neither the override chronology nor the override zone are used\n+     * by this method.\n+     *\n+     * @param partial  partial to format\n+     * @return the printed result\n+     */\n+    public String print(ReadablePartial partial) {\n+        checkPrinter();\n+        \n+        StringBuffer buf = new StringBuffer(iPrinter.estimatePrintedLength());\n+        printTo(buf, partial);\n+        return buf.toString();\n+    }\n+\n+    private void printTo(StringBuffer buf, long instant, Chronology chrono) {\n+        chrono = selectChronology(chrono);\n+        // Shift instant into local time (UTC) to avoid excessive offset\n+        // calculations when printing multiple fields in a composite printer.\n+        DateTimeZone zone = chrono.getZone();\n+        int offset = zone.getOffset(instant);\n+        iPrinter.printTo(buf, instant + offset, chrono.withUTC(), offset, zone, iLocale);\n+    }\n+\n+    private void printTo(Writer buf, long instant, Chronology chrono) throws IOException {\n+        chrono = selectChronology(chrono);\n+        // Shift instant into local time (UTC) to avoid excessive offset\n+        // calculations when printing multiple fields in a composite printer.\n+        DateTimeZone zone = chrono.getZone();\n+        int offset = zone.getOffset(instant);\n+        iPrinter.printTo(buf, instant + offset, chrono.withUTC(), offset, zone, iLocale);\n+    }\n+\n+    /**\n+     * Method called when there is nothing to parse.\n+     * \n+     * @return the exception\n+     */\n+    private void checkPrinter() {\n+        if (iPrinter == null) {\n+            throw new UnsupportedOperationException(\"Printing not supported\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Parses a datetime from the given text, at the given position, saving the\n+     * result into the fields of the given ReadWritableInstant. If the parse\n+     * succeeds, the return value is the new text position. Note that the parse\n+     * may succeed without fully reading the text and in this case those fields\n+     * that were read will be set.\n+     * <p>\n+     * Only those fields present in the string will be changed in the specified\n+     * instant. All other fields will remain unaltered. Thus if the string only\n+     * contains a year and a month, then the day and time will be retained from\n+     * the input instant. If this is not the behaviour you want, then reset the\n+     * fields before calling this method, or use {@link #parseDateTime(String)}\n+     * or {@link #parseMutableDateTime(String)}.\n+     * <p>\n+     * If it fails, the return value is negative, but the instant may still be\n+     * modified. To determine the position where the parse failed, apply the\n+     * one's complement operator (~) on the return value.\n+     * <p>\n+     * The parse will use the chronology of the instant.\n+     *\n+     * @param instant  an instant that will be modified, not null\n+     * @param text  the text to parse\n+     * @param position  position to start parsing from\n+     * @return new position, negative value means parse failed -\n+     *  apply complement operator (~) to get position of failure\n+     * @throws UnsupportedOperationException if parsing is not supported\n+     * @throws IllegalArgumentException if the instant is null\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    public int parseInto(ReadWritableInstant instant, String text, int position) {\n+        checkParser();\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"Instant must not be null\");\n+        }\n+        \n+        long instantMillis = instant.getMillis();\n+        Chronology chrono = instant.getChronology();\n+        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n+        chrono = selectChronology(chrono);\n+        \n+        DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale);\n+        int newPos = iParser.parseInto(bucket, text, position);\n+        instant.setMillis(bucket.computeMillis());\n+        if (iOffsetParsed && bucket.getZone() == null) {\n+            int parsedOffset = bucket.getOffset();\n+            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n+            chrono = chrono.withZone(parsedZone);\n+        }\n+        instant.setChronology(chrono);\n+        return newPos;\n+    }\n+\n+    /**\n+     * Parses a datetime from the given text, returning the number of\n+     * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n+     * <p>\n+     * The parse will use the ISO chronology, and the default time zone.\n+     * If the text contains a time zone string then that will be taken into account.\n+     *\n+     * @param text  text to parse\n+     * @return parsed value expressed in milliseconds since the epoch\n+     * @throws UnsupportedOperationException if parsing is not supported\n+     * @throws IllegalArgumentException if the text to parse is invalid\n+     */\n+    public long parseMillis(String text) {\n+        checkParser();\n+        \n+        Chronology chrono = selectChronology(iChrono);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale);\n+        int newPos = iParser.parseInto(bucket, text, 0);\n+        if (newPos >= 0) {\n+            if (newPos >= text.length()) {\n+                return bucket.computeMillis(true);\n+            }\n+        } else {\n+            newPos = ~newPos;\n+        }\n+        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n+    }\n+\n+    /**\n+     * Parses a datetime from the given text, returning a new DateTime.\n+     * <p>\n+     * The parse will use the zone and chronology specified on this formatter.\n+     * <p>\n+     * If the text contains a time zone string then that will be taken into\n+     * account in adjusting the time of day as follows.\n+     * If the {@link #withOffsetParsed()} has been called, then the resulting\n+     * DateTime will have a fixed offset based on the parsed time zone.\n+     * Otherwise the resulting DateTime will have the zone of this formatter,\n+     * but the parsed zone may have caused the time to be adjusted.\n+     *\n+     * @param text  the text to parse\n+     * @return parsed value in a DateTime object\n+     * @throws UnsupportedOperationException if parsing is not supported\n+     * @throws IllegalArgumentException if the text to parse is invalid\n+     */\n+    public DateTime parseDateTime(String text) {\n+        checkParser();\n+        \n+        Chronology chrono = selectChronology(null);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale);\n+        int newPos = iParser.parseInto(bucket, text, 0);\n+        if (newPos >= 0) {\n+            if (newPos >= text.length()) {\n+                long millis = bucket.computeMillis(true);\n+                if (iOffsetParsed && bucket.getZone() == null) {\n+                    int parsedOffset = bucket.getOffset();\n+                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n+                    chrono = chrono.withZone(parsedZone);\n+                }\n+                return new DateTime(millis, chrono);\n+            }\n+        } else {\n+            newPos = ~newPos;\n+        }\n+        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n+    }\n+\n+    /**\n+     * Parses a datetime from the given text, returning a new MutableDateTime.\n+     * <p>\n+     * The parse will use the zone and chronology specified on this formatter.\n+     * <p>\n+     * If the text contains a time zone string then that will be taken into\n+     * account in adjusting the time of day as follows.\n+     * If the {@link #withOffsetParsed()} has been called, then the resulting\n+     * DateTime will have a fixed offset based on the parsed time zone.\n+     * Otherwise the resulting DateTime will have the zone of this formatter,\n+     * but the parsed zone may have caused the time to be adjusted.\n+     *\n+     * @param text  the text to parse\n+     * @return parsed value in a MutableDateTime object\n+     * @throws UnsupportedOperationException if parsing is not supported\n+     * @throws IllegalArgumentException if the text to parse is invalid\n+     */\n+    public MutableDateTime parseMutableDateTime(String text) {\n+        checkParser();\n+        \n+        Chronology chrono = selectChronology(null);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale);\n+        int newPos = iParser.parseInto(bucket, text, 0);\n+        if (newPos >= 0) {\n+            if (newPos >= text.length()) {\n+                long millis = bucket.computeMillis(true);\n+                if (iOffsetParsed && bucket.getZone() == null) {\n+                    int parsedOffset = bucket.getOffset();\n+                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n+                    chrono = chrono.withZone(parsedZone);\n+                }\n+                return new MutableDateTime(millis, chrono);\n+            }\n+        } else {\n+            newPos = ~newPos;\n+        }\n+        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n+    }\n+\n+    /**\n+     * Method called when there is nothing to parse.\n+     * \n+     * @return the exception\n+     */\n+    private void checkParser() {\n+        if (iParser == null) {\n+            throw new UnsupportedOperationException(\"Parsing not supported\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Determines the correct chronology to use.\n+     *\n+     * @param chrono  the proposed chronology\n+     * @return the actual chronology\n+     */\n+    private Chronology selectChronology(Chronology chrono) {\n+        chrono = DateTimeUtils.getChronology(chrono);\n+        if (iChrono != null) {\n+            chrono = iChrono;\n+        }\n+        if (iZone != null) {\n+            chrono = chrono.withZone(iZone);\n+        }\n+        return chrono;\n+    }\n+\n }\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n  */\n public class DateTimeFormatterBuilder {\n \n-    /** The locale the builder uses. */\n-    private final Locale iLocale;\n-\n-    // Array contents alternate between printers and parsers.\n+    /** Array of printers and parsers (alternating). */\n     private ArrayList iElementPairs;\n+    /** Cache of the last returned formatter. */\n     private Object iFormatter;\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Creates a DateTimeFormatterBuilder for the default locale.\n+     * Creates a DateTimeFormatterBuilder.\n      */\n     public DateTimeFormatterBuilder() {\n-        this(Locale.getDefault());\n-    }\n-\n-    /**\n-     * Creates a DateTimeFormatterBuilder for the specified locale.\n-     * \n-     * @param locale Locale to use, or null for default\n-     */\n-    public DateTimeFormatterBuilder(Locale locale) {\n-        if (locale == null) {\n-            locale = Locale.getDefault();\n-        }\n-        iLocale = locale;\n+        super();\n         iElementPairs = new ArrayList();\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Returns the locale being used by the formatter builder, never null.\n-     */\n-    public Locale getLocale() {\n-        return iLocale;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Converts to a DateTimePrinter that prints using all the appended\n-     * elements. Subsequent changes to this builder do not affect the returned\n-     * printer.\n-     *\n-     * @throws UnsupportedOperationException if any formatter element doesn't support\n-     * printing\n-     */\n-    public DateTimePrinter toPrinter() throws UnsupportedOperationException {\n+     * Converts to a DateTimePrinter that can only print, using all the\n+     * appended elements.\n+     * <p>\n+     * Subsequent changes to this builder do not affect the returned formatter.\n+     *\n+     * @throws UnsupportedOperationException if printing is not supported\n+     */\n+    public DateTimePrinter toPrinter() {\n         Object f = getFormatter();\n         if (isPrinter(f)) {\n-            return (DateTimePrinter)f;\n-        }\n-        throw new UnsupportedOperationException(\"Printing not supported\");\n-    }\n-\n-    /**\n-     * Converts to a DateTimeParser that parses using all the appended\n-     * elements. Subsequent changes to this builder do not affect the returned\n-     * parser.\n-     *\n-     * @throws UnsupportedOperationException if any formatter element doesn't support\n-     * parsing\n-     */\n-    public DateTimeParser toParser() throws UnsupportedOperationException {\n+            return (DateTimePrinter) f;\n+        }\n+        throw new UnsupportedOperationException(\"Printing is not supported\");\n+    }\n+\n+    /**\n+     * Converts to a DateTimeFormatter that can only parse, using all the\n+     * appended elements.\n+     * <p>\n+     * Subsequent changes to this builder do not affect the returned formatter.\n+     *\n+     * @throws UnsupportedOperationException if parsing is not supported\n+     */\n+    public DateTimeParser toParser() {\n         Object f = getFormatter();\n         if (isParser(f)) {\n-            return (DateTimeParser)f;\n-        }\n-        throw new UnsupportedOperationException(\"Parsing not supported\");\n-    }\n-\n-    /**\n-     * Converts to a DateTimeFormatter that prints and parses using all the\n-     * appended elements. Subsequent changes to this builder do not affect the\n-     * returned formatter.\n-     *\n-     * @throws UnsupportedOperationException if any formatter element doesn't support\n-     * both printing and parsing\n-     */\n-    public DateTimeFormatter toFormatter() throws UnsupportedOperationException {\n+            return (DateTimeParser) f;\n+        }\n+        throw new UnsupportedOperationException(\"Parsing is not supported\");\n+    }\n+\n+    /**\n+     * Converts to a DateTimeFormatter that using all the appended elements.\n+     * <p>\n+     * Subsequent changes to this builder do not affect the returned formatter.\n+     * <p>\n+     * The returned formatter may not support both printing and parsing.\n+     * The methods {@link DateTimeFormatter#isPrinter()} and\n+     * {@link DateTimeFormatter#isParser()} will help you determine the state\n+     * of the formatter.\n+     *\n+     * @throws UnsupportedOperationException if neither printing nor parsing is supported\n+     */\n+    public DateTimeFormatter toFormatter() {\n         Object f = getFormatter();\n-        if (isFormatter(f)) {\n-            return (DateTimeFormatter)f;\n+        DateTimePrinter printer = null;\n+        if (isPrinter(f)) {\n+            printer = (DateTimePrinter) f;\n+        }\n+        DateTimeParser parser = null;\n+        if (isParser(f)) {\n+            parser = (DateTimeParser) f;\n+        }\n+        if (printer != null || parser != null) {\n+            return new DateTimeFormatter(printer, parser);\n         }\n         throw new UnsupportedOperationException(\"Both printing and parsing not supported\");\n     }\n     /**\n      * Returns true if toPrinter can be called without throwing an\n      * UnsupportedOperationException.\n+     * \n+     * @return true if a printer can be built\n      */\n     public boolean canBuildPrinter() {\n         return isPrinter(getFormatter());\n     /**\n      * Returns true if toParser can be called without throwing an\n      * UnsupportedOperationException.\n+     * \n+     * @return true if a parser can be built\n      */\n     public boolean canBuildParser() {\n         return isParser(getFormatter());\n     /**\n      * Returns true if toFormatter can be called without throwing an\n      * UnsupportedOperationException.\n+     * \n+     * @return true if a formatter can be built\n      */\n     public boolean canBuildFormatter() {\n         return isFormatter(getFormatter());\n         if (formatter == null) {\n             throw new IllegalArgumentException(\"No formatter supplied\");\n         }\n-        return append0(formatter);\n+        return append0(formatter.getPrinter(), formatter.getParser());\n     }\n \n     /**\n      */\n     public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {\n         checkParser(parser);\n-        DateTimeFormatter[] parsers = new DateTimeFormatter[] {\n-            (DateTimeFormatter) parser, null\n-        };\n+        DateTimeParser[] parsers = new DateTimeParser[] {parser, null};\n         return append0(null, new MatchingParser(parsers));\n     }\n \n         if (fieldType == null) {\n             throw new IllegalArgumentException(\"Field type must not be null\");\n         }\n-        return append0(new TextField(fieldType, iLocale, false));\n+        return append0(new TextField(fieldType, false));\n     }\n \n     /**\n         if (fieldType == null) {\n             throw new IllegalArgumentException(\"Field type must not be null\");\n         }\n-        return append0(new TextField(fieldType, iLocale, true));\n+        return append0(new TextField(fieldType, true));\n     }\n \n     /**\n      * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendTimeZoneName() {\n-        return append0(new TimeZonePrinter( iLocale, false), null);\n+        return append0(new TimeZonePrinter(false), null);\n     }\n \n     /**\n      * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendTimeZoneShortName() {\n-        return append0(new TimeZonePrinter( iLocale, true), null);\n+        return append0(new TimeZonePrinter(true), null);\n     }\n \n     /**\n     public DateTimeFormatterBuilder appendTimeZoneOffset(\n             String zeroOffsetText, boolean showSeparators,\n             int minFields, int maxFields) {\n-        return append0(new TimeZoneOffsetFormatter\n+        return append0(new TimeZoneOffset\n                        (zeroOffsetText, showSeparators, minFields, maxFields));\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Calls upon {@link DateTimeFormat} to parse the pattern and append the\n      * results into this builder.\n         return this;\n     }\n \n+    //-----------------------------------------------------------------------\n     private Object getFormatter() {\n         Object f = iFormatter;\n \n         if (f instanceof DateTimeFormatter) {\n             if (f instanceof Composite) {\n                 return ((Composite)f).isPrinter()\n-                    && ((Composite)f).isParser();\n+                    || ((Composite)f).isParser();\n             }\n             return true;\n         }\n \n     //-----------------------------------------------------------------------\n     static class CharacterLiteral\n-            extends BaseDateTimeFormatter\n-            implements DateTimeFormatter {\n+            implements DateTimePrinter, DateTimeParser {\n \n         private final char iValue;\n \n             return 1;\n         }\n \n-        public void printTo(StringBuffer buf,\n-                            long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) {\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n             buf.append(iValue);\n         }\n \n-        public void printTo(Writer out,\n-                            long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) throws IOException {\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n             out.write(iValue);\n         }\n \n-        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n             buf.append(iValue);\n         }\n \n-        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n             out.write(iValue);\n-        }\n-\n-        public String print(long instant, Chronology chrono,\n-                               int displayOffset, DateTimeZone displayZone) {\n-            return String.valueOf(iValue);\n-        }\n-\n-        public String print(ReadablePartial partial) {\n-            return String.valueOf(iValue);\n         }\n \n         public int estimateParsedLength() {\n \n     //-----------------------------------------------------------------------\n     static class StringLiteral\n-            extends BaseDateTimeFormatter\n-            implements DateTimeFormatter {\n+            implements DateTimePrinter, DateTimeParser {\n \n         private final String iValue;\n \n             return iValue.length();\n         }\n \n-        public void printTo(StringBuffer buf,\n-                            long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) {\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n             buf.append(iValue);\n         }\n \n-        public void printTo(Writer out,\n-                            long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) throws IOException {\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n             out.write(iValue);\n         }\n \n-        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n             buf.append(iValue);\n         }\n \n-        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n             out.write(iValue);\n-        }\n-\n-        public String print(long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) {\n-            return iValue;\n-        }\n-\n-        public String print(ReadablePartial partial) {\n-            return iValue;\n         }\n \n         public int estimateParsedLength() {\n \n     //-----------------------------------------------------------------------\n     static abstract class NumberFormatter\n-            extends BaseDateTimeFormatter\n-            implements DateTimeFormatter {\n+            implements DateTimePrinter, DateTimeParser {\n         protected final DateTimeFieldType iFieldType;\n         protected final int iMaxParsedDigits;\n         protected final boolean iSigned;\n             return iMaxParsedDigits;\n         }\n \n-        public void printTo(StringBuffer buf,\n-                            long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) {\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n             try {\n                 DateTimeField field = iFieldType.getField(chrono);\n                 FormatUtils.appendUnpaddedInteger(buf, field.get(instant));\n             }\n         }\n \n-        public void printTo(Writer out,\n-                            long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) throws IOException {\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n             try {\n                 DateTimeField field = iFieldType.getField(chrono);\n                 FormatUtils.writeUnpaddedInteger(out, field.get(instant));\n             }\n         }\n \n-        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n             if (partial.isSupported(iFieldType)) {\n                 try {\n                     FormatUtils.appendUnpaddedInteger(buf, partial.get(iFieldType));\n             }\n         }\n \n-        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n             if (partial.isSupported(iFieldType)) {\n                 try {\n                     FormatUtils.writeUnpaddedInteger(out, partial.get(iFieldType));\n             return iMaxParsedDigits;\n         }\n \n-        public void printTo(StringBuffer buf,\n-                            long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) {\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n             try {\n                 DateTimeField field = iFieldType.getField(chrono);\n                 FormatUtils.appendPaddedInteger(buf, field.get(instant), iMinPrintedDigits);\n             }\n         }\n \n-        public void printTo(Writer out,\n-                            long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) throws IOException {\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n             try {\n                 DateTimeField field = iFieldType.getField(chrono);\n                 FormatUtils.writePaddedInteger(out, field.get(instant), iMinPrintedDigits);\n             }\n         }\n \n-        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n             if (partial.isSupported(iFieldType)) {\n                 try {\n                     FormatUtils.appendPaddedInteger(buf, partial.get(iFieldType), iMinPrintedDigits);\n             }\n         }\n \n-        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n             if (partial.isSupported(iFieldType)) {\n                 try {\n                     FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits);\n \n     //-----------------------------------------------------------------------\n     static class TwoDigitYear\n-            extends BaseDateTimeFormatter\n-            implements DateTimeFormatter {\n+            implements DateTimePrinter, DateTimeParser {\n \n         private final int iPivot;\n \n             return 2;\n         }\n \n-        public void printTo(StringBuffer buf,\n-                            long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) {\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n             int year = getTwoDigitYear(instant, chrono);\n             if (year < 0) {\n                 buf.append('\\ufffd');\n             }\n         }\n \n-        public void printTo(Writer out,\n-                            long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) throws IOException {\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n             int year = getTwoDigitYear(instant, chrono);\n             if (year < 0) {\n                 out.write('\\ufffd');\n             }\n         }\n \n-        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n             int year = getTwoDigitYear(partial);\n             if (year < 0) {\n                 buf.append('\\ufffd');\n             }\n         }\n \n-        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n             int year = getTwoDigitYear(partial);\n             if (year < 0) {\n                 out.write('\\ufffd');\n \n     //-----------------------------------------------------------------------\n     static class TextField\n-            extends BaseDateTimeFormatter\n-            implements DateTimeFormatter {\n+            implements DateTimePrinter, DateTimeParser {\n \n         private final DateTimeFieldType iFieldType;\n-        private final Locale iLocale;\n         private final boolean iShort;\n \n-        TextField(DateTimeFieldType fieldType, Locale locale, boolean isShort) {\n+        TextField(DateTimeFieldType fieldType, boolean isShort) {\n             super();\n             iFieldType = fieldType;\n-            iLocale = locale;\n             iShort = isShort;\n         }\n \n             return iShort ? 6 : 20;\n         }\n \n-        public void printTo(StringBuffer buf,\n-                            long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) {\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n             try {\n-                buf.append(print(instant, chrono, displayOffset, displayZone));\n+                buf.append(print(instant, chrono, locale));\n             } catch (RuntimeException e) {\n                 buf.append('\\ufffd');\n             }\n         }\n \n-        public void printTo(Writer out,\n-                            long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) throws IOException {\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n             try {\n-                out.write(print(instant, chrono, displayOffset, displayZone));\n+                out.write(print(instant, chrono, locale));\n             } catch (RuntimeException e) {\n                 out.write('\\ufffd');\n             }\n         }\n \n-        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n             try {\n-                buf.append(print(partial));\n+                buf.append(print(partial, locale));\n             } catch (RuntimeException e) {\n                 buf.append('\\ufffd');\n             }\n         }\n \n-        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n             try {\n-                out.write(print(partial));\n+                out.write(print(partial, locale));\n             } catch (RuntimeException e) {\n                 out.write('\\ufffd');\n             }\n         }\n \n-        public String print(long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) {\n+        private String print(long instant, Chronology chrono, Locale locale) {\n             DateTimeField field = iFieldType.getField(chrono);\n             if (iShort) {\n-                return field.getAsShortText(instant, iLocale);\n+                return field.getAsShortText(instant, locale);\n             } else {\n-                return field.getAsText(instant, iLocale);\n-            }\n-        }\n-\n-        public String print(ReadablePartial partial) {\n+                return field.getAsText(instant, locale);\n+            }\n+        }\n+\n+        private String print(ReadablePartial partial, Locale locale) {\n             if (partial.isSupported(iFieldType)) {\n                 DateTimeField field = iFieldType.getField(partial.getChronology());\n                 if (iShort) {\n-                    return field.getAsShortText(partial, iLocale);\n+                    return field.getAsShortText(partial, locale);\n                 } else {\n-                    return field.getAsText(partial, iLocale);\n+                    return field.getAsText(partial, locale);\n                 }\n             } else {\n                 return \"\\ufffd\";\n                 return ~position;\n             }\n \n-            bucket.saveField(iFieldType, text.substring(position, i), iLocale);\n+            Locale locale = bucket.getLocale();\n+            bucket.saveField(iFieldType, text.substring(position, i), locale);\n \n             return i;\n         }\n \n     //-----------------------------------------------------------------------\n     static class Fraction\n-            extends BaseDateTimeFormatter\n-            implements DateTimeFormatter {\n+            implements DateTimePrinter, DateTimeParser {\n \n         private final DateTimeFieldType iFieldType;\n         protected int iMinDigits;\n             return iMaxDigits;\n         }\n \n-        public void printTo(StringBuffer buf,\n-                            long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) {\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n             try {\n                 printTo(buf, null, instant, chrono);\n             } catch (IOException e) {\n             }\n         }\n \n-        public void printTo(Writer out,\n-                            long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) throws IOException {\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n             printTo(null, out, instant, chrono);\n         }\n \n-        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n             if (partial.isSupported(iFieldType)) {\n                 long millis = partial.getChronology().set(partial, 0L);\n                 try {\n             }\n         }\n \n-        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n             if (partial.isSupported(iFieldType)) {\n                 long millis = partial.getChronology().set(partial, 0L);\n                 printTo(null, out, millis, partial.getChronology());\n     }\n \n     //-----------------------------------------------------------------------\n-    static class TimeZoneOffsetFormatter\n-            extends BaseDateTimeFormatter\n-            implements DateTimeFormatter {\n+    static class TimeZoneOffset\n+            implements DateTimePrinter, DateTimeParser {\n \n         private final String iZeroOffsetText;\n         private final boolean iShowSeparators;\n         private final int iMinFields;\n         private final int iMaxFields;\n \n-        TimeZoneOffsetFormatter(String zeroOffsetText,\n+        TimeZoneOffset(String zeroOffsetText,\n                                 boolean showSeparators,\n                                 int minFields, int maxFields)\n         {\n             return est;\n         }\n         \n-        public void printTo(StringBuffer buf,\n-                            long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) {\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n             if (displayZone == null) {\n                 return;  // no zone\n             }\n             FormatUtils.appendPaddedInteger(buf, displayOffset, 3);\n         }\n         \n-        public void printTo(Writer out,\n-                            long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) throws IOException {\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n             if (displayZone == null) {\n                 return;  // no zone\n             }\n             FormatUtils.writePaddedInteger(out, displayOffset, 3);\n         }\n \n-        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n             // no zone info\n         }\n \n-        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n             // no zone info\n         }\n \n \n     //-----------------------------------------------------------------------\n     static class TimeZonePrinter\n-            extends BaseDateTimeFormatter\n             implements DateTimePrinter {\n \n-        private final Locale iLocale;\n         private final boolean iShortFormat;\n \n-        TimeZonePrinter(Locale locale, boolean shortFormat) {\n+        TimeZonePrinter(boolean shortFormat) {\n             super();\n-            iLocale = locale;\n             iShortFormat = shortFormat;\n         }\n \n             return iShortFormat ? 4 : 20;\n         }\n \n-        public void printTo(StringBuffer buf,\n-                            long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) {\n-            buf.append(print(instant, chrono, displayOffset, displayZone));\n-        }\n-\n-        public void printTo(Writer out,\n-                            long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) throws IOException {\n-            out.write(print(instant, chrono, displayOffset, displayZone));\n-        }\n-\n-        public String print(long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) {\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n+            buf.append(print(instant, displayZone, locale));\n+        }\n+\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n+            out.write(print(instant, displayZone, locale));\n+        }\n+\n+        private String print(long instant, DateTimeZone displayZone, Locale locale) {\n             if (displayZone == null) {\n                 return \"\";  // no zone\n             }\n             if (iShortFormat) {\n-                return displayZone.getShortName(instant, this.iLocale);\n+                return displayZone.getShortName(instant, locale);\n             } else {\n-                return displayZone.getName(instant, this.iLocale);\n-            }\n-        }\n-\n-        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+                return displayZone.getName(instant, locale);\n+            }\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n             // no zone info\n         }\n \n-        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n             // no zone info\n         }\n     }\n \n     //-----------------------------------------------------------------------\n     static class Composite\n-            extends BaseDateTimeFormatter\n-            implements DateTimeFormatter {\n+            implements DateTimePrinter, DateTimeParser {\n \n         private final DateTimePrinter[] iPrinters;\n         private final DateTimeParser[] iParsers;\n             }\n         }\n \n-        private Composite(Composite base, DateTimeFormatter[] printers) {\n+        private Composite(Composite base, DateTimePrinter[] printers) {\n             iPrinters = printers;\n             iParsers = base.iParsers;\n             iPrintedLengthEstimate = base.iPrintedLengthEstimate;\n             return iPrintedLengthEstimate;\n         }\n \n-        public void printTo(StringBuffer buf,\n-                            long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) {\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n             DateTimePrinter[] elements = iPrinters;\n             if (elements == null) {\n                 throw new UnsupportedOperationException();\n \n             int len = elements.length;\n             for (int i = 0; i < len; i++) {\n-                elements[i].printTo(buf, instant, chrono, displayOffset, displayZone);\n-            }\n-        }\n-\n-        public void printTo(Writer out,\n-                            long instant, Chronology chrono,\n-                            int displayOffset, DateTimeZone displayZone) throws IOException {\n+                elements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale);\n+            }\n+        }\n+\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n             DateTimePrinter[] elements = iPrinters;\n             if (elements == null) {\n                 throw new UnsupportedOperationException();\n \n             int len = elements.length;\n             for (int i = 0; i < len; i++) {\n-                elements[i].printTo(out, instant, chrono, displayOffset, displayZone);\n-            }\n-        }\n-\n-        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+                elements[i].printTo(out, instant, chrono, displayOffset, displayZone, locale);\n+            }\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n             DateTimePrinter[] elements = iPrinters;\n             if (elements == null) {\n                 throw new UnsupportedOperationException();\n \n             int len = elements.length;\n             for (int i=0; i<len; i++) {\n-                elements[i].printTo(buf, partial);\n-            }\n-        }\n-\n-        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+                elements[i].printTo(buf, partial, locale);\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n             DateTimePrinter[] elements = iPrinters;\n             if (elements == null) {\n                 throw new UnsupportedOperationException();\n \n             int len = elements.length;\n             for (int i=0; i<len; i++) {\n-                elements[i].printTo(out, partial);\n+                elements[i].printTo(out, partial, locale);\n             }\n         }\n \n \n     //-----------------------------------------------------------------------\n     static class MatchingParser\n-            extends BaseDateTimeFormatter\n             implements DateTimeParser {\n \n         private final DateTimeParser[] iParsers;\n             return ~bestInvalidPos;\n         }\n     }\n+\n }\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeParser.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParser.java\n  */\n package org.joda.time.format;\n \n-import org.joda.time.Chronology;\n-import org.joda.time.DateTime;\n-import org.joda.time.MutableDateTime;\n-import org.joda.time.ReadWritableInstant;\n-import org.joda.time.ReadableInstant;\n-\n /**\n- * Defines an interface for parsing textual representations of datetimes.\n+ * Internal interface for parsing textual representations of datetimes.\n+ * <p>\n+ * Application users will rarely use this class directly. Instead, you\n+ * will use one of the factory classes to create a {@link DateTimeFormatter}.\n+ * <p>\n+ * The factory classes are:<br />\n+ * - {@link DateTimeFormatterBuilder}<br />\n+ * - {@link DateTimeFormat}<br />\n+ * - {@link ISODateTimeFormat}<br />\n  *\n  * @author Brian S O'Neill\n  * @see DateTimeFormatter\n public interface DateTimeParser {\n \n     /**\n-     * Returns the expected maximum number of characters consumed. The actual\n-     * amount should rarely exceed this estimate.\n+     * Returns the expected maximum number of characters consumed.\n+     * The actual amount should rarely exceed this estimate.\n      * \n      * @return the estimated length\n      */\n      * where the parse failed, apply the one's complement operator (~) on the\n      * return value.\n      *\n-     * @param bucket  field are saved into this\n-     * @param text  the text to parse\n+     * @param bucket  field are saved into this, not null\n+     * @param text  the text to parse, not null\n      * @param position  position to start parsing from\n      * @return new position, negative value means parse failed -\n      *  apply complement operator (~) to get position of failure\n      */\n     int parseInto(DateTimeParserBucket bucket, String text, int position);\n \n-    /**\n-     * Parses a datetime from the given text, at the given position, saving the\n-     * result into the fields of the given ReadWritableInstant. If the parse\n-     * succeeds, the return value is the new text position. Note that the parse\n-     * may succeed without fully reading the text.\n-     * <p>\n-     * If it fails, the return value is negative, but the instant may still be\n-     * modified. To determine the position where the parse failed, apply the\n-     * one's complement operator (~) on the return value.\n-     * <p>\n-     * The parse will use the chronology of the instant.\n-     *\n-     * @param instant  an instant that will be modified\n-     * @param text  the text to parse\n-     * @param position  position to start parsing from\n-     * @return new position, negative value means parse failed -\n-     *  apply complement operator (~) to get position of failure\n-     * @throws IllegalArgumentException if the instant is null\n-     * @throws IllegalArgumentException if any field is out of range\n-     */\n-    int parseInto(ReadWritableInstant instant, String text, int position);\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Parses a datetime from the given text, returning the number of\n-     * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n-     * <p>\n-     * The parse will use the ISO chronology, and the default time zone.\n-     * If the text contains a time zone string then that will be taken into account.\n-     *\n-     * @param text  text to parse\n-     * @return parsed value expressed in milliseconds since the epoch\n-     * @throws IllegalArgumentException if the text to parse is invalid\n-     */\n-    long parseMillis(String text);\n-\n-    /**\n-     * Parses a datetime from the given text, returning the number of\n-     * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n-     * <p>\n-     * The parse will use the given chronology and time zone.\n-     * If the text contains a time zone string then that will be taken into account.\n-     *\n-     * @param text  the text to parse\n-     * @param chrono  the chronology to use, null means ISO default\n-     * @return parsed value expressed in milliseconds since the epoch\n-     * @throws IllegalArgumentException if the text to parse is invalid\n-     */\n-    long parseMillis(String text, Chronology chrono);\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Parses a datetime from the given text, at the given position, returning\n-     * the number of milliseconds since the epoch, 1970-01-01T00:00:00Z.\n-     * An initial millisecond value is passed in, which is relative to the epoch,\n-     * local time, and which can default field values.\n-     * <p>\n-     * The parse will use the ISO chronology and default time zone.\n-     * If the text contains a time zone string then that will be taken into account.\n-     *\n-     * @param text  the text to parse\n-     * @param instant  initial value of instant, relative to the epoch, local time\n-     * @return parsed value expressed in milliseconds since the epoch, UTC\n-     * @throws IllegalArgumentException if the text to parse is invalid\n-     */\n-    long parseMillis(String text, long instant);\n-\n-    /**\n-     * Parses a datetime from the given text, at the given position, returning\n-     * the number of milliseconds since the epoch, 1970-01-01T00:00:00Z.\n-     * An initial millisecond value is passed in, which is relative to the epoch,\n-     * which can default field values.\n-     * <p>\n-     * The parse will use the given chronology and time zone.\n-     * If the text contains a time zone string then that will be taken into account.\n-     *\n-     * @param text  the text to parse\n-     * @param instant  initial value of instant, relative to the epoch\n-     * @param chrono  the chronology to use, null means ISO default\n-     * @return parsed value expressed in milliseconds since the epoch, UTC\n-     * @throws IllegalArgumentException if the text to parse is invalid\n-     */\n-    long parseMillis(String text, long instant, Chronology chrono);\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Parses a datetime from the given text, returning a new DateTime.\n-     * <p>\n-     * The parse will use the ISO chronology and default time zone.\n-     * If the text contains a time zone string then that will be taken into account.\n-     *\n-     * @param text  the text to parse\n-     * @return parsed value in a DateTime object\n-     * @throws IllegalArgumentException if the text to parse is invalid\n-     */\n-    DateTime parseDateTime(String text);\n-\n-    /**\n-     * Parses a datetime from the given text, returning a new DateTime.\n-     * <p>\n-     * The parse will use the given chronology and time zone.\n-     * If the text contains a time zone string then that will be taken into account.\n-     *\n-     * @param text  the text to parse\n-     * @param chrono  the chronology to use, null means ISO default\n-     * @return parsed value in a DateTime object\n-     * @throws IllegalArgumentException if the text to parse is invalid\n-     */\n-    DateTime parseDateTime(String text, Chronology chrono);\n-\n-    /**\n-     * Parses a datetime from the given text, returning a new DateTime, using\n-     * the given instant to supply field values that were not parsed.\n-     * <p>\n-     * The parse will use the instant's chronology and time zone.\n-     * If the text contains a time zone string then that will be taken into account.\n-     *\n-     * @param text  the text to parse\n-     * @param instant  initial value of DateTime\n-     * @return parsed value in a DateTime object\n-     * @throws IllegalArgumentException if the text to parse is invalid\n-     */\n-    DateTime parseDateTime(String text, ReadableInstant instant);\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Parses a datetime from the given text, returning a new MutableDateTime.\n-     * <p>\n-     * The parse will use the ISO chronology and default time zone.\n-     * If the text contains a time zone string then that will be taken into account.\n-     *\n-     * @param text  the text to parse\n-     * @return parsed value in a MutableDateTime object\n-     * @throws IllegalArgumentException if the text to parse is invalid\n-     */\n-    MutableDateTime parseMutableDateTime(String text);\n-\n-    /**\n-     * Parses a datetime from the given text, returning a new MutableDateTime.\n-     * <p>\n-     * The parse will use the given chronology and time zone.\n-     * If the text contains a time zone string then that will be taken into account.\n-     *\n-     * @param text  the text to parse\n-     * @param chrono  the chronology to use, null means ISO default\n-     * @return parsed value in a MutableDateTime object\n-     * @throws IllegalArgumentException if the text to parse is invalid\n-     */\n-    MutableDateTime parseMutableDateTime(String text, Chronology chrono);\n-\n-    /**\n-     * Parses a datetime from the given text, returning a new MutableDateTime,\n-     * using the given instant to supply field values that were not parsed.\n-     * <p>\n-     * The parse will use the instant's chronology and time zone.\n-     * If the text contains a time zone string then that will be taken into account.\n-     *\n-     * @param text  the text to parse\n-     * @param instant  initial value of DateTime\n-     * @return parsed value in a MutableDateTime object\n-     * @throws IllegalArgumentException if the text to parse is invalid\n-     */\n-    MutableDateTime parseMutableDateTime(String text, ReadableInstant instant);\n-\n }\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java\n  */\n public class DateTimeParserBucket {\n \n+    /** The chronology to use for parsing. */\n     private final Chronology iChrono;\n     private final long iMillis;\n     \n     // TimeZone to switch to in computeMillis. If null, use offset.\n-    DateTimeZone iZone;\n-    int iOffset;\n+    private DateTimeZone iZone;\n+    private int iOffset;\n+    /** The locale to use for parsing. */\n+    private Locale iLocale;\n     \n     SavedField[] iSavedFields = new SavedField[8];\n     int iSavedFieldsCount;\n      * \n      * @param instantLocal the initial millis from 1970-01-01T00:00:00, local time\n      * @param chrono  the chronology to use\n-     */\n-    public DateTimeParserBucket(long instantLocal, Chronology chrono) {\n+     * @param locale  the locale to use\n+     */\n+    public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale) {\n         super();\n         chrono = DateTimeUtils.getChronology(chrono);\n         iMillis = instantLocal;\n         iChrono = chrono.withUTC();\n+        iLocale = (locale == null ? Locale.getDefault() : locale);\n         setZone(chrono.getZone());\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the chronology of the bucket, which will be a local (UTC) chronology.\n     public Chronology getChronology() {\n         return iChrono;\n     }\n-    \n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the locale to be used during parsing.\n+     * \n+     * @return the locale to use\n+     */\n+    public Locale getLocale() {\n+        return iLocale;\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Returns the time zone used by computeMillis, or null if an offset is\n     \n     //-----------------------------------------------------------------------\n     /**\n-     * Returns the time zone offset used by computeMillis, unless\n-     * getZone doesn't return null.\n+     * Returns the time zone offset in milliseconds used by computeMillis,\n+     * unless getZone doesn't return null.\n      */\n     public int getOffset() {\n         return iOffset;\n--- a/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java\n \n import java.io.IOException;\n import java.io.Writer;\n+import java.util.Locale;\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.ReadableInstant;\n import org.joda.time.ReadablePartial;\n \n /**\n- * Defines an interface for creating textual representations of datetimes.\n+ * Internal interface for creating textual representations of datetimes.\n  * <p>\n- * Instances of this interface are provided by the various builder classes.\n+ * Application users will rarely use this class directly. Instead, you\n+ * will use one of the factory classes to create a {@link DateTimeFormatter}.\n+ * <p>\n+ * The factory classes are:<br />\n+ * - {@link DateTimeFormatterBuilder}<br />\n+ * - {@link DateTimeFormat}<br />\n+ * - {@link ISODateTimeFormat}<br />\n  *\n  * @author Brian S O'Neill\n  * @author Stephen Colebourne\n public interface DateTimePrinter {\n \n     /**\n-     * Returns the expected maximum number of characters produced. The actual\n-     * amount should rarely exceed this estimate.\n+     * Returns the expected maximum number of characters produced.\n+     * The actual amount should rarely exceed this estimate.\n      * \n      * @return the estimated length\n      */\n     int estimatePrintedLength();\n-\n-    /**\n-     * Prints a ReadableInstant, using the chronology supplied by the instant.\n-     *\n-     * @param buf  formatted instant is appended to this buffer\n-     * @param instant  instant to format, null means now\n-     */\n-    void printTo(StringBuffer buf, ReadableInstant instant);\n-\n-    /**\n-     * Prints a ReadableInstant, using the chronology supplied by the instant.\n-     *\n-     * @param out  formatted instant is written out\n-     * @param instant  instant to format, null means now\n-     */\n-    void printTo(Writer out, ReadableInstant instant) throws IOException;\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * using ISO chronology in the default DateTimeZone.\n-     *\n-     * @param buf  formatted instant is appended to this buffer\n-     * @param instant  millis since 1970-01-01T00:00:00Z\n-     */\n-    void printTo(StringBuffer buf, long instant);\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * using ISO chronology in the default DateTimeZone.\n-     *\n-     * @param out  formatted instant is written out\n-     * @param instant  millis since 1970-01-01T00:00:00Z\n-     */\n-    void printTo(Writer out, long instant) throws IOException;\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * using ISO chronology in the given DateTimeZone.\n-     *\n-     * @param buf  formatted instant is appended to this buffer\n-     * @param instant  millis since 1970-01-01T00:00:00Z\n-     * @param zone  the zone to use, null means default\n-     */\n-    void printTo(StringBuffer buf, long instant, DateTimeZone zone);\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * using ISO chronology in the given DateTimeZone.\n-     *\n-     * @param out  formatted instant is written out\n-     * @param instant  millis since 1970-01-01T00:00:00Z\n-     * @param zone  the zone to use, null means default\n-     */\n-    void printTo(Writer out, long instant, DateTimeZone zone) throws IOException;\n \n     //-----------------------------------------------------------------------\n     /**\n      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n      * using the given Chronology.\n      *\n-     * @param buf  formatted instant is appended to this buffer\n+     * @param buf  formatted instant is appended to this buffer, not null\n      * @param instant  millis since 1970-01-01T00:00:00Z\n-     * @param chrono  the chronology to use, null means ISO default\n+     * @param chrono  the chronology to use, not null\n+     * @param displayOffset  if a time zone offset is printed, force it to use\n+     * this millisecond value\n+     * @param displayZone  the time zone to use, null means local time\n+     * @param locale  the locale to use, null means default locale\n      */\n-    void printTo(StringBuffer buf, long instant, Chronology chrono);\n+    void printTo(StringBuffer buf, long instant, Chronology chrono,\n+                 int displayOffset, DateTimeZone displayZone, Locale locale);\n \n     /**\n      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n      *\n      * @param out  formatted instant is written out\n      * @param instant  millis since 1970-01-01T00:00:00Z\n-     * @param chrono  the chronology to use, null means ISO default\n-     */\n-    void printTo(Writer out, long instant, Chronology chrono) throws IOException;\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * using the given Chronology.\n-     *\n-     * @param buf  formatted instant is appended to this buffer\n-     * @param instant  millis since 1970-01-01T00:00:00Z\n-     * @param chrono  the chronology to use, null means ISO default\n+     * @param chrono  the chronology to use, not null\n      * @param displayOffset  if a time zone offset is printed, force it to use\n      * this millisecond value\n-     * @param displayZone  if a time zone is printed, force it to use this one\n-     */\n-    void printTo(StringBuffer buf, long instant, Chronology chrono,\n-                 int displayOffset, DateTimeZone displayZone);\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * using the given Chronology.\n-     *\n-     * @param out  formatted instant is written out\n-     * @param instant  millis since 1970-01-01T00:00:00Z\n-     * @param chrono  the chronology to use, null means ISO default\n-     * @param displayOffset  if a time zone offset is printed, force it to use\n-     * this millisecond value\n-     * @param displayZone  if a time zone is printed, force it to use this one\n+     * @param displayZone  the time zone to use, null means local time\n+     * @param locale  the locale to use, null means default locale\n      */\n     void printTo(Writer out, long instant, Chronology chrono,\n-                 int displayOffset, DateTimeZone displayZone) throws IOException;\n+                 int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException;\n \n     //-----------------------------------------------------------------------\n     /**\n      * Prints a ReadablePartial.\n      *\n-     * @param buf  formatted partial is appended to this buffer\n-     * @param partial  partial to format\n+     * @param buf  formatted partial is appended to this buffer, not null\n+     * @param partial  partial to format, not null\n+     * @param locale  the locale to use, null means default locale\n      */\n-    void printTo(StringBuffer buf, ReadablePartial partial);\n+    void printTo(StringBuffer buf, ReadablePartial partial, Locale locale);\n \n     /**\n      * Prints a ReadablePartial.\n      *\n-     * @param out  formatted partial is written out\n-     * @param partial  partial to format\n+     * @param out  formatted partial is written out, not null\n+     * @param partial  partial to format, not null\n+     * @param locale  the locale to use, null means default locale\n      */\n-    void printTo(Writer out, ReadablePartial partial) throws IOException;\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Prints a ReadableInstant to a new String, using the chronology of the instant.\n-     *\n-     * @param instant  instant to format, null means now\n-     * @return the printed result\n-     */\n-    String print(ReadableInstant instant);\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * using ISO chronology in the default zone.\n-     *\n-     * @param instant  millis since 1970-01-01T00:00:00Z\n-     * @return the printed result\n-     */\n-    String print(long instant);\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * using ISO chronology in the given zone.\n-     *\n-     * @param instant  millis since 1970-01-01T00:00:00Z\n-     * @param zone  the zone to use, null means default\n-     * @return the printed result\n-     */\n-    String print(long instant, DateTimeZone zone);\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * using the given chronology.\n-     *\n-     * @param instant  millis since 1970-01-01T00:00:00Z\n-     * @param chrono  the chronoogy to use\n-     * @return the printed result\n-     */\n-    String print(long instant, Chronology chrono);\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * using the given chronology.\n-     *\n-     * @param instant  millis since 1970-01-01T00:00:00Z\n-     * @param chrono  the chronoogy to use\n-     * @param displayOffset  if a time zone offset is printed, force it to use\n-     * this millisecond value\n-     * @param displayZone  if a time zone is printed, force it to use this one\n-     * @return the printed result\n-     */\n-    String print(long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone);\n-\n-    /**\n-     * Prints a ReadablePartial to a new String.\n-     *\n-     * @param partial  partial to format\n-     * @return the printed result\n-     */\n-    String print(ReadablePartial partial);\n+    void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException;\n \n }\n--- a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java\n     private static final ISODateTimeFormat INSTANCE = new ISODateTimeFormat();\n \n     /**\n-     * Gets an instance of a the format provider.\n-     * \n-     * @return a format provider\n+     * Deprecated, use static methods instead.\n+     * \n+     * @deprecated remove method call, as methods are now static\n      */\n     public static ISODateTimeFormat getInstance() {\n         return INSTANCE;\n     }\n \n     //-----------------------------------------------------------------------\n-    private transient DateTimeFormatter\n+    private static DateTimeFormatter\n         ye,  // year element (yyyy)\n         mye, // monthOfYear element (-MM)\n         dme, // dayOfMonth element (-dd)\n \n         bwd,  // basic week date\n         bwdt, // basic week date time\n-        bwdtx; // basic week date time no millis\n-\n-    private transient DateTimeParser\n+        bwdtx, // basic week date time no millis\n+\n         dpe, // date parser element\n         tpe, // time parser element\n         dp,  // date parser\n      * offset            = 'Z' | (('+' | '-') HH [':' mm [':' ss [('.' | ',') SSS]]])\n      * </pre>\n      */\n-    public DateTimeParser dateParser() {\n+    public static DateTimeFormatter dateParser() {\n         if (dp == null) {\n             dp = new DateTimeFormatterBuilder()\n                 .append(dateElementParser())\n                  .appendLiteral('T')\n                  .append(offsetElement())\n                  .toParser())\n-                .toParser();\n+                .toFormatter();\n         }\n         return dp;\n     }\n      * week-date-element = xxxx '-W' ww ['-' e]\n      * </pre>\n      */\n-    public DateTimeParser dateElementParser() {\n+    public static DateTimeFormatter dateElementParser() {\n         if (dpe == null) {\n             dpe = new DateTimeFormatterBuilder()\n                 .append(null, new DateTimeParser[] {\n                     .appendOptional\n                     (new DateTimeFormatterBuilder()\n                      .append(monthElement())\n-                     .appendOptional(dayOfMonthElement())\n+                     .appendOptional(dayOfMonthElement().getParser())\n                      .toParser())\n                     .toParser(),\n                     new DateTimeFormatterBuilder()\n                     .append(weekyearElement())\n                     .append(weekElement())\n-                    .appendOptional(dayOfWeekElement())\n+                    .appendOptional(dayOfWeekElement().getParser())\n                     .toParser(),\n                     new DateTimeFormatterBuilder()\n                     .append(yearElement())\n                     .append(dayOfYearElement())\n                     .toParser()\n                 })\n-                .toParser();\n+                .toFormatter();\n         }\n         return dpe;\n     }\n      * offset         = 'Z' | (('+' | '-') HH [':' mm [':' ss [('.' | ',') SSS]]])\n      * </pre>\n      */\n-    public DateTimeParser timeParser() {\n+    public static DateTimeFormatter timeParser() {\n         if (tp == null) {\n             tp = new DateTimeFormatterBuilder()\n                 .appendOptional\n                  .appendLiteral('T')\n                  .toParser())\n                 .append(timeElementParser())\n-                .appendOptional(offsetElement())\n-                .toParser();\n+                .appendOptional(offsetElement().getParser())\n+                .toFormatter();\n         }\n         return tp;\n     }\n      * fraction       = ('.' | ',') digit+\n      * </pre>\n      */\n-    public DateTimeParser timeElementParser() {\n+    public static DateTimeFormatter timeElementParser() {\n         if (tpe == null) {\n             // Decimal point can be either '.' or ','\n             DateTimeParser decimalPoint = new DateTimeFormatterBuilder()\n                     .toParser(),\n                     null\n                 })\n-                .toParser();\n+                .toFormatter();\n         }\n         return tpe;\n     }\n      * offset            = 'Z' | (('+' | '-') HH [':' mm [':' ss [('.' | ',') SSS]]])\n      * </pre>\n      */\n-    public DateTimeParser dateTimeParser() {\n+    public static DateTimeFormatter dateTimeParser() {\n         if (dtp == null) {\n             // This is different from the general time parser in that the 'T'\n             // is required.\n             DateTimeParser time = new DateTimeFormatterBuilder()\n                 .appendLiteral('T')\n                 .append(timeElementParser())\n-                .appendOptional(offsetElement())\n+                .appendOptional(offsetElement().getParser())\n                 .toParser();\n \n             dtp = new DateTimeFormatterBuilder()\n                     })\n                     .toParser()\n                 })\n-                .toParser();\n+                .toFormatter();\n         }\n         return dtp;\n     }\n      * \n      * @return a formatter for yyyy-MM-dd\n      */\n-    public DateTimeFormatter date() {\n+    public static DateTimeFormatter date() {\n         return yearMonthDay();\n     }\n \n      * \n      * @return a formatter for HH:mm:ss.SSSZ\n      */\n-    public DateTimeFormatter time() {\n+    public static DateTimeFormatter time() {\n         if (t == null) {\n             t = new DateTimeFormatterBuilder()\n                 .append(hourMinuteSecondMillis())\n      * \n      * @return a formatter for HH:mm:ssZ\n      */\n-    public DateTimeFormatter timeNoMillis() {\n+    public static DateTimeFormatter timeNoMillis() {\n         if (tx == null) {\n             tx = new DateTimeFormatterBuilder()\n                 .append(hourMinuteSecond())\n      * \n      * @return a formatter for 'T'HH:mm:ss.SSSZ\n      */\n-    public DateTimeFormatter tTime() {\n+    public static DateTimeFormatter tTime() {\n         if (tt == null) {\n             tt = new DateTimeFormatterBuilder()\n                 .append(literalTElement())\n      * \n      * @return a formatter for 'T'HH:mm:ssZ\n      */\n-    public DateTimeFormatter tTimeNoMillis() {\n+    public static DateTimeFormatter tTimeNoMillis() {\n         if (ttx == null) {\n             ttx = new DateTimeFormatterBuilder()\n                 .append(literalTElement())\n      * \n      * @return a formatter for yyyy-MM-dd'T'HH:mm:ss.SSSZ\n      */\n-    public DateTimeFormatter dateTime() {\n+    public static DateTimeFormatter dateTime() {\n         if (dt == null) {\n             dt = new DateTimeFormatterBuilder()\n                 .append(date())\n      * \n      * @return a formatter for yyyy-MM-dd'T'HH:mm:ssZ\n      */\n-    public DateTimeFormatter dateTimeNoMillis() {\n+    public static DateTimeFormatter dateTimeNoMillis() {\n         if (dtx == null) {\n             dtx = new DateTimeFormatterBuilder()\n                 .append(date())\n      * \n      * @return a formatter for xxxx-'W'ww-e\n      */\n-    public DateTimeFormatter weekDate() {\n+    public static DateTimeFormatter weekDate() {\n         return weekyearWeekDay();\n     }\n \n      * \n      * @return a formatter for xxxx-'W'ww-e'T'HH:mm:ss.SSSZ\n      */\n-    public DateTimeFormatter weekDateTime() {\n+    public static DateTimeFormatter weekDateTime() {\n         if (wdt == null) {\n             wdt = new DateTimeFormatterBuilder()\n                 .append(weekDate())\n      * \n      * @return a formatter for xxxx-'W'ww-e'T'HH:mm:ssZ\n      */\n-    public DateTimeFormatter weekDateTimeNoMillis() {\n+    public static DateTimeFormatter weekDateTimeNoMillis() {\n         if (wdtx == null) {\n             wdtx = new DateTimeFormatterBuilder()\n                 .append(weekDate())\n      * \n      * @return a formatter for yyyyMMdd\n      */\n-    public DateTimeFormatter basicDate() {\n+    public static DateTimeFormatter basicDate() {\n         if (bd == null) {\n             bd = new DateTimeFormatterBuilder()\n                 .appendYear(4, 4)\n      * \n      * @return a formatter for HHmmss.SSSZ\n      */\n-    public DateTimeFormatter basicTime() {\n+    public static DateTimeFormatter basicTime() {\n         if (bt == null) {\n             bt = new DateTimeFormatterBuilder()\n                 .appendHourOfDay(2)\n      * \n      * @return a formatter for HHmmssZ\n      */\n-    public DateTimeFormatter basicTimeNoMillis() {\n+    public static DateTimeFormatter basicTimeNoMillis() {\n         if (btx == null) {\n             btx = new DateTimeFormatterBuilder()\n                 .appendHourOfDay(2)\n      * \n      * @return a formatter for 'T'HHmmss.SSSZ\n      */\n-    public DateTimeFormatter basicTTime() {\n+    public static DateTimeFormatter basicTTime() {\n         if (btt == null) {\n             btt = new DateTimeFormatterBuilder()\n                 .append(literalTElement())\n      * \n      * @return a formatter for 'T'HHmmssZ\n      */\n-    public DateTimeFormatter basicTTimeNoMillis() {\n+    public static DateTimeFormatter basicTTimeNoMillis() {\n         if (bttx == null) {\n             bttx = new DateTimeFormatterBuilder()\n                 .append(literalTElement())\n      * \n      * @return a formatter for yyyyMMdd'T'HHmmss.SSSZ\n      */\n-    public DateTimeFormatter basicDateTime() {\n+    public static DateTimeFormatter basicDateTime() {\n         if (bdt == null) {\n             bdt = new DateTimeFormatterBuilder()\n                 .append(basicDate())\n      * \n      * @return a formatter for yyyyMMdd'T'HHmmssZ\n      */\n-    public DateTimeFormatter basicDateTimeNoMillis() {\n+    public static DateTimeFormatter basicDateTimeNoMillis() {\n         if (bdtx == null) {\n             bdtx = new DateTimeFormatterBuilder()\n                 .append(basicDate())\n      * \n      * @return a formatter for xxxx'W'wwe\n      */\n-    public DateTimeFormatter basicWeekDate() {\n+    public static DateTimeFormatter basicWeekDate() {\n         if (bwd == null) {\n             bwd = new DateTimeFormatterBuilder()\n                 .appendWeekyear(4, 4)\n      * \n      * @return a formatter for xxxx'W'wwe'T'HHmmss.SSSZ\n      */\n-    public DateTimeFormatter basicWeekDateTime() {\n+    public static DateTimeFormatter basicWeekDateTime() {\n         if (bwdt == null) {\n             bwdt = new DateTimeFormatterBuilder()\n                 .append(basicWeekDate())\n      * \n      * @return a formatter for xxxx'W'wwe'T'HHmmssZ\n      */\n-    public DateTimeFormatter basicWeekDateTimeNoMillis() {\n+    public static DateTimeFormatter basicWeekDateTimeNoMillis() {\n         if (bwdtx == null) {\n             bwdtx = new DateTimeFormatterBuilder()\n                 .append(basicWeekDate())\n      * \n      * @return a formatter for yyyy\n      */\n-    public DateTimeFormatter year() {\n+    public static DateTimeFormatter year() {\n         return yearElement();\n     }\n \n      * \n      * @return a formatter for yyyy-MM\n      */\n-    public DateTimeFormatter yearMonth() {\n+    public static DateTimeFormatter yearMonth() {\n         if (ym == null) {\n             ym = new DateTimeFormatterBuilder()\n                 .append(yearElement())\n      * \n      * @return a formatter for yyyy-MM-dd\n      */\n-    public DateTimeFormatter yearMonthDay() {\n+    public static DateTimeFormatter yearMonthDay() {\n         if (ymd == null) {\n             ymd = new DateTimeFormatterBuilder()\n                 .append(yearElement())\n      * \n      * @return a formatter for xxxx\n      */\n-    public DateTimeFormatter weekyear() {\n+    public static DateTimeFormatter weekyear() {\n         return weekyearElement();\n     }\n \n      * \n      * @return a formatter for xxxx-'W'ww\n      */\n-    public DateTimeFormatter weekyearWeek() {\n+    public static DateTimeFormatter weekyearWeek() {\n         if (ww == null) {\n             ww = new DateTimeFormatterBuilder()\n                 .append(weekyearElement())\n      * \n      * @return a formatter for xxxx-'W'ww-e\n      */\n-    public DateTimeFormatter weekyearWeekDay() {\n+    public static DateTimeFormatter weekyearWeekDay() {\n         if (wwd == null) {\n             wwd = new DateTimeFormatterBuilder()\n                 .append(weekyearElement())\n      * \n      * @return a formatter for HH\n      */\n-    public DateTimeFormatter hour() {\n+    public static DateTimeFormatter hour() {\n         return hourElement();\n     }\n \n      * \n      * @return a formatter for HH:mm\n      */\n-    public DateTimeFormatter hourMinute() {\n+    public static DateTimeFormatter hourMinute() {\n         if (hm == null) {\n             hm = new DateTimeFormatterBuilder()\n                 .append(hourElement())\n      * \n      * @return a formatter for HH:mm:ss\n      */\n-    public DateTimeFormatter hourMinuteSecond() {\n+    public static DateTimeFormatter hourMinuteSecond() {\n         if (hms == null) {\n             hms = new DateTimeFormatterBuilder()\n                 .append(hourElement())\n      * \n      * @return a formatter for HH:mm:ss.SSS\n      */\n-    public DateTimeFormatter hourMinuteSecondMillis() {\n+    public static DateTimeFormatter hourMinuteSecondMillis() {\n         if (hmsl == null) {\n             hmsl = new DateTimeFormatterBuilder()\n                 .append(hourElement())\n      * \n      * @return a formatter for HH:mm:ss.SSS\n      */\n-    public DateTimeFormatter hourMinuteSecondFraction() {\n+    public static DateTimeFormatter hourMinuteSecondFraction() {\n         if (hmsf == null) {\n             hmsf = new DateTimeFormatterBuilder()\n                 .append(hourElement())\n      * \n      * @return a formatter for yyyy-MM-dd'T'HH\n      */\n-    public DateTimeFormatter dateHour() {\n+    public static DateTimeFormatter dateHour() {\n         if (dh == null) {\n             dh = new DateTimeFormatterBuilder()\n                 .append(date())\n      * \n      * @return a formatter for yyyy-MM-dd'T'HH:mm\n      */\n-    public DateTimeFormatter dateHourMinute() {\n+    public static DateTimeFormatter dateHourMinute() {\n         if (dhm == null) {\n             dhm = new DateTimeFormatterBuilder()\n                 .append(date())\n      * \n      * @return a formatter for yyyy-MM-dd'T'HH:mm:ss\n      */\n-    public DateTimeFormatter dateHourMinuteSecond() {\n+    public static DateTimeFormatter dateHourMinuteSecond() {\n         if (dhms == null) {\n             dhms = new DateTimeFormatterBuilder()\n                 .append(date())\n      * \n      * @return a formatter for yyyy-MM-dd'T'HH:mm:ss.SSS\n      */\n-    public DateTimeFormatter dateHourMinuteSecondMillis() {\n+    public static DateTimeFormatter dateHourMinuteSecondMillis() {\n         if (dhmsl == null) {\n             dhmsl = new DateTimeFormatterBuilder()\n                 .append(date())\n      * \n      * @return a formatter for yyyy-MM-dd'T'HH:mm:ss.SSS\n      */\n-    public DateTimeFormatter dateHourMinuteSecondFraction() {\n+    public static DateTimeFormatter dateHourMinuteSecondFraction() {\n         if (dhmsf == null) {\n             dhmsf = new DateTimeFormatterBuilder()\n                 .append(date())\n     }\n \n     //-----------------------------------------------------------------------\n-    private DateTimeFormatter yearElement() {\n+    private static DateTimeFormatter yearElement() {\n         if (ye == null) {\n             ye = new DateTimeFormatterBuilder()\n                 .appendYear(4, 9)\n         return ye;\n     }\n \n-    private DateTimeFormatter monthElement() {\n+    private static DateTimeFormatter monthElement() {\n         if (mye == null) {\n             mye = new DateTimeFormatterBuilder()\n                 .appendLiteral('-')\n         return mye;\n     }\n \n-    private DateTimeFormatter dayOfMonthElement() {\n+    private static DateTimeFormatter dayOfMonthElement() {\n         if (dme == null) {\n             dme = new DateTimeFormatterBuilder()\n                 .appendLiteral('-')\n         return dme;\n     }\n \n-    private DateTimeFormatter weekyearElement() {\n+    private static DateTimeFormatter weekyearElement() {\n         if (we == null) {\n             we = new DateTimeFormatterBuilder()\n                 .appendWeekyear(4, 9)\n         return we;\n     }\n \n-    private DateTimeFormatter weekElement() {\n+    private static DateTimeFormatter weekElement() {\n         if (wwe == null) {\n             wwe = new DateTimeFormatterBuilder()\n                 .appendLiteral(\"-W\")\n         return wwe;\n     }\n \n-    private DateTimeFormatter dayOfWeekElement() {\n+    private static DateTimeFormatter dayOfWeekElement() {\n         if (dwe == null) {\n             dwe = new DateTimeFormatterBuilder()\n                 .appendLiteral('-')\n         return dwe;\n     }\n \n-    private DateTimeFormatter dayOfYearElement() {\n+    private static DateTimeFormatter dayOfYearElement() {\n         if (dye == null) {\n             dye = new DateTimeFormatterBuilder()\n                 .appendLiteral('-')\n         return dye;\n     }\n     \n-    private DateTimeFormatter literalTElement() {\n+    private static DateTimeFormatter literalTElement() {\n         if (lte == null) {\n             lte = new DateTimeFormatterBuilder()\n                 .appendLiteral('T')\n         return lte;\n     }\n \n-    private DateTimeFormatter hourElement() {\n+    private static DateTimeFormatter hourElement() {\n         if (hde == null) {\n             hde = new DateTimeFormatterBuilder()\n                 .appendHourOfDay(2)\n         return hde;\n     }\n \n-    private DateTimeFormatter minuteElement() {\n+    private static DateTimeFormatter minuteElement() {\n         if (mhe == null) {\n             mhe = new DateTimeFormatterBuilder()\n                 .appendLiteral(':')\n         return mhe;\n     }\n \n-    private DateTimeFormatter secondElement() {\n+    private static DateTimeFormatter secondElement() {\n         if (sme == null) {\n             sme = new DateTimeFormatterBuilder()\n                 .appendLiteral(':')\n         return sme;\n     }\n \n-    private DateTimeFormatter millisElement() {\n+    private static DateTimeFormatter millisElement() {\n         if (lse == null) {\n             lse = new DateTimeFormatterBuilder()\n                 .appendLiteral('.')\n         return lse;\n     }\n \n-    private DateTimeFormatter fractionElement() {\n+    private static DateTimeFormatter fractionElement() {\n         if (fse == null) {\n             fse = new DateTimeFormatterBuilder()\n                 .appendLiteral('.')\n         return fse;\n     }\n \n-    private DateTimeFormatter offsetElement() {\n+    private static DateTimeFormatter offsetElement() {\n         if (ze == null) {\n             ze = new DateTimeFormatterBuilder()\n                 .appendTimeZoneOffset(\"Z\", true, 2, 4)\n--- a/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java\n+++ b/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeZone;\n import org.joda.time.MutableDateTime;\n-import org.joda.time.format.DateTimeParser;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.chrono.LenientChronology;\n+import org.joda.time.format.DateTimeFormatter;\n import org.joda.time.format.ISODateTimeFormat;\n-import org.joda.time.chrono.LenientChronology;\n-import org.joda.time.chrono.ISOChronology;\n \n /**\n  * Compiles Olson ZoneInfo database files into binary files for each time zone\n     }\n \n     static int parseTime(String str) {\n-        DateTimeParser p = ISODateTimeFormat.getInstance().hourMinuteSecondFraction();\n+        DateTimeFormatter p = ISODateTimeFormat.hourMinuteSecondFraction();\n         MutableDateTime mdt = new MutableDateTime(0, getLenientISOChronology());\n         int pos = 0;\n         if (str.startsWith(\"-\")) {\n--- a/JodaTime/src/test/org/joda/time/TestParseISO.java\n+++ b/JodaTime/src/test/org/joda/time/TestParseISO.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n-import org.joda.time.format.DateTimeParser;\n+import org.joda.time.format.DateTimeFormatter;\n import org.joda.time.format.ISODateTimeFormat;\n \n /**\n             }\n             assertEquals(msg + \"\\nZone: \", z, dt.getZone());\n         }\n-        protected void parse(DateTimeParser p) {\n+        protected void parse(DateTimeFormatter p) {\n             int result = p.parseInto(dt, extended, 0);\n             assertTrue(\"\\nSpec:   \" + spec + \"\\nParsed: \" + extended + \"\\nTo:     \"\n                 + dt + \"\\nParse failed at: \" + ~result,\n         }            \n         protected void run() {\n             dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);\n-            parse(ISODateTimeFormat.getInstance().dateTimeParser());\n+            parse(ISODateTimeFormat.dateTimeParser());\n             super.assertDate();\n         }\n     }\n         }\n         protected void run() {\n             dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);\n-            parse(ISODateTimeFormat.getInstance().dateParser());\n+            parse(ISODateTimeFormat.dateParser());\n             super.assertDate();\n         \n             dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);\n-            parse(ISODateTimeFormat.getInstance().dateTimeParser());\n+            parse(ISODateTimeFormat.dateTimeParser());\n             super.assertDate();\n         }\n     }\n         }\n         protected void run() {\n             dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);\n-            parse(ISODateTimeFormat.getInstance().timeParser());\n+            parse(ISODateTimeFormat.timeParser());\n             super.assertDate();\n             \n             extended = \"T\" + extended;\n             dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);\n-            parse(ISODateTimeFormat.getInstance().timeParser());\n+            parse(ISODateTimeFormat.timeParser());\n             super.assertDate();\n             \n             dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);\n-            parse(ISODateTimeFormat.getInstance().dateTimeParser());\n+            parse(ISODateTimeFormat.dateTimeParser());\n             super.assertDate();\n         }\n     }\n--- a/JodaTime/src/test/org/joda/time/format/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/format/TestAll.java\n     public static Test suite() {\n         TestSuite suite = new TestSuite();\n         \n+        suite.addTest(TestDateTimeFormatter.suite());\n         suite.addTest(TestDateTimeFormat.suite());\n         suite.addTest(TestISODateTimeFormat.suite());\n         \n--- a/JodaTime/src/test/org/joda/time/format/TestDateTimeFormat.java\n+++ b/JodaTime/src/test/org/joda/time/format/TestDateTimeFormat.java\n     //-----------------------------------------------------------------------\n     public void testFormat_era() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"G\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"G\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"AD\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n     //-----------------------------------------------------------------------\n     public void testFormat_centuryOfEra() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"C\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"C\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"20\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n     //-----------------------------------------------------------------------\n     public void testFormat_yearOfEra() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"Y\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"Y\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"2004\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n     //-----------------------------------------------------------------------\n     public void testFormat_year() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"y\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"y\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"2004\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n     //-----------------------------------------------------------------------\n     public void testFormat_weekyear() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"x\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"x\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"2004\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n     //-----------------------------------------------------------------------\n     public void testFormat_weekOfWeekyear() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"w\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"w\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"24\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n     //-----------------------------------------------------------------------\n     public void testFormat_dayOfWeek() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"e\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"e\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"3\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n     //-----------------------------------------------------------------------\n     public void testFormat_dayOfWeekShortText() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"E\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"E\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"Wed\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n         \n         dt = dt.withZone(TOKYO);\n         assertEquals(dt.toString(), \"Wed\", f.print(dt));\n+        \n+        f = f.withLocale(Locale.FRENCH);\n+        assertEquals(dt.toString(), \"mer.\", f.print(dt));\n     }\n \n     //-----------------------------------------------------------------------\n     public void testFormat_dayOfWeekText() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"EEEE\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"EEEE\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"Wednesday\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n         \n         dt = dt.withZone(TOKYO);\n         assertEquals(dt.toString(), \"Wednesday\", f.print(dt));\n+        \n+        f = f.withLocale(Locale.FRENCH);\n+        assertEquals(dt.toString(), \"mercredi\", f.print(dt));\n     }\n \n     //-----------------------------------------------------------------------\n     public void testFormat_dayOfYearText() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"D\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"D\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"161\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n     //-----------------------------------------------------------------------\n     public void testFormat_monthOfYear() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"M\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"6\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n     //-----------------------------------------------------------------------\n     public void testFormat_monthOfYearShortText() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"MMM\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"MMM\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"Jun\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n         \n         dt = dt.withZone(TOKYO);\n         assertEquals(dt.toString(), \"Jun\", f.print(dt));\n+        \n+        f = f.withLocale(Locale.FRENCH);\n+        assertEquals(dt.toString(), \"juin\", f.print(dt));\n     }\n \n     //-----------------------------------------------------------------------\n     public void testFormat_monthOfYearText() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"MMMM\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"MMMM\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"June\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n         \n         dt = dt.withZone(TOKYO);\n         assertEquals(dt.toString(), \"June\", f.print(dt));\n+        \n+        f = f.withLocale(Locale.FRENCH);\n+        assertEquals(dt.toString(), \"juin\", f.print(dt));\n     }\n \n     //-----------------------------------------------------------------------\n     public void testFormat_dayOfMonth() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"d\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"d\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"9\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n     //-----------------------------------------------------------------------\n     public void testFormat_halfdayOfDay() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"a\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"a\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"AM\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n     //-----------------------------------------------------------------------\n     public void testFormat_hourOfHalfday() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"K\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"K\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"10\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n     //-----------------------------------------------------------------------\n     public void testFormat_clockhourOfHalfday() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"h\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"h\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"10\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n     //-----------------------------------------------------------------------\n     public void testFormat_hourOfDay() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"H\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"H\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"10\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n     //-----------------------------------------------------------------------\n     public void testFormat_clockhourOfDay() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"k\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"k\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"10\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n     //-----------------------------------------------------------------------\n     public void testFormat_minute() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"m\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"m\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"20\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n     //-----------------------------------------------------------------------\n     public void testFormat_second() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"s\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"s\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"30\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n     //-----------------------------------------------------------------------\n     public void testFormat_fractionOfSecond() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"SSS\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"SSS\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"040\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n     //-----------------------------------------------------------------------\n     public void testFormat_zoneText() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"z\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"z\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"UTC\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n     //-----------------------------------------------------------------------\n     public void testFormat_zoneAmount() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"Z\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"Z\").withLocale(Locale.UK);\n         assertEquals(dt.toString(), \"+0000\", f.print(dt));\n         \n         dt = dt.withZone(NEWYORK);\n     //-----------------------------------------------------------------------\n     public void testFormat_other() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        DateTimeFormatter f = DateTimeFormat.getInstance(Locale.UK).forPattern(\"'Hello' ''\");\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"'Hello' ''\");\n         assertEquals(\"Hello '\", f.print(dt));\n     }\n \n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/format/TestDateTimeFormatter.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.format;\n+\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.MutableDateTime;\n+\n+/**\n+ * This class is a Junit unit test for DateTime Formating.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestDateTimeFormatter extends TestCase {\n+\n+    private static final DateTimeZone UTC = DateTimeZone.UTC;\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n+    private static final DateTimeZone TOKYO = DateTimeZone.forID(\"Asia/Tokyo\");\n+    private static final DateTimeZone NEWYORK = DateTimeZone.forID(\"America/New_York\");\n+    private static final Chronology ISO_UTC = Chronology.getISOUTC();\n+    private static final Chronology ISO_PARIS = Chronology.getISO(PARIS);\n+    private static final Chronology BUDDHIST_PARIS = Chronology.getBuddhist(PARIS);\n+\n+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365;\n+    // 2002-06-09\n+    private long TEST_TIME_NOW =\n+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    private DateTimeZone originalDateTimeZone = null;\n+    private TimeZone originalTimeZone = null;\n+    private Locale originalLocale = null;\n+    private DateTimeFormatter f = null;\n+    private DateTimeFormatter g = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestDateTimeFormatter.class);\n+    }\n+\n+    public TestDateTimeFormatter(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        originalDateTimeZone = DateTimeZone.getDefault();\n+        originalTimeZone = TimeZone.getDefault();\n+        originalLocale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n+        Locale.setDefault(Locale.UK);\n+        f = new DateTimeFormatterBuilder()\n+                .appendDayOfWeekShortText()\n+                .appendLiteral(' ')\n+                .append(ISODateTimeFormat.dateTimeNoMillis())\n+                .toFormatter();\n+        g = ISODateTimeFormat.dateTimeNoMillis();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(originalDateTimeZone);\n+        TimeZone.setDefault(originalTimeZone);\n+        Locale.setDefault(originalLocale);\n+        originalDateTimeZone = null;\n+        originalTimeZone = null;\n+        originalLocale = null;\n+        f = null;\n+        g = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPrint_simple() {\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n+        assertEquals(\"Wed 2004-06-09T10:20:30Z\", f.print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"Wed 2004-06-09T12:20:30+02:00\", f.print(dt));\n+        \n+        dt = dt.withZone(NEWYORK);\n+        assertEquals(\"Wed 2004-06-09T06:20:30-04:00\", f.print(dt));\n+        \n+        dt = dt.withChronology(BUDDHIST_PARIS);\n+        assertEquals(\"Wed 2547-06-09T12:20:30+02:00\", f.print(dt));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPrint_locale() {\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n+        assertEquals(\"mer. 2004-06-09T10:20:30Z\", f.withLocale(Locale.FRENCH).print(dt));\n+        assertEquals(\"Wed 2004-06-09T10:20:30Z\", f.withLocale(null).print(dt));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPrint_zone() {\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n+        assertEquals(\"Wed 2004-06-09T06:20:30-04:00\", f.withZone(NEWYORK).print(dt));\n+        assertEquals(\"Wed 2004-06-09T12:20:30+02:00\", f.withZone(PARIS).print(dt));\n+        assertEquals(\"Wed 2004-06-09T10:20:30Z\", f.withZone(null).print(dt));\n+        \n+        dt = dt.withZone(NEWYORK);\n+        assertEquals(\"Wed 2004-06-09T06:20:30-04:00\", f.withZone(NEWYORK).print(dt));\n+        assertEquals(\"Wed 2004-06-09T12:20:30+02:00\", f.withZone(PARIS).print(dt));\n+        assertEquals(\"Wed 2004-06-09T10:20:30Z\", f.withZone(UTC).print(dt));\n+        assertEquals(\"Wed 2004-06-09T06:20:30-04:00\", f.withZone(null).print(dt));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPrint_chrono() {\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n+        assertEquals(\"Wed 2004-06-09T12:20:30+02:00\", f.withChronology(ISO_PARIS).print(dt));\n+        assertEquals(\"Wed 2547-06-09T12:20:30+02:00\", f.withChronology(BUDDHIST_PARIS).print(dt));\n+        assertEquals(\"Wed 2004-06-09T10:20:30Z\", f.withChronology(null).print(dt));\n+        \n+        dt = dt.withChronology(BUDDHIST_PARIS);\n+        assertEquals(\"Wed 2004-06-09T12:20:30+02:00\", f.withChronology(ISO_PARIS).print(dt));\n+        assertEquals(\"Wed 2547-06-09T12:20:30+02:00\", f.withChronology(BUDDHIST_PARIS).print(dt));\n+        assertEquals(\"Wed 2004-06-09T10:20:30Z\", f.withChronology(ISO_UTC).print(dt));\n+        assertEquals(\"Wed 2547-06-09T12:20:30+02:00\", f.withChronology(null).print(dt));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPrint_chrono_and_zone() {\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n+        assertEquals(\"Wed 2004-06-09T10:20:30Z\",\n+                f.withChronology(null).withZone(null).print(dt));\n+        assertEquals(\"Wed 2004-06-09T12:20:30+02:00\",\n+                f.withChronology(ISO_PARIS).withZone(null).print(dt));\n+        assertEquals(\"Wed 2004-06-09T12:20:30+02:00\",\n+                f.withChronology(ISO_PARIS).withZone(PARIS).print(dt));\n+        assertEquals(\"Wed 2004-06-09T06:20:30-04:00\",\n+                f.withChronology(ISO_PARIS).withZone(NEWYORK).print(dt));\n+        assertEquals(\"Wed 2004-06-09T06:20:30-04:00\",\n+                f.withChronology(null).withZone(NEWYORK).print(dt));\n+        \n+        dt = dt.withChronology(ISO_PARIS);\n+        assertEquals(\"Wed 2004-06-09T12:20:30+02:00\",\n+                f.withChronology(null).withZone(null).print(dt));\n+        assertEquals(\"Wed 2004-06-09T12:20:30+02:00\",\n+                f.withChronology(ISO_PARIS).withZone(null).print(dt));\n+        assertEquals(\"Wed 2004-06-09T12:20:30+02:00\",\n+                f.withChronology(ISO_PARIS).withZone(PARIS).print(dt));\n+        assertEquals(\"Wed 2004-06-09T06:20:30-04:00\",\n+                f.withChronology(ISO_PARIS).withZone(NEWYORK).print(dt));\n+        assertEquals(\"Wed 2004-06-09T06:20:30-04:00\",\n+                f.withChronology(null).withZone(NEWYORK).print(dt));\n+        \n+        dt = dt.withChronology(BUDDHIST_PARIS);\n+        assertEquals(\"Wed 2547-06-09T12:20:30+02:00\",\n+                f.withChronology(null).withZone(null).print(dt));\n+        assertEquals(\"Wed 2004-06-09T12:20:30+02:00\",\n+                f.withChronology(ISO_PARIS).withZone(null).print(dt));\n+        assertEquals(\"Wed 2004-06-09T12:20:30+02:00\",\n+                f.withChronology(ISO_PARIS).withZone(PARIS).print(dt));\n+        assertEquals(\"Wed 2004-06-09T06:20:30-04:00\",\n+                f.withChronology(ISO_PARIS).withZone(NEWYORK).print(dt));\n+        assertEquals(\"Wed 2547-06-09T06:20:30-04:00\",\n+                f.withChronology(null).withZone(NEWYORK).print(dt));\n+    }\n+\n+    public void testWithGetMethods() {\n+        DateTimeFormatter f2 = f.withLocale(Locale.FRENCH);\n+        assertEquals(Locale.FRENCH, f2.getLocale());\n+        assertSame(f2, f2.withLocale(Locale.FRENCH));\n+        \n+        f2 = f.withZone(PARIS);\n+        assertEquals(PARIS, f2.getZone());\n+        assertSame(f2, f2.withZone(PARIS));\n+        \n+        f2 = f.withChronology(BUDDHIST_PARIS);\n+        assertEquals(BUDDHIST_PARIS, f2.getChronolgy());\n+        assertSame(f2, f2.withChronology(BUDDHIST_PARIS));\n+    }        \n+\n+    public void testWithGetOffsetParsedMethods() {\n+        DateTimeFormatter f2 = f;\n+        assertEquals(false, f2.isOffsetParsed());\n+        assertEquals(null, f2.getZone());\n+        \n+        f2 = f.withOffsetParsed();\n+        assertEquals(true, f2.isOffsetParsed());\n+        assertEquals(null, f2.getZone());\n+        \n+        f2 = f2.withZone(PARIS);\n+        assertEquals(false, f2.isOffsetParsed());\n+        assertEquals(PARIS, f2.getZone());\n+        \n+        f2 = f2.withOffsetParsed();\n+        assertEquals(true, f2.isOffsetParsed());\n+        assertEquals(null, f2.getZone());\n+        \n+        f2 = f.withOffsetParsed();\n+        assertNotSame(f, f2);\n+        DateTimeFormatter f3 = f2.withOffsetParsed();\n+        assertSame(f2, f3);\n+    }\n+\n+    public void testPrinterParserMethods() {\n+        DateTimeFormatter f2 = new DateTimeFormatter(f.getPrinter(), f.getParser());\n+        assertEquals(f.getPrinter(), f2.getPrinter());\n+        assertEquals(f.getParser(), f2.getParser());\n+        assertEquals(true, f2.isPrinter());\n+        assertEquals(true, f2.isParser());\n+        assertNotNull(f2.print(0L));\n+        assertNotNull(f2.parseDateTime(\"Thu 1970-01-01T00:00:00Z\"));\n+        \n+        f2 = new DateTimeFormatter(f.getPrinter(), null);\n+        assertEquals(f.getPrinter(), f2.getPrinter());\n+        assertEquals(null, f2.getParser());\n+        assertEquals(true, f2.isPrinter());\n+        assertEquals(false, f2.isParser());\n+        assertNotNull(f2.print(0L));\n+        try {\n+            f2.parseDateTime(\"Thu 1970-01-01T00:00:00Z\");\n+        } catch (UnsupportedOperationException ex) {}\n+        \n+        f2 = new DateTimeFormatter(null, f.getParser());\n+        assertEquals(null, f2.getPrinter());\n+        assertEquals(f.getParser(), f2.getParser());\n+        assertEquals(false, f2.isPrinter());\n+        assertEquals(true, f2.isParser());\n+        try {\n+            f2.print(0L);\n+        } catch (UnsupportedOperationException ex) {}\n+        assertNotNull(f2.parseDateTime(\"Thu 1970-01-01T00:00:00Z\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testParseDateTime_simple() {\n+        DateTime expect = null;\n+        expect = new DateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n+        assertEquals(expect, g.parseDateTime(\"2004-06-09T10:20:30Z\"));\n+        \n+        try {\n+            g.parseDateTime(\"ABC\");\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testParseDateTime_zone() {\n+        DateTime expect = null;\n+        expect = new DateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n+        assertEquals(expect, g.withZone(LONDON).parseDateTime(\"2004-06-09T10:20:30Z\"));\n+        \n+        expect = new DateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n+        assertEquals(expect, g.withZone(null).parseDateTime(\"2004-06-09T10:20:30Z\"));\n+        \n+        expect = new DateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);\n+        assertEquals(expect, g.withZone(PARIS).parseDateTime(\"2004-06-09T10:20:30Z\"));\n+    }\n+\n+    public void testParseDateTime_zone2() {\n+        DateTime expect = null;\n+        expect = new DateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n+        assertEquals(expect, g.withZone(LONDON).parseDateTime(\"2004-06-09T06:20:30-04:00\"));\n+        \n+        expect = new DateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n+        assertEquals(expect, g.withZone(null).parseDateTime(\"2004-06-09T06:20:30-04:00\"));\n+        \n+        expect = new DateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);\n+        assertEquals(expect, g.withZone(PARIS).parseDateTime(\"2004-06-09T06:20:30-04:00\"));\n+    }\n+\n+    public void testParseDateTime_zone3() {\n+        DateTimeFormatter h = new DateTimeFormatterBuilder()\n+        .append(ISODateTimeFormat.date())\n+        .appendLiteral('T')\n+        .append(ISODateTimeFormat.timeElementParser())\n+        .toFormatter();\n+        \n+        DateTime expect = null;\n+        expect = new DateTime(2004, 6, 9, 10, 20, 30, 0, LONDON);\n+        assertEquals(expect, h.withZone(LONDON).parseDateTime(\"2004-06-09T10:20:30\"));\n+        \n+        expect = new DateTime(2004, 6, 9, 10, 20, 30, 0, LONDON);\n+        assertEquals(expect, h.withZone(null).parseDateTime(\"2004-06-09T10:20:30\"));\n+        \n+        expect = new DateTime(2004, 6, 9, 10, 20, 30, 0, PARIS);\n+        assertEquals(expect, h.withZone(PARIS).parseDateTime(\"2004-06-09T10:20:30\"));\n+    }\n+\n+    public void testParseDateTime_simple_precedence() {\n+        DateTime expect = null;\n+        // use correct day of week\n+        expect = new DateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n+        assertEquals(expect, f.parseDateTime(\"Wed 2004-06-09T10:20:30Z\"));\n+        \n+        // use wrong day of week\n+        expect = new DateTime(2004, 6, 7, 11, 20, 30, 0, LONDON);\n+        // DayOfWeek takes precedence, because week < month in length\n+        assertEquals(expect, f.parseDateTime(\"Mon 2004-06-09T10:20:30Z\"));\n+    }\n+\n+    public void testParseDateTime_offsetParsed() {\n+        DateTime expect = null;\n+        expect = new DateTime(2004, 6, 9, 10, 20, 30, 0, UTC);\n+        assertEquals(expect, g.withOffsetParsed().parseDateTime(\"2004-06-09T10:20:30Z\"));\n+        \n+        expect = new DateTime(2004, 6, 9, 6, 20, 30, 0, DateTimeZone.forOffsetHours(-4));\n+        assertEquals(expect, g.withOffsetParsed().parseDateTime(\"2004-06-09T06:20:30-04:00\"));\n+        \n+        expect = new DateTime(2004, 6, 9, 10, 20, 30, 0, UTC);\n+        assertEquals(expect, g.withZone(PARIS).withOffsetParsed().parseDateTime(\"2004-06-09T10:20:30Z\"));\n+        expect = new DateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);\n+        assertEquals(expect, g.withOffsetParsed().withZone(PARIS).parseDateTime(\"2004-06-09T10:20:30Z\"));\n+    }\n+\n+    public void testParseDateTime_chrono() {\n+        DateTime expect = null;\n+        expect = new DateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);\n+        assertEquals(expect, g.withChronology(ISO_PARIS).parseDateTime(\"2004-06-09T10:20:30Z\"));\n+        \n+        expect = new DateTime(2004, 6, 9, 11, 20, 30, 0,LONDON);\n+        assertEquals(expect, g.withChronology(null).parseDateTime(\"2004-06-09T10:20:30Z\"));\n+        \n+        expect = new DateTime(2547, 6, 9, 12, 20, 30, 0, BUDDHIST_PARIS);\n+        assertEquals(expect, g.withChronology(BUDDHIST_PARIS).parseDateTime(\"2547-06-09T10:20:30Z\"));\n+        \n+        expect = new DateTime(2004, 6, 9, 10, 29, 51, 0, BUDDHIST_PARIS); // zone is +00:09:21 in 1451\n+        assertEquals(expect, g.withChronology(BUDDHIST_PARIS).parseDateTime(\"2004-06-09T10:20:30Z\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testParseMutableDateTime_simple() {\n+        MutableDateTime expect = null;\n+        expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n+        assertEquals(expect, g.parseMutableDateTime(\"2004-06-09T10:20:30Z\"));\n+        \n+        try {\n+            g.parseMutableDateTime(\"ABC\");\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testParseMutableDateTime_zone() {\n+        MutableDateTime expect = null;\n+        expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n+        assertEquals(expect, g.withZone(LONDON).parseMutableDateTime(\"2004-06-09T10:20:30Z\"));\n+        \n+        expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n+        assertEquals(expect, g.withZone(null).parseMutableDateTime(\"2004-06-09T10:20:30Z\"));\n+        \n+        expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);\n+        assertEquals(expect, g.withZone(PARIS).parseMutableDateTime(\"2004-06-09T10:20:30Z\"));\n+    }\n+\n+    public void testParseMutableDateTime_zone2() {\n+        MutableDateTime expect = null;\n+        expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n+        assertEquals(expect, g.withZone(LONDON).parseMutableDateTime(\"2004-06-09T06:20:30-04:00\"));\n+        \n+        expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n+        assertEquals(expect, g.withZone(null).parseMutableDateTime(\"2004-06-09T06:20:30-04:00\"));\n+        \n+        expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);\n+        assertEquals(expect, g.withZone(PARIS).parseMutableDateTime(\"2004-06-09T06:20:30-04:00\"));\n+    }\n+\n+    public void testParseMutableDateTime_zone3() {\n+        DateTimeFormatter h = new DateTimeFormatterBuilder()\n+        .append(ISODateTimeFormat.date())\n+        .appendLiteral('T')\n+        .append(ISODateTimeFormat.timeElementParser())\n+        .toFormatter();\n+        \n+        MutableDateTime expect = null;\n+        expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, LONDON);\n+        assertEquals(expect, h.withZone(LONDON).parseMutableDateTime(\"2004-06-09T10:20:30\"));\n+        \n+        expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, LONDON);\n+        assertEquals(expect, h.withZone(null).parseMutableDateTime(\"2004-06-09T10:20:30\"));\n+        \n+        expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, PARIS);\n+        assertEquals(expect, h.withZone(PARIS).parseMutableDateTime(\"2004-06-09T10:20:30\"));\n+    }\n+\n+    public void testParseMutableDateTime_simple_precedence() {\n+        MutableDateTime expect = null;\n+        // use correct day of week\n+        expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n+        assertEquals(expect, f.parseDateTime(\"Wed 2004-06-09T10:20:30Z\"));\n+        \n+        // use wrong day of week\n+        expect = new MutableDateTime(2004, 6, 7, 11, 20, 30, 0, LONDON);\n+        // DayOfWeek takes precedence, because week < month in length\n+        assertEquals(expect, f.parseDateTime(\"Mon 2004-06-09T10:20:30Z\"));\n+    }\n+\n+    public void testParseMutableDateTime_offsetParsed() {\n+        MutableDateTime expect = null;\n+        expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, UTC);\n+        assertEquals(expect, g.withOffsetParsed().parseMutableDateTime(\"2004-06-09T10:20:30Z\"));\n+        \n+        expect = new MutableDateTime(2004, 6, 9, 6, 20, 30, 0, DateTimeZone.forOffsetHours(-4));\n+        assertEquals(expect, g.withOffsetParsed().parseMutableDateTime(\"2004-06-09T06:20:30-04:00\"));\n+        \n+        expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, UTC);\n+        assertEquals(expect, g.withZone(PARIS).withOffsetParsed().parseMutableDateTime(\"2004-06-09T10:20:30Z\"));\n+        expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);\n+        assertEquals(expect, g.withOffsetParsed().withZone(PARIS).parseMutableDateTime(\"2004-06-09T10:20:30Z\"));\n+    }\n+\n+    public void testParseMutableDateTime_chrono() {\n+        MutableDateTime expect = null;\n+        expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);\n+        assertEquals(expect, g.withChronology(ISO_PARIS).parseMutableDateTime(\"2004-06-09T10:20:30Z\"));\n+        \n+        expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0,LONDON);\n+        assertEquals(expect, g.withChronology(null).parseMutableDateTime(\"2004-06-09T10:20:30Z\"));\n+        \n+        expect = new MutableDateTime(2547, 6, 9, 12, 20, 30, 0, BUDDHIST_PARIS);\n+        assertEquals(expect, g.withChronology(BUDDHIST_PARIS).parseMutableDateTime(\"2547-06-09T10:20:30Z\"));\n+        \n+        expect = new MutableDateTime(2004, 6, 9, 10, 29, 51, 0, BUDDHIST_PARIS); // zone is +00:09:21 in 1451\n+        assertEquals(expect, g.withChronology(BUDDHIST_PARIS).parseMutableDateTime(\"2004-06-09T10:20:30Z\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testParseInto_simple() {\n+        MutableDateTime expect = null;\n+        expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n+        MutableDateTime result = new MutableDateTime(0L);\n+        assertEquals(20, g.parseInto(result, \"2004-06-09T10:20:30Z\", 0));\n+        assertEquals(expect, result);\n+        \n+        try {\n+            g.parseInto(null, \"2004-06-09T10:20:30Z\", 0);\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            g.parseInto(result, \"ABC\", 0);\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testParseInto_zone() {\n+        MutableDateTime expect = null;\n+        MutableDateTime result = null;\n+        expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n+        result = new MutableDateTime(0L);\n+        assertEquals(20, g.withZone(LONDON).parseInto(result, \"2004-06-09T10:20:30Z\", 0));\n+        assertEquals(expect, result);\n+        \n+        expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n+        result = new MutableDateTime(0L);\n+        assertEquals(20, g.withZone(null).parseInto(result, \"2004-06-09T10:20:30Z\", 0));\n+        assertEquals(expect, result);\n+        \n+        expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);\n+        result = new MutableDateTime(0L);\n+        assertEquals(20, g.withZone(PARIS).parseInto(result, \"2004-06-09T10:20:30Z\", 0));\n+        assertEquals(expect, result);\n+    }\n+\n+    public void testParseInto_zone2() {\n+        MutableDateTime expect = null;\n+        MutableDateTime result = null;\n+        expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n+        result = new MutableDateTime(0L);\n+        assertEquals(25, g.withZone(LONDON).parseInto(result, \"2004-06-09T06:20:30-04:00\", 0));\n+        assertEquals(expect, result);\n+        \n+        expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n+        assertEquals(25, g.withZone(null).parseInto(result, \"2004-06-09T06:20:30-04:00\", 0));\n+        assertEquals(expect, result);\n+        \n+        expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);\n+        assertEquals(25, g.withZone(PARIS).parseInto(result, \"2004-06-09T06:20:30-04:00\", 0));\n+        assertEquals(expect, result);\n+    }\n+\n+    public void testParseInto_zone3() {\n+        DateTimeFormatter h = new DateTimeFormatterBuilder()\n+        .append(ISODateTimeFormat.date())\n+        .appendLiteral('T')\n+        .append(ISODateTimeFormat.timeElementParser())\n+        .toFormatter();\n+        \n+        MutableDateTime expect = null;\n+        MutableDateTime result = null;\n+        expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, LONDON);\n+        result = new MutableDateTime(0L);\n+        assertEquals(19, h.withZone(LONDON).parseInto(result, \"2004-06-09T10:20:30\", 0));\n+        assertEquals(expect, result);\n+        \n+        expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, LONDON);\n+        result = new MutableDateTime(0L);\n+        assertEquals(19, h.withZone(null).parseInto(result, \"2004-06-09T10:20:30\", 0));\n+        assertEquals(expect, result);\n+        \n+        expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, PARIS);\n+        result = new MutableDateTime(0L);\n+        assertEquals(19, h.withZone(PARIS).parseInto(result, \"2004-06-09T10:20:30\", 0));\n+        assertEquals(expect, result);\n+    }\n+\n+    public void testParseInto_simple_precedence() {\n+        MutableDateTime expect = null;\n+        MutableDateTime result = null;\n+        expect = new MutableDateTime(2004, 6, 7, 11, 20, 30, 0, LONDON);\n+        result = new MutableDateTime(0L);\n+        // DayOfWeek takes precedence, because week < month in length\n+        assertEquals(24, f.parseInto(result, \"Mon 2004-06-09T10:20:30Z\", 0));\n+        assertEquals(expect, result);\n+    }\n+\n+    public void testParseInto_offsetParsed() {\n+        MutableDateTime expect = null;\n+        MutableDateTime result = null;\n+        expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, UTC);\n+        result = new MutableDateTime(0L);\n+        assertEquals(20, g.withOffsetParsed().parseInto(result, \"2004-06-09T10:20:30Z\", 0));\n+        assertEquals(expect, result);\n+        \n+        expect = new MutableDateTime(2004, 6, 9, 6, 20, 30, 0, DateTimeZone.forOffsetHours(-4));\n+        result = new MutableDateTime(0L);\n+        assertEquals(25, g.withOffsetParsed().parseInto(result, \"2004-06-09T06:20:30-04:00\", 0));\n+        assertEquals(expect, result);\n+        \n+        expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, UTC);\n+        result = new MutableDateTime(0L);\n+        assertEquals(20, g.withZone(PARIS).withOffsetParsed().parseInto(result, \"2004-06-09T10:20:30Z\", 0));\n+        assertEquals(expect, result);\n+        expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);\n+        result = new MutableDateTime(0L);\n+        assertEquals(20, g.withOffsetParsed().withZone(PARIS).parseInto(result, \"2004-06-09T10:20:30Z\", 0));\n+        assertEquals(expect, result);\n+    }\n+\n+    public void testParseInto_chrono() {\n+        MutableDateTime expect = null;\n+        MutableDateTime result = null;\n+        expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);\n+        result = new MutableDateTime(0L);\n+        assertEquals(20, g.withChronology(ISO_PARIS).parseInto(result, \"2004-06-09T10:20:30Z\", 0));\n+        assertEquals(expect, result);\n+        \n+        expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n+        result = new MutableDateTime(0L);\n+        assertEquals(20, g.withChronology(null).parseInto(result, \"2004-06-09T10:20:30Z\", 0));\n+        assertEquals(expect, result);\n+        \n+        expect = new MutableDateTime(2547, 6, 9, 12, 20, 30, 0, BUDDHIST_PARIS);\n+        result = new MutableDateTime(0L);\n+        assertEquals(20, g.withChronology(BUDDHIST_PARIS).parseInto(result, \"2547-06-09T10:20:30Z\", 0));\n+        assertEquals(expect, result);\n+        \n+        expect = new MutableDateTime(2004, 6, 9, 10, 29, 51, 0, BUDDHIST_PARIS);\n+        result = new MutableDateTime(0L);\n+        assertEquals(20, g.withChronology(BUDDHIST_PARIS).parseInto(result, \"2004-06-09T10:20:30Z\", 0));\n+        assertEquals(expect, result);\n+    }\n+\n+}\n--- a/JodaTime/src/test/org/joda/time/format/TestISODateTimeFormat.java\n+++ b/JodaTime/src/test/org/joda/time/format/TestISODateTimeFormat.java\n     //-----------------------------------------------------------------------\n     public void testFormat_date() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"2004-06-09\", ISODateTimeFormat.getInstance().date().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"2004-06-09\", ISODateTimeFormat.getInstance().date().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"2004-06-09\", ISODateTimeFormat.getInstance().date().print(dt));\n+        assertEquals(\"2004-06-09\", ISODateTimeFormat.date().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"2004-06-09\", ISODateTimeFormat.date().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"2004-06-09\", ISODateTimeFormat.date().print(dt));\n     }\n \n     public void testFormat_time() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"10:20:30.040Z\", ISODateTimeFormat.getInstance().time().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"11:20:30.040+01:00\", ISODateTimeFormat.getInstance().time().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"12:20:30.040+02:00\", ISODateTimeFormat.getInstance().time().print(dt));\n+        assertEquals(\"10:20:30.040Z\", ISODateTimeFormat.time().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"11:20:30.040+01:00\", ISODateTimeFormat.time().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"12:20:30.040+02:00\", ISODateTimeFormat.time().print(dt));\n     }\n \n     public void testFormat_timeNoMillis() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"10:20:30Z\", ISODateTimeFormat.getInstance().timeNoMillis().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"11:20:30+01:00\", ISODateTimeFormat.getInstance().timeNoMillis().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"12:20:30+02:00\", ISODateTimeFormat.getInstance().timeNoMillis().print(dt));\n+        assertEquals(\"10:20:30Z\", ISODateTimeFormat.timeNoMillis().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"11:20:30+01:00\", ISODateTimeFormat.timeNoMillis().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"12:20:30+02:00\", ISODateTimeFormat.timeNoMillis().print(dt));\n     }\n \n     public void testFormat_tTime() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"T10:20:30.040Z\", ISODateTimeFormat.getInstance().tTime().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"T11:20:30.040+01:00\", ISODateTimeFormat.getInstance().tTime().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"T12:20:30.040+02:00\", ISODateTimeFormat.getInstance().tTime().print(dt));\n+        assertEquals(\"T10:20:30.040Z\", ISODateTimeFormat.tTime().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"T11:20:30.040+01:00\", ISODateTimeFormat.tTime().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"T12:20:30.040+02:00\", ISODateTimeFormat.tTime().print(dt));\n     }\n \n     public void testFormat_tTimeNoMillis() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"T10:20:30Z\", ISODateTimeFormat.getInstance().tTimeNoMillis().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"T11:20:30+01:00\", ISODateTimeFormat.getInstance().tTimeNoMillis().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"T12:20:30+02:00\", ISODateTimeFormat.getInstance().tTimeNoMillis().print(dt));\n+        assertEquals(\"T10:20:30Z\", ISODateTimeFormat.tTimeNoMillis().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"T11:20:30+01:00\", ISODateTimeFormat.tTimeNoMillis().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"T12:20:30+02:00\", ISODateTimeFormat.tTimeNoMillis().print(dt));\n     }\n \n     public void testFormat_dateTime() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"2004-06-09T10:20:30.040Z\", ISODateTimeFormat.getInstance().dateTime().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"2004-06-09T11:20:30.040+01:00\", ISODateTimeFormat.getInstance().dateTime().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"2004-06-09T12:20:30.040+02:00\", ISODateTimeFormat.getInstance().dateTime().print(dt));\n+        assertEquals(\"2004-06-09T10:20:30.040Z\", ISODateTimeFormat.dateTime().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"2004-06-09T11:20:30.040+01:00\", ISODateTimeFormat.dateTime().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"2004-06-09T12:20:30.040+02:00\", ISODateTimeFormat.dateTime().print(dt));\n         \n //        dt = dt.withZone(LONDON);\n //        assertEquals(\"2004-06-09T11:20:30.040+01:00\", ISODateTimeFormat.getInstance(PARIS).dateTime().print(dt));\n //        \n //        dt = dt.withZone(LONDON);\n-//        assertEquals(\"2004-06-09T12:20:30.040+02:00\", ISODateTimeFormat.getInstance().dateTime().print(dt.getMillis(), PARIS));\n+//        assertEquals(\"2004-06-09T12:20:30.040+02:00\", ISODateTimeFormat.dateTime().print(dt.getMillis(), PARIS));\n //        \n //        dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, Chronology.getCoptic());\n-//        assertEquals(\"2288-02-19T10:20:30.040Z\", ISODateTimeFormat.getInstance().dateTime().print(dt));\n+//        assertEquals(\"2288-02-19T10:20:30.040Z\", ISODateTimeFormat.dateTime().print(dt));\n //        \n //        dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, Chronology.getCoptic());\n //        assertEquals(\"2004-06-09T10:20:30.040Z\", ISODateTimeFormat.getInstance(Chronology.getCoptic()).dateTime().print(dt));\n \n     public void testFormat_dateTimeNoMillis() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"2004-06-09T10:20:30Z\", ISODateTimeFormat.getInstance().dateTimeNoMillis().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"2004-06-09T11:20:30+01:00\", ISODateTimeFormat.getInstance().dateTimeNoMillis().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"2004-06-09T12:20:30+02:00\", ISODateTimeFormat.getInstance().dateTimeNoMillis().print(dt));\n+        assertEquals(\"2004-06-09T10:20:30Z\", ISODateTimeFormat.dateTimeNoMillis().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"2004-06-09T11:20:30+01:00\", ISODateTimeFormat.dateTimeNoMillis().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"2004-06-09T12:20:30+02:00\", ISODateTimeFormat.dateTimeNoMillis().print(dt));\n     }\n \n     public void testFormat_weekDate() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"2004-W24-3\", ISODateTimeFormat.getInstance().weekDate().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"2004-W24-3\", ISODateTimeFormat.getInstance().weekDate().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"2004-W24-3\", ISODateTimeFormat.getInstance().weekDate().print(dt));\n+        assertEquals(\"2004-W24-3\", ISODateTimeFormat.weekDate().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"2004-W24-3\", ISODateTimeFormat.weekDate().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"2004-W24-3\", ISODateTimeFormat.weekDate().print(dt));\n     }\n \n     public void testFormat_weekDateTime() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"2004-W24-3T10:20:30.040Z\", ISODateTimeFormat.getInstance().weekDateTime().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"2004-W24-3T11:20:30.040+01:00\", ISODateTimeFormat.getInstance().weekDateTime().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"2004-W24-3T12:20:30.040+02:00\", ISODateTimeFormat.getInstance().weekDateTime().print(dt));\n+        assertEquals(\"2004-W24-3T10:20:30.040Z\", ISODateTimeFormat.weekDateTime().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"2004-W24-3T11:20:30.040+01:00\", ISODateTimeFormat.weekDateTime().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"2004-W24-3T12:20:30.040+02:00\", ISODateTimeFormat.weekDateTime().print(dt));\n     }\n \n     public void testFormat_weekDateTimeNoMillis() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"2004-W24-3T10:20:30Z\", ISODateTimeFormat.getInstance().weekDateTimeNoMillis().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"2004-W24-3T11:20:30+01:00\", ISODateTimeFormat.getInstance().weekDateTimeNoMillis().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"2004-W24-3T12:20:30+02:00\", ISODateTimeFormat.getInstance().weekDateTimeNoMillis().print(dt));\n+        assertEquals(\"2004-W24-3T10:20:30Z\", ISODateTimeFormat.weekDateTimeNoMillis().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"2004-W24-3T11:20:30+01:00\", ISODateTimeFormat.weekDateTimeNoMillis().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"2004-W24-3T12:20:30+02:00\", ISODateTimeFormat.weekDateTimeNoMillis().print(dt));\n     }\n \n     //-----------------------------------------------------------------------\n     public void testFormat_basicDate() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"20040609\", ISODateTimeFormat.getInstance().basicDate().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"20040609\", ISODateTimeFormat.getInstance().basicDate().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"20040609\", ISODateTimeFormat.getInstance().basicDate().print(dt));\n+        assertEquals(\"20040609\", ISODateTimeFormat.basicDate().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"20040609\", ISODateTimeFormat.basicDate().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"20040609\", ISODateTimeFormat.basicDate().print(dt));\n     }\n \n     public void testFormat_basicTime() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"102030.040Z\", ISODateTimeFormat.getInstance().basicTime().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"112030.040+0100\", ISODateTimeFormat.getInstance().basicTime().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"122030.040+0200\", ISODateTimeFormat.getInstance().basicTime().print(dt));\n+        assertEquals(\"102030.040Z\", ISODateTimeFormat.basicTime().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"112030.040+0100\", ISODateTimeFormat.basicTime().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"122030.040+0200\", ISODateTimeFormat.basicTime().print(dt));\n     }\n \n     public void testFormat_basicTimeNoMillis() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"102030Z\", ISODateTimeFormat.getInstance().basicTimeNoMillis().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"112030+0100\", ISODateTimeFormat.getInstance().basicTimeNoMillis().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"122030+0200\", ISODateTimeFormat.getInstance().basicTimeNoMillis().print(dt));\n+        assertEquals(\"102030Z\", ISODateTimeFormat.basicTimeNoMillis().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"112030+0100\", ISODateTimeFormat.basicTimeNoMillis().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"122030+0200\", ISODateTimeFormat.basicTimeNoMillis().print(dt));\n     }\n \n     public void testFormat_basicTTime() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"T102030.040Z\", ISODateTimeFormat.getInstance().basicTTime().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"T112030.040+0100\", ISODateTimeFormat.getInstance().basicTTime().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"T122030.040+0200\", ISODateTimeFormat.getInstance().basicTTime().print(dt));\n+        assertEquals(\"T102030.040Z\", ISODateTimeFormat.basicTTime().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"T112030.040+0100\", ISODateTimeFormat.basicTTime().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"T122030.040+0200\", ISODateTimeFormat.basicTTime().print(dt));\n     }\n \n     public void testFormat_basicTTimeNoMillis() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"T102030Z\", ISODateTimeFormat.getInstance().basicTTimeNoMillis().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"T112030+0100\", ISODateTimeFormat.getInstance().basicTTimeNoMillis().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"T122030+0200\", ISODateTimeFormat.getInstance().basicTTimeNoMillis().print(dt));\n+        assertEquals(\"T102030Z\", ISODateTimeFormat.basicTTimeNoMillis().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"T112030+0100\", ISODateTimeFormat.basicTTimeNoMillis().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"T122030+0200\", ISODateTimeFormat.basicTTimeNoMillis().print(dt));\n     }\n \n     public void testFormat_basicDateTime() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"20040609T102030.040Z\", ISODateTimeFormat.getInstance().basicDateTime().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"20040609T112030.040+0100\", ISODateTimeFormat.getInstance().basicDateTime().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"20040609T122030.040+0200\", ISODateTimeFormat.getInstance().basicDateTime().print(dt));\n+        assertEquals(\"20040609T102030.040Z\", ISODateTimeFormat.basicDateTime().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"20040609T112030.040+0100\", ISODateTimeFormat.basicDateTime().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"20040609T122030.040+0200\", ISODateTimeFormat.basicDateTime().print(dt));\n     }\n \n     public void testFormat_basicDateTimeNoMillis() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"20040609T102030Z\", ISODateTimeFormat.getInstance().basicDateTimeNoMillis().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"20040609T112030+0100\", ISODateTimeFormat.getInstance().basicDateTimeNoMillis().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"20040609T122030+0200\", ISODateTimeFormat.getInstance().basicDateTimeNoMillis().print(dt));\n+        assertEquals(\"20040609T102030Z\", ISODateTimeFormat.basicDateTimeNoMillis().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"20040609T112030+0100\", ISODateTimeFormat.basicDateTimeNoMillis().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"20040609T122030+0200\", ISODateTimeFormat.basicDateTimeNoMillis().print(dt));\n     }\n \n     public void testFormat_basicWeekDate() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"2004W243\", ISODateTimeFormat.getInstance().basicWeekDate().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"2004W243\", ISODateTimeFormat.getInstance().basicWeekDate().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"2004W243\", ISODateTimeFormat.getInstance().basicWeekDate().print(dt));\n+        assertEquals(\"2004W243\", ISODateTimeFormat.basicWeekDate().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"2004W243\", ISODateTimeFormat.basicWeekDate().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"2004W243\", ISODateTimeFormat.basicWeekDate().print(dt));\n     }\n \n     public void testFormat_basicWeekDateTime() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"2004W243T102030.040Z\", ISODateTimeFormat.getInstance().basicWeekDateTime().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"2004W243T112030.040+0100\", ISODateTimeFormat.getInstance().basicWeekDateTime().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"2004W243T122030.040+0200\", ISODateTimeFormat.getInstance().basicWeekDateTime().print(dt));\n+        assertEquals(\"2004W243T102030.040Z\", ISODateTimeFormat.basicWeekDateTime().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"2004W243T112030.040+0100\", ISODateTimeFormat.basicWeekDateTime().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"2004W243T122030.040+0200\", ISODateTimeFormat.basicWeekDateTime().print(dt));\n     }\n \n     public void testFormat_basicWeekDateTimeNoMillis() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"2004W243T102030Z\", ISODateTimeFormat.getInstance().basicWeekDateTimeNoMillis().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"2004W243T112030+0100\", ISODateTimeFormat.getInstance().basicWeekDateTimeNoMillis().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"2004W243T122030+0200\", ISODateTimeFormat.getInstance().basicWeekDateTimeNoMillis().print(dt));\n+        assertEquals(\"2004W243T102030Z\", ISODateTimeFormat.basicWeekDateTimeNoMillis().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"2004W243T112030+0100\", ISODateTimeFormat.basicWeekDateTimeNoMillis().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"2004W243T122030+0200\", ISODateTimeFormat.basicWeekDateTimeNoMillis().print(dt));\n     }\n \n     //-----------------------------------------------------------------------\n     public void testFormat_year() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"2004\", ISODateTimeFormat.getInstance().year().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"2004\", ISODateTimeFormat.getInstance().year().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"2004\", ISODateTimeFormat.getInstance().year().print(dt));\n+        assertEquals(\"2004\", ISODateTimeFormat.year().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"2004\", ISODateTimeFormat.year().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"2004\", ISODateTimeFormat.year().print(dt));\n     }\n \n     public void testFormat_yearMonth() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"2004-06\", ISODateTimeFormat.getInstance().yearMonth().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"2004-06\", ISODateTimeFormat.getInstance().yearMonth().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"2004-06\", ISODateTimeFormat.getInstance().yearMonth().print(dt));\n+        assertEquals(\"2004-06\", ISODateTimeFormat.yearMonth().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"2004-06\", ISODateTimeFormat.yearMonth().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"2004-06\", ISODateTimeFormat.yearMonth().print(dt));\n     }\n \n     public void testFormat_yearMonthDay() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"2004-06-09\", ISODateTimeFormat.getInstance().yearMonthDay().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"2004-06-09\", ISODateTimeFormat.getInstance().yearMonthDay().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"2004-06-09\", ISODateTimeFormat.getInstance().yearMonthDay().print(dt));\n+        assertEquals(\"2004-06-09\", ISODateTimeFormat.yearMonthDay().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"2004-06-09\", ISODateTimeFormat.yearMonthDay().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"2004-06-09\", ISODateTimeFormat.yearMonthDay().print(dt));\n     }\n \n     public void testFormat_weekyear() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"2004\", ISODateTimeFormat.getInstance().weekyear().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"2004\", ISODateTimeFormat.getInstance().weekyear().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"2004\", ISODateTimeFormat.getInstance().weekyear().print(dt));\n+        assertEquals(\"2004\", ISODateTimeFormat.weekyear().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"2004\", ISODateTimeFormat.weekyear().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"2004\", ISODateTimeFormat.weekyear().print(dt));\n     }\n \n     public void testFormat_weekyearWeek() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"2004-W24\", ISODateTimeFormat.getInstance().weekyearWeek().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"2004-W24\", ISODateTimeFormat.getInstance().weekyearWeek().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"2004-W24\", ISODateTimeFormat.getInstance().weekyearWeek().print(dt));\n+        assertEquals(\"2004-W24\", ISODateTimeFormat.weekyearWeek().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"2004-W24\", ISODateTimeFormat.weekyearWeek().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"2004-W24\", ISODateTimeFormat.weekyearWeek().print(dt));\n     }\n \n     public void testFormat_weekyearWeekDay() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"2004-W24-3\", ISODateTimeFormat.getInstance().weekyearWeekDay().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"2004-W24-3\", ISODateTimeFormat.getInstance().weekyearWeekDay().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"2004-W24-3\", ISODateTimeFormat.getInstance().weekyearWeekDay().print(dt));\n+        assertEquals(\"2004-W24-3\", ISODateTimeFormat.weekyearWeekDay().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"2004-W24-3\", ISODateTimeFormat.weekyearWeekDay().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"2004-W24-3\", ISODateTimeFormat.weekyearWeekDay().print(dt));\n     }\n \n     //-----------------------------------------------------------------------\n     public void testFormat_hour() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"10\", ISODateTimeFormat.getInstance().hour().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"11\", ISODateTimeFormat.getInstance().hour().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"12\", ISODateTimeFormat.getInstance().hour().print(dt));\n+        assertEquals(\"10\", ISODateTimeFormat.hour().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"11\", ISODateTimeFormat.hour().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"12\", ISODateTimeFormat.hour().print(dt));\n     }\n \n     public void testFormat_hourMinute() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"10:20\", ISODateTimeFormat.getInstance().hourMinute().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"11:20\", ISODateTimeFormat.getInstance().hourMinute().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"12:20\", ISODateTimeFormat.getInstance().hourMinute().print(dt));\n+        assertEquals(\"10:20\", ISODateTimeFormat.hourMinute().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"11:20\", ISODateTimeFormat.hourMinute().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"12:20\", ISODateTimeFormat.hourMinute().print(dt));\n     }\n \n     public void testFormat_hourMinuteSecond() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"10:20:30\", ISODateTimeFormat.getInstance().hourMinuteSecond().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"11:20:30\", ISODateTimeFormat.getInstance().hourMinuteSecond().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"12:20:30\", ISODateTimeFormat.getInstance().hourMinuteSecond().print(dt));\n+        assertEquals(\"10:20:30\", ISODateTimeFormat.hourMinuteSecond().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"11:20:30\", ISODateTimeFormat.hourMinuteSecond().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"12:20:30\", ISODateTimeFormat.hourMinuteSecond().print(dt));\n     }\n \n     public void testFormat_hourMinuteSecondMillis() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"10:20:30.040\", ISODateTimeFormat.getInstance().hourMinuteSecondMillis().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"11:20:30.040\", ISODateTimeFormat.getInstance().hourMinuteSecondMillis().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"12:20:30.040\", ISODateTimeFormat.getInstance().hourMinuteSecondMillis().print(dt));\n+        assertEquals(\"10:20:30.040\", ISODateTimeFormat.hourMinuteSecondMillis().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"11:20:30.040\", ISODateTimeFormat.hourMinuteSecondMillis().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"12:20:30.040\", ISODateTimeFormat.hourMinuteSecondMillis().print(dt));\n     }\n \n     public void testFormat_hourMinuteSecondFraction() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"10:20:30.040\", ISODateTimeFormat.getInstance().hourMinuteSecondFraction().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"11:20:30.040\", ISODateTimeFormat.getInstance().hourMinuteSecondFraction().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"12:20:30.040\", ISODateTimeFormat.getInstance().hourMinuteSecondFraction().print(dt));\n+        assertEquals(\"10:20:30.040\", ISODateTimeFormat.hourMinuteSecondFraction().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"11:20:30.040\", ISODateTimeFormat.hourMinuteSecondFraction().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"12:20:30.040\", ISODateTimeFormat.hourMinuteSecondFraction().print(dt));\n     }\n \n     //-----------------------------------------------------------------------\n     public void testFormat_dateHour() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"2004-06-09T10\", ISODateTimeFormat.getInstance().dateHour().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"2004-06-09T11\", ISODateTimeFormat.getInstance().dateHour().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"2004-06-09T12\", ISODateTimeFormat.getInstance().dateHour().print(dt));\n+        assertEquals(\"2004-06-09T10\", ISODateTimeFormat.dateHour().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"2004-06-09T11\", ISODateTimeFormat.dateHour().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"2004-06-09T12\", ISODateTimeFormat.dateHour().print(dt));\n     }\n \n     public void testFormat_dateHourMinute() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"2004-06-09T10:20\", ISODateTimeFormat.getInstance().dateHourMinute().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"2004-06-09T11:20\", ISODateTimeFormat.getInstance().dateHourMinute().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"2004-06-09T12:20\", ISODateTimeFormat.getInstance().dateHourMinute().print(dt));\n+        assertEquals(\"2004-06-09T10:20\", ISODateTimeFormat.dateHourMinute().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"2004-06-09T11:20\", ISODateTimeFormat.dateHourMinute().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"2004-06-09T12:20\", ISODateTimeFormat.dateHourMinute().print(dt));\n     }\n \n     public void testFormat_dateHourMinuteSecond() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"2004-06-09T10:20:30\", ISODateTimeFormat.getInstance().dateHourMinuteSecond().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"2004-06-09T11:20:30\", ISODateTimeFormat.getInstance().dateHourMinuteSecond().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"2004-06-09T12:20:30\", ISODateTimeFormat.getInstance().dateHourMinuteSecond().print(dt));\n+        assertEquals(\"2004-06-09T10:20:30\", ISODateTimeFormat.dateHourMinuteSecond().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"2004-06-09T11:20:30\", ISODateTimeFormat.dateHourMinuteSecond().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"2004-06-09T12:20:30\", ISODateTimeFormat.dateHourMinuteSecond().print(dt));\n     }\n \n     public void testFormat_dateHourMinuteSecondMillis() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"2004-06-09T10:20:30.040\", ISODateTimeFormat.getInstance().dateHourMinuteSecondMillis().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"2004-06-09T11:20:30.040\", ISODateTimeFormat.getInstance().dateHourMinuteSecondMillis().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"2004-06-09T12:20:30.040\", ISODateTimeFormat.getInstance().dateHourMinuteSecondMillis().print(dt));\n+        assertEquals(\"2004-06-09T10:20:30.040\", ISODateTimeFormat.dateHourMinuteSecondMillis().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"2004-06-09T11:20:30.040\", ISODateTimeFormat.dateHourMinuteSecondMillis().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"2004-06-09T12:20:30.040\", ISODateTimeFormat.dateHourMinuteSecondMillis().print(dt));\n     }\n \n     public void testFormat_dateHourMinuteSecondFraction() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n-        assertEquals(\"2004-06-09T10:20:30.040\", ISODateTimeFormat.getInstance().dateHourMinuteSecondFraction().print(dt));\n-        \n-        dt = dt.withZone(LONDON);\n-        assertEquals(\"2004-06-09T11:20:30.040\", ISODateTimeFormat.getInstance().dateHourMinuteSecondFraction().print(dt));\n-        \n-        dt = dt.withZone(PARIS);\n-        assertEquals(\"2004-06-09T12:20:30.040\", ISODateTimeFormat.getInstance().dateHourMinuteSecondFraction().print(dt));\n+        assertEquals(\"2004-06-09T10:20:30.040\", ISODateTimeFormat.dateHourMinuteSecondFraction().print(dt));\n+        \n+        dt = dt.withZone(LONDON);\n+        assertEquals(\"2004-06-09T11:20:30.040\", ISODateTimeFormat.dateHourMinuteSecondFraction().print(dt));\n+        \n+        dt = dt.withZone(PARIS);\n+        assertEquals(\"2004-06-09T12:20:30.040\", ISODateTimeFormat.dateHourMinuteSecondFraction().print(dt));\n     }\n \n }\n--- a/JodaTime/src/test/org/joda/time/format/TestTextFields.java\n+++ b/JodaTime/src/test/org/joda/time/format/TestTextFields.java\n \n     //-----------------------------------------------------------------------\n     public void testMonthNames_monthStart() {\n-        DateTimePrinter printer = DateTimeFormat.getInstance().forPattern(\"MMMM\");\n+        DateTimeFormatter printer = DateTimeFormat.forPattern(\"MMMM\");\n         for (int i=0; i<ZONES.length; i++) {\n             for (int month=1; month<=12; month++) {\n                 DateTime dt = new DateTime(2004, month, 1, 1, 20, 30, 40, ZONES[i]);\n     }\n \n     public void testMonthNames_monthMiddle() {\n-        DateTimePrinter printer = DateTimeFormat.getInstance().forPattern(\"MMMM\");\n+        DateTimeFormatter printer = DateTimeFormat.forPattern(\"MMMM\");\n         for (int i=0; i<ZONES.length; i++) {\n             for (int month=1; month<=12; month++) {\n                 DateTime dt = new DateTime(2004, month, 15, 12, 20, 30, 40, ZONES[i]);\n     }\n \n     public void testMonthNames_monthEnd() {\n-        DateTimePrinter printer = DateTimeFormat.getInstance().forPattern(\"MMMM\");\n+        DateTimeFormatter printer = DateTimeFormat.forPattern(\"MMMM\");\n         for (int i=0; i<ZONES.length; i++) {\n             Chronology chrono = Chronology.getISO(ZONES[i]);\n             for (int month=1; month<=12; month++) {\n     }\n \n     public void testWeekdayNames() {\n-        DateTimePrinter printer = DateTimeFormat.getInstance().forPattern(\"EEEE\");\n+        DateTimeFormatter printer = DateTimeFormat.forPattern(\"EEEE\");\n         for (int i=0; i<ZONES.length; i++) {\n             MutableDateTime mdt = new MutableDateTime(2004, 1, 1, 1, 20, 30, 40, ZONES[i]);\n             for (int day=1; day<=366; day++) {\n     }\n \n     public void testHalfdayNames() {\n-        DateTimePrinter printer = DateTimeFormat.getInstance().forPattern(\"a\");\n+        DateTimeFormatter printer = DateTimeFormat.forPattern(\"a\");\n         for (int i=0; i<ZONES.length; i++) {\n             Chronology chrono = Chronology.getISO(ZONES[i]);\n             MutableDateTime mdt = new MutableDateTime(2004, 5, 30, 0, 20, 30, 40, chrono);", "timestamp": 1108262394, "metainfo": ""}