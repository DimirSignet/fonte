{"sha": "9316fce1b432caa8b56ff6056d916f0a0aaefc1a", "log": "Use DateTimeFieldType for custom fields   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationFieldType;\n import org.joda.time.MutableDateTime;\n import org.joda.time.ReadWritableInstant;\n import org.joda.time.ReadableInstant;\n             case 'y': // year (number)\n             case 'Y': // year of era (number)\n                 if (tokenLen == 2) {\n-                    // Use a new RemainderDateTimeField to ensure that the year\n-                    // of century is zero-based.\n-                    DateTimeField field;\n-                    Chronology chronoUTC = builder.getChronology().withUTC();\n+                    // Use a new remainder type to ensure that the year of\n+                    // century is zero-based.\n+                    DateTimeFieldType type;\n                     switch (c) {\n                     case 'x':\n-                        field = new RemainderDateTimeField\n-                            (chronoUTC.weekyear(), DateTimeFieldType.weekyearOfCentury(), 100);\n+                        type = new RemainderType(DateTimeFieldType.weekyear(),\n+                                                 DateTimeFieldType.weekyearOfCentury(), 100);\n                         break;\n                     case 'y': default:\n-                        field = new RemainderDateTimeField\n-                            (chronoUTC.year(), DateTimeFieldType.yearOfCentury(), 100);\n+                        type = new RemainderType(DateTimeFieldType.year(),\n+                                                 DateTimeFieldType.yearOfCentury(), 100);\n                         break;\n                     case 'Y':\n-                        field = new RemainderDateTimeField\n-                            (chronoUTC.yearOfEra(), DateTimeFieldType.yearOfCentury(), 100);\n+                        type = new RemainderType(DateTimeFieldType.yearOfEra(),\n+                                                 DateTimeFieldType.yearOfCentury(), 100);\n                         break;\n                     }\n-                    builder.appendDecimal(field, 2, 2);\n+                    builder.appendDecimal(type, 2, 2);\n                 } else {\n                     // Try to support long year values.\n                     int maxDigits = 9;\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Special field type which derives a new field as a remainder.\n+     */\n+    static class RemainderType extends DateTimeFieldType {\n+        private final DateTimeFieldType iWrappedType;\n+        private final DateTimeFieldType iType;\n+        private final int iDivisor;\n+\n+        private transient RemainderDateTimeField iRecent;\n+\n+        RemainderType(DateTimeFieldType wrappedType, DateTimeFieldType type, int divisor) {\n+            super(type.getName());\n+            iWrappedType = wrappedType;\n+            iType = type;\n+            iDivisor = divisor;\n+        }\n+\n+        public DurationFieldType getDurationType() {\n+            return iType.getDurationType();\n+        }\n+\n+        public DurationFieldType getRangeDurationType() {\n+            return iType.getRangeDurationType();\n+        }\n+\n+        public DateTimeField getField(Chronology chrono) {\n+            DateTimeField wrappedField = iWrappedType.getField(chrono);\n+            RemainderDateTimeField field = iRecent;\n+            if (field.getWrappedField() == wrappedField) {\n+                return field;\n+            }\n+            field = new RemainderDateTimeField(wrappedField, iType, iDivisor);\n+            iRecent = field;\n+            return field;\n+        }\n+    }\n+\n+    /**\n      * A fake formatter that can only print.\n      */\n     static class FPrinter implements DateTimeFormatter {\n         private final DateTimePrinter mPrinter;\n \n-        FPrinter(final DateTimePrinter printer) {\n+        FPrinter(DateTimePrinter printer) {\n             super();\n             mPrinter = printer;\n         }\n             return mPrinter.estimatePrintedLength();\n         }\n \n-        public void printTo(final StringBuffer buf, final ReadableInstant instant) {\n+        public void printTo(StringBuffer buf, ReadableInstant instant) {\n             mPrinter.printTo(buf, instant);\n         }\n \n-        public void printTo(final Writer out, final ReadableInstant instant) throws IOException {\n+        public void printTo(Writer out, ReadableInstant instant) throws IOException {\n             mPrinter.printTo(out, instant);\n         }\n \n-        public void printTo(final StringBuffer buf, final long instant) {\n+        public void printTo(StringBuffer buf, long instant) {\n             mPrinter.printTo(buf, instant);\n         }\n \n-        public void printTo(final Writer out, final long instant) throws IOException {\n+        public void printTo(Writer out, long instant) throws IOException {\n             mPrinter.printTo(out, instant);\n         }\n \n-        public void printTo(final StringBuffer buf, final long instant, final DateTimeZone zone) {\n+        public void printTo(StringBuffer buf, long instant, DateTimeZone zone) {\n             mPrinter.printTo(buf, instant, zone);\n         }\n \n-        public void printTo(final Writer out, final long instant, final DateTimeZone zone)\n+        public void printTo(Writer out, long instant, DateTimeZone zone)\n             throws IOException {\n             mPrinter.printTo(out, instant, zone);\n         }\n \n-        public void printTo(final StringBuffer buf, final long instant,\n-                            final DateTimeZone zone, final long instantLocal) {\n+        public void printTo(StringBuffer buf, long instant,\n+                            DateTimeZone zone, long instantLocal) {\n             mPrinter.printTo(buf, instant, zone, instantLocal);\n         }\n \n-        public void printTo(final Writer out, final long instant,\n-                            final DateTimeZone zone, final long instantLocal)\n+        public void printTo(Writer out, long instant,\n+                            DateTimeZone zone, long instantLocal)\n             throws IOException {\n             mPrinter.printTo(out, instant, zone, instantLocal);\n         }\n             mPrinter.printTo(out, instant);\n         }\n \n-        public String print(final ReadableInstant instant) {\n+        public String print(ReadableInstant instant) {\n             return mPrinter.print(instant);\n         }\n \n-        public String print(final long instant) {\n+        public String print(long instant) {\n             return mPrinter.print(instant);\n         }\n \n-        public String print(final long instant, final DateTimeZone zone) {\n+        public String print(long instant, DateTimeZone zone) {\n             return mPrinter.print(instant, zone);\n         }\n \n-        public String print(final long instant, final DateTimeZone zone, final long instantLocal) {\n+        public String print(long instant, DateTimeZone zone, long instantLocal) {\n             return mPrinter.print(instant, zone, instantLocal);\n         }\n \n             return 0;\n         }\n \n-        public int parseInto(final DateTimeParserBucket bucket, final String text, final int position) {\n-            throw unsupported();\n-        }\n-\n-        public int parseInto(final ReadWritableInstant instant, final String text, final int position) {\n-            throw unsupported();\n-        }\n-\n-        public long parseMillis(final String text) {\n-            throw unsupported();\n-        }\n-\n-        public long parseMillis(final String text, final long instantLocal) {\n-            throw unsupported();\n-        }\n-\n-        public DateTime parseDateTime(final String text) {\n-            throw unsupported();\n-        }\n-\n-        public DateTime parseDateTime(final String text, final ReadableInstant instant) {\n-            throw unsupported();\n-        }\n-\n-        public MutableDateTime parseMutableDateTime(final String text) {\n-            throw unsupported();\n-        }\n-\n-        public MutableDateTime parseMutableDateTime(final String text,\n-                                                    final ReadableInstant instant) {\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            throw unsupported();\n+        }\n+\n+        public int parseInto(ReadWritableInstant instant, String text, int position) {\n+            throw unsupported();\n+        }\n+\n+        public long parseMillis(String text) {\n+            throw unsupported();\n+        }\n+\n+        public long parseMillis(String text, long instantLocal) {\n+            throw unsupported();\n+        }\n+\n+        public DateTime parseDateTime(String text) {\n+            throw unsupported();\n+        }\n+\n+        public DateTime parseDateTime(String text, ReadableInstant instant) {\n+            throw unsupported();\n+        }\n+\n+        public MutableDateTime parseMutableDateTime(String text) {\n+            throw unsupported();\n+        }\n+\n+        public MutableDateTime parseMutableDateTime(String text,\n+                                                    ReadableInstant instant) {\n             throw unsupported();\n         }\n \n     static class FParser implements DateTimeFormatter {\n         private final DateTimeParser mParser;\n \n-        FParser(final DateTimeParser parser) {\n+        FParser(DateTimeParser parser) {\n             super();\n             mParser = parser;\n         }\n             return 0;\n         }\n \n-        public void printTo(final StringBuffer buf, final ReadableInstant instant) {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(final Writer out, final ReadableInstant instant) throws IOException {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(final StringBuffer buf, final long instant) {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(final Writer out, final long instant) throws IOException {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(final StringBuffer buf, final long instant, final DateTimeZone zone) {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(final Writer out, final long instant, final DateTimeZone zone) {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(final StringBuffer buf, final long instant,\n-                            final DateTimeZone zone, final long instantLocal) {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(final Writer out, final long instant,\n-                            final DateTimeZone zone, final long instantLocal) {\n+        public void printTo(StringBuffer buf, ReadableInstant instant) {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(Writer out, ReadableInstant instant) throws IOException {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(StringBuffer buf, long instant) {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(Writer out, long instant) throws IOException {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(StringBuffer buf, long instant, DateTimeZone zone) {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(Writer out, long instant, DateTimeZone zone) {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(StringBuffer buf, long instant,\n+                            DateTimeZone zone, long instantLocal) {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(Writer out, long instant,\n+                            DateTimeZone zone, long instantLocal) {\n             throw unsupported();\n         }\n \n             throw unsupported();\n         }\n \n-        public String print(final ReadableInstant instant) {\n-            throw unsupported();\n-        }\n-\n-        public String print(final long instant) {\n-            throw unsupported();\n-        }\n-\n-        public String print(final long instant, final DateTimeZone zone) {\n-            throw unsupported();\n-        }\n-\n-        public String print(final long instant, final DateTimeZone zone, final long instantLocal) {\n+        public String print(ReadableInstant instant) {\n+            throw unsupported();\n+        }\n+\n+        public String print(long instant) {\n+            throw unsupported();\n+        }\n+\n+        public String print(long instant, DateTimeZone zone) {\n+            throw unsupported();\n+        }\n+\n+        public String print(long instant, DateTimeZone zone, long instantLocal) {\n             throw unsupported();\n         }\n \n             return mParser.estimateParsedLength();\n         }\n \n-        public int parseInto(final DateTimeParserBucket bucket, final String text, final int position) {\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             return mParser.parseInto(bucket, text, position);\n         }\n \n-        public int parseInto(final ReadWritableInstant instant, final String text, final int position) {\n+        public int parseInto(ReadWritableInstant instant, String text, int position) {\n             return mParser.parseInto(instant, text, position);\n         }\n \n-        public long parseMillis(final String text) {\n+        public long parseMillis(String text) {\n             return mParser.parseMillis(text);\n         }\n \n-        public long parseMillis(final String text, final long instantLocal) {\n+        public long parseMillis(String text, long instantLocal) {\n             return mParser.parseMillis(text, instantLocal);\n         }\n \n-        public DateTime parseDateTime(final String text) {\n+        public DateTime parseDateTime(String text) {\n             return mParser.parseDateTime(text);\n         }\n \n-        public DateTime parseDateTime(final String text, final ReadableInstant instant) {\n+        public DateTime parseDateTime(String text, ReadableInstant instant) {\n             return mParser.parseDateTime(text, instant);\n         }\n \n-        public MutableDateTime parseMutableDateTime(final String text) {\n+        public MutableDateTime parseMutableDateTime(String text) {\n             return mParser.parseMutableDateTime(text);\n         }\n \n-        public MutableDateTime parseMutableDateTime(final String text,\n-                                                    final ReadableInstant instant) {\n+        public MutableDateTime parseMutableDateTime(String text,\n+                                                    ReadableInstant instant) {\n             return mParser.parseMutableDateTime(text, instant);\n         }\n \n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n import java.io.IOException;\n import java.io.Writer;\n import java.util.ArrayList;\n+import java.util.List;\n import java.util.Locale;\n \n import org.joda.time.Chronology;\n      * Creates a DateTimeFormatterBuilder with {@link ISOChronology}, in the\n      * given time zone, with the default locale.\n      */\n-    public DateTimeFormatterBuilder(final DateTimeZone zone) {\n+    public DateTimeFormatterBuilder(DateTimeZone zone) {\n         this(ISOChronology.getInstance(zone));\n     }\n \n      * Creates a DateTimeFormatterBuilder with {@link ISOChronology}, in the\n      * given time zone, with any locale.\n      */\n-    public DateTimeFormatterBuilder(final DateTimeZone zone, final Locale locale) {\n+    public DateTimeFormatterBuilder(DateTimeZone zone, Locale locale) {\n         this(ISOChronology.getInstance(zone), locale);\n     }\n \n      *\n      * @param chrono Chronology to use\n      */\n-    public DateTimeFormatterBuilder(final Chronology chrono) {\n+    public DateTimeFormatterBuilder(Chronology chrono) {\n         this(chrono, Locale.getDefault());\n     }\n \n     }\n \n     /**\n-     * Returns the locale being used by the formatter builder.\n+     * Returns the locale being used by the formatter builder, never null.\n      */\n     public Locale getLocale() {\n         return iLocale;\n      * @return this DateTimeFormatterBuilder\n      * @throws IllegalArgumentException if formatter is null\n      */\n-    public DateTimeFormatterBuilder append(final DateTimeFormatter formatter)\n+    public DateTimeFormatterBuilder append(DateTimeFormatter formatter)\n         throws IllegalArgumentException\n     {\n         if (formatter == null) {\n      * @return this DateTimeFormatterBuilder\n      * @throws IllegalArgumentException if printer is null\n      */\n-    public DateTimeFormatterBuilder append(final DateTimePrinter printer)\n+    public DateTimeFormatterBuilder append(DateTimePrinter printer)\n         throws IllegalArgumentException\n     {\n         if (printer == null) {\n      * @return this DateTimeFormatterBuilder\n      * @throws IllegalArgumentException if parser is null\n      */\n-    public DateTimeFormatterBuilder append(final DateTimeParser parser) {\n+    public DateTimeFormatterBuilder append(DateTimeParser parser) {\n         if (parser == null) {\n             throw new IllegalArgumentException(\"No parser supplied\");\n         }\n      * @return this DateTimeFormatterBuilder\n      * @throws IllegalArgumentException if printer or parser is null\n      */\n-    public DateTimeFormatterBuilder append(final DateTimePrinter printer,\n-                                           final DateTimeParser parser)\n+    public DateTimeFormatterBuilder append(DateTimePrinter printer,\n+                                           DateTimeParser parser)\n         throws IllegalArgumentException\n     {\n         if (printer == null) {\n      * @return this DateTimeFormatterBuilder\n      * @throws IllegalArgumentException if any parser element but the last is null\n      */\n-    public DateTimeFormatterBuilder append(final DateTimePrinter printer,\n-                                           final DateTimeParser[] parsers)\n+    public DateTimeFormatterBuilder append(DateTimePrinter printer,\n+                                           DateTimeParser[] parsers)\n         throws IllegalArgumentException\n     {\n         if (parsers == null) {\n      * @return this DateTimeFormatterBuilder\n      * @throws IllegalArgumentException if parser is null\n      */\n-    public DateTimeFormatterBuilder appendOptional(final DateTimeParser parser) {\n+    public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {\n         if (parser == null) {\n             throw new IllegalArgumentException(\"No parser supplied\");\n         }\n         return append0(null, new MatchingParser(iChrono, new DateTimeParser[] {parser, null}));\n     }\n \n-    private DateTimeFormatterBuilder append0(final Object element) {\n+    private DateTimeFormatterBuilder append0(Object element) {\n         iFormatter = null;\n         // Add the element as both a printer and parser.\n         iElementPairs.add(element);\n     }\n \n     private DateTimeFormatterBuilder append0(\n-            final DateTimePrinter printer, final DateTimeParser parser) {\n+            DateTimePrinter printer, DateTimeParser parser) {\n         iFormatter = null;\n         iElementPairs.add(printer);\n         iElementPairs.add(parser);\n      *\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendLiteral(final char c) {\n+    public DateTimeFormatterBuilder appendLiteral(char c) {\n         return append0(new CharacterLiteral(iChrono, c));\n     }\n \n      * @return this DateTimeFormatterBuilder\n      * @throws IllegalArgumentException if text is null\n      */\n-    public DateTimeFormatterBuilder appendLiteral(final String text) {\n+    public DateTimeFormatterBuilder appendLiteral(String text) {\n         if (text == null) {\n             throw new IllegalArgumentException(\"Literal must not be null\");\n         }\n      * Instructs the printer to emit a field value as a decimal number, and the\n      * parser to expect an unsigned decimal number.\n      *\n-     * @param field field should operate in UTC or be time zone agnostic\n+     * @param fieldType type of field to append\n      * @param minDigits minumum number of digits to <i>print</i>\n      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n      * @return this DateTimeFormatterBuilder\n-     * @throws IllegalArgumentException if field is null\n+     * @throws IllegalArgumentException if field type is null\n      */\n     public DateTimeFormatterBuilder appendDecimal(\n-            DateTimeField field, int minDigits, int maxDigits) {\n-        if (field == null) {\n-            throw new IllegalArgumentException(\"Field must not be null\");\n+            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field type must not be null\");\n         }\n         if (maxDigits < minDigits) {\n             maxDigits = minDigits;\n         if (minDigits < 0 || maxDigits <= 0) {\n             throw new IllegalArgumentException();\n         }\n+        DateTimeField field = fieldType.getField(iChronoUTC);\n         if (minDigits <= 1) {\n             return append0(new UnpaddedNumber(iChrono, field, maxDigits, false));\n         } else {\n      * Instructs the printer to emit a field value as a decimal number, and the\n      * parser to expect a signed decimal number.\n      *\n-     * @param field field should operate in UTC or be time zone agnostic\n+     * @param fieldType type of field to append\n      * @param minDigits minumum number of digits to <i>print</i>\n      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n      * @return this DateTimeFormatterBuilder\n-     * @throws IllegalArgumentException if field is null\n+     * @throws IllegalArgumentException if field type is null\n      */\n     public DateTimeFormatterBuilder appendSignedDecimal(\n-            DateTimeField field, int minDigits, int maxDigits) {\n-        if (field == null) {\n-            throw new IllegalArgumentException(\"Field must not be null\");\n+            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field type must not be null\");\n         }\n         if (maxDigits < minDigits) {\n             maxDigits = minDigits;\n         if (minDigits < 0 || maxDigits <= 0) {\n             throw new IllegalArgumentException();\n         }\n+        DateTimeField field = fieldType.getField(iChronoUTC);\n         if (minDigits <= 1) {\n             return append0(new UnpaddedNumber(iChrono, field, maxDigits, true));\n         } else {\n      * Instructs the printer to emit a field value as text, and the\n      * parser to expect text.\n      *\n-     * @param field field should operate in UTC or be time zone agnostic\n-     * @return this DateTimeFormatterBuilder\n-     */\n-    public DateTimeFormatterBuilder appendText(final DateTimeField field) {\n+     * @param fieldType type of field to append\n+     * @return this DateTimeFormatterBuilder\n+     * @throws IllegalArgumentException if field type is null\n+     */\n+    public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field type must not be null\");\n+        }\n+        DateTimeField field = fieldType.getField(iChronoUTC);\n         return append0(new TextField(iChrono, field, iLocale, false));\n     }\n \n      * Instructs the printer to emit a field value as short text, and the\n      * parser to expect text.\n      *\n-     * @param field field should operate in UTC or be time zone agnostic\n-     * @return this DateTimeFormatterBuilder\n-     */\n-    public DateTimeFormatterBuilder appendShortText(final DateTimeField field) {\n+     * @param fieldType type of field to append\n+     * @return this DateTimeFormatterBuilder\n+     * @throws IllegalArgumentException if field type is null\n+     */\n+    public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field type must not be null\");\n+        }\n+        DateTimeField field = fieldType.getField(iChronoUTC);\n         return append0(new TextField(iChrono, field, iLocale, true));\n     }\n \n      * decimal point is implied, so the fraction is 0.75, or three-quarters of\n      * a minute.\n      *\n-     * @param field field should operate in UTC or be time zone agnostic\n+     * @param fieldType type of field to append\n      * @param minDigits minumum number of digits to print.\n      * @param maxDigits maximum number of digits to print or parse.\n      * @return this DateTimeFormatterBuilder\n-     * @throws IllegalArgumentException if field's duration is not precise\n+     * @throws IllegalArgumentException if field type is null\n      */\n     public DateTimeFormatterBuilder appendFraction(\n-            DateTimeField field, int minDigits, int maxDigits) {\n-        if (field.getDurationField().isPrecise() == false) {\n-            throw new IllegalArgumentException(\"Field duration must be precise\");\n+            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field type must not be null\");\n         }\n         if (maxDigits < minDigits) {\n             maxDigits = minDigits;\n         if (minDigits < 0 || maxDigits <= 0) {\n             throw new IllegalArgumentException();\n         }\n+        DateTimeField field = fieldType.getField(iChronoUTC);\n         return append0(new Fraction(iChrono, field, minDigits, maxDigits));\n     }\n \n      * @param maxDigits maximum number of digits to print or parse\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendFractionOfSecond(final int minDigits, final int maxDigits) {\n-        return appendFraction(iChronoUTC.secondOfDay(), minDigits, maxDigits);\n+    public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\n+        return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n     }\n \n     /**\n      * @param maxDigits maximum number of digits to print or parse\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendFractionOfMinute(final int minDigits, final int maxDigits) {\n-        return appendFraction(iChronoUTC.minuteOfDay(), minDigits, maxDigits);\n+    public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) {\n+        return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits);\n     }\n \n     /**\n      * @param maxDigits maximum number of digits to print or parse\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendFractionOfHour(final int minDigits, final int maxDigits) {\n-        return appendFraction(iChronoUTC.hourOfDay(), minDigits, maxDigits);\n+    public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) {\n+        return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits);\n     }\n \n     /**\n      * @param maxDigits maximum number of digits to print or parse\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendFractionOfDay(final int minDigits, final int maxDigits) {\n-        return appendFraction(iChronoUTC.dayOfYear(), minDigits, maxDigits);\n+    public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) {\n+        return appendFraction(DateTimeFieldType.dayOfYear(), minDigits, maxDigits);\n     }\n \n     /**\n      * @param minDigits minumum number of digits to print\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendMillisOfSecond(final int minDigits) {\n-        return appendDecimal(iChronoUTC.millisOfSecond(), minDigits, 3);\n+    public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.millisOfSecond(), minDigits, 3);\n     }\n \n     /**\n      * @param minDigits minumum number of digits to print\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendMillisOfDay(final int minDigits) {\n-        return appendDecimal(iChronoUTC.millisOfDay(), minDigits, 8);\n+    public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.millisOfDay(), minDigits, 8);\n     }\n \n     /**\n      * @param minDigits minumum number of digits to print\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendSecondOfMinute(final int minDigits) {\n-        return appendDecimal(iChronoUTC.secondOfMinute(), minDigits, 2);\n+    public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n     }\n \n     /**\n      * @param minDigits minumum number of digits to print\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendSecondOfDay(final int minDigits) {\n-        return appendDecimal(iChronoUTC.secondOfDay(), minDigits, 5);\n+    public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5);\n     }\n \n     /**\n      * @param minDigits minumum number of digits to print\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendMinuteOfHour(final int minDigits) {\n-        return appendDecimal(iChronoUTC.minuteOfHour(), minDigits, 2);\n+    public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n     }\n \n     /**\n      * @param minDigits minumum number of digits to print\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendMinuteOfDay(final int minDigits) {\n-        return appendDecimal(iChronoUTC.minuteOfDay(), minDigits, 4);\n+    public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.minuteOfDay(), minDigits, 4);\n     }\n \n     /**\n      * @param minDigits minumum number of digits to print\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendHourOfDay(final int minDigits) {\n-        return appendDecimal(iChronoUTC.hourOfDay(), minDigits, 2);\n+    public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n     }\n \n     /**\n      * @param minDigits minumum number of digits to print\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendClockhourOfDay(final int minDigits) {\n-        return appendDecimal(iChronoUTC.clockhourOfDay(), minDigits, 2);\n+    public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2);\n     }\n \n     /**\n      * @param minDigits minumum number of digits to print\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendHourOfHalfday(final int minDigits) {\n-        return appendDecimal(iChronoUTC.hourOfHalfday(), minDigits, 2);\n+    public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2);\n     }\n \n     /**\n      * @param minDigits minumum number of digits to print\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendClockhourOfHalfday(final int minDigits) {\n-        return appendDecimal(iChronoUTC.clockhourOfHalfday(), minDigits, 2);\n+    public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2);\n     }\n \n     /**\n      * @param minDigits minumum number of digits to print\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendDayOfWeek(final int minDigits) {\n-        return appendDecimal(iChronoUTC.dayOfWeek(), minDigits, 1);\n+    public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.dayOfWeek(), minDigits, 1);\n     }\n \n     /**\n      * @param minDigits minumum number of digits to print\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendDayOfMonth(final int minDigits) {\n-        return appendDecimal(iChronoUTC.dayOfMonth(), minDigits, 2);\n+    public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n     }\n \n     /**\n      * @param minDigits minumum number of digits to print\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendDayOfYear(final int minDigits) {\n-        return appendDecimal(iChronoUTC.dayOfYear(), minDigits, 3);\n+    public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3);\n     }\n \n     /**\n      * @param minDigits minumum number of digits to print\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendWeekOfWeekyear(final int minDigits) {\n-        return appendDecimal(iChronoUTC.weekOfWeekyear(), minDigits, 2);\n+    public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);\n     }\n \n     /**\n      * maximum number of digits to print\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendWeekyear(final int minDigits, final int maxDigits) {\n-        return appendSignedDecimal(iChronoUTC.weekyear(), minDigits, maxDigits);\n+    public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {\n+        return appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits);\n     }\n \n     /**\n      * @param minDigits minumum number of digits to print\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendMonthOfYear(final int minDigits) {\n-        return appendDecimal(iChronoUTC.monthOfYear(), minDigits, 2);\n+    public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n     }\n \n     /**\n      * maximum number of digits to print\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendYear(final int minDigits, final int maxDigits) {\n-        return appendSignedDecimal(iChronoUTC.year(), minDigits, maxDigits);\n+    public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\n+        return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n     }\n \n     /**\n      * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) {\n-        return append0(new TwoDigitYear(iChrono, iChronoUTC.year(), pivot));\n+        DateTimeField field = DateTimeFieldType.year().getField(iChronoUTC);\n+        return append0(new TwoDigitYear(iChrono, field, pivot));\n     }\n \n     /**\n      * maximum number of digits to print\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendYearOfEra(final int minDigits, final int maxDigits) {\n-        return appendDecimal(iChronoUTC.yearOfEra(), minDigits, maxDigits);\n+    public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {\n+        return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits);\n     }\n \n     /**\n      * maximum number of digits to print\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendYearOfCentury(final int minDigits, final int maxDigits) {\n-        return appendDecimal(iChronoUTC.yearOfCentury(), minDigits, maxDigits);\n+    public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {\n+        return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits);\n     }\n \n     /**\n      * maximum number of digits to print\n      * @return this DateTimeFormatterBuilder\n      */\n-    public DateTimeFormatterBuilder appendCenturyOfEra(final int minDigits, final int maxDigits) {\n-        return appendSignedDecimal(iChronoUTC.centuryOfEra(), minDigits, maxDigits);\n+    public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) {\n+        return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits);\n     }\n \n     /**\n      * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendHalfdayOfDayText() {\n-        return appendText(iChronoUTC.halfdayOfDay());\n+        return appendText(DateTimeFieldType.halfdayOfDay());\n     }\n \n     /**\n      * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendDayOfWeekText() {\n-        return appendText(iChronoUTC.dayOfWeek());\n+        return appendText(DateTimeFieldType.dayOfWeek());\n     }\n \n     /**\n      * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendDayOfWeekShortText() {\n-        return appendShortText(iChronoUTC.dayOfWeek());\n+        return appendShortText(DateTimeFieldType.dayOfWeek());\n     }\n \n     /**\n      * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendMonthOfYearText() { \n-        return appendText(iChronoUTC.monthOfYear());\n+        return appendText(DateTimeFieldType.monthOfYear());\n     }\n \n     /**\n      * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendMonthOfYearShortText() {\n-        return appendShortText(iChronoUTC.monthOfYear());\n+        return appendShortText(DateTimeFieldType.monthOfYear());\n     }\n \n     /**\n      * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendEraText() {\n-        return appendText(iChronoUTC.era());\n+        return appendText(DateTimeFieldType.era());\n     }\n \n     /**\n      * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendTimeZoneOffset(\n-            final String zeroOffsetText, final boolean showSeparators,\n-            final int minFields, final int maxFields) {\n+            String zeroOffsetText, boolean showSeparators,\n+            int minFields, int maxFields) {\n         return append0(new TimeZoneOffsetFormatter\n                        (iChrono, zeroOffsetText, showSeparators, minFields, maxFields));\n     }\n         return f;\n     }\n \n-    private boolean isPrinter(final Object f) {\n+    private boolean isPrinter(Object f) {\n         if (f instanceof DateTimePrinter) {\n             if (f instanceof Composite) {\n                 return ((Composite)f).isPrinter();\n         return false;\n     }\n \n-    private boolean isParser(final Object f) {\n+    private boolean isParser(Object f) {\n         if (f instanceof DateTimeParser) {\n             if (f instanceof Composite) {\n                 return ((Composite)f).isParser();\n         return false;\n     }\n \n-    private boolean isFormatter(final Object f) {\n+    private boolean isFormatter(Object f) {\n         if (f instanceof DateTimeFormatter) {\n             if (f instanceof Composite) {\n                 return ((Composite)f).isPrinter()\n         private final int iPrintedLengthEstimate;\n         private final int iParsedLengthEstimate;\n \n-        Composite(Chronology chrono, ArrayList elementPairs) {\n+        Composite(Chronology chrono, List elementPairs) {\n             super(chrono);\n \n-            int len = elementPairs.size() / 2;\n-\n-            boolean isPrinter = true;\n-            boolean isParser = true;\n-\n-            int printEst = 0;\n-            int parseEst = 0;\n-\n-            DateTimePrinter[] printers = new DateTimePrinter[len];\n-            DateTimeParser[] parsers = new DateTimeParser[len];\n-            for (int i=0; i<len; i++) {\n-                Object element = elementPairs.get(i * 2);\n-                if (element == null || !(element instanceof DateTimePrinter)) {\n-                    isPrinter = false;\n-                } else {\n-                    DateTimePrinter printer = (DateTimePrinter)element;\n+            List printerList = new ArrayList();\n+            List parserList = new ArrayList();\n+\n+            decompose(elementPairs, printerList, parserList);\n+\n+            if (printerList.size() <= 0) {\n+                iPrinters = null;\n+                iPrintedLengthEstimate = 0;\n+            } else {\n+                int size = printerList.size();\n+                iPrinters = new DateTimePrinter[size];\n+                int printEst = 0;\n+                for (int i=0; i<size; i++) {\n+                    DateTimePrinter printer = (DateTimePrinter)printerList.get(i);\n                     printEst += printer.estimatePrintedLength();\n-                    printers[i] = printer;\n-                }\n-\n-                element = elementPairs.get(i * 2 + 1);\n-                if (element == null || !(element instanceof DateTimeParser)) {\n-                    isParser = false;\n-                } else {\n-                    DateTimeParser parser = (DateTimeParser)element;\n+                    iPrinters[i] = printer;\n+                }\n+                iPrintedLengthEstimate = printEst;\n+            }\n+\n+            if (parserList.size() <= 0) {\n+                iParsers = null;\n+                iParsedLengthEstimate = 0;\n+            } else {\n+                int size = parserList.size();\n+                iParsers = new DateTimeParser[size];\n+                int parseEst = 0;\n+                for (int i=0; i<size; i++) {\n+                    DateTimeParser parser = (DateTimeParser)parserList.get(i);\n                     parseEst += parser.estimateParsedLength();\n-                    parsers[i] = parser;\n-                }\n-            }\n-\n-            if (!isPrinter) {\n-                printers = null;\n-            }\n-            if (!isParser) {\n-                parsers = null;\n-            }\n-\n-            iPrinters = printers;\n-            iParsers = parsers;\n-            iPrintedLengthEstimate = printEst;\n-            iParsedLengthEstimate = parseEst;\n+                    iParsers[i] = parser;\n+                }\n+                iParsedLengthEstimate = parseEst;\n+            }\n         }\n \n         public int estimatePrintedLength() {\n \n         boolean isParser() {\n             return iParsers != null;\n+        }\n+\n+        /**\n+         * Processes the element pairs, putting results into the given printer\n+         * and parser lists.\n+         */\n+        private void decompose(List elementPairs, List printerList, List parserList) {\n+            int size = elementPairs.size();\n+            for (int i=0; i<size; i+=2) {\n+                Object element = elementPairs.get(i);\n+                if (element != null && element instanceof DateTimePrinter) {\n+                    if (element instanceof Composite) {\n+                        addArrayToList(printerList, ((Composite)element).iPrinters);\n+                    } else {\n+                        printerList.add(element);\n+                    }\n+                }\n+\n+                element = elementPairs.get(i + 1);\n+                if (element != null && element instanceof DateTimeParser) {\n+                    if (element instanceof Composite) {\n+                        addArrayToList(parserList, ((Composite)element).iParsers);\n+                    } else {\n+                        parserList.add(element);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void addArrayToList(List list, Object[] array) {\n+            if (array != null) {\n+                for (int i=0; i<array.length; i++) {\n+                    list.add(array[i]);\n+                }\n+            }\n         }\n     }\n \n             return iParsedLengthEstimate;\n         }\n \n-        public int parseInto(final DateTimeParserBucket bucket, final String text, final int position) {\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             DateTimeParser[] parsers = iParsers;\n             int length = parsers.length;\n ", "timestamp": 1094945434, "metainfo": ""}