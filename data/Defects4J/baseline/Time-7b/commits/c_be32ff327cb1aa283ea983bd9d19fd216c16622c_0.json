{"sha": "be32ff327cb1aa283ea983bd9d19fd216c16622c", "log": "Added TestUnsupportedDateTimeField to exercise all methods in UnsupportedDateTimeField. Modified TestAll.java to include this test suite.   ", "commit": "\n--- a/JodaTime/src/test/org/joda/time/field/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/field/TestAll.java\n         suite.addTest(TestMillisDurationField.suite());\n         suite.addTest(TestPreciseDurationField.suite());\n         suite.addTest(TestScaledDurationField.suite());\n-        \n+        suite.addTest(TestUnsupportedDateTimeField.suite());\n         return suite;\n     }\n \n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/field/TestUnsupportedDateTimeField.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationFieldType;\n+import org.joda.time.LocalTime;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.chrono.GregorianChronology;\n+import org.joda.time.chrono.IslamicChronology;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * This class is a JUnit test to test only the UnsupportedDateTimeField class.\n+ * This set of test cases exercises everything described in the Javadoc for this\n+ * class.\n+ * \n+ * @author Jeremy R. Rickard\n+ */\n+public class TestUnsupportedDateTimeField extends TestCase {\n+\n+    private DurationFieldType weeks;\n+    private DurationFieldType months;\n+    private DateTimeFieldType dateTimeFieldTypeOne;\n+    private ReadablePartial localTime;\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestUnsupportedDateTimeField.class);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        weeks = DurationFieldType.weeks();\n+        months = DurationFieldType.months();\n+        dateTimeFieldTypeOne = DateTimeFieldType.centuryOfEra();\n+        localTime = new LocalTime();\n+    }\n+\n+    /**\n+     * Passing null values into UnsupportedDateTimeField.getInstance() should\n+     * throw an IllegalArguementsException\n+     */\n+    public void testNullValuesToGetInstanceThrowsException() {\n+\n+        try {\n+            UnsupportedDateTimeField.getInstance(null, null);\n+            assertTrue(false);\n+        } catch (IllegalArgumentException e) {\n+            assertTrue(true);\n+        }\n+    }\n+\n+    /**\n+     * \n+     * This test exercises the logic in UnsupportedDateTimeField.getInstance. If\n+     * getInstance() is invoked twice with: - the same DateTimeFieldType -\n+     * different duration fields\n+     * \n+     * Then the field returned in the first invocation should not be equal to\n+     * the field returned by the second invocation. In otherwords, the generated\n+     * instance should be the same for a unique pairing of\n+     * DateTimeFieldType/DurationField\n+     */\n+    public void testDifferentDurationReturnDifferentObjects() {\n+\n+        /**\n+         * The fields returned by getInstance should be the same when the\n+         * duration is the same for both method calls.\n+         */\n+        DateTimeField fieldOne = UnsupportedDateTimeField.getInstance(\n+                dateTimeFieldTypeOne, UnsupportedDurationField\n+                        .getInstance(weeks));\n+        DateTimeField fieldTwo = UnsupportedDateTimeField.getInstance(\n+                dateTimeFieldTypeOne, UnsupportedDurationField\n+                        .getInstance(weeks));\n+        assertSame(fieldOne, fieldTwo);\n+\n+        /**\n+         * The fields returned by getInstance should NOT be the same when the\n+         * duration is the same for both method calls.\n+         */\n+        DateTimeField fieldThree = UnsupportedDateTimeField.getInstance(\n+                dateTimeFieldTypeOne, UnsupportedDurationField\n+                        .getInstance(months));\n+        assertNotSame(fieldOne, fieldThree);\n+    }\n+\n+    /**\n+     * The getName() method should return the same value as the getName() method\n+     * of the DateTimeFieldType that was used to create the instance.\n+     * \n+     */\n+    public void testPublicGetNameMethod() {\n+        DateTimeField fieldOne = UnsupportedDateTimeField.getInstance(\n+                dateTimeFieldTypeOne, UnsupportedDurationField\n+                        .getInstance(weeks));\n+\n+        assertSame(fieldOne.getName(), dateTimeFieldTypeOne.getName());\n+    }\n+\n+    /**\n+     * As this is an unsupported date/time field, some normal methods will\n+     * always return false, as they are not supported. Verify that each method\n+     * correctly returns null.\n+     */\n+    public void testAlwaysFalseReturnTypes() {\n+        DateTimeField fieldOne = UnsupportedDateTimeField.getInstance(\n+                dateTimeFieldTypeOne, UnsupportedDurationField\n+                        .getInstance(weeks));\n+        assertFalse(fieldOne.isLenient());\n+        assertFalse(fieldOne.isSupported());\n+    }\n+\n+    /**\n+     * According to the JavaDocs, there are two methods that should always\n+     * return null. * getRangeDurationField() * getLeapDurationField()\n+     * \n+     * Ensure that these are in fact null.\n+     */\n+\n+    public void testMethodsThatShouldAlwaysReturnNull() {\n+        DateTimeField fieldOne = UnsupportedDateTimeField.getInstance(\n+                dateTimeFieldTypeOne, UnsupportedDurationField\n+                        .getInstance(weeks));\n+\n+        assertNull(fieldOne.getLeapDurationField());\n+        assertNull(fieldOne.getRangeDurationField());\n+    }\n+\n+    /**\n+     * As this is an unsupported date/time field, many normal methods are\n+     * unsupported and throw an UnsupportedOperationException. Verify that each\n+     * method correctly throws this exception. * add(ReadablePartial instant,\n+     * int fieldIndex, int[] values, int valueToAdd) * addWrapField(long\n+     * instant, int value) * addWrapField(ReadablePartial instant, int\n+     * fieldIndex, int[] values, int valueToAdd) *\n+     * addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int\n+     * valueToAdd) * get(long instant) * getAsShortText(int fieldValue, Locale\n+     * locale) * getAsShortText(long instant) * getAsShortText(long instant,\n+     * Locale locale) * getAsShortText(ReadablePartial partial, int fieldValue,\n+     * Locale locale) * getAsShortText(ReadablePartial partial, Locale locale) *\n+     * getAsText(int fieldValue, Locale locale) * getAsText(long instant) *\n+     * getAsText(long instant, Locale locale) * getAsText(ReadablePartial\n+     * partial, int fieldValue, Locale locale) * getAsText(ReadablePartial\n+     * partial, Locale locale) * getLeapAmount(long instant) *\n+     * getMaximumShortTextLength(Locale locale) * getMaximumTextLength(Locale\n+     * locale) * getMaximumValue() * getMaximumValue(long instant) *\n+     * getMaximumValue(ReadablePartial instant) *\n+     * getMaximumValue(ReadablePartial instant, int[] values) *\n+     * getMinimumValue() * getMinimumValue(long instant) *\n+     * getMinimumValue(ReadablePartial instant) *\n+     * getMinimumValue(ReadablePartial instant, int[] values) * isLeap(long\n+     * instant) * remainder(long instant) * roundCeiling(long instant) *\n+     * roundFloor(long instant) * roundHalfCeiling(long instant) *\n+     * roundHalfEven(long instant) * roundHalfFloor(long instant) * set(long\n+     * instant, int value) * set(long instant, String text) * set(long instant,\n+     * String text, Locale locale) * set(ReadablePartial instant, int\n+     * fieldIndex, int[] values, int newValue) * set(ReadablePartial instant,\n+     * int fieldIndex, int[] values, String text, Locale locale)\n+     */\n+    public void testUnsupportedMethods() {\n+        DateTimeField fieldOne = UnsupportedDateTimeField.getInstance(\n+                dateTimeFieldTypeOne, UnsupportedDurationField\n+                        .getInstance(weeks));\n+\n+        // add(ReadablePartial instant, int fieldIndex, int[] values, int\n+        // valueToAdd)\n+        try {\n+            fieldOne.add(localTime, 0, new int[] { 0, 100 }, 100);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+        // addWrapField(long instant, int value)\n+        try {\n+            fieldOne.addWrapField(100000L, 250);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+        // addWrapField(ReadablePartial instant, int fieldIndex, int[] values,\n+        // int valueToAdd)\n+        try {\n+            fieldOne.addWrapField(localTime, 0, new int[] { 0, 100 }, 100);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+        // addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values,\n+        // int valueToAdd)\n+        try {\n+            fieldOne.addWrapPartial(localTime, 0, new int[] { 0, 100 }, 100);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+        // UnsupportedDateTimeField.get(long instant)\n+        try {\n+            fieldOne.get(1000L);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getAsShortText(int fieldValue,\n+        // Locale locale)\n+        try {\n+            fieldOne.getAsShortText(0, Locale.getDefault());\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getAsShortText(long instant)\n+        try {\n+            fieldOne.getAsShortText(100000L);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getAsShortText(long instant, Locale locale)\n+        try {\n+            fieldOne.getAsShortText(100000L, Locale.getDefault());\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getAsShortText(ReadablePartial partial,\n+        // int fieldValue,\n+        // Locale locale)\n+        try {\n+            fieldOne.getAsShortText(localTime, 0, Locale.getDefault());\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getAsShortText(ReadablePartial partial,\n+        // Locale locale)\n+        try {\n+            fieldOne.getAsShortText(localTime, Locale.getDefault());\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getAsText(int fieldValue,\n+        // Locale locale)\n+        try {\n+            fieldOne.getAsText(0, Locale.getDefault());\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getAsText(long instant)\n+        try {\n+            fieldOne.getAsText(1000L);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getAsText(long instant, Locale locale)\n+        try {\n+            fieldOne.getAsText(1000L, Locale.getDefault());\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getAsText(ReadablePartial partial,\n+        // int fieldValue,\n+        // Locale locale)\n+        try {\n+            fieldOne.getAsText(localTime, 0, Locale.getDefault());\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getAsText(ReadablePartial partial,\n+        // Locale locale)\n+        try {\n+            fieldOne.getAsText(localTime, Locale.getDefault());\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getLeapAmount(long instant) is unsupported\n+        // and should always thrown an UnsupportedOperationException\n+        try {\n+            fieldOne.getLeapAmount(System.currentTimeMillis());\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getMaximumShortTextLength(Locale locale)\n+        // is unsupported and should always thrown an\n+        // UnsupportedOperationException\n+        try {\n+            fieldOne.getMaximumShortTextLength(Locale.getDefault());\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getMaximumTextLength(Locale locale)\n+        // is unsupported and should always thrown an\n+        // UnsupportedOperationException\n+        try {\n+            fieldOne.getMaximumTextLength(Locale.getDefault());\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getMaximumValue() is unsupported\n+        // and should always thrown an UnsupportedOperationException\n+        try {\n+            fieldOne.getMaximumValue();\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getMaximumValue(long instant)\n+        // is unsupported and should always thrown an\n+        // UnsupportedOperationException\n+        try {\n+            fieldOne.getMaximumValue(1000000L);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getMaximumValue(ReadablePartial instant)\n+        // is unsupported and should always thrown an\n+        // UnsupportedOperationException\n+        try {\n+            fieldOne.getMaximumValue(localTime);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getMaximumValue(ReadablePartial instant,\n+        // int[] values)\n+        // is unsupported and should always thrown an\n+        // UnsupportedOperationException\n+        try {\n+            fieldOne.getMaximumValue(localTime, new int[] { 0 });\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getMinumumValue() is unsupported\n+        // and should always thrown an UnsupportedOperationException\n+        try {\n+            fieldOne.getMinimumValue();\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getMinumumValue(long instant) is unsupported\n+        // and should always thrown an UnsupportedOperationException\n+        try {\n+            fieldOne.getMinimumValue(10000000L);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getMinumumValue(ReadablePartial instant)\n+        // is unsupported and should always thrown an\n+        // UnsupportedOperationException\n+        try {\n+            fieldOne.getMinimumValue(localTime);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.getMinumumValue(ReadablePartial instant,\n+        // int[] values) is unsupported\n+        // and should always thrown an UnsupportedOperationException\n+        try {\n+            fieldOne.getMinimumValue(localTime, new int[] { 0 });\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.isLeap(long instant) is unsupported and\n+        // should always thrown an UnsupportedOperationException\n+        try {\n+            fieldOne.isLeap(System.currentTimeMillis());\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.remainder(long instant) is unsupported and\n+        // should always thrown an UnsupportedOperationException\n+        try {\n+            fieldOne.remainder(1000000L);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.roundCeiling(long instant) is unsupported\n+        // and\n+        // should always thrown an UnsupportedOperationException\n+        try {\n+            fieldOne.roundCeiling(1000000L);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.roundFloor(long instant) is unsupported and\n+        // should always thrown an UnsupportedOperationException\n+        try {\n+            fieldOne.roundFloor(1000000L);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.roundHalfCeiling(long instant) is\n+        // unsupported and\n+        // should always thrown an UnsupportedOperationException\n+        try {\n+            fieldOne.roundHalfCeiling(1000000L);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.roundHalfEven(long instant) is unsupported\n+        // and\n+        // should always thrown an UnsupportedOperationException\n+        try {\n+            fieldOne.roundHalfEven(1000000L);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.roundHalfFloor(long instant) is unsupported\n+        // and\n+        // should always thrown an UnsupportedOperationException\n+        try {\n+            fieldOne.roundHalfFloor(1000000L);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.set(long instant, int value) is unsupported\n+        // and\n+        // should always thrown an UnsupportedOperationException\n+        try {\n+            fieldOne.set(1000000L, 1000);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.set(long instant, String test) is\n+        // unsupported and\n+        // should always thrown an UnsupportedOperationException\n+        try {\n+            fieldOne.set(1000000L, \"Unsupported Operation\");\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.set(long instant, String text, Locale\n+        // locale)\n+        // is unsupported and should always thrown an\n+        // UnsupportedOperationException\n+        try {\n+            fieldOne\n+                    .set(1000000L, \"Unsupported Operation\", Locale.getDefault());\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.set(ReadablePartial instant,\n+        // int fieldIndex,\n+        // int[] values,\n+        // int newValue) is unsupported and\n+        // should always thrown an UnsupportedOperationException\n+        try {\n+            fieldOne.set(localTime, 0, new int[] { 0 }, 10000);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        // UnsupportedDateTimeField.set(ReadablePartial instant,\n+        // int fieldIndex,\n+        // int[] values,\n+        // String text,\n+        // Locale locale) is unsupported and\n+        // should always thrown an UnsupportedOperationException\n+        try {\n+            fieldOne.set(localTime, 0, new int[] { 0 },\n+                    \"Unsupported Operation\", Locale.getDefault());\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+    }\n+\n+    /**\n+     * As this is an unsupported date/time field, many normal methods are\n+     * unsupported. Some delegate and can possibly throw an\n+     * UnsupportedOperationException or have a valid return. Verify that each\n+     * method correctly throws this exception when appropriate and delegates\n+     * correctly based on the Duration used to get the instance.\n+     */\n+    public void testDelegatedMethods() {\n+        DateTimeField fieldOne = UnsupportedDateTimeField.getInstance(\n+                dateTimeFieldTypeOne, UnsupportedDurationField\n+                        .getInstance(weeks));\n+        PreciseDurationField hoursDuration = new PreciseDurationField(\n+                DurationFieldType.hours(), 10L);\n+        DateTimeField fieldTwo = UnsupportedDateTimeField.getInstance(\n+                dateTimeFieldTypeOne, hoursDuration);\n+\n+        // UnsupportedDateTimeField.add(long instant, int value) should\n+        // throw an UnsupportedOperationException when the duration does\n+        // not support the operation, otherwise it delegates to the duration.\n+        // First\n+        // try it with an UnsupportedDurationField, then a PreciseDurationField.\n+        try {\n+            fieldOne.add(System.currentTimeMillis(), 100);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+        try {\n+                long currentTime = System.currentTimeMillis();\n+            long firstComputation = hoursDuration.add(currentTime, 100);\n+            long secondComputation = fieldTwo.add(currentTime,\n+                    100);\n+            System.out.println(firstComputation);\n+            System.out.println(secondComputation);\n+            assertEquals(firstComputation,secondComputation);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(false);\n+        }\n+\n+        // UnsupportedDateTimeField.add(long instant, long value) should\n+        // throw an UnsupportedOperationException when the duration does\n+        // not support the operation, otherwise it delegates to the duration.\n+        // First\n+        // try it with an UnsupportedDurationField, then a PreciseDurationField.\n+        try {\n+            fieldOne.add(System.currentTimeMillis(), 1000L);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        try {\n+                long currentTime = System.currentTimeMillis();\n+            long firstComputation = hoursDuration.add(currentTime, 1000L);\n+            long secondComputation = fieldTwo.add(currentTime,\n+                    1000L);\n+            assertTrue(firstComputation == secondComputation);\n+            assertEquals(firstComputation,secondComputation);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(false);\n+        }\n+\n+        // UnsupportedDateTimeField.getDifference(long minuendInstant,\n+        // long subtrahendInstant)\n+        // should throw an UnsupportedOperationException when the duration does\n+        // not support the operation, otherwise return the result from the\n+        // delegated call.\n+        try {\n+\n+            fieldOne.getDifference(100000L, 1000L);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        try {\n+            int firstDifference = hoursDuration.getDifference(100000L, 1000L);\n+            int secondDifference = fieldTwo.getDifference(100000L, 1000L);\n+            assertEquals(firstDifference,secondDifference);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(false);\n+        }\n+\n+        // UnsupportedDateTimeField.getDifferenceAsLong(long minuendInstant,\n+        // long subtrahendInstant)\n+        // should throw an UnsupportedOperationException when the duration does\n+        // not support the operation, otherwise return the result from the\n+        // delegated call.\n+        try {\n+\n+            fieldOne.getDifferenceAsLong(100000L, 1000L);\n+            assertTrue(false);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(true);\n+        }\n+\n+        try {\n+            long firstDifference = hoursDuration.getDifference(100000L, 1000L);\n+            long secondDifference = fieldTwo.getDifference(100000L, 1000L);\n+            assertEquals(firstDifference,secondDifference);\n+        } catch (UnsupportedOperationException e) {\n+            assertTrue(false);\n+        }\n+    }\n+\n+    /**\n+    * The toString method should return a suitable debug message (not null).\n+    * Ensure that the toString method returns a string with length greater than\n+    * 0 (and not null)\n+    * \n+    */\n+    public void testToString() {\n+        DateTimeField fieldOne = UnsupportedDateTimeField.getInstance(\n+                dateTimeFieldTypeOne, UnsupportedDurationField\n+                        .getInstance(weeks));\n+\n+        String debugMessage = fieldOne.toString();\n+        assertNotNull(debugMessage);\n+        assertTrue(debugMessage.length() > 0);\n+    }\n+}", "timestamp": 1174960598, "metainfo": ""}