{"sha": "672fc2244038f0d45ccb6e9e9179f3e861b9fbea", "log": "Initial versions of local datetime classes   ", "commit": "\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/LocalDate.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import org.joda.time.base.AbstractPartial;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.InstantConverter;\n+import org.joda.time.field.AbstractReadableInstantFieldProperty;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * LocalDate is an unmodifiable datetime class representing a\n+ * datetime without a time zone.\n+ * <p>\n+ * LocalDate implements the {@link ReadablePartial} interface.\n+ * To do this, the interface methods focus on the key fields -\n+ * Year, MonthOfYear and DayOfMonth.\n+ * However, <b>all</b> fields may in fact be queried.\n+ * <p>\n+ * LocalDate differs from DateMidnight in that this class does not\n+ * have a time zone and does not represent a single instant in time.\n+ * <p>\n+ * Calculations on LocalDate are performed using a {@link Chronology}.\n+ * This chronology will be set internally to be in the UTC time zone\n+ * for all calculations.\n+ *\n+ * <p>Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getMonthOfYear()</code>\n+ * <li><code>monthOfYear().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value\n+ * <li>text value\n+ * <li>short text value\n+ * <li>maximum/minimum values\n+ * <li>add/subtract\n+ * <li>set\n+ * <li>rounding\n+ * </ul>\n+ *\n+ * <p>\n+ * LocalDate is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.3\n+ */\n+public final class LocalDate\n+        extends AbstractPartial\n+        implements ReadablePartial, Serializable {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -8775358157899L;\n+\n+    /** The index of the year field in the field array */\n+    private static final int YEAR = 0;\n+    /** The index of the monthOfYear field in the field array */\n+    private static final int MONTH_OF_YEAR = 1;\n+    /** The index of the dayOfMonth field in the field array */\n+    private static final int DAY_OF_MONTH = 2;\n+    /** Set of known duration types. */\n+    private static final Set DATE_DURATION_TYPES = new HashSet();\n+    static {\n+        DATE_DURATION_TYPES.add(DurationFieldType.days());\n+        DATE_DURATION_TYPES.add(DurationFieldType.weeks());\n+        DATE_DURATION_TYPES.add(DurationFieldType.months());\n+        DATE_DURATION_TYPES.add(DurationFieldType.weekyears());\n+        DATE_DURATION_TYPES.add(DurationFieldType.years());\n+        DATE_DURATION_TYPES.add(DurationFieldType.centuries());\n+        DATE_DURATION_TYPES.add(DurationFieldType.eras());\n+    }\n+\n+    /** The local millis from 1970-01-01T00:00:00 */\n+    private long iLocalMillis;\n+    /** The chronology to use in UTC */\n+    private Chronology iChronology;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the current local time evaluated using\n+     * ISO chronology in the default zone.\n+     * <p>\n+     * Once the constructor is completed, the zone is no longer used.\n+     */\n+    public static LocalDate nowDefaultZone() {\n+        return forInstant(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current local time evaluated using\n+     * ISO chronology in the specified zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public static LocalDate now(DateTimeZone zone) {\n+        return forInstant(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current local time evaluated using\n+     * specified chronology.\n+     * <p>\n+     * If the chronology is null, ISO chronology in the default time zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public static LocalDate now(Chronology chronology) {\n+        return forInstant(DateTimeUtils.currentTimeMillis(), chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Calendar and assigned to the LocalDate.\n+     * This is useful if you have been using the Calendar as a local date,\n+     * ignoing the zone.\n+     * <p>\n+     * This factory method ignores the type of the calendar and always\n+     * creates a LocalDate with ISO chronology. It is expected that you\n+     * will only pass in instances of <code>GregorianCalendar</code> however\n+     * this is not validated.\n+     *\n+     * @param calendar  the Calendar to extract fields from\n+     * @return the created LocalDate\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n+     */\n+    public static LocalDate forFields(Calendar calendar) {\n+        if (calendar == null) {\n+            throw new IllegalArgumentException(\"The calendar must not be null\");\n+        }\n+        return new LocalDate(\n+            calendar.get(Calendar.YEAR),\n+            calendar.get(Calendar.MONTH) + 1,\n+            calendar.get(Calendar.DAY_OF_MONTH)\n+        );\n+    }\n+\n+    /**\n+     * Constructs a LocalDate from a <code>java.util.Date</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Date and assigned to the LocalDate.\n+     * This is useful if you have been using the Date as a local date,\n+     * ignoing the zone.\n+     * <p>\n+     * This factory method always creates a LocalDate with ISO chronology.\n+     *\n+     * @param date  the Date to extract fields from\n+     * @return the created LocalDate\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n+     */\n+    public static LocalDate forFields(Date date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return new LocalDate(\n+            date.getYear() + 1900,\n+            date.getMonth() + 1,\n+            date.getDate()\n+        );\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using ISO chronology in the default zone.\n+     * <p>\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public static LocalDate forInstantDefaultZone(long instant) {\n+        return forInstant(instant, ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using ISO chronology in the specified zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public static LocalDate forInstant(long instant, DateTimeZone zone) {\n+        return forInstant(instant, ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using the specified chronology.\n+     * <p>\n+     * If the chronology is null, ISO chronology in the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public static LocalDate forInstant(long instant, Chronology chronology) {\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\n+        return new LocalDate(localMillis, chronology.withUTC());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * forcing the time zone to that specified.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * If the specified time zone is null, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object\n+     * @param zone  the time zone\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public static LocalDate forInstant(Object instant, DateTimeZone zone) {\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        Chronology chrono = converter.getChronology(instant, zone);\n+        long millis = converter.getInstantMillis(instant, chrono);\n+        chrono = DateTimeUtils.getChronology(chrono);\n+        return forInstant(millis, chrono);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, ISO in the default time zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object\n+     * @param chronology  the chronology\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public static LocalDate forInstant(Object instant, Chronology chronology) {\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        Chronology chrono = DateTimeUtils.getChronology(converter.getChronology(instant, chronology));\n+        long millis = converter.getInstantMillis(instant, chronology);\n+        return forInstant(millis, chrono);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using the specified local (UTC) chronology.\n+     *\n+     * @param localMillis  the local milliseconds from 1970-01-01T00:00:00\n+     * @param chronology  the UTC chronology, not null\n+     */\n+    LocalDate(long localMillis, Chronology chronology) {\n+        super();\n+        chronology.dayOfMonth().roundFloor(localMillis);\n+        iLocalMillis = localMillis;\n+        iChronology = chronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the specified date and time\n+     * using <code>ISOChronology</code>.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     */\n+    public LocalDate(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth) {\n+        this(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the specified date and time\n+     * using the specified chronology, whose zone is ignored.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code> is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public LocalDate(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            Chronology chronology) {\n+        super();\n+        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n+        long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n+        iChronology = chronology;\n+        iLocalMillis = instant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial, which is three.\n+     * The supported fields are Year, MonthOfYear and DayOfMonth.\n+     * Note that all fields from day and above may in fact be queried via\n+     * other methods.\n+     *\n+     * @return the field count, three\n+     */\n+    public int size() {\n+        return 3;\n+    }\n+\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * <p>\n+     * This method must not use any instance variables.\n+     *\n+     * @param index  the index to retrieve\n+     * @param chrono  the chronology to use\n+     * @return the field\n+     */\n+    protected DateTimeField getField(int index, Chronology chrono) {\n+        switch (index) {\n+            case YEAR:\n+                return chrono.year();\n+            case MONTH_OF_YEAR:\n+                return chrono.monthOfYear();\n+            case DAY_OF_MONTH:\n+                return chrono.dayOfMonth();\n+            default:\n+                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n+    }\n+\n+    /**\n+     * Gets the value of the field at the specifed index.\n+     * <p>\n+     * This method is required to support the <code>ReadablePartial</code>\n+     * interface. The supported fields are Year, MonthOfYear and DayOfMonth.\n+     * Note that all fields from day and above may in fact be queried via\n+     * other methods.\n+     *\n+     * @param index  the index, zero to two\n+     * @return the value\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public int getValue(int index) {\n+        switch (index) {\n+            case YEAR:\n+                return getChronology().year().get(getLocalMillis());\n+            case MONTH_OF_YEAR:\n+                return getChronology().monthOfYear().get(getLocalMillis());\n+            case DAY_OF_MONTH:\n+                return getChronology().dayOfMonth().get(getLocalMillis());\n+            default:\n+                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value of one of the fields of a datetime.\n+     * <p>\n+     * This method gets the value of the specified field.\n+     * For example:\n+     * <pre>\n+     * LocalDate dt = LocalDate.nowDefaultZone();\n+     * int year = dt.get(DateTimeFieldType.year());\n+     * </pre>\n+     *\n+     * @param fieldType  a field type, usually obtained from DateTimeFieldType, not null\n+     * @return the value of that field\n+     * @throws IllegalArgumentException if the field type is null or unsupported\n+     */\n+    public int get(DateTimeFieldType fieldType) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n+        }\n+        if (isSupported(fieldType) == false) {\n+            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n+        }\n+        return fieldType.getField(getChronology()).get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Checks if the field type specified is supported by this\n+     * local datetime and chronology.\n+     * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.\n+     *\n+     * @param type  a field type, usually obtained from DateTimeFieldType\n+     * @return true if the field type is supported\n+     */\n+    public boolean isSupported(DateTimeFieldType type) {\n+        if (type == null) {\n+            return false;\n+        }\n+        DateTimeField field = type.getField(getChronology());\n+        if (DATE_DURATION_TYPES.contains(type.getDurationType()) ||\n+            field.getDurationField().getUnitMillis() >= getChronology().days().getUnitMillis()) {\n+            return field.isSupported();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks if the duration type specified is supported by this\n+     * local datetime and chronology.\n+     *\n+     * @param type  a duration type, usually obtained from DurationFieldType\n+     * @return true if the field type is supported\n+     */\n+    public boolean isSupported(DurationFieldType type) {\n+        if (type == null) {\n+            return false;\n+        }\n+        DurationField field = type.getField(getChronology());\n+        if (DATE_DURATION_TYPES.contains(type) ||\n+            field.getUnitMillis() >= getChronology().days().getUnitMillis()) {\n+            return field.isSupported();\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the milliseconds of the datetime instant from the Java epoch\n+     * of 1970-01-01T00:00:00 (not fixed to any specific time zone).\n+     * \n+     * @return the number of milliseconds since 1970-01-01T00:00:00\n+     */\n+    long getLocalMillis() {\n+        return iLocalMillis;\n+    }\n+\n+    /**\n+     * Gets the chronology of the datetime.\n+     * \n+     * @return the Chronology that the datetime is using\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this LocalDate to a full datetime at midnight using the\n+     * default time zone.\n+     *\n+     * @return this date as a datetime at midnight\n+     */\n+    public DateTime toDateTimeAtMidnightDefaultZone() {\n+        return toDateTimeAtMidnight(null);\n+    }\n+\n+    /**\n+     * Converts this LocalDate to a full datetime at midnight using the\n+     * specified time zone.\n+     * <p>\n+     * This method uses the chronology from this instance plus the time zone\n+     * specified.\n+     *\n+     * @param zone  the zone to use, null means default zone\n+     * @return this date as a datetime at midnight\n+     */\n+    public DateTime toDateTimeAtMidnight(DateTimeZone zone) {\n+        zone = DateTimeUtils.getZone(zone);\n+        Chronology chrono = getChronology().withZone(zone);\n+        return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this LocalDate to a full datetime using the default time zone\n+     * setting the date fields from this instance and the time fields from\n+     * the current time.\n+     *\n+     * @return this date as a datetime with the time as the current time\n+     */\n+    public DateTime toDateTimeAtCurrentTimeDefaultZone() {\n+        return toDateTimeAtCurrentTime(null);\n+    }\n+\n+    /**\n+     * Converts this LocalDate to a full datetime using the specified time zone\n+     * setting the date fields from this instance and the time fields from\n+     * the current time.\n+     * <p>\n+     * This method uses the chronology from this instance plus the time zone\n+     * specified.\n+     *\n+     * @param zone  the zone to use, null means default zone\n+     * @return this date as a datetime with the time as the current time\n+     */\n+    public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) {\n+        zone = DateTimeUtils.getZone(zone);\n+        Chronology chrono = getChronology().withZone(zone);\n+        long instantMillis = DateTimeUtils.currentTimeMillis();\n+        long resolved = chrono.set(this, instantMillis);\n+        return new DateTime(resolved, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this LocalDate to a DateMidnight in the default time zone.\n+     *\n+     * @return the DateMidnight instance in the default zone\n+     */\n+    public DateMidnight toDateMidnightDefaultZone() {\n+        return toDateMidnight(null);\n+    }\n+\n+    /**\n+     * Converts this LocalDate to a DateMidnight.\n+     *\n+     * @param zone  the zone to get the DateMidnight in, null means default zone\n+     * @return the DateMidnight instance\n+     */\n+    public DateMidnight toDateMidnight(DateTimeZone zone) {\n+        zone = DateTimeUtils.getZone(zone);\n+        Chronology chrono = getChronology().withZone(zone);\n+        return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this date with different local millis.\n+     * <p>\n+     * The returned object will be a new instance of the same type.\n+     * Only the millis will change, the chronology is kept.\n+     * The returned object will be either be a new instance or <code>this</code>.\n+     *\n+     * @param newMillis  the new millis, from 1970-01-01T00:00:00\n+     * @return a copy of this date with different millis\n+     */\n+    LocalDate withLocalMillis(long newMillis) {\n+        newMillis = iChronology.dayOfMonth().roundFloor(newMillis);\n+        return (newMillis == getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this LocalDate with the partial set of fields replacing\n+     * those from this instance.\n+     * <p>\n+     * For example, if the partial contains a year and a month then those two\n+     * fields will be changed in the returned instance.\n+     * Unsupported fields are ignored.\n+     * If the partial is null, then <code>this</code> is returned.\n+     *\n+     * @param partial  the partial set of fields to apply to this datetime, null ignored\n+     * @return a copy of this datetime with a different set of fields\n+     * @throws IllegalArgumentException if any value is invalid\n+     */\n+    public LocalDate withFields(ReadablePartial partial) {\n+        if (partial == null) {\n+            return this;\n+        }\n+        return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n+    }\n+\n+    /**\n+     * Gets a copy of this LocalDate with the specified field set to a new value.\n+     * <p>\n+     * For example, if the field type is <code>monthOfYear</code> then the\n+     * month of year field will be changed in the returned instance.\n+     * If the field type is null, then <code>this</code> is returned.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * LocalDate updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n+     * LocalDate updated = dt.dayOfMonth().withValue(6);\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this datetime with the field set\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public LocalDate withField(DateTimeFieldType fieldType, int value) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n+        if (isSupported(fieldType) == false) {\n+            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n+        }\n+        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Gets a copy of this LocalDate with the value of the specified field increased.\n+     * <p>\n+     * If the addition is zero or the field is null, then <code>this</code> is returned.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);\n+     * LocalDate added = dt.plusYears(6);\n+     * LocalDate added = dt.plus(Period.years(6));\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this datetime with the field updated\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n+        if (isSupported(fieldType) == false) {\n+            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n+        }\n+        if (amount == 0) {\n+            return this;\n+        }\n+        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this LocalDate with the specified period added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add multiple copies of complex\n+     * period instances. Adding one field is best achieved using methods\n+     * like {@link #withFieldAdded(DurationFieldType, int)}\n+     * or {@link #plusYears(int)}.\n+     * Unsupported fields are ignored.\n+     *\n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this datetime with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period == null || scalar == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().add(period, getLocalMillis(), scalar);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this LocalDate with the specified period added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add complex period instances.\n+     * Adding one field is best achieved using methods\n+     * like {@link #plusYears(int)}.\n+     * Unsupported fields are ignored.\n+     *\n+     * @param period  the duration to add to this one, null means zero\n+     * @return a copy of this LocalDate with the period added\n+     * @throws ArithmeticException if the new LocalDate exceeds the capacity of a long\n+     */\n+    public LocalDate plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new LocalDate plus the specified number of years.\n+     * <p>\n+     * This LocalDate instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDate added = dt.plusYears(6);\n+     * LocalDate added = dt.plus(Period.years(6));\n+     * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);\n+     * </pre>\n+     *\n+     * @param years  the amount of years to add, may be negative\n+     * @return the new LocalDate plus the increased years\n+     */\n+    public LocalDate plusYears(int years) {\n+        if (years == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().years().add(getLocalMillis(), years);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new LocalDate plus the specified number of months.\n+     * <p>\n+     * This LocalDate instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDate added = dt.plusMonths(6);\n+     * LocalDate added = dt.plus(Period.months(6));\n+     * LocalDate added = dt.withFieldAdded(DurationFieldType.months(), 6);\n+     * </pre>\n+     *\n+     * @param months  the amount of months to add, may be negative\n+     * @return the new LocalDate plus the increased months\n+     */\n+    public LocalDate plusMonths(int months) {\n+        if (months == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().months().add(getLocalMillis(), months);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new LocalDate plus the specified number of weeks.\n+     * <p>\n+     * This LocalDate instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDate added = dt.plusWeeks(6);\n+     * LocalDate added = dt.plus(Period.weeks(6));\n+     * LocalDate added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n+     * </pre>\n+     *\n+     * @param weeks  the amount of weeks to add, may be negative\n+     * @return the new LocalDate plus the increased weeks\n+     */\n+    public LocalDate plusWeeks(int weeks) {\n+        if (weeks == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().weeks().add(getLocalMillis(), weeks);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new LocalDate plus the specified number of days.\n+     * <p>\n+     * This LocalDate instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDate added = dt.plusDays(6);\n+     * LocalDate added = dt.plus(Period.days(6));\n+     * LocalDate added = dt.withFieldAdded(DurationFieldType.days(), 6);\n+     * </pre>\n+     *\n+     * @param days  the amount of days to add, may be negative\n+     * @return the new LocalDate plus the increased days\n+     */\n+    public LocalDate plusDays(int days) {\n+        if (days == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().days().add(getLocalMillis(), days);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this LocalDate with the specified period take away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to subtract complex period instances.\n+     * Subtracting one field is best achieved using methods\n+     * like {@link #minusYears(int)}.\n+     *\n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this LocalDate with the period taken away\n+     * @throws ArithmeticException if the new LocalDate exceeds the capacity of a long\n+     */\n+    public LocalDate minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new LocalDate minus the specified number of years.\n+     * <p>\n+     * This LocalDate instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDate subtracted = dt.minusYears(6);\n+     * LocalDate subtracted = dt.minus(Period.years(6));\n+     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n+     * </pre>\n+     *\n+     * @param years  the amount of years to subtract, may be negative\n+     * @return the new LocalDate minus the increased years\n+     */\n+    public LocalDate minusYears(int years) {\n+        if (years == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().years().subtract(getLocalMillis(), years);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new LocalDate minus the specified number of months.\n+     * <p>\n+     * This LocalDate instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDate subtracted = dt.minusMonths(6);\n+     * LocalDate subtracted = dt.minus(Period.months(6));\n+     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n+     * </pre>\n+     *\n+     * @param months  the amount of months to subtract, may be negative\n+     * @return the new LocalDate minus the increased months\n+     */\n+    public LocalDate minusMonths(int months) {\n+        if (months == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().months().subtract(getLocalMillis(), months);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new LocalDate minus the specified number of weeks.\n+     * <p>\n+     * This LocalDate instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDate subtracted = dt.minusWeeks(6);\n+     * LocalDate subtracted = dt.minus(Period.weeks(6));\n+     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n+     * </pre>\n+     *\n+     * @param weeks  the amount of weeks to subtract, may be negative\n+     * @return the new LocalDate minus the increased weeks\n+     */\n+    public LocalDate minusWeeks(int weeks) {\n+        if (weeks == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new LocalDate minus the specified number of days.\n+     * <p>\n+     * This LocalDate instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDate subtracted = dt.minusDays(6);\n+     * LocalDate subtracted = dt.minus(Period.days(6));\n+     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n+     * </pre>\n+     *\n+     * @param days  the amount of days to subtract, may be negative\n+     * @return the new LocalDate minus the increased days\n+     */\n+    public LocalDate minusDays(int days) {\n+        if (days == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().days().subtract(getLocalMillis(), days);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains many\n+     * useful methods.\n+     *\n+     * @param fieldType  the field type to get the chronology for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType fieldType) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n+        }\n+        if (isSupported(fieldType) == false) {\n+            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n+        }\n+        return new Property(this, fieldType.getField(getChronology()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the era field value.\n+     *\n+     * @return the era\n+     */\n+    public int getEra() {\n+        return getChronology().era().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the year of era field value.\n+     *\n+     * @return the year of era\n+     */\n+    public int getCenturyOfEra() {\n+        return getChronology().centuryOfEra().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the year of era field value.\n+     *\n+     * @return the year of era\n+     */\n+    public int getYearOfEra() {\n+        return getChronology().yearOfEra().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the year of century field value.\n+     *\n+     * @return the year of century\n+     */\n+    public int getYearOfCentury() {\n+        return getChronology().yearOfCentury().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the year field value.\n+     *\n+     * @return the year\n+     */\n+    public int getYear() {\n+        return getChronology().year().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the weekyear field value.\n+     *\n+     * @return the year of a week based year\n+     */\n+    public int getWeekyear() {\n+        return getChronology().weekyear().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the month of year field value.\n+     *\n+     * @return the month of year\n+     */\n+    public int getMonthOfYear() {\n+        return getChronology().monthOfYear().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the week of weekyear field value.\n+     *\n+     * @return the week of a week based year\n+     */\n+    public int getWeekOfWeekyear() {\n+        return getChronology().weekOfWeekyear().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the day of year field value.\n+     *\n+     * @return the day of year\n+     */\n+    public int getDayOfYear() {\n+        return getChronology().dayOfYear().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the day of month field value.\n+     * <p>\n+     * The values for the day of month are defined in {@link org.joda.time.DateTimeConstants}.\n+     *\n+     * @return the day of month\n+     */\n+    public int getDayOfMonth() {\n+        return getChronology().dayOfMonth().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the day of week field value.\n+     * <p>\n+     * The values for the day of week are defined in {@link org.joda.time.DateTimeConstants}.\n+     *\n+     * @return the day of week\n+     */\n+    public int getDayOfWeek() {\n+        return getChronology().dayOfWeek().get(getLocalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the era property.\n+     *\n+     * @return the era property\n+     */\n+    public Property era() {\n+        return new Property(this, getChronology().era());\n+    }\n+\n+    /**\n+     * Get the century of era property.\n+     *\n+     * @return the year of era property\n+     */\n+    public Property centuryOfEra() {\n+        return new Property(this, getChronology().centuryOfEra());\n+    }\n+\n+    /**\n+     * Get the year of century property.\n+     *\n+     * @return the year of era property\n+     */\n+    public Property yearOfCentury() {\n+        return new Property(this, getChronology().yearOfCentury());\n+    }\n+\n+    /**\n+     * Get the year of era property.\n+     *\n+     * @return the year of era property\n+     */\n+    public Property yearOfEra() {\n+        return new Property(this, getChronology().yearOfEra());\n+    }\n+\n+    /**\n+     * Get the year property.\n+     *\n+     * @return the year property\n+     */\n+    public Property year() {\n+        return new Property(this, getChronology().year());\n+    }\n+\n+    /**\n+     * Get the year of a week based year property.\n+     *\n+     * @return the year of a week based year property\n+     */\n+    public Property weekyear() {\n+        return new Property(this, getChronology().weekyear());\n+    }\n+\n+    /**\n+     * Get the month of year property.\n+     *\n+     * @return the month of year property\n+     */\n+    public Property monthOfYear() {\n+        return new Property(this, getChronology().monthOfYear());\n+    }\n+\n+    /**\n+     * Get the week of a week based year property.\n+     *\n+     * @return the week of a week based year property\n+     */\n+    public Property weekOfWeekyear() {\n+        return new Property(this, getChronology().weekOfWeekyear());\n+    }\n+\n+    /**\n+     * Get the day of year property.\n+     *\n+     * @return the day of year property\n+     */\n+    public Property dayOfYear() {\n+        return new Property(this, getChronology().dayOfYear());\n+    }\n+\n+    /**\n+     * Get the day of month property.\n+     *\n+     * @return the day of month property\n+     */\n+    public Property dayOfMonth() {\n+        return new Property(this, getChronology().dayOfMonth());\n+    }\n+\n+    /**\n+     * Get the day of week property.\n+     *\n+     * @return the day of week property\n+     */\n+    public Property dayOfWeek() {\n+        return new Property(this, getChronology().dayOfWeek());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the date time in ISO8601 format (yyyy-MM-dd).\n+     *\n+     * @return ISO8601 time formatted string.\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.date().print(this);\n+    }\n+\n+    /**\n+     * Output the date using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern) {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Output the date using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @param locale  Locale to use, null means default\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * LocalDate.Property binds a LocalDate to a DateTimeField allowing\n+     * powerful datetime functionality to be easily accessed.\n+     * <p>\n+     * The simplest use of this class is as an alternative get method, here used to\n+     * get the year '1972' (as an int) and the month 'December' (as a String).\n+     * <pre>\n+     * LocalDate dt = new LocalDate(1972, 12, 3, 0, 0);\n+     * int year = dt.year().get();\n+     * String monthStr = dt.month().getAsText();\n+     * </pre>\n+     * <p>\n+     * Methods are also provided that allow date modification. These return\n+     * new instances of LocalDate - they do not modify the original.\n+     * The example below yields two independent immutable date objects\n+     * 20 years apart.\n+     * <pre>\n+     * LocalDate dt = new LocalDate(1972, 12, 3);\n+     * LocalDate dt1920 = dt.year().withValue(1920);\n+     * <p>\n+     * LocalDate.Propery itself is thread-safe and immutable, as well as the\n+     * LocalDate being operated on.\n+     *\n+     * @author Stephen Colebourne\n+     * @author Brian S O'Neill\n+     * @since 1.3\n+     */\n+    public static final class Property extends AbstractReadableInstantFieldProperty {\n+        \n+        /** Serialization version */\n+        private static final long serialVersionUID = -3193829732634L;\n+        \n+        /** The instant this property is working against */\n+        private transient LocalDate iInstant;\n+        /** The field this property is working against */\n+        private transient DateTimeField iField;\n+        \n+        /**\n+         * Constructor.\n+         * \n+         * @param instant  the instant to set\n+         * @param field  the field to use\n+         */\n+        Property(LocalDate instant, DateTimeField field) {\n+            super();\n+            iInstant = instant;\n+            iField = field;\n+        }\n+        \n+        /**\n+         * Writes the property in a safe serialization format.\n+         */\n+        private void writeObject(ObjectOutputStream oos) throws IOException {\n+            oos.writeObject(iInstant);\n+            oos.writeObject(iField.getType());\n+        }\n+\n+        /**\n+         * Reads the property from a safe serialization format.\n+         */\n+        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n+            iInstant = (LocalDate) oos.readObject();\n+            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n+            iField = type.getField(iInstant.getChronology());\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Gets the field being used.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iField;\n+        }\n+        \n+        /**\n+         * Gets the milliseconds of the datetime that this property is linked to.\n+         * \n+         * @return the milliseconds\n+         */\n+        protected long getMillis() {\n+            return iInstant.getLocalMillis();\n+        }\n+        \n+        /**\n+         * Gets the LocalDate being used.\n+         * \n+         * @return the LocalDate\n+         */\n+        public LocalDate getLocalDate() {\n+            return iInstant;\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to this field in a copy of this LocalDate.\n+         * <p>\n+         * The LocalDate attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the LocalDate with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public LocalDate plus(int value) {\n+            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        /**\n+         * Adds to this field, possibly wrapped, in a copy of this LocalDate.\n+         * A wrapped operation only changes this field.\n+         * Thus 31st January plusWrapField one day goes to the 1st January.\n+         * <p>\n+         * The LocalDate attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the LocalDate with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public LocalDate plusWrapField(int value) {\n+            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the LocalDate.\n+         * <p>\n+         * The LocalDate attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the LocalDate with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public LocalDate withValue(int value) {\n+            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        /**\n+         * Sets this field in a copy of the LocalDate to a parsed text value.\n+         * <p>\n+         * The LocalDate attached to this property is unchanged by this call.\n+         *\n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the LocalDate with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public LocalDate withValue(String text, Locale locale) {\n+            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale));\n+        }\n+        \n+        /**\n+         * Sets this field in a copy of the LocalDate to a parsed text value.\n+         * <p>\n+         * The LocalDate attached to this property is unchanged by this call.\n+         *\n+         * @param text  the text value to set\n+         * @return a copy of the LocalDate with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public LocalDate withValue(String text) {\n+            return withValue(text, null);\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Returns a new LocalDate with this field set to the maximum value\n+         * for this field.\n+         * <p>\n+         * This operation is useful for obtaining a LocalDate on the last day\n+         * of the month, as month lengths vary.\n+         * <pre>\n+         * LocalDate lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n+         * </pre>\n+         * <p>\n+         * The LocalDate attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the LocalDate with this field set to its maximum\n+         */\n+        public LocalDate withMaximumValue() {\n+            return withValue(getMaximumValue());\n+        }\n+        \n+        /**\n+         * Returns a new LocalDate with this field set to the minimum value\n+         * for this field.\n+         * <p>\n+         * The LocalDate attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the LocalDate with this field set to its minimum\n+         */\n+        public LocalDate withMinimumValue() {\n+            return withValue(getMinimumValue());\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Rounds to the lowest whole unit of this field on a copy of this\n+         * LocalDate.\n+         * <p>\n+         * For example, rounding floor on the hourOfDay field of a LocalDate\n+         * where the time is 10:30 would result in new LocalDate with the\n+         * time of 10:00.\n+         *\n+         * @return a copy of the LocalDate with the field value changed\n+         */\n+        public LocalDate withRoundedFloor() {\n+            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the highest whole unit of this field on a copy of this\n+         * LocalDate.\n+         * <p>\n+         * For example, rounding floor on the hourOfDay field of a LocalDate\n+         * where the time is 10:30 would result in new LocalDate with the\n+         * time of 11:00.\n+         *\n+         * @return a copy of the LocalDate with the field value changed\n+         */\n+        public LocalDate withRoundedCeiling() {\n+            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this\n+         * LocalDate, favoring the floor if halfway.\n+         *\n+         * @return a copy of the LocalDate with the field value changed\n+         */\n+        public LocalDate withRoundedHalfFloor() {\n+            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this\n+         * LocalDate, favoring the ceiling if halfway.\n+         *\n+         * @return a copy of the LocalDate with the field value changed\n+         */\n+        public LocalDate withRoundedHalfCeiling() {\n+            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this\n+         * LocalDate.  If halfway, the ceiling is favored over the floor\n+         * only if it makes this field's value even.\n+         *\n+         * @return a copy of the LocalDate with the field value changed\n+         */\n+        public LocalDate withRoundedHalfEven() {\n+            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/LocalDateTime.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Locale;\n+\n+import org.joda.time.base.AbstractPartial;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.InstantConverter;\n+import org.joda.time.field.AbstractReadableInstantFieldProperty;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * LocalDateTime is an unmodifiable datetime class representing a\n+ * datetime without a time zone.\n+ * <p>\n+ * LocalDateTime implements the {@link ReadablePartial} interface.\n+ * To do this, certain methods focus on key fields Year, MonthOfYear,\n+ * DayOfYear, HourOfDay, MinuteOfHour, SecondOfMinute and MillisOfSecond.\n+ * However, <b>all</b> fields may in fact be queried.\n+ * <p>\n+ * Internally, LocalDateTime holds the datetime as milliseconds\n+ * from 1970-01-01T00:00:00. This represents the <i>local</i> millisecond\n+ * count which differs from the epoch-based millisecond value in a\n+ * <code>ReadableInstant</code> implementation by the amount of the zone offset.\n+ * <p>\n+ * Calculations on LocalDateTime are performed using a {@link Chronology}.\n+ * This chronology will be set internally to be in the UTC time zone\n+ * for all calculations.\n+ *\n+ * <p>Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getHourOfDay()</code>\n+ * <li><code>hourOfDay().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value\n+ * <li>text value\n+ * <li>short text value\n+ * <li>maximum/minimum values\n+ * <li>add/subtract\n+ * <li>set\n+ * <li>rounding\n+ * </ul>\n+ *\n+ * <p>\n+ * LocalDateTime is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public final class LocalDateTime\n+        extends AbstractPartial\n+        implements ReadablePartial, Serializable {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -268716875315837168L;\n+\n+    /** The index of the year field in the field array */\n+    private static final int YEAR = 0;\n+    /** The index of the dayOfYear field in the field array */\n+    private static final int DAY_OF_YEAR = 1;\n+    /** The index of the millis field in the field array */\n+    private static final int MILLIS_OF_DAY = 2;\n+\n+    /** The local millis from 1970-01-01T00:00:00 */\n+    private long iLocalMillis;\n+    /** The chronology to use in UTC */\n+    private Chronology iChronology;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the current local time evaluated using\n+     * ISO chronology in the default zone.\n+     * <p>\n+     * Once the constructor is completed, the zone is no longer used.\n+     */\n+    public static LocalDateTime nowDefaultZone() {\n+        return forInstant(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current local time evaluated using\n+     * ISO chronology in the specified zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public static LocalDateTime now(DateTimeZone zone) {\n+        return forInstant(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current local time evaluated using\n+     * specified chronology.\n+     * <p>\n+     * If the chronology is null, ISO chronology in the default time zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public static LocalDateTime now(Chronology chronology) {\n+        return forInstant(DateTimeUtils.currentTimeMillis(), chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n+     * This is useful if you have been using the Calendar as a local date,\n+     * ignoing the zone.\n+     * <p>\n+     * This factory method ignores the type of the calendar and always\n+     * creates a LocalDateTime with ISO chronology. It is expected that you\n+     * will only pass in instances of <code>GregorianCalendar</code> however\n+     * this is not validated.\n+     *\n+     * @param calendar  the Calendar to extract fields from\n+     * @return the created LocalDateTime\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n+     */\n+    public static LocalDateTime forFields(Calendar calendar) {\n+        if (calendar == null) {\n+            throw new IllegalArgumentException(\"The calendar must not be null\");\n+        }\n+        return new LocalDateTime(\n+            calendar.get(Calendar.YEAR),\n+            calendar.get(Calendar.MONTH) + 1,\n+            calendar.get(Calendar.DAY_OF_MONTH),\n+            calendar.get(Calendar.HOUR_OF_DAY),\n+            calendar.get(Calendar.MINUTE),\n+            calendar.get(Calendar.SECOND),\n+            calendar.get(Calendar.MILLISECOND)\n+        );\n+    }\n+\n+    /**\n+     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Date and assigned to the LocalDateTime.\n+     * This is useful if you have been using the Date as a local date,\n+     * ignoing the zone.\n+     * <p>\n+     * This factory method always creates a LocalDateTime with ISO chronology.\n+     *\n+     * @param date  the Date to extract fields from\n+     * @return the created LocalDateTime\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n+     */\n+    public static LocalDateTime forFields(Date date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return new LocalDateTime(\n+            date.getYear() + 1900,\n+            date.getMonth() + 1,\n+            date.getDate(),\n+            date.getHours(),\n+            date.getMinutes(),\n+            date.getSeconds(),\n+            (int) (date.getTime() % 1000)\n+        );\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using ISO chronology in the default zone.\n+     * <p>\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public static LocalDateTime forInstantDefaultZone(long instant) {\n+        return forInstant(instant, ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using ISO chronology in the specified zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public static LocalDateTime forInstant(long instant, DateTimeZone zone) {\n+        return forInstant(instant, ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using the specified chronology.\n+     * <p>\n+     * If the chronology is null, ISO chronology in the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public static LocalDateTime forInstant(long instant, Chronology chronology) {\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\n+        return new LocalDateTime(localMillis, chronology.withUTC());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from an Object that represents a datetime.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * If the object contains no time zone, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public static LocalDateTime forInstant(Object instant) {\n+        return forInstant(instant, (Chronology) null);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * forcing the time zone to that specified.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * If the specified time zone is null, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object\n+     * @param zone  the time zone\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public static LocalDateTime forInstant(Object instant, DateTimeZone zone) {\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        Chronology chrono = converter.getChronology(instant, zone);\n+        long millis = converter.getInstantMillis(instant, chrono);\n+        chrono = DateTimeUtils.getChronology(chrono);\n+        return forInstant(millis, chrono);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, ISO in the default time zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object\n+     * @param chronology  the chronology\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public static LocalDateTime forInstant(Object instant, Chronology chronology) {\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        Chronology chrono = DateTimeUtils.getChronology(converter.getChronology(instant, chronology));\n+        long millis = converter.getInstantMillis(instant, chronology);\n+        return forInstant(millis, chrono);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using the specified local (UTC) chronology.\n+     *\n+     * @param localMillis  the local milliseconds from 1970-01-01T00:00:00\n+     * @param chronology  the UTC chronology, not null\n+     */\n+    LocalDateTime(long localMillis, Chronology chronology) {\n+        super();\n+        iLocalMillis = localMillis;\n+        iChronology = chronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the specified date and time\n+     * using <code>ISOChronology</code>.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     */\n+    public LocalDateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour) {\n+        this(year, monthOfYear, dayOfMonth, hourOfDay,\n+            minuteOfHour, 0, 0, ISOChronology.getInstanceUTC());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the specified date and time\n+     * using <code>ISOChronology</code>.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     */\n+    public LocalDateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute) {\n+        this(year, monthOfYear, dayOfMonth, hourOfDay,\n+            minuteOfHour, secondOfMinute, 0, ISOChronology.getInstanceUTC());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the specified date and time\n+     * using <code>ISOChronology</code>.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     */\n+    public LocalDateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond) {\n+        this(year, monthOfYear, dayOfMonth, hourOfDay,\n+            minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstanceUTC());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the specified date and time\n+     * using the specified chronology, whose zone is ignored.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code> is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public LocalDateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond,\n+            Chronology chronology) {\n+        super();\n+        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n+        long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n+            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        iChronology = chronology;\n+        iLocalMillis = instant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial, which is three.\n+     * The supported fields are Year, DayOfYear and MillisOfDay.\n+     *\n+     * @return the field count, three\n+     */\n+    public int size() {\n+        return 3;\n+    }\n+\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * <p>\n+     * This method must not use any instance variables.\n+     *\n+     * @param index  the index to retrieve\n+     * @param chrono  the chronology to use\n+     * @return the field\n+     */\n+    protected DateTimeField getField(int index, Chronology chrono) {\n+        switch (index) {\n+            case YEAR:\n+                return chrono.year();\n+            case DAY_OF_YEAR:\n+                return chrono.dayOfYear();\n+            case MILLIS_OF_DAY:\n+                return chrono.millisOfDay();\n+            default:\n+                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n+    }\n+\n+    /**\n+     * Gets the value of the field at the specifed index.\n+     * <p>\n+     * This method is required to support the <code>ReadablePartial</code>\n+     * interface. The supported fields are Year, DayOfYear and MillisOfDay.\n+     *\n+     * @param index  the index, zero to two\n+     * @return the value\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public int getValue(int index) {\n+        switch (index) {\n+            case YEAR:\n+                return getChronology().year().get(getLocalMillis());\n+            case DAY_OF_YEAR:\n+                return getChronology().dayOfYear().get(getLocalMillis());\n+            case MILLIS_OF_DAY:\n+                return getChronology().millisOfDay().get(getLocalMillis());\n+            default:\n+                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value of one of the fields of a datetime.\n+     * <p>\n+     * This method gets the value of the specified field.\n+     * For example:\n+     * <pre>\n+     * DateTime dt = new DateTime();\n+     * int year = dt.get(DateTimeFieldType.year());\n+     * </pre>\n+     *\n+     * @param type  a field type, usually obtained from DateTimeFieldType, not null\n+     * @return the value of that field\n+     * @throws IllegalArgumentException if the field type is null\n+     */\n+    public int get(DateTimeFieldType type) {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n+        }\n+        return type.getField(getChronology()).get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Checks if the field type specified is supported by this\n+     * local datetime and chronology.\n+     * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.\n+     *\n+     * @param type  a field type, usually obtained from DateTimeFieldType\n+     * @return true if the field type is supported\n+     */\n+    public boolean isSupported(DateTimeFieldType type) {\n+        if (type == null) {\n+            return false;\n+        }\n+        return type.getField(getChronology()).isSupported();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the milliseconds of the datetime instant from the Java epoch\n+     * of 1970-01-01T00:00:00 (not fixed to any specific time zone).\n+     * \n+     * @return the number of milliseconds since 1970-01-01T00:00:00\n+     */\n+    long getLocalMillis() {\n+        return iLocalMillis;\n+    }\n+\n+    /**\n+     * Gets the chronology of the datetime.\n+     * \n+     * @return the Chronology that the datetime is using\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this object as a DateTime using the default zone.\n+     * \n+     * @return <code>this</code>\n+     */\n+    public DateTime toDateTimeDefaultZone() {\n+        return toDateTime((DateTimeZone) null);\n+    }\n+\n+    /**\n+     * Get this object as a DateTime using the specified zone.\n+     * \n+     * @param zone time zone to apply, or default if null\n+     * @return a DateTime using the same millis\n+     */\n+    public DateTime toDateTime(DateTimeZone zone) {\n+        zone = DateTimeUtils.getZone(zone);\n+        Chronology chrono = iChronology.withZone(zone);\n+        return new DateTime(getLocalMillis(), chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to a LocalDate with the same date and chronology.\n+     * \n+     * @return a LocalDate with the same date and chronology\n+     */\n+    public LocalDate getDate() {\n+        return new LocalDate(\n+                getYear(), getMonthOfYear(), getDayOfMonth(), getChronology());\n+    }\n+\n+//    /**\n+//     * Converts this object to a LocalTime with the same time and chronology.\n+//     * \n+//     * @return a LocalTime with the same time and chronology\n+//     */\n+//    public LocalTime getTime() {\n+//        return new LocalTime(\n+//                getHourOfDay(), getMinuteOfHour(),\n+//                getSecondOfMinute(), getMillisOfSecond(), getChronology());\n+//    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this datetime with different local millis.\n+     * <p>\n+     * The returned object will be a new instance of the same type.\n+     * Only the millis will change, the chronology is kept.\n+     * The returned object will be either be a new instance or <code>this</code>.\n+     *\n+     * @param newMillis  the new millis, from 1970-01-01T00:00:00\n+     * @return a copy of this datetime with different millis\n+     */\n+    LocalDateTime withLocalMillis(long newMillis) {\n+        return (newMillis == getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this datetime with the specified date, retaining the time fields.\n+     * <p>\n+     * If the date is already the date passed in, then <code>this</code> is returned.\n+     * <p>\n+     * To set a single field use the properties, for example:\n+     * <pre>\n+     * DateTime set = dt.monthOfYear().setCopy(6);\n+     * </pre>\n+     *\n+     * @param year  the new year value\n+     * @param monthOfYear  the new monthOfYear value\n+     * @param dayOfMonth  the new dayOfMonth value\n+     * @return a copy of this datetime with a different date\n+     * @throws IllegalArgumentException if any value if invalid\n+     */\n+    public LocalDateTime withDate(int year, int monthOfYear, int dayOfMonth) {\n+        Chronology chrono = getChronology();\n+        long instant = getLocalMillis();\n+        instant = chrono.year().set(instant, year);\n+        instant = chrono.monthOfYear().set(instant, monthOfYear);\n+        instant = chrono.dayOfMonth().set(instant, dayOfMonth);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Gets a copy of this datetime with the specified time, retaining the date fields.\n+     * <p>\n+     * If the time is already the time passed in, then <code>this</code> is returned.\n+     * <p>\n+     * To set a single field use the properties, for example:\n+     * <pre>\n+     * LocalDateTime set = dt.hourOfDay().setCopy(6);\n+     * </pre>\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @return a copy of this datetime with a different time\n+     * @throws IllegalArgumentException if any value if invalid\n+     */\n+    public LocalDateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n+        Chronology chrono = getChronology();\n+        long instant = getLocalMillis();\n+        instant = chrono.hourOfDay().set(instant, hourOfDay);\n+        instant = chrono.minuteOfHour().set(instant, minuteOfHour);\n+        instant = chrono.secondOfMinute().set(instant, secondOfMinute);\n+        instant = chrono.millisOfSecond().set(instant, millisOfSecond);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this datetime with the partial set of fields replacing those\n+     * from this instance.\n+     * <p>\n+     * For example, if the partial is a <code>TimeOfDay</code> then the time fields\n+     * would be changed in the returned instance.\n+     * If the partial is null, then <code>this</code> is returned.\n+     *\n+     * @param partial  the partial set of fields to apply to this datetime, null ignored\n+     * @return a copy of this datetime with a different set of fields\n+     * @throws IllegalArgumentException if any value is invalid\n+     */\n+    public LocalDateTime withFields(ReadablePartial partial) {\n+        if (partial == null) {\n+            return this;\n+        }\n+        return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n+    }\n+\n+    /**\n+     * Gets a copy of this datetime with the specified field set to a new value.\n+     * <p>\n+     * For example, if the field type is <code>hourOfDay</code> then the hour of day\n+     * field would be changed in the returned instance.\n+     * If the field type is null, then <code>this</code> is returned.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * LocalDateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n+     * LocalDateTime updated = dt.dayOfMonth().setCopy(6);\n+     * LocalDateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this datetime with the field set\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public LocalDateTime withField(DateTimeFieldType fieldType, int value) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n+        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Gets a copy of this datetime with the value of the specified field increased.\n+     * <p>\n+     * If the addition is zero or the field is null, then <code>this</code> is returned.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n+     * LocalDateTime added = dt.plusYears(6);\n+     * LocalDateTime added = dt.plus(Period.years(6));\n+     * </pre>\n+     * \n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this datetime with the field updated\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n+        if (amount == 0) {\n+            return this;\n+        }\n+        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this datetime with the specified duration added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * \n+     * @param durationToAdd  the duration to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this datetime with the duration added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public LocalDateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n+        if (durationToAdd == null || scalar == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().add(getLocalMillis(), durationToAdd.getMillis(), scalar);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Gets a copy of this datetime with the specified period added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add multiple copies of complex\n+     * period instances. Adding one field is best achieved using methods\n+     * like {@link #withFieldAdded(DurationFieldType, int)}\n+     * or {@link #plusYears(int)}.\n+     * \n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this datetime with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public LocalDateTime withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period == null || scalar == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().add(period, getLocalMillis(), scalar);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this datetime with the specified duration added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param duration  the duration to add to this one, null means zero\n+     * @return a copy of this datetime with the duration added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public LocalDateTime plus(ReadableDuration duration) {\n+        return withDurationAdded(duration, 1);\n+    }\n+\n+    /**\n+     * Gets a copy of this datetime with the specified period added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add complex period instances.\n+     * Adding one field is best achieved using methods\n+     * like {@link #plusYears(int)}.\n+     * \n+     * @param period  the duration to add to this one, null means zero\n+     * @return a copy of this datetime with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public LocalDateTime plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new datetime plus the specified number of years.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime added = dt.plusYears(6);\n+     * LocalDateTime added = dt.plus(Period.years(6));\n+     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n+     * </pre>\n+     *\n+     * @param years  the amount of years to add, may be negative\n+     * @return the new datetime plus the increased years\n+     */\n+    public LocalDateTime plusYears(int years) {\n+        if (years == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().years().add(getLocalMillis(), years);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new datetime plus the specified number of months.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime added = dt.plusMonths(6);\n+     * LocalDateTime added = dt.plus(Period.months(6));\n+     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.months(), 6);\n+     * </pre>\n+     *\n+     * @param months  the amount of months to add, may be negative\n+     * @return the new datetime plus the increased months\n+     */\n+    public LocalDateTime plusMonths(int months) {\n+        if (months == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().months().add(getLocalMillis(), months);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new datetime plus the specified number of weeks.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime added = dt.plusWeeks(6);\n+     * LocalDateTime added = dt.plus(Period.weeks(6));\n+     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n+     * </pre>\n+     *\n+     * @param weeks  the amount of weeks to add, may be negative\n+     * @return the new datetime plus the increased weeks\n+     */\n+    public LocalDateTime plusWeeks(int weeks) {\n+        if (weeks == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().weeks().add(getLocalMillis(), weeks);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new datetime plus the specified number of days.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime added = dt.plusDays(6);\n+     * LocalDateTime added = dt.plus(Period.days(6));\n+     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.days(), 6);\n+     * </pre>\n+     *\n+     * @param days  the amount of days to add, may be negative\n+     * @return the new datetime plus the increased days\n+     */\n+    public LocalDateTime plusDays(int days) {\n+        if (days == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().days().add(getLocalMillis(), days);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new datetime plus the specified number of hours.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime added = dt.plusHours(6);\n+     * LocalDateTime added = dt.plus(Period.hours(6));\n+     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n+     * </pre>\n+     *\n+     * @param hours  the amount of hours to add, may be negative\n+     * @return the new datetime plus the increased hours\n+     */\n+    public LocalDateTime plusHours(int hours) {\n+        if (hours == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().hours().add(getLocalMillis(), hours);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new datetime plus the specified number of minutes.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime added = dt.plusMinutes(6);\n+     * LocalDateTime added = dt.plus(Period.minutes(6));\n+     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);\n+     * </pre>\n+     *\n+     * @param minutes  the amount of minutes to add, may be negative\n+     * @return the new datetime plus the increased minutes\n+     */\n+    public LocalDateTime plusMinutes(int minutes) {\n+        if (minutes == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().minutes().add(getLocalMillis(), minutes);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new datetime plus the specified number of seconds.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime added = dt.plusSeconds(6);\n+     * LocalDateTime added = dt.plus(Period.seconds(6));\n+     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);\n+     * </pre>\n+     *\n+     * @param seconds  the amount of seconds to add, may be negative\n+     * @return the new datetime plus the increased seconds\n+     */\n+    public LocalDateTime plusSeconds(int seconds) {\n+        if (seconds == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().seconds().add(getLocalMillis(), seconds);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new datetime plus the specified number of millis.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime added = dt.plusMillis(6);\n+     * LocalDateTime added = dt.plus(Period.millis(6));\n+     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);\n+     * </pre>\n+     *\n+     * @param millis  the amount of millis to add, may be negative\n+     * @return the new datetime plus the increased millis\n+     */\n+    public LocalDateTime plusMillis(int millis) {\n+        if (millis == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().millis().add(getLocalMillis(), millis);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this datetime with the specified duration take away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param duration  the duration to reduce this instant by\n+     * @return a copy of this datetime with the duration taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public LocalDateTime minus(ReadableDuration duration) {\n+        return withDurationAdded(duration, -1);\n+    }\n+\n+    /**\n+     * Gets a copy of this datetime with the specified period take away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to subtract complex period instances.\n+     * Subtracting one field is best achieved using methods\n+     * like {@link #minusYears(int)}.\n+     * \n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this datetime with the period taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public LocalDateTime minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new datetime minus the specified number of years.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime subtracted = dt.minusYears(6);\n+     * LocalDateTime subtracted = dt.minus(Period.years(6));\n+     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n+     * </pre>\n+     *\n+     * @param years  the amount of years to subtract, may be negative\n+     * @return the new datetime minus the increased years\n+     */\n+    public LocalDateTime minusYears(int years) {\n+        if (years == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().years().subtract(getLocalMillis(), years);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new datetime minus the specified number of months.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime subtracted = dt.minusMonths(6);\n+     * LocalDateTime subtracted = dt.minus(Period.months(6));\n+     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n+     * </pre>\n+     *\n+     * @param months  the amount of months to subtract, may be negative\n+     * @return the new datetime minus the increased months\n+     */\n+    public LocalDateTime minusMonths(int months) {\n+        if (months == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().months().subtract(getLocalMillis(), months);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new datetime minus the specified number of weeks.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime subtracted = dt.minusWeeks(6);\n+     * LocalDateTime subtracted = dt.minus(Period.weeks(6));\n+     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n+     * </pre>\n+     *\n+     * @param weeks  the amount of weeks to subtract, may be negative\n+     * @return the new datetime minus the increased weeks\n+     */\n+    public LocalDateTime minusWeeks(int weeks) {\n+        if (weeks == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new datetime minus the specified number of days.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime subtracted = dt.minusDays(6);\n+     * LocalDateTime subtracted = dt.minus(Period.days(6));\n+     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n+     * </pre>\n+     *\n+     * @param days  the amount of days to subtract, may be negative\n+     * @return the new datetime minus the increased days\n+     */\n+    public LocalDateTime minusDays(int days) {\n+        if (days == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().days().subtract(getLocalMillis(), days);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new datetime minus the specified number of hours.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime subtracted = dt.minusHours(6);\n+     * LocalDateTime subtracted = dt.minus(Period.hours(6));\n+     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);\n+     * </pre>\n+     *\n+     * @param hours  the amount of hours to subtract, may be negative\n+     * @return the new datetime minus the increased hours\n+     */\n+    public LocalDateTime minusHours(int hours) {\n+        if (hours == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().hours().subtract(getLocalMillis(), hours);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new datetime minus the specified number of minutes.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime subtracted = dt.minusMinutes(6);\n+     * LocalDateTime subtracted = dt.minus(Period.minutes(6));\n+     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);\n+     * </pre>\n+     *\n+     * @param minutes  the amount of minutes to subtract, may be negative\n+     * @return the new datetime minus the increased minutes\n+     */\n+    public LocalDateTime minusMinutes(int minutes) {\n+        if (minutes == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().minutes().subtract(getLocalMillis(), minutes);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new datetime minus the specified number of seconds.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime subtracted = dt.minusSeconds(6);\n+     * LocalDateTime subtracted = dt.minus(Period.seconds(6));\n+     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);\n+     * </pre>\n+     *\n+     * @param seconds  the amount of seconds to subtract, may be negative\n+     * @return the new datetime minus the increased seconds\n+     */\n+    public LocalDateTime minusSeconds(int seconds) {\n+        if (seconds == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().seconds().subtract(getLocalMillis(), seconds);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new datetime minus the specified number of millis.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime subtracted = dt.minusMillis(6);\n+     * LocalDateTime subtracted = dt.minus(Period.millis(6));\n+     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);\n+     * </pre>\n+     *\n+     * @param millis  the amount of millis to subtract, may be negative\n+     * @return the new datetime minus the increased millis\n+     */\n+    public LocalDateTime minusMillis(int millis) {\n+        if (millis == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().millis().subtract(getLocalMillis(), millis);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains many useful methods.\n+     *\n+     * @param type  the field type to get the chronology for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType type) {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n+        }\n+        DateTimeField field = type.getField(getChronology());\n+        if (field.isSupported() == false) {\n+            throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\n+        }\n+        return new Property(this, field);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the era field value.\n+     * \n+     * @return the era\n+     */\n+    public int getEra() {\n+        return getChronology().era().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the year of era field value.\n+     * \n+     * @return the year of era\n+     */\n+    public int getCenturyOfEra() {\n+        return getChronology().centuryOfEra().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the year of era field value.\n+     * \n+     * @return the year of era\n+     */\n+    public int getYearOfEra() {\n+        return getChronology().yearOfEra().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the year of century field value.\n+     * \n+     * @return the year of century\n+     */\n+    public int getYearOfCentury() {\n+        return getChronology().yearOfCentury().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the year field value.\n+     * \n+     * @return the year\n+     */\n+    public int getYear() {\n+        return getChronology().year().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the weekyear field value.\n+     * \n+     * @return the year of a week based year\n+     */\n+    public int getWeekyear() {\n+        return getChronology().weekyear().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the month of year field value.\n+     * \n+     * @return the month of year\n+     */\n+    public int getMonthOfYear() {\n+        return getChronology().monthOfYear().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the week of weekyear field value.\n+     * \n+     * @return the week of a week based year\n+     */\n+    public int getWeekOfWeekyear() {\n+        return getChronology().weekOfWeekyear().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the day of year field value.\n+     * \n+     * @return the day of year\n+     */\n+    public int getDayOfYear() {\n+        return getChronology().dayOfYear().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the day of month field value.\n+     * <p>\n+     * The values for the day of month are defined in {@link org.joda.time.DateTimeConstants}.\n+     * \n+     * @return the day of month\n+     */\n+    public int getDayOfMonth() {\n+        return getChronology().dayOfMonth().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the day of week field value.\n+     * <p>\n+     * The values for the day of week are defined in {@link org.joda.time.DateTimeConstants}.\n+     * \n+     * @return the day of week\n+     */\n+    public int getDayOfWeek() {\n+        return getChronology().dayOfWeek().get(getLocalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day field value.\n+     *\n+     * @return the hour of day\n+     */\n+    public int getHourOfDay() {\n+        return getChronology().hourOfDay().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the minute of hour field value.\n+     *\n+     * @return the minute of hour\n+     */\n+    public int getMinuteOfHour() {\n+        return getChronology().minuteOfHour().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the second of minute field value.\n+     *\n+     * @return the second of minute\n+     */\n+    public int getSecondOfMinute() {\n+        return getChronology().secondOfMinute().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the millis of second field value.\n+     *\n+     * @return the millis of second\n+     */\n+    public int getMillisOfSecond() {\n+        return getChronology().millisOfSecond().get(getLocalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the era property.\n+     * \n+     * @return the era property\n+     */\n+    public Property era() {\n+        return new Property(this, getChronology().era());\n+    }\n+\n+    /**\n+     * Get the century of era property.\n+     * \n+     * @return the year of era property\n+     */\n+    public Property centuryOfEra() {\n+        return new Property(this, getChronology().centuryOfEra());\n+    }\n+\n+    /**\n+     * Get the year of century property.\n+     * \n+     * @return the year of era property\n+     */\n+    public Property yearOfCentury() {\n+        return new Property(this, getChronology().yearOfCentury());\n+    }\n+\n+    /**\n+     * Get the year of era property.\n+     * \n+     * @return the year of era property\n+     */\n+    public Property yearOfEra() {\n+        return new Property(this, getChronology().yearOfEra());\n+    }\n+\n+    /**\n+     * Get the year property.\n+     * \n+     * @return the year property\n+     */\n+    public Property year() {\n+        return new Property(this, getChronology().year());\n+    }\n+\n+    /**\n+     * Get the year of a week based year property.\n+     * \n+     * @return the year of a week based year property\n+     */\n+    public Property weekyear() {\n+        return new Property(this, getChronology().weekyear());\n+    }\n+\n+    /**\n+     * Get the month of year property.\n+     * \n+     * @return the month of year property\n+     */\n+    public Property monthOfYear() {\n+        return new Property(this, getChronology().monthOfYear());\n+    }\n+\n+    /**\n+     * Get the week of a week based year property.\n+     * \n+     * @return the week of a week based year property\n+     */\n+    public Property weekOfWeekyear() {\n+        return new Property(this, getChronology().weekOfWeekyear());\n+    }\n+\n+    /**\n+     * Get the day of year property.\n+     * \n+     * @return the day of year property\n+     */\n+    public Property dayOfYear() {\n+        return new Property(this, getChronology().dayOfYear());\n+    }\n+\n+    /**\n+     * Get the day of month property.\n+     * \n+     * @return the day of month property\n+     */\n+    public Property dayOfMonth() {\n+        return new Property(this, getChronology().dayOfMonth());\n+    }\n+\n+    /**\n+     * Get the day of week property.\n+     * \n+     * @return the day of week property\n+     */\n+    public Property dayOfWeek() {\n+        return new Property(this, getChronology().dayOfWeek());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day field property\n+     * \n+     * @return the hour of day property\n+     */\n+    public Property hourOfDay() {\n+        return new Property(this, getChronology().hourOfDay());\n+    }\n+\n+    /**\n+     * Get the minute of hour field property\n+     * \n+     * @return the minute of hour property\n+     */\n+    public Property minuteOfHour() {\n+        return new Property(this, getChronology().minuteOfHour());\n+    }\n+\n+    /**\n+     * Get the second of minute field property\n+     * \n+     * @return the second of minute property\n+     */\n+    public Property secondOfMinute() {\n+        return new Property(this, getChronology().secondOfMinute());\n+    }\n+\n+    /**\n+     * Get the millis of second property\n+     * \n+     * @return the millis of second property\n+     */\n+    public Property millisOfSecond() {\n+        return new Property(this, getChronology().millisOfSecond());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZ).\n+     * \n+     * @return ISO8601 time formatted string.\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.dateTime().print(this);\n+    }\n+\n+    /**\n+     * Output the date using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern) {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Output the date using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @param locale  Locale to use, null means default\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * LocalDateTime.Property binds a LocalDateTime to a DateTimeField allowing\n+     * powerful datetime functionality to be easily accessed.\n+     * <p>\n+     * The simplest use of this class is as an alternative get method, here used to\n+     * get the year '1972' (as an int) and the month 'December' (as a String).\n+     * <pre>\n+     * LocalDateTime dt = new LocalDateTime(1972, 12, 3, 0, 0);\n+     * int year = dt.year().get();\n+     * String monthStr = dt.month().getAsText();\n+     * </pre>\n+     * <p>\n+     * Methods are also provided that allow date modification. These return new instances\n+     * of DateTime - they do not modify the original. The example below yields two\n+     * independent immutable date objects 20 years apart.\n+     * <pre>\n+     * DateTime dt = new DateTime(1972, 12, 3, 0, 0, 0, 0);\n+     * DateTime dt1920 = dt.year().setCopy(1920);\n+     * <p>\n+     * LocalDateTime.Propery itself is thread-safe and immutable, as well as the\n+     * LocalDateTime being operated on.\n+     *\n+     * @author Stephen Colebourne\n+     * @author Brian S O'Neill\n+     * @since 1.2\n+     */\n+    public static final class Property extends AbstractReadableInstantFieldProperty {\n+        \n+        /** Serialization version */\n+        private static final long serialVersionUID = -358138762846288L;\n+        \n+        /** The instant this property is working against */\n+        private transient LocalDateTime iInstant;\n+        /** The field this property is working against */\n+        private transient DateTimeField iField;\n+        \n+        /**\n+         * Constructor.\n+         * \n+         * @param instant  the instant to set\n+         * @param field  the field to use\n+         */\n+        Property(LocalDateTime instant, DateTimeField field) {\n+            super();\n+            iInstant = instant;\n+            iField = field;\n+        }\n+        \n+        /**\n+         * Writes the property in a safe serialization format.\n+         */\n+        private void writeObject(ObjectOutputStream oos) throws IOException {\n+            oos.writeObject(iInstant);\n+            oos.writeObject(iField.getType());\n+        }\n+\n+        /**\n+         * Reads the property from a safe serialization format.\n+         */\n+        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n+            iInstant = (LocalDateTime) oos.readObject();\n+            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n+            iField = type.getField(iInstant.getChronology());\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Gets the field being used.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iField;\n+        }\n+        \n+        /**\n+         * Gets the milliseconds of the datetime that this property is linked to.\n+         * \n+         * @return the milliseconds\n+         */\n+        protected long getMillis() {\n+            return iInstant.getLocalMillis();\n+        }\n+        \n+        /**\n+         * Gets the datetime being used.\n+         * \n+         * @return the datetime\n+         */\n+        public LocalDateTime getLocalDateTime() {\n+            return iInstant;\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to this field in a copy of this LocalDateTime.\n+         * <p>\n+         * The LocalDateTime attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the LocalDateTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public LocalDateTime plus(int value) {\n+            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        /**\n+         * Adds to this field in a copy of this LocalDateTime.\n+         * <p>\n+         * The LocalDateTime attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the LocalDateTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public LocalDateTime plus(long value) {\n+            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        /**\n+         * Adds to this field, possibly wrapped, in a copy of this LocalDateTime.\n+         * A wrapped operation only changes this field.\n+         * Thus 31st January plusWrapField one day goes to the 1st January.\n+         * <p>\n+         * The LocalDateTime attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the LocalDateTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public LocalDateTime plusWrapField(int value) {\n+            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the LocalDateTime.\n+         * <p>\n+         * The LocalDateTime attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the LocalDateTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public LocalDateTime withValue(int value) {\n+            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        /**\n+         * Sets this field in a copy of the LocalDateTime to a parsed text value.\n+         * <p>\n+         * The LocalDateTime attached to this property is unchanged by this call.\n+         *\n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the LocalDateTime with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public LocalDateTime withValue(String text, Locale locale) {\n+            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale));\n+        }\n+        \n+        /**\n+         * Sets this field in a copy of the LocalDateTime to a parsed text value.\n+         * <p>\n+         * The LocalDateTime attached to this property is unchanged by this call.\n+         *\n+         * @param text  the text value to set\n+         * @return a copy of the LocalDateTime with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public LocalDateTime withValue(String text) {\n+            return withValue(text, null);\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Returns a new LocalDateTime with this field set to the maximum value\n+         * for this field.\n+         * <p>\n+         * This operation is useful for obtaining a LocalDateTime on the last day\n+         * of the month, as month lengths vary.\n+         * <pre>\n+         * LocalDateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n+         * </pre>\n+         * <p>\n+         * The LocalDateTime attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the LocalDateTime with this field set to its maximum\n+         */\n+        public LocalDateTime withMaximumValue() {\n+            return withValue(getMaximumValue());\n+        }\n+        \n+        /**\n+         * Returns a new LocalDateTime with this field set to the minimum value\n+         * for this field.\n+         * <p>\n+         * The LocalDateTime attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the LocalDateTime with this field set to its minimum\n+         */\n+        public LocalDateTime withMinimumValue() {\n+            return withValue(getMinimumValue());\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Rounds to the lowest whole unit of this field on a copy of this\n+         * LocalDateTime.\n+         * <p>\n+         * For example, rounding floor on the hourOfDay field of a LocalDateTime\n+         * where the time is 10:30 would result in new LocalDateTime with the\n+         * time of 10:00.\n+         *\n+         * @return a copy of the LocalDateTime with the field value changed\n+         */\n+        public LocalDateTime withRoundedFloor() {\n+            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the highest whole unit of this field on a copy of this\n+         * LocalDateTime.\n+         * <p>\n+         * For example, rounding floor on the hourOfDay field of a LocalDateTime\n+         * where the time is 10:30 would result in new LocalDateTime with the\n+         * time of 11:00.\n+         *\n+         * @return a copy of the LocalDateTime with the field value changed\n+         */\n+        public LocalDateTime withRoundedCeiling() {\n+            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this\n+         * LocalDateTime, favoring the floor if halfway.\n+         *\n+         * @return a copy of the LocalDateTime with the field value changed\n+         */\n+        public LocalDateTime withRoundedHalfFloor() {\n+            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this\n+         * LocalDateTime, favoring the ceiling if halfway.\n+         *\n+         * @return a copy of the LocalDateTime with the field value changed\n+         */\n+        public LocalDateTime withRoundedHalfCeiling() {\n+            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this\n+         * LocalDateTime.  If halfway, the ceiling is favored over the floor\n+         * only if it makes this field's value even.\n+         *\n+         * @return a copy of the LocalDateTime with the field value changed\n+         */\n+        public LocalDateTime withRoundedHalfEven() {\n+            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));\n+        }\n+    }\n+\n+}", "timestamp": 1136678933, "metainfo": ""}