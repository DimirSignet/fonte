{"sha": "b10e0031a3572dfd2783ec0b179a59b5532a4c1f", "log": "Change DurationType to PeriodType   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/AbstractDuration.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractDuration.java\n     /**\n      * Converts this duration to a TimePeriod instance using the All type.\n      * <p>\n-     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n      * <p>\n      * If the duration is small, less than one day, then this method will perform\n      * as you might expect and split the fields evenly. The situation is more complex\n      * @return a TimePeriod created using the millisecond duration from this instance\n      */\n     public final TimePeriod toTimePeriod() {\n-        return new TimePeriod(this, DurationType.getAllType());\n-    }\n-\n-    /**\n-     * Converts this duration to a TimePeriod instance specifying a duration type\n+        return new TimePeriod(this, PeriodType.getAllType());\n+    }\n+\n+    /**\n+     * Converts this duration to a TimePeriod instance specifying a period type\n      * to control how the duration is split into fields.\n      * <p>\n-     * The exact impact of this method is determined by the duration type.\n-     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * The exact impact of this method is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n      * <p>\n      * If the duration is small, less than one day, then this method will perform\n      * as you might expect and split the fields evenly. The situation is more complex\n      * for larger durations.\n      * <p>\n-     * If the duration type is PreciseAll then all fields can be set.\n+     * If the period type is PreciseAll then all fields can be set.\n      * For example, a duration equal to (365 + 60 + 5) days will be converted to\n      * 1 year, 2 months and 5 days using the PreciseAll type.\n      * <p>\n-     * If the duration type is All then the years and months fields will remain as zero,\n+     * If the period type is All then the years and months fields will remain as zero,\n      * with the duration allocated to the weeks and days fields.\n      * Normally, the weeks and days fields are imprecise, but this method\n      * calculates using the UTC time zone making weeks and days precise.\n      * For more control over the conversion process, you should convert the duration\n      * to an interval by referencing a fixed instant and then obtain the period.\n      * \n-     * @param type  the duration type determining how to split the duration into fields\n+     * @param type  the period type determining how to split the duration into fields\n      * @return a TimePeriod created using the millisecond duration from this instance\n      */\n-    public final TimePeriod toTimePeriod(DurationType type) {\n+    public final TimePeriod toTimePeriod(PeriodType type) {\n         return new TimePeriod(this, type);\n     }\n \n      * Gets the value as a String in the ISO8601 duration format.\n      * <p>\n      * For example, \"P6H3M7S\" represents 6 hours, 3 minutes, 7 seconds.\n-     * The field values are determined using the PreciseAll duration type.\n+     * The field values are determined using the PreciseAll period type.\n      *\n      * @return the value as an ISO8601 string\n      */\n--- a/JodaTime/src/java/org/joda/time/AbstractInterval.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractInterval.java\n     //-----------------------------------------------------------------------\n     /**\n      * Converts the duration of the interval to a time period using the\n-     * All duration type.\n+     * All period type.\n      * <p>\n      * This method should be used to exract the field values describing the\n      * difference between the start and end instants.\n \n     /**\n      * Converts the duration of the interval to a time period using the\n-     * specified duration type.\n+     * specified period type.\n      * <p>\n      * This method should be used to exract the field values describing the\n      * difference between the start and end instants.\n      * @param type  the requested type of the duration, null means AllType\n      * @return a time period derived from the interval\n      */\n-    public final TimePeriod toTimePeriod(DurationType type) {\n+    public final TimePeriod toTimePeriod(PeriodType type) {\n         return new TimePeriod(getStartMillis(), getEndMillis(), type);\n     }\n \n--- a/JodaTime/src/java/org/joda/time/AbstractTimePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractTimePeriod.java\n     /** Millis cache has been calculated and is valid */\n     private static final int STATE_CALCULATED = 2;\n \n-    /** The duration type that allocates the duration to fields */\n-    private final DurationType iType;\n+    /** The period type that allocates the duration to fields */\n+    private final PeriodType iType;\n     /** The object state */\n     private int iState;\n     /** The duration, if known */\n      * Creates a period from the given millisecond duration.\n      * <p>\n      * The millisecond duration will be split to fields using a UTC version of\n-     * the duration type.\n+     * the period type.\n      *\n      * @param duration  the duration, in milliseconds\n      * @param type  which set of fields this period supports\n-     * @throws IllegalArgumentException if duration type is invalid\n-     */\n-    public AbstractTimePeriod(long duration, DurationType type) {\n+     * @throws IllegalArgumentException if period type is invalid\n+     */\n+    public AbstractTimePeriod(long duration, PeriodType type) {\n         super();\n-        type = checkDurationType(type);\n+        type = checkPeriodType(type);\n         iType = type;\n         // Only call a private method\n         setTimePeriod(type, duration);\n      * @param seconds  amount of seconds in this period, which must be zero if unsupported\n      * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n      * @param type  which set of fields this period supports\n-     * @throws IllegalArgumentException if duration type is invalid\n+     * @throws IllegalArgumentException if period type is invalid\n      * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n     public AbstractTimePeriod(int years, int months, int weeks, int days,\n                             int hours, int minutes, int seconds, int millis,\n-                            DurationType type) {\n+                            PeriodType type) {\n         super();\n-        type = checkDurationType(type);\n+        type = checkPeriodType(type);\n         iType = type;\n         // Only call a private method\n         setTimePeriod(type, years, months, weeks, days, hours, minutes, seconds, millis);\n      * @param startInstant  interval start, in milliseconds\n      * @param endInstant  interval end, in milliseconds\n      * @param type  which set of fields this period supports\n-     * @throws IllegalArgumentException if duration type is invalid\n-     */\n-    public AbstractTimePeriod(long startInstant, long endInstant, DurationType type) {\n+     * @throws IllegalArgumentException if period type is invalid\n+     */\n+    public AbstractTimePeriod(long startInstant, long endInstant, PeriodType type) {\n         super();\n-        type = checkDurationType(type);\n+        type = checkPeriodType(type);\n         iType = type;\n         // Only call a private method\n         setTimePeriod(type, startInstant, endInstant);\n      * @param startInstant  interval start, null means now\n      * @param endInstant  interval end, null means now\n      * @param type  which set of fields this period supports\n-     * @throws IllegalArgumentException if duration type is invalid\n+     * @throws IllegalArgumentException if period type is invalid\n      */\n     public AbstractTimePeriod(\n-            ReadableInstant startInstant, ReadableInstant  endInstant, DurationType type) {\n+            ReadableInstant startInstant, ReadableInstant  endInstant, PeriodType type) {\n         super();\n-        type = checkDurationType(type);\n+        type = checkPeriodType(type);\n         if (startInstant == null && endInstant == null) {\n             iType = type;\n         } else {\n      * @throws IllegalArgumentException if period is invalid\n      * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n-    public AbstractTimePeriod(Object period, DurationType type) {\n+    public AbstractTimePeriod(Object period, PeriodType type) {\n         super();\n         TimePeriodConverter converter = ConverterManager.getInstance().getTimePeriodConverter(period);\n-        type = (type == null ? converter.getDurationType(period, false) : type);\n-        type = checkDurationType(type);\n+        type = (type == null ? converter.getPeriodType(period, false) : type);\n+        type = checkPeriodType(type);\n         iType = type;\n         if (this instanceof ReadWritableTimePeriod) {\n             converter.setInto((ReadWritableTimePeriod) this, period);\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Validates a duration type, converting nulls to a default value and\n+     * Validates a period type, converting nulls to a default value and\n      * checking the type is suitable for this instance.\n      * \n      * @param type  the type to check, may be null\n      * @return the validated type to use, not null\n-     * @throws IllegalArgumentException if the duration type is invalid\n-     */\n-    protected abstract DurationType checkDurationType(DurationType type);\n+     * @throws IllegalArgumentException if the period type is invalid\n+     */\n+    protected abstract PeriodType checkPeriodType(PeriodType type);\n \n     //-----------------------------------------------------------------------\n     /**\n      * Returns the object which defines which fields this period supports.\n      */\n-    public final DurationType getDurationType() {\n+    public final PeriodType getPeriodType() {\n         return iType;\n     }\n \n             return FieldUtils.safeAdd(instant, toDurationMillis() * scalar);\n         }\n         \n-        DurationType type = iType;\n+        PeriodType type = iType;\n         if (chrono != null) {\n             type = type.withChronology(chrono);\n         }\n             return false;\n         }\n         ReadableTimePeriod other = (ReadableTimePeriod) readablePeriod;\n-        DurationType type = getDurationType();\n-        if (type.equals(other.getDurationType()) == false) {\n+        PeriodType type = getPeriodType();\n+        if (type.equals(other.getPeriodType()) == false) {\n             return false;\n         }\n         return getYears() == other.getYears()\n      * @return a hash code\n      */\n     public final int hashCode() {\n-        int hash = getDurationType().hashCode();\n+        int hash = getPeriodType().hashCode();\n         hash = 53 * hash + getYears();\n         hash = 53 * hash + getMonths();\n         hash = 53 * hash + getWeeks();\n     /**\n      * This method is private to prevent subclasses from overriding.\n      */\n-    private void setTimePeriod(DurationType type, ReadableTimePeriod period) {\n+    private void setTimePeriod(PeriodType type, ReadableTimePeriod period) {\n         setTimePeriod(type,\n             period.getYears(), period.getMonths(),\n             period.getWeeks(), period.getDays(),\n     /**\n      * This method is private to prevent subclasses from overriding.\n      */\n-    private void setTimePeriod(DurationType type,\n+    private void setTimePeriod(PeriodType type,\n                              int years, int months, int weeks, int days,\n                              int hours, int minutes, int seconds, int millis) {\n         if (years != 0) {\n      * @param startInstant  interval start, in milliseconds\n      * @param endInstant  interval end, in milliseconds\n      */\n-    private void setTimePeriod(DurationType type, long startInstant, long endInstant) {\n+    private void setTimePeriod(PeriodType type, long startInstant, long endInstant) {\n         long baseTotalMillis = (endInstant - startInstant);\n         int years = 0, months = 0, weeks = 0, days = 0;\n         int hours = 0, minutes = 0, seconds = 0, millis = 0;\n      *\n      * @param duration  the duration, in milliseconds\n      */\n-    private void setTimePeriod(DurationType type, long duration) {\n+    private void setTimePeriod(PeriodType type, long duration) {\n         if (duration == 0) {\n             iDuration = duration;\n             iYears = 0;\n \n     /**\n      * Sets all the fields in one go from an interval dividing the\n-     * fields using the duration type.\n+     * fields using the period type.\n      * \n      * @param interval  the interval to set, null means zero length\n      */\n \n     /**\n      * Sets all the fields in one go from a duration dividing the\n-     * fields using the duration type.\n+     * fields using the period type.\n      * \n      * @param duration  the duration to set, null means zero length\n      */\n      * @throws ArithmeticException if the millis exceeds the capacity of the period\n      */\n     private int updateTotalMillis() {\n-        final DurationType type = iType;\n+        final PeriodType type = iType;\n \n         boolean isPrecise = true;\n         long totalMillis = 0;\n      */\n     protected void add(ReadableInterval interval) {\n         if (interval != null) {\n-            add(interval.toTimePeriod(getDurationType()));\n+            add(interval.toTimePeriod(getPeriodType()));\n         }\n     }\n \n      */\n     protected void add(ReadableDuration duration) {\n         if (duration != null) {\n-            add(new TimePeriod(duration.getMillis(), getDurationType()));\n+            add(new TimePeriod(duration.getMillis(), getPeriodType()));\n         }\n     }\n \n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n      */\n     protected void add(long duration) {\n-        add(new TimePeriod(duration, getDurationType()));\n+        add(new TimePeriod(duration, getPeriodType()));\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/MutableTimePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/MutableTimePeriod.java\n     }\n \n     /**\n-     * Creates a zero-length period using the specified duration type.\n+     * Creates a zero-length period using the specified period type.\n      *\n      * @param type  which set of fields this period supports\n      */\n-    public MutableTimePeriod(DurationType type) {\n+    public MutableTimePeriod(PeriodType type) {\n         super(0L, type);\n     }\n \n     /**\n      * Creates a period from the given millisecond duration using AllType.\n      * <p>\n-     * The exact impact of this constructor is determined by the duration type.\n-     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * The exact impact of this constructor is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n      * <p>\n      * If the duration is small, less than one day, then this method will perform\n      * as you might expect and split the fields evenly. The situation is more complex\n      * for larger durations.\n      * <p>\n-     * If this period uses the PreciseAll duration type then all fields can be set.\n+     * If this period uses the PreciseAll period type then all fields can be set.\n      * For example, a duration equal to (365 + 60 + 5) days will be converted to\n      * 1 year, 2 months and 5 days using the PreciseAll type.\n      * <p>\n-     * If the period uses the All duration type then the years and months fields\n+     * If the period uses the All period type then the years and months fields\n      * will remain as zero, with the duration allocated to the weeks field.\n      * Normally, the weeks and days fields are imprecise, but this method\n      * calculates using the UTC time zone making weeks and days precise.\n     /**\n      * Creates a period from the given millisecond duration.\n      * <p>\n-     * The exact impact of this constructor is determined by the duration type.\n-     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * The exact impact of this constructor is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n      * <p>\n      * If the duration is small, less than one day, then this method will perform\n      * as you might expect and split the fields evenly. The situation is more complex\n      * for larger durations.\n      * <p>\n-     * If this period uses the PreciseAll duration type then all fields can be set.\n+     * If this period uses the PreciseAll period type then all fields can be set.\n      * For example, a duration equal to (365 + 60 + 5) days will be converted to\n      * 1 year, 2 months and 5 days using the PreciseAll type.\n      * <p>\n-     * If the period uses the All duration type then the years and months fields\n+     * If the period uses the All period type then the years and months fields\n      * will remain as zero, with the duration allocated to the weeks field.\n      * Normally, the weeks and days fields are imprecise, but this method\n      * calculates using the UTC time zone making weeks and days precise.\n      * @param duration  the duration, in milliseconds\n      * @param type  which set of fields this duration supports\n      */\n-    public MutableTimePeriod(long duration, DurationType type) {\n+    public MutableTimePeriod(long duration, PeriodType type) {\n         super(duration, type);\n     }\n \n      * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n     public MutableTimePeriod(int years, int months, int weeks, int days,\n-                    int hours, int minutes, int seconds, int millis, DurationType type) {\n+                    int hours, int minutes, int seconds, int millis, PeriodType type) {\n         super(years, months, weeks, days, hours, minutes, seconds, millis, type);\n     }\n \n      * @param endInstant  interval end, in milliseconds\n      * @param type  which set of fields this period supports, null means AllType\n      */\n-    public MutableTimePeriod(long startInstant, long endInstant, DurationType type) {\n+    public MutableTimePeriod(long startInstant, long endInstant, PeriodType type) {\n         super(startInstant, endInstant, type);\n     }\n \n      * @param endInstant  interval end, null means now\n      * @param type  which set of fields this period supports, null means AllType\n      */\n-    public MutableTimePeriod(ReadableInstant startInstant, ReadableInstant endInstant, DurationType type) {\n+    public MutableTimePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {\n         super(startInstant, endInstant, type);\n     }\n \n      * @throws IllegalArgumentException if period is invalid\n      * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n      */\n-    public MutableTimePeriod(Object period, DurationType type) {\n+    public MutableTimePeriod(Object period, PeriodType type) {\n         super(period, type);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Validates a duration type, converting nulls to a default value and\n+     * Validates a period type, converting nulls to a default value and\n      * checking the type is suitable for this instance.\n      * \n      * @param type  the type to check, may be null\n      * @return the validated type to use, not null\n-     * @throws IllegalArgumentException if the duration type is not precise\n-     */\n-    protected DurationType checkDurationType(DurationType type) {\n+     * @throws IllegalArgumentException if the period type is not precise\n+     */\n+    protected PeriodType checkPeriodType(PeriodType type) {\n         if (type == null) {\n-            return DurationType.getAllType();\n+            return PeriodType.getAllType();\n         }\n         return type;\n     }\n \n     /**\n      * Sets all the fields in one go from an interval dividing the\n-     * fields using the duration type.\n+     * fields using the period type.\n      * \n      * @param interval  the interval to set, null means zero length\n      */\n \n     /**\n      * Sets all the fields in one go from a millisecond interval dividing the\n-     * fields using the duration type.\n+     * fields using the period type.\n      * \n      * @param startInstant  interval start, in milliseconds\n      * @param endInstant  interval end, in milliseconds\n \n     /**\n      * Sets all the fields in one go from a duration dividing the\n-     * fields using the duration type.\n-     * <p>\n-     * The exact impact of this method is determined by the duration type.\n-     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * fields using the period type.\n+     * <p>\n+     * The exact impact of this method is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n      * <p>\n      * If the duration is small, less than one day, then this method will perform\n      * as you might expect and split the fields evenly. The situation is more complex\n      * for larger durations.\n      * <p>\n-     * If this period uses the PreciseAll duration type then all fields can be set.\n+     * If this period uses the PreciseAll period type then all fields can be set.\n      * For example, a duration equal to (365 + 60 + 5) days will be converted to\n      * 1 year, 2 months and 5 days using the PreciseAll type.\n      * <p>\n-     * If the period uses the All duration type then the years and months fields\n+     * If the period uses the All period type then the years and months fields\n      * will remain as zero, with the duration allocated to the weeks field.\n      * Normally, the weeks and days fields are imprecise, but this method\n      * calculates using the UTC time zone making weeks and days precise.\n \n     /**\n      * Sets all the fields in one go from a millisecond duration dividing the\n-     * fields using the duration type.\n-     * <p>\n-     * The exact impact of this method is determined by the duration type.\n-     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * fields using the period type.\n+     * <p>\n+     * The exact impact of this method is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n      * <p>\n      * If the duration is small, less than one day, then this method will perform\n      * as you might expect and split the fields evenly. The situation is more complex\n      * for larger durations.\n      * <p>\n-     * If this period uses the PreciseAll duration type then all fields can be set.\n+     * If this period uses the PreciseAll period type then all fields can be set.\n      * For example, a duration equal to (365 + 60 + 5) days will be converted to\n      * 1 year, 2 months and 5 days using the PreciseAll type.\n      * <p>\n-     * If the period uses the All duration type then the years and months fields\n+     * If the period uses the All period type then the years and months fields\n      * will remain as zero, with the duration allocated to the weeks field.\n      * Normally, the weeks and days fields are imprecise, but this method\n      * calculates using the UTC time zone making weeks and days precise.\n \n     /**\n      * Adds an interval to this one by converting it to a period using the same\n-     * duration type and then adding each field in turn.\n+     * period type and then adding each field in turn.\n      * \n      * @param interval  the interval to add, null means add nothing\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n      * Adds a duration to this one by dividing the duration into\n      * fields and then adding each field in turn.\n      * <p>\n-     * The exact impact of this method is determined by the duration type.\n-     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * The exact impact of this method is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n      * <p>\n      * If the duration is small, less than one day, then this method will perform\n      * as you might expect and split the fields evenly. The situation is more complex\n      * for larger durations.\n      * <p>\n-     * If this period uses the PreciseAll duration type then all fields can be set.\n+     * If this period uses the PreciseAll period type then all fields can be set.\n      * For example, a duration equal to (365 + 60 + 5) days will be converted to\n      * 1 year, 2 months and 5 days using the PreciseAll type.\n      * <p>\n-     * If the period uses the All duration type then the years and months fields\n+     * If the period uses the All period type then the years and months fields\n      * will remain as zero, with the duration allocated to the weeks field.\n      * Normally, the weeks and days fields are imprecise, but this method\n      * calculates using the UTC time zone making weeks and days precise.\n      * Adds a duration to this one by dividing the duration into\n      * fields and then adding each field in turn.\n      * <p>\n-     * The exact impact of this method is determined by the duration type.\n-     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * The exact impact of this method is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n      * <p>\n      * If the duration is small, less than one day, then this method will perform\n      * as you might expect and split the fields evenly. The situation is more complex\n      * for larger durations.\n      * <p>\n-     * If this period uses the PreciseAll duration type then all fields can be set.\n+     * If this period uses the PreciseAll period type then all fields can be set.\n      * For example, a duration equal to (365 + 60 + 5) days will be converted to\n      * 1 year, 2 months and 5 days using the PreciseAll type.\n      * <p>\n-     * If the period uses the All duration type then the years and months fields\n+     * If the period uses the All period type then the years and months fields\n      * will remain as zero, with the duration allocated to the weeks field.\n      * Normally, the weeks and days fields are imprecise, but this method\n      * calculates using the UTC time zone making weeks and days precise.\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/PeriodType.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.field.MillisDurationField;\n+import org.joda.time.field.ScaledDurationField;\n+import org.joda.time.field.UnsupportedDurationField;\n+\n+/**\n+ * Controls a duration implementation by specifying which duration fields are to be used.\n+ * <p>\n+ * The following implementations are provided:\n+ * <ul>\n+ * <li>Millis - the duration is defined only in terms of milliseconds, other\n+ *  fields are not used\n+ * <li>All - the duration is defined to permit all fields to be used\n+ * <li>DayHour - the duration is expressed in terms of days, hours, minutes, seconds\n+ *  and milliseconds\n+ * <li>YearMonth - the duration is expressed using all fields except weeks\n+ * <li>YearWeek - the duration is expressed using all fields except months\n+ * <li>AverageYearMonth - as YearMonth, but years and months have fixed average lengths\n+ * <li>PreciseAll - defines years as 365 days, months as 30 days, weeks as 7 days,\n+ * days as 24 hours and all the time fields\n+ * <li>PreciseDayHour - defines days as 24 hours and all the time fields\n+ * <li>PreciseYearDay - defines years as 365 days, days as 24 hours and all the time fields\n+ * <li>PreciseYearWeek - defines years as 365 days, weeks as 7 days,\n+ * days as 24 hours and all the time fields\n+ * <li>PreciseYearMonth - defines years as 365 days, months as 30 days,\n+ * days as 24 hours and all the time fields\n+ * </ul>\n+ *\n+ * <p>\n+ * PeriodType is thread-safe and immutable, and all subclasses must be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class PeriodType implements Serializable {\n+    private static final long serialVersionUID = 2274324892792009998L;\n+\n+    private static final PeriodType DAY_HOUR_TYPE;\n+    private static final PeriodType YEAR_WEEK_TYPE;\n+    private static final PeriodType YEAR_MONTH_TYPE;\n+    private static final PeriodType ALL_TYPE;\n+    private static final PeriodType MILLIS_TYPE;\n+    private static final PeriodType PRECISE_DAY_HOUR_TYPE;\n+    private static final PeriodType PRECISE_YEAR_DAY_TYPE;\n+    private static final PeriodType PRECISE_YEAR_WEEK_TYPE;\n+    private static final PeriodType PRECISE_YEAR_MONTH_TYPE;\n+    private static final PeriodType PRECISE_ALL_TYPE;\n+\n+    static {\n+        DAY_HOUR_TYPE = new DayHourType(ISOChronology.getInstance());\n+        YEAR_WEEK_TYPE = new YearWeekType(ISOChronology.getInstance());\n+        YEAR_MONTH_TYPE = new YearMonthType(ISOChronology.getInstance());\n+        ALL_TYPE = new AllType(ISOChronology.getInstance());\n+        MILLIS_TYPE = new MillisType();\n+        PRECISE_DAY_HOUR_TYPE = new PreciseDayHourType(ISOChronology.getInstanceUTC());\n+        PRECISE_YEAR_DAY_TYPE = new PreciseYearDayType(ISOChronology.getInstanceUTC());\n+        PRECISE_YEAR_WEEK_TYPE = new PreciseYearWeekType(ISOChronology.getInstanceUTC());\n+        PRECISE_YEAR_MONTH_TYPE = new PreciseYearMonthType(ISOChronology.getInstanceUTC());\n+        PRECISE_ALL_TYPE = new PreciseAllType(ISOChronology.getInstanceUTC());\n+    }\n+\n+    /**\n+     * Returns a PeriodType of only a milliseconds field using the ISOChronology.\n+     * When using this type, the maximum millisecond value that can be stored is\n+     * typically limited by a 32 bit int.\n+     */\n+    public static PeriodType getMillisType() {\n+        return MILLIS_TYPE;\n+    }\n+\n+    /**\n+     * Returns a PeriodType using the ISOChronology in current time zone of:\n+     *\n+     * <ul>\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     */\n+    public static PeriodType getDayHourType() {\n+        return DAY_HOUR_TYPE;\n+    }\n+\n+    /**\n+     * Returns a PeriodType of:\n+     *\n+     * <ul>\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     *\n+     * This factory method returns a PeriodType that calculates using any\n+     * Chronology. For best results, the Chronology's time zone should\n+     * be UTC or have fixed offsets.\n+     *\n+     * @param chrono Chronology to use for calculations.\n+     */\n+    public static PeriodType getDayHourType(Chronology chrono) {\n+        if (chrono == null || chrono.equals(ISOChronology.getInstance())) {\n+            return getDayHourType();\n+        }\n+        return new DayHourType(chrono);\n+    }\n+\n+    /**\n+     * Returns a PeriodType using the ISOChronology in current time zone of:\n+     *\n+     * <ul>\n+     * <li>years\n+     * <li>months\n+     * <li>weeks\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     */\n+    public static PeriodType getAllType() {\n+        return ALL_TYPE;\n+    }\n+\n+    /**\n+     * Returns a PeriodType of:\n+     *\n+     * <ul>\n+     * <li>years\n+     * <li>months\n+     * <li>weeks\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     *\n+     * This factory method returns a PeriodType that calculates using any\n+     * Chronology. For best results, the Chronology's time zone should\n+     * be UTC or have fixed offsets.\n+     *\n+     * @param chrono Chronology to use for calculations.\n+     */\n+    public static PeriodType getAllType(Chronology chrono) {\n+        if (chrono == null || chrono.equals(ISOChronology.getInstance())) {\n+            return getAllType();\n+        }\n+        return new AllType(chrono);\n+    }\n+\n+    /**\n+     * Returns a PeriodType using the ISOChronology in current time zone of:\n+     *\n+     * <ul>\n+     * <li>years\n+     * <li>months\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     */\n+    public static PeriodType getYearMonthType() {\n+        return YEAR_MONTH_TYPE;\n+    }\n+\n+    /**\n+     * Returns a PeriodType of:\n+     *\n+     * <ul>\n+     * <li>years\n+     * <li>months\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     *\n+     * This factory method returns a PeriodType that calculates using any\n+     * Chronology. For best results, the Chronology's time zone should\n+     * be UTC or have fixed offsets.\n+     *\n+     * @param chrono Chronology to use for calculations.\n+     */\n+    public static PeriodType getYearMonthType(Chronology chrono) {\n+        if (chrono == null || chrono.equals(ISOChronology.getInstance())) {\n+            return getYearMonthType();\n+        }\n+        return new YearMonthType(chrono);\n+    }\n+\n+    /**\n+     * Returns a PeriodType using the ISOChronology in current time zone of:\n+     *\n+     * <ul>\n+     * <li>years (weekyears)\n+     * <li>weeks\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     */\n+    public static PeriodType getYearWeekType() {\n+        return YEAR_WEEK_TYPE;\n+    }\n+\n+    /**\n+     * Returns a PeriodType of:\n+     *\n+     * <ul>\n+     * <li>years (weekyears)\n+     * <li>weeks\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     *\n+     * This factory method returns a PeriodType that calculates using any\n+     * Chronology. For best results, the Chronology's time zone should\n+     * be UTC or have fixed offsets.\n+     *\n+     * @param chrono Chronology to use for calculations.\n+     */\n+    public static PeriodType getYearWeekType(Chronology chrono) {\n+        if (chrono == null || chrono.equals(ISOChronology.getInstance())) {\n+            return getYearWeekType();\n+        }\n+        return new YearWeekType(chrono);\n+    }\n+\n+    /**\n+     * Returns a precise PeriodType using the ISOChronology in UTC of:\n+     *\n+     * <ul>\n+     * <li>days (fixed at 24 hours)\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     */\n+    public static PeriodType getPreciseDayHourType() {\n+        return PRECISE_DAY_HOUR_TYPE;\n+    }\n+\n+    /**\n+     * Returns a precise PeriodType using the ISOChronology in UTC of:\n+     *\n+     * <ul>\n+     * <li>years (fixed at 365 days)\n+     * <li>days (fixed at 24 hours)\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     */\n+    public static PeriodType getPreciseYearDayType() {\n+        return PRECISE_YEAR_DAY_TYPE;\n+    }\n+\n+    /**\n+     * Returns a precise PeriodType using the ISOChronology in UTC of:\n+     *\n+     * <ul>\n+     * <li>years (fixed at 365 days)\n+     * <li>months (fixed at 30 days)\n+     * <li>weeks (fixed at 7 days)\n+     * <li>days (fixed at 24 hours)\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     */\n+    public static PeriodType getPreciseAllType() {\n+        return PRECISE_ALL_TYPE;\n+    }\n+\n+    /**\n+     * Returns a precise PeriodType using the ISOChronology in UTC of:\n+     *\n+     * <ul>\n+     * <li>years (fixed at 365 days)\n+     * <li>months (fixed at 30 days)\n+     * <li>days (fixed at 24 hours)\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     */\n+    public static PeriodType getPreciseYearMonthType() {\n+        return PRECISE_YEAR_MONTH_TYPE;\n+    }\n+\n+    /**\n+     * Returns a precise PeriodType using the ISOChronology in UTC of:\n+     *\n+     * <ul>\n+     * <li>years (fixed at 365 days)\n+     * <li>weeks (fixed at 7 days)\n+     * <li>days (fixed at 24 hours)\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     */\n+    public static PeriodType getPreciseYearWeekType() {\n+        return PRECISE_YEAR_WEEK_TYPE;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     */\n+    protected PeriodType() {\n+    }\n+\n+    /**\n+     * Gets the name of the period type.\n+     * \n+     * @return the name\n+     */\n+    public abstract String getName();\n+\n+    /**\n+     * Returns the chronology used, or null if none.\n+     * \n+     * @return the chronology\n+     */\n+    public abstract Chronology getChronology();\n+\n+    /**\n+     * Returns a PeriodType that uses the given chronology.\n+     * \n+     * @param chrono  the new chronology, null means ISOChronology in UTC\n+     * @return a new period type with the specified chronology\n+     */\n+    public abstract PeriodType withChronology(Chronology chrono);\n+\n+    /**\n+     * Returns true if every supported field in this type is precise.\n+     * \n+     * @return true if precise\n+     */\n+    public abstract boolean isPrecise();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a DurationField representing years.\n+     *\n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField years() {\n+        return UnsupportedDurationField.getInstance(\"years\");\n+    }\n+\n+    /**\n+     * Returns a DurationField representing months.\n+     *\n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField months() {\n+        return UnsupportedDurationField.getInstance(\"months\");\n+    }\n+\n+    /**\n+     * Returns a DurationField representing weeks.\n+     *\n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField weeks() {\n+        return UnsupportedDurationField.getInstance(\"weeks\");\n+    }\n+\n+    /**\n+     * Returns a DurationField representing days.\n+     *\n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField days() {\n+        return UnsupportedDurationField.getInstance(\"days\");\n+    }\n+\n+    /**\n+     * Returns a DurationField representing hours.\n+     *\n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField hours() {\n+        return UnsupportedDurationField.getInstance(\"hours\");\n+    }\n+\n+    /**\n+     * Returns a DurationField representing minutes.\n+     *\n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField minutes() {\n+        return UnsupportedDurationField.getInstance(\"minutes\");\n+    }\n+\n+    /**\n+     * Returns a DurationField representing seconds.\n+     *\n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField seconds() {\n+        return UnsupportedDurationField.getInstance(\"seconds\");\n+    }\n+\n+    /**\n+     * Returns a DurationField representing milliseconds.\n+     *\n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField millis() {\n+        return UnsupportedDurationField.getInstance(\"millis\");\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a version of this PeriodType instance that does not support years.\n+     * \n+     * @return a new period type that supports the original set of fields except years\n+     */\n+    public PeriodType withYearsRemoved() {\n+        if (!years().isSupported()) {\n+            return this;\n+        }\n+        return MaskedType.mask(this, 1 << 0);\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support months.\n+     * \n+     * @return a new period type that supports the original set of fields except months\n+     */\n+    public PeriodType withMonthsRemoved() {\n+        if (!months().isSupported()) {\n+            return this;\n+        }\n+        return MaskedType.mask(this, 1 << 1);\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support weeks.\n+     * \n+     * @return a new period type that supports the original set of fields except weeks\n+     */\n+    public PeriodType withWeeksRemoved() {\n+        if (!weeks().isSupported()) {\n+            return this;\n+        }\n+        return MaskedType.mask(this, 1 << 2);\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support days.\n+     * \n+     * @return a new period type that supports the original set of fields except days\n+     */\n+    public PeriodType withDaysRemoved() {\n+        if (!days().isSupported()) {\n+            return this;\n+        }\n+        return MaskedType.mask(this, 1 << 3);\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support hours.\n+     * \n+     * @return a new period type that supports the original set of fields except hours\n+     */\n+    public PeriodType withHoursRemoved() {\n+        if (!hours().isSupported()) {\n+            return this;\n+        }\n+        return MaskedType.mask(this, 1 << 4);\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support minutes.\n+     * \n+     * @return a new period type that supports the original set of fields except minutes\n+     */\n+    public PeriodType withMinutesRemoved() {\n+        if (!minutes().isSupported()) {\n+            return this;\n+        }\n+        return MaskedType.mask(this, 1 << 5);\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support seconds.\n+     * \n+     * @return a new period type that supports the original set of fields except seconds\n+     */\n+    public PeriodType withSecondsRemoved() {\n+        if (!seconds().isSupported()) {\n+            return this;\n+        }\n+        return MaskedType.mask(this, 1 << 6);\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support milliseconds.\n+     * \n+     * @return a new period type that supports the original set of fields except milliseconds\n+     */\n+    public PeriodType withMillisRemoved() {\n+        if (!millis().isSupported()) {\n+            return this;\n+        }\n+        return MaskedType.mask(this, 1 << 7);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this type to another object.\n+     * To be equal, the object must be a PeriodType with the same chronology\n+     * and same supported fields.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (!(obj instanceof PeriodType)) {\n+            return false;\n+        }\n+        PeriodType other = (PeriodType)obj;\n+        Chronology chrono = getChronology();\n+        if (chrono == null) {\n+            if (other.getChronology() != null) {\n+                return false;\n+            }\n+        } else if (!chrono.equals(other.getChronology())) {\n+            return false;\n+        }\n+        return years().equals(other.years())\n+            && months().equals(other.months())\n+            && weeks().equals(other.weeks())\n+            && days().equals(other.days())\n+            && hours().equals(other.hours())\n+            && minutes().equals(other.minutes())\n+            && seconds().equals(other.seconds())\n+            && millis().equals(other.millis());\n+    }\n+\n+    /**\n+     * Returns a hashcode based on the chronology and supported fields.\n+     * \n+     * @return a suitable hashcode\n+     */\n+    public int hashCode() {\n+        int hash = 0;\n+        Chronology chrono = getChronology();\n+        if (chrono != null) {\n+            hash += chrono.hashCode();\n+        }\n+        hash = hash\n+            + years().hashCode()\n+            + months().hashCode()\n+            + weeks().hashCode()\n+            + days().hashCode()\n+            + hours().hashCode()\n+            + minutes().hashCode()\n+            + seconds().hashCode()\n+            + millis().hashCode();\n+        return hash;\n+    }\n+    \n+    public String toString() {\n+        String name = getName();\n+        return \"PeriodType[\" + (name == null ? \"\" : name) + \"]\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private static class MillisType extends PeriodType {\n+        private static final long serialVersionUID = -4314867016852780422L;\n+\n+        MillisType() {\n+        }\n+\n+        public boolean isPrecise() {\n+            return true;\n+        }\n+\n+        public final DurationField millis() {\n+            return MillisDurationField.INSTANCE;\n+        }\n+\n+        public Chronology getChronology() {\n+            return ISOChronology.getInstanceUTC();\n+        }\n+\n+        public PeriodType withChronology(Chronology chrono) {\n+            return this;\n+        }\n+\n+        private Object readResolve() {\n+            return getMillisType();\n+        }\n+        \n+        public String getName() {\n+            return \"MillisType\";\n+        }\n+    }\n+\n+    private static class DayHourType extends PeriodType {\n+        private static final long serialVersionUID = 1115025839896760481L;\n+\n+        protected final Chronology iChronology;\n+\n+        DayHourType(Chronology chrono) {\n+            iChronology = chrono;\n+        }\n+\n+        public final Chronology getChronology() {\n+            return iChronology;\n+        }\n+\n+        public PeriodType withChronology(Chronology chrono) {\n+            if (chrono == iChronology) {\n+                return this;\n+            }\n+            return PeriodType.getDayHourType(chrono);\n+        }\n+\n+        public boolean isPrecise() {\n+            return days().isPrecise()\n+                && hours().isPrecise()\n+                && minutes().isPrecise()\n+                && seconds().isPrecise()\n+                && minutes().isPrecise();\n+        }\n+\n+        public final DurationField days() {\n+            return iChronology.days();\n+        }\n+\n+        public final DurationField hours() {\n+            return iChronology.hours();\n+        }\n+\n+        public final DurationField minutes() {\n+            return iChronology.minutes();\n+        }\n+\n+        public final DurationField seconds() {\n+            return iChronology.seconds();\n+        }\n+\n+        public final DurationField millis() {\n+            return iChronology.millis();\n+        }\n+\n+        private Object readResolve() {\n+            return getDayHourType(iChronology);\n+        }\n+        \n+        public String getName() {\n+            return \"DayHourType\";\n+        }\n+    }\n+\n+    private static class YearWeekType extends DayHourType {\n+        private static final long serialVersionUID = 1347170237843447098L;\n+\n+        YearWeekType(Chronology chrono) {\n+            super(chrono);\n+        }\n+\n+        public PeriodType withChronology(Chronology chrono) {\n+            if (chrono == iChronology) {\n+                return this;\n+            }\n+            return PeriodType.getYearWeekType(chrono);\n+        }\n+\n+        public boolean isPrecise() {\n+            return years().isPrecise()\n+                && weeks().isPrecise()\n+                && super.isPrecise();\n+        }\n+\n+        public DurationField years() {\n+            return iChronology.weekyears();\n+        }\n+\n+        public DurationField weeks() {\n+            return iChronology.weeks();\n+        }\n+\n+        private Object readResolve() {\n+            return getYearWeekType(iChronology);\n+        }\n+        \n+        public String getName() {\n+            return \"YearWeekType\";\n+        }\n+    }\n+\n+    private static class YearMonthType extends DayHourType {\n+        private static final long serialVersionUID = -1336767257680877683L;\n+\n+        YearMonthType(Chronology chrono) {\n+            super(chrono);\n+        }\n+\n+        public PeriodType withChronology(Chronology chrono) {\n+            if (chrono == iChronology) {\n+                return this;\n+            }\n+            return PeriodType.getYearMonthType(chrono);\n+        }\n+\n+        public boolean isPrecise() {\n+            return years().isPrecise()\n+                && months().isPrecise()\n+                && super.isPrecise();\n+        }\n+\n+        public DurationField years() {\n+            return iChronology.years();\n+        }\n+\n+        public DurationField months() {\n+            return iChronology.months();\n+        }\n+\n+        private Object readResolve() {\n+            return getYearMonthType(iChronology);\n+        }\n+        \n+        public String getName() {\n+            return \"YearMonthType\";\n+        }\n+    }\n+\n+    private static class AllType extends DayHourType {\n+        private static final long serialVersionUID = -359769822629866L;\n+\n+        AllType(Chronology chrono) {\n+            super(chrono);\n+        }\n+\n+        public PeriodType withChronology(Chronology chrono) {\n+            if (chrono == iChronology) {\n+                return this;\n+            }\n+            return PeriodType.getAllType(chrono);\n+        }\n+\n+        public boolean isPrecise() {\n+            return years().isPrecise()\n+                && months().isPrecise()\n+                && weeks().isPrecise()\n+                && super.isPrecise();\n+        }\n+\n+        public DurationField years() {\n+            return iChronology.years();\n+        }\n+\n+        public DurationField months() {\n+            return iChronology.months();\n+        }\n+\n+        public DurationField weeks() {\n+            return iChronology.weeks();\n+        }\n+\n+        private Object readResolve() {\n+            return getAllType(iChronology);\n+        }\n+        \n+        public String getName() {\n+            return \"AllType\";\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private static class PreciseDayHourType extends PeriodType {\n+        private static final long serialVersionUID = 216528691637527857L;\n+\n+        protected final Chronology iChronology;\n+\n+        PreciseDayHourType(Chronology chrono) {\n+            iChronology = chrono;\n+        }\n+\n+        public final Chronology getChronology() {\n+            return iChronology;\n+        }\n+\n+        public PeriodType withChronology(Chronology chrono) {\n+            return this;\n+        }\n+\n+        public boolean isPrecise() {\n+            return true;\n+        }\n+\n+        public final DurationField days() {\n+            return iChronology.days();\n+        }\n+\n+        public final DurationField hours() {\n+            return iChronology.hours();\n+        }\n+\n+        public final DurationField minutes() {\n+            return iChronology.minutes();\n+        }\n+\n+        public final DurationField seconds() {\n+            return iChronology.seconds();\n+        }\n+\n+        public final DurationField millis() {\n+            return iChronology.millis();\n+        }\n+\n+        private Object readResolve() {\n+            return getPreciseDayHourType();\n+        }\n+        \n+        public String getName() {\n+            return \"PreciseDayHourType\";\n+        }\n+    }\n+\n+    private static class PreciseYearDayType extends PreciseDayHourType {\n+        private static final long serialVersionUID = -2553285612358L;\n+\n+        private final DurationField iYears;\n+        \n+        PreciseYearDayType(Chronology chrono) {\n+            super(chrono);\n+            iYears = new ScaledDurationField(chrono.days(), \"PreciseYears\", 365);\n+            // rely on days/weeks to be precise because only ISO UTC used\n+        }\n+\n+        public PeriodType withChronology(Chronology chrono) {\n+            return this;\n+        }\n+\n+        public boolean isPrecise() {\n+            return years().isPrecise()\n+                && super.isPrecise();\n+        }\n+\n+        public DurationField years() {\n+            return iYears;\n+        }\n+\n+        private Object readResolve() {\n+            return getPreciseYearDayType();\n+        }\n+        \n+        public String getName() {\n+            return \"PreciseYearDayType\";\n+        }\n+    }\n+\n+    private static class PreciseYearWeekType extends PreciseYearDayType {\n+        private static final long serialVersionUID = -2040324323318740267L;\n+\n+        PreciseYearWeekType(Chronology chrono) {\n+            super(chrono);\n+        }\n+\n+        public PeriodType withChronology(Chronology chrono) {\n+            return this;\n+        }\n+\n+        public boolean isPrecise() {\n+            return weeks().isPrecise()\n+                && super.isPrecise();\n+        }\n+\n+        public DurationField weeks() {\n+            return iChronology.weeks();\n+        }\n+\n+        private Object readResolve() {\n+            return getPreciseYearWeekType();\n+        }\n+        \n+        public String getName() {\n+            return \"PreciseYearWeekType\";\n+        }\n+    }\n+\n+    private static class PreciseYearMonthType extends PreciseYearDayType {\n+        private static final long serialVersionUID = 1203161678926193794L;\n+\n+        private final DurationField iMonths;\n+        \n+        PreciseYearMonthType(Chronology chrono) {\n+            super(chrono);\n+            iMonths = new ScaledDurationField(chrono.days(), \"PreciseMonths\", 30);\n+        }\n+\n+        public PeriodType withChronology(Chronology chrono) {\n+            return this;\n+        }\n+\n+        public boolean isPrecise() {\n+            return months().isPrecise()\n+                && super.isPrecise();\n+        }\n+\n+        public DurationField months() {\n+            return iMonths;\n+        }\n+\n+        private Object readResolve() {\n+            return getPreciseYearMonthType();\n+        }\n+        \n+        public String getName() {\n+            return \"PreciseYearMonthType\";\n+        }\n+    }\n+\n+    private static class PreciseAllType extends PreciseYearMonthType {\n+        private static final long serialVersionUID = 43967269280186L;\n+\n+        PreciseAllType(Chronology chrono) {\n+            super(chrono);\n+        }\n+\n+        public PeriodType withChronology(Chronology chrono) {\n+            return this;\n+        }\n+\n+        public boolean isPrecise() {\n+            return weeks().isPrecise()\n+                && super.isPrecise();\n+        }\n+\n+        public DurationField weeks() {\n+            return iChronology.weeks();\n+        }\n+\n+        private Object readResolve() {\n+            return getPreciseAllType();\n+        }\n+        \n+        public String getName() {\n+            return \"PreciseAllType\";\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private static class MaskedType extends PeriodType {\n+        private static final long serialVersionUID = 940106774669244586L;\n+\n+        public static PeriodType mask(PeriodType type, int mask) {\n+            if (type instanceof MaskedType) {\n+                MaskedType masked = (MaskedType)type;\n+                mask |= masked.iMask;\n+                type = masked.iType;\n+            }\n+            return new MaskedType(type, mask);\n+        }\n+\n+        private final PeriodType iType;\n+\n+        // Bit 0: when set, years is unsupported\n+        // Bit 1: when set, months is unsupported\n+        // ...\n+        private final int iMask;\n+\n+        private MaskedType(PeriodType type, int mask) {\n+            iType = type;\n+            iMask = mask;\n+        }\n+\n+        public Chronology getChronology() {\n+            return iType.getChronology();\n+        }\n+\n+        public PeriodType withChronology(Chronology chrono) {\n+            if (chrono == getChronology()) {\n+                return this;\n+            }\n+            return MaskedType.mask(iType.withChronology(chrono), iMask);\n+        }\n+\n+        public boolean isPrecise() {\n+            return years().isPrecise()\n+                && months().isPrecise()\n+                && weeks().isPrecise()\n+                && days().isPrecise()\n+                && hours().isPrecise()\n+                && minutes().isPrecise()\n+                && seconds().isPrecise()\n+                && minutes().isPrecise();\n+        }\n+\n+        public DurationField years() {\n+            if ((iMask & (1 << 0)) != 0) {\n+                return UnsupportedDurationField.getInstance(\"years\");\n+            }\n+            return iType.years();\n+        }\n+\n+        public DurationField months() {\n+            if ((iMask & (1 << 1)) != 0) {\n+                return UnsupportedDurationField.getInstance(\"months\");\n+            }\n+            return iType.months();\n+        }\n+\n+        public DurationField weeks() {\n+            if ((iMask & (1 << 2)) != 0) {\n+                return UnsupportedDurationField.getInstance(\"weeks\");\n+            }\n+            return iType.weeks();\n+        }\n+\n+        public DurationField days() {\n+            if ((iMask & (1 << 3)) != 0) {\n+                return UnsupportedDurationField.getInstance(\"days\");\n+            }\n+            return iType.days();\n+        }\n+\n+        public DurationField hours() {\n+            if ((iMask & (1 << 4)) != 0) {\n+                return UnsupportedDurationField.getInstance(\"hours\");\n+            }\n+            return iType.hours();\n+        }\n+\n+        public DurationField minutes() {\n+            if ((iMask & (1 << 5)) != 0) {\n+                return UnsupportedDurationField.getInstance(\"minutes\");\n+            }\n+            return iType.minutes();\n+        }\n+\n+        public DurationField seconds() {\n+            if ((iMask & (1 << 6)) != 0) {\n+                return UnsupportedDurationField.getInstance(\"seconds\");\n+            }\n+            return iType.seconds();\n+        }\n+\n+        public DurationField millis() {\n+            if ((iMask & (1 << 7)) != 0) {\n+                return UnsupportedDurationField.getInstance(\"millis\");\n+            }\n+            return iType.millis();\n+        }\n+        \n+        public String getName() {\n+            String name = iType.getName();\n+            String maskStr = \"\";\n+            if ((iMask & (1 << 0)) != 0) {\n+                maskStr += \"Years\";\n+            }\n+            if ((iMask & (1 << 1)) != 0) {\n+                maskStr += \"Months\";\n+            }\n+            if ((iMask & (1 << 2)) != 0) {\n+                maskStr += \"Weeks\";\n+            }\n+            if ((iMask & (1 << 3)) != 0) {\n+                maskStr += \"Days\";\n+            }\n+            if ((iMask & (1 << 4)) != 0) {\n+                maskStr += \"Hours\";\n+            }\n+            if ((iMask & (1 << 5)) != 0) {\n+                maskStr += \"Minutes\";\n+            }\n+            if ((iMask & (1 << 6)) != 0) {\n+                maskStr += \"Seconds\";\n+            }\n+            if ((iMask & (1 << 7)) != 0) {\n+                maskStr += \"Millis\";\n+            }\n+            return \"Masked\" + maskStr + \"[\" + (name == null ? \"\" : name) + \"]\";\n+        }\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/ReadWritableTimePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/ReadWritableTimePeriod.java\n \n     /**\n      * Sets all the fields in one go from an interval dividing the\n-     * fields using the duration type.\n+     * fields using the period type.\n      * \n      * @param interval  the interval to set, null means zero length\n      */\n \n     /**\n      * Sets all the fields in one go from a millisecond interval dividing the\n-     * fields using the duration type.\n+     * fields using the period type.\n      * \n      * @param startInstant  interval start, in milliseconds\n      * @param endInstant  interval end, in milliseconds\n \n     /**\n      * Sets all the fields in one go from a duration dividing the\n-     * fields using the duration type.\n-     * <p>\n-     * The exact impact of this method is determined by the duration type.\n-     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * fields using the period type.\n+     * <p>\n+     * The exact impact of this method is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n      * <p>\n      * If the duration is small, less than one day, then this method will perform\n      * as you might expect and split the fields evenly. The situation is more complex\n      * for larger durations.\n      * <p>\n-     * If this period uses the PreciseAll duration type then all fields can be set.\n+     * If this period uses the PreciseAll period type then all fields can be set.\n      * For example, a duration equal to (365 + 60 + 5) days will be converted to\n      * 1 year, 2 months and 5 days using the PreciseAll type.\n      * <p>\n-     * If the period uses the All duration type then the years and months fields\n+     * If the period uses the All period type then the years and months fields\n      * will remain as zero, with the duration allocated to the weeks field.\n      * Normally, the weeks and days fields are imprecise, but this method\n      * calculates using the UTC time zone making weeks and days precise.\n \n     /**\n      * Sets all the fields in one go from a millisecond duration dividing the\n-     * fields using the duration type.\n-     * <p>\n-     * The exact impact of this method is determined by the duration type.\n-     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * fields using the period type.\n+     * <p>\n+     * The exact impact of this method is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n      * <p>\n      * If the duration is small, less than one day, then this method will perform\n      * as you might expect and split the fields evenly. The situation is more complex\n      * for larger durations.\n      * <p>\n-     * If this period uses the PreciseAll duration type then all fields can be set.\n+     * If this period uses the PreciseAll period type then all fields can be set.\n      * For example, a duration equal to (365 + 60 + 5) days will be converted to\n      * 1 year, 2 months and 5 days using the PreciseAll type.\n      * <p>\n-     * If the period uses the All duration type then the years and months fields\n+     * If the period uses the All period type then the years and months fields\n      * will remain as zero, with the duration allocated to the weeks field.\n      * Normally, the weeks and days fields are imprecise, but this method\n      * calculates using the UTC time zone making weeks and days precise.\n      * Adds a duration to this one by dividing the duration into\n      * fields and then adding each field in turn.\n      * <p>\n-     * The exact impact of this method is determined by the duration type.\n-     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * The exact impact of this method is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n      * <p>\n      * If the duration is small, less than one day, then this method will perform\n      * as you might expect and split the fields evenly. The situation is more complex\n      * for larger durations.\n      * <p>\n-     * If this period uses the PreciseAll duration type then all fields can be set.\n+     * If this period uses the PreciseAll period type then all fields can be set.\n      * For example, a duration equal to (365 + 60 + 5) days will be converted to\n      * 1 year, 2 months and 5 days using the PreciseAll type.\n      * <p>\n-     * If the period uses the All duration type then the years and months fields\n+     * If the period uses the All period type then the years and months fields\n      * will remain as zero, with the duration allocated to the weeks field.\n      * Normally, the weeks and days fields are imprecise, but this method\n      * calculates using the UTC time zone making weeks and days precise.\n      * Adds a duration to this one by dividing the duration into\n      * fields and then adding each field in turn.\n      * <p>\n-     * The exact impact of this method is determined by the duration type.\n-     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * The exact impact of this method is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n      * <p>\n      * If the duration is small, less than one day, then this method will perform\n      * as you might expect and split the fields evenly. The situation is more complex\n      * for larger durations.\n      * <p>\n-     * If this period uses the PreciseAll duration type then all fields can be set.\n+     * If this period uses the PreciseAll period type then all fields can be set.\n      * For example, a duration equal to (365 + 60 + 5) days will be converted to\n      * 1 year, 2 months and 5 days using the PreciseAll type.\n      * <p>\n-     * If the period uses the All duration type then the years and months fields\n+     * If the period uses the All period type then the years and months fields\n      * will remain as zero, with the duration allocated to the weeks field.\n      * Normally, the weeks and days fields are imprecise, but this method\n      * calculates using the UTC time zone making weeks and days precise.\n--- a/JodaTime/src/java/org/joda/time/ReadableDuration.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableDuration.java\n     /**\n      * Converts this duration to a TimePeriod instance using the All type.\n      * <p>\n-     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n      * <p>\n      * If the duration is small, less than one day, then this method will perform\n      * as you might expect and split the fields evenly. The situation is more complex\n     TimePeriod toTimePeriod();\n \n     /**\n-     * Converts this duration to a TimePeriod instance specifying a duration type\n+     * Converts this duration to a TimePeriod instance specifying a period type\n      * to control how the duration is split into fields.\n      * <p>\n-     * The exact impact of this method is determined by the duration type.\n-     * Only precise fields in the duration type will be used and the calculation will use UTC.\n+     * The exact impact of this method is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n      * <p>\n      * If the duration is small, less than one day, then this method will perform\n      * as you might expect and split the fields evenly. The situation is more complex\n      * for larger durations.\n      * <p>\n-     * If the duration type is PreciseAll then all fields can be set.\n+     * If the period type is PreciseAll then all fields can be set.\n      * For example, a duration equal to (365 + 60 + 5) days will be converted to\n      * 1 year, 2 months and 5 days using the PreciseAll type.\n      * <p>\n-     * If the duration type is All then the years and months fields will remain as zero,\n+     * If the period type is All then the years and months fields will remain as zero,\n      * with the duration allocated to the weeks and days fields.\n      * The effect is that a large duration of several years or months will be converted\n      * to a period including a large number of weeks and zero years and months.\n      * For more control over the conversion process, you should convert the duration\n      * to an interval by referencing a fixed instant and then obtain the period.\n      * \n-     * @param type  the duration type determining how to split the duration into fields\n+     * @param type  the period type determining how to split the duration into fields\n      * @return a TimePeriod created using the millisecond duration from this instance\n      */\n-    TimePeriod toTimePeriod(DurationType type);\n+    TimePeriod toTimePeriod(PeriodType type);\n \n     //-----------------------------------------------------------------------\n     /**\n      * Gets the value as a String in the ISO8601 duration format.\n      * <p>\n      * For example, \"P6H3M7S\" represents 6 hours, 3 minutes, 7 seconds.\n-     * The field values are determined using the PreciseAll duration type.\n+     * The field values are determined using the PreciseAll period type.\n      *\n      * @return the value as an ISO8601 string\n      */\n--- a/JodaTime/src/java/org/joda/time/ReadableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableInterval.java\n     //-----------------------------------------------------------------------\n     /**\n      * Converts the duration of the interval to a time period using the\n-     * All duration type.\n+     * All period type.\n      * <p>\n      * This method should be used to exract the field values describing the\n      * difference between the start and end instants.\n \n     /**\n      * Converts the duration of the interval to a time period using the\n-     * specified duration type.\n+     * specified period type.\n      * <p>\n      * This method should be used to exract the field values describing the\n      * difference between the start and end instants.\n      * @param type  the requested type of the duration, null means AllType\n      * @return a time period derived from the interval\n      */\n-    TimePeriod toTimePeriod(DurationType type);\n+    TimePeriod toTimePeriod(PeriodType type);\n \n     //-----------------------------------------------------------------------\n     /**\n--- a/JodaTime/src/java/org/joda/time/ReadableTimePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableTimePeriod.java\n  * Time periods are split up into multiple fields, for example days and seconds.\n  * Implementations are not required to evenly distribute the values across the fields.\n  * The value for each field may be positive or negative.\n- * The {@link DurationType} defines the rules for dividing the fields and which fields\n+ * The {@link PeriodType} defines the rules for dividing the fields and which fields\n  * are supported. Unsupported fields always have a value of zero.\n  * <p>\n  * When a time period is added to an instant, the effect is to add each field in turn.\n public interface ReadableTimePeriod {\n \n     /**\n-     * Returns the object which defines which fields this period supports.\n-     */\n-    DurationType getDurationType();\n+     * Returns the period type which defines which fields this period supports.\n+     * \n+     * @return the period type\n+     */\n+    PeriodType getPeriodType();\n \n     /**\n      * Is this period a precise length of time, or descriptive.\n     /**\n      * Adds this period to the given instant, returning a new value.\n      * <p>\n-     * The addition uses the chronology of the DurationType.\n+     * The addition uses the chronology of the PeriodType.\n      * To add just once, pass in a scalar of one. To subtract once, pass\n      * in a scalar of minus one.\n      *\n      * Gets a hash code for the period that is compatable with the \n      * equals method. The hashcode must be calculated as follows:\n      * <pre>\n-     *   int hash = getDurationType().hashCode();\n+     *   int hash = getPeriodType().hashCode();\n      *   hash = 53 * hash + getYears();\n      *   hash = 53 * hash + getMonths();\n      *   hash = 53 * hash + getWeeks();\n--- a/JodaTime/src/java/org/joda/time/TimePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/TimePeriod.java\n  * An immutable time period specifying a set of duration field values.\n  * <p>\n  * A time period is divided into a number of fields, such as hours and seconds.\n- * The way in which that divide occurs is controlled by the DurationType class.\n- * <p>\n- * <code>TimePeriod</code> can use any duration type to split the milliseconds into fields.\n- * The {@link DurationType#getAllType() All} type is used by default.\n+ * The way in which that divide occurs is controlled by the PeriodType class.\n+ * <p>\n+ * <code>TimePeriod</code> can use any period type to split the milliseconds into fields.\n+ * The {@link PeriodType#getAllType() All} type is used by default.\n  * <code>All</code> uses the ISO chronology and divides a duration into years, months,\n  * weeks, days, hours, minutes, seconds and milliseconds as best it can.\n  * <p>\n  * 23 hours rather than 24 to ensure that the time remains the same.\n  * If this is not the behaviour you want, then see {@link Duration}.\n  * <p>\n- * TimePeriod is thread-safe and immutable, provided that the DurationType is as well.\n- * All standard DurationType classes supplied are thread-safe and immutable.\n+ * TimePeriod is thread-safe and immutable, provided that the PeriodType is as well.\n+ * All standard PeriodType classes supplied are thread-safe and immutable.\n  *\n  * @author Brian S O'Neill\n  * @author Stephen Colebourne\n      * Creates a period from the given millisecond duration using AllType.\n      * <p>\n      * The millisecond duration will be split to fields using a UTC version of\n-     * the duration type. This ensures that there are no odd effects caused by\n+     * the period type. This ensures that there are no odd effects caused by\n      * time zones. The add methods will still use the time zone specific version\n-     * of the duration type.\n+     * of the period type.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n      * Creates a period from the given millisecond duration.\n      * <p>\n      * The millisecond duration will be split to fields using a UTC version of\n-     * the duration type. This ensures that there are no odd effects caused by\n+     * the period type. This ensures that there are no odd effects caused by\n      * time zones. The add methods will still use the time zone specific version\n-     * of the duration type.\n+     * of the period type.\n      *\n      * @param duration  the duration, in milliseconds\n      * @param type  which set of fields this period supports\n      */\n-    public TimePeriod(long duration, DurationType type) {\n+    public TimePeriod(long duration, PeriodType type) {\n         super(duration, type);\n     }\n \n      * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n     public TimePeriod(int years, int months, int weeks, int days,\n-                    int hours, int minutes, int seconds, int millis, DurationType type) {\n+                    int hours, int minutes, int seconds, int millis, PeriodType type) {\n         super(years, months, weeks, days, hours, minutes, seconds, millis, type);\n     }\n \n      * @param endInstant  interval end, in milliseconds\n      * @param type  which set of fields this period supports, null means AllType\n      */\n-    public TimePeriod(long startInstant, long endInstant, DurationType type) {\n+    public TimePeriod(long startInstant, long endInstant, PeriodType type) {\n         super(startInstant, endInstant, type);\n     }\n \n      * @param endInstant  interval end, null means now\n      * @param type  which set of fields this period supports, null means AllType\n      */\n-    public TimePeriod(ReadableInstant startInstant, ReadableInstant endInstant, DurationType type) {\n+    public TimePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {\n         super(startInstant, endInstant, type);\n     }\n \n      * @throws IllegalArgumentException if period is invalid\n      * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n      */\n-    public TimePeriod(Object period, DurationType type) {\n+    public TimePeriod(Object period, PeriodType type) {\n         super(period, type);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Validates a duration type, converting nulls to a default value and\n+     * Validates a period type, converting nulls to a default value and\n      * checking the type is suitable for this instance.\n      * \n      * @param type  the type to check, may be null\n      * @return the validated type to use, not null\n-     * @throws IllegalArgumentException if the duration type is not precise\n-     */\n-    protected final DurationType checkDurationType(DurationType type) {\n+     * @throws IllegalArgumentException if the period type is not precise\n+     */\n+    protected final PeriodType checkPeriodType(PeriodType type) {\n         if (type == null) {\n-            return DurationType.getAllType();\n+            return PeriodType.getAllType();\n         }\n         return type;\n     }\n     //-----------------------------------------------------------------------\n     /**\n      * Creates a new TimePeriod instance with the same field values but\n-     * different DurationType.\n+     * different PeriodType.\n      * \n-     * @param type  the duration type to use, null means AllType\n+     * @param type  the period type to use, null means AllType\n      * @return the new period instance\n      * @throws IllegalArgumentException if the new period won't accept all of the current fields\n      */\n-    public TimePeriod withDurationType(DurationType type) {\n+    public TimePeriod withPeriodType(PeriodType type) {\n         if (type == null) {\n-            type = DurationType.getAllType();\n-        }\n-        if (type.equals(getDurationType())) {\n+            type = PeriodType.getAllType();\n+        }\n+        if (type.equals(getPeriodType())) {\n             return this;\n         }\n         return new TimePeriod(getYears(), getMonths(), getWeeks(), getDays(),\n \n     /**\n      * Creates a new TimePeriod instance with the same millisecond duration but\n-     * different DurationType.\n+     * different PeriodType.\n      * \n-     * @param type  the duration type to use, null means AllType\n+     * @param type  the period type to use, null means AllType\n      * @return the new period instance\n      * @throws IllegalStateException if this period is imprecise\n      */\n-    public TimePeriod withDurationTypeRetainDuration(DurationType type) {\n+    public TimePeriod withPeriodTypeRetainDuration(PeriodType type) {\n         if (type == null) {\n-            type = DurationType.getAllType();\n-        }\n-        if (type.equals(getDurationType())) {\n+            type = PeriodType.getAllType();\n+        }\n+        if (type.equals(getPeriodType())) {\n             return this;\n         }\n         return new TimePeriod(toDurationMillis(), type);\n      * @throws IllegalStateException if this period is imprecise\n      */\n     public TimePeriod withFieldsNormalized() {\n-        return new TimePeriod(toDurationMillis(), getDurationType());\n+        return new TimePeriod(toDurationMillis(), getPeriodType());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.DurationType;\n+import org.joda.time.PeriodType;\n import org.joda.time.chrono.ISOChronology;\n \n /**\n     \n     //-----------------------------------------------------------------------\n     /**\n-     * Selects a suitable duration type for the given object.\n+     * Selects a suitable period type for the given object.\n      *\n      * @param object  the object to examine, must not be null\n      * @param precise  true if a precise type is required\n-     * @return the duration type, never null\n+     * @return the period type, never null\n      * @throws ClassCastException if the object is invalid\n      */\n-    public DurationType getDurationType(Object object, boolean precise) {\n+    public PeriodType getPeriodType(Object object, boolean precise) {\n         if (precise) {\n-            return DurationType.getPreciseAllType();\n+            return PeriodType.getPreciseAllType();\n         }\n-        return DurationType.getAllType();\n+        return PeriodType.getAllType();\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/convert/LongConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/LongConverter.java\n \n /**\n  * LongConverter converts a Long to milliseconds in the ISOChronology.\n- * The duration type created is the millis type.\n  *\n  * @author Stephen Colebourne\n  * @author Brian S O'Neill\n--- a/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java\n  */\n package org.joda.time.convert;\n \n-import org.joda.time.DurationType;\n+import org.joda.time.PeriodType;\n import org.joda.time.ReadWritableTimePeriod;\n import org.joda.time.ReadableDuration;\n \n     }\n \n     /**\n-     * Selects a suitable duration type for the given object.\n+     * Selects a suitable period type for the given object.\n      *\n      * @param object  the object to examine, must not be null\n      * @param precise  true if a precise type is required\n-     * @return the duration type from the readable duration\n+     * @return the period type from the readable duration\n      * @throws NullPointerException if the object is null\n      * @throws ClassCastException if the object is an invalid type\n      */\n-    public DurationType getDurationType(Object object, boolean precise) {\n-        return DurationType.getPreciseAllType();\n+    public PeriodType getPeriodType(Object object, boolean precise) {\n+        return PeriodType.getPreciseAllType();\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java\n import org.joda.time.ReadableInterval;\n \n /**\n- * Converts intervals into durations of any requested duration type.\n+ * Converts intervals into durations of any requested period type.\n  *\n  * @author Brian S O'Neill\n  * @since 1.0\n--- a/JodaTime/src/java/org/joda/time/convert/ReadableTimePeriodConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableTimePeriodConverter.java\n  */\n package org.joda.time.convert;\n \n-import org.joda.time.DurationType;\n+import org.joda.time.PeriodType;\n import org.joda.time.ReadWritableTimePeriod;\n import org.joda.time.ReadableTimePeriod;\n \n     }\n \n     /**\n-     * Selects a suitable duration type for the given object.\n+     * Selects a suitable period type for the given object.\n      *\n      * @param object  the object to examine, must not be null\n      * @param precise  true if a precise type is required\n-     * @return the duration type from the readable duration\n+     * @return the period type from the readable duration\n      * @throws NullPointerException if the object is null\n      * @throws ClassCastException if the object is an invalid type\n      */\n-    public DurationType getDurationType(Object object, boolean precise) {\n+    public PeriodType getPeriodType(Object object, boolean precise) {\n         ReadableTimePeriod period = (ReadableTimePeriod) object;\n         if (precise) {\n-            if (period.getDurationType().isPrecise()) {\n-                return period.getDurationType();\n+            if (period.getPeriodType().isPrecise()) {\n+                return period.getPeriodType();\n             } else {\n-                return DurationType.getPreciseAllType();\n+                return PeriodType.getPreciseAllType();\n             }\n         }\n-        return period.getDurationType();\n+        return period.getPeriodType();\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.DurationType;\n+import org.joda.time.PeriodType;\n import org.joda.time.MutableTimePeriod;\n import org.joda.time.ReadWritableInterval;\n import org.joda.time.ReadWritableTimePeriod;\n      */\n     public long getDurationMillis(Object object) {\n         String str = (String) object;\n-        MutableTimePeriod period = new MutableTimePeriod(DurationType.getPreciseAllType());\n+        MutableTimePeriod period = new MutableTimePeriod(PeriodType.getPreciseAllType());\n         TimePeriodParser parser = ISOTimePeriodFormat.getInstance().standard();\n         int pos = parser.parseInto(period, str, 0);\n         if (pos < str.length()) {\n             if (pos < 0) {\n                 // Parse again to get a better exception thrown.\n-                parser.parseMutableTimePeriod(period.getDurationType(), str);\n+                parser.parseMutableTimePeriod(period.getPeriodType(), str);\n             }\n             throw new IllegalArgumentException(\"Invalid format: \\\"\" + str + '\"');\n         }\n         if (pos < str.length()) {\n             if (pos < 0) {\n                 // Parse again to get a better exception thrown.\n-                parser.parseMutableTimePeriod(period.getDurationType(), str);\n+                parser.parseMutableTimePeriod(period.getPeriodType(), str);\n             }\n             throw new IllegalArgumentException(\"Invalid format: \\\"\" + str + '\"');\n         }\n         char c = leftStr.charAt(0);\n         if (c == 'P' || c == 'p') {\n             startInstant = 0;\n-            period = durationParser.parseTimePeriod(getDurationType(leftStr, false), leftStr);\n+            period = durationParser.parseTimePeriod(getPeriodType(leftStr, false), leftStr);\n         } else {\n             startInstant = dateTimeParser.parseMillis(leftStr);\n             period = null;\n             if (period != null) {\n                 throw new IllegalArgumentException(\"Interval composed of two durations: \" + str);\n             }\n-            period = durationParser.parseTimePeriod(getDurationType(rightStr, false), rightStr);\n+            period = durationParser.parseTimePeriod(getPeriodType(rightStr, false), rightStr);\n             writableInterval.setStartMillis(startInstant);\n             writableInterval.setTimePeriodAfterStart(period);\n         } else {\n--- a/JodaTime/src/java/org/joda/time/convert/TimePeriodConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/TimePeriodConverter.java\n  */\n package org.joda.time.convert;\n \n-import org.joda.time.DurationType;\n+import org.joda.time.PeriodType;\n import org.joda.time.ReadWritableTimePeriod;\n \n /**\n     void setInto(ReadWritableTimePeriod period, Object object);\n \n     /**\n-     * Selects a suitable duration type for the given object.\n+     * Selects a suitable period type for the given object.\n      *\n      * @param object  the object to examine, must not be null\n-     * @param precise  true if the duration type must be precise\n-     * @return the duration type, never null\n+     * @param precise  true if the period type must be precise\n+     * @return the period type, never null\n      * @throws ClassCastException if the object is invalid\n      */\n-    DurationType getDurationType(Object object, boolean precise);\n+    PeriodType getPeriodType(Object object, boolean precise);\n \n }\n--- a/JodaTime/src/java/org/joda/time/format/AbstractTimePeriodFormatter.java\n+++ b/JodaTime/src/java/org/joda/time/format/AbstractTimePeriodFormatter.java\n  */\n package org.joda.time.format;\n \n-import org.joda.time.DurationType;\n+import org.joda.time.PeriodType;\n import org.joda.time.MutableTimePeriod;\n import org.joda.time.ReadableTimePeriod;\n import org.joda.time.TimePeriod;\n         return buf.toString();\n     }\n \n-    public TimePeriod parseTimePeriod(DurationType type, String text) {\n+    public TimePeriod parseTimePeriod(PeriodType type, String text) {\n         return parseMutableTimePeriod(type, text).toTimePeriod();\n     }\n \n-    public MutableTimePeriod parseMutableTimePeriod(DurationType type, String text) {\n+    public MutableTimePeriod parseMutableTimePeriod(PeriodType type, String text) {\n         TimePeriodParser p = (TimePeriodParser) this;\n         MutableTimePeriod period = new MutableTimePeriod(0, type);\n \n--- a/JodaTime/src/java/org/joda/time/format/TimePeriodFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/TimePeriodFormatterBuilder.java\n import java.util.ArrayList;\n import java.util.List;\n \n-import org.joda.time.DurationType;\n+import org.joda.time.PeriodType;\n import org.joda.time.ReadWritableTimePeriod;\n import org.joda.time.ReadableTimePeriod;\n \n                 }\n             }\n \n-            if (!mustParse && !isSupported(period.getDurationType())) {\n+            if (!mustParse && !isSupported(period.getPeriodType())) {\n                 // If parsing is not required and the field is not supported,\n                 // exit gracefully so that another parser can continue on.\n                 return position;\n          * is signed int value.\n          */\n         long getFieldValue(ReadableTimePeriod period) {\n-            DurationType type;\n+            PeriodType type;\n             if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n                 type = null; // Don't need to check if supported.\n             } else {\n-                type = period.getDurationType();\n+                type = period.getPeriodType();\n             }\n \n             int value;\n             return value & 0xffffffffL;\n         }\n \n-        boolean isSupported(DurationType type) {\n+        boolean isSupported(PeriodType type) {\n             switch (iFieldType) {\n             default:\n                 return false;\n         }\n \n         private FieldFormatter chooseFieldToPrint(ReadableTimePeriod period) {\n-            DurationType type = period.getDurationType();\n+            PeriodType type = period.getPeriodType();\n             TimePeriodPrinter[] printers = iAlternatePrinters;\n             if (iFavorFirstFieldForZero) {\n                 int len = printers.length;\n--- a/JodaTime/src/java/org/joda/time/format/TimePeriodParser.java\n+++ b/JodaTime/src/java/org/joda/time/format/TimePeriodParser.java\n package org.joda.time.format;\n \n import org.joda.time.TimePeriod;\n-import org.joda.time.DurationType;\n+import org.joda.time.PeriodType;\n import org.joda.time.MutableTimePeriod;\n import org.joda.time.ReadWritableTimePeriod;\n \n      * @return parsed value in a Duration object\n      * @throws IllegalArgumentException if any field is out of range\n      */\n-    TimePeriod parseTimePeriod(DurationType type, String periodStr);\n+    TimePeriod parseTimePeriod(PeriodType type, String periodStr);\n \n     /**\n      * Parses a period from the given text, returning a new MutableTimePeriod.\n      * @return parsed value in a MutableDuration object\n      * @throws IllegalArgumentException if any field is out of range\n      */\n-    MutableTimePeriod parseMutableTimePeriod(DurationType type, String periodStr);\n+    MutableTimePeriod parseMutableTimePeriod(PeriodType type, String periodStr);\n \n }\n--- a/JodaTime/src/test/org/joda/time/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/TestAll.java\n         suite.addTest(TestDateTimeConstants.suite());\n         suite.addTest(TestDateTimeUtils.suite());\n         suite.addTest(TestDateTimeZone.suite());\n-        suite.addTest(TestDurationType.suite());\n+        suite.addTest(TestPeriodType.suite());\n //        suite.addTest(TestParseISO.suite());\n         return suite;\n     }\n--- a/JodaTime/src/test/org/joda/time/TestDurationType.java\n+++ b/JodaTime/src/test/org/joda/time/TestDurationType.java\n import org.joda.time.chrono.ISOChronology;\n \n /**\n- * This class is a JUnit test for DurationType.\n+ * This class is a JUnit test for PeriodType.\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestDurationType extends TestCase {\n+public class TestPeriodType extends TestCase {\n     // Test in 2002/03 as time zones are more well known\n     // (before the late 90's they were all over the place)\n \n     }\n \n     public static TestSuite suite() {\n-        return new TestSuite(TestDurationType.class);\n-    }\n-\n-    public TestDurationType(String name) {\n+        return new TestSuite(TestPeriodType.class);\n+    }\n+\n+    public TestPeriodType(String name) {\n         super(name);\n     }\n \n     }\n \n     //-----------------------------------------------------------------------\n-    private void assertEqualsAfterSerialization(DurationType type) throws Exception {\n+    private void assertEqualsAfterSerialization(PeriodType type) throws Exception {\n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         ObjectOutputStream oos = new ObjectOutputStream(baos);\n         oos.writeObject(type);\n         \n         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n         ObjectInputStream ois = new ObjectInputStream(bais);\n-        DurationType result = (DurationType) ois.readObject();\n+        PeriodType result = (PeriodType) ois.readObject();\n         ois.close();\n         \n         assertEquals(type, result);\n     }\n \n-    private void assertSameAfterSerialization(DurationType type) throws Exception {\n+    private void assertSameAfterSerialization(PeriodType type) throws Exception {\n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         ObjectOutputStream oos = new ObjectOutputStream(baos);\n         oos.writeObject(type);\n         \n         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n         ObjectInputStream ois = new ObjectInputStream(bais);\n-        DurationType result = (DurationType) ois.readObject();\n+        PeriodType result = (PeriodType) ois.readObject();\n         ois.close();\n         \n         assertSame(type, result);\n \n     //-----------------------------------------------------------------------\n     public void testMillisType() throws Exception {\n-        DurationType type = DurationType.getMillisType();\n+        PeriodType type = PeriodType.getMillisType();\n         assertEquals(false, type.years().isSupported());\n         assertEquals(false, type.months().isSupported());\n         assertEquals(false, type.weeks().isSupported());\n         assertEquals(true, type.isPrecise());\n         assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, type == DurationType.getMillisType());\n-        assertEquals(false, type.equals(DurationType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == DurationType.getMillisType().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(true, type == PeriodType.getMillisType());\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getMillisType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n         assertEquals(\"MillisType\", type.getName());\n-        assertEquals(\"DurationType[MillisType]\", type.toString());\n+        assertEquals(\"PeriodType[MillisType]\", type.toString());\n         assertSameAfterSerialization(type);\n         assertSame(type, type.withChronology(null));\n         assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));\n \n     //-----------------------------------------------------------------------\n     public void testDayHourType() throws Exception {\n-        DurationType type = DurationType.getDayHourType();\n+        PeriodType type = PeriodType.getDayHourType();\n         assertEquals(false, type.years().isSupported());\n         assertEquals(false, type.months().isSupported());\n         assertEquals(false, type.weeks().isSupported());\n         assertEquals(false, type.isPrecise());\n         assertEquals(ISOChronology.getInstance(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, type == DurationType.getDayHourType());\n-        assertEquals(false, type.equals(DurationType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == DurationType.getDayHourType().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(true, type == PeriodType.getDayHourType());\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getDayHourType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n         assertEquals(\"DayHourType\", type.getName());\n-        assertEquals(\"DurationType[DayHourType]\", type.toString());\n+        assertEquals(\"PeriodType[DayHourType]\", type.toString());\n         assertSameAfterSerialization(type);\n         assertSame(type, type.withChronology(null));\n         assertSame(type, type.withChronology(ISOChronology.getInstance()));\n \n     //-----------------------------------------------------------------------\n     public void testDayHourType_Chronology() throws Exception {\n-        DurationType type = DurationType.getDayHourType(BuddhistChronology.getInstanceUTC());\n+        PeriodType type = PeriodType.getDayHourType(BuddhistChronology.getInstanceUTC());\n         assertEquals(false, type.years().isSupported());\n         assertEquals(false, type.months().isSupported());\n         assertEquals(false, type.weeks().isSupported());\n         assertEquals(true, type.isPrecise());\n         assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, DurationType.getDayHourType() == DurationType.getDayHourType(null));\n-        assertEquals(true, DurationType.getDayHourType() == DurationType.getDayHourType(ISOChronology.getInstance()));\n-        assertEquals(true, type.equals(DurationType.getDayHourType(BuddhistChronology.getInstanceUTC())));\n-        assertEquals(false, type.equals(DurationType.getDayHourType()));\n-        assertEquals(false, type.equals(DurationType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getDayHourType().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(true, PeriodType.getDayHourType() == PeriodType.getDayHourType(null));\n+        assertEquals(true, PeriodType.getDayHourType() == PeriodType.getDayHourType(ISOChronology.getInstance()));\n+        assertEquals(true, type.equals(PeriodType.getDayHourType(BuddhistChronology.getInstanceUTC())));\n+        assertEquals(false, type.equals(PeriodType.getDayHourType()));\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getDayHourType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n         assertEquals(\"DayHourType\", type.getName());\n-        assertEquals(\"DurationType[DayHourType]\", type.toString());\n-        assertEqualsAfterSerialization(type);\n-        assertSame(DurationType.getDayHourType(), type.withChronology(null));\n-        assertSame(DurationType.getDayHourType(), type.withChronology(ISOChronology.getInstance()));\n+        assertEquals(\"PeriodType[DayHourType]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+        assertSame(PeriodType.getDayHourType(), type.withChronology(null));\n+        assertSame(PeriodType.getDayHourType(), type.withChronology(ISOChronology.getInstance()));\n         assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testYearWeekType() throws Exception {\n-        DurationType type = DurationType.getYearWeekType();\n+        PeriodType type = PeriodType.getYearWeekType();\n         assertEquals(true, type.years().isSupported());\n         assertEquals(false, type.months().isSupported());\n         assertEquals(true, type.weeks().isSupported());\n         assertEquals(false, type.isPrecise());\n         assertEquals(ISOChronology.getInstance(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, type == DurationType.getYearWeekType());\n-        assertEquals(false, type.equals(DurationType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == DurationType.getYearWeekType().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(true, type == PeriodType.getYearWeekType());\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getYearWeekType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n         assertEquals(\"YearWeekType\", type.getName());\n-        assertEquals(\"DurationType[YearWeekType]\", type.toString());\n+        assertEquals(\"PeriodType[YearWeekType]\", type.toString());\n         assertSameAfterSerialization(type);\n         assertSame(type, type.withChronology(null));\n         assertSame(type, type.withChronology(ISOChronology.getInstance()));\n \n     //-----------------------------------------------------------------------\n     public void testYearWeekType_Chronology() throws Exception {\n-        DurationType type = DurationType.getYearWeekType(BuddhistChronology.getInstanceUTC());\n+        PeriodType type = PeriodType.getYearWeekType(BuddhistChronology.getInstanceUTC());\n         assertEquals(true, type.years().isSupported());\n         assertEquals(false, type.months().isSupported());\n         assertEquals(true, type.weeks().isSupported());\n         assertEquals(false, type.isPrecise());\n         assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, DurationType.getYearWeekType() == DurationType.getYearWeekType(null));\n-        assertEquals(true, DurationType.getYearWeekType() == DurationType.getYearWeekType(ISOChronology.getInstance()));\n-        assertEquals(true, type.equals(DurationType.getYearWeekType(BuddhistChronology.getInstanceUTC())));\n-        assertEquals(false, type.equals(DurationType.getYearWeekType()));\n-        assertEquals(false, type.equals(DurationType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getYearWeekType().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(true, PeriodType.getYearWeekType() == PeriodType.getYearWeekType(null));\n+        assertEquals(true, PeriodType.getYearWeekType() == PeriodType.getYearWeekType(ISOChronology.getInstance()));\n+        assertEquals(true, type.equals(PeriodType.getYearWeekType(BuddhistChronology.getInstanceUTC())));\n+        assertEquals(false, type.equals(PeriodType.getYearWeekType()));\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getYearWeekType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n         assertEquals(\"YearWeekType\", type.getName());\n-        assertEquals(\"DurationType[YearWeekType]\", type.toString());\n-        assertEqualsAfterSerialization(type);\n-        assertSame(DurationType.getYearWeekType(), type.withChronology(null));\n-        assertSame(DurationType.getYearWeekType(), type.withChronology(ISOChronology.getInstance()));\n+        assertEquals(\"PeriodType[YearWeekType]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+        assertSame(PeriodType.getYearWeekType(), type.withChronology(null));\n+        assertSame(PeriodType.getYearWeekType(), type.withChronology(ISOChronology.getInstance()));\n         assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testYearMonthType() throws Exception {\n-        DurationType type = DurationType.getYearMonthType();\n+        PeriodType type = PeriodType.getYearMonthType();\n         assertEquals(true, type.years().isSupported());\n         assertEquals(true, type.months().isSupported());\n         assertEquals(false, type.weeks().isSupported());\n         assertEquals(false, type.isPrecise());\n         assertEquals(ISOChronology.getInstance(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, type == DurationType.getYearMonthType());\n-        assertEquals(false, type.equals(DurationType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == DurationType.getYearMonthType().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(true, type == PeriodType.getYearMonthType());\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getYearMonthType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n         assertEquals(\"YearMonthType\", type.getName());\n-        assertEquals(\"DurationType[YearMonthType]\", type.toString());\n+        assertEquals(\"PeriodType[YearMonthType]\", type.toString());\n         assertSameAfterSerialization(type);\n         assertSame(type, type.withChronology(null));\n         assertSame(type, type.withChronology(ISOChronology.getInstance()));\n \n     //-----------------------------------------------------------------------\n     public void testYearMonthType_Chronology() throws Exception {\n-        DurationType type = DurationType.getYearMonthType(BuddhistChronology.getInstanceUTC());\n+        PeriodType type = PeriodType.getYearMonthType(BuddhistChronology.getInstanceUTC());\n         assertEquals(true, type.years().isSupported());\n         assertEquals(true, type.months().isSupported());\n         assertEquals(false, type.weeks().isSupported());\n         assertEquals(false, type.isPrecise());\n         assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, DurationType.getYearMonthType() == DurationType.getYearMonthType(null));\n-        assertEquals(true, DurationType.getYearMonthType() == DurationType.getYearMonthType(ISOChronology.getInstance()));\n-        assertEquals(true, type.equals(DurationType.getYearMonthType(BuddhistChronology.getInstanceUTC())));\n-        assertEquals(false, type.equals(DurationType.getYearMonthType()));\n-        assertEquals(false, type.equals(DurationType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getYearMonthType().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(true, PeriodType.getYearMonthType() == PeriodType.getYearMonthType(null));\n+        assertEquals(true, PeriodType.getYearMonthType() == PeriodType.getYearMonthType(ISOChronology.getInstance()));\n+        assertEquals(true, type.equals(PeriodType.getYearMonthType(BuddhistChronology.getInstanceUTC())));\n+        assertEquals(false, type.equals(PeriodType.getYearMonthType()));\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getYearMonthType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n         assertEquals(\"YearMonthType\", type.getName());\n-        assertEquals(\"DurationType[YearMonthType]\", type.toString());\n-        assertEqualsAfterSerialization(type);\n-        assertSame(DurationType.getYearMonthType(), type.withChronology(null));\n-        assertSame(DurationType.getYearMonthType(), type.withChronology(ISOChronology.getInstance()));\n+        assertEquals(\"PeriodType[YearMonthType]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+        assertSame(PeriodType.getYearMonthType(), type.withChronology(null));\n+        assertSame(PeriodType.getYearMonthType(), type.withChronology(ISOChronology.getInstance()));\n         assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testAllType() throws Exception {\n-        DurationType type = DurationType.getAllType();\n+        PeriodType type = PeriodType.getAllType();\n         assertEquals(true, type.years().isSupported());\n         assertEquals(true, type.months().isSupported());\n         assertEquals(true, type.weeks().isSupported());\n         assertEquals(false, type.isPrecise());\n         assertEquals(ISOChronology.getInstance(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, type == DurationType.getAllType());\n-        assertEquals(false, type.equals(DurationType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == DurationType.getAllType().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(true, type == PeriodType.getAllType());\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getAllType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n         assertEquals(\"AllType\", type.getName());\n-        assertEquals(\"DurationType[AllType]\", type.toString());\n+        assertEquals(\"PeriodType[AllType]\", type.toString());\n         assertSameAfterSerialization(type);\n         assertSame(type, type.withChronology(null));\n         assertSame(type, type.withChronology(ISOChronology.getInstance()));\n \n     //-----------------------------------------------------------------------\n     public void testAllType_Chronology() throws Exception {\n-        DurationType type = DurationType.getAllType(BuddhistChronology.getInstanceUTC());\n+        PeriodType type = PeriodType.getAllType(BuddhistChronology.getInstanceUTC());\n         assertEquals(true, type.years().isSupported());\n         assertEquals(true, type.months().isSupported());\n         assertEquals(true, type.weeks().isSupported());\n         assertEquals(false, type.isPrecise());\n         assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, DurationType.getAllType() == DurationType.getAllType(null));\n-        assertEquals(true, DurationType.getAllType() == DurationType.getAllType(ISOChronology.getInstance()));\n-        assertEquals(true, type.equals(DurationType.getAllType(BuddhistChronology.getInstanceUTC())));\n-        assertEquals(false, type.equals(DurationType.getAllType()));\n-        assertEquals(false, type.equals(DurationType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(true, PeriodType.getAllType() == PeriodType.getAllType(null));\n+        assertEquals(true, PeriodType.getAllType() == PeriodType.getAllType(ISOChronology.getInstance()));\n+        assertEquals(true, type.equals(PeriodType.getAllType(BuddhistChronology.getInstanceUTC())));\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n         assertEquals(\"AllType\", type.getName());\n-        assertEquals(\"DurationType[AllType]\", type.toString());\n-        assertEqualsAfterSerialization(type);\n-        assertSame(DurationType.getAllType(), type.withChronology(null));\n-        assertSame(DurationType.getAllType(), type.withChronology(ISOChronology.getInstance()));\n+        assertEquals(\"PeriodType[AllType]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+        assertSame(PeriodType.getAllType(), type.withChronology(null));\n+        assertSame(PeriodType.getAllType(), type.withChronology(ISOChronology.getInstance()));\n         assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testPreciseDayHourType() throws Exception {\n-        DurationType type = DurationType.getPreciseDayHourType();\n+        PeriodType type = PeriodType.getPreciseDayHourType();\n         assertEquals(false, type.years().isSupported());\n         assertEquals(false, type.months().isSupported());\n         assertEquals(false, type.weeks().isSupported());\n         assertEquals(true, type.isPrecise());\n         assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, type == DurationType.getPreciseDayHourType());\n-        assertEquals(false, type.equals(DurationType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == DurationType.getPreciseDayHourType().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(true, type == PeriodType.getPreciseDayHourType());\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseDayHourType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n         assertEquals(\"PreciseDayHourType\", type.getName());\n-        assertEquals(\"DurationType[PreciseDayHourType]\", type.toString());\n+        assertEquals(\"PeriodType[PreciseDayHourType]\", type.toString());\n         assertSameAfterSerialization(type);\n         assertSame(type, type.withChronology(null));\n         assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n \n     //-----------------------------------------------------------------------\n     public void testPreciseYearDayType() throws Exception {\n-        DurationType type = DurationType.getPreciseYearDayType();\n+        PeriodType type = PeriodType.getPreciseYearDayType();\n         assertEquals(true, type.years().isSupported());\n         assertEquals(false, type.months().isSupported());\n         assertEquals(false, type.weeks().isSupported());\n         assertEquals(true, type.isPrecise());\n         assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, type == DurationType.getPreciseYearDayType());\n-        assertEquals(false, type.equals(DurationType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == DurationType.getPreciseYearDayType().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(true, type == PeriodType.getPreciseYearDayType());\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseYearDayType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n         assertEquals(\"PreciseYearDayType\", type.getName());\n-        assertEquals(\"DurationType[PreciseYearDayType]\", type.toString());\n+        assertEquals(\"PeriodType[PreciseYearDayType]\", type.toString());\n         assertSameAfterSerialization(type);\n         assertSame(type, type.withChronology(null));\n         assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n \n     //-----------------------------------------------------------------------\n     public void testPreciseYearWeekType() throws Exception {\n-        DurationType type = DurationType.getPreciseYearWeekType();\n+        PeriodType type = PeriodType.getPreciseYearWeekType();\n         assertEquals(true, type.years().isSupported());\n         assertEquals(false, type.months().isSupported());\n         assertEquals(true, type.weeks().isSupported());\n         assertEquals(true, type.isPrecise());\n         assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, type == DurationType.getPreciseYearWeekType());\n-        assertEquals(false, type.equals(DurationType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == DurationType.getPreciseYearWeekType().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(true, type == PeriodType.getPreciseYearWeekType());\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseYearWeekType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n         assertEquals(\"PreciseYearWeekType\", type.getName());\n-        assertEquals(\"DurationType[PreciseYearWeekType]\", type.toString());\n+        assertEquals(\"PeriodType[PreciseYearWeekType]\", type.toString());\n         assertSameAfterSerialization(type);\n         assertSame(type, type.withChronology(null));\n         assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n \n     //-----------------------------------------------------------------------\n     public void testPreciseYearMonthType() throws Exception {\n-        DurationType type = DurationType.getPreciseYearMonthType();\n+        PeriodType type = PeriodType.getPreciseYearMonthType();\n         assertEquals(true, type.years().isSupported());\n         assertEquals(true, type.months().isSupported());\n         assertEquals(false, type.weeks().isSupported());\n         assertEquals(true, type.isPrecise());\n         assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, type == DurationType.getPreciseYearMonthType());\n-        assertEquals(false, type.equals(DurationType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == DurationType.getPreciseYearMonthType().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(true, type == PeriodType.getPreciseYearMonthType());\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseYearMonthType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n         assertEquals(\"PreciseYearMonthType\", type.getName());\n-        assertEquals(\"DurationType[PreciseYearMonthType]\", type.toString());\n+        assertEquals(\"PeriodType[PreciseYearMonthType]\", type.toString());\n         assertSameAfterSerialization(type);\n         assertSame(type, type.withChronology(null));\n         assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n \n     //-----------------------------------------------------------------------\n     public void testPreciseAllType() throws Exception {\n-        DurationType type = DurationType.getPreciseAllType();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(true, type.months().isSupported());\n-        assertEquals(true, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(true, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type == DurationType.getPreciseAllType());\n-        assertEquals(false, type.equals(DurationType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == DurationType.getPreciseAllType().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        PeriodType type = PeriodType.getPreciseAllType();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.getPreciseAllType());\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n         assertEquals(\"PreciseAllType\", type.getName());\n-        assertEquals(\"DurationType[PreciseAllType]\", type.toString());\n+        assertEquals(\"PeriodType[PreciseAllType]\", type.toString());\n         assertSameAfterSerialization(type);\n         assertSame(type, type.withChronology(null));\n         assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n \n     //-----------------------------------------------------------------------\n     public void testMaskYears() throws Exception {\n-        DurationType type = DurationType.getPreciseAllType().withYearsRemoved();\n+        PeriodType type = PeriodType.getPreciseAllType().withYearsRemoved();\n         assertEquals(false, type.years().isSupported());\n         assertEquals(true, type.months().isSupported());\n         assertEquals(true, type.weeks().isSupported());\n         assertEquals(true, type.isPrecise());\n         assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, type.equals(DurationType.getPreciseAllType().withYearsRemoved()));\n-        assertEquals(false, type.equals(DurationType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == DurationType.getPreciseAllType().withYearsRemoved().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withYearsRemoved()));\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withYearsRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n         assertEquals(\"MaskedYears[PreciseAllType]\", type.getName());\n-        assertEquals(\"DurationType[MaskedYears[PreciseAllType]]\", type.toString());\n+        assertEquals(\"PeriodType[MaskedYears[PreciseAllType]]\", type.toString());\n         assertEqualsAfterSerialization(type);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskMonths() throws Exception {\n-        DurationType type = DurationType.getPreciseAllType().withMonthsRemoved();\n+        PeriodType type = PeriodType.getPreciseAllType().withMonthsRemoved();\n         assertEquals(true, type.years().isSupported());\n         assertEquals(false, type.months().isSupported());\n         assertEquals(true, type.weeks().isSupported());\n         assertEquals(true, type.isPrecise());\n         assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, type.equals(DurationType.getPreciseAllType().withMonthsRemoved()));\n-        assertEquals(false, type.equals(DurationType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == DurationType.getPreciseAllType().withMonthsRemoved().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withMonthsRemoved()));\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withMonthsRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n         assertEquals(\"MaskedMonths[PreciseAllType]\", type.getName());\n-        assertEquals(\"DurationType[MaskedMonths[PreciseAllType]]\", type.toString());\n+        assertEquals(\"PeriodType[MaskedMonths[PreciseAllType]]\", type.toString());\n         assertEqualsAfterSerialization(type);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskWeeks() throws Exception {\n-        DurationType type = DurationType.getPreciseAllType().withWeeksRemoved();\n+        PeriodType type = PeriodType.getPreciseAllType().withWeeksRemoved();\n         assertEquals(true, type.years().isSupported());\n         assertEquals(true, type.months().isSupported());\n         assertEquals(false, type.weeks().isSupported());\n         assertEquals(true, type.isPrecise());\n         assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, type.equals(DurationType.getPreciseAllType().withWeeksRemoved()));\n-        assertEquals(false, type.equals(DurationType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == DurationType.getPreciseAllType().withWeeksRemoved().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withWeeksRemoved()));\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withWeeksRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n         assertEquals(\"MaskedWeeks[PreciseAllType]\", type.getName());\n-        assertEquals(\"DurationType[MaskedWeeks[PreciseAllType]]\", type.toString());\n+        assertEquals(\"PeriodType[MaskedWeeks[PreciseAllType]]\", type.toString());\n         assertEqualsAfterSerialization(type);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskDays() throws Exception {\n-        DurationType type = DurationType.getPreciseAllType().withDaysRemoved();\n+        PeriodType type = PeriodType.getPreciseAllType().withDaysRemoved();\n         assertEquals(true, type.years().isSupported());\n         assertEquals(true, type.months().isSupported());\n         assertEquals(true, type.weeks().isSupported());\n         assertEquals(true, type.isPrecise());\n         assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, type.equals(DurationType.getPreciseAllType().withDaysRemoved()));\n-        assertEquals(false, type.equals(DurationType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == DurationType.getPreciseAllType().withDaysRemoved().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withDaysRemoved()));\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withDaysRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n         assertEquals(\"MaskedDays[PreciseAllType]\", type.getName());\n-        assertEquals(\"DurationType[MaskedDays[PreciseAllType]]\", type.toString());\n+        assertEquals(\"PeriodType[MaskedDays[PreciseAllType]]\", type.toString());\n         assertEqualsAfterSerialization(type);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskHours() throws Exception {\n-        DurationType type = DurationType.getPreciseAllType().withHoursRemoved();\n+        PeriodType type = PeriodType.getPreciseAllType().withHoursRemoved();\n         assertEquals(true, type.years().isSupported());\n         assertEquals(true, type.months().isSupported());\n         assertEquals(true, type.weeks().isSupported());\n         assertEquals(true, type.isPrecise());\n         assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, type.equals(DurationType.getPreciseAllType().withHoursRemoved()));\n-        assertEquals(false, type.equals(DurationType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == DurationType.getPreciseAllType().withHoursRemoved().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withHoursRemoved()));\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withHoursRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n         assertEquals(\"MaskedHours[PreciseAllType]\", type.getName());\n-        assertEquals(\"DurationType[MaskedHours[PreciseAllType]]\", type.toString());\n+        assertEquals(\"PeriodType[MaskedHours[PreciseAllType]]\", type.toString());\n         assertEqualsAfterSerialization(type);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskMinutes() throws Exception {\n-        DurationType type = DurationType.getPreciseAllType().withMinutesRemoved();\n+        PeriodType type = PeriodType.getPreciseAllType().withMinutesRemoved();\n         assertEquals(true, type.years().isSupported());\n         assertEquals(true, type.months().isSupported());\n         assertEquals(true, type.weeks().isSupported());\n         assertEquals(true, type.isPrecise());\n         assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, type.equals(DurationType.getPreciseAllType().withMinutesRemoved()));\n-        assertEquals(false, type.equals(DurationType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == DurationType.getPreciseAllType().withMinutesRemoved().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withMinutesRemoved()));\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withMinutesRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n         assertEquals(\"MaskedMinutes[PreciseAllType]\", type.getName());\n-        assertEquals(\"DurationType[MaskedMinutes[PreciseAllType]]\", type.toString());\n+        assertEquals(\"PeriodType[MaskedMinutes[PreciseAllType]]\", type.toString());\n         assertEqualsAfterSerialization(type);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskSeconds() throws Exception {\n-        DurationType type = DurationType.getPreciseAllType().withSecondsRemoved();\n+        PeriodType type = PeriodType.getPreciseAllType().withSecondsRemoved();\n         assertEquals(true, type.years().isSupported());\n         assertEquals(true, type.months().isSupported());\n         assertEquals(true, type.weeks().isSupported());\n         assertEquals(true, type.isPrecise());\n         assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, type.equals(DurationType.getPreciseAllType().withSecondsRemoved()));\n-        assertEquals(false, type.equals(DurationType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == DurationType.getPreciseAllType().withSecondsRemoved().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withSecondsRemoved()));\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withSecondsRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n         assertEquals(\"MaskedSeconds[PreciseAllType]\", type.getName());\n-        assertEquals(\"DurationType[MaskedSeconds[PreciseAllType]]\", type.toString());\n+        assertEquals(\"PeriodType[MaskedSeconds[PreciseAllType]]\", type.toString());\n         assertEqualsAfterSerialization(type);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskMillis() throws Exception {\n-        DurationType type = DurationType.getPreciseAllType().withMillisRemoved();\n+        PeriodType type = PeriodType.getPreciseAllType().withMillisRemoved();\n         assertEquals(true, type.years().isSupported());\n         assertEquals(true, type.months().isSupported());\n         assertEquals(true, type.weeks().isSupported());\n         assertEquals(true, type.isPrecise());\n         assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, type.equals(DurationType.getPreciseAllType().withMillisRemoved()));\n-        assertEquals(false, type.equals(DurationType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == DurationType.getPreciseAllType().withMillisRemoved().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withMillisRemoved()));\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withMillisRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n         assertEquals(\"MaskedMillis[PreciseAllType]\", type.getName());\n-        assertEquals(\"DurationType[MaskedMillis[PreciseAllType]]\", type.toString());\n+        assertEquals(\"PeriodType[MaskedMillis[PreciseAllType]]\", type.toString());\n         assertEqualsAfterSerialization(type);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskHoursMinutesSeconds() throws Exception {\n-        DurationType type = DurationType.getPreciseAllType().withHoursRemoved().withMinutesRemoved().withSecondsRemoved();\n+        PeriodType type = PeriodType.getPreciseAllType().withHoursRemoved().withMinutesRemoved().withSecondsRemoved();\n         assertEquals(true, type.years().isSupported());\n         assertEquals(true, type.months().isSupported());\n         assertEquals(true, type.weeks().isSupported());\n         assertEquals(true, type.isPrecise());\n         assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, type.equals(DurationType.getPreciseAllType().withHoursRemoved().withMinutesRemoved().withSecondsRemoved()));\n-        assertEquals(false, type.equals(DurationType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == DurationType.getPreciseAllType().withHoursRemoved().withMinutesRemoved().withSecondsRemoved().hashCode());\n-        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withHoursRemoved().withMinutesRemoved().withSecondsRemoved()));\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withHoursRemoved().withMinutesRemoved().withSecondsRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n         assertEquals(\"MaskedHoursMinutesSeconds[PreciseAllType]\", type.getName());\n-        assertEquals(\"DurationType[MaskedHoursMinutesSeconds[PreciseAllType]]\", type.toString());\n+        assertEquals(\"PeriodType[MaskedHoursMinutesSeconds[PreciseAllType]]\", type.toString());\n         assertEqualsAfterSerialization(type);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskWithChronology() throws Exception {\n-        DurationType type = DurationType.getAllType().withYearsRemoved();\n+        PeriodType type = PeriodType.getAllType().withYearsRemoved();\n         assertEquals(type, type.withChronology(null));\n         assertEquals(type, type.withChronology(ISOChronology.getInstance()));\n         \n-        DurationType type2 = type.withChronology(CopticChronology.getInstanceUTC());\n+        PeriodType type2 = type.withChronology(CopticChronology.getInstanceUTC());\n         assertEquals(CopticChronology.getInstanceUTC(), type2.getChronology());\n         assertEquals(false, type2.years().isSupported());\n         assertEquals(true, type2.months().isSupported());\n \n     //-----------------------------------------------------------------------\n     public void testMaskTwice1() throws Exception {\n-        DurationType type = DurationType.getPreciseAllType().withYearsRemoved();\n-        DurationType type2 = type.withYearsRemoved();\n-        assertEquals(true, type == type2);\n-        \n-        type = DurationType.getPreciseAllType().withMonthsRemoved();\n+        PeriodType type = PeriodType.getPreciseAllType().withYearsRemoved();\n+        PeriodType type2 = type.withYearsRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = PeriodType.getPreciseAllType().withMonthsRemoved();\n         type2 = type.withMonthsRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = DurationType.getPreciseAllType().withWeeksRemoved();\n+        type = PeriodType.getPreciseAllType().withWeeksRemoved();\n         type2 = type.withWeeksRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = DurationType.getPreciseAllType().withDaysRemoved();\n+        type = PeriodType.getPreciseAllType().withDaysRemoved();\n         type2 = type.withDaysRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = DurationType.getPreciseAllType().withHoursRemoved();\n+        type = PeriodType.getPreciseAllType().withHoursRemoved();\n         type2 = type.withHoursRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = DurationType.getPreciseAllType().withMinutesRemoved();\n+        type = PeriodType.getPreciseAllType().withMinutesRemoved();\n         type2 = type.withMinutesRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = DurationType.getPreciseAllType().withSecondsRemoved();\n+        type = PeriodType.getPreciseAllType().withSecondsRemoved();\n         type2 = type.withSecondsRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = DurationType.getPreciseAllType().withMillisRemoved();\n+        type = PeriodType.getPreciseAllType().withMillisRemoved();\n         type2 = type.withMillisRemoved();\n         assertEquals(true, type == type2);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskTwice2() throws Exception {\n-        DurationType type = DurationType.getDayHourType();\n-        DurationType type2 = type.withYearsRemoved();\n-        assertEquals(true, type == type2);\n-        \n-        type = DurationType.getDayHourType();\n+        PeriodType type = PeriodType.getDayHourType();\n+        PeriodType type2 = type.withYearsRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = PeriodType.getDayHourType();\n         type2 = type.withMonthsRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = DurationType.getDayHourType();\n+        type = PeriodType.getDayHourType();\n         type2 = type.withWeeksRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = DurationType.getMillisType();\n+        type = PeriodType.getMillisType();\n         type2 = type.withDaysRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = DurationType.getMillisType();\n+        type = PeriodType.getMillisType();\n         type2 = type.withHoursRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = DurationType.getMillisType();\n+        type = PeriodType.getMillisType();\n         type2 = type.withMinutesRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = DurationType.getMillisType();\n+        type = PeriodType.getMillisType();\n         type2 = type.withSecondsRemoved();\n         assertEquals(true, type == type2);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskNullName() throws Exception {\n-        DurationType type = new MockDurationTypeWithFields().withYearsRemoved();\n+        PeriodType type = new MockPeriodTypeWithFields().withYearsRemoved();\n         assertEquals(\"MaskedYears[]\", type.getName());\n-        assertEquals(\"DurationType[MaskedYears[]]\", type.toString());\n+        assertEquals(\"PeriodType[MaskedYears[]]\", type.toString());\n     }        \n \n     //-----------------------------------------------------------------------\n     public void testAbstract() throws Exception {\n-        assertEquals(true, Modifier.isPublic(DurationType.class.getModifiers()));\n-        assertEquals(true, Modifier.isAbstract(DurationType.class.getModifiers()));\n-        \n-        DurationType type = new MockDurationType();\n+        assertEquals(true, Modifier.isPublic(PeriodType.class.getModifiers()));\n+        assertEquals(true, Modifier.isAbstract(PeriodType.class.getModifiers()));\n+        \n+        PeriodType type = new MockPeriodType();\n         assertEquals(false, type.years().isSupported());\n         assertEquals(false, type.months().isSupported());\n         assertEquals(false, type.weeks().isSupported());\n         assertEquals(false, type.isPrecise());\n         assertEquals(null, type.getChronology());\n         assertEquals(true, type.equals(type));\n-        assertEquals(true, type.equals(new MockDurationType()));\n-        assertEquals(false, type.equals(DurationType.getAllType()));\n+        assertEquals(true, type.equals(new MockPeriodType()));\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n         assertEquals(false, type.equals(null));\n         assertEquals(false, type.equals(\"six\"));\n         assertEquals(null, type.getName());\n-        assertEquals(\"DurationType[]\", type.toString());\n-    }\n-\n-    static class MockDurationType extends DurationType {\n+        assertEquals(\"PeriodType[]\", type.toString());\n+    }\n+\n+    static class MockPeriodType extends PeriodType {\n         public String getName() {\n             return null;\n         }\n         public Chronology getChronology() {\n             return null;\n         }\n-        public DurationType withChronology(Chronology chrono) {\n+        public PeriodType withChronology(Chronology chrono) {\n             return null;\n         }\n         public boolean isPrecise() {\n         }\n     }\n \n-    static class MockDurationTypeWithFields extends DurationType {\n+    static class MockPeriodTypeWithFields extends PeriodType {\n         public String getName() {\n             return null;\n         }\n         public DurationField months() {\n             return ISOChronology.getInstanceUTC().months();\n         }\n-        public DurationType withChronology(Chronology chrono) {\n+        public PeriodType withChronology(Chronology chrono) {\n             return null;\n         }\n         public boolean isPrecise() {\n--- a/JodaTime/src/test/org/joda/time/TestDuration_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestDuration_Basics.java\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetDurationType() {\n+    public void testGetPeriodType() {\n         TimePeriod test = new TimePeriod(0L);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n     }\n \n     public void testGetIsPrecise() {\n         \n         assertEquals(false, test1.equals(\"Hello\"));\n         assertEquals(true, test1.equals(new MockDuration(123L)));\n-        assertEquals(false, test1.equals(new TimePeriod(123L, DurationType.getDayHourType())));\n+        assertEquals(false, test1.equals(new TimePeriod(123L, PeriodType.getDayHourType())));\n     }\n     \n     class MockDuration extends AbstractTimePeriod {\n         public MockDuration(long value) {\n             super(value, null);\n         }\n-        protected DurationType checkDurationType(DurationType type) {\n-            return DurationType.getAllType();\n+        protected PeriodType checkPeriodType(PeriodType type) {\n+            return PeriodType.getAllType();\n         }\n     }\n \n         assertEquals(-1, test1.compareTo(test2));\n         assertEquals(+1, test2.compareTo(test1));\n         \n-        TimePeriod test3 = new TimePeriod(321L, DurationType.getAllType());\n+        TimePeriod test3 = new TimePeriod(321L, PeriodType.getAllType());\n         assertEquals(-1, test1.compareTo(test3));\n         assertEquals(+1, test3.compareTo(test1));\n         assertEquals(0, test3.compareTo(test2));\n         assertEquals(false, test1.isEqual(test2));\n         assertEquals(false, test2.isEqual(test1));\n         \n-        TimePeriod test3 = new TimePeriod(321L, DurationType.getAllType());\n+        TimePeriod test3 = new TimePeriod(321L, PeriodType.getAllType());\n         assertEquals(false, test1.isEqual(test3));\n         assertEquals(false, test3.isEqual(test1));\n         assertEquals(true, test3.isEqual(test2));\n         assertEquals(true, test1.isShorterThan(test2));\n         assertEquals(false, test2.isShorterThan(test1));\n         \n-        TimePeriod test3 = new TimePeriod(321L, DurationType.getAllType());\n+        TimePeriod test3 = new TimePeriod(321L, PeriodType.getAllType());\n         assertEquals(true, test1.isShorterThan(test3));\n         assertEquals(false, test3.isShorterThan(test1));\n         assertEquals(false, test3.isShorterThan(test2));\n         assertEquals(false, test1.isLongerThan(test2));\n         assertEquals(true, test2.isLongerThan(test1));\n         \n-        TimePeriod test3 = new TimePeriod(321L, DurationType.getAllType());\n+        TimePeriod test3 = new TimePeriod(321L, PeriodType.getAllType());\n         assertEquals(false, test1.isLongerThan(test3));\n         assertEquals(true, test3.isLongerThan(test1));\n         assertEquals(false, test3.isLongerThan(test2));\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2);\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2, ISOChronology.getInstance());  // local specified so use it\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2, null);  // no chrono specified so drop back to duration (UTC)\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(new Instant(), -2);  // Instant has no time zone, uses duration's zone (UTC)\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(new DateTime(), -2);  // DateTime has local time zone\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(null, -2);  // null has no time zone, uses duration's zone (UTC)\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         MutableDateTime mdt = new MutableDateTime();\n         test.addInto(mdt, -2);  // MutableDateTime has a chronology, use it\n         assertEquals(expected, mdt.getMillis());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testWithDurationTypeUsingTotalMillis1() {\n+    public void testWithPeriodTypeUsingTotalMillis1() {\n         TimePeriod test = new TimePeriod(123L);\n-        TimePeriod result = test.withDurationTypeUsingTotalMillis(DurationType.getAllType());\n+        TimePeriod result = test.withPeriodTypeUsingTotalMillis(PeriodType.getAllType());\n         assertSame(test, result);\n     }\n \n-    public void testWithDurationTypeUsingTotalMillis2() {\n+    public void testWithPeriodTypeUsingTotalMillis2() {\n         TimePeriod test = new TimePeriod(3123L);\n-        TimePeriod result = test.withDurationTypeUsingTotalMillis(DurationType.getDayHourType());\n+        TimePeriod result = test.withPeriodTypeUsingTotalMillis(PeriodType.getDayHourType());\n         assertEquals(3, result.getSeconds());\n         assertEquals(123, result.getMillis());\n         assertEquals(3123L, result.getTotalMillis());\n-        assertEquals(DurationType.getDayHourType(), result.getDurationType());\n-    }\n-\n-    public void testWithDurationTypeUsingTotalMillis3() {\n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType());\n+        assertEquals(PeriodType.getDayHourType(), result.getPeriodType());\n+    }\n+\n+    public void testWithPeriodTypeUsingTotalMillis3() {\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType());\n         try {\n-            test.withDurationTypeUsingTotalMillis(DurationType.getDayHourType());\n+            test.withPeriodTypeUsingTotalMillis(PeriodType.getDayHourType());\n             fail();\n         } catch (IllegalStateException ex) {}\n     }\n \n-    public void testWithDurationTypeUsingTotalMillis4() {\n+    public void testWithPeriodTypeUsingTotalMillis4() {\n         TimePeriod test = new TimePeriod(3123L);\n-        TimePeriod result = test.withDurationTypeUsingTotalMillis(null);\n+        TimePeriod result = test.withPeriodTypeUsingTotalMillis(null);\n         assertEquals(3, result.getSeconds());\n         assertEquals(123, result.getMillis());\n         assertEquals(3123L, result.getTotalMillis());\n-        assertEquals(DurationType.getAllType(), result.getDurationType());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testWithDurationTypeUsingFields1() {\n+        assertEquals(PeriodType.getAllType(), result.getPeriodType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithPeriodTypeUsingFields1() {\n         TimePeriod test = new TimePeriod(123L);\n-        TimePeriod result = test.withDurationTypeUsingFields(DurationType.getAllType());\n+        TimePeriod result = test.withPeriodTypeUsingFields(PeriodType.getAllType());\n         assertSame(test, result);\n     }\n \n-    public void testWithDurationTypeUsingFields2() {\n+    public void testWithPeriodTypeUsingFields2() {\n         TimePeriod test = new TimePeriod(3123L);\n-        TimePeriod result = test.withDurationTypeUsingFields(DurationType.getDayHourType());\n+        TimePeriod result = test.withPeriodTypeUsingFields(PeriodType.getDayHourType());\n         assertEquals(3, result.getSeconds());\n         assertEquals(123, result.getMillis());\n         assertEquals(3123L, result.getTotalMillis());\n-        assertEquals(DurationType.getDayHourType(), result.getDurationType());\n-    }\n-\n-    public void testWithDurationTypeUsingFields3() {\n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType());\n+        assertEquals(PeriodType.getDayHourType(), result.getPeriodType());\n+    }\n+\n+    public void testWithPeriodTypeUsingFields3() {\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType());\n         try {\n-            test.withDurationTypeUsingFields(DurationType.getDayHourType());\n+            test.withPeriodTypeUsingFields(PeriodType.getDayHourType());\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n \n-    public void testWithDurationTypeUsingFields4() {\n+    public void testWithPeriodTypeUsingFields4() {\n         TimePeriod test = new TimePeriod(3123L);\n-        TimePeriod result = test.withDurationTypeUsingFields(null);\n+        TimePeriod result = test.withPeriodTypeUsingFields(null);\n         assertEquals(3, result.getSeconds());\n         assertEquals(123, result.getMillis());\n         assertEquals(3123L, result.getTotalMillis());\n-        assertEquals(DurationType.getAllType(), result.getDurationType());\n-    }\n-\n-    public void testWithDurationTypeUsingFields5() {\n-        TimePeriod test = new TimePeriod(1, 2, 0, 4, 5, 6, 7, 8, DurationType.getAllType());\n-        TimePeriod result = test.withDurationTypeUsingFields(DurationType.getYearMonthType());\n-        assertEquals(DurationType.getYearMonthType(), result.getDurationType());\n+        assertEquals(PeriodType.getAllType(), result.getPeriodType());\n+    }\n+\n+    public void testWithPeriodTypeUsingFields5() {\n+        TimePeriod test = new TimePeriod(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.getAllType());\n+        TimePeriod result = test.withPeriodTypeUsingFields(PeriodType.getYearMonthType());\n+        assertEquals(PeriodType.getYearMonthType(), result.getPeriodType());\n         assertEquals(1, result.getYears());\n         assertEquals(2, result.getMonths());\n         assertEquals(0, result.getWeeks());\n \n     //-----------------------------------------------------------------------\n     public void testWithFieldsNormalized1() {\n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 61, 8, DurationType.getPreciseAllType());\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 61, 8, PeriodType.getPreciseAllType());\n         TimePeriod result = test.withFieldsNormalized();\n         assertEquals(1, result.getYears());\n         assertEquals(2, result.getMonths());\n     }\n \n     public void testWithFieldsNormalized2() {\n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 61, 8, DurationType.getAllType());\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 61, 8, PeriodType.getAllType());\n         try {\n             test.withFieldsNormalized();\n             fail();\n--- a/JodaTime/src/test/org/joda/time/TestDuration_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestDuration_Constructors.java\n      */\n     public void testZERO() throws Throwable {\n         MillisDuration test = MillisDuration.ZERO;\n-        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n         MillisDuration test = new MillisDuration(length);\n-        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testConstructor_long_DurationType1() throws Throwable {\n+    public void testConstructor_long_PeriodType1() throws Throwable {\n         long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n         MillisDuration test = new MillisDuration(length, null);\n-        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(length, test.getTotalMillis());\n     }\n \n-    public void testConstructor_long_DurationType2() throws Throwable {\n+    public void testConstructor_long_PeriodType2() throws Throwable {\n         long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MillisDuration test = new MillisDuration(length, DurationType.getMillisType());\n-        assertEquals(DurationType.getMillisType(), test.getDurationType());\n+        MillisDuration test = new MillisDuration(length, PeriodType.getMillisType());\n+        assertEquals(PeriodType.getMillisType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(length, test.getTotalMillis());\n     }\n \n-    public void testConstructor_long_DurationType3() throws Throwable {\n+    public void testConstructor_long_PeriodType3() throws Throwable {\n         long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MillisDuration test = new MillisDuration(length, DurationType.getPreciseDayHourType());\n-        assertEquals(DurationType.getPreciseDayHourType(), test.getDurationType());\n+        MillisDuration test = new MillisDuration(length, PeriodType.getPreciseDayHourType());\n+        assertEquals(PeriodType.getPreciseDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(length, test.getTotalMillis());\n     }\n \n-    public void testConstructor_long_DurationType4() throws Throwable {\n+    public void testConstructor_long_PeriodType4() throws Throwable {\n         long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MillisDuration test = new MillisDuration(length, DurationType.getPreciseAllType().withMillisRemoved());\n-        assertEquals(DurationType.getPreciseAllType().withMillisRemoved(), test.getDurationType());\n+        MillisDuration test = new MillisDuration(length, PeriodType.getPreciseAllType().withMillisRemoved());\n+        assertEquals(PeriodType.getPreciseAllType().withMillisRemoved(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n      */\n     public void testConstructor_4int1() throws Throwable {\n         MillisDuration test = new MillisDuration(5, 6, 7, 8);\n-        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n      */\n     public void testConstructor_8int1() throws Throwable {\n         MillisDuration test = new MillisDuration(1, 2, 3, 4, 5, 6, 7, 8);\n-        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(3, test.getWeeks());\n     /**\n      * Test constructor (8ints)\n      */\n-    public void testConstructor_8int__DurationType1() throws Throwable {\n+    public void testConstructor_8int__PeriodType1() throws Throwable {\n         MillisDuration test = new MillisDuration(1, 2, 3, 4, 5, 6, 7, 8, null);\n-        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(3, test.getWeeks());\n             7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.getTotalMillis());\n     }\n \n-    public void testConstructor_8int__DurationType2() throws Throwable {\n-        MillisDuration test = new MillisDuration(0, 0, 0, 0, 5, 6, 7, 8, DurationType.getPreciseDayHourType());\n-        assertEquals(DurationType.getPreciseDayHourType(), test.getDurationType());\n+    public void testConstructor_8int__PeriodType2() throws Throwable {\n+        MillisDuration test = new MillisDuration(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.getPreciseDayHourType());\n+        assertEquals(PeriodType.getPreciseDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n             7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.getTotalMillis());\n     }\n \n-    public void testConstructor_8int__DurationType3() throws Throwable {\n+    public void testConstructor_8int__PeriodType3() throws Throwable {\n         try {\n-            new MillisDuration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getDayHourType());\n+            new MillisDuration(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getDayHourType());\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         MillisDuration test = new MillisDuration(dt1.getMillis(), dt2.getMillis());\n-        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         MillisDuration test = new MillisDuration(dt1.getMillis(), dt2.getMillis());\n-        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testConstructor_long_long_DurationType1() throws Throwable {\n+    public void testConstructor_long_long_PeriodType1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         MillisDuration test = new MillisDuration(dt1.getMillis(), dt2.getMillis(), null);\n-        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n-        assertEquals(1, test.getYears());\n-        assertEquals(1, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(1, test.getDays());\n-        assertEquals(1, test.getHours());\n-        assertEquals(1, test.getMinutes());\n-        assertEquals(1, test.getSeconds());\n-        assertEquals(1, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n-    }\n-\n-    public void testConstructor_long_long_DurationType2() throws Throwable {\n+        assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(1, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(1, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(1, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_long_long_PeriodType2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);\n-        MillisDuration test = new MillisDuration(dt1.getMillis(), dt2.getMillis(), DurationType.getPreciseDayHourType());\n-        assertEquals(DurationType.getPreciseDayHourType(), test.getDurationType());\n+        MillisDuration test = new MillisDuration(dt1.getMillis(), dt2.getMillis(), PeriodType.getPreciseDayHourType());\n+        assertEquals(PeriodType.getPreciseDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n     }\n \n-    public void testConstructor_long_long_DurationType3() throws Throwable {\n+    public void testConstructor_long_long_PeriodType3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        MillisDuration test = new MillisDuration(dt1.getMillis(), dt2.getMillis(), DurationType.getPreciseAllType().withMillisRemoved());\n-        assertEquals(DurationType.getPreciseAllType().withMillisRemoved(), test.getDurationType());\n+        MillisDuration test = new MillisDuration(dt1.getMillis(), dt2.getMillis(), PeriodType.getPreciseAllType().withMillisRemoved());\n+        assertEquals(PeriodType.getPreciseAllType().withMillisRemoved(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         MillisDuration test = new MillisDuration(dt1, dt2);\n-        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         MillisDuration test = new MillisDuration(dt1, dt2);\n-        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         MillisDuration test = new MillisDuration(dt1, dt2);\n-        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());\n         assertEquals(3, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n         MillisDuration test = new MillisDuration(dt1, dt2);\n-        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());\n         assertEquals(-3, test.getYears());\n         assertEquals(-1, test.getMonths());\n         assertEquals(-1, test.getWeeks());\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n         MillisDuration test = new MillisDuration(dt1, dt2);\n-        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testConstructor_RI_RI_DurationType1() throws Throwable {\n+    public void testConstructor_RI_RI_PeriodType1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         MillisDuration test = new MillisDuration(dt1, dt2, null);\n-        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n-        assertEquals(1, test.getYears());\n-        assertEquals(1, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(1, test.getDays());\n-        assertEquals(1, test.getHours());\n-        assertEquals(1, test.getMinutes());\n-        assertEquals(1, test.getSeconds());\n-        assertEquals(1, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n-    }\n-\n-    public void testConstructor_RI_RI_DurationType2() throws Throwable {\n+        assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(1, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(1, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(1, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_RI_RI_PeriodType2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);\n-        MillisDuration test = new MillisDuration(dt1, dt2, DurationType.getPreciseDayHourType());\n-        assertEquals(DurationType.getPreciseDayHourType(), test.getDurationType());\n+        MillisDuration test = new MillisDuration(dt1, dt2, PeriodType.getPreciseDayHourType());\n+        assertEquals(PeriodType.getPreciseDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n     }\n \n-    public void testConstructor_RI_RI_DurationType3() throws Throwable {\n+    public void testConstructor_RI_RI_PeriodType3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        MillisDuration test = new MillisDuration(dt1, dt2, DurationType.getPreciseAllType().withMillisRemoved());\n-        assertEquals(DurationType.getPreciseAllType().withMillisRemoved(), test.getDurationType());\n+        MillisDuration test = new MillisDuration(dt1, dt2, PeriodType.getPreciseAllType().withMillisRemoved());\n+        assertEquals(PeriodType.getPreciseAllType().withMillisRemoved(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.getTotalMillis());\n     }\n \n-    public void testConstructor_RI_RI_DurationType4() throws Throwable {\n+    public void testConstructor_RI_RI_PeriodType4() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        MillisDuration test = new MillisDuration(dt1, dt2, DurationType.getPreciseAllType());\n-        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n+        MillisDuration test = new MillisDuration(dt1, dt2, PeriodType.getPreciseAllType());\n+        assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());\n         assertEquals(3, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         assertEquals(dt2.getMillis() - TEST_TIME_NOW, test.getTotalMillis());\n     }\n \n-    public void testConstructor_RI_RI_DurationType5() throws Throwable {\n+    public void testConstructor_RI_RI_PeriodType5() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n-        MillisDuration test = new MillisDuration(dt1, dt2, DurationType.getPreciseAllType());\n-        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n+        MillisDuration test = new MillisDuration(dt1, dt2, PeriodType.getPreciseAllType());\n+        assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n      */\n     public void testConstructor_Object1() throws Throwable {\n         MillisDuration test = new MillisDuration(\"P1Y2M3D\");\n-        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(0, test.getWeeks());\n \n     public void testConstructor_Object2() throws Throwable {\n         MillisDuration test = new MillisDuration((Object) null);\n-        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     public void testConstructor_Object3() throws Throwable {\n-        MillisDuration base = new MillisDuration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getPreciseDayHourType());\n+        MillisDuration base = new MillisDuration(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getPreciseDayHourType());\n         MillisDuration test = new MillisDuration(base);\n-        assertEquals(DurationType.getPreciseDayHourType(), test.getDurationType());\n+        assertEquals(PeriodType.getPreciseDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         MillisDuration base = new MillisDuration(dt1, dt2);  // AllType and precise\n         MillisDuration test = new MillisDuration(base);\n-        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     public void testConstructor_Object5() throws Throwable {\n-        MillisDuration base = new MillisDuration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType());\n+        MillisDuration base = new MillisDuration(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType());\n         try {\n             new MillisDuration(base);\n             fail();\n     /**\n      * Test constructor (Object)\n      */\n-    public void testConstructor_Object_DurationType1() throws Throwable {\n-        MillisDuration test = new MillisDuration(\"P1Y2M3D\", DurationType.getPreciseYearMonthType());\n-        assertEquals(DurationType.getPreciseYearMonthType(), test.getDurationType());\n+    public void testConstructor_Object_PeriodType1() throws Throwable {\n+        MillisDuration test = new MillisDuration(\"P1Y2M3D\", PeriodType.getPreciseYearMonthType());\n+        assertEquals(PeriodType.getPreciseYearMonthType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(0, test.getWeeks());\n             (365L + 2L * 30L + 3L) * DateTimeConstants.MILLIS_PER_DAY, test.getTotalMillis());\n     }\n \n-    public void testConstructor_Object_DurationType2() throws Throwable {\n-        MillisDuration test = new MillisDuration((Object) null, DurationType.getPreciseYearMonthType());\n-        assertEquals(DurationType.getPreciseYearMonthType(), test.getDurationType());\n+    public void testConstructor_Object_PeriodType2() throws Throwable {\n+        MillisDuration test = new MillisDuration((Object) null, PeriodType.getPreciseYearMonthType());\n+        assertEquals(PeriodType.getPreciseYearMonthType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(0, test.getTotalMillis());\n     }\n \n-    public void testConstructor_Object_DurationType3() throws Throwable {\n+    public void testConstructor_Object_PeriodType3() throws Throwable {\n         MillisDuration test = new MillisDuration(\n-            new MillisDuration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getPreciseDayHourType()), DurationType.getPreciseYearMonthType());\n-        assertEquals(DurationType.getPreciseYearMonthType(), test.getDurationType());\n+            new MillisDuration(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getPreciseDayHourType()), PeriodType.getPreciseYearMonthType());\n+        assertEquals(PeriodType.getPreciseYearMonthType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n             3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());\n     }\n \n-    public void testConstructor_Object_DurationType4() throws Throwable {\n-        MillisDuration test = new MillisDuration(new MillisDuration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getPreciseDayHourType()), null);\n-        assertEquals(DurationType.getPreciseDayHourType(), test.getDurationType());\n+    public void testConstructor_Object_PeriodType4() throws Throwable {\n+        MillisDuration test = new MillisDuration(new MillisDuration(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getPreciseDayHourType()), null);\n+        assertEquals(PeriodType.getPreciseDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n--- a/JodaTime/src/test/org/joda/time/TestMutablePeriod_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutablePeriod_Basics.java\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetDurationType() {\n+    public void testGetPeriodType() {\n         MutableTimePeriod test = new MutableTimePeriod();\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n     }\n \n     public void testGetIsPrecise() {\n         \n         assertEquals(false, test1.equals(\"Hello\"));\n         assertEquals(true, test1.equals(new MockMutablePeriod(123L)));\n-        assertEquals(false, test1.equals(new TimePeriod(123L, DurationType.getDayHourType())));\n+        assertEquals(false, test1.equals(new TimePeriod(123L, PeriodType.getDayHourType())));\n     }\n     \n     class MockMutablePeriod extends AbstractTimePeriod {\n         public MockMutablePeriod(long value) {\n             super(value, null);\n         }\n-        protected DurationType checkDurationType(DurationType type) {\n-            return DurationType.getAllType();\n+        protected PeriodType checkPeriodType(PeriodType type) {\n+            return PeriodType.getAllType();\n         }\n     }\n \n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2);\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2, ISOChronology.getInstance());  // local specified so use it\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2, null);  // no chrono specified so drop back to duration (UTC)\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(new Instant(), -2);  // Instant has no time zone, uses duration's zone (UTC)\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(new DateTime(), -2);  // DateTime has local time zone\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(null, -2);  // null has no time zone, uses duration's zone (UTC)\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         MutableDateTime mdt = new MutableDateTime();\n         test.addInto(mdt, -2);  // MutableDateTime has a chronology, use it\n         assertEquals(expected, mdt.getMillis());\n     public void testCopy() {\n         MutableTimePeriod test = new MutableTimePeriod(123L);\n         MutableTimePeriod copy = test.copy();\n-        assertEquals(test.getDurationType(), copy.getDurationType());\n+        assertEquals(test.getPeriodType(), copy.getPeriodType());\n         assertEquals(test.isPrecise(), copy.isPrecise());\n         assertEquals(test.toDurationMillis(), copy.toDurationMillis());\n     }\n     public void testClone() {\n         MutableTimePeriod test = new MutableTimePeriod(123L);\n         MutableTimePeriod copy = (MutableTimePeriod) test.clone();\n-        assertEquals(test.getDurationType(), copy.getDurationType());\n+        assertEquals(test.getPeriodType(), copy.getPeriodType());\n         assertEquals(test.isPrecise(), copy.isPrecise());\n         assertEquals(test.toDurationMillis(), copy.toDurationMillis());\n     }\n--- a/JodaTime/src/test/org/joda/time/TestMutablePeriod_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutablePeriod_Constructors.java\n      */\n     public void testConstructor1() throws Throwable {\n         MutableTimePeriod test = new MutableTimePeriod();\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Test constructor (DurationType)\n+     * Test constructor (PeriodType)\n      */\n-    public void testConstructor_DurationType1() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod(DurationType.getYearMonthType());\n-        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n+    public void testConstructor_PeriodType1() throws Throwable {\n+        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getYearMonthType());\n+        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(0, test.toDurationMillis());\n     }\n \n-    public void testConstructor_DurationType2() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod((DurationType) null);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+    public void testConstructor_PeriodType2() throws Throwable {\n+        MutableTimePeriod test = new MutableTimePeriod((PeriodType) null);\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n         MutableTimePeriod test = new MutableTimePeriod(length);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n         MutableTimePeriod test = new MutableTimePeriod(length);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testConstructor_long_DurationType1() throws Throwable {\n+    public void testConstructor_long_PeriodType1() throws Throwable {\n         long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n         MutableTimePeriod test = new MutableTimePeriod(length, null);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         } catch (IllegalStateException ex) {}\n     }\n \n-    public void testConstructor_long_DurationType2() throws Throwable {\n+    public void testConstructor_long_PeriodType2() throws Throwable {\n         long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutableTimePeriod test = new MutableTimePeriod(length, DurationType.getMillisType());\n-        assertEquals(DurationType.getMillisType(), test.getDurationType());\n+        MutableTimePeriod test = new MutableTimePeriod(length, PeriodType.getMillisType());\n+        assertEquals(PeriodType.getMillisType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(length, test.toDurationMillis());\n     }\n \n-    public void testConstructor_long_DurationType3() throws Throwable {\n+    public void testConstructor_long_PeriodType3() throws Throwable {\n         long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutableTimePeriod test = new MutableTimePeriod(length, DurationType.getAllType());\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        MutableTimePeriod test = new MutableTimePeriod(length, PeriodType.getAllType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         } catch (IllegalStateException ex) {}\n     }\n \n-    public void testConstructor_long_DurationType4() throws Throwable {\n+    public void testConstructor_long_PeriodType4() throws Throwable {\n         long length =\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutableTimePeriod test = new MutableTimePeriod(length, DurationType.getAllType().withMillisRemoved());\n-        assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n+        MutableTimePeriod test = new MutableTimePeriod(length, PeriodType.getAllType().withMillisRemoved());\n+        assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n      */\n     public void testConstructor_4int1() throws Throwable {\n         MutableTimePeriod test = new MutableTimePeriod(5, 6, 7, 8);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n      */\n     public void testConstructor_8int1() throws Throwable {\n         MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(3, test.getWeeks());\n     /**\n      * Test constructor (8ints)\n      */\n-    public void testConstructor_8int__DurationType1() throws Throwable {\n+    public void testConstructor_8int__PeriodType1() throws Throwable {\n         MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, null);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(3, test.getWeeks());\n         } catch (IllegalStateException ex) {}\n     }\n \n-    public void testConstructor_8int__DurationType2() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod(0, 0, 0, 0, 5, 6, 7, 8, DurationType.getDayHourType());\n-        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+    public void testConstructor_8int__PeriodType2() throws Throwable {\n+        MutableTimePeriod test = new MutableTimePeriod(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.getDayHourType());\n+        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n             7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.toDurationMillis());\n     }\n \n-    public void testConstructor_8int__DurationType3() throws Throwable {\n-        try {\n-            new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getDayHourType());\n+    public void testConstructor_8int__PeriodType3() throws Throwable {\n+        try {\n+            new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getDayHourType());\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         MutableTimePeriod test = new MutableTimePeriod(dt1.getMillis(), dt2.getMillis());\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         MutableTimePeriod test = new MutableTimePeriod(dt1.getMillis(), dt2.getMillis());\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testConstructor_long_long_DurationType1() throws Throwable {\n+    public void testConstructor_long_long_PeriodType1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         MutableTimePeriod test = new MutableTimePeriod(dt1.getMillis(), dt2.getMillis(), null);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         } catch (IllegalStateException ex) {}\n     }\n \n-    public void testConstructor_long_long_DurationType2() throws Throwable {\n+    public void testConstructor_long_long_PeriodType2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);\n-        MutableTimePeriod test = new MutableTimePeriod(dt1.getMillis(), dt2.getMillis(), DurationType.getDayHourType());\n-        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+        MutableTimePeriod test = new MutableTimePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.getDayHourType());\n+        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         } catch (IllegalStateException ex) {}\n     }\n \n-    public void testConstructor_long_long_DurationType3() throws Throwable {\n+    public void testConstructor_long_long_PeriodType3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);\n-        MutableTimePeriod test = new MutableTimePeriod(dt1.getMillis(), dt2.getMillis(), DurationType.getAllType().withMillisRemoved());\n-        assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n+        MutableTimePeriod test = new MutableTimePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.getAllType().withMillisRemoved());\n+        assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         MutableTimePeriod test = new MutableTimePeriod(dt1, dt2);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         MutableTimePeriod test = new MutableTimePeriod(dt1, dt2);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         MutableTimePeriod test = new MutableTimePeriod(dt1, dt2);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(3, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n         MutableTimePeriod test = new MutableTimePeriod(dt1, dt2);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(-3, test.getYears());\n         assertEquals(-1, test.getMonths());\n         assertEquals(-1, test.getWeeks());\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n         MutableTimePeriod test = new MutableTimePeriod(dt1, dt2);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testConstructor_RI_RI_DurationType1() throws Throwable {\n+    public void testConstructor_RI_RI_PeriodType1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         MutableTimePeriod test = new MutableTimePeriod(dt1, dt2, null);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         } catch (IllegalStateException ex) {}\n     }\n \n-    public void testConstructor_RI_RI_DurationType2() throws Throwable {\n+    public void testConstructor_RI_RI_PeriodType2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);\n-        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2, DurationType.getDayHourType());\n-        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2, PeriodType.getDayHourType());\n+        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         } catch (IllegalStateException ex) {}\n     }\n \n-    public void testConstructor_RI_RI_DurationType3() throws Throwable {\n+    public void testConstructor_RI_RI_PeriodType3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);\n-        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2, DurationType.getAllType().withMillisRemoved());\n-        assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n+        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2, PeriodType.getAllType().withMillisRemoved());\n+        assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.toDurationMillis());\n     }\n \n-    public void testConstructor_RI_RI_DurationType4() throws Throwable {\n+    public void testConstructor_RI_RI_PeriodType4() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2, DurationType.getAllType());\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2, PeriodType.getAllType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(3, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         } catch (IllegalStateException ex) {}\n     }\n \n-    public void testConstructor_RI_RI_DurationType5() throws Throwable {\n+    public void testConstructor_RI_RI_PeriodType5() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n-        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2, DurationType.getAllType());\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2, PeriodType.getAllType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n      */\n     public void testConstructor_Object1() throws Throwable {\n         MutableTimePeriod test = new MutableTimePeriod(\"P1Y2M3D\");\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(0, test.getWeeks());\n \n     public void testConstructor_Object2() throws Throwable {\n         MutableTimePeriod test = new MutableTimePeriod((Object) null);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     public void testConstructor_Object3() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()));\n-        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+        MutableTimePeriod test = new MutableTimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()));\n+        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     public void testConstructor_Object4() throws Throwable {\n-        TimePeriod base = new TimePeriod(1, 1, 0, 1, 1, 1, 1, 1, DurationType.getAllType());\n+        TimePeriod base = new TimePeriod(1, 1, 0, 1, 1, 1, 1, 1, PeriodType.getAllType());\n         MutableTimePeriod test = new MutableTimePeriod(base);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Test constructor (Object,DurationType)\n+     * Test constructor (Object,PeriodType)\n      */\n-    public void testConstructor_Object_DurationType1() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod(\"P1Y2M3D\", DurationType.getYearMonthType());\n-        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n+    public void testConstructor_Object_PeriodType1() throws Throwable {\n+        MutableTimePeriod test = new MutableTimePeriod(\"P1Y2M3D\", PeriodType.getYearMonthType());\n+        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         } catch (IllegalStateException ex) {}\n     }\n \n-    public void testConstructor_Object_DurationType2() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod((Object) null, DurationType.getYearMonthType());\n-        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n+    public void testConstructor_Object_PeriodType2() throws Throwable {\n+        MutableTimePeriod test = new MutableTimePeriod((Object) null, PeriodType.getYearMonthType());\n+        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(0, test.toDurationMillis());\n     }\n \n-    public void testConstructor_Object_DurationType3() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), DurationType.getYearMonthType());\n-        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n+    public void testConstructor_Object_PeriodType3() throws Throwable {\n+        MutableTimePeriod test = new MutableTimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()), PeriodType.getYearMonthType());\n+        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n             3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.toDurationMillis());\n     }\n \n-    public void testConstructor_Object_DurationType4() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), null);\n-        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+    public void testConstructor_Object_PeriodType4() throws Throwable {\n+        MutableTimePeriod test = new MutableTimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()), null);\n+        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n--- a/JodaTime/src/test/org/joda/time/TestMutablePeriod_Updates.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutablePeriod_Updates.java\n     }\n \n     public void testSetTimePeriod_8ints2() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getMillisType());\n+        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getMillisType());\n         try {\n             test.setTimePeriod(11, 12, 13, 14, 15, 16, 17, 18);\n             fail();\n     }\n \n     public void testSetTimePeriod_8ints3() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getMillisType());\n+        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getMillisType());\n         test.setTimePeriod(0, 0, 0, 0, 0, 0, 0, 18);\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testSetTimePeriod_RP2() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getMillisType());\n+        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getMillisType());\n         try {\n             test.setTimePeriod(new MutableTimePeriod(11, 12, 13, 14, 15, 16, 17, 18));\n             fail();\n     }\n \n     public void testSetTimePeriod_RP3() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getMillisType());\n+        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getMillisType());\n         test.setTimePeriod(new MutableTimePeriod(0, 0, 0, 0, 0, 0, 0, 18));\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testSetTimePeriod_long_long_NoYears() {\n-        MutableTimePeriod test = new MutableTimePeriod(DurationType.getAllType().withYearsRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getAllType().withYearsRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setTimePeriod(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetTimePeriod_long_long_NoMonths() {\n-        MutableTimePeriod test = new MutableTimePeriod(DurationType.getAllType().withMonthsRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getAllType().withMonthsRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setTimePeriod(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetTimePeriod_long_long_NoWeeks() {\n-        MutableTimePeriod test = new MutableTimePeriod(DurationType.getAllType().withWeeksRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getAllType().withWeeksRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setTimePeriod(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetTimePeriod_long_long_NoDays() {\n-        MutableTimePeriod test = new MutableTimePeriod(DurationType.getAllType().withDaysRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getAllType().withDaysRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setTimePeriod(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetTimePeriod_long_long_NoHours() {\n-        MutableTimePeriod test = new MutableTimePeriod(DurationType.getAllType().withHoursRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getAllType().withHoursRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setTimePeriod(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetTimePeriod_long_long_NoMinutes() {\n-        MutableTimePeriod test = new MutableTimePeriod(DurationType.getAllType().withMinutesRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getAllType().withMinutesRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setTimePeriod(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetTimePeriod_long_long_NoSeconds() {\n-        MutableTimePeriod test = new MutableTimePeriod(DurationType.getAllType().withSecondsRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getAllType().withSecondsRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setTimePeriod(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetTimePeriod_long_long_NoMillis() {\n-        MutableTimePeriod test = new MutableTimePeriod(DurationType.getAllType().withMillisRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getAllType().withMillisRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setTimePeriod(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetTimePeriod_long3() {\n-        MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearMonthType());\n+        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getPreciseYearMonthType());\n         test.setTimePeriod(\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n     }\n \n     public void testSetTimePeriod_long4() {\n-        MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearWeekType());\n+        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getPreciseYearWeekType());\n         test.setTimePeriod(\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearMonthType().withYearsRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getPreciseYearMonthType().withYearsRemoved());\n         test.setTimePeriod(ms);\n         assertEquals(0, test.getYears());\n         assertEquals(15, test.getMonths()); // totalDays=365+85=450=15*30\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearMonthType().withMonthsRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getPreciseYearMonthType().withMonthsRemoved());\n         test.setTimePeriod(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(0, test.getMonths());\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearWeekType().withWeeksRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getPreciseYearWeekType().withWeeksRemoved());\n         test.setTimePeriod(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(0, test.getMonths());\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearMonthType().withDaysRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getPreciseYearMonthType().withDaysRemoved());\n         test.setTimePeriod(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearMonthType().withHoursRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getPreciseYearMonthType().withHoursRemoved());\n         test.setTimePeriod(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearMonthType().withMinutesRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getPreciseYearMonthType().withMinutesRemoved());\n         test.setTimePeriod(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearMonthType().withSecondsRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getPreciseYearMonthType().withSecondsRemoved());\n         test.setTimePeriod(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearMonthType().withMillisRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getPreciseYearMonthType().withMillisRemoved());\n         test.setTimePeriod(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n     }\n \n     public void testAdd_8ints2() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getYearMonthType());\n+        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getYearMonthType());\n         try {\n             test.add(1, 2, 3, 4, 5, 6, 7, 8);\n             fail();\n     }\n \n     public void testAdd_long2() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getPreciseYearMonthType());\n+        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getPreciseYearMonthType());\n         long ms =\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n     }\n \n     public void testAdd_long3() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getPreciseYearMonthType());\n+        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getPreciseYearMonthType());\n         long ms =0L;\n         test.add(ms);\n         assertEquals(0, test.getYears());\n     }\n \n     public void testAdd_RD2() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getPreciseYearMonthType());\n+        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getPreciseYearMonthType());\n         long ms =\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n     }\n \n     public void testAdd_RD3() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getPreciseYearMonthType());\n+        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getPreciseYearMonthType());\n         long ms =0L;\n         test.add(new Duration(ms));\n         assertEquals(0, test.getYears());\n \n     public void testAdd_RP2() {\n         MutableTimePeriod test = new MutableTimePeriod(100L);  // All type\n-        test.add(new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getPreciseAllType()));\n+        test.add(new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getPreciseAllType()));\n         assertEquals(1, test.getYears());  // add field value, ignore different types\n         assertEquals(2, test.getMonths());  // add field value, ignore different types\n         assertEquals(3, test.getWeeks());  // add field value, ignore different types\n     }\n \n     public void testAdd_RP3() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getPreciseYearMonthType());\n+        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getPreciseYearMonthType());\n         test.add(new TimePeriod(0L));\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testAdd_RP4() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 0, 4, 5, 6, 7, 8, DurationType.getYearMonthType());\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.getYearMonthType());\n         try {\n             test.add(new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8));  // cannot set weeks\n             fail();\n     }\n \n     public void testAdd_RInterval4() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getPreciseYearMonthType());\n+        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getPreciseYearMonthType());\n         test.add(new Interval(0L, 0L));\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testAdd_RInterval5() {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 0, 0, 0, 8);\n-        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getYearMonthType());\n+        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getYearMonthType());\n         test.add(new Interval(dt1, dt2));\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     }\n \n     public void testNormalize2() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 14, 0, 36, 29, 66, 67, 1008, DurationType.getPreciseYearMonthType());\n+        MutableTimePeriod test = new MutableTimePeriod(1, 14, 0, 36, 29, 66, 67, 1008, PeriodType.getPreciseYearMonthType());\n         //   365 + 14*30 + 6 days\n         // extra year created from 12 months of 30 days plus 5 extra days\n         // 2*365 +  2*30 + 1 day\n--- a/JodaTime/src/test/org/joda/time/TestPeriod_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestPeriod_Basics.java\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetDurationType() {\n+    public void testGetPeriodType() {\n         TimePeriod test = new TimePeriod(0L);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n     }\n \n     public void testGetIsPrecise() {\n         \n         assertEquals(false, test1.equals(\"Hello\"));\n         assertEquals(true, test1.equals(new MockPeriod(123L)));\n-        assertEquals(false, test1.equals(new TimePeriod(123L, DurationType.getDayHourType())));\n+        assertEquals(false, test1.equals(new TimePeriod(123L, PeriodType.getDayHourType())));\n     }\n     \n     class MockPeriod extends AbstractTimePeriod {\n         public MockPeriod(long value) {\n             super(value, null);\n         }\n-        protected DurationType checkDurationType(DurationType type) {\n-            return DurationType.getAllType();\n+        protected PeriodType checkPeriodType(PeriodType type) {\n+            return PeriodType.getAllType();\n         }\n     }\n \n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2);\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2, ISOChronology.getInstance());  // local specified so use it\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2, null);  // no chrono specified so drop back to duration (UTC)\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(new Instant(), -2);  // Instant has no time zone, uses duration's zone (UTC)\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(new DateTime(), -2);  // DateTime has local time zone\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(null, -2);  // null has no time zone, uses duration's zone (UTC)\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         MutableDateTime mdt = new MutableDateTime();\n         test.addInto(mdt, -2);  // MutableDateTime has a chronology, use it\n         assertEquals(expected, mdt.getMillis());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testWithDurationTypeRetainDuration1() {\n-        TimePeriod test = new TimePeriod(123L);\n-        TimePeriod result = test.withDurationTypeRetainDuration(DurationType.getAllType());\n+    public void testWithPeriodTypeRetainDuration1() {\n+        TimePeriod test = new TimePeriod(123L);\n+        TimePeriod result = test.withPeriodTypeRetainDuration(PeriodType.getAllType());\n         assertSame(test, result);\n     }\n \n-    public void testWithDurationTypeRetainDuration2() {\n+    public void testWithPeriodTypeRetainDuration2() {\n         TimePeriod test = new TimePeriod(3123L);\n-        TimePeriod result = test.withDurationTypeRetainDuration(DurationType.getDayHourType());\n+        TimePeriod result = test.withPeriodTypeRetainDuration(PeriodType.getDayHourType());\n         assertEquals(3, result.getSeconds());\n         assertEquals(123, result.getMillis());\n         assertEquals(3123L, result.toDurationMillis());\n-        assertEquals(DurationType.getDayHourType(), result.getDurationType());\n-    }\n-\n-    public void testWithDurationTypeRetainDuration3() {\n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType());\n+        assertEquals(PeriodType.getDayHourType(), result.getPeriodType());\n+    }\n+\n+    public void testWithPeriodTypeRetainDuration3() {\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType());\n         try {\n-            test.withDurationTypeRetainDuration(DurationType.getDayHourType());\n+            test.withPeriodTypeRetainDuration(PeriodType.getDayHourType());\n             fail();\n         } catch (IllegalStateException ex) {}\n     }\n \n-    public void testWithDurationTypeRetainDuration4() {\n+    public void testWithPeriodTypeRetainDuration4() {\n         TimePeriod test = new TimePeriod(3123L);\n-        TimePeriod result = test.withDurationTypeRetainDuration(null);\n+        TimePeriod result = test.withPeriodTypeRetainDuration(null);\n         assertEquals(3, result.getSeconds());\n         assertEquals(123, result.getMillis());\n         assertEquals(3123L, result.toDurationMillis());\n-        assertEquals(DurationType.getAllType(), result.getDurationType());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testWithDurationType1() {\n-        TimePeriod test = new TimePeriod(123L);\n-        TimePeriod result = test.withDurationType(DurationType.getAllType());\n+        assertEquals(PeriodType.getAllType(), result.getPeriodType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithPeriodType1() {\n+        TimePeriod test = new TimePeriod(123L);\n+        TimePeriod result = test.withPeriodType(PeriodType.getAllType());\n         assertSame(test, result);\n     }\n \n-    public void testWithDurationType2() {\n+    public void testWithPeriodType2() {\n         TimePeriod test = new TimePeriod(3123L);\n-        TimePeriod result = test.withDurationType(DurationType.getDayHourType());\n+        TimePeriod result = test.withPeriodType(PeriodType.getDayHourType());\n         assertEquals(3, result.getSeconds());\n         assertEquals(123, result.getMillis());\n         assertEquals(3123L, result.toDurationMillis());\n-        assertEquals(DurationType.getDayHourType(), result.getDurationType());\n-    }\n-\n-    public void testWithDurationType3() {\n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType());\n+        assertEquals(PeriodType.getDayHourType(), result.getPeriodType());\n+    }\n+\n+    public void testWithPeriodType3() {\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType());\n         try {\n-            test.withDurationType(DurationType.getDayHourType());\n+            test.withPeriodType(PeriodType.getDayHourType());\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n \n-    public void testWithDurationType4() {\n+    public void testWithPeriodType4() {\n         TimePeriod test = new TimePeriod(3123L);\n-        TimePeriod result = test.withDurationType(null);\n+        TimePeriod result = test.withPeriodType(null);\n         assertEquals(3, result.getSeconds());\n         assertEquals(123, result.getMillis());\n         assertEquals(3123L, result.toDurationMillis());\n-        assertEquals(DurationType.getAllType(), result.getDurationType());\n-    }\n-\n-    public void testWithDurationType5() {\n-        TimePeriod test = new TimePeriod(1, 2, 0, 4, 5, 6, 7, 8, DurationType.getAllType());\n-        TimePeriod result = test.withDurationType(DurationType.getYearMonthType());\n-        assertEquals(DurationType.getYearMonthType(), result.getDurationType());\n+        assertEquals(PeriodType.getAllType(), result.getPeriodType());\n+    }\n+\n+    public void testWithPeriodType5() {\n+        TimePeriod test = new TimePeriod(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.getAllType());\n+        TimePeriod result = test.withPeriodType(PeriodType.getYearMonthType());\n+        assertEquals(PeriodType.getYearMonthType(), result.getPeriodType());\n         assertEquals(1, result.getYears());\n         assertEquals(2, result.getMonths());\n         assertEquals(0, result.getWeeks());\n \n     //-----------------------------------------------------------------------\n     public void testWithFieldsNormalized1() {\n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 61, 8, DurationType.getPreciseAllType());\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 61, 8, PeriodType.getPreciseAllType());\n         TimePeriod result = test.withFieldsNormalized();\n         assertEquals(1, result.getYears());\n         assertEquals(2, result.getMonths());\n     }\n \n     public void testWithFieldsNormalized2() {\n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 61, 8, DurationType.getAllType());\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 61, 8, PeriodType.getAllType());\n         try {\n             test.withFieldsNormalized();\n             fail();\n--- a/JodaTime/src/test/org/joda/time/TestPeriod_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestPeriod_Constructors.java\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n         TimePeriod test = new TimePeriod(length);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n         TimePeriod test = new TimePeriod(length);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testConstructor_long_DurationType1() throws Throwable {\n+    public void testConstructor_long_PeriodType1() throws Throwable {\n         long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n         TimePeriod test = new TimePeriod(length, null);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         } catch (IllegalStateException ex) {}\n     }\n \n-    public void testConstructor_long_DurationType2() throws Throwable {\n+    public void testConstructor_long_PeriodType2() throws Throwable {\n         long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        TimePeriod test = new TimePeriod(length, DurationType.getMillisType());\n-        assertEquals(DurationType.getMillisType(), test.getDurationType());\n+        TimePeriod test = new TimePeriod(length, PeriodType.getMillisType());\n+        assertEquals(PeriodType.getMillisType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(length, test.toDurationMillis());\n     }\n \n-    public void testConstructor_long_DurationType3() throws Throwable {\n+    public void testConstructor_long_PeriodType3() throws Throwable {\n         long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        TimePeriod test = new TimePeriod(length, DurationType.getDayHourType());\n-        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+        TimePeriod test = new TimePeriod(length, PeriodType.getDayHourType());\n+        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         } catch (IllegalStateException ex) {}\n     }\n \n-    public void testConstructor_long_DurationType4() throws Throwable {\n+    public void testConstructor_long_PeriodType4() throws Throwable {\n         long length =\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        TimePeriod test = new TimePeriod(length, DurationType.getAllType().withMillisRemoved());\n-        assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n+        TimePeriod test = new TimePeriod(length, PeriodType.getAllType().withMillisRemoved());\n+        assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n      */\n     public void testConstructor_4int1() throws Throwable {\n         TimePeriod test = new TimePeriod(5, 6, 7, 8);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n      */\n     public void testConstructor_8int1() throws Throwable {\n         TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(3, test.getWeeks());\n     /**\n      * Test constructor (8ints)\n      */\n-    public void testConstructor_8int__DurationType1() throws Throwable {\n+    public void testConstructor_8int__PeriodType1() throws Throwable {\n         TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, null);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(3, test.getWeeks());\n         } catch (IllegalStateException ex) {}\n     }\n \n-    public void testConstructor_8int__DurationType2() throws Throwable {\n-        TimePeriod test = new TimePeriod(0, 0, 0, 0, 5, 6, 7, 8, DurationType.getDayHourType());\n-        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+    public void testConstructor_8int__PeriodType2() throws Throwable {\n+        TimePeriod test = new TimePeriod(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.getDayHourType());\n+        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n             7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.toDurationMillis());\n     }\n \n-    public void testConstructor_8int__DurationType3() throws Throwable {\n-        try {\n-            new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getDayHourType());\n+    public void testConstructor_8int__PeriodType3() throws Throwable {\n+        try {\n+            new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getDayHourType());\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis());\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis());\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testConstructor_long_long_DurationType1() throws Throwable {\n+    public void testConstructor_long_long_PeriodType1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis(), null);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n-        assertEquals(1, test.getYears());\n-        assertEquals(1, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(1, test.getDays());\n-        assertEquals(1, test.getHours());\n-        assertEquals(1, test.getMinutes());\n-        assertEquals(1, test.getSeconds());\n-        assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n-    }\n-\n-    public void testConstructor_long_long_DurationType2() throws Throwable {\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(1, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(1, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(1, test.getMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.toDurationMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    public void testConstructor_long_long_PeriodType2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);\n-        TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis(), DurationType.getDayHourType());\n-        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+        TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.getDayHourType());\n+        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         } catch (IllegalStateException ex) {}\n     }\n \n-    public void testConstructor_long_long_DurationType3() throws Throwable {\n+    public void testConstructor_long_long_PeriodType3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);\n-        TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis(), DurationType.getAllType().withMillisRemoved());\n-        assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n+        TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.getAllType().withMillisRemoved());\n+        assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         TimePeriod test = new TimePeriod(dt1, dt2);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         TimePeriod test = new TimePeriod(dt1, dt2);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         TimePeriod test = new TimePeriod(dt1, dt2);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(3, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n         TimePeriod test = new TimePeriod(dt1, dt2);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(-3, test.getYears());\n         assertEquals(-1, test.getMonths());\n         assertEquals(-1, test.getWeeks());\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n         TimePeriod test = new TimePeriod(dt1, dt2);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testConstructor_RI_RI_DurationType1() throws Throwable {\n+    public void testConstructor_RI_RI_PeriodType1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         TimePeriod test = new TimePeriod(dt1, dt2, null);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n-        assertEquals(1, test.getYears());\n-        assertEquals(1, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(1, test.getDays());\n-        assertEquals(1, test.getHours());\n-        assertEquals(1, test.getMinutes());\n-        assertEquals(1, test.getSeconds());\n-        assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n-    }\n-\n-    public void testConstructor_RI_RI_DurationType2() throws Throwable {\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(1, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(1, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(1, test.getMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.toDurationMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    public void testConstructor_RI_RI_PeriodType2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);\n-        TimePeriod test = new TimePeriod(dt1, dt2, DurationType.getDayHourType());\n-        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+        TimePeriod test = new TimePeriod(dt1, dt2, PeriodType.getDayHourType());\n+        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         } catch (IllegalStateException ex) {}\n     }\n \n-    public void testConstructor_RI_RI_DurationType3() throws Throwable {\n+    public void testConstructor_RI_RI_PeriodType3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);\n-        TimePeriod test = new TimePeriod(dt1, dt2, DurationType.getAllType().withMillisRemoved());\n-        assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n+        TimePeriod test = new TimePeriod(dt1, dt2, PeriodType.getAllType().withMillisRemoved());\n+        assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.toDurationMillis());\n     }\n \n-    public void testConstructor_RI_RI_DurationType4() throws Throwable {\n+    public void testConstructor_RI_RI_PeriodType4() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        TimePeriod test = new TimePeriod(dt1, dt2, DurationType.getAllType());\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        TimePeriod test = new TimePeriod(dt1, dt2, PeriodType.getAllType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(3, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         } catch (IllegalStateException ex) {}\n     }\n \n-    public void testConstructor_RI_RI_DurationType5() throws Throwable {\n+    public void testConstructor_RI_RI_PeriodType5() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n-        TimePeriod test = new TimePeriod(dt1, dt2, DurationType.getAllType());\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        TimePeriod test = new TimePeriod(dt1, dt2, PeriodType.getAllType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n      */\n     public void testConstructor_Object1() throws Throwable {\n         TimePeriod test = new TimePeriod(\"P1Y2M3D\");\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(0, test.getWeeks());\n \n     public void testConstructor_Object2() throws Throwable {\n         TimePeriod test = new TimePeriod((Object) null);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     public void testConstructor_Object3() throws Throwable {\n-        TimePeriod test = new TimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()));\n-        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+        TimePeriod test = new TimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()));\n+        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     public void testConstructor_Object4() throws Throwable {\n-        TimePeriod base = new TimePeriod(1, 1, 0, 1, 1, 1, 1, 1, DurationType.getAllType());\n+        TimePeriod base = new TimePeriod(1, 1, 0, 1, 1, 1, 1, 1, PeriodType.getAllType());\n         TimePeriod test = new TimePeriod(base);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     /**\n      * Test constructor (Object)\n      */\n-    public void testConstructor_Object_DurationType1() throws Throwable {\n-        TimePeriod test = new TimePeriod(\"P1Y2M3D\", DurationType.getYearMonthType());\n-        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n+    public void testConstructor_Object_PeriodType1() throws Throwable {\n+        TimePeriod test = new TimePeriod(\"P1Y2M3D\", PeriodType.getYearMonthType());\n+        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         } catch (IllegalStateException ex) {}\n     }\n \n-    public void testConstructor_Object_DurationType2() throws Throwable {\n-        TimePeriod test = new TimePeriod((Object) null, DurationType.getYearMonthType());\n-        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n+    public void testConstructor_Object_PeriodType2() throws Throwable {\n+        TimePeriod test = new TimePeriod((Object) null, PeriodType.getYearMonthType());\n+        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(0, test.toDurationMillis());\n     }\n \n-    public void testConstructor_Object_DurationType3() throws Throwable {\n-        TimePeriod test = new TimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), DurationType.getYearMonthType());\n-        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n+    public void testConstructor_Object_PeriodType3() throws Throwable {\n+        TimePeriod test = new TimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()), PeriodType.getYearMonthType());\n+        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n             3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.toDurationMillis());\n     }\n \n-    public void testConstructor_Object_DurationType4() throws Throwable {\n-        TimePeriod test = new TimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), null);\n-        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+    public void testConstructor_Object_PeriodType4() throws Throwable {\n+        TimePeriod test = new TimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()), null);\n+        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n--- a/JodaTime/src/test/org/joda/time/convert/TestConverterManager.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestConverterManager.java\n import org.joda.time.Duration;\n import org.joda.time.ReadableTimePeriod;\n import org.joda.time.TimePeriod;\n-import org.joda.time.DurationType;\n+import org.joda.time.PeriodType;\n import org.joda.time.Interval;\n import org.joda.time.JodaTimePermission;\n import org.joda.time.ReadWritableTimePeriod;\n         c = ConverterManager.getInstance().getDurationConverter(new Duration(123L));\n         assertEquals(ReadableDuration.class, c.getSupportedType());\n         \n-        c = ConverterManager.getInstance().getDurationConverter(new TimePeriod(DurationType.getMillisType()));\n+        c = ConverterManager.getInstance().getDurationConverter(new TimePeriod(PeriodType.getMillisType()));\n         assertEquals(ReadableDuration.class, c.getSupportedType());\n         \n         c = ConverterManager.getInstance().getDurationConverter(new Interval(0L, 1000L));\n     private static int PERIOD_SIZE = 5;\n     \n     public void testGetTimePeriodConverter() {\n-        TimePeriodConverter c = ConverterManager.getInstance().getTimePeriodConverter(new TimePeriod(DurationType.getMillisType()));\n+        TimePeriodConverter c = ConverterManager.getInstance().getTimePeriodConverter(new TimePeriod(PeriodType.getMillisType()));\n         assertEquals(ReadableTimePeriod.class, c.getSupportedType());\n         \n         c = ConverterManager.getInstance().getTimePeriodConverter(new Duration(123L));\n     public void testAddTimePeriodConverter1() {\n         TimePeriodConverter c = new TimePeriodConverter() {\n             public void setInto(ReadWritableTimePeriod duration, Object object) {}\n-            public DurationType getDurationType(Object object, boolean tmm) {return null;}\n+            public PeriodType getPeriodType(Object object, boolean tmm) {return null;}\n             public Class getSupportedType() {return Boolean.class;}\n         };\n         try {\n     public void testAddTimePeriodConverter2() {\n         TimePeriodConverter c = new TimePeriodConverter() {\n             public void setInto(ReadWritableTimePeriod duration, Object object) {}\n-            public DurationType getDurationType(Object object, boolean tmm) {return null;}\n+            public PeriodType getPeriodType(Object object, boolean tmm) {return null;}\n             public Class getSupportedType() {return String.class;}\n         };\n         try {\n     public void testRemoveTimePeriodConverter2() {\n         TimePeriodConverter c = new TimePeriodConverter() {\n             public void setInto(ReadWritableTimePeriod duration, Object object) {}\n-            public DurationType getDurationType(Object object, boolean tmm) {return null;}\n+            public PeriodType getPeriodType(Object object, boolean tmm) {return null;}\n             public Class getSupportedType() {return Boolean.class;}\n         };\n         TimePeriodConverter removed = ConverterManager.getInstance().removeTimePeriodConverter(c);\n--- a/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.DurationType;\n+import org.joda.time.PeriodType;\n import org.joda.time.MutableTimePeriod;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.chrono.JulianChronology;\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetDurationType_Object() throws Exception {\n-        assertEquals(DurationType.getAllType(),\n-            LongConverter.INSTANCE.getDurationType(new Long(123L), false));\n-        assertEquals(DurationType.getPreciseAllType(),\n-            LongConverter.INSTANCE.getDurationType(new Long(123L), true));\n+    public void testGetPeriodType_Object() throws Exception {\n+        assertEquals(PeriodType.getAllType(),\n+            LongConverter.INSTANCE.getPeriodType(new Long(123L), false));\n+        assertEquals(PeriodType.getPreciseAllType(),\n+            LongConverter.INSTANCE.getPeriodType(new Long(123L), true));\n     }\n \n     public void testSetInto_Object() throws Exception {\n-        MutableTimePeriod m = new MutableTimePeriod(DurationType.getMillisType());\n+        MutableTimePeriod m = new MutableTimePeriod(PeriodType.getMillisType());\n         LongConverter.INSTANCE.setInto(m, new Long(123L));\n         assertEquals(123L, m.toDurationMillis());\n     }\n--- a/JodaTime/src/test/org/joda/time/convert/TestNullConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestNullConverter.java\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.DurationType;\n+import org.joda.time.PeriodType;\n import org.joda.time.MutableTimePeriod;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.chrono.JulianChronology;\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetDurationType_Object() throws Exception {\n-        assertEquals(DurationType.getAllType(),\n-            NullConverter.INSTANCE.getDurationType(null, false));\n-        assertEquals(DurationType.getPreciseAllType(),\n-            NullConverter.INSTANCE.getDurationType(null, true));\n+    public void testGetPeriodType_Object() throws Exception {\n+        assertEquals(PeriodType.getAllType(),\n+            NullConverter.INSTANCE.getPeriodType(null, false));\n+        assertEquals(PeriodType.getPreciseAllType(),\n+            NullConverter.INSTANCE.getPeriodType(null, true));\n     }\n \n     public void testSetInto_Object() throws Exception {\n-        MutableTimePeriod m = new MutableTimePeriod(DurationType.getMillisType());\n+        MutableTimePeriod m = new MutableTimePeriod(PeriodType.getMillisType());\n         NullConverter.INSTANCE.setInto(m, null);\n         assertEquals(0L, m.toDurationMillis());\n     }\n--- a/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeZone;\n import org.joda.time.Duration;\n-import org.joda.time.DurationType;\n+import org.joda.time.PeriodType;\n import org.joda.time.MutableTimePeriod;\n import org.joda.time.ReadableDuration;\n import org.joda.time.chrono.ISOChronology;\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetDurationType_Object() throws Exception {\n-        assertEquals(DurationType.getPreciseAllType(),\n-            ReadableDurationConverter.INSTANCE.getDurationType(new Duration(123L), false));\n-        assertEquals(DurationType.getPreciseAllType(),\n-            ReadableDurationConverter.INSTANCE.getDurationType(new Duration(123L), true));\n+    public void testGetPeriodType_Object() throws Exception {\n+        assertEquals(PeriodType.getPreciseAllType(),\n+            ReadableDurationConverter.INSTANCE.getPeriodType(new Duration(123L), false));\n+        assertEquals(PeriodType.getPreciseAllType(),\n+            ReadableDurationConverter.INSTANCE.getPeriodType(new Duration(123L), true));\n     }\n \n     public void testSetInto_Object() throws Exception {\n-        MutableTimePeriod m = new MutableTimePeriod(DurationType.getYearMonthType());\n+        MutableTimePeriod m = new MutableTimePeriod(PeriodType.getYearMonthType());\n         ReadableDurationConverter.INSTANCE.setInto(m, new Duration(\n             3L * DateTimeConstants.MILLIS_PER_DAY +\n             4L * DateTimeConstants.MILLIS_PER_MINUTE + 5L\n--- a/JodaTime/src/test/org/joda/time/convert/TestReadableIntervalConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestReadableIntervalConverter.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.DurationType;\n+import org.joda.time.PeriodType;\n import org.joda.time.Interval;\n import org.joda.time.MutableTimePeriod;\n import org.joda.time.MutableInterval;\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetDurationType_Object() throws Exception {\n+    public void testGetPeriodType_Object() throws Exception {\n         Interval i = new Interval(100L, 223L);\n-        assertEquals(DurationType.getAllType(),\n-            ReadableIntervalConverter.INSTANCE.getDurationType(i, false));\n-        assertEquals(DurationType.getPreciseAllType(),\n-            ReadableIntervalConverter.INSTANCE.getDurationType(i, true));\n+        assertEquals(PeriodType.getAllType(),\n+            ReadableIntervalConverter.INSTANCE.getPeriodType(i, false));\n+        assertEquals(PeriodType.getPreciseAllType(),\n+            ReadableIntervalConverter.INSTANCE.getPeriodType(i, true));\n     }\n \n     public void testSetInto_Object() throws Exception {\n         Interval i = new Interval(100L, 223L);\n-        MutableTimePeriod m = new MutableTimePeriod(DurationType.getMillisType());\n+        MutableTimePeriod m = new MutableTimePeriod(PeriodType.getMillisType());\n         ReadableIntervalConverter.INSTANCE.setInto(m, i);\n         assertEquals(0, m.getYears());\n         assertEquals(0, m.getMonths());\n--- a/JodaTime/src/test/org/joda/time/convert/TestReadablePeriodConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestReadablePeriodConverter.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.DurationType;\n+import org.joda.time.PeriodType;\n import org.joda.time.MutableTimePeriod;\n import org.joda.time.ReadableTimePeriod;\n import org.joda.time.TimePeriod;\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetDurationType_Object() throws Exception {\n-        assertEquals(DurationType.getAllType(),\n-            ReadableTimePeriodConverter.INSTANCE.getDurationType(new TimePeriod(123L), false));\n-        assertEquals(DurationType.getPreciseAllType(),\n-            ReadableTimePeriodConverter.INSTANCE.getDurationType(new TimePeriod(123L), true));\n-        assertEquals(DurationType.getPreciseAllType(),\n-            ReadableTimePeriodConverter.INSTANCE.getDurationType(new TimePeriod(123L, DurationType.getAllType()), true));\n-        assertEquals(DurationType.getPreciseYearDayType(),\n-            ReadableTimePeriodConverter.INSTANCE.getDurationType(new TimePeriod(123L, DurationType.getPreciseYearDayType()), true));\n+    public void testGetPeriodType_Object() throws Exception {\n+        assertEquals(PeriodType.getAllType(),\n+            ReadableTimePeriodConverter.INSTANCE.getPeriodType(new TimePeriod(123L), false));\n+        assertEquals(PeriodType.getPreciseAllType(),\n+            ReadableTimePeriodConverter.INSTANCE.getPeriodType(new TimePeriod(123L), true));\n+        assertEquals(PeriodType.getPreciseAllType(),\n+            ReadableTimePeriodConverter.INSTANCE.getPeriodType(new TimePeriod(123L, PeriodType.getAllType()), true));\n+        assertEquals(PeriodType.getPreciseYearDayType(),\n+            ReadableTimePeriodConverter.INSTANCE.getPeriodType(new TimePeriod(123L, PeriodType.getPreciseYearDayType()), true));\n     }\n \n     public void testSetInto_Object() throws Exception {\n-        MutableTimePeriod m = new MutableTimePeriod(DurationType.getYearMonthType());\n+        MutableTimePeriod m = new MutableTimePeriod(PeriodType.getYearMonthType());\n         ReadableTimePeriodConverter.INSTANCE.setInto(m, new TimePeriod(0, 0, 0, 3, 0, 4, 0, 5));\n         assertEquals(0, m.getYears());\n         assertEquals(0, m.getMonths());\n--- a/JodaTime/src/test/org/joda/time/convert/TestStringConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestStringConverter.java\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.DurationType;\n+import org.joda.time.PeriodType;\n import org.joda.time.MutableTimePeriod;\n import org.joda.time.MutableInterval;\n import org.joda.time.chrono.ISOChronology;\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetDurationType_Object() throws Exception {\n-        assertEquals(DurationType.getAllType(),\n-            StringConverter.INSTANCE.getDurationType(\"P2Y6M9D\", false));\n-        assertEquals(DurationType.getPreciseAllType(),\n-            StringConverter.INSTANCE.getDurationType(\"P2Y6M9D\", true));\n+    public void testGetPeriodType_Object() throws Exception {\n+        assertEquals(PeriodType.getAllType(),\n+            StringConverter.INSTANCE.getPeriodType(\"P2Y6M9D\", false));\n+        assertEquals(PeriodType.getPreciseAllType(),\n+            StringConverter.INSTANCE.getPeriodType(\"P2Y6M9D\", true));\n     }\n \n     public void testSetInto_Object() throws Exception {\n-        MutableTimePeriod m = new MutableTimePeriod(DurationType.getYearMonthType());\n+        MutableTimePeriod m = new MutableTimePeriod(PeriodType.getYearMonthType());\n         StringConverter.INSTANCE.setInto(m, \"P2Y6M9DT12H24M48S\");\n         assertEquals(2, m.getYears());\n         assertEquals(6, m.getMonths());\n         assertEquals(48, m.getSeconds());\n         assertEquals(0, m.getMillis());\n         \n-        m = new MutableTimePeriod(DurationType.getYearWeekType());\n+        m = new MutableTimePeriod(PeriodType.getYearWeekType());\n         StringConverter.INSTANCE.setInto(m, \"P2Y4W3DT12H24M48S\");\n         assertEquals(2, m.getYears());\n         assertEquals(4, m.getWeeks());\n         assertEquals(48, m.getSeconds());\n         assertEquals(0, m.getMillis());\n         \n-        m = new MutableTimePeriod(1, 0, 1, 1, 1, 1, 1, 1, DurationType.getYearWeekType());\n+        m = new MutableTimePeriod(1, 0, 1, 1, 1, 1, 1, 1, PeriodType.getYearWeekType());\n         StringConverter.INSTANCE.setInto(m, \"P2Y4W3D\");\n         assertEquals(2, m.getYears());\n         assertEquals(4, m.getWeeks());", "timestamp": 1091818155, "metainfo": ""}