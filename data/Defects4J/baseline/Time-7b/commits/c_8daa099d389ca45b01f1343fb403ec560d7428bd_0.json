{"sha": "8daa099d389ca45b01f1343fb403ec560d7428bd", "log": "Refactor to create TimePeriod and make Duration millisecond only   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/AbstractDuration.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractDuration.java\n  */\n package org.joda.time;\n \n-import java.io.Serializable;\n-\n+import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.DurationConverter;\n-import org.joda.time.convert.ConverterManager;\n import org.joda.time.field.FieldUtils;\n-import org.joda.time.format.ISODurationFormat;\n+import org.joda.time.format.ISOTimePeriodFormat;\n \n /**\n  * AbstractDuration provides the common behaviour for duration classes.\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public abstract class AbstractDuration implements ReadableDuration, Serializable {\n+public abstract class AbstractDuration implements ReadableDuration {\n \n     /** Serialization version */\n-    private static final long serialVersionUID = -2110953284060001145L;\n-    /** Millis cache is currently unknown */\n-    private static final int STATE_UNKNOWN = 0;\n-    /** Millis cache is not calculable */\n-    private static final int STATE_NOT_CALCULABLE = 1;\n-    /** Millis cache has been calculated and is valid */\n-    private static final int STATE_CALCULATED = 2;\n-    /** Total millis is the master field, fields always accurate */\n-    private static final int STATE_TOTAL_MILLIS_MASTER = -1;\n-\n-    /** The duration type that allocates the duration to fields */\n-    private final DurationType iType;\n-    /** The object state */\n-    private int iState;\n-    /** The total milliseconds, if known */\n-    private long iTotalMillis;\n-    /** Value for years */\n-    private int iYears;\n-    /** Value for months */\n-    private int iMonths;\n-    /** Value for weeks */\n-    private int iWeeks;\n-    /** Value for days */\n-    private int iDays;\n-    /** Value for hours */\n-    private int iHours;\n-    /** Value for minutes */\n-    private int iMinutes;\n-    /** Value for seconds */\n-    private int iSeconds;\n-    /** Value for millis */\n-    private int iMillis;\n+    private static final long serialVersionUID = 358732693691287348L;\n+\n+    /** The duration length */\n+    private long iMillis;\n \n     /**\n      * Creates a duration from the given millisecond duration.\n-     * <p>\n-     * The millisecond duration will be split to fields using a UTC version of\n-     * the duration type.\n      *\n      * @param duration  the duration, in milliseconds\n-     * @param type  which set of fields this duration supports\n-     * @param totalMillisMaster  true if the total millis is master, false if the fields are\n-     * @throws IllegalArgumentException if duration type is invalid\n-     */\n-    public AbstractDuration(long duration, DurationType type, boolean totalMillisMaster) {\n+     */\n+    public AbstractDuration(long duration) {\n         super();\n-        type = init(type, totalMillisMaster);\n-        iType = type;\n-        // Only call a private method\n-        setTotalMillis(type, duration);\n-    }\n-\n-    /**\n-     * Creates a duration from a set of field values.\n-     *\n-     * @param years  amount of years in this duration, which must be zero if unsupported\n-     * @param months  amount of months in this duration, which must be zero if unsupported\n-     * @param weeks  amount of weeks in this duration, which must be zero if unsupported\n-     * @param days  amount of days in this duration, which must be zero if unsupported\n-     * @param hours  amount of hours in this duration, which must be zero if unsupported\n-     * @param minutes  amount of minutes in this duration, which must be zero if unsupported\n-     * @param seconds  amount of seconds in this duration, which must be zero if unsupported\n-     * @param millis  amount of milliseconds in this duration, which must be zero if unsupported\n-     * @param type  which set of fields this duration supports\n-     * @param totalMillisMaster  true if the total millis is master, false if the fields are\n-     * @throws IllegalArgumentException if duration type is invalid\n-     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n-     */\n-    public AbstractDuration(int years, int months, int weeks, int days,\n-                            int hours, int minutes, int seconds, int millis,\n-                            DurationType type, boolean totalMillisMaster) {\n-        super();\n-        type = init(type, totalMillisMaster);\n-        iType = type;\n-        // Only call a private method\n-        setDuration(type, years, months, weeks, days, hours, minutes, seconds, millis);\n-    }\n-\n-    /**\n-     * Creates a duration from the given interval endpoints.\n-     *\n-     * @param startInstant  interval start, in milliseconds\n-     * @param endInstant  interval end, in milliseconds\n-     * @param type  which set of fields this duration supports\n-     * @param totalMillisMaster  true if the total millis is master, false if the fields are\n-     * @throws IllegalArgumentException if duration type is invalid\n-     */\n-    public AbstractDuration(long startInstant, long endInstant, DurationType type, boolean totalMillisMaster) {\n-        super();\n-        type = init(type, totalMillisMaster);\n-        iType = type;\n-        // Only call a private method\n-        setTotalMillis(type, startInstant, endInstant);\n+        iMillis = duration;\n     }\n \n     /**\n      *\n      * @param startInstant  interval start, null means now\n      * @param endInstant  interval end, null means now\n-     * @param type  which set of fields this duration supports\n-     * @param totalMillisMaster  true if the total millis is master, false if the fields are\n-     * @throws IllegalArgumentException if duration type is invalid\n-     */\n-    public AbstractDuration(\n-            ReadableInstant startInstant, ReadableInstant  endInstant, DurationType type, boolean totalMillisMaster) {\n+     * @throws ArithmeticException if the duration exceeds a 64 bit long\n+     */\n+    public AbstractDuration(long startInstant, long  endInstant) {\n         super();\n-        type = init(type, totalMillisMaster);\n-        if (startInstant == null && endInstant == null) {\n-            iType = type;\n+        iMillis = FieldUtils.safeAdd(endInstant, -startInstant);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     * @throws ArithmeticException if the duration exceeds a 64 bit long\n+     */\n+    public AbstractDuration(ReadableInstant startInstant, ReadableInstant  endInstant) {\n+        super();\n+        if (startInstant == endInstant) {\n+            iMillis = 0L;\n         } else {\n             long start = (startInstant == null ? DateTimeUtils.currentTimeMillis() : startInstant.getMillis());\n             long end = (endInstant == null ? DateTimeUtils.currentTimeMillis() : endInstant.getMillis());\n-            iType = type;\n-            // Only call a private method\n-            setTotalMillis(type, start, end);\n+            iMillis = FieldUtils.safeAdd(end, -start);\n         }\n     }\n \n      * Creates a new duration based on another using the {@link ConverterManager}.\n      *\n      * @param duration  duration to convert\n-     * @param type  which set of fields this duration supports, null means use type from object\n-     * @param totalMillisMaster  true if the total millis is master, false if the fields are\n      * @throws IllegalArgumentException if duration is invalid\n-     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n-     */\n-    public AbstractDuration(Object duration, DurationType type, boolean totalMillisMaster) {\n+     */\n+    public AbstractDuration(Object duration) {\n         super();\n         DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);\n-        type = (type == null ? converter.getDurationType(duration, totalMillisMaster) : type);\n-        type = init(type, totalMillisMaster);\n-        iType = type;\n-        if (type.isPrecise() && converter.isPrecise(duration)) {\n-            // Only call a private method\n-            setTotalMillis(type, converter.getDurationMillis(duration));\n-        } else if (this instanceof ReadWritableDuration) {\n-            converter.setInto((ReadWritableDuration) this, duration);\n-        } else {\n-            // Only call a private method\n-            setDuration(type, new MutableDuration(duration, type));\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Validates a duration type, converting nulls to a default value and\n-     * checking the type is suitable for this instance.\n-     * \n-     * @param type  the type to check\n-     * @param totalMillisMaster  true if total millis should be master\n-     * @return the duration type, not null\n-     * @throws IllegalArgumentException if the duration type is invalid\n-     */\n-    private DurationType init(DurationType type, boolean totalMillisMaster) {\n-        if (totalMillisMaster) {\n-            iState = STATE_TOTAL_MILLIS_MASTER;\n-        }\n-        type = checkDurationType(type);\n-        if (type == null) {\n-            throw new IllegalArgumentException(\"The duration type must not be null\");\n-        }\n-        if (totalMillisMaster && type.isPrecise() == false) {\n-            throw new IllegalArgumentException(\"The duration type must be precise: \" + type);\n-        }\n-        return type;\n-    }\n-\n-    /**\n-     * Validates a duration type, converting nulls to a default value and\n-     * checking the type is suitable for this instance.\n-     * \n-     * @param type  the type to check, may be null\n-     * @return the validated type to use, not null\n-     * @throws IllegalArgumentException if the duration type is invalid\n-     */\n-    protected abstract DurationType checkDurationType(DurationType type);\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Returns the object which defines which fields this duration supports.\n-     */\n-    public final DurationType getDurationType() {\n-        return iType;\n-    }\n-\n-    /**\n-     * Is this duration based on a millisecond duration and thus performs\n-     * all calculations using the total millisecond value.\n-     * <p>\n-     * Durations operate either using the total milliseconds as the master and the\n-     * field values as derived, or vice versa. This method returns true if the\n-     * total millis field is the master.\n-     * <p>\n-     * If true, {@link #isPrecise()} will always return true, {@link #getTotalMillis()}\n-     * and {@link #compareTo(Object)} methods will never throw an exception and the\n-     * add methods will add using the total milliseconds value.\n-     * See {@link MillisDuration} for details.\n-     *\n-     * @return true if the duration is based on total milliseconds\n-     */\n-    public final boolean isTotalMillisBased() {\n-        return (iState == STATE_TOTAL_MILLIS_MASTER);\n-    }\n-\n-    /**\n-     * Gets the total length of this duration in milliseconds, \n-     * failing if the duration is imprecise.\n+        iMillis = converter.getDurationMillis(duration);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the total length of this duration in milliseconds.\n      *\n      * @return the total length of the duration in milliseconds.\n-     * @throws IllegalStateException if the duration is imprecise\n-     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n-     */\n-    public final long getTotalMillis() {\n-        int state = iState;\n-        if (state == STATE_TOTAL_MILLIS_MASTER) {\n-            return iTotalMillis;\n-        }\n-        if (state == STATE_UNKNOWN) {\n-            state = updateTotalMillis();\n-        }\n-        if (state != STATE_CALCULATED) {\n-            throw new IllegalStateException(\"Duration is imprecise\");\n-        }\n-        return iTotalMillis;\n-    }\n-\n-    /**\n-     * Is this duration a precise length of time, or descriptive.\n-     * <p>\n-     * A precise duration could include millis, seconds, minutes or hours.\n-     * However, days, weeks, months and years can vary in length, resulting in\n-     * an imprecise duration.\n-     * <p>\n-     * An imprecise duration can be made precise by pairing it with a\n-     * date in a {@link ReadableInterval}.\n-     *\n-     * @return true if the duration is precise\n-     */\n-    public final boolean isPrecise() {\n-        int state = iState;\n-        if (state == STATE_TOTAL_MILLIS_MASTER) {\n-            return true;\n-        }\n-        if (state == STATE_UNKNOWN) {\n-            state = updateTotalMillis();\n-        }\n-        return (state == STATE_CALCULATED);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Adds this duration to the given instant using the chronology of the duration\n-     * which typically ignores time zones.\n-     * <p>\n-     * To add just once, pass in a scalar of one. To subtract once, pass\n-     * in a scalar of minus one.\n-     *\n-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n-     * duration to\n-     * @param scalar  the number of times to add the duration, negative to subtract\n-     * @return milliseconds value plus this duration times scalar\n-     * @throws ArithmeticException if the result of the calculation is too large\n-     */\n-    public final long addTo(long instant, int scalar) {\n-        return addTo(instant, scalar, null);\n-    }\n-\n-    /**\n-     * Adds this duration to the given instant using a specific chronology.\n-     * <p>\n-     * To add just once, pass in a scalar of one. To subtract once, pass\n-     * in a scalar of minus one.\n-     *\n-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n-     * duration to\n-     * @param scalar  the number of times to add the duration, negative to subtract\n-     * @param chrono  override the duration's chronology, unless null is passed in\n-     * @return milliseconds value plus this duration times scalar\n-     * @throws ArithmeticException if the result of the calculation is too large\n-     */\n-    public final long addTo(long instant, int scalar, Chronology chrono) {\n-        if (isPrecise()) {\n-            return FieldUtils.safeAdd(instant, getTotalMillis() * scalar);\n-        }\n-        \n-        DurationType type = iType;\n-        if (chrono != null) {\n-            type = type.withChronology(chrono);\n-        }\n-        \n-        long value; // used to lock fields against threading issues\n-        value = scaleValue(iYears, scalar);\n-        if (value != 0) {\n-            instant = type.years().add(instant, value);\n-        }\n-        value = scaleValue(iMonths, scalar);\n-        if (value != 0) {\n-            instant = type.months().add(instant, value);\n-        }\n-        value = scaleValue(iWeeks, scalar);\n-        if (value != 0) {\n-            instant = type.weeks().add(instant, value);\n-        }\n-        value = scaleValue(iDays, scalar);\n-        if (value != 0) {\n-            instant = type.days().add(instant, value);\n-        }\n-        value = scaleValue(iHours, scalar);\n-        if (value != 0) {\n-            instant = type.hours().add(instant, value);\n-        }\n-        value = scaleValue(iMinutes, scalar);\n-        if (value != 0) {\n-            instant = type.minutes().add(instant, value);\n-        }\n-        value = scaleValue(iSeconds, scalar);\n-        if (value != 0) {\n-            instant = type.seconds().add(instant, value);\n-        }\n-        value = scaleValue(iMillis, scalar);\n-        if (value != 0) {\n-            instant = type.millis().add(instant, value);\n-        }\n-\n-        return instant;\n-    }\n-\n-    /**\n-     * Convert the scalar to a multiple efficiently.\n-     * \n-     * @param value  the value\n-     * @param scalar  the scalar\n-     * @return the converted value\n-     */\n-    private static long scaleValue(int value, int scalar) {\n-        long val = value;  // use long to avoid truncation\n-        switch (scalar) {\n-        case -1:\n-            return -val;\n-        case 0:\n-            return 0;\n-        case 1:\n-            return val;\n-        default:\n-            return val * scalar;\n-        }\n-    }\n-\n-    /**\n-     * Adds this duration to the given instant using the chronology of the specified\n-     * instant (if present), returning a new Instant.\n-     * <p>\n-     * To add just once, pass in a scalar of one. To subtract once, pass\n-     * in a scalar of minus one.\n-     *\n-     * @param instant  the instant to add the duration to, null means now\n-     * @param scalar  the number of times to add the duration, negative to subtract\n-     * @return instant with the original value plus this duration times scalar\n-     * @throws ArithmeticException if the result of the calculation is too large\n-     */\n-    public final Instant addTo(ReadableInstant instant, int scalar) {\n-        if (instant == null) {\n-            return new Instant(addTo(DateTimeUtils.currentTimeMillis(), scalar));\n-        }\n-        return new Instant(addTo(instant.getMillis(), scalar, instant.getChronology()));\n-    }\n-\n-    /**\n-     * Adds this duration into the given mutable instant using the chronology of\n-     * the specified mutable instant (if present).\n-     * <p>\n-     * To add just once, pass in a scalar of one. To subtract once, pass\n-     * in a scalar of minus one.\n-     *\n-     * @param instant  the instant to update with the added duration, must not be null\n-     * @param scalar  the number of times to add the duration, negative to subtract\n-     * @throws IllegalArgumentException if the instant is null\n-     * @throws ArithmeticException if the result of the calculation is too large\n-     */\n-    public final void addInto(ReadWritableInstant instant, int scalar) {\n-        if (instant == null) {\n-            throw new IllegalArgumentException(\"The instant must not be null\");\n-        }\n-        instant.setMillis(addTo(instant.getMillis(), scalar, instant.getChronology()));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the years field part of the duration.\n-     * \n-     * @return the number of years in the duration, zero if unsupported\n-     */\n-    public final int getYears() {\n-        return iYears;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the months field part of the duration.\n-     * \n-     * @return the number of months in the duration, zero if unsupported\n-     */\n-    public final int getMonths() {\n-        return iMonths;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the weeks field part of the duration.\n-     * \n-     * @return the number of weeks in the duration, zero if unsupported\n-     */\n-    public final int getWeeks() {\n-        return iWeeks;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the days field part of the duration.\n-     * \n-     * @return the number of days in the duration, zero if unsupported\n-     */\n-    public final int getDays() {\n-        return iDays;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the hours field part of the duration.\n-     * \n-     * @return the number of hours in the duration, zero if unsupported\n-     */\n-    public final int getHours() {\n-        return iHours;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the minutes field part of the duration.\n-     * \n-     * @return the number of minutes in the duration, zero if unsupported\n-     */\n-    public final int getMinutes() {\n-        return iMinutes;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the seconds field part of the duration.\n-     * \n-     * @return the number of seconds in the duration, zero if unsupported\n-     */\n-    public final int getSeconds() {\n-        return iSeconds;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the millis field part of the duration.\n-     * \n-     * @return the number of millis in the duration, zero if unsupported\n-     */\n-    public final int getMillis() {\n+     */\n+    public final long getMillis() {\n         return iMillis;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Get this object as an immutable Duration. This can be useful if you\n-     * don't trust the implementation of the interface to be well-behaved, or\n-     * to get a guaranteed immutable object.\n-     * \n-     * @return a Duration using the same field set and values\n+     * Converts this duration to a Duration instance.\n+     * \n+     * @return a Duration created using the millisecond duration from this instance\n      */\n     public final Duration toDuration() {\n         if (this instanceof Duration) {\n             return (Duration) this;\n         }\n-        return new Duration(this);\n-    }\n-\n-    /**\n-     * Get this object as a MutableDuration.\n-     * \n-     * @return a MutableDuration using the same field set and values\n-     */\n-    public final MutableDuration toMutableDuration() {\n-        return new MutableDuration(this);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Compares this duration with the specified duration, which can only be\n-     * performed if both are precise.\n-     *\n-     * @param obj  a precise duration to check against\n+        return new Duration(getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this duration to a TimePeriod instance using the PreciseAll type.\n+     * <p>\n+     * The PreciseAll type fixes days at 24 hours, months ay 30 days and years at 365 days\n+     * thus the time period will be precise. As a result there is no loss of precision\n+     * with regards the length of the duration and the following code will work:\n+     * <pre>\n+     * Duration dur = new Duration(123456789L);\n+     * TimePeriod period = d.toTimePeriod();\n+     * Duration dur2 = period.toDuration();\n+     * // dur.getMillis() == dur2.getMillis()\n+     * </pre>\n+     * \n+     * @return a TimePeriod created using the millisecond duration from this instance\n+     */\n+    public final TimePeriod toTimePeriod() {\n+        return new TimePeriod(this, DurationType.getPreciseAllType());\n+    }\n+\n+    /**\n+     * Converts this duration to a TimePeriod instance specifying a duration type\n+     * to control how the duration is split into fields.\n+     * <p>\n+     * If a non-precise duration type is used, the resulting time period will only\n+     * represent an approximation of the duration. As a result it will not be\n+     * possible to call {@link TimePeriod#toDuration()} to get the duration back.\n+     * \n+     * @param type  the duration type determining how to split the duration into fields\n+     * @return a TimePeriod created using the millisecond duration from this instance\n+     */\n+    public final TimePeriod toTimePeriod(DurationType type) {\n+        return new TimePeriod(this, type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this duration with the specified duration based on length.\n+     *\n+     * @param obj  a duration to check against\n      * @return negative value if this is less, 0 if equal, or positive value if greater\n      * @throws NullPointerException if the object is null\n      * @throws ClassCastException if the given object is not supported\n-     * @throws IllegalStateException if either duration is imprecise\n-     */\n-    public int compareTo(Object obj) {\n+     */\n+    public final int compareTo(Object obj) {\n         // Comparable contract means we cannot handle null or other types gracefully\n         ReadableDuration thisDuration = (ReadableDuration) this;\n         ReadableDuration otherDuration = (ReadableDuration) obj;\n         \n-        long thisMillis = thisDuration.getTotalMillis();\n-        long otherMillis = otherDuration.getTotalMillis();\n+        long thisMillis = thisDuration.getMillis();\n+        long otherMillis = otherDuration.getMillis();\n         \n         // cannot do (thisMillis - otherMillis) as it can overflow\n         if (thisMillis < otherMillis) {\n \n     /**\n      * Is the length of this duration equal to the duration passed in.\n-     * Both durations must be precise.\n      *\n      * @param duration  another duration to compare to, null means zero milliseconds\n      * @return true if this duration is equal to than the duration passed in\n-     * @throws IllegalStateException if either duration is imprecise\n-     */\n-    public boolean isEqual(ReadableDuration duration) {\n+     */\n+    public final boolean isEqual(ReadableDuration duration) {\n         if (duration == null) {\n             duration = Duration.ZERO;\n         }\n \n     /**\n      * Is the length of this duration longer than the duration passed in.\n-     * Both durations must be precise.\n      *\n      * @param duration  another duration to compare to, null means zero milliseconds\n      * @return true if this duration is equal to than the duration passed in\n-     * @throws IllegalStateException if either duration is imprecise\n-     */\n-    public boolean isLongerThan(ReadableDuration duration) {\n+     */\n+    public final boolean isLongerThan(ReadableDuration duration) {\n         if (duration == null) {\n             duration = Duration.ZERO;\n         }\n \n     /**\n      * Is the length of this duration shorter than the duration passed in.\n-     * Both durations must be precise.\n      *\n      * @param duration  another duration to compare to, null means zero milliseconds\n      * @return true if this duration is equal to than the duration passed in\n-     * @throws IllegalStateException if either duration is imprecise\n-     */\n-    public boolean isShorterThan(ReadableDuration duration) {\n+     */\n+    public final boolean isShorterThan(ReadableDuration duration) {\n         if (duration == null) {\n             duration = Duration.ZERO;\n         }\n     //-----------------------------------------------------------------------\n     /**\n      * Compares this object with the specified object for equality based\n-     * on the value of each field. All ReadableDuration instances are accepted.\n-     * <p>\n-     * To compare two durations for absolute duration (ie. millisecond duration\n-     * ignoring the fields), use {@link #isEqual(ReadableDuration)} or\n-     * {@link #compareTo(Object)}.\n+     * on the millisecond length. All ReadableDuration instances are accepted.\n      *\n      * @param readableDuration  a readable duration to check against\n-     * @return true if all the field values are equal, false if\n-     *  not or the duration is null or of an incorrect type\n-     */\n-    public boolean equals(Object readableDuration) {\n+     * @return true if the length of the duration is equal\n+     */\n+    public final boolean equals(Object readableDuration) {\n         if (this == readableDuration) {\n             return true;\n         }\n             return false;\n         }\n         ReadableDuration other = (ReadableDuration) readableDuration;\n-        DurationType type = getDurationType();\n-        if (type.equals(other.getDurationType()) == false) {\n-            return false;\n-        }\n-        return getYears() == other.getYears()\n-            && getMonths() == other.getMonths()\n-            && getWeeks() == other.getWeeks()\n-            && getDays() == other.getDays()\n-            && getHours() == other.getHours()\n-            && getMinutes() == other.getMinutes()\n-            && getSeconds() == other.getSeconds()\n-            && getMillis() == other.getMillis();\n+        return (getMillis() == other.getMillis());\n     }\n \n     /**\n      *\n      * @return a hash code\n      */\n-    public int hashCode() {\n-        int hash = getDurationType().hashCode();\n-        hash = 53 * hash + getYears();\n-        hash = 53 * hash + getMonths();\n-        hash = 53 * hash + getWeeks();\n-        hash = 53 * hash + getDays();\n-        hash = 53 * hash + getHours();\n-        hash = 53 * hash + getMinutes();\n-        hash = 53 * hash + getSeconds();\n-        hash = 53 * hash + getMillis();\n-        return hash;\n+    public final int hashCode() {\n+        long len = getMillis();\n+        return (int) (len ^ (len >>> 32));\n     }\n \n     //-----------------------------------------------------------------------\n      * Gets the value as a String in the ISO8601 duration format.\n      * <p>\n      * For example, \"P6H3M7S\" represents 6 hours, 3 minutes, 7 seconds.\n+     * The field values are determined using the PreciseAll duration type.\n      *\n      * @return the value as an ISO8601 string\n      */\n     public String toString() {\n-        return ISODurationFormat.getInstance().standard().print(this);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Checks whether the field is supported.\n-     */\n-    private static void checkArgument(DurationField field, String name) {\n-        if (!field.isSupported()) {\n-            throw new IllegalArgumentException\n-                (\"Duration does not support field \\\"\" + name + '\"');\n-        }\n-    }\n-\n-    /**\n-     * Checks whether the field is supported.\n-     */\n-    private static void checkSupport(DurationField field, String name) {\n-        if (!field.isSupported()) {\n-            throw new UnsupportedOperationException\n-                (\"Duration does not support field \\\"\" + name + '\"');\n-        }\n-    }\n-\n+        return ISOTimePeriodFormat.getInstance().standard().print(toTimePeriod());\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Sets all the fields in one go from another ReadableDuration.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n      * \n      * @param duration  the duration to set, null means zero length duration\n      * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n     protected void setDuration(ReadableDuration duration) {\n         if (duration == null) {\n-            setTotalMillis(iType, 0L);\n+            setMillis(0L);\n         } else {\n-            setDuration(iType, duration);\n-        }\n-    }\n-\n-    /**\n-     * This method is private to prevent subclasses from overriding.\n-     */\n-    private void setDuration(DurationType type, ReadableDuration duration) {\n-        if (iState == STATE_TOTAL_MILLIS_MASTER) {\n-            if (duration.isPrecise() == false) {\n-                throw new IllegalArgumentException(\"The duration to copy from must be precise\");\n-            }\n-            setTotalMillis(type, duration.getTotalMillis());\n-        } else {\n-            setDuration(type,\n-                        duration.getYears(), duration.getMonths(),\n-                        duration.getWeeks(), duration.getDays(),\n-                        duration.getHours(), duration.getMinutes(),\n-                        duration.getSeconds(), duration.getMillis());\n-            if (type.equals(duration.getDurationType()) && duration.isPrecise()) {\n-                iTotalMillis = duration.getTotalMillis();\n-                iState = STATE_CALCULATED;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Sets all the fields in one go.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     * \n-     * @param years  amount of years in this duration, which must be zero if unsupported\n-     * @param months  amount of months in this duration, which must be zero if unsupported\n-     * @param weeks  amount of weeks in this duration, which must be zero if unsupported\n-     * @param days  amount of days in this duration, which must be zero if unsupported\n-     * @param hours  amount of hours in this duration, which must be zero if unsupported\n-     * @param minutes  amount of minutes in this duration, which must be zero if unsupported\n-     * @param seconds  amount of seconds in this duration, which must be zero if unsupported\n-     * @param millis  amount of milliseconds in this duration, which must be zero if unsupported\n-     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n-     */\n-    protected void setDuration(int years, int months, int weeks, int days,\n-                               int hours, int minutes, int seconds, int millis) {\n-        setDuration(iType, years, months, weeks, days, hours, minutes, seconds, millis);\n-    }\n-\n-    /**\n-     * This method is private to prevent subclasses from overriding.\n-     */\n-    private void setDuration(DurationType type,\n-                             int years, int months, int weeks, int days,\n-                             int hours, int minutes, int seconds, int millis) {\n-        if (years != 0) {\n-            checkArgument(type.years(), \"years\");\n-        }\n-        if (months != 0) {\n-            checkArgument(type.months(), \"months\");\n-        }\n-        if (weeks != 0) {\n-            checkArgument(type.weeks(), \"weeks\");\n-        }\n-        if (days != 0) {\n-            checkArgument(type.days(), \"days\");\n-        }\n-        if (hours != 0) {\n-            checkArgument(type.hours(), \"hours\");\n-        }\n-        if (minutes != 0) {\n-            checkArgument(type.minutes(), \"minutes\");\n-        }\n-        if (seconds != 0) {\n-            checkArgument(type.seconds(), \"seconds\");\n-        }\n-        if (millis != 0) {\n-            checkArgument(type.millis(), \"millis\");\n-        }\n-        \n-        if (iState == STATE_TOTAL_MILLIS_MASTER) {\n-            updateTotalMillis(years, months, weeks, days, hours, minutes, seconds, millis);\n-        } else {\n-            iState = STATE_UNKNOWN;\n-        }\n-        // assign fields in one block to reduce threading issues\n-        iYears = years;\n-        iMonths = months;\n-        iWeeks = weeks;\n-        iDays = days;\n-        iHours = hours;\n-        iMinutes = minutes;\n-        iSeconds = seconds;\n-        iMillis = millis;\n+            setMillis(duration.getMillis());\n+        }\n     }\n \n     /**\n      * @param startInstant  interval start, in milliseconds\n      * @param endInstant  interval end, in milliseconds\n      */\n-    protected void setTotalMillis(long startInstant, long endInstant) {\n-        setTotalMillis(iType, startInstant, endInstant);\n-    }\n-\n-    /**\n-     * This method is private to prevent subclasses from overriding.\n-     *\n-     * @param startInstant  interval start, in milliseconds\n-     * @param endInstant  interval end, in milliseconds\n-     */\n-    private void setTotalMillis(DurationType type, long startInstant, long endInstant) {\n-        long baseTotalMillis = (endInstant - startInstant);\n-        if (iState == STATE_TOTAL_MILLIS_MASTER) {\n-            setTotalMillis(type, baseTotalMillis);\n-            return;\n-        }\n-        int years = 0, months = 0, weeks = 0, days = 0;\n-        int hours = 0, minutes = 0, seconds = 0, millis = 0;\n-        DurationField field;\n-        field = type.years();\n-        if (field.isSupported()) {\n-            years = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, years);\n-        }\n-        field = type.months();\n-        if (field.isSupported()) {\n-            months = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, months);\n-        }\n-        field = type.weeks();\n-        if (field.isSupported()) {\n-            weeks = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, weeks);\n-        }\n-        field = type.days();\n-        if (field.isSupported()) {\n-            days = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, days);\n-        }\n-        field = type.hours();\n-        if (field.isSupported()) {\n-            hours = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, hours);\n-        }\n-        field = type.minutes();\n-        if (field.isSupported()) {\n-            minutes = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, minutes);\n-        }\n-        field = type.seconds();\n-        if (field.isSupported()) {\n-            seconds = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, seconds);\n-        }\n-        field = type.millis();\n-        if (field.isSupported()) {\n-            millis = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, millis);\n-        }\n-        \n-        // assign fields in one block to reduce threading issues\n-        iYears = years;\n-        iMonths = months;\n-        iWeeks = weeks;\n-        iDays = days;\n-        iHours = hours;\n-        iMinutes = minutes;\n-        iSeconds = seconds;\n-        iMillis = millis;\n-        // (end - start) is excess to be discarded\n-        iTotalMillis = baseTotalMillis - (endInstant - startInstant);\n-        iState = STATE_CALCULATED;\n-    }\n-\n-    /**\n-     * Sets all the fields in one go from a millisecond duration. If any\n-     * supported fields are imprecise, an UnsupportedOperationException is\n-     * thrown. The exception to this is when the specified duration is zero.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     * \n-     * @param duration  the duration, in milliseconds\n-     */\n-    protected void setTotalMillis(long duration) {\n-        setTotalMillis(iType, duration);\n-    }\n-\n-    /**\n-     * This method is private to prevent subclasses from overriding.\n-     *\n-     * @param duration  the duration, in milliseconds\n-     */\n-    private void setTotalMillis(DurationType type, long duration) {\n-        if (duration == 0) {\n-            iTotalMillis = duration;\n-            if (iState != STATE_TOTAL_MILLIS_MASTER) {\n-                iState = STATE_CALCULATED;\n-            }\n-\n-            iYears = 0;\n-            iMonths = 0;\n-            iWeeks = 0;\n-            iDays = 0;\n-            iHours = 0;\n-            iMinutes = 0;\n-            iSeconds = 0;\n-            iMillis = 0;\n-\n-            return;\n-        }\n-        \n-        type = type.withChronology(type.getChronology().withUTC());\n-        long startInstant = 0;\n-        int years = 0, months = 0, weeks = 0, days = 0;\n-        int hours = 0, minutes = 0, seconds = 0, millis = 0;\n-        DurationField field;\n-        \n-        field = type.years();\n-        if (field.isSupported() && field.isPrecise()) {\n-            years = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, years);\n-        }\n-        field = type.months();\n-        if (field.isSupported() && field.isPrecise()) {\n-            months = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, months);\n-        }\n-        field = type.weeks();\n-        if (field.isSupported() && field.isPrecise()) {\n-            weeks = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, weeks);\n-        }\n-        field = type.days();\n-        if (field.isSupported() && field.isPrecise()) {\n-            days = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, days);\n-        }\n-        field = type.hours();\n-        if (field.isSupported() && field.isPrecise()) {\n-            hours = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, hours);\n-        }\n-        field = type.minutes();\n-        if (field.isSupported() && field.isPrecise()) {\n-            minutes = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, minutes);\n-        }\n-        field = type.seconds();\n-        if (field.isSupported() && field.isPrecise()) {\n-            seconds = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, seconds);\n-        }\n-        field = type.millis();\n-        if (field.isSupported() && field.isPrecise()) {\n-            millis = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, millis);\n-        }\n-        \n-        // assign fields in one block to reduce threading issues\n-        iYears = years;\n-        iMonths = months;\n-        iWeeks = weeks;\n-        iDays = days;\n-        iHours = hours;\n-        iMinutes = minutes;\n-        iSeconds = seconds;\n-        iMillis = millis;\n-        // (end - start) is excess to be discarded\n-        iTotalMillis = duration - (duration - startInstant);\n-        if (iState != STATE_TOTAL_MILLIS_MASTER) {\n-            iState = STATE_CALCULATED;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Walks through the field values, determining total millis and whether\n-     * this duration is precise.\n-     *\n-     * @return new state\n-     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n-     */\n-    private int updateTotalMillis() {\n-        return updateTotalMillis(iYears, iMonths, iWeeks, iDays, iHours, iMinutes, iSeconds, iMillis);\n-    }\n-\n-    /**\n-     * Walks through the field values, determining total millis and whether\n-     * this duration is precise.\n-     *\n-     * @return new state\n-     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n-     */\n-    private int updateTotalMillis(int years, int months, int weeks, int days,\n-                                  int hours, int minutes, int seconds, int millis) {\n-        final DurationType type = iType;\n-\n-        boolean isPrecise = true;\n-        long totalMillis = 0;\n-\n-        DurationField field;\n-        if (years != 0) {\n-            field = type.years();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(years));\n-            }\n-        }\n-        if (months != 0) {\n-            field = type.months();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(months));\n-            }\n-        }\n-        if (weeks != 0) {\n-            field = type.weeks();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(weeks));\n-            }\n-        }\n-        if (days != 0) {\n-            field = type.days();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(days));\n-            }\n-        }\n-        if (hours != 0) {\n-            field = type.hours();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(hours));\n-            }\n-        }\n-        if (minutes != 0) {\n-            field = type.minutes();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(minutes));\n-            }\n-        }\n-        if (seconds != 0) {\n-            field = type.seconds();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(seconds));\n-            }\n-        }\n-        if (millis != 0) {\n-            field = type.millis();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(millis));\n-            }\n-        }\n-        \n-        iTotalMillis = totalMillis;\n-        if (iState == STATE_TOTAL_MILLIS_MASTER) {\n-            return STATE_TOTAL_MILLIS_MASTER;\n-        } else if (isPrecise) {\n-            return iState = STATE_CALCULATED;\n-        } else {\n-            return iState = STATE_NOT_CALCULABLE;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Adds a millisecond duration to this one. As a side-effect, all field\n-     * values are normalized.\n-     * \n-     * @param duration  the duration, in milliseconds\n-     * @throws IllegalStateException if the duration is imprecise\n-     * @throws ArithmeticException if the addition exceeds the capacity of the duration\n-     */\n-    protected void add(long duration) {\n-        setTotalMillis(FieldUtils.safeAdd(getTotalMillis(), duration));\n-    }\n-    \n-    /**\n-     * Adds a duration to this one.\n-     * \n-     * @param duration  the duration to add, mulls means add nothing\n-     * @throws IllegalStateException if the duration is imprecise\n-     */\n-    protected void add(ReadableDuration duration) {\n-        if (duration != null) {\n-            add(duration.getTotalMillis());\n-        }\n-    }\n-    \n-    /**\n-     * Normalizes all the field values in this duration.\n-     *\n-     * @throws IllegalStateException if this duration is imprecise\n-     */\n-    protected void normalize() {\n-        setTotalMillis(getTotalMillis());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of years of the duration.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     * \n-     * @param years  the number of years\n-     * @throws UnsupportedOperationException if field is not supported.\n-     */\n-    protected void setYears(int years) {\n-        if (years != iYears) {\n-            if (years != 0) {\n-                checkSupport(iType.years(), \"years\");\n-            }\n-            if (iState == STATE_TOTAL_MILLIS_MASTER) {\n-                updateTotalMillis(years, iMonths, iWeeks, iDays, iHours, iMinutes, iSeconds, iMillis);\n-                iYears = years;\n-            } else {\n-                iYears = years;\n-                iState = STATE_UNKNOWN;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Adds the specified years to the number of years in the duration.\n-     * \n-     * @param years  the number of years\n-     * @throws UnsupportedOperationException if field is not supported\n-     * @throws ArithmeticException if the addition exceeds the capacity of the duration\n-     */\n-    protected void addYears(int years) {\n-        setYears(FieldUtils.safeAdd(getYears(), years));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of months of the duration.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     * \n-     * @param months  the number of months\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setMonths(int months) {\n-        if (months != iMonths) {\n-            if (months != 0) {\n-                checkSupport(iType.months(), \"months\");\n-            }\n-            if (iState == STATE_TOTAL_MILLIS_MASTER) {\n-                updateTotalMillis(iYears, months, iWeeks, iDays, iHours, iMinutes, iSeconds, iMillis);\n-                iMonths = months;\n-            } else {\n-                iMonths = months;\n-                iState = STATE_UNKNOWN;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Adds the specified months to the number of months in the duration.\n-     * \n-     * @param months  the number of months\n-     * @throws UnsupportedOperationException if field is not supported\n-     * @throws ArithmeticException if the addition exceeds the capacity of the duration\n-     */\n-    protected void addMonths(int months) {\n-        setMonths(FieldUtils.safeAdd(getMonths(), months));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of weeks of the duration.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     * \n-     * @param weeks  the number of weeks\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setWeeks(int weeks) {\n-        if (weeks != iWeeks) {\n-            if (weeks != 0) {\n-                checkSupport(iType.weeks(), \"weeks\");\n-            }\n-            if (iState == STATE_TOTAL_MILLIS_MASTER) {\n-                updateTotalMillis(iYears, iMonths, weeks, iDays, iHours, iMinutes, iSeconds, iMillis);\n-                iWeeks = weeks;\n-            } else {\n-                iWeeks = weeks;\n-                iState = STATE_UNKNOWN;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Adds the specified weeks to the number of weeks in the duration.\n-     * \n-     * @param weeks  the number of weeks\n-     * @throws UnsupportedOperationException if field is not supported\n-     * @throws ArithmeticException if the addition exceeds the capacity of the duration\n-     */\n-    protected void addWeeks(int weeks) {\n-        setWeeks(FieldUtils.safeAdd(getWeeks(), weeks));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of days of the duration.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     * \n-     * @param days  the number of days\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setDays(int days) {\n-        if (days != iDays) {\n-            if (days != 0) {\n-                checkSupport(iType.days(), \"days\");\n-            }\n-            if (iState == STATE_TOTAL_MILLIS_MASTER) {\n-                updateTotalMillis(iYears, iMonths, iWeeks, days, iHours, iMinutes, iSeconds, iMillis);\n-                iDays = days;\n-            } else {\n-                iDays = days;\n-                iState = STATE_UNKNOWN;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Adds the specified days to the number of days in the duration.\n-     * \n-     * @param days  the number of days\n-     * @throws UnsupportedOperationException if field is not supported\n-     * @throws ArithmeticException if the addition exceeds the capacity of the duration\n-     */\n-    protected void addDays(int days) {\n-        setDays(FieldUtils.safeAdd(getDays(), days));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of hours of the duration.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     * \n-     * @param hours  the number of hours\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setHours(int hours) {\n-        if (hours != iHours) {\n-            if (hours != 0) {\n-                checkSupport(iType.hours(), \"hours\");\n-            }\n-            if (iState == STATE_TOTAL_MILLIS_MASTER) {\n-                updateTotalMillis(iYears, iMonths, iWeeks, iDays, hours, iMinutes, iSeconds, iMillis);\n-                iHours = hours;\n-            } else {\n-                iHours = hours;\n-                iState = STATE_UNKNOWN;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Adds the specified hours to the number of hours in the duration.\n-     * \n-     * @param hours  the number of hours\n-     * @throws UnsupportedOperationException if field is not supported\n-     * @throws ArithmeticException if the addition exceeds the capacity of the duration\n-     */\n-    protected void addHours(int hours) {\n-        setHours(FieldUtils.safeAdd(getHours(), hours));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of minutes of the duration.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     * \n-     * @param minutes  the number of minutes\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setMinutes(int minutes) {\n-        if (minutes != iMinutes) {\n-            if (minutes != 0) {\n-                checkSupport(iType.minutes(), \"minutes\");\n-            }\n-            if (iState == STATE_TOTAL_MILLIS_MASTER) {\n-                updateTotalMillis(iYears, iMonths, iWeeks, iDays, iHours, minutes, iSeconds, iMillis);\n-                iMinutes = minutes;\n-            } else {\n-                iMinutes = minutes;\n-                iState = STATE_UNKNOWN;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Adds the specified minutes to the number of minutes in the duration.\n-     * \n-     * @param minutes  the number of minutes\n-     * @throws UnsupportedOperationException if field is not supported\n-     * @throws ArithmeticException if the addition exceeds the capacity of the duration\n-     */\n-    protected void addMinutes(int minutes) {\n-        setMinutes(FieldUtils.safeAdd(getMinutes(), minutes));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of seconds of the duration.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     * \n-     * @param seconds  the number of seconds\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setSeconds(int seconds) {\n-        if (seconds != iSeconds) {\n-            if (seconds != 0) {\n-                checkSupport(iType.seconds(), \"seconds\");\n-            }\n-            if (iState == STATE_TOTAL_MILLIS_MASTER) {\n-                updateTotalMillis(iYears, iMonths, iWeeks, iDays, iHours, iMinutes, seconds, iMillis);\n-                iSeconds = seconds;\n-            } else {\n-                iSeconds = seconds;\n-                iState = STATE_UNKNOWN;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Adds the specified seconds to the number of seconds in the duration.\n-     * \n-     * @param seconds  the number of seconds\n-     * @throws UnsupportedOperationException if field is not supported\n-     * @throws ArithmeticException if the addition exceeds the capacity of the duration\n-     */\n-    protected void addSeconds(int seconds) {\n-        setSeconds(FieldUtils.safeAdd(getSeconds(), seconds));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of millis of the duration.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     * \n-     * @param millis  the number of millis\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setMillis(int millis) {\n-        if (millis != iMillis) {\n-            if (millis != 0) {\n-                checkSupport(iType.millis(), \"millis\");\n-            }\n-            if (iState == STATE_TOTAL_MILLIS_MASTER) {\n-                updateTotalMillis(iYears, iMonths, iWeeks, iDays, iHours, iMinutes, iSeconds, millis);\n-                iMillis = millis;\n-            } else {\n-                iMillis = millis;\n-                iState = STATE_UNKNOWN;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Adds the specified millis to the number of millis in the duration.\n-     * \n-     * @param millis  the number of millis\n-     * @throws UnsupportedOperationException if field is not supported\n-     * @throws ArithmeticException if the addition exceeds the capacity of the duration\n-     */\n-    protected void addMillis(int millis) {\n-        setMillis(FieldUtils.safeAdd(getMillis(), millis));\n+    protected void setMillis(long length) {\n+        iMillis = length;\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/AbstractInterval.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractInterval.java\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.IntervalConverter;\n+import org.joda.time.field.FieldUtils;\n import org.joda.time.format.DateTimePrinter;\n import org.joda.time.format.ISODateTimeFormat;\n \n      */\n     public AbstractInterval(Object interval) {\n         super();\n-        Duration duration;\n-        if (interval instanceof ReadableInterval) {\n+        TimePeriod duration;\n+        if (interval instanceof AbstractInterval) {\n+            AbstractInterval ri = (AbstractInterval) interval;\n+            iStartMillis = ri.iStartMillis;\n+            iStartInstant = ri.iStartInstant;\n+            iEndMillis = ri.iEndMillis;\n+            iEndInstant = ri.iEndInstant;\n+            iDuration = ri.iDuration;\n+            \n+        } else if (interval instanceof ReadableInterval) {\n             ReadableInterval ri = (ReadableInterval) interval;\n             iStartMillis = ri.getStartMillis();\n             iEndMillis = ri.getEndMillis();\n-            duration = ri.getDuration();\n+            \n         } else {\n             IntervalConverter converter = ConverterManager.getInstance().getIntervalConverter(interval);\n             if (this instanceof ReadWritableInterval) {\n                 converter.setInto((ReadWritableInterval) this, interval);\n-                duration = null;\n             } else {\n-                MutableInterval mi = new MutableInterval(0, 0);\n+                MutableInterval mi = new MutableInterval();\n                 converter.setInto(mi, interval);\n                 iStartMillis = mi.getStartMillis();\n                 iEndMillis = mi.getEndMillis();\n-                duration = mi.getDuration();\n             }\n-        }\n-        if (duration != null && duration.isPrecise()) {\n-            iDuration = duration;\n         }\n     }\n \n     }\n \n     /**\n-     * Constructs an interval from a start instant and a duration.\n-     * <p>\n-     * When forming the interval, the chronology from the instant is used\n-     * if present, otherwise the chronology of the duration is used.\n+     * Constructs an interval from a start instant and a millisecond duration.\n      * \n      * @param start  start of this interval, null means now\n-     * @param duration  duration of this interval, null means zero length\n+     * @param duration  the duration of this interval, null means zero length\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n     public AbstractInterval(ReadableInstant start, ReadableDuration duration) {\n         super();\n         if (duration == null) {\n             iEndMillis = iStartMillis;\n         } else {\n-            iEndMillis = duration.addTo(iStartMillis, 1, chrono);\n-            if (duration.isPrecise()) {\n-                iDuration = duration.toDuration();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Constructs an interval from a duration and an end instant.\n-     * <p>\n-     * When forming the interval, the chronology from the instant is used\n-     * if present, otherwise the chronology of the duration is used.\n-     * \n-     * @param duration  duration of this interval, null means zero length\n+            iEndMillis = FieldUtils.safeAdd(iStartMillis, duration.getMillis());\n+            iDuration = duration.toDuration();\n+        }\n+    }\n+\n+    /**\n+     * Constructs an interval from a millisecond duration and an end instant.\n+     * \n+     * @param duration  the duration of this interval, null means zero length\n      * @param end  end of this interval, null means now\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n     public AbstractInterval(ReadableDuration duration, ReadableInstant end) {\n         super();\n         if (duration == null) {\n             iStartMillis = iEndMillis;\n         } else {\n-            iStartMillis = duration.addTo(iEndMillis, 1, chrono);\n-            if (duration.isPrecise()) {\n-                iDuration = duration.toDuration();\n+            iStartMillis = FieldUtils.safeAdd(iEndMillis, -duration.getMillis());\n+            iDuration = duration.toDuration();\n+        }\n+    }\n+\n+    /**\n+     * Constructs an interval from a start instant and a period.\n+     * <p>\n+     * When forming the interval, the chronology from the instant is used\n+     * if present, otherwise the chronology of the period is used.\n+     * \n+     * @param start  start of this interval, null means now\n+     * @param period  the period of this interval, null means zero length\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    public AbstractInterval(ReadableInstant start, ReadableTimePeriod period) {\n+        super();\n+        Chronology chrono = null;\n+        if (start == null) {\n+            iStartMillis = DateTimeUtils.currentTimeMillis();\n+        } else {\n+            iStartMillis = start.getMillis();\n+            chrono = start.getChronology();\n+            if (start instanceof Instant) {\n+                iStartInstant = (Instant) start;\n             }\n+        }\n+        if (period == null) {\n+            iEndMillis = iStartMillis;\n+        } else {\n+            iEndMillis = period.addTo(iStartMillis, 1, chrono);\n+        }\n+    }\n+\n+    /**\n+     * Constructs an interval from a period and an end instant.\n+     * <p>\n+     * When forming the interval, the chronology from the instant is used\n+     * if present, otherwise the chronology of the period is used.\n+     * \n+     * @param period  the period of this interval, null means zero length\n+     * @param end  end of this interval, null means now\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    public AbstractInterval(ReadableTimePeriod period, ReadableInstant end) {\n+        super();\n+        Chronology chrono = null;\n+        if (end == null) {\n+            iEndMillis = DateTimeUtils.currentTimeMillis();\n+        } else {\n+            iEndMillis = end.getMillis();\n+            chrono = end.getChronology();\n+            if (end instanceof Instant) {\n+                iEndInstant = (Instant) end;\n+            }\n+        }\n+        if (period == null) {\n+            iStartMillis = iEndMillis;\n+        } else {\n+            iStartMillis = period.addTo(iEndMillis, -1, chrono);\n         }\n     }\n \n         return iEndInstant;\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Gets the duration of this time interval in milliseconds.\n      * <p>\n      * a known date.\n      *\n      * @return the duration of the time interval in milliseconds\n+     * @throws ArithmeticException if the duration exceeds the capacity of a long\n      */\n     public final long getDurationMillis() {\n-        return (getEndMillis() - getStartMillis());\n-    }\n-\n-    /**\n-     * Gets the precise duration of this time interval.\n+        return FieldUtils.safeAdd(getEndMillis(), -getStartMillis());\n+    }\n+\n+    /**\n+     * Gets the millisecond duration of this time interval.\n      * <p>\n      * If this interval was constructed using a precise duration then that object will\n      * be returned. Otherwise a new Duration instance using the MillisType is returned.\n      *\n      * @return the precise duration of the time interval\n+     * @throws ArithmeticException if the duration exceeds the capacity of a long\n      */\n     public final Duration getDuration() {\n         if (iDuration == null) {\n-            return getDuration(null);\n+            if (iStartMillis == iEndMillis) {\n+                iDuration = Duration.ZERO;\n+            } else {\n+                iDuration = new Duration(iStartMillis, iEndMillis);\n+            }\n         }\n         return iDuration;\n-    }\n-\n-    /**\n-     * Gets the duration of this time interval using the specified duration type.\n-     *\n-     * @param type  the requested type of the duration, null means MillisType\n-     * @return the duration of the time interval\n-     */\n-    public final Duration getDuration(DurationType type) {\n-        if (type == null) {\n-            type = DurationType.getMillisType();\n-        }\n-        Duration duration = iDuration;\n-        if (duration == null) {\n-            if (type.isPrecise()) {\n-                duration = new Duration(getEndMillis() - getStartMillis(), type);\n-                if (type.equals(DurationType.getMillisType())) {\n-                    iDuration = duration;\n-                }\n-            } else {\n-                duration = new Duration(getStartInstant(), getEndInstant(), type);\n-            }\n-        } else {\n-            duration = duration.withDurationTypeUsingTotalMillis(type);\n-        }\n-        return duration;\n     }\n \n     //-----------------------------------------------------------------------\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Converts the duration of the interval to a time period using the\n+     * All duration type.\n+     * <p>\n+     * This method should be used to exract the field values describing the\n+     * difference between the start and end instants.\n+     * The time period may not be precise - if you want the millisecond duration\n+     * then you should use {@link #getDuration()}.\n+     *\n+     * @param type  the requested type of the duration, null means AllType\n+     * @return a time period derived from the interval\n+     */\n+    public final TimePeriod toTimePeriod() {\n+        return new TimePeriod(getStartMillis(), getEndMillis());\n+    }\n+\n+    /**\n+     * Converts the duration of the interval to a time period using the\n+     * specified duration type.\n+     * <p>\n+     * This method should be used to exract the field values describing the\n+     * difference between the start and end instants.\n+     * The time period may not be precise - if you want the millisecond duration\n+     * then you should use {@link #getDuration()}.\n+     *\n+     * @param type  the requested type of the duration, null means AllType\n+     * @return a time period derived from the interval\n+     */\n+    public final TimePeriod toTimePeriod(DurationType type) {\n+        return new TimePeriod(getStartMillis(), getEndMillis(), type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Compares this object with the specified object for equality based\n      * on start and end millis. All ReadableInterval instances are accepted.\n      * <p>\n      * @param readableInterval  a readable interval to check against\n      * @return true if the start and end millis are equal\n      */\n-    public boolean equals(Object readableInterval) {\n+    public final boolean equals(Object readableInterval) {\n         if (this == readableInterval) {\n             return true;\n         }\n      *\n      * @return suitable hashcode\n      */\n-    public int hashCode() {\n+    public final int hashCode() {\n         int result = 97;\n         result = 31 * result + ((int) (getStartMillis() ^ (getStartMillis() >>> 32)));\n         result = 31 * result + ((int) (getEndMillis() ^ (getEndMillis() >>> 32)));\n     }\n \n     /**\n-     * Sets the duration of this time interval, preserving the start instant.\n+     * Stores the duration of this time interval.\n      * <p>\n      * Subclasses that wish to be immutable should override this method with an\n      * empty implementation that is protected and final. This also ensures that\n      * all lower subclasses are also immutable.\n      *\n+     * @param duration  new duration for interval, null means zero length\n+     */\n+    protected void storeDuration(Duration duration) {\n+        // this method exists so that subclasses can block it\n+        iDuration = duration;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the duration of this time interval, preserving the start instant.\n+     *\n      * @param duration  new duration for interval\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    protected void setDurationAfterStart(long duration) {\n+        setEndMillis(FieldUtils.safeAdd(getStartMillis(), duration));\n+    }\n+\n+    /**\n+     * Sets the duration of this time interval, preserving the end instant.\n+     *\n+     * @param duration  new duration for interval\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    protected void setDurationBeforeEnd(long duration) {\n+        setStartMillis(FieldUtils.safeAdd(getEndMillis(), -duration));\n+    }\n+\n+    /**\n+     * Sets the duration of this time interval, preserving the start instant.\n+     *\n+     * @param duration  new duration for interval, null means zero length\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n     protected void setDurationAfterStart(ReadableDuration duration) {\n         if (duration == null) {\n-            throw new IllegalArgumentException(\"The duration must not be null\");\n-        }\n-        setEndMillis(duration.addTo(getStartMillis(), 1));\n-        if (duration.isPrecise()) {\n-            iDuration = duration.toDuration();\n+            setEndMillis(getStartMillis());\n+        } else {\n+            setEndMillis(FieldUtils.safeAdd(getStartMillis(), duration.getMillis()));\n+            storeDuration(duration.toDuration());\n         }\n     }\n \n     /**\n      * Sets the duration of this time interval, preserving the end instant.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     *\n-     * @param duration  new duration for interval\n+     *\n+     * @param duration  new duration for interval, null means zero length\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n     protected void setDurationBeforeEnd(ReadableDuration duration) {\n         if (duration == null) {\n-            throw new IllegalArgumentException(\"The duration must not be null\");\n-        }\n-        setStartMillis(duration.addTo(getEndMillis(), -1));\n-        if (duration.isPrecise()) {\n-            iDuration = duration.toDuration();\n+            setStartMillis(getEndMillis());\n+        } else {\n+            setStartMillis(FieldUtils.safeAdd(getEndMillis(), -duration.getMillis()));\n+            storeDuration(duration.toDuration());\n+        }\n+    }\n+\n+    /**\n+     * Sets the period of this time interval, preserving the start instant.\n+     *\n+     * @param period  new period for interval, null means zero length\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    protected void setTimePeriodAfterStart(ReadableTimePeriod period) {\n+        if (period == null) {\n+            setEndMillis(getStartMillis());\n+        } else {\n+            setEndMillis(period.addTo(getStartMillis(), 1));\n+        }\n+    }\n+\n+    /**\n+     * Sets the period of this time interval, preserving the end instant.\n+     *\n+     * @param period  new period for interval, null means zero length\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    protected void setTimePeriodBeforeEnd(ReadableTimePeriod period) {\n+        if (period == null) {\n+            setStartMillis(getEndMillis());\n+        } else {\n+            setStartMillis(period.addTo(getEndMillis(), -1));\n         }\n     }\n \n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/AbstractTimePeriod.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.convert.DurationConverter;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISOTimePeriodFormat;\n+\n+/**\n+ * AbstractDuration provides the common behaviour for duration classes.\n+ * <p>\n+ * This class should generally not be used directly by API users. The \n+ * {@link ReadableDuration} interface should be used when different \n+ * kinds of durations are to be referenced.\n+ * <p>\n+ * AbstractDuration subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class AbstractTimePeriod\n+        implements ReadableTimePeriod, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -2110953284060001145L;\n+    /** Millis cache is currently unknown */\n+    private static final int STATE_UNKNOWN = 0;\n+    /** Millis cache is not calculable */\n+    private static final int STATE_NOT_CALCULABLE = 1;\n+    /** Millis cache has been calculated and is valid */\n+    private static final int STATE_CALCULATED = 2;\n+\n+    /** The duration type that allocates the duration to fields */\n+    private final DurationType iType;\n+    /** The object state */\n+    private int iState;\n+    /** The duration, if known */\n+    private long iDuration;\n+    /** Value for years */\n+    private int iYears;\n+    /** Value for months */\n+    private int iMonths;\n+    /** Value for weeks */\n+    private int iWeeks;\n+    /** Value for days */\n+    private int iDays;\n+    /** Value for hours */\n+    private int iHours;\n+    /** Value for minutes */\n+    private int iMinutes;\n+    /** Value for seconds */\n+    private int iSeconds;\n+    /** Value for millis */\n+    private int iMillis;\n+\n+    /**\n+     * Creates a duration from the given millisecond duration.\n+     * <p>\n+     * The millisecond duration will be split to fields using a UTC version of\n+     * the duration type.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this duration supports\n+     * @throws IllegalArgumentException if duration type is invalid\n+     */\n+    public AbstractTimePeriod(long duration, DurationType type) {\n+        super();\n+        type = checkDurationType(type);\n+        iType = type;\n+        // Only call a private method\n+        setTimePeriod(type, duration);\n+    }\n+\n+    /**\n+     * Creates a duration from a set of field values.\n+     *\n+     * @param years  amount of years in this duration, which must be zero if unsupported\n+     * @param months  amount of months in this duration, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this duration, which must be zero if unsupported\n+     * @param days  amount of days in this duration, which must be zero if unsupported\n+     * @param hours  amount of hours in this duration, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this duration, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this duration, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this duration, which must be zero if unsupported\n+     * @param type  which set of fields this duration supports\n+     * @throws IllegalArgumentException if duration type is invalid\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    public AbstractTimePeriod(int years, int months, int weeks, int days,\n+                            int hours, int minutes, int seconds, int millis,\n+                            DurationType type) {\n+        super();\n+        type = checkDurationType(type);\n+        iType = type;\n+        // Only call a private method\n+        setTimePeriod(type, years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param type  which set of fields this duration supports\n+     * @throws IllegalArgumentException if duration type is invalid\n+     */\n+    public AbstractTimePeriod(long startInstant, long endInstant, DurationType type) {\n+        super();\n+        type = checkDurationType(type);\n+        iType = type;\n+        // Only call a private method\n+        setTimePeriod(type, startInstant, endInstant);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     * @param type  which set of fields this duration supports\n+     * @throws IllegalArgumentException if duration type is invalid\n+     */\n+    public AbstractTimePeriod(\n+            ReadableInstant startInstant, ReadableInstant  endInstant, DurationType type) {\n+        super();\n+        type = checkDurationType(type);\n+        if (startInstant == null && endInstant == null) {\n+            iType = type;\n+        } else {\n+            long start = (startInstant == null ? DateTimeUtils.currentTimeMillis() : startInstant.getMillis());\n+            long end = (endInstant == null ? DateTimeUtils.currentTimeMillis() : endInstant.getMillis());\n+            iType = type;\n+            // Only call a private method\n+            setTimePeriod(type, start, end);\n+        }\n+    }\n+\n+    /**\n+     * Creates a new duration based on another using the {@link ConverterManager}.\n+     *\n+     * @param duration  duration to convert\n+     * @param type  which set of fields this duration supports, null means use type from object\n+     * @throws IllegalArgumentException if duration is invalid\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    public AbstractTimePeriod(Object duration, DurationType type) {\n+        super();\n+        DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);\n+        type = (type == null ? converter.getDurationType(duration, false) : type);\n+        type = checkDurationType(type);\n+        iType = type;\n+        if (type.isPrecise() && converter.isPrecise(duration)) {\n+            // Only call a private method\n+            setTimePeriod(type, converter.getDurationMillis(duration));\n+        } else if (this instanceof ReadWritableTimePeriod) {\n+            converter.setInto((ReadWritableTimePeriod) this, duration);\n+        } else {\n+            // Only call a private method\n+            setTimePeriod(type, new MutableTimePeriod(duration, type));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates a duration type, converting nulls to a default value and\n+     * checking the type is suitable for this instance.\n+     * \n+     * @param type  the type to check, may be null\n+     * @return the validated type to use, not null\n+     * @throws IllegalArgumentException if the duration type is invalid\n+     */\n+    protected abstract DurationType checkDurationType(DurationType type);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the object which defines which fields this duration supports.\n+     */\n+    public final DurationType getDurationType() {\n+        return iType;\n+    }\n+\n+    /**\n+     * Is this duration a precise length of time, or descriptive.\n+     * <p>\n+     * A typical precise duration could include millis, seconds, minutes or hours,\n+     * but days, weeks, months and years usually vary in length, resulting in\n+     * an imprecise duration.\n+     * <p>\n+     * An imprecise duration can be made precise by pairing it with a\n+     * date in a {@link ReadableInterval}.\n+     *\n+     * @return true if the duration is precise\n+     */\n+    public final boolean isPrecise() {\n+        int state = iState;\n+        if (state == STATE_UNKNOWN) {\n+            state = updateTotalMillis();\n+        }\n+        return (state == STATE_CALCULATED);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds this duration to the given instant using the chronology of the duration\n+     * which typically ignores time zones.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n+     * duration to\n+     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @return milliseconds value plus this duration times scalar\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    public final long addTo(long instant, int scalar) {\n+        return addTo(instant, scalar, null);\n+    }\n+\n+    /**\n+     * Adds this duration to the given instant using a specific chronology.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n+     * duration to\n+     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @param chrono  override the duration's chronology, unless null is passed in\n+     * @return milliseconds value plus this duration times scalar\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    public final long addTo(long instant, int scalar, Chronology chrono) {\n+        if (isPrecise()) {\n+            return FieldUtils.safeAdd(instant, toDurationMillis() * scalar);\n+        }\n+        \n+        DurationType type = iType;\n+        if (chrono != null) {\n+            type = type.withChronology(chrono);\n+        }\n+        \n+        long value; // used to lock fields against threading issues\n+        value = scaleValue(iYears, scalar);\n+        if (value != 0) {\n+            instant = type.years().add(instant, value);\n+        }\n+        value = scaleValue(iMonths, scalar);\n+        if (value != 0) {\n+            instant = type.months().add(instant, value);\n+        }\n+        value = scaleValue(iWeeks, scalar);\n+        if (value != 0) {\n+            instant = type.weeks().add(instant, value);\n+        }\n+        value = scaleValue(iDays, scalar);\n+        if (value != 0) {\n+            instant = type.days().add(instant, value);\n+        }\n+        value = scaleValue(iHours, scalar);\n+        if (value != 0) {\n+            instant = type.hours().add(instant, value);\n+        }\n+        value = scaleValue(iMinutes, scalar);\n+        if (value != 0) {\n+            instant = type.minutes().add(instant, value);\n+        }\n+        value = scaleValue(iSeconds, scalar);\n+        if (value != 0) {\n+            instant = type.seconds().add(instant, value);\n+        }\n+        value = scaleValue(iMillis, scalar);\n+        if (value != 0) {\n+            instant = type.millis().add(instant, value);\n+        }\n+\n+        return instant;\n+    }\n+\n+    /**\n+     * Convert the scalar to a multiple efficiently.\n+     * \n+     * @param value  the value\n+     * @param scalar  the scalar\n+     * @return the converted value\n+     */\n+    private static long scaleValue(int value, int scalar) {\n+        long val = value;  // use long to avoid truncation\n+        switch (scalar) {\n+        case -1:\n+            return -val;\n+        case 0:\n+            return 0;\n+        case 1:\n+            return val;\n+        default:\n+            return val * scalar;\n+        }\n+    }\n+\n+    /**\n+     * Adds this duration to the given instant using the chronology of the specified\n+     * instant (if present), returning a new Instant.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the instant to add the duration to, null means now\n+     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @return instant with the original value plus this duration times scalar\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    public final Instant addTo(ReadableInstant instant, int scalar) {\n+        if (instant == null) {\n+            return new Instant(addTo(DateTimeUtils.currentTimeMillis(), scalar));\n+        }\n+        return new Instant(addTo(instant.getMillis(), scalar, instant.getChronology()));\n+    }\n+\n+    /**\n+     * Adds this duration into the given mutable instant using the chronology of\n+     * the specified mutable instant (if present).\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the instant to update with the added duration, must not be null\n+     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @throws IllegalArgumentException if the instant is null\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    public final void addInto(ReadWritableInstant instant, int scalar) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        instant.setMillis(addTo(instant.getMillis(), scalar, instant.getChronology()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the years field part of the duration.\n+     * \n+     * @return the number of years in the duration, zero if unsupported\n+     */\n+    public final int getYears() {\n+        return iYears;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the months field part of the duration.\n+     * \n+     * @return the number of months in the duration, zero if unsupported\n+     */\n+    public final int getMonths() {\n+        return iMonths;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the weeks field part of the duration.\n+     * \n+     * @return the number of weeks in the duration, zero if unsupported\n+     */\n+    public final int getWeeks() {\n+        return iWeeks;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the days field part of the duration.\n+     * \n+     * @return the number of days in the duration, zero if unsupported\n+     */\n+    public final int getDays() {\n+        return iDays;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the hours field part of the duration.\n+     * \n+     * @return the number of hours in the duration, zero if unsupported\n+     */\n+    public final int getHours() {\n+        return iHours;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the minutes field part of the duration.\n+     * \n+     * @return the number of minutes in the duration, zero if unsupported\n+     */\n+    public final int getMinutes() {\n+        return iMinutes;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the seconds field part of the duration.\n+     * \n+     * @return the number of seconds in the duration, zero if unsupported\n+     */\n+    public final int getSeconds() {\n+        return iSeconds;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the millis field part of the duration.\n+     * \n+     * @return the number of millis in the duration, zero if unsupported\n+     */\n+    public final int getMillis() {\n+        return iMillis;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this object as an immutable TimePeriod. This can be useful if you\n+     * don't trust the implementation of the interface to be well-behaved, or\n+     * to get a guaranteed immutable object.\n+     * \n+     * @return a Duration using the same field set and values\n+     */\n+    public final TimePeriod toTimePeriod() {\n+        if (this instanceof TimePeriod) {\n+            return (TimePeriod) this;\n+        }\n+        return new TimePeriod(this);\n+    }\n+\n+    /**\n+     * Get this object as a MutableTimePeriod.\n+     * \n+     * @return a MutableTimePeriod using the same field set and values\n+     */\n+    public final MutableTimePeriod toMutableTimePeriod() {\n+        return new MutableTimePeriod(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the total length of this duration in milliseconds, \n+     * failing if the duration is imprecise.\n+     *\n+     * @return the total length of the duration in milliseconds.\n+     * @throws IllegalStateException if the duration is imprecise\n+     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n+     */\n+    public final long toDurationMillis() {\n+        int state = iState;\n+        if (state == STATE_UNKNOWN) {\n+            state = updateTotalMillis();\n+        }\n+        if (state != STATE_CALCULATED) {\n+            throw new IllegalStateException(\"Duration is imprecise\");\n+        }\n+        return iDuration;\n+    }\n+\n+    /**\n+     * Gets the total length of this duration in milliseconds, \n+     * failing if the duration is imprecise.\n+     *\n+     * @return the total length of the duration in milliseconds.\n+     * @throws IllegalStateException if the duration is imprecise\n+     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n+     */\n+    public final Duration toDuration() {\n+        return new Duration(toDurationMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the value of each field. All ReadableTimePeriod instances are accepted.\n+     * <p>\n+     * To compare two durations for absolute duration (ie. millisecond duration\n+     * ignoring the fields), use {@link #toDurationMillis()} or {@link #toDuration()}.\n+     *\n+     * @param readableDuration  a readable duration to check against\n+     * @return true if all the field values are equal, false if\n+     *  not or the duration is null or of an incorrect type\n+     */\n+    public final boolean equals(Object readableTimePeriod) {\n+        if (this == readableTimePeriod) {\n+            return true;\n+        }\n+        if (readableTimePeriod instanceof ReadableTimePeriod == false) {\n+            return false;\n+        }\n+        ReadableTimePeriod other = (ReadableTimePeriod) readableTimePeriod;\n+        DurationType type = getDurationType();\n+        if (type.equals(other.getDurationType()) == false) {\n+            return false;\n+        }\n+        return getYears() == other.getYears()\n+            && getMonths() == other.getMonths()\n+            && getWeeks() == other.getWeeks()\n+            && getDays() == other.getDays()\n+            && getHours() == other.getHours()\n+            && getMinutes() == other.getMinutes()\n+            && getSeconds() == other.getSeconds()\n+            && getMillis() == other.getMillis();\n+    }\n+\n+    /**\n+     * Gets a hash code for the duration that is compatable with the \n+     * equals method.\n+     *\n+     * @return a hash code\n+     */\n+    public final int hashCode() {\n+        int hash = getDurationType().hashCode();\n+        hash = 53 * hash + getYears();\n+        hash = 53 * hash + getMonths();\n+        hash = 53 * hash + getWeeks();\n+        hash = 53 * hash + getDays();\n+        hash = 53 * hash + getHours();\n+        hash = 53 * hash + getMinutes();\n+        hash = 53 * hash + getSeconds();\n+        hash = 53 * hash + getMillis();\n+        return hash;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"P6H3M7S\" represents 6 hours, 3 minutes, 7 seconds.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public String toString() {\n+        return ISOTimePeriodFormat.getInstance().standard().print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the field is supported.\n+     */\n+    private static void checkArgument(DurationField field) {\n+        if (!field.isSupported()) {\n+            throw new IllegalArgumentException\n+                (\"Time period does not support field '\" + field.getName() + \"'\");\n+        }\n+    }\n+\n+    /**\n+     * Checks whether the field is supported.\n+     */\n+    private static void checkSupport(DurationField field) {\n+        if (!field.isSupported()) {\n+            throw new UnsupportedOperationException\n+                (\"Time period does not support field '\" + field.getName() + \"'\");\n+        }\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from another ReadableTimePeriod.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param period  the period to set, null means zero length period\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected void setTimePeriod(ReadableTimePeriod period) {\n+        if (period == null) {\n+            setTimePeriod(iType, 0L);\n+        } else {\n+            setTimePeriod(iType, period);\n+        }\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     */\n+    private void setTimePeriod(DurationType type, ReadableTimePeriod period) {\n+        setTimePeriod(type,\n+            period.getYears(), period.getMonths(),\n+            period.getWeeks(), period.getDays(),\n+            period.getHours(), period.getMinutes(),\n+            period.getSeconds(), period.getMillis());\n+    }\n+\n+    /**\n+     * Sets all the fields in one go.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param years  amount of years in this duration, which must be zero if unsupported\n+     * @param months  amount of months in this duration, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this duration, which must be zero if unsupported\n+     * @param days  amount of days in this duration, which must be zero if unsupported\n+     * @param hours  amount of hours in this duration, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this duration, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this duration, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this duration, which must be zero if unsupported\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected void setTimePeriod(int years, int months, int weeks, int days,\n+                               int hours, int minutes, int seconds, int millis) {\n+        setTimePeriod(iType, years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     */\n+    private void setTimePeriod(DurationType type,\n+                             int years, int months, int weeks, int days,\n+                             int hours, int minutes, int seconds, int millis) {\n+        if (years != 0) {\n+            checkArgument(type.years());\n+        }\n+        if (months != 0) {\n+            checkArgument(type.months());\n+        }\n+        if (weeks != 0) {\n+            checkArgument(type.weeks());\n+        }\n+        if (days != 0) {\n+            checkArgument(type.days());\n+        }\n+        if (hours != 0) {\n+            checkArgument(type.hours());\n+        }\n+        if (minutes != 0) {\n+            checkArgument(type.minutes());\n+        }\n+        if (seconds != 0) {\n+            checkArgument(type.seconds());\n+        }\n+        if (millis != 0) {\n+            checkArgument(type.millis());\n+        }\n+        \n+        // assign fields in one block to reduce threading issues\n+        iYears = years;\n+        iMonths = months;\n+        iWeeks = weeks;\n+        iDays = days;\n+        iHours = hours;\n+        iMinutes = minutes;\n+        iSeconds = seconds;\n+        iMillis = millis;\n+        iState = STATE_UNKNOWN;\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond interval.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    protected void setTimePeriod(long startInstant, long endInstant) {\n+        setTimePeriod(iType, startInstant, endInstant);\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    private void setTimePeriod(DurationType type, long startInstant, long endInstant) {\n+        long baseTotalMillis = (endInstant - startInstant);\n+        int years = 0, months = 0, weeks = 0, days = 0;\n+        int hours = 0, minutes = 0, seconds = 0, millis = 0;\n+        DurationField field;\n+        field = type.years();\n+        if (field.isSupported()) {\n+            years = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, years);\n+        }\n+        field = type.months();\n+        if (field.isSupported()) {\n+            months = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, months);\n+        }\n+        field = type.weeks();\n+        if (field.isSupported()) {\n+            weeks = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, weeks);\n+        }\n+        field = type.days();\n+        if (field.isSupported()) {\n+            days = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, days);\n+        }\n+        field = type.hours();\n+        if (field.isSupported()) {\n+            hours = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, hours);\n+        }\n+        field = type.minutes();\n+        if (field.isSupported()) {\n+            minutes = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, minutes);\n+        }\n+        field = type.seconds();\n+        if (field.isSupported()) {\n+            seconds = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, seconds);\n+        }\n+        field = type.millis();\n+        if (field.isSupported()) {\n+            millis = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, millis);\n+        }\n+        \n+        // assign fields in one block to reduce threading issues\n+        iYears = years;\n+        iMonths = months;\n+        iWeeks = weeks;\n+        iDays = days;\n+        iHours = hours;\n+        iMinutes = minutes;\n+        iSeconds = seconds;\n+        iMillis = millis;\n+        iState = STATE_UNKNOWN;\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond duration.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param duration  the duration, in milliseconds\n+     */\n+    protected void setTimePeriod(long duration) {\n+        setTimePeriod(iType, duration);\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     */\n+    private void setTimePeriod(DurationType type, long duration) {\n+        if (duration == 0) {\n+            iDuration = duration;\n+            iYears = 0;\n+            iMonths = 0;\n+            iWeeks = 0;\n+            iDays = 0;\n+            iHours = 0;\n+            iMinutes = 0;\n+            iSeconds = 0;\n+            iMillis = 0;\n+            iState = STATE_CALCULATED;\n+            return;\n+        }\n+        \n+        type = type.withChronology(type.getChronology().withUTC());\n+        long startInstant = 0;\n+        int years = 0, months = 0, weeks = 0, days = 0;\n+        int hours = 0, minutes = 0, seconds = 0, millis = 0;\n+        DurationField field;\n+        \n+        field = type.years();\n+        if (field.isSupported() && field.isPrecise()) {\n+            years = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, years);\n+        }\n+        field = type.months();\n+        if (field.isSupported() && field.isPrecise()) {\n+            months = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, months);\n+        }\n+        field = type.weeks();\n+        if (field.isSupported() && field.isPrecise()) {\n+            weeks = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, weeks);\n+        }\n+        field = type.days();\n+        if (field.isSupported() && field.isPrecise()) {\n+            days = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, days);\n+        }\n+        field = type.hours();\n+        if (field.isSupported() && field.isPrecise()) {\n+            hours = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, hours);\n+        }\n+        field = type.minutes();\n+        if (field.isSupported() && field.isPrecise()) {\n+            minutes = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, minutes);\n+        }\n+        field = type.seconds();\n+        if (field.isSupported() && field.isPrecise()) {\n+            seconds = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, seconds);\n+        }\n+        field = type.millis();\n+        if (field.isSupported() && field.isPrecise()) {\n+            millis = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, millis);\n+        }\n+        \n+        // assign fields in one block to reduce threading issues\n+        iYears = years;\n+        iMonths = months;\n+        iWeeks = weeks;\n+        iDays = days;\n+        iHours = hours;\n+        iMinutes = minutes;\n+        iSeconds = seconds;\n+        iMillis = millis;\n+        iState = STATE_UNKNOWN;\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from an interval dividing the\n+     * fields using the duration type.\n+     * \n+     * @param interval  the interval to set, null means zero length\n+     */\n+    protected void setTimePeriod(ReadableInterval interval) {\n+        if (interval != null) {\n+            setTimePeriod(interval.getStartMillis(), interval.getEndMillis());\n+        } else {\n+            setTimePeriod(0L);\n+        }\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a duration dividing the\n+     * fields using the duration type.\n+     * \n+     * @param duration  the duration to set, null means zero length\n+     */\n+    protected void setTimePeriod(ReadableDuration duration) {\n+        if (duration != null) {\n+            setTimePeriod(duration.getMillis());\n+        } else {\n+            setTimePeriod(0L);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Walks through the field values, determining total millis and whether\n+     * this duration is precise.\n+     *\n+     * @return new state\n+     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n+     */\n+    private int updateTotalMillis() {\n+        final DurationType type = iType;\n+\n+        boolean isPrecise = true;\n+        long totalMillis = 0;\n+\n+        DurationField field;\n+        int years = iYears, months = iMonths, weeks = iWeeks, days = iDays;\n+        int hours = iHours, minutes = iMinutes, seconds = iSeconds, millis = iMillis;\n+        if (years != 0) {\n+            field = type.years();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(years));\n+            }\n+        }\n+        if (months != 0) {\n+            field = type.months();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(months));\n+            }\n+        }\n+        if (weeks != 0) {\n+            field = type.weeks();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(weeks));\n+            }\n+        }\n+        if (days != 0) {\n+            field = type.days();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(days));\n+            }\n+        }\n+        if (hours != 0) {\n+            field = type.hours();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(hours));\n+            }\n+        }\n+        if (minutes != 0) {\n+            field = type.minutes();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(minutes));\n+            }\n+        }\n+        if (seconds != 0) {\n+            field = type.seconds();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(seconds));\n+            }\n+        }\n+        if (millis != 0) {\n+            field = type.millis();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(millis));\n+            }\n+        }\n+        \n+        iDuration = totalMillis;\n+        if (isPrecise) {\n+            return iState = STATE_CALCULATED;\n+        } else {\n+            return iState = STATE_NOT_CALCULABLE;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a period to this one by adding each field in turn.\n+     * \n+     * @param period  the period to add, null means add nothing\n+     * @throws IllegalArgumentException if the period being added contains a field\n+     * not supported by this period\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void add(ReadableTimePeriod period) {\n+        if (period != null) {\n+            setTimePeriod(\n+                FieldUtils.safeAdd(getYears(), period.getYears()),\n+                FieldUtils.safeAdd(getMonths(), period.getMonths()),\n+                FieldUtils.safeAdd(getWeeks(), period.getWeeks()),\n+                FieldUtils.safeAdd(getDays(), period.getDays()),\n+                FieldUtils.safeAdd(getHours(), period.getHours()),\n+                FieldUtils.safeAdd(getMinutes(), period.getMinutes()),\n+                FieldUtils.safeAdd(getSeconds(), period.getSeconds()),\n+                FieldUtils.safeAdd(getMillis(), period.getMillis())\n+            );\n+        }\n+    }\n+\n+    /**\n+     * Adds an interval to this one by dividing the interval into\n+     * fields and calling {@link #add(ReadableTimePeriod)}.\n+     * \n+     * @param interval  the interval to add, null means add nothing\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void add(ReadableInterval interval) {\n+        if (interval != null) {\n+            add(new TimePeriod(interval.getStartMillis(), interval.getEndMillis()));\n+        }\n+    }\n+\n+    /**\n+     * Adds a duration to this one by dividing the duration into\n+     * fields and calling {@link #add(ReadableTimePeriod)}.\n+     * \n+     * @param duration  the duration to add, null means add nothing\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void add(ReadableDuration duration) {\n+        if (duration != null) {\n+            add(new TimePeriod(duration.getMillis()));\n+        }\n+    }\n+\n+    /**\n+     * Adds a millisecond duration to this one by dividing the duration into\n+     * fields and calling {@link #add(ReadableTimePeriod)}.\n+     * \n+     * @param duration  the duration, in milliseconds\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void add(long duration) {\n+        add(new TimePeriod(duration));\n+    }\n+\n+    /**\n+     * Normalizes all the field values in this duration.\n+     * <p>\n+     * This method converts to a milliecond duration and back again.\n+     *\n+     * @throws IllegalStateException if this duration is imprecise\n+     */\n+    protected void normalize() {\n+        setTimePeriod(toDurationMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of years of the period.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void setYears(int years) {\n+        if (years != iYears) {\n+            if (years != 0) {\n+                checkSupport(iType.years());\n+            }\n+            iYears = years;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified years to the number of years in the period.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addYears(int years) {\n+        if (years != 0) {\n+            setYears(FieldUtils.safeAdd(getYears(), years));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of months of the period.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setMonths(int months) {\n+        if (months != iMonths) {\n+            if (months != 0) {\n+                checkSupport(iType.months());\n+            }\n+            iMonths = months;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified months to the number of months in the period.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addMonths(int months) {\n+        if (months != 0) {\n+            setMonths(FieldUtils.safeAdd(getMonths(), months));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of weeks of the period.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setWeeks(int weeks) {\n+        if (weeks != iWeeks) {\n+            if (weeks != 0) {\n+                checkSupport(iType.weeks());\n+            }\n+            iWeeks = weeks;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified weeks to the number of weeks in the period.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addWeeks(int weeks) {\n+        if (weeks != 0) {\n+            setWeeks(FieldUtils.safeAdd(getWeeks(), weeks));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of days of the period.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setDays(int days) {\n+        if (days != iDays) {\n+            if (days != 0) {\n+                checkSupport(iType.days());\n+            }\n+            iDays = days;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified days to the number of days in the period.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addDays(int days) {\n+        if (days != 0) {\n+            setDays(FieldUtils.safeAdd(getDays(), days));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of hours of the period.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setHours(int hours) {\n+        if (hours != iHours) {\n+            if (hours != 0) {\n+                checkSupport(iType.hours());\n+            }\n+            iHours = hours;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified hours to the number of hours in the period.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addHours(int hours) {\n+        if (hours != 0) {\n+            setHours(FieldUtils.safeAdd(getHours(), hours));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of minutes of the period.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setMinutes(int minutes) {\n+        if (minutes != iMinutes) {\n+            if (minutes != 0) {\n+                checkSupport(iType.minutes());\n+            }\n+            iMinutes = minutes;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified minutes to the number of minutes in the period.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addMinutes(int minutes) {\n+        if (minutes != 0) {\n+            setMinutes(FieldUtils.safeAdd(getMinutes(), minutes));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of seconds of the period.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setSeconds(int seconds) {\n+        if (seconds != iSeconds) {\n+            if (seconds != 0) {\n+                checkSupport(iType.seconds());\n+            }\n+            iSeconds = seconds;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified seconds to the number of seconds in the period.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addSeconds(int seconds) {\n+        if (seconds != 0) {\n+            setSeconds(FieldUtils.safeAdd(getSeconds(), seconds));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of millis of the period.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setMillis(int millis) {\n+        if (millis != iMillis) {\n+            if (millis != 0) {\n+                checkSupport(iType.millis());\n+            }\n+            iMillis = millis;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified millis to the number of millis in the period.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addMillis(int millis) {\n+        if (millis != 0) {\n+            setMillis(FieldUtils.safeAdd(getMillis(), millis));\n+        }\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/Duration.java\n+++ b/JodaTime/src/java/org/joda/time/Duration.java\n import java.io.Serializable;\n \n /**\n- * An immutable duration that defines and adds durations based on individual field values.\n+ * An immutable duration specifying a length of time in milliseconds.\n  * <p>\n- * A duration can be divided into a number of fields, such as hours and seconds.\n- * The way in which that divide occurs is controlled by the DurationType class.\n+ * A duration is defined by a fixed number of milliseconds.\n+ * There is no concept of fields, such as days or seconds, as these fields can vary in length.\n+ * A duration may be converted to a {@link TimePeriod} to obtain field values.\n+ * This conversion will typically cause a loss of precision however.\n  * <p>\n- * <code>Duration</code> can uses any duration type to split the milliseconds into fields.\n- * The {@link DurationType#getAllType() All} type is used by default.\n- * <code>All</code> uses the ISO chronology and divide the duration into years, months,\n- * weeks, days, hours, minutes, seconds and milliseconds as best it can.\n- * <p>\n- * This class performs calculations using the individual fields.\n- * The {@link ReadableDuration#isTotalMillisBased} method will always return false.\n- * The total milliseconds may be calculated so long as the value of all imprecise\n- * fields in the duration type are set to zero.\n- * <p>\n- * When this duration is added to an instant, the effect is of adding each field in turn.\n- * As a result, this duration takes into account daylight savings time.\n- * Adding a duration of 1 day to the day before daylight savings starts will only add\n- * 23 hours rather than 24 to ensure that the time remains the same.\n- * If this is not the behaviour you want, then see {@link MillisDuration}.\n- * <p>\n- * Duration is thread-safe and immutable, provided that the DurationType is as well.\n- * All standard DurationType classes supplied are thread-safe and immutable.\n+ * Duration is thread-safe and immutable.\n  *\n  * @author Brian S O'Neill\n  * @author Stephen Colebourne\n  * @since 1.0\n- * @see MutableDuration\n  */\n public class Duration\n         extends AbstractDuration\n     public static final Duration ZERO = new Duration(0L);\n \n     /** Serialization version */\n-    private static final long serialVersionUID = 741052353876488155L;\n+    private static final long serialVersionUID = 2471658376918L;\n \n     /**\n-     * Creates a duration from the given millisecond duration using AllType.\n-     * <p>\n-     * The millisecond duration will be split to fields using a UTC version of\n-     * the duration type. This ensures that there are no odd effects caused by\n-     * time zones. The add methods will still use the time zone specific version\n-     * of the duration type.\n+     * Creates a duration from the given millisecond duration.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     public Duration(long duration) {\n-        super(duration, null, false);\n-    }\n-\n-    /**\n-     * Creates a duration from the given millisecond duration.\n-     * <p>\n-     * The millisecond duration will be split to fields using a UTC version of\n-     * the duration type. This ensures that there are no odd effects caused by\n-     * time zones. The add methods will still use the time zone specific version\n-     * of the duration type.\n-     *\n-     * @param duration  the duration, in milliseconds\n-     * @param type  which set of fields this duration supports\n-     */\n-    public Duration(long duration, DurationType type) {\n-        super(duration, type, false);\n-    }\n-\n-    /**\n-     * Create a duration from a set of field values using AllType.\n-     * This constructor creates a precise duration.\n-     *\n-     * @param hours  amount of hours in this duration\n-     * @param minutes  amount of minutes in this duration\n-     * @param seconds  amount of seconds in this duration\n-     * @param millis  amount of milliseconds in this duration\n-     */\n-    public Duration(int hours, int minutes, int seconds, int millis) {\n-        super(0, 0, 0, 0, hours, minutes, seconds, millis, null, false);\n-    }\n-\n-    /**\n-     * Create a duration from a set of field values using AllType.\n-     *\n-     * @param years  amount of years in this duration\n-     * @param months  amount of months in this duration\n-     * @param weeks  amount of weeks in this duration\n-     * @param days  amount of days in this duration\n-     * @param hours  amount of hours in this duration\n-     * @param minutes  amount of minutes in this duration\n-     * @param seconds  amount of seconds in this duration\n-     * @param millis  amount of milliseconds in this duration\n-     */\n-    public Duration(int years, int months, int weeks, int days,\n-                    int hours, int minutes, int seconds, int millis) {\n-        super(years, months, weeks, days, hours, minutes, seconds, millis, null, false);\n-    }\n-\n-    /**\n-     * Create a duration from a set of field values.\n-     *\n-     * @param years  amount of years in this duration, which must be zero if unsupported\n-     * @param months  amount of months in this duration, which must be zero if unsupported\n-     * @param weeks  amount of weeks in this duration, which must be zero if unsupported\n-     * @param days  amount of days in this duration, which must be zero if unsupported\n-     * @param hours  amount of hours in this duration, which must be zero if unsupported\n-     * @param minutes  amount of minutes in this duration, which must be zero if unsupported\n-     * @param seconds  amount of seconds in this duration, which must be zero if unsupported\n-     * @param millis  amount of milliseconds in this duration, which must be zero if unsupported\n-     * @param type  which set of fields this duration supports, null means AllType\n-     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n-     */\n-    public Duration(int years, int months, int weeks, int days,\n-                    int hours, int minutes, int seconds, int millis, DurationType type) {\n-        super(years, months, weeks, days, hours, minutes, seconds, millis, type, false);\n-    }\n-\n-    /**\n-     * Creates a duration from the given interval endpoints using AllType.\n-     * This constructor creates a precise duration.\n-     *\n-     * @param startInstant  interval start, in milliseconds\n-     * @param endInstant  interval end, in milliseconds\n-     */\n-    public Duration(long startInstant, long endInstant) {\n-        super(startInstant, endInstant, null, false);\n+        super(duration);\n     }\n \n     /**\n      * Creates a duration from the given interval endpoints.\n-     * This constructor creates a precise duration.\n      *\n      * @param startInstant  interval start, in milliseconds\n      * @param endInstant  interval end, in milliseconds\n-     * @param type  which set of fields this duration supports, null means AllType\n+     * @throws ArithmeticException if the duration exceeds a 64 bit long\n      */\n-    public Duration(long startInstant, long endInstant, DurationType type) {\n-        super(startInstant, endInstant, type, false);\n-    }\n-\n-    /**\n-     * Creates a duration from the given interval endpoints using AllType.\n-     * This constructor creates a precise duration.\n-     *\n-     * @param startInstant  interval start, null means now\n-     * @param endInstant  interval end, null means now\n-     */\n-    public Duration(ReadableInstant startInstant, ReadableInstant endInstant) {\n-        super(startInstant, endInstant, null, false);\n+    public Duration(long startInstant, long endInstant) {\n+        super(startInstant, endInstant);\n     }\n \n     /**\n      * Creates a duration from the given interval endpoints.\n-     * This constructor creates a precise duration.\n      *\n      * @param startInstant  interval start, null means now\n      * @param endInstant  interval end, null means now\n-     * @param type  which set of fields this duration supports, null means AllType\n+     * @throws ArithmeticException if the duration exceeds a 64 bit long\n      */\n-    public Duration(ReadableInstant startInstant, ReadableInstant endInstant, DurationType type) {\n-        super(startInstant, endInstant, type, false);\n+    public Duration(ReadableInstant startInstant, ReadableInstant endInstant) {\n+        super(startInstant, endInstant);\n     }\n \n     /**\n      *\n      * @param duration  duration to convert\n      * @throws IllegalArgumentException if duration is invalid\n-     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n      */\n     public Duration(Object duration) {\n-        super(duration, null, false);\n-    }\n-\n-    /**\n-     * Creates a duration from the specified object using the\n-     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n-     *\n-     * @param duration  duration to convert\n-     * @param type  which set of fields this duration supports, null means use converter\n-     * @throws IllegalArgumentException if duration is invalid\n-     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n-     */\n-    public Duration(Object duration, DurationType type) {\n-        super(duration, type, false);\n+        super(duration);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Validates a duration type, converting nulls to a default value and\n-     * checking the type is suitable for this instance.\n+     * Creates a new Duration instance with a different milisecond length.\n      * \n-     * @param type  the type to check, may be null\n-     * @return the validated type to use, not null\n-     * @throws IllegalArgumentException if the duration type is not precise\n+     * @param length  the new length\n+     * @return the new duration instance\n      */\n-    protected final DurationType checkDurationType(DurationType type) {\n-        if (type == null) {\n-            return DurationType.getAllType();\n-        }\n-        return type;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Creates a new Duration instance with the same total milliseconds but\n-     * different DurationType.\n-     * \n-     * @param type  the duration type to use, null means AllType\n-     * @return the new duration instance\n-     * @throws IllegalStateException if this duration is imprecise\n-     */\n-    public Duration withDurationTypeUsingTotalMillis(DurationType type) {\n-        if (type == null) {\n-            type = DurationType.getAllType();\n-        }\n-        if (type.equals(getDurationType())) {\n+    public Duration withMillis(long length) {\n+        if (length == getMillis()) {\n             return this;\n         }\n-        return new Duration(getTotalMillis(), type);\n-    }\n-\n-    /**\n-     * Creates a new Duration instance with the same field values but\n-     * different DurationType.\n-     * \n-     * @param type  the duration type to use, null means AllType\n-     * @return the new duration instance\n-     * @throws IllegalArgumentException if the new duration won't accept all of the current fields\n-     */\n-    public Duration withDurationTypeUsingFields(DurationType type) {\n-        if (type == null) {\n-            type = DurationType.getAllType();\n-        }\n-        if (type.equals(getDurationType())) {\n-            return this;\n-        }\n-        return new Duration(getYears(), getMonths(), getWeeks(), getDays(),\n-                    getHours(), getMinutes(), getSeconds(), getMillis(), type);\n-    }\n-\n-    /**\n-     * Creates a new Duration instance with the same total milliseconds but\n-     * all the fields normalized to be within their standard ranges.\n-     * \n-     * @return the new duration instance\n-     * @throws IllegalStateException if this duration is imprecise\n-     */\n-    public Duration withFieldsNormalized() {\n-        return new Duration(getTotalMillis(), getDurationType());\n+        return new Duration(length);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n-    protected final void setDuration(ReadableDuration duration) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setDuration(int years, int months, int weeks, int days,\n-                                     int hours, int minutes, int seconds, int millis) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setTotalMillis(long startInstant, long endInstant) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setTotalMillis(long duration) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setYears(int years) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setMonths(int months) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setWeeks(int weeks) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setDays(int days) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setHours(int hours) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setMinutes(int minutes) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setSeconds(int seconds) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setMillis(int millis) {\n+    protected final void setMillis(long duration) {\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/Interval.java\n+++ b/JodaTime/src/java/org/joda/time/Interval.java\n import java.io.Serializable;\n \n /**\n- * Interval is the standard implementation of an immutable time interval\n- * class. The duration of the time interval is always a precise amount of\n- * milliseconds even if a variable length duration was passed into the\n- * constructor.\n+ * Interval is the standard implementation of an immutable time interval.\n+ * <p>\n+ * The duration of the time interval is always a precise amount of milliseconds\n+ * even if a variable length duration was passed into the constructor.\n  * <p>\n  * Interval is thread-safe and immutable.\n  *\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public final class Interval extends AbstractInterval\n+public class Interval\n+        extends AbstractInterval\n         implements ReadableInterval, Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 4922451897541386752L;\n \n     /**\n+     * Constructs an interval from a start and end instant.\n+     * \n+     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     */\n+    public Interval(long startInstant, long endInstant) {\n+        super(startInstant, endInstant);\n+    }\n+\n+    /**\n      * Constructs a time interval as a copy of another.\n      * \n-     * @param interval  the time interval to convert\n+     * @param interval  the time interval to copy\n      * @throws IllegalArgumentException if the interval is null or invalid\n      */\n     public Interval(Object interval) {\n         super(interval);\n-    }\n-\n-    /**\n-     * Constructs an interval from a start and end instant.\n-     * \n-     * @param startInstant  start of this interval, as milliseconds from\n-     *  1970-01-01T00:00:00Z.\n-     * @param endInstant  end of this interval, as milliseconds from\n-     *  1970-01-01T00:00:00Z.\n-     */\n-    public Interval(long startInstant, long endInstant) {\n-        super(startInstant, endInstant);\n     }\n \n     /**\n     }\n \n     /**\n-     * Constructs an interval from a start instant and a duration.\n+     * Constructs an interval from a start instant and a millisecond duration.\n      * \n      * @param start  start of this interval, null means now\n-     * @param duration  duration of this interval, null means zero length\n+     * @param duration  the duration of this interval, null means zero length\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n     public Interval(ReadableInstant start, ReadableDuration duration) {\n         super(start, duration);\n     }\n \n     /**\n-     * Constructs an interval from a duration and an end instant.\n+     * Constructs an interval from a millisecond duration and an end instant.\n      * \n-     * @param duration  duration of this interval, null means zero length\n+     * @param duration  the duration of this interval, null means zero length\n      * @param end  end of this interval, null means now\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n     public Interval(ReadableDuration duration, ReadableInstant end) {\n         super(duration, end);\n     }\n \n+    /**\n+     * Constructs an interval from a start instant and a time period.\n+     * <p>\n+     * When forming the interval, the chronology from the instant is used\n+     * if present, otherwise the chronology of the period is used.\n+     * \n+     * @param start  start of this interval, null means now\n+     * @param period  the period of this interval, null means zero length\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    public Interval(ReadableInstant start, ReadableTimePeriod period) {\n+        super(start, period);\n+    }\n+\n+    /**\n+     * Constructs an interval from a time period and an end instant.\n+     * <p>\n+     * When forming the interval, the chronology from the instant is used\n+     * if present, otherwise the chronology of the period is used.\n+     * \n+     * @param period  the period of this interval, null means zero length\n+     * @param end  end of this interval, null means now\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    public Interval(ReadableTimePeriod period, ReadableInstant end) {\n+        super(period, end);\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n     /**\n      * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n-    protected final void setDurationAfterStart(ReadableDuration duration) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setDurationBeforeEnd(ReadableDuration duration) {\n+    protected final void storeDuration(Duration duration) {\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java\n      * @throws ArithmeticException if the result exceeds the capacity of the instant\n      */\n     public void add(final Object duration, final int scalar) {\n+        // TODO Change from Object to individual methods\n         if (duration instanceof ReadableDuration) {\n             ReadableDuration d = (ReadableDuration) duration;\n+            add(FieldUtils.safeMultiply(d.getMillis(), scalar));\n+        } else if (duration instanceof ReadableTimePeriod) {\n+            ReadableTimePeriod d = (ReadableTimePeriod) duration;\n             d.addInto(this, scalar);\n         } else {\n             DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);\n--- a/JodaTime/src/java/org/joda/time/MutableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/MutableInterval.java\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public final class MutableInterval extends AbstractInterval\n+public final class MutableInterval\n+        extends AbstractInterval\n         implements ReadWritableInterval, Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = -5982824024992428470L;\n \n     /**\n+     * Constructs a time interval from 1970-01-01 to 1970-01-01.\n+     */\n+    public MutableInterval() {\n+        super(0L, 0L);\n+    }\n+\n+    /**\n+     * Constructs an interval from a start and end instant.\n+     * \n+     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     */\n+    public MutableInterval(long startInstant, long endInstant) {\n+        super(startInstant, endInstant);\n+    }\n+\n+    /**\n      * Constructs a time interval as a copy of another.\n      * \n-     * @param interval the time interval to copy\n-     * @throws IllegalArgumentException if the interval is null\n-     */\n-    public MutableInterval(ReadableInterval interval) {\n-        super(interval);\n-    }\n-    \n-    /**\n-     * Constructs a time interval as a copy of another.\n-     * \n-     * @param interval the time interval to convert\n-     * @throws IllegalArgumentException if the interval is null\n+     * @param interval  the time interval to copy\n+     * @throws IllegalArgumentException if the interval is null or invalid\n      */\n     public MutableInterval(Object interval) {\n         super(interval);\n     /**\n      * Constructs an interval from a start and end instant.\n      * \n-     * @param startInstant  start of this interval, as milliseconds from\n-     *  1970-01-01T00:00:00Z.\n-     * @param endInstant  end of this interval, as milliseconds from\n-     *  1970-01-01T00:00:00Z.\n-     */\n-    public MutableInterval(long startInstant, long endInstant) {\n-        super(startInstant, endInstant);\n-    }\n-    \n-    /**\n-     * Constructs an interval from a start and end instant.\n-     * \n-     * @param start  start of this interval\n-     * @param end  end of this interval\n-     * @throws IllegalArgumentException if either instant is null\n+     * @param start  start of this interval, null means now\n+     * @param end  end of this interval, null means now\n      */\n     public MutableInterval(ReadableInstant start, ReadableInstant end) {\n         super(start, end);\n     }\n-    \n-    /**\n-     * Constructs an interval from a start instant and a duration.\n-     * \n-     * @param start  start of this interval\n-     * @param duration  duration of this interval\n-     * @throws IllegalArgumentException if start or duration is null\n+\n+    /**\n+     * Constructs an interval from a start instant and a millisecond duration.\n+     * \n+     * @param start  start of this interval, null means now\n+     * @param duration  the duration of this interval, null means zero length\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n     public MutableInterval(ReadableInstant start, ReadableDuration duration) {\n         super(start, duration);\n     }\n-    \n-    /**\n-     * Constructs an interval from a duration and an end instant.\n-     * \n-     * @param duration duration of this interval\n-     * @param end end of this interval\n-     * @throws IllegalArgumentException if duration or end is null\n+\n+    /**\n+     * Constructs an interval from a millisecond duration and an end instant.\n+     * \n+     * @param duration  the duration of this interval, null means zero length\n+     * @param end  end of this interval, null means now\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n     public MutableInterval(ReadableDuration duration, ReadableInstant end) {\n         super(duration, end);\n     }\n-    \n+\n+    /**\n+     * Constructs an interval from a start instant and a time period.\n+     * <p>\n+     * When forming the interval, the chronology from the instant is used\n+     * if present, otherwise the chronology of the period is used.\n+     * \n+     * @param start  start of this interval, null means now\n+     * @param period  the period of this interval, null means zero length\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    public MutableInterval(ReadableInstant start, ReadableTimePeriod period) {\n+        super(start, period);\n+    }\n+\n+    /**\n+     * Constructs an interval from a time period and an end instant.\n+     * <p>\n+     * When forming the interval, the chronology from the instant is used\n+     * if present, otherwise the chronology of the period is used.\n+     * \n+     * @param period  the period of this interval, null means zero length\n+     * @param end  end of this interval, null means now\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    public MutableInterval(ReadableTimePeriod period, ReadableInstant end) {\n+        super(period, end);\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Sets the start of this time interval.\n         super.setEndMillis(instant.getMillis());\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Sets the duration of this time interval, preserving the start instant.\n      *\n-     * @param millisDuration  new duration for interval\n-     */\n-    public void setDurationAfterStart(long millisDuration) {\n-        super.setEndMillis(getStartMillis() + millisDuration);\n+     * @param duration  new duration for interval\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    public void setDurationAfterStart(long duration) {\n+        super.setDurationAfterStart(duration);\n+    }\n+\n+    /**\n+     * Sets the duration of this time interval, preserving the end instant.\n+     *\n+     * @param duration  new duration for interval\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    public void setDurationBeforeEnd(long duration) {\n+        super.setDurationBeforeEnd(duration);\n     }\n \n     /**\n      * Sets the duration of this time interval, preserving the start instant.\n      *\n      * @param duration  new duration for interval\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n     public void setDurationAfterStart(ReadableDuration duration) {\n         super.setDurationAfterStart(duration);\n     /**\n      * Sets the duration of this time interval, preserving the end instant.\n      *\n-     * @param millisDuration  new duration for interval\n-     */\n-    public void setDurationBeforeEnd(long millisDuration) {\n-        super.setStartMillis(getEndMillis() - millisDuration);\n-    }\n-\n-    /**\n-     * Sets the duration of this time interval, preserving the end instant.\n-     *\n-     * @param duration  new duration for interval\n+     * @param duration  new duration for interval\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n     public void setDurationBeforeEnd(ReadableDuration duration) {\n         super.setDurationBeforeEnd(duration);\n     }\n \n+    /**\n+     * Sets the period of this time interval, preserving the start instant.\n+     *\n+     * @param period  new period for interval, null means zero length\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    public void setTimePeriodAfterStart(ReadableTimePeriod period) {\n+        super.setTimePeriodAfterStart(period);\n+    }\n+\n+    /**\n+     * Sets the period of this time interval, preserving the end instant.\n+     *\n+     * @param period  new period for interval, null means zero length\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    public void setTimePeriodBeforeEnd(ReadableTimePeriod period) {\n+        super.setTimePeriodBeforeEnd(period);\n+    }\n+\n }\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/MutableTimePeriod.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Standard mutable time period implementation.\n+ * <p>\n+ * MutableTimePeriod is mutable and not thread-safe, unless concurrent threads\n+ * are not invoking mutator methods.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ * @see TimePeriod\n+ */\n+public class MutableTimePeriod\n+        extends AbstractTimePeriod\n+        implements ReadWritableTimePeriod, Cloneable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 3436451121567212165L;\n+\n+    /**\n+     * Creates a zero-length period using AllType.\n+     */\n+    public MutableTimePeriod() {\n+        super(0L, null);\n+    }\n+\n+    /**\n+     * Creates a zero-length period using the specified duration type.\n+     *\n+     * @param type  which set of fields this period supports\n+     */\n+    public MutableTimePeriod(DurationType type) {\n+        super(0L, type);\n+    }\n+\n+    /**\n+     * Creates a period from the given millisecond duration using AllType.\n+     * <p>\n+     * The millisecond duration will be split to fields using a UTC version of\n+     * the duration type. This ensures that there are no odd effects caused by\n+     * time zones. The add methods will still use the time zone specific version\n+     * of the duration type.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     */\n+    public MutableTimePeriod(long duration) {\n+        super(duration, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given millisecond duration.\n+     * <p>\n+     * The millisecond duration will be split to fields using a UTC version of\n+     * the duration type. This ensures that there are no odd effects caused by\n+     * time zones. The add methods will still use the time zone specific version\n+     * of the duration type.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this duration supports\n+     */\n+    public MutableTimePeriod(long duration, DurationType type) {\n+        super(duration, type);\n+    }\n+\n+    /**\n+     * Create a period from a set of field values using AllType.\n+     * This constructor creates a precise period.\n+     *\n+     * @param hours  amount of hours in this period\n+     * @param minutes  amount of minutes in this period\n+     * @param seconds  amount of seconds in this period\n+     * @param millis  amount of milliseconds in this period\n+     */\n+    public MutableTimePeriod(int hours, int minutes, int seconds, int millis) {\n+        super(0, 0, 0, 0, hours, minutes, seconds, millis, null);\n+    }\n+\n+    /**\n+     * Create a period from a set of field values using AllType.\n+     *\n+     * @param years  amount of years in this period\n+     * @param months  amount of months in this period\n+     * @param weeks  amount of weeks in this period\n+     * @param days  amount of days in this period\n+     * @param hours  amount of hours in this period\n+     * @param minutes  amount of minutes in this period\n+     * @param seconds  amount of seconds in this period\n+     * @param millis  amount of milliseconds in this period\n+     */\n+    public MutableTimePeriod(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis) {\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, null);\n+    }\n+\n+    /**\n+     * Create a period from a set of field values.\n+     *\n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @param type  which set of fields this period supports, null means AllType\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    public MutableTimePeriod(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis, DurationType type) {\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, type);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints using AllType.\n+     * This constructor creates a precise period.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    public MutableTimePeriod(long startInstant, long endInstant) {\n+        super(startInstant, endInstant, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     * This constructor creates a precise period.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param type  which set of fields this period supports, null means AllType\n+     */\n+    public MutableTimePeriod(long startInstant, long endInstant, DurationType type) {\n+        super(startInstant, endInstant, type);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints using AllType.\n+     * This constructor creates a precise period.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     */\n+    public MutableTimePeriod(ReadableInstant startInstant, ReadableInstant endInstant) {\n+        super(startInstant, endInstant, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     * This constructor creates a precise period.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     * @param type  which set of fields this period supports, null means AllType\n+     */\n+    public MutableTimePeriod(ReadableInstant startInstant, ReadableInstant endInstant, DurationType type) {\n+        super(startInstant, endInstant, type);\n+    }\n+\n+    /**\n+     * Creates a period from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param period  period to convert\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public MutableTimePeriod(Object period) {\n+        super(period, null);\n+    }\n+\n+    /**\n+     * Creates a period from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param period  period to convert\n+     * @param type  which set of fields this period supports, null means use converter\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public MutableTimePeriod(Object period, DurationType type) {\n+        super(period, type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates a duration type, converting nulls to a default value and\n+     * checking the type is suitable for this instance.\n+     * \n+     * @param type  the type to check, may be null\n+     * @return the validated type to use, not null\n+     * @throws IllegalArgumentException if the duration type is not precise\n+     */\n+    protected DurationType checkDurationType(DurationType type) {\n+        if (type == null) {\n+            return DurationType.getAllType();\n+        }\n+        return type;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets all the fields in one go from another ReadableTimePeriod.\n+     * \n+     * @param period  the period to set, null means zero length period\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    public void setTimePeriod(ReadableTimePeriod period) {\n+        super.setTimePeriod(period);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go.\n+     * \n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    public void setTimePeriod(int years, int months, int weeks, int days,\n+                            int hours, int minutes, int seconds, int millis) {\n+        super.setTimePeriod(years, months, weeks, days,\n+                          hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from an interval dividing the\n+     * fields using the duration type.\n+     * \n+     * @param interval  the interval to set, null means zero length\n+     */\n+    public void setTimePeriod(ReadableInterval interval) {\n+        super.setTimePeriod(interval);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond interval dividing the\n+     * fields using the duration type.\n+     * \n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    public void setTimePeriod(long startInstant, long endInstant) {\n+        super.setTimePeriod(startInstant, endInstant);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a duration dividing the\n+     * fields using the duration type.\n+     * \n+     * @param duration  the duration to set, null means zero length\n+     */\n+    public void setTimePeriod(ReadableDuration duration) {\n+        super.setTimePeriod(duration);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond duration dividing the\n+     * fields using the duration type.\n+     * \n+     * @param duration  the duration, in milliseconds\n+     */\n+    public void setTimePeriod(long duration) {\n+        super.setTimePeriod(duration);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a period to this one by adding each field in turn.\n+     * \n+     * @param period  the period to add, null means add nothing\n+     * @throws IllegalArgumentException if the period being added contains a field\n+     * not supported by this period\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void add(ReadableTimePeriod period) {\n+        super.add(period);\n+    }\n+\n+    /**\n+     * Adds an interval to this one by dividing the duration into\n+     * fields and then adding each field in turn.\n+     * \n+     * @param interval  the interval to add, null means add nothing\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void add(ReadableInterval interval) {\n+        super.add(interval);\n+    }\n+\n+    /**\n+     * Adds a duration to this one by dividing the duration into\n+     * fields and then adding each field in turn.\n+     * \n+     * @param duration  the duration to add, null means add nothing\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void add(ReadableDuration duration) {\n+        super.add(duration);\n+    }\n+\n+    /**\n+     * Adds a duration to this one by dividing the duration into\n+     * fields and then adding each field in turn.\n+     * \n+     * @param duration  the duration to add\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void add(long duration) {\n+        super.add(duration);\n+    }\n+\n+    /**\n+     * Normalizes all the field values in this period.\n+     * <p>\n+     * This method converts to a milliecond duration and back again.\n+     *\n+     * @throws IllegalStateException if this period is imprecise\n+     */\n+    public void normalize() {\n+        super.normalize();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of years of the period.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setYears(int years) {\n+        super.setYears(years);\n+    }\n+\n+    /**\n+     * Adds the specified years to the number of years in the period.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addYears(int years) {\n+        super.addYears(years);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of months of the period.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setMonths(int months) {\n+        super.setMonths(months);\n+    }\n+\n+    /**\n+     * Adds the specified months to the number of months in the period.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addMonths(int months) {\n+        super.addMonths(months);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of weeks of the period.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setWeeks(int weeks) {\n+        super.setWeeks(weeks);\n+    }\n+\n+    /**\n+     * Adds the specified weeks to the number of weeks in the period.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addWeeks(int weeks) {\n+        super.addWeeks(weeks);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of days of the period.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setDays(int days) {\n+        super.setDays(days);\n+    }\n+\n+    /**\n+     * Adds the specified days to the number of days in the period.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addDays(int days) {\n+        super.addDays(days);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of hours of the period.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setHours(int hours) {\n+        super.setHours(hours);\n+    }\n+\n+    /**\n+     * Adds the specified hours to the number of hours in the period.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addHours(int hours) {\n+        super.addHours(hours);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of minutes of the period.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setMinutes(int minutes) {\n+        super.setMinutes(minutes);\n+    }\n+\n+    /**\n+     * Adds the specified minutes to the number of minutes in the period.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addMinutes(int minutes) {\n+        super.addMinutes(minutes);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of seconds of the period.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setSeconds(int seconds) {\n+        super.setSeconds(seconds);\n+    }\n+\n+    /**\n+     * Adds the specified seconds to the number of seconds in the period.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addSeconds(int seconds) {\n+        super.addSeconds(seconds);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of millis of the period.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setMillis(int millis) {\n+        super.setMillis(millis);\n+    }\n+\n+    /**\n+     * Adds the specified millis to the number of millis in the period.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addMillis(int millis) {\n+        super.addMillis(millis);\n+    }\n+\n+    // Misc\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clone this object without having to cast the returned object.\n+     *\n+     * @return a clone of the this object.\n+     */\n+    public MutableTimePeriod copy() {\n+        return (MutableTimePeriod)clone();\n+    }\n+\n+    /**\n+     * Clone this object.\n+     *\n+     * @return a clone of this object.\n+     */\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (CloneNotSupportedException ex) {\n+            throw new InternalError(\"Clone error\");\n+        }\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/ReadWritableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/ReadWritableInterval.java\n      * Sets the duration of this time interval, preserving the start instant.\n      *\n      * @param millisDuration  new duration for interval\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n     void setDurationAfterStart(long millisDuration);\n-\n-    /**\n-     * Sets the duration of this time interval, preserving the start instant.\n-     *\n-     * @param duration  new duration for interval\n-     */\n-    void setDurationAfterStart(ReadableDuration duration);\n \n     /**\n      * Sets the duration of this time interval, preserving the end instant.\n     void setDurationBeforeEnd(long millisDuration);\n \n     /**\n+     * Sets the duration of this time interval, preserving the start instant.\n+     *\n+     * @param duration  new duration for interval\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    void setDurationAfterStart(ReadableDuration duration);\n+\n+    /**\n      * Sets the duration of this time interval, preserving the end instant.\n      *\n      * @param duration  new duration for interval\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n     void setDurationBeforeEnd(ReadableDuration duration);\n \n+    /**\n+     * Sets the period of this time interval, preserving the start instant.\n+     *\n+     * @param period  new period for interval, null means zero length\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    void setTimePeriodAfterStart(ReadableTimePeriod period);\n+\n+    /**\n+     * Sets the period of this time interval, preserving the end instant.\n+     *\n+     * @param period  new period for interval, null means zero length\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    void setTimePeriodBeforeEnd(ReadableTimePeriod period);\n+\n }\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/ReadWritableTimePeriod.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Defines a duration of time that can be queried and modified using datetime fields.\n+ * <p>\n+ * The implementation of this interface will be mutable.\n+ * It may provide more advanced methods than those in the interface.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface ReadWritableTimePeriod extends ReadableTimePeriod {\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets all the fields in one go from another ReadableTimePeriod.\n+     * \n+     * @param period  the period to set, null means zero length period\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    void setTimePeriod(ReadableTimePeriod period);\n+\n+    /**\n+     * Sets all the fields in one go.\n+     * \n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    void setTimePeriod(int years, int months, int weeks, int days,\n+                       int hours, int minutes, int seconds, int millis);\n+\n+    /**\n+     * Sets all the fields in one go from an interval dividing the\n+     * fields using the duration type.\n+     * \n+     * @param interval  the interval to set, null means zero length\n+     */\n+    void setTimePeriod(ReadableInterval interval);\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond interval dividing the\n+     * fields using the duration type.\n+     * \n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    void setTimePeriod(long startInstant, long endInstant);\n+\n+    /**\n+     * Sets all the fields in one go from a duration dividing the\n+     * fields using the duration type.\n+     * \n+     * @param duration  the duration to set, null means zero length\n+     */\n+    void setTimePeriod(ReadableDuration duration);\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond duration dividing the\n+     * fields using the duration type.\n+     * \n+     * @param duration  the duration, in milliseconds\n+     */\n+    void setTimePeriod(long duration);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a period to this one by adding each field in turn.\n+     * \n+     * @param period  the period to add, null means add nothing\n+     * @throws IllegalArgumentException if the period being added contains a field\n+     * not supported by this period\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void add(ReadableTimePeriod period);\n+\n+    /**\n+     * Adds an interval to this one by dividing the interval into\n+     * fields and then adding each field in turn.\n+     * \n+     * @param interval  the interval to add, null means add nothing\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void add(ReadableInterval interval);\n+\n+    /**\n+     * Adds a duration to this one by dividing the duration into\n+     * fields and then adding each field in turn.\n+     * \n+     * @param duration  the duration to add, null means add nothing\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void add(ReadableDuration duration);\n+\n+    /**\n+     * Adds a duration to this one by dividing the duration into\n+     * fields and then adding each field in turn.\n+     * \n+     * @param duration  the duration to add\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void add(long duration);\n+\n+    /**\n+     * Normalizes all the field values in this period.\n+     * <p>\n+     * This method converts to a milliecond duration and back again.\n+     *\n+     * @throws IllegalStateException if this period is imprecise\n+     */\n+    void normalize();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of years of the period.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setYears(int years);\n+\n+    /**\n+     * Adds the specified years to the number of years in the period.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addYears(int years);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of months of the period.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setMonths(int months);\n+\n+    /**\n+     * Adds the specified months to the number of months in the period.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addMonths(int months);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of weeks of the period.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setWeeks(int weeks);\n+\n+    /**\n+     * Adds the specified weeks to the number of weeks in the period.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addWeeks(int weeks);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of days of the period.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setDays(int days);\n+\n+    /**\n+     * Adds the specified days to the number of days in the period.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addDays(int days);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of hours of the period.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setHours(int hours);\n+\n+    /**\n+     * Adds the specified hours to the number of hours in the period.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addHours(int hours);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of minutes of the period.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setMinutes(int minutes);\n+\n+    /**\n+     * Adds the specified minutes to the number of minutes in the period.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addMinutes(int minutes);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of seconds of the period.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setSeconds(int seconds);\n+\n+    /**\n+     * Adds the specified seconds to the number of seconds in the period.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addSeconds(int seconds);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of millis of the period.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setMillis(int millis);\n+\n+    /**\n+     * Adds the specified millis to the number of millis in the period.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addMillis(int millis);\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/ReadableDuration.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableDuration.java\n package org.joda.time;\n \n /**\n- * Defines a duration of time that can be queried using fields.\n+ * Defines an exact duration of time in milliseconds.\n  * <p>\n  * The implementation of this interface may be mutable or immutable. This\n  * interface only gives access to retrieve data, never to change it.\n- * <p>\n- * Durations can be split up into multiple fields, but implementations are not\n- * required to evenly distribute the values across the fields. Nor are they\n- * required to normalize the fields nor match the signs.\n- * <p>\n- * For example, an implementation can represent a duration of \"4 days, 6 hours\"\n- * as \"102 hours\", \"1 day, 78 hours\", \"367200000 milliseconds\", or even\n- * \"3 days, -8 hours, 2275 minutes, 298 seconds, 2000 milliseconds\".\n  *\n  * @see ReadableInterval\n+ * @see ReadableTimePeriod\n  * @author Brian S O'Neill\n  * @author Stephen Colebourne\n  * @since 1.0\n public interface ReadableDuration extends Comparable {\n \n     /**\n-     * Returns the object which defines which fields this duration supports.\n-     */\n-    DurationType getDurationType();\n-\n-    /**\n-     * Is this duration based on a millisecond duration and thus performs\n-     * all calculations using the total millisecond value.\n-     * <p>\n-     * Durations operate either using the total milliseconds as the master and the\n-     * field values as derived, or vice versa. This method returns true if the\n-     * total millis field is the master. The effect is to control how the duration\n-     * manages addition over the daylight savings boundary.\n-     * <p>\n-     * If true, {@link #isPrecise()} will always return true, {@link #getTotalMillis()}\n-     * and {@link #compareTo(Object)} methods will never throw an exception and the\n-     * add methods will add using the total milliseconds value.\n-     * See {@link MillisDuration} for details.\n-     *\n-     * @return true if the duration is based on total milliseconds\n-     */\n-    boolean isTotalMillisBased();\n-\n-    /**\n-     * Gets the total length of this duration in milliseconds, \n-     * failing if the duration is imprecise.\n+     * Gets the total length of this duration in milliseconds.\n      *\n      * @return the total length of the time duration in milliseconds.\n-     * @throws IllegalStateException if the duration is imprecise\n      */\n-    long getTotalMillis();\n-\n-    /**\n-     * Is this duration a precise length of time, or descriptive.\n-     * <p>\n-     * A precise duration could include millis, seconds, minutes or hours.\n-     * However, days, weeks, months and years can vary in length, resulting in\n-     * an imprecise duration.\n-     * <p>\n-     * An imprecise duration can be made precise by pairing it with a\n-     * date in a {@link ReadableInterval}.\n-     *\n-     * @return true if the duration is precise\n-     */\n-    boolean isPrecise();\n+    long getMillis();\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Adds this duration to the given instant, returning a new value.\n-     * <p>\n-     * To add just once, pass in a scalar of one. To subtract once, pass\n-     * in a scalar of minus one.\n-     *\n-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n-     * duration to\n-     * @param scalar  the number of times to add the duration, negative to subtract\n-     * @return milliseconds value plus this duration times scalar\n-     * @throws ArithmeticException if the result of the calculation is too large\n+     * Converts this duration to a Duration instance.\n+     * This can be useful if you don't trust the implementation of the interface\n+     * to be well-behaved, or to get a guaranteed immutable object.\n+     * \n+     * @return a Duration created using the millisecond duration from this instance\n      */\n-    long addTo(long instant, int scalar);\n-\n-    /**\n-     * Adds this duration to the given instant, returning a new value.\n-     * <p>\n-     * To add just once, pass in a scalar of one. To subtract once, pass\n-     * in a scalar of minus one.\n-     *\n-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n-     * duration to\n-     * @param scalar  the number of times to add the duration, negative to subtract\n-     * @param chrono  override the duration's chronology, unless null is passed in\n-     * @return milliseconds value plus this duration times scalar\n-     * @throws ArithmeticException if the result of the calculation is too large\n-     */\n-    long addTo(long instant, int scalar, Chronology chrono);\n-\n-    /**\n-     * Adds this duration to the given instant, returning a new Instant.\n-     * <p>\n-     * To add just once, pass in a scalar of one. To subtract once, pass\n-     * in a scalar of minus one.\n-     *\n-     * @param instant  the instant to add the duration to\n-     * @param scalar  the number of times to add the duration, negative to subtract\n-     * @return instant with the original value plus this duration times scalar\n-     * @throws IllegalArgumentException if the instant is null\n-     * @throws ArithmeticException if the result of the calculation is too large\n-     */\n-    Instant addTo(ReadableInstant instant, int scalar);\n-\n-    /**\n-     * Adds this duration into the given mutable instant.\n-     * <p>\n-     * To add just once, pass in a scalar of one. To subtract once, pass\n-     * in a scalar of minus one.\n-     *\n-     * @param instant  the instant to update with the added duration\n-     * @param scalar  the number of times to add the duration, negative to subtract\n-     * @throws IllegalArgumentException if the instant is null\n-     * @throws ArithmeticException if the result of the calculation is too large\n-     */\n-    void addInto(ReadWritableInstant instant, int scalar);\n+    Duration toDuration();\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the years field part of the duration.\n+     * Converts this duration to a TimePeriod instance using the PreciseAll type.\n+     * <p>\n+     * The PreciseAll type fixes days at 24 hours, months ay 30 days and years at 365 days\n+     * thus the time period will be precise. As a result there is no loss of precision\n+     * with regards the length of the duration and the following code will work:\n+     * <pre>\n+     * Duration dur = new Duration(123456789L);\n+     * TimePeriod period = d.toTimePeriod();\n+     * Duration dur2 = period.toDuration();\n+     * // dur.getMillis() == dur2.getMillis()\n+     * </pre>\n      * \n-     * @return the number of years in the duration, zero if unsupported\n+     * @return a TimePeriod created using the millisecond duration from this instance\n      */\n-    int getYears();\n+    TimePeriod toTimePeriod();\n \n     /**\n-     * Gets the months field part of the duration.\n+     * Converts this duration to a TimePeriod instance specifying a duration type\n+     * to control how the duration is split into fields.\n+     * <p>\n+     * If a non-precise duration type is used, the resulting time period will only\n+     * represent an approximation of the duration. As a result it will not be\n+     * possible to call {@link TimePeriod#toDuration()} to get the duration back.\n      * \n-     * @return the number of months in the duration, zero if unsupported\n+     * @param type  the duration type determining how to split the duration into fields\n+     * @return a TimePeriod created using the millisecond duration from this instance\n      */\n-    int getMonths();\n-\n-    /**\n-     * Gets the weeks field part of the duration.\n-     * \n-     * @return the number of weeks in the duration, zero if unsupported\n-     */\n-    int getWeeks();\n-\n-    /**\n-     * Gets the days field part of the duration.\n-     * \n-     * @return the number of days in the duration, zero if unsupported\n-     */\n-    int getDays();\n-\n-    /**\n-     * Gets the hours field part of the duration.\n-     * \n-     * @return the number of hours in the duration, zero if unsupported\n-     */\n-    int getHours();\n-\n-    /**\n-     * Gets the minutes field part of the duration.\n-     * \n-     * @return the number of minutes in the duration, zero if unsupported\n-     */\n-    int getMinutes();\n-\n-    /**\n-     * Gets the seconds field part of the duration.\n-     * \n-     * @return the number of seconds in the duration, zero if unsupported\n-     */\n-    int getSeconds();\n-\n-    /**\n-     * Gets the millis field part of the duration.\n-     * \n-     * @return the number of millis in the duration, zero if unsupported\n-     */\n-    int getMillis();\n-\n-    /**\n-     * Gets this object as an immutable Duration. This can be useful if you\n-     * don't trust the implementation of the interface to be well-behaved, or\n-     * to get a guaranteed immutable object.\n-     * \n-     * @return a Duration using the same field set and values\n-     */\n-    Duration toDuration();\n-\n-    /**\n-     * Get this object as a MutableDuration.\n-     * \n-     * @return a MutableDuration using the same field set and values\n-     */\n-    MutableDuration toMutableDuration();\n+    TimePeriod toTimePeriod(DurationType type);\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Compares this duration with the specified duration, which can only be\n-     * performed if both are precise.\n+     * Compares this duration with the specified duration based on length.\n      *\n-     * @param obj  a precise duration to check against\n+     * @param obj  a duration to check against\n      * @return negative value if this is less, 0 if equal, or positive value if greater\n      * @throws NullPointerException if the object is null\n      * @throws ClassCastException if the given object is not supported\n-     * @throws IllegalStateException if either duration is imprecise\n      */\n     int compareTo(Object obj);\n \n     /**\n      * Is the length of this duration equal to the duration passed in.\n-     * Both durations must be precise.\n      *\n-     * @param duration  another duration to compare to\n+     * @param duration  another duration to compare to, null means zero milliseconds\n      * @return true if this duration is equal to than the duration passed in\n-     * @throws IllegalArgumentException if the duration is null\n-     * @throws IllegalStateException if either duration is imprecise\n      */\n     boolean isEqual(ReadableDuration duration);\n \n     /**\n      * Is the length of this duration longer than the duration passed in.\n-     * Both durations must be precise.\n      *\n-     * @param duration  another duration to compare to\n+     * @param duration  another duration to compare to, null means zero milliseconds\n      * @return true if this duration is equal to than the duration passed in\n-     * @throws IllegalArgumentException if the duration is null\n-     * @throws IllegalStateException if either duration is imprecise\n      */\n     boolean isLongerThan(ReadableDuration duration);\n \n     /**\n      * Is the length of this duration shorter than the duration passed in.\n-     * Both durations must be precise.\n      *\n-     * @param duration  another duration to compare to\n+     * @param duration  another duration to compare to, null means zero milliseconds\n      * @return true if this duration is equal to than the duration passed in\n-     * @throws IllegalArgumentException if the duration is null\n-     * @throws IllegalStateException if either duration is imprecise\n      */\n     boolean isShorterThan(ReadableDuration duration);\n \n     //-----------------------------------------------------------------------\n     /**\n      * Compares this object with the specified object for equality based\n-     * on the value of each field. All ReadableDuration instances are accepted.\n-     * <p>\n-     * To compare two durations for absolute duration (ie. millisecond duration\n-     * ignoring the fields), use {@link #isEqual(ReadableDuration)} or\n-     * {@link #compareTo(Object)}.\n+     * on the millisecond length. All ReadableDuration instances are accepted.\n      *\n      * @param readableDuration  a readable duration to check against\n-     * @return true if all the field values are equal, false if\n-     *  not or the duration is null or of an incorrect type\n+     * @return true if the length of the duration is equal\n      */\n     boolean equals(Object readableDuration);\n \n     /**\n      * Gets a hash code for the duration that is compatable with the \n      * equals method.\n+     * The following formula must be used:\n+     * <pre>\n+     *  long len = getMillis();\n+     *  return (int) (len ^ (len >>> 32));\n+     * </pre>\n      *\n      * @return a hash code\n      */\n     /**\n      * Gets the value as a String in the ISO8601 duration format.\n      * <p>\n-     * For example, \"P6H3M5S\" represents 6 hours, 3 minutes, 5 seconds.\n+     * For example, \"P6H3M7S\" represents 6 hours, 3 minutes, 7 seconds.\n+     * The field values are determined using the PreciseAll duration type.\n      *\n      * @return the value as an ISO8601 string\n      */\n--- a/JodaTime/src/java/org/joda/time/ReadableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableInterval.java\n      */\n     Instant getEndInstant();\n \n-    /** \n+    //-----------------------------------------------------------------------\n+    /**\n      * Gets the duration of this time interval in milliseconds.\n      * <p>\n      * The duration returned will always be precise because it is relative to\n      * a known date.\n      *\n      * @return the duration of the time interval in milliseconds\n+     * @throws ArithmeticException if the duration exceeds the capacity of a long\n      */\n     long getDurationMillis();\n \n-    /** \n-     * Gets the duration of this time interval using the MillisType duration type.\n-     * <p>\n-     * The duration returned will always be precise because it is relative to\n-     * a known date.\n-     *\n-     * @return the duration of the time interval\n+    /**\n+     * Gets the millisecond duration of this time interval.\n+     * <p>\n+     * If this interval was constructed using a precise duration then that object will\n+     * be returned. Otherwise a new Duration instance using the MillisType is returned.\n+     *\n+     * @return the precise duration of the time interval\n+     * @throws ArithmeticException if the duration exceeds the capacity of a long\n      */\n     Duration getDuration();\n-\n-    /** \n-     * Gets the duration of this time interval.\n-     *\n-     * @param type  the requested type of the duration, null means MillisType\n-     * @return the duration of the time interval\n-     */\n-    Duration getDuration(DurationType type);\n \n     //-----------------------------------------------------------------------\n     /**\n      * @return the time interval as a MutableInterval object\n      */\n     MutableInterval toMutableInterval();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts the duration of the interval to a time period using the\n+     * All duration type.\n+     * <p>\n+     * This method should be used to exract the field values describing the\n+     * difference between the start and end instants.\n+     * The time period may not be precise - if you want the millisecond duration\n+     * then you should use {@link #getDuration()}.\n+     *\n+     * @param type  the requested type of the duration, null means AllType\n+     * @return a time period derived from the interval\n+     */\n+    TimePeriod toTimePeriod();\n+\n+    /**\n+     * Converts the duration of the interval to a time period using the\n+     * specified duration type.\n+     * <p>\n+     * This method should be used to exract the field values describing the\n+     * difference between the start and end instants.\n+     * The time period may not be precise - if you want the millisecond duration\n+     * then you should use {@link #getDuration()}.\n+     *\n+     * @param type  the requested type of the duration, null means AllType\n+     * @return a time period derived from the interval\n+     */\n+    TimePeriod toTimePeriod(DurationType type);\n \n     //-----------------------------------------------------------------------\n     /**\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/ReadableTimePeriod.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Defines a time period specified in terms of individual duration fields.\n+ * <p>\n+ * The implementation of this interface may be mutable or immutable. This\n+ * interface only gives access to retrieve data, never to change it.\n+ * <p>\n+ * Time periods are split up into multiple fields, for example days and seconds.\n+ * Implementations are not required to evenly distribute the values across the fields.\n+ * The value for each field may be positive or negative.\n+ * The {@link DurationType} defines the rules for dividing the fields and which fields\n+ * are supported. Unsupported fields always have a value of zero.\n+ * <p>\n+ * When a time period is added to an instant, the effect is to add each field in turn.\n+ * For example, a time period could be defined as 3 months, 2 days and -1 hours.\n+ * In most circumstances this would be the same as 3 months, 1 day, and 23 hours.\n+ * However, when adding across a daylight savings boundary, a day may be 23 or 25 hours long.\n+ * Thus, the time period is always added field by field to the datetime.\n+ *\n+ * @see ReadableDuration\n+ * @see ReadableInterval\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface ReadableTimePeriod {\n+\n+    /**\n+     * Returns the object which defines which fields this duration supports.\n+     */\n+    DurationType getDurationType();\n+\n+    /**\n+     * Is this duration a precise length of time, or descriptive.\n+     * <p>\n+     * A precise duration could include millis, seconds, minutes or hours.\n+     * However, days, weeks, months and years can vary in length, resulting in\n+     * an imprecise duration.\n+     * <p>\n+     * An imprecise duration can be made precise by pairing it with a\n+     * date in a {@link ReadableInterval}.\n+     *\n+     * @return true if the duration is precise\n+     */\n+    boolean isPrecise();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds this duration to the given instant, returning a new value.\n+     * <p>\n+     * The addition uses the chronology of the DurationType.\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n+     * duration to\n+     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @return milliseconds value plus this duration times scalar\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    long addTo(long instant, int scalar);\n+\n+    /**\n+     * Adds this duration to the given instant, returning a new value.\n+     * <p>\n+     * The addition uses the chronology specified.\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n+     * duration to\n+     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @param chrono  override the chronology of the duration type, unless null is passed in\n+     * @return milliseconds value plus this duration times scalar\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    long addTo(long instant, int scalar, Chronology chrono);\n+\n+    /**\n+     * Adds this duration to the given instant, returning a new Instant.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the instant to add the duration to\n+     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @return instant with the original value plus this duration times scalar\n+     * @throws IllegalArgumentException if the instant is null\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    Instant addTo(ReadableInstant instant, int scalar);\n+\n+    /**\n+     * Adds this duration into the given mutable instant.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the instant to update with the added duration\n+     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @throws IllegalArgumentException if the instant is null\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    void addInto(ReadWritableInstant instant, int scalar);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the years field part of the duration.\n+     * \n+     * @return the number of years in the duration, zero if unsupported\n+     */\n+    int getYears();\n+\n+    /**\n+     * Gets the months field part of the duration.\n+     * \n+     * @return the number of months in the duration, zero if unsupported\n+     */\n+    int getMonths();\n+\n+    /**\n+     * Gets the weeks field part of the duration.\n+     * \n+     * @return the number of weeks in the duration, zero if unsupported\n+     */\n+    int getWeeks();\n+\n+    /**\n+     * Gets the days field part of the duration.\n+     * \n+     * @return the number of days in the duration, zero if unsupported\n+     */\n+    int getDays();\n+\n+    /**\n+     * Gets the hours field part of the duration.\n+     * \n+     * @return the number of hours in the duration, zero if unsupported\n+     */\n+    int getHours();\n+\n+    /**\n+     * Gets the minutes field part of the duration.\n+     * \n+     * @return the number of minutes in the duration, zero if unsupported\n+     */\n+    int getMinutes();\n+\n+    /**\n+     * Gets the seconds field part of the duration.\n+     * \n+     * @return the number of seconds in the duration, zero if unsupported\n+     */\n+    int getSeconds();\n+\n+    /**\n+     * Gets the millis field part of the duration.\n+     * \n+     * @return the number of millis in the duration, zero if unsupported\n+     */\n+    int getMillis();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this object as an immutable TimePeriod. This can be useful if you\n+     * don't trust the implementation of the interface to be well-behaved, or\n+     * to get a guaranteed immutable object.\n+     * \n+     * @return a Duration using the same field set and values\n+     */\n+    TimePeriod toTimePeriod();\n+\n+    /**\n+     * Get this object as a MutableTimePeriod.\n+     * \n+     * @return a MutableTimePeriod using the same field set and values\n+     */\n+    MutableTimePeriod toMutableTimePeriod();\n+\n+    /**\n+     * Gets the total length of this time period in milliseconds, \n+     * failing if the duration is imprecise.\n+     *\n+     * @return the total length of the time period in milliseconds.\n+     * @throws IllegalStateException if this time period is imprecise\n+     */\n+    long toDurationMillis();\n+\n+    /**\n+     * Gets the total length of this time period,\n+     * failing if the duration is imprecise.\n+     *\n+     * @return the total length of the time period in milliseconds.\n+     * @throws IllegalStateException if this time period is imprecise\n+     */\n+    Duration toDuration();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the value of each field. All ReadableTimePeriod instances are accepted.\n+     * <p>\n+     * To compare two durations for absolute duration (ie. millisecond duration\n+     * ignoring the fields), use {@link #toDurationMillis()} or {@link #toDuration()}.\n+     *\n+     * @param readableDuration  a readable duration to check against\n+     * @return true if all the field values are equal, false if\n+     *  not or the duration is null or of an incorrect type\n+     */\n+    boolean equals(Object readableTimePeriod);\n+\n+    /**\n+     * Gets a hash code for the duration that is compatable with the \n+     * equals method. The hashcode must be calculated as follows:\n+     * <pre>\n+     *   int hash = getDurationType().hashCode();\n+     *   hash = 53 * hash + getYears();\n+     *   hash = 53 * hash + getMonths();\n+     *   hash = 53 * hash + getWeeks();\n+     *   hash = 53 * hash + getDays();\n+     *   hash = 53 * hash + getHours();\n+     *   hash = 53 * hash + getMinutes();\n+     *   hash = 53 * hash + getSeconds();\n+     *   hash = 53 * hash + getMillis();\n+     *   return hash;\n+     * </pre>\n+     *\n+     * @return a hash code\n+     */\n+    int hashCode();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"P6H3M5S\" represents 6 hours, 3 minutes, 5 seconds.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    String toString();\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/TimePeriod.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * An immutable time period specifying a set of duration field values.\n+ * <p>\n+ * A time period is divided into a number of fields, such as hours and seconds.\n+ * The way in which that divide occurs is controlled by the DurationType class.\n+ * <p>\n+ * <code>TimePeriod</code> can use any duration type to split the milliseconds into fields.\n+ * The {@link DurationType#getAllType() All} type is used by default.\n+ * <code>All</code> uses the ISO chronology and divides a duration into years, months,\n+ * weeks, days, hours, minutes, seconds and milliseconds as best it can.\n+ * <p>\n+ * This class performs calculations using the individual fields.\n+ * It <i>may</i> be possible to convert a <code>TimePeriod</code> to a <code>Duration</code>.\n+ * The conversion will succeed if the time period is precise.\n+ * A time period is precise if all of the populated fields have a fixed known duration.\n+ * <p>\n+ * When this time period is added to an instant, the effect is of adding each field in turn.\n+ * As a result, this takes into account daylight savings time.\n+ * Adding a time period of 1 day to the day before daylight savings starts will only add\n+ * 23 hours rather than 24 to ensure that the time remains the same.\n+ * If this is not the behaviour you want, then see {@link Duration}.\n+ * <p>\n+ * TimePeriod is thread-safe and immutable, provided that the DurationType is as well.\n+ * All standard DurationType classes supplied are thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ * @see MutableTimePeriod\n+ */\n+public class TimePeriod\n+        extends AbstractTimePeriod\n+        implements ReadableTimePeriod, Serializable {\n+\n+    /** Constant representing zero millisecond duration */\n+    public static final TimePeriod ZERO = new TimePeriod(0L);\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 741052353876488155L;\n+\n+    /**\n+     * Creates a duration from the given millisecond duration using AllType.\n+     * <p>\n+     * The millisecond duration will be split to fields using a UTC version of\n+     * the duration type. This ensures that there are no odd effects caused by\n+     * time zones. The add methods will still use the time zone specific version\n+     * of the duration type.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     */\n+    public TimePeriod(long duration) {\n+        super(duration, null);\n+    }\n+\n+    /**\n+     * Creates a duration from the given millisecond duration.\n+     * <p>\n+     * The millisecond duration will be split to fields using a UTC version of\n+     * the duration type. This ensures that there are no odd effects caused by\n+     * time zones. The add methods will still use the time zone specific version\n+     * of the duration type.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this duration supports\n+     */\n+    public TimePeriod(long duration, DurationType type) {\n+        super(duration, type);\n+    }\n+\n+    /**\n+     * Create a duration from a set of field values using AllType.\n+     * This constructor creates a precise duration.\n+     *\n+     * @param hours  amount of hours in this duration\n+     * @param minutes  amount of minutes in this duration\n+     * @param seconds  amount of seconds in this duration\n+     * @param millis  amount of milliseconds in this duration\n+     */\n+    public TimePeriod(int hours, int minutes, int seconds, int millis) {\n+        super(0, 0, 0, 0, hours, minutes, seconds, millis, null);\n+    }\n+\n+    /**\n+     * Create a duration from a set of field values using AllType.\n+     *\n+     * @param years  amount of years in this duration\n+     * @param months  amount of months in this duration\n+     * @param weeks  amount of weeks in this duration\n+     * @param days  amount of days in this duration\n+     * @param hours  amount of hours in this duration\n+     * @param minutes  amount of minutes in this duration\n+     * @param seconds  amount of seconds in this duration\n+     * @param millis  amount of milliseconds in this duration\n+     */\n+    public TimePeriod(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis) {\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, null);\n+    }\n+\n+    /**\n+     * Create a duration from a set of field values.\n+     *\n+     * @param years  amount of years in this duration, which must be zero if unsupported\n+     * @param months  amount of months in this duration, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this duration, which must be zero if unsupported\n+     * @param days  amount of days in this duration, which must be zero if unsupported\n+     * @param hours  amount of hours in this duration, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this duration, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this duration, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this duration, which must be zero if unsupported\n+     * @param type  which set of fields this duration supports, null means AllType\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    public TimePeriod(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis, DurationType type) {\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, type);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints using AllType.\n+     * This constructor creates a precise duration.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    public TimePeriod(long startInstant, long endInstant) {\n+        super(startInstant, endInstant, null);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     * This constructor creates a precise duration.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param type  which set of fields this duration supports, null means AllType\n+     */\n+    public TimePeriod(long startInstant, long endInstant, DurationType type) {\n+        super(startInstant, endInstant, type);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints using AllType.\n+     * This constructor creates a precise duration.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     */\n+    public TimePeriod(ReadableInstant startInstant, ReadableInstant endInstant) {\n+        super(startInstant, endInstant, null);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     * This constructor creates a precise duration.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     * @param type  which set of fields this duration supports, null means AllType\n+     */\n+    public TimePeriod(ReadableInstant startInstant, ReadableInstant endInstant, DurationType type) {\n+        super(startInstant, endInstant, type);\n+    }\n+\n+    /**\n+     * Creates a duration from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param duration  duration to convert\n+     * @throws IllegalArgumentException if duration is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public TimePeriod(Object duration) {\n+        super(duration, null);\n+    }\n+\n+    /**\n+     * Creates a duration from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param duration  duration to convert\n+     * @param type  which set of fields this duration supports, null means use converter\n+     * @throws IllegalArgumentException if duration is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public TimePeriod(Object duration, DurationType type) {\n+        super(duration, type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates a duration type, converting nulls to a default value and\n+     * checking the type is suitable for this instance.\n+     * \n+     * @param type  the type to check, may be null\n+     * @return the validated type to use, not null\n+     * @throws IllegalArgumentException if the duration type is not precise\n+     */\n+    protected final DurationType checkDurationType(DurationType type) {\n+        if (type == null) {\n+            return DurationType.getAllType();\n+        }\n+        return type;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new TimePeriod instance with the same field values but\n+     * different DurationType.\n+     * \n+     * @param type  the duration type to use, null means AllType\n+     * @return the new duration instance\n+     * @throws IllegalArgumentException if the new duration won't accept all of the current fields\n+     */\n+    public TimePeriod withDurationType(DurationType type) {\n+        if (type == null) {\n+            type = DurationType.getAllType();\n+        }\n+        if (type.equals(getDurationType())) {\n+            return this;\n+        }\n+        return new TimePeriod(getYears(), getMonths(), getWeeks(), getDays(),\n+                    getHours(), getMinutes(), getSeconds(), getMillis(), type);\n+    }\n+\n+    /**\n+     * Creates a new TimePeriod instance with the same millisecond duration but\n+     * different DurationType.\n+     * \n+     * @param type  the duration type to use, null means AllType\n+     * @return the new duration instance\n+     * @throws IllegalStateException if this duration is imprecise\n+     */\n+    public TimePeriod withDurationTypeRetainDuration(DurationType type) {\n+        if (type == null) {\n+            type = DurationType.getAllType();\n+        }\n+        if (type.equals(getDurationType())) {\n+            return this;\n+        }\n+        return new TimePeriod(toDurationMillis(), type);\n+    }\n+\n+    /**\n+     * Creates a new TimePeriod instance with the same millisecond duration but\n+     * all the fields normalized to be within their standard ranges.\n+     * \n+     * @return the new duration instance\n+     * @throws IllegalStateException if this duration is imprecise\n+     */\n+    public TimePeriod withFieldsNormalized() {\n+        return new TimePeriod(toDurationMillis(), getDurationType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setTimePeriod(ReadableTimePeriod period) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setTimePeriod(int years, int months, int weeks, int days,\n+                                       int hours, int minutes, int seconds, int millis) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setTimePeriod(long startInstant, long endInstant) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setTimePeriod(long duration) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setYears(int years) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setMonths(int months) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setWeeks(int weeks) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setDays(int days) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setHours(int hours) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setMinutes(int minutes) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setSeconds(int seconds) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setMillis(int millis) {\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java\n      * Selects a suitable duration type for the given object.\n      *\n      * @param object  the object to examine, must not be null\n-     * @param totalMillisMaster  true if total millis based duration\n+     * @param precise  true if a precise type is required\n      * @return the duration type, never null\n      * @throws ClassCastException if the object is invalid\n      */\n-    public DurationType getDurationType(Object object, boolean totalMillisMaster) {\n-        if (totalMillisMaster) {\n+    public DurationType getDurationType(Object object, boolean precise) {\n+        if (precise) {\n             return DurationType.getPreciseAllType();\n         }\n         return DurationType.getAllType();\n--- a/JodaTime/src/java/org/joda/time/convert/DurationConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/DurationConverter.java\n package org.joda.time.convert;\n \n import org.joda.time.DurationType;\n-import org.joda.time.ReadWritableDuration;\n+import org.joda.time.ReadWritableTimePeriod;\n \n /**\n  * DurationConverter defines how an object is converted to a millisecond duration.\n      * @param object  the object to convert, must not be null\n      * @throws ClassCastException if the object is invalid\n      */\n-    void setInto(ReadWritableDuration duration, Object object);\n+    void setInto(ReadWritableTimePeriod duration, Object object);\n \n     /**\n      * Selects a suitable duration type for the given object.\n--- a/JodaTime/src/java/org/joda/time/convert/LongConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/LongConverter.java\n  */\n package org.joda.time.convert;\n \n-import org.joda.time.ReadWritableDuration;\n+import org.joda.time.ReadWritableTimePeriod;\n \n /**\n  * LongConverter converts a Long to milliseconds in the ISOChronology.\n      * @throws ClassCastException if the object is an invalid type\n      * @throws IllegalArgumentException if the object is invalid\n      */\n-    public void setInto(ReadWritableDuration duration, Object object) {\n-        duration.setTotalMillis(((Long) object).longValue());\n+    public void setInto(ReadWritableTimePeriod duration, Object object) {\n+        duration.setTimePeriod(((Long) object).longValue());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/convert/NullConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/NullConverter.java\n package org.joda.time.convert;\n \n import org.joda.time.DateTimeUtils;\n-import org.joda.time.ReadWritableDuration;\n+import org.joda.time.ReadWritableTimePeriod;\n \n /**\n  * NullConverter converts null to milliseconds (now) in the ISOChronology.\n      * @param object  the object to convert\n      * @throws NullPointerException if the duration is null\n      */\n-    public void setInto(ReadWritableDuration duration, Object object) {\n-        duration.setTotalMillis(0L);\n+    public void setInto(ReadWritableTimePeriod duration, Object object) {\n+        duration.setTimePeriod(0L);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java\n \n import org.joda.time.DurationType;\n import org.joda.time.ReadableDuration;\n-import org.joda.time.ReadWritableDuration;\n+import org.joda.time.ReadWritableTimePeriod;\n \n /**\n  * ReadableDurationConverter extracts milliseconds and chronology from a ReadableDuration.\n      * @throws ClassCastException if the object is an invalid type\n      */\n     public boolean isPrecise(Object object) {\n-        return ((ReadableDuration) object).isPrecise();\n+        return true;\n     }\n \n     /**\n      * @throws IllegalArgumentException if the object is invalid\n      */\n     public long getDurationMillis(Object object) {\n-        return ((ReadableDuration) object).getTotalMillis();\n+        return ((ReadableDuration) object).getMillis();\n     }\n     \n     /**\n      * @throws ClassCastException if the object is an invalid type\n      * @throws IllegalArgumentException if the object is invalid\n      */\n-    public void setInto(ReadWritableDuration duration, Object object) {\n-        duration.setDuration((ReadableDuration) object);\n+    public void setInto(ReadWritableTimePeriod duration, Object object) {\n+        duration.setTimePeriod((ReadableDuration) object);\n     }\n \n     /**\n      * Selects a suitable duration type for the given object.\n      *\n      * @param object  the object to examine, must not be null\n-     * @param totalMillisMaster  true if total millis based duration\n+     * @param precise  true if a precise type is required\n      * @return the duration type from the readable duration\n      * @throws NullPointerException if the object is null\n      * @throws ClassCastException if the object is an invalid type\n      */\n-    public DurationType getDurationType(Object object, boolean totalMillisMaster) {\n-        return ((ReadableDuration) object).getDurationType();\n+    public DurationType getDurationType(Object object, boolean precise) {\n+        return DurationType.getPreciseAllType();\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java\n  */\n package org.joda.time.convert;\n \n-import org.joda.time.ReadWritableDuration;\n+import org.joda.time.ReadWritableTimePeriod;\n import org.joda.time.ReadWritableInterval;\n import org.joda.time.ReadableInterval;\n \n      * @param writableDuration  the duration to set\n      * @param object  the interval to set from\n      */\n-    public void setInto(ReadWritableDuration writableDuration, Object object) {\n+    public void setInto(ReadWritableTimePeriod writableDuration, Object object) {\n         ReadableInterval interval = (ReadableInterval) object;\n-        writableDuration.setTotalMillis(interval.getStartMillis(), interval.getEndMillis());\n+        writableDuration.setTimePeriod(interval.getStartMillis(), interval.getEndMillis());\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.ReadWritableDuration;\n+import org.joda.time.ReadWritableTimePeriod;\n import org.joda.time.ReadWritableInterval;\n import org.joda.time.ReadableDuration;\n+import org.joda.time.TimePeriod;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.format.DateTimeParser;\n-import org.joda.time.format.DurationFormatter;\n-import org.joda.time.format.DurationParser;\n+import org.joda.time.format.TimePeriodFormatter;\n+import org.joda.time.format.TimePeriodParser;\n import org.joda.time.format.ISODateTimeFormat;\n-import org.joda.time.format.ISODurationFormat;\n+import org.joda.time.format.ISOTimePeriodFormat;\n \n /**\n  * StringConverter converts a String to milliseconds in the ISOChronology.\n      * @return the millisecond duration\n      * @throws ClassCastException if the object is invalid\n      */\n-    public void setInto(ReadWritableDuration duration, Object object) {\n-        String str = (String) object;\n-        DurationParser parser = ISODurationFormat.getInstance().standard();\n+    public void setInto(ReadWritableTimePeriod duration, Object object) {\n+        String str = (String) object;\n+        TimePeriodParser parser = ISOTimePeriodFormat.getInstance().standard();\n         int pos = parser.parseInto(duration, str, 0);\n         if (pos < str.length()) {\n             if (pos < 0) {\n                 // Parse again to get a better exception thrown.\n-                parser.parseMutableDuration(duration.getDurationType(), str);\n+                parser.parseMutableTimePeriod(duration.getDurationType(), str);\n             }\n             throw new IllegalArgumentException(\"Invalid format: \\\"\" + str + '\"');\n         }\n         }\n \n         DateTimeParser dateTimeParser = ISODateTimeFormat.getInstance().dateTimeParser();\n-        DurationFormatter durationParser = ISODurationFormat.getInstance().standard();\n+        TimePeriodFormatter durationParser = ISOTimePeriodFormat.getInstance().standard();\n         long startInstant;\n-        ReadableDuration duration;\n+        TimePeriod period;\n \n         char c = leftStr.charAt(0);\n         if (c == 'P' || c == 'p') {\n             startInstant = 0;\n-            duration = durationParser.parseDuration(getDurationType(leftStr, false), leftStr);\n+            period = durationParser.parseTimePeriod(getDurationType(leftStr, false), leftStr);\n         } else {\n             startInstant = dateTimeParser.parseMillis(leftStr);\n-            duration = null;\n+            period = null;\n         }\n \n         c = rightStr.charAt(0);\n         if (c == 'P' || c == 'p') {\n-            if (duration != null) {\n+            if (period != null) {\n                 throw new IllegalArgumentException(\"Interval composed of two durations: \" + str);\n             }\n-            duration = durationParser.parseDuration(getDurationType(rightStr, false), rightStr);\n+            period = durationParser.parseTimePeriod(getDurationType(rightStr, false), rightStr);\n             writableInterval.setStartMillis(startInstant);\n-            writableInterval.setDurationAfterStart(duration);\n+            writableInterval.setTimePeriodAfterStart(period);\n         } else {\n             long endInstant = dateTimeParser.parseMillis(rightStr);\n             writableInterval.setEndMillis(endInstant);\n-            if (duration == null) {\n+            if (period == null) {\n                 writableInterval.setStartMillis(startInstant);\n             } else {\n-                writableInterval.setDurationBeforeEnd(duration);\n+                writableInterval.setTimePeriodBeforeEnd(period);\n             }\n         }\n     }\n--- a/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java\n+++ b/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java\n  */\n public abstract class AbstractDateTimeFormatter {\n \n-    // Accessed also by AbstractDurationFormatter.\n+    // Accessed also by AbstractTimePeriodFormatter.\n     static String createErrorMessage(final String text, final int errorPos) {\n         int sampleLen = errorPos + 20;\n         String sampleText;\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/AbstractTimePeriodFormatter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import org.joda.time.DurationType;\n+import org.joda.time.MutableTimePeriod;\n+import org.joda.time.ReadableTimePeriod;\n+import org.joda.time.TimePeriod;\n+\n+/**\n+ * Abstract base class for implementing {@link TimePeriodPrinter}s,\n+ * {@link TimePeriodParser}s, and {@link TimePeriodFormatter}s. This class\n+ * intentionally does not implement any of those interfaces. You can subclass\n+ * and implement only the interfaces that you need to.\n+ * <p>\n+ * The print methods assume that your subclass has implemented TimePeriodPrinter or\n+ * TimePeriodFormatter. If not, a ClassCastException is thrown when calling those\n+ * methods.\n+ * <p>\n+ * Likewise, the parse methods assume that your subclass has implemented\n+ * TimePeriodParser or TimePeriodFormatter. If not, a ClassCastException is thrown\n+ * when calling the parse methods.\n+ * \n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class AbstractTimePeriodFormatter {\n+    \n+    public int countFieldsToPrint(ReadableTimePeriod period) {\n+        return ((TimePeriodPrinter) this).countFieldsToPrint(period, Integer.MAX_VALUE);\n+    }\n+\n+    public String print(ReadableTimePeriod period) {\n+        TimePeriodPrinter p = (TimePeriodPrinter) this;\n+        StringBuffer buf = new StringBuffer(p.calculatePrintedLength(period));\n+        p.printTo(buf, period);\n+        return buf.toString();\n+    }\n+\n+    public TimePeriod parseTimePeriod(DurationType type, String text) {\n+        return parseMutableTimePeriod(type, text).toTimePeriod();\n+    }\n+\n+    public MutableTimePeriod parseMutableTimePeriod(DurationType type, String text) {\n+        TimePeriodParser p = (TimePeriodParser) this;\n+        MutableTimePeriod period = new MutableTimePeriod(0, type);\n+\n+        int newPos = p.parseInto(period, text, 0);\n+        if (newPos >= 0) {\n+            if (newPos >= text.length()) {\n+                return period;\n+            }\n+        } else {\n+            newPos = ~newPos;\n+        }\n+\n+        throw new IllegalArgumentException(\n+            AbstractDateTimeFormatter.createErrorMessage(text, newPos));\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/ISOTimePeriodFormat.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+/**\n+ * ISOTimePeriodFormat provides factory methods for the ISO8601 standard.\n+ * <p>\n+ * ISOTimePeriodFormat is thread-safe and immutable, and the formatters it\n+ * returns are as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @see TimePeriodFormat\n+ * @see TimePeriodFormatterBuilder\n+ */\n+public class ISOTimePeriodFormat {\n+    private static final ISOTimePeriodFormat INSTANCE = new ISOTimePeriodFormat();\n+\n+    /**\n+     * Returns a singleton instance of ISOTimePeriodFormat.\n+     */\n+    public static ISOTimePeriodFormat getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    private transient TimePeriodFormatter\n+        iStandard,\n+        iAlternate,\n+        iAlternateExtended,\n+        iAlternateWithWeeks,\n+        iAlternateExtendedWihWeeks;\n+\n+    private ISOTimePeriodFormat() {\n+    }\n+\n+    /**\n+     * The standard ISO format - PyYmMwWdDThHmMsS.\n+     * Milliseconds are not output.\n+     */\n+    public TimePeriodFormatter standard() {\n+        if (iStandard == null) {\n+            iStandard = new TimePeriodFormatterBuilder()\n+                .appendLiteral(\"P\")\n+                .printZeroRarely()\n+                .appendYears()\n+                .appendSuffix(\"Y\")\n+                .appendMonths()\n+                .appendSuffix(\"M\")\n+                .appendWeeks()\n+                .appendSuffix(\"W\")\n+                .appendDays()\n+                .appendSuffix(\"D\")\n+                .appendSeparator(\"T\")\n+                .appendHours()\n+                .appendSuffix(\"H\")\n+                .appendMinutes()\n+                .appendSuffix(\"M\")\n+                .appendSeconds()\n+                .appendSuffix(\"S\")\n+                .toFormatter();\n+        }\n+        return iStandard;\n+    }\n+\n+    /**\n+     * PyyyymmddThhmmss\n+     */\n+    public TimePeriodFormatter alternate() {\n+        if (iAlternate == null) {\n+            iAlternate = new TimePeriodFormatterBuilder()\n+                .appendLiteral(\"P\")\n+                .printZeroAlways()\n+                .minimumPrintedDigits(4)\n+                .appendYears()\n+                .minimumPrintedDigits(2)\n+                .appendMonths()\n+                .appendDays()\n+                .appendSeparator(\"T\")\n+                .appendHours()\n+                .appendMinutes()\n+                .appendSeconds()\n+                .toFormatter();\n+        }\n+        return iAlternate;\n+    }\n+\n+    /**\n+     * Pyyyy-mm-ddThh:mm:ss\n+     */\n+    public TimePeriodFormatter alternateExtended() {\n+        if (iAlternateExtended == null) {\n+            iAlternateExtended = new TimePeriodFormatterBuilder()\n+                .appendLiteral(\"P\")\n+                .printZeroAlways()\n+                .minimumPrintedDigits(4)\n+                .appendYears()\n+                .appendSeparator(\"-\")\n+                .minimumPrintedDigits(2)\n+                .appendMonths()\n+                .appendSeparator(\"-\")\n+                .appendDays()\n+                .appendSeparator(\"T\")\n+                .appendHours()\n+                .appendSeparator(\":\")\n+                .appendMinutes()\n+                .appendSeparator(\":\")\n+                .appendSeconds()\n+                .toFormatter();\n+        }\n+        return iAlternateExtended;\n+    }\n+\n+    /**\n+     * PyyyyWwwddThhmmss\n+     */\n+    public TimePeriodFormatter alternateWithWeeks() {\n+        if (iAlternateWithWeeks == null) {\n+            iAlternateWithWeeks = new TimePeriodFormatterBuilder()\n+                .appendLiteral(\"P\")\n+                .printZeroAlways()\n+                .minimumPrintedDigits(4)\n+                .appendYears()\n+                .minimumPrintedDigits(2)\n+                .appendPrefix(\"W\")\n+                .appendWeeks()\n+                .appendDays()\n+                .appendSeparator(\"T\")\n+                .appendHours()\n+                .appendMinutes()\n+                .appendSeconds()\n+                .toFormatter();\n+        }\n+        return iAlternateWithWeeks;\n+    }\n+\n+    /**\n+     * Pyyyy-Www-ddThh:mm:ss\n+     */\n+    public TimePeriodFormatter alternateExtendedWithWeeks() {\n+        if (iAlternateExtendedWihWeeks == null) {\n+            iAlternateExtendedWihWeeks = new TimePeriodFormatterBuilder()\n+                .appendLiteral(\"P\")\n+                .printZeroAlways()\n+                .minimumPrintedDigits(4)\n+                .appendYears()\n+                .appendSeparator(\"-\")\n+                .minimumPrintedDigits(2)\n+                .appendPrefix(\"W\")\n+                .appendWeeks()\n+                .appendSeparator(\"-\")\n+                .appendDays()\n+                .appendSeparator(\"T\")\n+                .appendHours()\n+                .appendSeparator(\":\")\n+                .appendMinutes()\n+                .appendSeparator(\":\")\n+                .appendSeconds()\n+                .toFormatter();\n+        }\n+        return iAlternateExtendedWihWeeks;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/TimePeriodFormat.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.util.Locale;\n+\n+/**\n+ * TimePeriodFormat provides basic printing and parsing capabilities for\n+ * durations. Eventually, this class will also support localization.\n+ * <p>\n+ * TimePeriodFormat is thread-safe and immutable, and the formatters it returns\n+ * are as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see ISOTimePeriodFormat\n+ * @see TimePeriodFormatterBuilder\n+ */\n+public class TimePeriodFormat {\n+\n+    private static final TimePeriodFormat INSTANCE = new TimePeriodFormat();\n+\n+    /**\n+     * Gets a formatter provider that works using the default locale.\n+     * \n+     * @return a format provider\n+     */\n+    public static TimePeriodFormat getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    /**\n+     * Gets a formatter provider that works using the given locale.\n+     * \n+     * @param locale  the Locale to use, null for default locale\n+     * @return a format provider\n+     */\n+    public static TimePeriodFormat getInstance(Locale locale) {\n+        return INSTANCE;\n+    }\n+\n+    private final TimePeriodFormatter iDefault;\n+\n+    private TimePeriodFormat() {\n+        iDefault = new TimePeriodFormatterBuilder()\n+            .appendYears()\n+            .appendSuffix(\" year\", \" years\")\n+            .appendSeparator(\", \", \" and \")\n+            .appendMonths()\n+            .appendSuffix(\" month\", \" months\")\n+            .appendSeparator(\", \", \" and \")\n+            .appendWeeks()\n+            .appendSuffix(\" week\", \" weeks\")\n+            .appendSeparator(\", \", \" and \")\n+            .appendDays()\n+            .appendSuffix(\" day\", \" days\")\n+            .appendSeparator(\", \", \" and \")\n+            .appendHours()\n+            .appendSuffix(\" hour\", \" hours\")\n+            .appendSeparator(\", \", \" and \")\n+            .appendMinutes()\n+            .appendSuffix(\" minute\", \" minutes\")\n+            .appendSeparator(\", \", \" and \")\n+            .appendSeconds()\n+            .appendSuffix(\" second\", \" seconds\")\n+            .appendSeparator(\", \", \" and \")\n+            .appendMillis()\n+            .appendSuffix(\" millisecond\", \" milliseconds\")\n+            .toFormatter();\n+    }\n+\n+    /**\n+     * Returns the default TimePeriodFormatter.\n+     */\n+    public TimePeriodFormatter getDefault() {\n+        return iDefault;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/TimePeriodFormatter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+/**\n+ * Combined interface for printing and parsing.\n+ * <p>\n+ * See each extended interface for details of the methods.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface TimePeriodFormatter extends TimePeriodPrinter, TimePeriodParser {\n+\n+    // Methods inherited\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/TimePeriodFormatterBuilder.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.joda.time.DurationType;\n+import org.joda.time.ReadWritableTimePeriod;\n+import org.joda.time.ReadableTimePeriod;\n+\n+/**\n+ * TimePeriodFormatterBuilder is used for constructing {@link TimePeriodFormatter}s.\n+ * TimePeriodFormatters are built by appending specific fields and separators.\n+ *\n+ * <p>\n+ * For example, a formatter that prints years and months, like \"15 years and 8 months\",\n+ * can be constructed as follows:\n+ * <p>\n+ * <pre>\n+ * TimePeriodFormatter yearsAndMonths = new TimePeriodFormatterBuilder()\n+ *     .printZeroAlways()\n+ *     .appendYears()\n+ *     .appendSuffix(\" year\", \" years\")\n+ *     .appendSeparator(\" and \")\n+ *     .printZeroRarely()\n+ *     .appendMonths()\n+ *     .appendSuffix(\" month\", \" months\")\n+ *     .toFormatter();\n+ * </pre>\n+ * <p>\n+ * TimePeriodFormatterBuilder itself is mutable and not thread-safe, but the\n+ * formatters that it builds are thread-safe and immutable.\n+ *\n+ * @see TimePeriodFormat\n+ * @author Brian S O'Neill\n+ */\n+public class TimePeriodFormatterBuilder {\n+    private static final int PRINT_ZERO_RARELY = 1;\n+    private static final int PRINT_ZERO_IF_SUPPORTED = 2;\n+    private static final int PRINT_ZERO_ALWAYS = 3;\n+\n+    private boolean iFavorFirstFieldForZero;\n+\n+    private int iMinPrintedDigits;\n+    private int iPrintZeroSetting;\n+    private int iMaxParsedDigits;\n+    private boolean iRejectSignedValues;\n+\n+    private DurationFieldAffix iPrefix;\n+\n+    // List of TimePeriodFormatters used to build a final formatter.\n+    private List iFormatters;\n+\n+    // List of TimePeriodFormatters used to build an alternate formatter. The\n+    // alternate is chosen if no other fields are printed.\n+    private List iAlternateFormatters;\n+\n+    public TimePeriodFormatterBuilder() {\n+        clear();\n+    }\n+\n+    /**\n+     * Converts to a TimePeriodPrinter that prints using all the appended\n+     * elements. Subsequent changes to this builder do not affect the returned\n+     * printer.\n+     */\n+    public TimePeriodPrinter toPrinter() {\n+        return toFormatter();\n+    }\n+\n+    /**\n+     * Converts to a TimePeriodParser that parses using all the appended\n+     * elements. Subsequent changes to this builder do not affect the returned\n+     * parser.\n+     */\n+    public TimePeriodParser toParser() {\n+        return toFormatter();\n+    }\n+\n+    /**\n+     * Converts to a TimePeriodFormatter that formats using all the appended\n+     * elements. Subsequent changes to this builder do not affect the returned\n+     * formatter.\n+     */\n+    public TimePeriodFormatter toFormatter() {\n+        TimePeriodFormatter formatter = toFormatter(iFormatters);\n+        List altFormatters = iAlternateFormatters;\n+        if (altFormatters.size() > 0) {\n+            // Alternate is needed only if field formatters were\n+            // appended. Literals may have been appended as well.\n+            for (int i=altFormatters.size(); --i>=0; ) {\n+                if (altFormatters.get(i) instanceof FieldFormatter) {\n+                    formatter = new AlternateSelector\n+                        (formatter, altFormatters, iFavorFirstFieldForZero);\n+                    break;\n+                }\n+            }\n+        }\n+        return formatter;\n+    }\n+\n+    private static TimePeriodFormatter toFormatter(List formatters) {\n+        int size = formatters.size();\n+        if (size >= 2 && formatters.get(1) instanceof Separator) {\n+            TimePeriodFormatter before = (TimePeriodFormatter) formatters.get(0);\n+            if (size == 2) {\n+                // Separator at the end would never format anything.\n+                return before;\n+            }\n+            return ((Separator) formatters.get(1)).finish\n+                (before, toFormatter(formatters.subList(2, size)));\n+        }\n+        return createComposite(formatters);\n+    }\n+\n+    /**\n+     * Clears out all the appended elements, allowing this builder to be\n+     * reused.\n+     */\n+    public void clear() {\n+        iFavorFirstFieldForZero = false;\n+        iMinPrintedDigits = 1;\n+        iPrintZeroSetting = PRINT_ZERO_RARELY;\n+        iMaxParsedDigits = 10;\n+        iRejectSignedValues = false;\n+        iPrefix = null;\n+        if (iFormatters == null) {\n+            iFormatters = new ArrayList();\n+        } else {\n+            iFormatters.clear();\n+        }\n+        if (iAlternateFormatters == null) {\n+            iAlternateFormatters = new ArrayList();\n+        } else {\n+            iAlternateFormatters.clear();\n+        }\n+    }\n+\n+    /**\n+     * Appends another formatter.\n+     *\n+     * @return this TimePeriodFormatterBuilder\n+     */\n+    public TimePeriodFormatterBuilder append(TimePeriodFormatter formatter)\n+        throws IllegalArgumentException\n+    {\n+        if (formatter == null) {\n+            throw new IllegalArgumentException(\"No formatter supplied\");\n+        }\n+        clearPrefix();\n+        iFormatters.add(formatter);\n+        return this;\n+    }\n+\n+    /**\n+     * Instructs the printer to emit specific text, and the parser to expect\n+     * it. The parser is case-insensitive.\n+     *\n+     * @return this TimePeriodFormatterBuilder\n+     * @throws IllegalArgumentException if text is null\n+     */\n+    public TimePeriodFormatterBuilder appendLiteral(String text) {\n+        if (text == null) {\n+            throw new IllegalArgumentException(\"Literal must not be null\");\n+        }\n+        clearPrefix();\n+        Literal literal = new Literal(text);\n+        iFormatters.add(literal);\n+        iAlternateFormatters.add(literal);\n+        return this;\n+    }\n+\n+    /**\n+     * Set the minimum digits printed for the next and following appended\n+     * fields. By default, the minimum digits printed is one. If the field value\n+     * is zero, it is not printed unless a printZero rule is applied.\n+     *\n+     * @return this TimePeriodFormatterBuilder\n+     */\n+    public TimePeriodFormatterBuilder minimumPrintedDigits(int minDigits) {\n+        iMinPrintedDigits = minDigits;\n+        return this;\n+    }\n+\n+    /**\n+     * Set the maximum digits parsed for the next and following appended\n+     * fields. By default, the maximum digits parsed is ten.\n+     *\n+     * @return this TimePeriodFormatterBuilder\n+     */\n+    public TimePeriodFormatterBuilder maximumParsedDigits(int maxDigits) {\n+        iMaxParsedDigits = maxDigits;\n+        return this;\n+    }\n+\n+    /**\n+     * Reject signed values when parsing the next and following appended fields.\n+     *\n+     * @return this TimePeriodFormatterBuilder\n+     */\n+    public TimePeriodFormatterBuilder rejectSignedValues(boolean v) {\n+        iRejectSignedValues = v;\n+        return this;\n+    }\n+\n+    /**\n+     * Never print zero values for the next and following appended fields,\n+     * unless no fields would be printed. If no fields are printed, the printer\n+     * forces at most one \"printZeroRarely\" field to print a zero.\n+     * <p>\n+     * This field setting is the default.\n+     *\n+     * @return this TimePeriodFormatterBuilder\n+     * @see #favorLastFieldForZero()\n+     * @see #favorFirstFieldForZero()\n+     */\n+    public TimePeriodFormatterBuilder printZeroRarely() {\n+        iPrintZeroSetting = PRINT_ZERO_RARELY;\n+        return this;\n+    }\n+\n+    /**\n+     * Print zero values for the next and following appened fields only if the\n+     * duration supports it.\n+     *\n+     * @return this TimePeriodFormatterBuilder\n+     */\n+    public TimePeriodFormatterBuilder printZeroIfSupported() {\n+        iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED;\n+        return this;\n+    }\n+\n+    /**\n+     * Always print zero values for the next and following appended fields,\n+     * even if the duration doesn't support it. The parser requires values for\n+     * fields that always print zero.\n+     *\n+     * @return this TimePeriodFormatterBuilder\n+     */\n+    public TimePeriodFormatterBuilder printZeroAlways() {\n+        iPrintZeroSetting = PRINT_ZERO_ALWAYS;\n+        return this;\n+    }\n+\n+    /**\n+     * Append a field prefix which applies only to the next appended field. If\n+     * the field is not printed, neither is the prefix.\n+     *\n+     * @param text text to print before field only if field is printed\n+     * @return this TimePeriodFormatterBuilder\n+     * @see #appendSuffix\n+     */\n+    public TimePeriodFormatterBuilder appendPrefix(String text) {\n+        if (text == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        return appendPrefix(new SingularAffix(text));\n+    }\n+\n+    /**\n+     * Append a field prefix which applies only to the next appended field. If\n+     * the field is not printed, neither is the prefix.\n+     * <p>\n+     * During parsing, the singular and plural versions are accepted whether\n+     * or not the actual value matches plurality.\n+     *\n+     * @param singularText text to print if field value is one\n+     * @param pluralText text to print if field value is not one\n+     * @return this TimePeriodFormatterBuilder\n+     * @see #appendSuffix\n+     */\n+    public TimePeriodFormatterBuilder appendPrefix(String singularText,\n+                                                 String pluralText) {\n+        if (singularText == null || pluralText == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        return appendPrefix(new PluralAffix(singularText, pluralText));\n+    }\n+\n+    /**\n+     * Append a field prefix which applies only to the next appended field. If\n+     * the field is not printed, neither is the prefix.\n+     *\n+     * @param prefix custom prefix\n+     * @return this TimePeriodFormatterBuilder\n+     * @see #appendSuffix\n+     */\n+    private TimePeriodFormatterBuilder appendPrefix(DurationFieldAffix prefix) {\n+        if (prefix == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (iPrefix != null) {\n+            prefix = new CompositeAffix(iPrefix, prefix);\n+        }\n+        iPrefix = prefix;\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer years field, if supported.\n+     *\n+     * @return this TimePeriodFormatterBuilder\n+     */\n+    public TimePeriodFormatterBuilder appendYears() {\n+        appendField(1);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer years field, if supported.\n+     *\n+     * @return this TimePeriodFormatterBuilder\n+     */\n+    public TimePeriodFormatterBuilder appendMonths() {\n+        appendField(2);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer weeks field, if supported.\n+     *\n+     * @return this TimePeriodFormatterBuilder\n+     */\n+    public TimePeriodFormatterBuilder appendWeeks() {\n+        appendField(3);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer days field, if supported.\n+     *\n+     * @return this TimePeriodFormatterBuilder\n+     */\n+    public TimePeriodFormatterBuilder appendDays() {\n+        appendField(4);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer hours field, if supported.\n+     *\n+     * @return this TimePeriodFormatterBuilder\n+     */\n+    public TimePeriodFormatterBuilder appendHours() {\n+        appendField(5);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer minutes field, if supported.\n+     *\n+     * @return this TimePeriodFormatterBuilder\n+     */\n+    public TimePeriodFormatterBuilder appendMinutes() {\n+        appendField(6);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer seconds field, if supported.\n+     *\n+     * @return this TimePeriodFormatterBuilder\n+     */\n+    public TimePeriodFormatterBuilder appendSeconds() {\n+        appendField(7);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer millis field, if supported.\n+     *\n+     * @return this TimePeriodFormatterBuilder\n+     */\n+    public TimePeriodFormatterBuilder appendMillis() {\n+        appendField(8);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer millis field, if supported.\n+     *\n+     * @return this TimePeriodFormatterBuilder\n+     */\n+    public TimePeriodFormatterBuilder appendMillis3Digit() {\n+        appendField(8, 3);\n+        return this;\n+    }\n+\n+    private void appendField(int type) {\n+        appendField(type, iMinPrintedDigits);\n+    }\n+\n+    private void appendField(int type, int minPrinted) {\n+        FieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting,\n+            iMaxParsedDigits, iRejectSignedValues, type, iPrefix, null);\n+        iFormatters.add(field);\n+        if (iPrintZeroSetting == PRINT_ZERO_RARELY) {\n+            iAlternateFormatters.add(field);\n+        }\n+        iPrefix = null;\n+    }\n+\n+    /**\n+     * Append a field suffix which applies only to the last appended field. If\n+     * the field is not printed, neither is the suffix.\n+     *\n+     * @param text text to print after field only if field is printed\n+     * @return this TimePeriodFormatterBuilder\n+     * @throws IllegalStateException if no field exists to append to\n+     * @see #appendPrefix\n+     */\n+    public TimePeriodFormatterBuilder appendSuffix(String text) {\n+        if (text == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        return appendSuffix(new SingularAffix(text));\n+    }\n+\n+    /**\n+     * Append a field suffix which applies only to the last appended field. If\n+     * the field is not printed, neither is the suffix.\n+     * <p>\n+     * During parsing, the singular and plural versions are accepted whether or\n+     * not the actual value matches plurality.\n+     *\n+     * @param singularText text to print if field value is one\n+     * @param pluralText text to print if field value is not one\n+     * @return this TimePeriodFormatterBuilder\n+     * @throws IllegalStateException if no field exists to append to\n+     * @see #appendPrefix\n+     */\n+    public TimePeriodFormatterBuilder appendSuffix(String singularText,\n+                                                 String pluralText) {\n+        if (singularText == null || pluralText == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        return appendSuffix(new PluralAffix(singularText, pluralText));\n+    }\n+\n+    /**\n+     * Append a field suffix which applies only to the last appended field. If\n+     * the field is not printed, neither is the suffix.\n+     *\n+     * @param suffix custom suffix\n+     * @return this TimePeriodFormatterBuilder\n+     * @throws IllegalStateException if no field exists to append to\n+     * @see #appendPrefix\n+     */\n+    private TimePeriodFormatterBuilder appendSuffix(DurationFieldAffix suffix) {\n+        final Object originalField;\n+        if (iFormatters.size() > 0) {\n+            originalField = iFormatters.get(iFormatters.size() - 1);\n+        } else {\n+            originalField = null;\n+        }\n+\n+        if (originalField == null || !(originalField instanceof FieldFormatter)) {\n+            throw new IllegalStateException(\"No field to apply suffix to\");\n+        }\n+\n+        clearPrefix();\n+        Object newField = new FieldFormatter((FieldFormatter) originalField, suffix);\n+        iFormatters.set(iFormatters.size() - 1, newField);\n+\n+        int index = iAlternateFormatters.lastIndexOf(originalField);\n+        if (index >= 0) {\n+            iAlternateFormatters.set(index, newField);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * During printing, separators are only printed if fields are printed\n+     * following the latest one.\n+     * <p>\n+     * Note: appending a separator discontinues any further work on the latest\n+     * appended field.\n+     *\n+     * @return this TimePeriodFormatterBuilder\n+     */\n+    public TimePeriodFormatterBuilder appendSeparator(String text) {\n+        return appendSeparator(text, text);\n+    }\n+\n+    /**\n+     * During printing, separators are only printed if fields are printed\n+     * following the latest one.\n+     * <p>\n+     * During parsing, either text parameter is accepted, and is\n+     * case-insensitive.\n+     * <p>\n+     * Note: appending a separator discontinues any further work on the latest\n+     * appended field.\n+     *\n+     * @param finalText alternate used if this is the final separator\n+     * printed\n+     * @return this TimePeriodFormatterBuilder\n+     */\n+    public TimePeriodFormatterBuilder appendSeparator(String text,\n+                                                    String finalText) {\n+        if (text == null || finalText == null) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        clearPrefix();\n+\n+        List formatters = iFormatters;\n+\n+        if (formatters.size() == 0) {\n+            // Separator at the beginning would never print anything.\n+            return this;\n+        }\n+\n+        // Create a composite over all the fields between separators.\n+        int i;\n+        Separator lastSeparator = null;\n+        for (i=formatters.size(); --i>=0; ) {\n+            if (formatters.get(i) instanceof Separator) {\n+                lastSeparator = (Separator) formatters.get(i);\n+                formatters = formatters.subList(i + 1, formatters.size());\n+                break;\n+            }\n+        }\n+\n+        if (lastSeparator != null && formatters.size() == 0) {\n+            // Merge two adjacent separators together.\n+            iFormatters.set(i, lastSeparator.merge(text, finalText));\n+        } else {\n+            TimePeriodFormatter composite = createComposite(formatters);\n+            formatters.clear();\n+            formatters.add(composite);\n+            \n+            // The separator will be finished later.\n+            formatters.add(new Separator(text, finalText));\n+        }\n+            \n+        return this;\n+    }\n+\n+    /**\n+     * If the printer doesn't print any field values, it forces a\n+     * \"printZeroRarely\" field to print. This setting controls which field is\n+     * selected.\n+     * <p>\n+     * It starts from the last appended field, and moves towards the first,\n+     * stopping until it finds a field that is supported by the duration being\n+     * printed. If no supported fields are found, then no fields are printed.\n+     * <p>\n+     * This setting is the default.\n+     *\n+     * @return this TimePeriodFormatterBuilder\n+     * @see #printZeroRarely()\n+     */\n+    public TimePeriodFormatterBuilder favorLastFieldForZero() {\n+        iFavorFirstFieldForZero = false;\n+        return this;\n+    }\n+\n+    /**\n+     * If the printer doesn't print any field values, it forces a\n+     * \"printZeroRarely\" field to print. This setting controls which field is\n+     * selected.\n+     * <p>\n+     * It starts from the first appended field, and moves towards the last,\n+     * stopping until it finds a field that is supported by the duration being\n+     * printed. If no supported fields are found, then no fields are printed.\n+     *\n+     * @return this TimePeriodFormatterBuilder\n+     * @see #printZeroRarely()\n+     */\n+    public TimePeriodFormatterBuilder favorFirstFieldForZero() {\n+        iFavorFirstFieldForZero = true;\n+        return this;\n+    }\n+\n+    private void clearPrefix() throws IllegalStateException {\n+        if (iPrefix != null) {\n+            throw new IllegalStateException(\"Prefix not followed by field\");\n+        }\n+        iPrefix = null;\n+    }\n+\n+    private static TimePeriodFormatter createComposite(List formatters) {\n+        if (formatters.size() == 1) {\n+            return (TimePeriodFormatter)formatters.get(0);\n+        } else {\n+            return new Composite(formatters);\n+        }\n+    }\n+\n+    /**\n+     * Defines a formatted field's prefix or suffix text.\n+     */\n+    private static interface DurationFieldAffix {\n+        int calculatePrintedLength(int value);\n+        \n+        void printTo(StringBuffer buf, int value);\n+        \n+        void printTo(Writer out, int value) throws IOException;\n+        \n+        /**\n+         * @return new position after parsing affix, or ~position of failure\n+         */\n+        int parse(String durationStr, int position);\n+\n+        /**\n+         * @return position where affix starts, or original ~position if not found\n+         */\n+        int scan(String durationStr, int position);\n+    }\n+\n+    private static final class SingularAffix implements DurationFieldAffix {\n+        private final String iText;\n+\n+        SingularAffix(String text) {\n+            iText = text;\n+        }\n+\n+        public int calculatePrintedLength(int value) {\n+            return iText.length();\n+        }\n+\n+        public void printTo(StringBuffer buf, int value) {\n+            buf.append(iText);\n+        }\n+\n+        public void printTo(Writer out, int value) throws IOException {\n+            out.write(iText);\n+        }\n+\n+        public int parse(String durationStr, int position) {\n+            String text = iText;\n+            int textLength = text.length();\n+            if (durationStr.regionMatches(true, position, text, 0, textLength)) {\n+                return position + textLength;\n+            }\n+            return ~position;\n+        }\n+\n+        public int scan(String durationStr, final int position) {\n+            String text = iText;\n+            int textLength = text.length();\n+            int sourceLength = durationStr.length();\n+            for (int pos = position; pos < sourceLength; pos++) {\n+                if (durationStr.regionMatches(true, pos, text, 0, textLength)) {\n+                    return pos;\n+                }\n+            }\n+            return ~position;\n+        }\n+    }\n+\n+    private static final class PluralAffix implements DurationFieldAffix {\n+        private final String iSingularText;\n+        private final String iPluralText;\n+\n+        PluralAffix(String singularText, String pluralText) {\n+            iSingularText = singularText;\n+            iPluralText = pluralText;\n+        }\n+\n+        public int calculatePrintedLength(int value) {\n+            return (value == 1 ? iSingularText : iPluralText).length();\n+        }\n+\n+        public void printTo(StringBuffer buf, int value) {\n+            buf.append(value == 1 ? iSingularText : iPluralText);\n+        }\n+\n+        public void printTo(Writer out, int value) throws IOException {\n+            out.write(value == 1 ? iSingularText : iPluralText);\n+        }\n+\n+        public int parse(String durationStr, int position) {\n+            String text1 = iPluralText;\n+            String text2 = iSingularText; \n+\n+            if (text1.length() < text2.length()) {\n+                // Swap in order to match longer one first.\n+                String temp = text1;\n+                text1 = text2;\n+                text2 = temp;\n+            }\n+\n+            if (durationStr.regionMatches\n+                (true, position, text1, 0, text1.length())) {\n+                return position + text1.length();\n+            }\n+            if (durationStr.regionMatches\n+                (true, position, text2, 0, text2.length())) {\n+                return position + text2.length();\n+            }\n+\n+            return ~position;\n+        }\n+\n+        public int scan(String durationStr, final int position) {\n+            String text1 = iPluralText;\n+            String text2 = iSingularText; \n+\n+            if (text1.length() < text2.length()) {\n+                // Swap in order to match longer one first.\n+                String temp = text1;\n+                text1 = text2;\n+                text2 = temp;\n+            }\n+\n+            int textLength1 = text1.length();\n+            int textLength2 = text2.length();\n+\n+            int sourceLength = durationStr.length();\n+            for (int pos = position; pos < sourceLength; pos++) {\n+                if (durationStr.regionMatches(true, pos, text1, 0, textLength1)) {\n+                    return pos;\n+                }\n+                if (durationStr.regionMatches(true, pos, text2, 0, textLength2)) {\n+                    return pos;\n+                }\n+            }\n+            return ~position;\n+        }\n+    }\n+\n+    private static final class CompositeAffix implements DurationFieldAffix {\n+        private final DurationFieldAffix iLeft;\n+        private final DurationFieldAffix iRight;\n+\n+        CompositeAffix(DurationFieldAffix left, DurationFieldAffix right) {\n+            iLeft = left;\n+            iRight = right;\n+        }\n+\n+        public int calculatePrintedLength(int value) {\n+            return iLeft.calculatePrintedLength(value)\n+                + iRight.calculatePrintedLength(value);\n+        }\n+\n+        public void printTo(StringBuffer buf, int value) {\n+            iLeft.printTo(buf, value);\n+            iRight.printTo(buf, value);\n+        }\n+\n+        public void printTo(Writer out, int value) throws IOException {\n+            iLeft.printTo(out, value);\n+            iRight.printTo(out, value);\n+        }\n+\n+        public int parse(String durationStr, int position) {\n+            position = iLeft.parse(durationStr, position);\n+            if (position >= 0) {\n+                position = iRight.parse(durationStr, position);\n+            }\n+            return position;\n+        }\n+\n+        public int scan(String durationStr, final int position) {\n+            int pos = iLeft.scan(durationStr, position);\n+            if (pos >= 0) {\n+                return iRight.scan(durationStr, pos);\n+            }\n+            return ~position;\n+        }\n+    }\n+\n+    private static final class FieldFormatter extends AbstractTimePeriodFormatter\n+        implements TimePeriodFormatter\n+    {\n+        private final int iMinPrintedDigits;\n+        private final int iPrintZeroSetting;\n+        private final int iMaxParsedDigits;\n+        private final boolean iRejectSignedValues;\n+\n+        private final int iFieldType;\n+\n+        private final DurationFieldAffix iPrefix;\n+        private final DurationFieldAffix iSuffix;\n+\n+        FieldFormatter(int minPrintedDigits, int printZeroSetting,\n+                       int maxParsedDigits, boolean rejectSignedValues,\n+                       int fieldType, DurationFieldAffix prefix, DurationFieldAffix suffix) {\n+            iMinPrintedDigits = minPrintedDigits;\n+            iPrintZeroSetting = printZeroSetting;\n+            iMaxParsedDigits = maxParsedDigits;\n+            iRejectSignedValues = rejectSignedValues;\n+            iFieldType = fieldType;\n+            iPrefix = prefix;\n+            iSuffix = suffix;\n+        }\n+\n+        FieldFormatter(FieldFormatter field, DurationFieldAffix suffix) {\n+            iMinPrintedDigits = field.iMinPrintedDigits;\n+            iPrintZeroSetting = field.iPrintZeroSetting;\n+            iMaxParsedDigits = field.iMaxParsedDigits;\n+            iRejectSignedValues = field.iRejectSignedValues;\n+            iFieldType = field.iFieldType;\n+            iPrefix = field.iPrefix;\n+            if (field.iSuffix != null) {\n+                suffix = new CompositeAffix(field.iSuffix, suffix);\n+            }\n+            iSuffix = suffix;\n+        }\n+\n+        FieldFormatter(FieldFormatter field, int printZeroSetting) {\n+            iMinPrintedDigits = field.iMinPrintedDigits;\n+            iPrintZeroSetting = printZeroSetting;\n+            iMaxParsedDigits = field.iMaxParsedDigits;\n+            iRejectSignedValues = field.iRejectSignedValues;\n+            iFieldType = field.iFieldType;\n+            iPrefix = field.iPrefix;\n+            iSuffix = field.iSuffix;\n+        }\n+\n+        public int countFieldsToPrint(ReadableTimePeriod period) {\n+            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) >= 0) {\n+                return 1;\n+            }\n+            return 0;\n+        }\n+\n+        public int countFieldsToPrint(ReadableTimePeriod period, int stopAt) {\n+            return stopAt <= 0 ? 0 : countFieldsToPrint(period);\n+        }\n+\n+        public int calculatePrintedLength(ReadableTimePeriod period) {\n+            long valueLong = getFieldValue(period);\n+            if (valueLong < 0) {\n+                return 0;\n+            }\n+\n+            int value = (int)valueLong;\n+\n+            int sum = Math.max\n+                (FormatUtils.calculateDigitCount(value), iMinPrintedDigits);\n+            if (value < 0) {\n+                // Account for sign character\n+                sum++;\n+            }\n+\n+            DurationFieldAffix affix;\n+            if ((affix = iPrefix) != null) {\n+                sum += affix.calculatePrintedLength(value);\n+            }\n+            if ((affix = iSuffix) != null) {\n+                sum += affix.calculatePrintedLength(value);\n+            }\n+\n+            return sum;\n+        }\n+        \n+        public void printTo(StringBuffer buf, ReadableTimePeriod period) {\n+            long valueLong = getFieldValue(period);\n+            if (valueLong < 0) {\n+                return;\n+            }\n+            int value = (int)valueLong;\n+\n+            DurationFieldAffix affix;\n+            if ((affix = iPrefix) != null) {\n+                affix.printTo(buf, value);\n+            }\n+            int minDigits = iMinPrintedDigits;\n+            if (minDigits <= 1) {\n+                FormatUtils.appendUnpaddedInteger(buf, value);\n+            } else {\n+                FormatUtils.appendPaddedInteger(buf, value, minDigits);\n+            }\n+            if ((affix = iSuffix) != null) {\n+                affix.printTo(buf, value);\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadableTimePeriod period) throws IOException {\n+            long valueLong = getFieldValue(period);\n+            if (valueLong < 0) {\n+                return;\n+            }\n+            int value = (int)valueLong;\n+\n+            DurationFieldAffix affix;\n+            if ((affix = iPrefix) != null) {\n+                affix.printTo(out, value);\n+            }\n+            int minDigits = iMinPrintedDigits;\n+            if (minDigits <= 1) {\n+                FormatUtils.writeUnpaddedInteger(out, value);\n+            } else {\n+                FormatUtils.writePaddedInteger(out, value, minDigits);\n+            }\n+            if ((affix = iSuffix) != null) {\n+                affix.printTo(out, value);\n+            }\n+        }\n+\n+        public int parseInto(ReadWritableTimePeriod period,\n+                             String text, int position) {\n+\n+            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n+\n+            // Shortcut test.\n+            if (position >= text.length()) {\n+                return mustParse ? ~position : position;\n+            }\n+\n+            if (iPrefix != null) {\n+                position = iPrefix.parse(text, position);\n+                if (position >= 0) {\n+                    // If prefix is found, then the parse must finish.\n+                    mustParse = true;\n+                } else {\n+                    // Prefix not found, so bail.\n+                    if (!mustParse) {\n+                        // It's okay because parsing of this field is not\n+                        // required. Don't return an error. Fields down the\n+                        // chain can continue on, trying to parse.\n+                        return ~position;\n+                    }\n+                    return position;\n+                }\n+            }\n+\n+            int suffixPos = -1;\n+            if (iSuffix != null && !mustParse) {\n+                // Pre-scan the suffix, to help determine if this field must be\n+                // parsed.\n+                suffixPos = iSuffix.scan(text, position);\n+                if (suffixPos >= 0) {\n+                    // If suffix is found, then parse must finish.\n+                    mustParse = true;\n+                } else {\n+                    // Suffix not found, so bail.\n+                    if (!mustParse) {\n+                        // It's okay because parsing of this field is not\n+                        // required. Don't return an error. Fields down the\n+                        // chain can continue on, trying to parse.\n+                        return ~suffixPos;\n+                    }\n+                    return suffixPos;\n+                }\n+            }\n+\n+            if (!mustParse && !isSupported(period.getDurationType())) {\n+                // If parsing is not required and the field is not supported,\n+                // exit gracefully so that another parser can continue on.\n+                return position;\n+            }\n+\n+            int limit;\n+            if (suffixPos > 0) {\n+                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n+            } else {\n+                limit = Math.min(iMaxParsedDigits, text.length() - position);\n+            }\n+\n+            boolean negative = false;\n+            int length = 0;\n+            while (length < limit) {\n+                char c = text.charAt(position + length);\n+                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n+                    negative = c == '-';\n+                    if (negative) {\n+                        length++;\n+                    } else {\n+                        // Skip the '+' for parseInt to succeed.\n+                        position++;\n+                    }\n+                    // Expand the limit to disregard the sign character.\n+                    limit = Math.min(limit + 1, text.length() - position);\n+                    continue;\n+                }\n+                if (c < '0' || c > '9') {\n+                    break;\n+                }\n+                length++;\n+            }\n+\n+            if (length == 0) {\n+                return ~position;\n+            }\n+\n+            int value;\n+            if (length >= 9) {\n+                // Since value may exceed max, use stock parser which checks\n+                // for this.\n+                value = Integer.parseInt\n+                    (text.substring(position, position += length));\n+            } else {\n+                int i = position;\n+                if (negative) {\n+                    i++;\n+                }\n+                value = text.charAt(i++) - '0';\n+                position += length;\n+                while (i < position) {\n+                    value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n+                }\n+                if (negative) {\n+                    value = -value;\n+                }\n+            }\n+            \n+            setFieldValue(period, value);\n+                \n+            if (position >= 0 && iSuffix != null) {\n+                position = iSuffix.parse(text, position);\n+            }\n+                \n+            return position;\n+        }\n+\n+        /**\n+         * @return negative value if nothing to print, otherwise lower 32 bits\n+         * is signed int value.\n+         */\n+        long getFieldValue(ReadableTimePeriod period) {\n+            DurationType type;\n+            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n+                type = null; // Don't need to check if supported.\n+            } else {\n+                type = period.getDurationType();\n+            }\n+\n+            int value;\n+\n+            switch (iFieldType) {\n+            default:\n+                return -1;\n+            case 1:\n+                if (type != null && type.years().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = period.getYears();\n+                break;\n+            case 2:\n+                if (type != null && type.months().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = period.getMonths();\n+                break;\n+            case 3:\n+                if (type != null && type.weeks().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = period.getWeeks();\n+                break;\n+            case 4:\n+                if (type != null && type.days().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = period.getDays();\n+                break;\n+            case 5:\n+                if (type != null && type.hours().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = period.getHours();\n+                break;\n+            case 6:\n+                if (type != null && type.minutes().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = period.getMinutes();\n+                break;\n+            case 7:\n+                if (type != null && type.seconds().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = period.getSeconds();\n+                break;\n+            case 8:\n+                if (type != null && type.millis().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = period.getMillis();\n+                break;\n+            }\n+\n+            if (value == 0 && iPrintZeroSetting == PRINT_ZERO_RARELY) {\n+                return -1;\n+            }\n+\n+            return value & 0xffffffffL;\n+        }\n+\n+        boolean isSupported(DurationType type) {\n+            switch (iFieldType) {\n+            default:\n+                return false;\n+            case 1:\n+                return type.years().isSupported();\n+            case 2:\n+                return type.months().isSupported();\n+            case 3:\n+                return type.weeks().isSupported();\n+            case 4:\n+                return type.days().isSupported();\n+            case 5:\n+                return type.hours().isSupported();\n+            case 6:\n+                return type.minutes().isSupported();\n+            case 7:\n+                return type.seconds().isSupported();\n+            case 8:\n+                return type.millis().isSupported();\n+            }\n+        }\n+\n+        void setFieldValue(ReadWritableTimePeriod period, int value) {\n+            switch (iFieldType) {\n+            default:\n+                break;\n+            case 1:\n+                period.setYears(value);\n+                break;\n+            case 2:\n+                period.setMonths(value);\n+                break;\n+            case 3:\n+                period.setWeeks(value);\n+                break;\n+            case 4:\n+                period.setDays(value);\n+                break;\n+            case 5:\n+                period.setHours(value);\n+                break;\n+            case 6:\n+                period.setMinutes(value);\n+                break;\n+            case 7:\n+                period.setSeconds(value);\n+                break;\n+            case 8:\n+                period.setMillis(value);\n+                break;\n+            }\n+        }\n+\n+        int getPrintZeroSetting() {\n+            return iPrintZeroSetting;\n+        }\n+    }\n+\n+    private static final class Literal extends AbstractTimePeriodFormatter\n+        implements TimePeriodFormatter\n+    {\n+        private final String iText;\n+\n+        Literal(String text) {\n+            iText = text;\n+        }\n+\n+        public int countFieldsToPrint(ReadableTimePeriod period, int stopAt) {\n+            return 0;\n+        }\n+\n+        public int calculatePrintedLength(ReadableTimePeriod period) {\n+            return iText.length();\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadableTimePeriod period) {\n+            buf.append(iText);\n+        }\n+\n+        public void printTo(Writer out, ReadableTimePeriod period) throws IOException {\n+            out.write(iText);\n+        }\n+\n+        public int parseInto(ReadWritableTimePeriod period,\n+                             String periodStr, int position) {\n+            if (periodStr.regionMatches(true, position, iText, 0, iText.length())) {\n+                return position + iText.length();\n+            }\n+            return ~position;\n+        }\n+    }\n+\n+    private static final class Separator extends AbstractTimePeriodFormatter\n+        implements TimePeriodFormatter\n+    {\n+        private final String iText;\n+        private final String iFinalText;\n+\n+        private final TimePeriodFormatter iBefore;\n+        private final TimePeriodFormatter iAfter;\n+\n+        Separator(String text, String finalText) {\n+            this(text, finalText, null, null);\n+        }\n+\n+        Separator(String text, String finalText,\n+                  TimePeriodFormatter before, TimePeriodFormatter after) {\n+            iText = text;\n+            iFinalText = finalText;\n+            iBefore = before;\n+            iAfter = after;\n+        }\n+\n+        public int countFieldsToPrint(ReadableTimePeriod period, int stopAt) {\n+            int sum = iBefore.countFieldsToPrint(period, stopAt);\n+            if (sum < stopAt) {\n+                sum += iAfter.countFieldsToPrint(period, stopAt);\n+            }\n+            return sum;\n+        }\n+\n+        public int calculatePrintedLength(ReadableTimePeriod period) {\n+            int sum = iBefore.calculatePrintedLength(period)\n+                + iAfter.calculatePrintedLength(period);\n+\n+            if (iBefore.countFieldsToPrint(period, 1) > 0) {\n+                int afterCount = iAfter.countFieldsToPrint(period, 2);\n+                if (afterCount > 0) {\n+                    sum += (afterCount > 1 ? iText : iFinalText).length();\n+                }\n+            }\n+\n+            return sum;\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadableTimePeriod period) {\n+            TimePeriodPrinter before = iBefore;\n+            TimePeriodPrinter after = iAfter;\n+\n+            before.printTo(buf, period);\n+\n+            if (before.countFieldsToPrint(period, 1) > 0) {\n+                int afterCount = after.countFieldsToPrint(period, 2);\n+                if (afterCount > 0) {\n+                    buf.append(afterCount > 1 ? iText : iFinalText);\n+                }\n+            }\n+\n+            after.printTo(buf, period);\n+        }\n+\n+        public void printTo(Writer out, ReadableTimePeriod period) throws IOException {\n+            TimePeriodPrinter before = iBefore;\n+            TimePeriodPrinter after = iAfter;\n+\n+            before.printTo(out, period);\n+\n+            if (before.countFieldsToPrint(period, 1) > 0) {\n+                int afterCount = after.countFieldsToPrint(period, 2);\n+                if (afterCount > 0) {\n+                    out.write(afterCount > 1 ? iText : iFinalText);\n+                }\n+            }\n+\n+            after.printTo(out, period);\n+        }\n+\n+        public int parseInto(ReadWritableTimePeriod period,\n+                             String periodStr, int position) {\n+            final int oldPos = position;\n+\n+            position = iBefore.parseInto(period, periodStr, position);\n+\n+            if (position < 0) {\n+                return position;\n+            }\n+\n+            if (position > oldPos) {\n+                // Since position advanced, this separator is\n+                // allowed. Optionally parse it.\n+                if (periodStr.regionMatches(true, position, iText, 0, iText.length())) {\n+                    position += iText.length();\n+                } else if (iText != iFinalText && periodStr.regionMatches\n+                           (true, position, iFinalText, 0, iFinalText.length())) {\n+                    position += iFinalText.length();\n+                }\n+            }\n+\n+            return iAfter.parseInto(period, periodStr, position);\n+        }\n+\n+        Separator merge(String text, String finalText) {\n+            return new Separator(iText + text, iFinalText + finalText, iBefore, iAfter);\n+        }\n+\n+        Separator finish(TimePeriodFormatter before, TimePeriodFormatter after) {\n+            return new Separator(iText, iFinalText, before, after);\n+        }\n+    }\n+\n+    private static final class Composite extends AbstractTimePeriodFormatter\n+        implements TimePeriodFormatter\n+    {\n+        private final TimePeriodFormatter[] iFormatters;\n+\n+        Composite(List formatters) {\n+            iFormatters = (TimePeriodFormatter[])formatters.toArray\n+                (new TimePeriodFormatter[formatters.size()]);\n+        }\n+\n+        public int countFieldsToPrint(ReadableTimePeriod period, int stopAt) {\n+            int sum = 0;\n+            TimePeriodPrinter[] printers = iFormatters;\n+            for (int i=printers.length; sum < stopAt && --i>=0; ) {\n+                sum += printers[i].countFieldsToPrint(period);\n+            }\n+            return sum;\n+        }\n+\n+        public int calculatePrintedLength(ReadableTimePeriod period) {\n+            int sum = 0;\n+            TimePeriodPrinter[] printers = iFormatters;\n+            for (int i=printers.length; --i>=0; ) {\n+                sum += printers[i].calculatePrintedLength(period);\n+            }\n+            return sum;\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadableTimePeriod period) {\n+            TimePeriodPrinter[] printers = iFormatters;\n+            int len = printers.length;\n+            for (int i=0; i<len; i++) {\n+                printers[i].printTo(buf, period);\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadableTimePeriod period) throws IOException {\n+            TimePeriodPrinter[] printers = iFormatters;\n+            int len = printers.length;\n+            for (int i=0; i<len; i++) {\n+                printers[i].printTo(out, period);\n+            }\n+        }\n+\n+        public int parseInto(ReadWritableTimePeriod period,\n+                             String periodStr, int position) {\n+            TimePeriodParser[] parsers = iFormatters;\n+\n+            if (parsers == null) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            int len = parsers.length;\n+            for (int i=0; i<len && position >= 0; i++) {\n+                position = parsers[i].parseInto(period, periodStr, position);\n+            }\n+            return position;\n+        }\n+    }\n+\n+    private static final class AlternateSelector extends AbstractTimePeriodFormatter\n+        implements TimePeriodFormatter\n+    {\n+        private final TimePeriodFormatter iPrimaryFormatter;\n+        private final TimePeriodPrinter[] iAlternatePrinters;\n+        private final boolean iFavorFirstFieldForZero;\n+\n+        AlternateSelector(TimePeriodFormatter primaryFormatter,\n+                          List alternatePrinters,\n+                          boolean favorFirstFieldForZero) {\n+            iPrimaryFormatter = primaryFormatter;\n+            iAlternatePrinters = (TimePeriodPrinter[])alternatePrinters.toArray\n+                (new TimePeriodPrinter[alternatePrinters.size()]);\n+            iFavorFirstFieldForZero = favorFirstFieldForZero;\n+        }\n+\n+        public int countFieldsToPrint(ReadableTimePeriod period, int stopAt) {\n+            int count = iPrimaryFormatter.countFieldsToPrint(period, stopAt);\n+            if (count < 1 && stopAt >= 1) {\n+                if (chooseFieldToPrint(period) != null) {\n+                    return 1;\n+                }\n+            }\n+            return count;\n+        }\n+\n+        public int calculatePrintedLength(ReadableTimePeriod period) {\n+            if (iPrimaryFormatter.countFieldsToPrint(period, 1) > 0) {\n+                return iPrimaryFormatter.calculatePrintedLength(period);\n+            }\n+\n+            Object chosenOne = chooseFieldToPrint(period);\n+\n+            int sum = 0;\n+            TimePeriodPrinter[] printers = iAlternatePrinters;\n+            for (int i=printers.length; --i>=0; ) {\n+                TimePeriodPrinter dp = printers[i];\n+                if (dp == chosenOne || !(dp instanceof FieldFormatter)) {\n+                    sum += dp.calculatePrintedLength(period);\n+                }\n+            }\n+            return sum;\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadableTimePeriod period) {\n+            if (iPrimaryFormatter.countFieldsToPrint(period, 1) > 0) {\n+                iPrimaryFormatter.printTo(buf, period);\n+                return;\n+            }\n+\n+            Object chosenOne = chooseFieldToPrint(period);\n+            \n+            TimePeriodPrinter[] printers = iAlternatePrinters;\n+            int len = printers.length;\n+            for (int i=0; i<len; i++) {\n+                TimePeriodPrinter dp = printers[i];\n+                if (dp == chosenOne || !(dp instanceof FieldFormatter)) {\n+                    dp.printTo(buf, period);\n+                }\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadableTimePeriod period) throws IOException {\n+            if (iPrimaryFormatter.countFieldsToPrint(period, 1) > 0) {\n+                iPrimaryFormatter.printTo(out, period);\n+                return;\n+            }\n+            \n+            Object chosenOne = chooseFieldToPrint(period);\n+\n+            TimePeriodPrinter[] printers = iAlternatePrinters;\n+            int len = printers.length;\n+            for (int i=0; i<len; i++) {\n+                TimePeriodPrinter dp = printers[i];\n+                if (dp == chosenOne || !(dp instanceof FieldFormatter)) {\n+                    dp.printTo(out, period);\n+                }\n+            }\n+        }\n+\n+        public int parseInto(ReadWritableTimePeriod period,\n+                             String periodStr, int position) {\n+            return iPrimaryFormatter.parseInto(period, periodStr, position);\n+        }\n+\n+        private FieldFormatter chooseFieldToPrint(ReadableTimePeriod period) {\n+            DurationType type = period.getDurationType();\n+            TimePeriodPrinter[] printers = iAlternatePrinters;\n+            if (iFavorFirstFieldForZero) {\n+                int len = printers.length;\n+                for (int i=0; i<len; i++) {\n+                    TimePeriodPrinter dp = printers[i];\n+                    if (dp instanceof FieldFormatter) {\n+                        FieldFormatter ff = (FieldFormatter) dp;\n+                        if (ff.isSupported(type)) {\n+                            if (ff.getPrintZeroSetting() == PRINT_ZERO_RARELY) {\n+                                ff = new FieldFormatter(ff, PRINT_ZERO_IF_SUPPORTED);\n+                                printers[i] = ff;\n+                            }\n+                            return ff;\n+                        }\n+                    }\n+                }\n+            } else {\n+                for (int i=printers.length; --i>=0; ) {\n+                    TimePeriodPrinter dp = printers[i];\n+                    if (dp instanceof FieldFormatter) {\n+                        FieldFormatter ff = (FieldFormatter) dp;\n+                        if (ff.isSupported(type)) {\n+                            if (ff.getPrintZeroSetting() == PRINT_ZERO_RARELY) {\n+                                ff = new FieldFormatter(ff, PRINT_ZERO_IF_SUPPORTED);\n+                                printers[i] = ff;\n+                            }\n+                            return ff;\n+                        }\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/TimePeriodParser.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import org.joda.time.TimePeriod;\n+import org.joda.time.DurationType;\n+import org.joda.time.MutableTimePeriod;\n+import org.joda.time.ReadWritableTimePeriod;\n+\n+/**\n+ * Defines an interface for parsing textual representations of time periods.\n+ *\n+ * @author Brian S O'Neill\n+ * @see TimePeriodFormatter\n+ * @see TimePeriodFormatterBuilder\n+ * @see TimePeriodFormat\n+ * @since 1.0\n+ */\n+public interface TimePeriodParser {\n+\n+    /**\n+     * Parses a period from the given text, at the given position, saving the\n+     * result into the fields of the given ReadWritableDuration. If the parse\n+     * succeeds, the return value is the new text position. Note that the parse\n+     * may succeed without fully reading the text.\n+     * <p>\n+     * If it fails, the return value is negative, but the period may still be\n+     * modified. To determine the position where the parse failed, apply the\n+     * one's complement operator (~) on the return value.\n+     *\n+     * @param period  a period that will be modified\n+     * @param periodStr  text to parse\n+     * @param position position to start parsing from\n+     * @return new position, if negative, parse failed. Apply complement\n+     * operator (~) to get position of failure\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    int parseInto(ReadWritableTimePeriod period, String periodStr, int position);\n+\n+    /**\n+     * Parses a period from the given text, returning a new TimePeriod.\n+     *\n+     * @param type  defines which fields may be parsed\n+     * @param periodStr  text to parse\n+     * @return parsed value in a Duration object\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    TimePeriod parseTimePeriod(DurationType type, String periodStr);\n+\n+    /**\n+     * Parses a period from the given text, returning a new MutableTimePeriod.\n+     *\n+     * @param type  defines which fields may be parsed\n+     * @param periodStr  text to parse\n+     * @return parsed value in a MutableDuration object\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    MutableTimePeriod parseMutableTimePeriod(DurationType type, String periodStr);\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/TimePeriodPrinter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import org.joda.time.ReadableTimePeriod;\n+\n+/**\n+ * Defines an interface for creating textual representations of time periods.\n+ *\n+ * @author Brian S O'Neill\n+ * @see TimePeriodFormatter\n+ * @see TimePeriodFormatterBuilder\n+ * @see TimePeriodFormat\n+ * @since 1.0\n+ */\n+public interface TimePeriodPrinter {\n+\n+    /**\n+     * Returns the amount of fields from the given duration that this printer\n+     * will print.\n+     * \n+     * @param period  the period to use\n+     * @return amount of fields printed\n+     */\n+    int countFieldsToPrint(ReadableTimePeriod period);\n+\n+    /**\n+     * Returns the amount of fields from the given duration that this printer\n+     * will print.\n+     * \n+     * @param period  the period to use\n+     * @param stopAt stop counting at this value\n+     * @return amount of fields printed\n+     */\n+    int countFieldsToPrint(ReadableTimePeriod period, int stopAt);\n+\n+    /**\n+     * Returns the exact number of characters produced for the given duration.\n+     * \n+     * @param period  the period to use\n+     * @return the estimated length\n+     */\n+    int calculatePrintedLength(ReadableTimePeriod period);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints a ReadableTimePeriod to a StringBuffer.\n+     *\n+     * @param buf  the formatted period is appended to this buffer\n+     * @param period  the period to format\n+     */\n+    void printTo(StringBuffer buf, ReadableTimePeriod period);\n+\n+    /**\n+     * Prints a ReadableTimePeriod to a Writer.\n+     *\n+     * @param out  the formatted period is written out\n+     * @param period  the period to format\n+     */\n+    void printTo(Writer out, ReadableTimePeriod period) throws IOException;\n+\n+    /**\n+     * Prints a ReadableTimePeriod to a new String.\n+     *\n+     * @param period  the period to format\n+     * @return the printed result\n+     */\n+    String print(ReadableTimePeriod period);\n+\n+}\n--- a/JodaTime/src/test/org/joda/time/TestDuration_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestDuration_Basics.java\n \n     //-----------------------------------------------------------------------\n     public void testGetDurationType() {\n-        Duration test = new Duration(0L);\n+        TimePeriod test = new TimePeriod(0L);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n     }\n \n     public void testGetIsTotalMillisBased() {\n-        Duration test = new Duration(123L);\n+        TimePeriod test = new TimePeriod(123L);\n         assertEquals(false, test.isTotalMillisBased());\n-        test = new Duration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         assertEquals(false, test.isTotalMillisBased());\n     }\n \n     public void testGetTotalMillis() {\n-        Duration test = new Duration(123L);\n+        TimePeriod test = new TimePeriod(123L);\n         assertEquals(123L, test.getTotalMillis());\n     }\n \n     public void testGetIsPrecise() {\n-        Duration test = new Duration(123L);\n+        TimePeriod test = new TimePeriod(123L);\n         assertEquals(true, test.isPrecise());\n-        test = new Duration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         assertEquals(false, test.isPrecise());\n     }\n \n     public void testGetMethods() {\n-        Duration test = new Duration(0L);\n+        TimePeriod test = new TimePeriod(0L);\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     public void testEqualsHashCode() {\n-        Duration test1 = new Duration(123L);\n-        Duration test2 = new Duration(123L);\n+        TimePeriod test1 = new TimePeriod(123L);\n+        TimePeriod test2 = new TimePeriod(123L);\n         assertEquals(true, test1.equals(test2));\n         assertEquals(true, test2.equals(test1));\n         assertEquals(true, test1.equals(test1));\n         assertEquals(true, test1.hashCode() == test1.hashCode());\n         assertEquals(true, test2.hashCode() == test2.hashCode());\n         \n-        Duration test3 = new Duration(321L);\n+        TimePeriod test3 = new TimePeriod(321L);\n         assertEquals(false, test1.equals(test3));\n         assertEquals(false, test2.equals(test3));\n         assertEquals(false, test3.equals(test1));\n         \n         assertEquals(false, test1.equals(\"Hello\"));\n         assertEquals(true, test1.equals(new MockDuration(123L)));\n-        assertEquals(false, test1.equals(new Duration(123L, DurationType.getDayHourType())));\n-    }\n-    \n-    class MockDuration extends AbstractDuration {\n+        assertEquals(false, test1.equals(new TimePeriod(123L, DurationType.getDayHourType())));\n+    }\n+    \n+    class MockDuration extends AbstractTimePeriod {\n         public MockDuration(long value) {\n             super(value, null, false);\n         }\n     }\n \n     public void testCompareTo() {\n-        Duration test1 = new Duration(123L);\n-        Duration test1a = new Duration(123L);\n+        TimePeriod test1 = new TimePeriod(123L);\n+        TimePeriod test1a = new TimePeriod(123L);\n         assertEquals(0, test1.compareTo(test1a));\n         assertEquals(0, test1a.compareTo(test1));\n         assertEquals(0, test1.compareTo(test1));\n         assertEquals(0, test1a.compareTo(test1a));\n         \n-        Duration test2 = new Duration(321L);\n+        TimePeriod test2 = new TimePeriod(321L);\n         assertEquals(-1, test1.compareTo(test2));\n         assertEquals(+1, test2.compareTo(test1));\n         \n-        Duration test3 = new Duration(321L, DurationType.getAllType());\n+        TimePeriod test3 = new TimePeriod(321L, DurationType.getAllType());\n         assertEquals(-1, test1.compareTo(test3));\n         assertEquals(+1, test3.compareTo(test1));\n         assertEquals(0, test3.compareTo(test2));\n             fail();\n         } catch (ClassCastException ex) {}\n         try {\n-            test1.compareTo(new Duration(1, 2, 3, 4, 5, 6, 7, 8));\n+            test1.compareTo(new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8));\n             fail();\n         } catch (IllegalStateException ex) {}\n     }\n \n     public void testIsEqual() {\n-        Duration test1 = new Duration(123L);\n-        Duration test1a = new Duration(123L);\n+        TimePeriod test1 = new TimePeriod(123L);\n+        TimePeriod test1a = new TimePeriod(123L);\n         assertEquals(true, test1.isEqual(test1a));\n         assertEquals(true, test1a.isEqual(test1));\n         assertEquals(true, test1.isEqual(test1));\n         assertEquals(true, test1a.isEqual(test1a));\n         \n-        Duration test2 = new Duration(321L);\n+        TimePeriod test2 = new TimePeriod(321L);\n         assertEquals(false, test1.isEqual(test2));\n         assertEquals(false, test2.isEqual(test1));\n         \n-        Duration test3 = new Duration(321L, DurationType.getAllType());\n+        TimePeriod test3 = new TimePeriod(321L, DurationType.getAllType());\n         assertEquals(false, test1.isEqual(test3));\n         assertEquals(false, test3.isEqual(test1));\n         assertEquals(true, test3.isEqual(test2));\n         assertEquals(false, test2.isEqual(new MockDuration(123L)));\n         assertEquals(true, test1.isEqual(new MockDuration(123L)));\n         assertEquals(false, test1.isEqual(null));\n-        assertEquals(true, new Duration(0L).isEqual(null));\n+        assertEquals(true, new TimePeriod(0L).isEqual(null));\n     }\n     \n     public void testIsBefore() {\n-        Duration test1 = new Duration(123L);\n-        Duration test1a = new Duration(123L);\n+        TimePeriod test1 = new TimePeriod(123L);\n+        TimePeriod test1a = new TimePeriod(123L);\n         assertEquals(false, test1.isShorterThan(test1a));\n         assertEquals(false, test1a.isShorterThan(test1));\n         assertEquals(false, test1.isShorterThan(test1));\n         assertEquals(false, test1a.isShorterThan(test1a));\n         \n-        Duration test2 = new Duration(321L);\n+        TimePeriod test2 = new TimePeriod(321L);\n         assertEquals(true, test1.isShorterThan(test2));\n         assertEquals(false, test2.isShorterThan(test1));\n         \n-        Duration test3 = new Duration(321L, DurationType.getAllType());\n+        TimePeriod test3 = new TimePeriod(321L, DurationType.getAllType());\n         assertEquals(true, test1.isShorterThan(test3));\n         assertEquals(false, test3.isShorterThan(test1));\n         assertEquals(false, test3.isShorterThan(test2));\n         assertEquals(false, test2.isShorterThan(new MockDuration(123L)));\n         assertEquals(false, test1.isShorterThan(new MockDuration(123L)));\n         assertEquals(false, test1.isShorterThan(null));\n-        assertEquals(false, new Duration(0L).isShorterThan(null));\n+        assertEquals(false, new TimePeriod(0L).isShorterThan(null));\n     }\n     \n     public void testIsAfter() {\n-        Duration test1 = new Duration(123L);\n-        Duration test1a = new Duration(123L);\n+        TimePeriod test1 = new TimePeriod(123L);\n+        TimePeriod test1a = new TimePeriod(123L);\n         assertEquals(false, test1.isLongerThan(test1a));\n         assertEquals(false, test1a.isLongerThan(test1));\n         assertEquals(false, test1.isLongerThan(test1));\n         assertEquals(false, test1a.isLongerThan(test1a));\n         \n-        Duration test2 = new Duration(321L);\n+        TimePeriod test2 = new TimePeriod(321L);\n         assertEquals(false, test1.isLongerThan(test2));\n         assertEquals(true, test2.isLongerThan(test1));\n         \n-        Duration test3 = new Duration(321L, DurationType.getAllType());\n+        TimePeriod test3 = new TimePeriod(321L, DurationType.getAllType());\n         assertEquals(false, test1.isLongerThan(test3));\n         assertEquals(true, test3.isLongerThan(test1));\n         assertEquals(false, test3.isLongerThan(test2));\n         assertEquals(true, test2.isLongerThan(new MockDuration(123L)));\n         assertEquals(false, test1.isLongerThan(new MockDuration(123L)));\n         assertEquals(true, test1.isLongerThan(null));\n-        assertEquals(false, new Duration(0L).isLongerThan(null));\n+        assertEquals(false, new TimePeriod(0L).isLongerThan(null));\n     }\n     \n     //-----------------------------------------------------------------------\n     public void testSerialization() throws Exception {\n-        Duration test = new Duration(123L);\n+        TimePeriod test = new TimePeriod(123L);\n         \n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         ObjectOutputStream oos = new ObjectOutputStream(baos);\n         \n         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n         ObjectInputStream ois = new ObjectInputStream(bais);\n-        Duration result = (Duration) ois.readObject();\n+        TimePeriod result = (TimePeriod) ois.readObject();\n         ois.close();\n         \n         assertEquals(test, result);\n         expected = ISOChronology.getInstance().seconds().add(expected, 7);\n         expected = ISOChronology.getInstance().millis().add(expected, 8);\n         \n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8);\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         long added = test.addTo(TEST_TIME_NOW, 1);\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8);\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         long added = test.addTo(TEST_TIME_NOW, -2);\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2);\n         assertEquals(expected, added);\n     }\n     \n     public void testAddTo4() {\n         long expected = TEST_TIME_NOW;\n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8);\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         long added = test.addTo(TEST_TIME_NOW, 0);\n         assertEquals(expected, added);\n     }\n     \n     public void testAddTo5() {\n         long expected = TEST_TIME_NOW + 100L;\n-        Duration test = new Duration(100L);\n+        TimePeriod test = new TimePeriod(100L);\n         long added = test.addTo(TEST_TIME_NOW, 1);\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, 7);\n         expected = ISOChronology.getInstance().millis().add(expected, 8);\n         \n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8);\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         long added = test.addTo(TEST_TIME_NOW, 1, ISOChronology.getInstance());\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2, ISOChronology.getInstance());  // local specified so use it\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2, null);  // no chrono specified so drop back to duration (UTC)\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, 7);\n         expected = ISOChronology.getInstance().millis().add(expected, 8);\n         \n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8);\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         Instant added = test.addTo(new Instant(), 1);  // Instant has no time zone, uses duration's zone (local)\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(new Instant(), -2);  // Instant has no time zone, uses duration's zone (UTC)\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(new DateTime(), -2);  // DateTime has local time zone\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(null, -2);  // null has no time zone, uses duration's zone (UTC)\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, 7);\n         expected = ISOChronology.getInstance().millis().add(expected, 8);\n         \n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8);\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         MutableDateTime mdt = new MutableDateTime();\n         test.addInto(mdt, 1);\n         assertEquals(expected, mdt.getMillis());\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n         MutableDateTime mdt = new MutableDateTime();\n         test.addInto(mdt, -2);  // MutableDateTime has a chronology, use it\n         assertEquals(expected, mdt.getMillis());\n     }\n     \n     public void testAddIntoRWI3() {\n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8);\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         try {\n             test.addInto(null, 1);\n             fail();\n     \n     //-----------------------------------------------------------------------\n     public void testToString() {\n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8);\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         assertEquals(\"P1Y2M3W4DT5H6M7.008S\", test.toString());\n         \n-        test = new Duration(0, 0, 0, 0, 0, 0, 0, 0);\n+        test = new TimePeriod(0, 0, 0, 0, 0, 0, 0, 0);\n         assertEquals(\"PT0S\", test.toString());\n         \n-        test = new Duration(12345L);\n+        test = new TimePeriod(12345L);\n         assertEquals(\"PT12.345S\", test.toString());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testToDuration() {\n-        Duration test = new Duration(123L);\n-        Duration result = test.toDuration();\n+        TimePeriod test = new TimePeriod(123L);\n+        TimePeriod result = test.toDuration();\n         assertSame(test, result);\n     }\n \n     public void testToMutableDuration() {\n-        Duration test = new Duration(123L);\n-        MutableDuration result = test.toMutableDuration();\n+        TimePeriod test = new TimePeriod(123L);\n+        MutableTimePeriod result = test.toMutableDuration();\n         assertEquals(test.getDurationType(), result.getDurationType());\n         assertEquals(test.isPrecise(), result.isPrecise());\n         assertEquals(test.getTotalMillis(), result.getTotalMillis());\n \n     //-----------------------------------------------------------------------\n     public void testConstant() {\n-        assertEquals(0L, Duration.ZERO.getTotalMillis());\n-        assertEquals(DurationType.getAllType(), Duration.ZERO.getDurationType());\n+        assertEquals(0L, TimePeriod.ZERO.getTotalMillis());\n+        assertEquals(DurationType.getAllType(), TimePeriod.ZERO.getDurationType());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testWithDurationTypeUsingTotalMillis1() {\n-        Duration test = new Duration(123L);\n-        Duration result = test.withDurationTypeUsingTotalMillis(DurationType.getAllType());\n+        TimePeriod test = new TimePeriod(123L);\n+        TimePeriod result = test.withDurationTypeUsingTotalMillis(DurationType.getAllType());\n         assertSame(test, result);\n     }\n \n     public void testWithDurationTypeUsingTotalMillis2() {\n-        Duration test = new Duration(3123L);\n-        Duration result = test.withDurationTypeUsingTotalMillis(DurationType.getDayHourType());\n+        TimePeriod test = new TimePeriod(3123L);\n+        TimePeriod result = test.withDurationTypeUsingTotalMillis(DurationType.getDayHourType());\n         assertEquals(3, result.getSeconds());\n         assertEquals(123, result.getMillis());\n         assertEquals(3123L, result.getTotalMillis());\n     }\n \n     public void testWithDurationTypeUsingTotalMillis3() {\n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType());\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType());\n         try {\n             test.withDurationTypeUsingTotalMillis(DurationType.getDayHourType());\n             fail();\n     }\n \n     public void testWithDurationTypeUsingTotalMillis4() {\n-        Duration test = new Duration(3123L);\n-        Duration result = test.withDurationTypeUsingTotalMillis(null);\n+        TimePeriod test = new TimePeriod(3123L);\n+        TimePeriod result = test.withDurationTypeUsingTotalMillis(null);\n         assertEquals(3, result.getSeconds());\n         assertEquals(123, result.getMillis());\n         assertEquals(3123L, result.getTotalMillis());\n \n     //-----------------------------------------------------------------------\n     public void testWithDurationTypeUsingFields1() {\n-        Duration test = new Duration(123L);\n-        Duration result = test.withDurationTypeUsingFields(DurationType.getAllType());\n+        TimePeriod test = new TimePeriod(123L);\n+        TimePeriod result = test.withDurationTypeUsingFields(DurationType.getAllType());\n         assertSame(test, result);\n     }\n \n     public void testWithDurationTypeUsingFields2() {\n-        Duration test = new Duration(3123L);\n-        Duration result = test.withDurationTypeUsingFields(DurationType.getDayHourType());\n+        TimePeriod test = new TimePeriod(3123L);\n+        TimePeriod result = test.withDurationTypeUsingFields(DurationType.getDayHourType());\n         assertEquals(3, result.getSeconds());\n         assertEquals(123, result.getMillis());\n         assertEquals(3123L, result.getTotalMillis());\n     }\n \n     public void testWithDurationTypeUsingFields3() {\n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType());\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType());\n         try {\n             test.withDurationTypeUsingFields(DurationType.getDayHourType());\n             fail();\n     }\n \n     public void testWithDurationTypeUsingFields4() {\n-        Duration test = new Duration(3123L);\n-        Duration result = test.withDurationTypeUsingFields(null);\n+        TimePeriod test = new TimePeriod(3123L);\n+        TimePeriod result = test.withDurationTypeUsingFields(null);\n         assertEquals(3, result.getSeconds());\n         assertEquals(123, result.getMillis());\n         assertEquals(3123L, result.getTotalMillis());\n     }\n \n     public void testWithDurationTypeUsingFields5() {\n-        Duration test = new Duration(1, 2, 0, 4, 5, 6, 7, 8, DurationType.getAllType());\n-        Duration result = test.withDurationTypeUsingFields(DurationType.getYearMonthType());\n+        TimePeriod test = new TimePeriod(1, 2, 0, 4, 5, 6, 7, 8, DurationType.getAllType());\n+        TimePeriod result = test.withDurationTypeUsingFields(DurationType.getYearMonthType());\n         assertEquals(DurationType.getYearMonthType(), result.getDurationType());\n         assertEquals(1, result.getYears());\n         assertEquals(2, result.getMonths());\n \n     //-----------------------------------------------------------------------\n     public void testWithFieldsNormalized1() {\n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 61, 8, DurationType.getPreciseAllType());\n-        Duration result = test.withFieldsNormalized();\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 61, 8, DurationType.getPreciseAllType());\n+        TimePeriod result = test.withFieldsNormalized();\n         assertEquals(1, result.getYears());\n         assertEquals(2, result.getMonths());\n         assertEquals(3, result.getWeeks());\n     }\n \n     public void testWithFieldsNormalized2() {\n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 61, 8, DurationType.getAllType());\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 61, 8, DurationType.getAllType());\n         try {\n             test.withFieldsNormalized();\n             fail();\n         assertEquals(111L, test.getTotalMillis());\n     }\n     \n-    static class MockChangeDuration extends Duration {\n+    static class MockChangeDuration extends TimePeriod {\n         MockChangeDuration(long duration) {\n             super(duration);\n         }\n--- a/JodaTime/src/test/org/joda/time/TestDuration_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestDuration_Constructors.java\n      * Test constructor ()\n      */\n     public void testZERO() throws Throwable {\n-        Duration test = Duration.ZERO;\n+        TimePeriod test = TimePeriod.ZERO;\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        Duration test = new Duration(length);\n+        TimePeriod test = new TimePeriod(length);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        Duration test = new Duration(length, null);\n+        TimePeriod test = new TimePeriod(length, null);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        Duration test = new Duration(length, DurationType.getMillisType());\n+        TimePeriod test = new TimePeriod(length, DurationType.getMillisType());\n         assertEquals(DurationType.getMillisType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        Duration test = new Duration(length, DurationType.getDayHourType());\n+        TimePeriod test = new TimePeriod(length, DurationType.getDayHourType());\n         assertEquals(DurationType.getDayHourType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        Duration test = new Duration(length, DurationType.getAllType().withMillisRemoved());\n+        TimePeriod test = new TimePeriod(length, DurationType.getAllType().withMillisRemoved());\n         assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n      * Test constructor (4ints)\n      */\n     public void testConstructor_4int1() throws Throwable {\n-        Duration test = new Duration(5, 6, 7, 8);\n+        TimePeriod test = new TimePeriod(5, 6, 7, 8);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n      * Test constructor (8ints)\n      */\n     public void testConstructor_8int1() throws Throwable {\n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8);\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n      * Test constructor (8ints)\n      */\n     public void testConstructor_8int__DurationType1() throws Throwable {\n-        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8, null);\n+        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, null);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n     }\n \n     public void testConstructor_8int__DurationType2() throws Throwable {\n-        Duration test = new Duration(0, 0, 0, 0, 5, 6, 7, 8, DurationType.getDayHourType());\n+        TimePeriod test = new TimePeriod(0, 0, 0, 0, 5, 6, 7, 8, DurationType.getDayHourType());\n         assertEquals(DurationType.getDayHourType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n \n     public void testConstructor_8int__DurationType3() throws Throwable {\n         try {\n-            new Duration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getDayHourType());\n+            new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getDayHourType());\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n     public void testConstructor_long_long1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        Duration test = new Duration(dt1.getMillis(), dt2.getMillis());\n+        TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis());\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_long_long2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        Duration test = new Duration(dt1.getMillis(), dt2.getMillis());\n+        TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis());\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_long_long_DurationType1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        Duration test = new Duration(dt1.getMillis(), dt2.getMillis(), null);\n+        TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis(), null);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_long_long_DurationType2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);\n-        Duration test = new Duration(dt1.getMillis(), dt2.getMillis(), DurationType.getDayHourType());\n+        TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis(), DurationType.getDayHourType());\n         assertEquals(DurationType.getDayHourType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testConstructor_long_long_DurationType3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        Duration test = new Duration(dt1.getMillis(), dt2.getMillis(), DurationType.getAllType().withMillisRemoved());\n+        TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis(), DurationType.getAllType().withMillisRemoved());\n         assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        Duration test = new Duration(dt1, dt2);\n+        TimePeriod test = new TimePeriod(dt1, dt2);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        Duration test = new Duration(dt1, dt2);\n+        TimePeriod test = new TimePeriod(dt1, dt2);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI3() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        Duration test = new Duration(dt1, dt2);\n+        TimePeriod test = new TimePeriod(dt1, dt2);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(3, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI4() throws Throwable {\n         DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n-        Duration test = new Duration(dt1, dt2);\n+        TimePeriod test = new TimePeriod(dt1, dt2);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(-3, test.getYears());\n         assertEquals(-1, test.getMonths());\n     public void testConstructor_RI_RI5() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n-        Duration test = new Duration(dt1, dt2);\n+        TimePeriod test = new TimePeriod(dt1, dt2);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testConstructor_RI_RI_DurationType1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        Duration test = new Duration(dt1, dt2, null);\n+        TimePeriod test = new TimePeriod(dt1, dt2, null);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI_DurationType2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);\n-        Duration test = new Duration(dt1, dt2, DurationType.getDayHourType());\n+        TimePeriod test = new TimePeriod(dt1, dt2, DurationType.getDayHourType());\n         assertEquals(DurationType.getDayHourType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testConstructor_RI_RI_DurationType3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        Duration test = new Duration(dt1, dt2, DurationType.getAllType().withMillisRemoved());\n+        TimePeriod test = new TimePeriod(dt1, dt2, DurationType.getAllType().withMillisRemoved());\n         assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI_DurationType4() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        Duration test = new Duration(dt1, dt2, DurationType.getAllType());\n+        TimePeriod test = new TimePeriod(dt1, dt2, DurationType.getAllType());\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(3, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI_DurationType5() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n-        Duration test = new Duration(dt1, dt2, DurationType.getAllType());\n+        TimePeriod test = new TimePeriod(dt1, dt2, DurationType.getAllType());\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n      * Test constructor (Object)\n      */\n     public void testConstructor_Object1() throws Throwable {\n-        Duration test = new Duration(\"P1Y2M3D\");\n+        TimePeriod test = new TimePeriod(\"P1Y2M3D\");\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n     }\n \n     public void testConstructor_Object2() throws Throwable {\n-        Duration test = new Duration((Object) null);\n+        TimePeriod test = new TimePeriod((Object) null);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testConstructor_Object3() throws Throwable {\n-        Duration test = new Duration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()));\n+        TimePeriod test = new TimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()));\n         assertEquals(DurationType.getDayHourType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testConstructor_Object4() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        Duration base = new Duration(dt1, dt2);  // AllType and precise\n-        Duration test = new Duration(base);\n+        TimePeriod base = new TimePeriod(dt1, dt2);  // AllType and precise\n+        TimePeriod test = new TimePeriod(base);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n      * Test constructor (Object)\n      */\n     public void testConstructor_Object_DurationType1() throws Throwable {\n-        Duration test = new Duration(\"P1Y2M3D\", DurationType.getYearMonthType());\n+        TimePeriod test = new TimePeriod(\"P1Y2M3D\", DurationType.getYearMonthType());\n         assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n     }\n \n     public void testConstructor_Object_DurationType2() throws Throwable {\n-        Duration test = new Duration((Object) null, DurationType.getYearMonthType());\n+        TimePeriod test = new TimePeriod((Object) null, DurationType.getYearMonthType());\n         assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testConstructor_Object_DurationType3() throws Throwable {\n-        Duration test = new Duration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), DurationType.getYearMonthType());\n+        TimePeriod test = new TimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), DurationType.getYearMonthType());\n         assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testConstructor_Object_DurationType4() throws Throwable {\n-        Duration test = new Duration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), null);\n+        TimePeriod test = new TimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), null);\n         assertEquals(DurationType.getDayHourType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n--- a/JodaTime/src/test/org/joda/time/TestInterval_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestInterval_Constructors.java\n     //-----------------------------------------------------------------------\n     public void testConstructor_RI_RD1() throws Throwable {\n         DateTime dt = new DateTime(TEST_TIME_NOW);\n-        Duration dur = new Duration(0, 6, 0, 0, 1, 0, 0, 0);\n+        TimePeriod dur = new TimePeriod(0, 6, 0, 0, 1, 0, 0, 0);\n         long result = TEST_TIME_NOW;\n         result = ISOChronology.getInstance().monthOfYear().add(result, 6);\n         result = ISOChronology.getInstance().hourOfDay().add(result, 1);\n \n     public void testConstructor_RI_RD2() throws Throwable {\n         Instant dt = new Instant(new DateTime(TEST_TIME_NOW));\n-        Duration dur = new Duration(0, 6, 0, 0, 1, 0, 0, 0);\n+        TimePeriod dur = new TimePeriod(0, 6, 0, 0, 1, 0, 0, 0);\n         long result = TEST_TIME_NOW;\n         result = ISOChronology.getInstanceUTC().monthOfYear().add(result, 6);\n         result = ISOChronology.getInstanceUTC().hourOfDay().add(result, 1);\n \n     public void testConstructor_RI_RD3() throws Throwable {\n         DateTime dt = new DateTime(TEST_TIME_NOW);\n-        Duration dur = new Duration(1 * DateTimeConstants.MILLIS_PER_HOUR + 23L);\n+        TimePeriod dur = new TimePeriod(1 * DateTimeConstants.MILLIS_PER_HOUR + 23L);\n         long result = TEST_TIME_NOW;\n         result = ISOChronology.getInstance().hourOfDay().add(result, 1);\n         result = ISOChronology.getInstance().millisOfSecond().add(result, 23);\n     }\n \n     public void testConstructor_RI_RD6() throws Throwable {\n-        Duration dur = new Duration(0, 6, 0, 0, 1, 0, 0, 0);\n+        TimePeriod dur = new TimePeriod(0, 6, 0, 0, 1, 0, 0, 0);\n         long result = TEST_TIME_NOW;\n         result = ISOChronology.getInstanceUTC().monthOfYear().add(result, 6);\n         result = ISOChronology.getInstanceUTC().hourOfDay().add(result, 1);\n--- a/JodaTime/src/test/org/joda/time/TestMutableDateTime_Adds.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableDateTime_Adds.java\n     }\n \n     public void testAdd_Object3() {\n-        Duration d = new Duration(1, 1, 0, 1, 1, 1, 1, 1);\n+        TimePeriod d = new TimePeriod(1, 1, 0, 1, 1, 1, 1, 1);\n         MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n         assertEquals(\"2002-06-09T05:06:07.008+01:00\", test.toString());\n         test.add(d);\n     }\n \n     public void testAdd_Object_int3() {\n-        Duration d = new Duration(1, 1, 0, 1, 1, 1, 1, 1);\n+        TimePeriod d = new TimePeriod(1, 1, 0, 1, 1, 1, 1, 1);\n         MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n         assertEquals(\"2002-06-09T05:06:07.008+01:00\", test.toString());\n         test.add(d, -2);\n--- a/JodaTime/src/test/org/joda/time/TestMutableDuration_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableDuration_Basics.java\n \n     //-----------------------------------------------------------------------\n     public void testGetDurationType() {\n-        MutableDuration test = new MutableDuration();\n+        MutableTimePeriod test = new MutableTimePeriod();\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n     }\n \n     public void testGetIsTotalMillisBased() {\n-        MutableDuration test = new MutableDuration(123L);\n+        MutableTimePeriod test = new MutableTimePeriod(123L);\n         assertEquals(false, test.isTotalMillisBased());\n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         assertEquals(false, test.isTotalMillisBased());\n     }\n \n     public void testGetTotalMillis() {\n-        MutableDuration test = new MutableDuration(123L);\n+        MutableTimePeriod test = new MutableTimePeriod(123L);\n         assertEquals(123L, test.getTotalMillis());\n     }\n \n     public void testGetIsPrecise() {\n-        MutableDuration test = new MutableDuration(123L);\n+        MutableTimePeriod test = new MutableTimePeriod(123L);\n         assertEquals(true, test.isPrecise());\n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         assertEquals(false, test.isPrecise());\n     }\n \n     public void testGetMethods() {\n-        MutableDuration test = new MutableDuration();\n+        MutableTimePeriod test = new MutableTimePeriod();\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getDays());\n     }\n \n     public void testEqualsHashCode() {\n-        MutableDuration test1 = new MutableDuration(123L);\n-        MutableDuration test2 = new MutableDuration(123L);\n+        MutableTimePeriod test1 = new MutableTimePeriod(123L);\n+        MutableTimePeriod test2 = new MutableTimePeriod(123L);\n         assertEquals(true, test1.equals(test2));\n         assertEquals(true, test2.equals(test1));\n         assertEquals(true, test1.equals(test1));\n         assertEquals(true, test1.hashCode() == test1.hashCode());\n         assertEquals(true, test2.hashCode() == test2.hashCode());\n         \n-        MutableDuration test3 = new MutableDuration(321L);\n+        MutableTimePeriod test3 = new MutableTimePeriod(321L);\n         assertEquals(false, test1.equals(test3));\n         assertEquals(false, test2.equals(test3));\n         assertEquals(false, test3.equals(test1));\n         \n         assertEquals(false, test1.equals(\"Hello\"));\n         assertEquals(true, test1.equals(new MockMutableDuration(123L)));\n-        assertEquals(false, test1.equals(new Duration(123L, DurationType.getDayHourType())));\n-    }\n-    \n-    class MockMutableDuration extends AbstractDuration {\n+        assertEquals(false, test1.equals(new TimePeriod(123L, DurationType.getDayHourType())));\n+    }\n+    \n+    class MockMutableDuration extends AbstractTimePeriod {\n         public MockMutableDuration(long value) {\n             super(value, null, false);\n         }\n     }\n \n     public void testCompareTo() {\n-        MutableDuration test1 = new MutableDuration(123L);\n-        MutableDuration test1a = new MutableDuration(123L);\n+        MutableTimePeriod test1 = new MutableTimePeriod(123L);\n+        MutableTimePeriod test1a = new MutableTimePeriod(123L);\n         assertEquals(0, test1.compareTo(test1a));\n         assertEquals(0, test1a.compareTo(test1));\n         assertEquals(0, test1.compareTo(test1));\n         assertEquals(0, test1a.compareTo(test1a));\n         \n-        MutableDuration test2 = new MutableDuration(321L);\n+        MutableTimePeriod test2 = new MutableTimePeriod(321L);\n         assertEquals(-1, test1.compareTo(test2));\n         assertEquals(+1, test2.compareTo(test1));\n         \n-        MutableDuration test3 = new MutableDuration(321L, DurationType.getAllType());\n+        MutableTimePeriod test3 = new MutableTimePeriod(321L, DurationType.getAllType());\n         assertEquals(-1, test1.compareTo(test3));\n         assertEquals(+1, test3.compareTo(test1));\n         assertEquals(0, test3.compareTo(test2));\n             fail();\n         } catch (ClassCastException ex) {}\n         try {\n-            test1.compareTo(new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8));\n+            test1.compareTo(new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8));\n             fail();\n         } catch (IllegalStateException ex) {}\n     }\n \n     public void testIsEqual() {\n-        MutableDuration test1 = new MutableDuration(123L);\n-        MutableDuration test1a = new MutableDuration(123L);\n+        MutableTimePeriod test1 = new MutableTimePeriod(123L);\n+        MutableTimePeriod test1a = new MutableTimePeriod(123L);\n         assertEquals(true, test1.isEqual(test1a));\n         assertEquals(true, test1a.isEqual(test1));\n         assertEquals(true, test1.isEqual(test1));\n         assertEquals(true, test1a.isEqual(test1a));\n         \n-        MutableDuration test2 = new MutableDuration(321L);\n+        MutableTimePeriod test2 = new MutableTimePeriod(321L);\n         assertEquals(false, test1.isEqual(test2));\n         assertEquals(false, test2.isEqual(test1));\n         \n-        MutableDuration test3 = new MutableDuration(321L, DurationType.getAllType());\n+        MutableTimePeriod test3 = new MutableTimePeriod(321L, DurationType.getAllType());\n         assertEquals(false, test1.isEqual(test3));\n         assertEquals(false, test3.isEqual(test1));\n         assertEquals(true, test3.isEqual(test2));\n         assertEquals(false, test2.isEqual(new MockMutableDuration(123L)));\n         assertEquals(true, test1.isEqual(new MockMutableDuration(123L)));\n         assertEquals(false, test1.isEqual(null));\n-        assertEquals(true, new MutableDuration(0L).isEqual(null));\n+        assertEquals(true, new MutableTimePeriod(0L).isEqual(null));\n     }\n     \n     public void testIsBefore() {\n-        MutableDuration test1 = new MutableDuration(123L);\n-        MutableDuration test1a = new MutableDuration(123L);\n+        MutableTimePeriod test1 = new MutableTimePeriod(123L);\n+        MutableTimePeriod test1a = new MutableTimePeriod(123L);\n         assertEquals(false, test1.isShorterThan(test1a));\n         assertEquals(false, test1a.isShorterThan(test1));\n         assertEquals(false, test1.isShorterThan(test1));\n         assertEquals(false, test1a.isShorterThan(test1a));\n         \n-        MutableDuration test2 = new MutableDuration(321L);\n+        MutableTimePeriod test2 = new MutableTimePeriod(321L);\n         assertEquals(true, test1.isShorterThan(test2));\n         assertEquals(false, test2.isShorterThan(test1));\n         \n-        MutableDuration test3 = new MutableDuration(321L, DurationType.getAllType());\n+        MutableTimePeriod test3 = new MutableTimePeriod(321L, DurationType.getAllType());\n         assertEquals(true, test1.isShorterThan(test3));\n         assertEquals(false, test3.isShorterThan(test1));\n         assertEquals(false, test3.isShorterThan(test2));\n         assertEquals(false, test2.isShorterThan(new MockMutableDuration(123L)));\n         assertEquals(false, test1.isShorterThan(new MockMutableDuration(123L)));\n         assertEquals(false, test1.isShorterThan(null));\n-        assertEquals(false, new MutableDuration(0L).isShorterThan(null));\n+        assertEquals(false, new MutableTimePeriod(0L).isShorterThan(null));\n     }\n     \n     public void testIsAfter() {\n-        MutableDuration test1 = new MutableDuration(123L);\n-        MutableDuration test1a = new MutableDuration(123L);\n+        MutableTimePeriod test1 = new MutableTimePeriod(123L);\n+        MutableTimePeriod test1a = new MutableTimePeriod(123L);\n         assertEquals(false, test1.isLongerThan(test1a));\n         assertEquals(false, test1a.isLongerThan(test1));\n         assertEquals(false, test1.isLongerThan(test1));\n         assertEquals(false, test1a.isLongerThan(test1a));\n         \n-        MutableDuration test2 = new MutableDuration(321L);\n+        MutableTimePeriod test2 = new MutableTimePeriod(321L);\n         assertEquals(false, test1.isLongerThan(test2));\n         assertEquals(true, test2.isLongerThan(test1));\n         \n-        MutableDuration test3 = new MutableDuration(321L, DurationType.getAllType());\n+        MutableTimePeriod test3 = new MutableTimePeriod(321L, DurationType.getAllType());\n         assertEquals(false, test1.isLongerThan(test3));\n         assertEquals(true, test3.isLongerThan(test1));\n         assertEquals(false, test3.isLongerThan(test2));\n         assertEquals(true, test2.isLongerThan(new MockMutableDuration(123L)));\n         assertEquals(false, test1.isLongerThan(new MockMutableDuration(123L)));\n         assertEquals(true, test1.isLongerThan(null));\n-        assertEquals(false, new MutableDuration(0L).isLongerThan(null));\n+        assertEquals(false, new MutableTimePeriod(0L).isLongerThan(null));\n     }\n     \n     //-----------------------------------------------------------------------\n     public void testSerialization() throws Exception {\n-        MutableDuration test = new MutableDuration(123L);\n+        MutableTimePeriod test = new MutableTimePeriod(123L);\n         \n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         ObjectOutputStream oos = new ObjectOutputStream(baos);\n         \n         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n         ObjectInputStream ois = new ObjectInputStream(bais);\n-        MutableDuration result = (MutableDuration) ois.readObject();\n+        MutableTimePeriod result = (MutableTimePeriod) ois.readObject();\n         ois.close();\n         \n         assertEquals(test, result);\n         expected = ISOChronology.getInstance().seconds().add(expected, 7);\n         expected = ISOChronology.getInstance().millis().add(expected, 8);\n         \n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         long added = test.addTo(TEST_TIME_NOW, 1);\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         long added = test.addTo(TEST_TIME_NOW, -2);\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2);\n         assertEquals(expected, added);\n     }\n     \n     public void testAddTo4() {\n         long expected = TEST_TIME_NOW;\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         long added = test.addTo(TEST_TIME_NOW, 0);\n         assertEquals(expected, added);\n     }\n     \n     public void testAddTo5() {\n         long expected = TEST_TIME_NOW + 100L;\n-        MutableDuration test = new MutableDuration(100L);\n+        MutableTimePeriod test = new MutableTimePeriod(100L);\n         long added = test.addTo(TEST_TIME_NOW, 1);\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, 7);\n         expected = ISOChronology.getInstance().millis().add(expected, 8);\n         \n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         long added = test.addTo(TEST_TIME_NOW, 1, ISOChronology.getInstance());\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2, ISOChronology.getInstance());  // local specified so use it\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2, null);  // no chrono specified so drop back to duration (UTC)\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, 7);\n         expected = ISOChronology.getInstance().millis().add(expected, 8);\n         \n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         Instant added = test.addTo(new Instant(), 1);  // Instant has no time zone, uses duration's zone (local)\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(new Instant(), -2);  // Instant has no time zone, uses duration's zone (UTC)\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(new DateTime(), -2);  // DateTime has local time zone\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(null, -2);  // null has no time zone, uses duration's zone (UTC)\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, 7);\n         expected = ISOChronology.getInstance().millis().add(expected, 8);\n         \n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         MutableDateTime mdt = new MutableDateTime();\n         test.addInto(mdt, 1);\n         assertEquals(expected, mdt.getMillis());\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType(ISOChronology.getInstanceUTC()));\n         MutableDateTime mdt = new MutableDateTime();\n         test.addInto(mdt, -2);  // MutableDateTime has a chronology, use it\n         assertEquals(expected, mdt.getMillis());\n     }\n     \n     public void testAddIntoRWI3() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         try {\n             test.addInto(null, 1);\n             fail();\n     \n     //-----------------------------------------------------------------------\n     public void testToString() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         assertEquals(\"P1Y2M3W4DT5H6M7.008S\", test.toString());\n         \n-        test = new MutableDuration(0, 0, 0, 0, 0, 0, 0, 0);\n+        test = new MutableTimePeriod(0, 0, 0, 0, 0, 0, 0, 0);\n         assertEquals(\"PT0S\", test.toString());\n         \n-        test = new MutableDuration(12345L);\n+        test = new MutableTimePeriod(12345L);\n         assertEquals(\"PT12.345S\", test.toString());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testToDuration() {\n-        MutableDuration test = new MutableDuration(123L);\n-        Duration result = test.toDuration();\n+        MutableTimePeriod test = new MutableTimePeriod(123L);\n+        TimePeriod result = test.toDuration();\n         assertEquals(test.getDurationType(), result.getDurationType());\n         assertEquals(test.isPrecise(), result.isPrecise());\n         assertEquals(test.getTotalMillis(), result.getTotalMillis());\n     }\n \n     public void testToMutableDuration() {\n-        MutableDuration test = new MutableDuration(123L);\n-        MutableDuration result = test.toMutableDuration();\n+        MutableTimePeriod test = new MutableTimePeriod(123L);\n+        MutableTimePeriod result = test.toMutableDuration();\n         assertEquals(test.getDurationType(), result.getDurationType());\n         assertEquals(test.isPrecise(), result.isPrecise());\n         assertEquals(test.getTotalMillis(), result.getTotalMillis());\n \n     //-----------------------------------------------------------------------\n     public void testCopy() {\n-        MutableDuration test = new MutableDuration(123L);\n-        MutableDuration copy = test.copy();\n+        MutableTimePeriod test = new MutableTimePeriod(123L);\n+        MutableTimePeriod copy = test.copy();\n         assertEquals(test.getDurationType(), copy.getDurationType());\n         assertEquals(test.isPrecise(), copy.isPrecise());\n         assertEquals(test.getTotalMillis(), copy.getTotalMillis());\n \n     //-----------------------------------------------------------------------\n     public void testClone() {\n-        MutableDuration test = new MutableDuration(123L);\n-        MutableDuration copy = (MutableDuration) test.clone();\n+        MutableTimePeriod test = new MutableTimePeriod(123L);\n+        MutableTimePeriod copy = (MutableTimePeriod) test.clone();\n         assertEquals(test.getDurationType(), copy.getDurationType());\n         assertEquals(test.isPrecise(), copy.isPrecise());\n         assertEquals(test.getTotalMillis(), copy.getTotalMillis());\n--- a/JodaTime/src/test/org/joda/time/TestMutableDuration_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableDuration_Constructors.java\n      * Test constructor ()\n      */\n     public void testConstructor1() throws Throwable {\n-        MutableDuration test = new MutableDuration();\n+        MutableTimePeriod test = new MutableTimePeriod();\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n      * Test constructor (DurationType)\n      */\n     public void testConstructor_DurationType1() throws Throwable {\n-        MutableDuration test = new MutableDuration(DurationType.getYearMonthType());\n+        MutableTimePeriod test = new MutableTimePeriod(DurationType.getYearMonthType());\n         assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testConstructor_DurationType2() throws Throwable {\n-        MutableDuration test = new MutableDuration((DurationType) null);\n+        MutableTimePeriod test = new MutableTimePeriod((DurationType) null);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n \n     //-----------------------------------------------------------------------\n     public void testConstructor_DurationType_boolean1() throws Throwable {\n-        MutableDuration test = new MutableDuration(null, true);\n+        MutableTimePeriod test = new MutableTimePeriod(null, true);\n         assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutableDuration test = new MutableDuration(null, false);\n+        MutableTimePeriod test = new MutableTimePeriod(null, false);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n \n     public void testConstructor_DurationType_boolean3() throws Throwable {\n         try {\n-            new MutableDuration(DurationType.getAllType(), true);\n+            new MutableTimePeriod(DurationType.getAllType(), true);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutableDuration test = new MutableDuration(length);\n+        MutableTimePeriod test = new MutableTimePeriod(length);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutableDuration test = new MutableDuration(length, null);\n+        MutableTimePeriod test = new MutableTimePeriod(length, null);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutableDuration test = new MutableDuration(length, DurationType.getMillisType());\n+        MutableTimePeriod test = new MutableTimePeriod(length, DurationType.getMillisType());\n         assertEquals(DurationType.getMillisType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutableDuration test = new MutableDuration(length, DurationType.getAllType());\n+        MutableTimePeriod test = new MutableTimePeriod(length, DurationType.getAllType());\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutableDuration test = new MutableDuration(length, DurationType.getAllType().withMillisRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(length, DurationType.getAllType().withMillisRemoved());\n         assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n      * Test constructor (4ints)\n      */\n     public void testConstructor_4int1() throws Throwable {\n-        MutableDuration test = new MutableDuration(5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(5, 6, 7, 8);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n      * Test constructor (8ints)\n      */\n     public void testConstructor_8int1() throws Throwable {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n      * Test constructor (8ints)\n      */\n     public void testConstructor_8int__DurationType1() throws Throwable {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8, null);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, null);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n     }\n \n     public void testConstructor_8int__DurationType2() throws Throwable {\n-        MutableDuration test = new MutableDuration(0, 0, 0, 0, 5, 6, 7, 8, DurationType.getDayHourType());\n+        MutableTimePeriod test = new MutableTimePeriod(0, 0, 0, 0, 5, 6, 7, 8, DurationType.getDayHourType());\n         assertEquals(DurationType.getDayHourType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n \n     public void testConstructor_8int__DurationType3() throws Throwable {\n         try {\n-            new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getDayHourType());\n+            new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getDayHourType());\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n     public void testConstructor_long_long1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        MutableDuration test = new MutableDuration(dt1.getMillis(), dt2.getMillis());\n+        MutableTimePeriod test = new MutableTimePeriod(dt1.getMillis(), dt2.getMillis());\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_long_long2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        MutableDuration test = new MutableDuration(dt1.getMillis(), dt2.getMillis());\n+        MutableTimePeriod test = new MutableTimePeriod(dt1.getMillis(), dt2.getMillis());\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_long_long_DurationType1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        MutableDuration test = new MutableDuration(dt1.getMillis(), dt2.getMillis(), null);\n+        MutableTimePeriod test = new MutableTimePeriod(dt1.getMillis(), dt2.getMillis(), null);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_long_long_DurationType2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);\n-        MutableDuration test = new MutableDuration(dt1.getMillis(), dt2.getMillis(), DurationType.getDayHourType());\n+        MutableTimePeriod test = new MutableTimePeriod(dt1.getMillis(), dt2.getMillis(), DurationType.getDayHourType());\n         assertEquals(DurationType.getDayHourType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testConstructor_long_long_DurationType3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        MutableDuration test = new MutableDuration(dt1.getMillis(), dt2.getMillis(), DurationType.getAllType().withMillisRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(dt1.getMillis(), dt2.getMillis(), DurationType.getAllType().withMillisRemoved());\n         assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        MutableDuration test = new MutableDuration(dt1, dt2);\n+        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        MutableDuration test = new MutableDuration(dt1, dt2);\n+        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI3() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        MutableDuration test = new MutableDuration(dt1, dt2);\n+        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(3, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI4() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n-        MutableDuration test = new MutableDuration(dt1, dt2);\n+        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testConstructor_RI_RI_DurationType1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        MutableDuration test = new MutableDuration(dt1, dt2, null);\n+        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2, null);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI_DurationType2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);\n-        MutableDuration test = new MutableDuration(dt1, dt2, DurationType.getDayHourType());\n+        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2, DurationType.getDayHourType());\n         assertEquals(DurationType.getDayHourType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testConstructor_RI_RI_DurationType3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        MutableDuration test = new MutableDuration(dt1, dt2, DurationType.getAllType().withMillisRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2, DurationType.getAllType().withMillisRemoved());\n         assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI_DurationType4() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        MutableDuration test = new MutableDuration(dt1, dt2, DurationType.getAllType());\n+        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2, DurationType.getAllType());\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(3, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI_DurationType5() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n-        MutableDuration test = new MutableDuration(dt1, dt2, DurationType.getAllType());\n+        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2, DurationType.getAllType());\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n      * Test constructor (Object)\n      */\n     public void testConstructor_Object1() throws Throwable {\n-        MutableDuration test = new MutableDuration(\"P1Y2M3D\");\n+        MutableTimePeriod test = new MutableTimePeriod(\"P1Y2M3D\");\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n     }\n \n     public void testConstructor_Object2() throws Throwable {\n-        MutableDuration test = new MutableDuration((Object) null);\n+        MutableTimePeriod test = new MutableTimePeriod((Object) null);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testConstructor_Object3() throws Throwable {\n-        MutableDuration test = new MutableDuration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()));\n+        MutableTimePeriod test = new MutableTimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()));\n         assertEquals(DurationType.getDayHourType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testConstructor_Object4() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        Duration base = new Duration(dt1, dt2);  // AllType and precise\n-        MutableDuration test = new MutableDuration(base);\n+        TimePeriod base = new TimePeriod(dt1, dt2);  // AllType and precise\n+        MutableTimePeriod test = new MutableTimePeriod(base);\n         assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n      * Test constructor (Object)\n      */\n     public void testConstructor_Object_DurationType1() throws Throwable {\n-        MutableDuration test = new MutableDuration(\"P1Y2M3D\", DurationType.getYearMonthType());\n+        MutableTimePeriod test = new MutableTimePeriod(\"P1Y2M3D\", DurationType.getYearMonthType());\n         assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n     }\n \n     public void testConstructor_Object_DurationType2() throws Throwable {\n-        MutableDuration test = new MutableDuration((Object) null, DurationType.getYearMonthType());\n+        MutableTimePeriod test = new MutableTimePeriod((Object) null, DurationType.getYearMonthType());\n         assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testConstructor_Object_DurationType3() throws Throwable {\n-        MutableDuration test = new MutableDuration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), DurationType.getYearMonthType());\n+        MutableTimePeriod test = new MutableTimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), DurationType.getYearMonthType());\n         assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testConstructor_Object_DurationType4() throws Throwable {\n-        MutableDuration test = new MutableDuration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), null);\n+        MutableTimePeriod test = new MutableTimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), null);\n         assertEquals(DurationType.getDayHourType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n--- a/JodaTime/src/test/org/joda/time/TestMutableDuration_Updates.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableDuration_Updates.java\n \n     //-----------------------------------------------------------------------\n     public void testAddYears() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addYears(10);\n         assertEquals(11, test.getYears());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addYears(-10);\n         assertEquals(-9, test.getYears());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addYears(0);\n         assertEquals(1, test.getYears());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testAddMonths() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addMonths(10);\n         assertEquals(12, test.getMonths());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addMonths(-10);\n         assertEquals(-8, test.getMonths());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addMonths(0);\n         assertEquals(2, test.getMonths());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testAddWeeks() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addWeeks(10);\n         assertEquals(13, test.getWeeks());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addWeeks(-10);\n         assertEquals(-7, test.getWeeks());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addWeeks(0);\n         assertEquals(3, test.getWeeks());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testAddDays() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addDays(10);\n         assertEquals(14, test.getDays());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addDays(-10);\n         assertEquals(-6, test.getDays());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addDays(0);\n         assertEquals(4, test.getDays());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testAddHours() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addHours(10);\n         assertEquals(15, test.getHours());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addHours(-10);\n         assertEquals(-5, test.getHours());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addHours(0);\n         assertEquals(5, test.getHours());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testAddMinutes() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addMinutes(10);\n         assertEquals(16, test.getMinutes());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addMinutes(-10);\n         assertEquals(-4, test.getMinutes());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addMinutes(0);\n         assertEquals(6, test.getMinutes());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testAddSeconds() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addSeconds(10);\n         assertEquals(17, test.getSeconds());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addSeconds(-10);\n         assertEquals(-3, test.getSeconds());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addSeconds(0);\n         assertEquals(7, test.getSeconds());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testAddMillis() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addMillis(10);\n         assertEquals(18, test.getMillis());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addMillis(-10);\n         assertEquals(-2, test.getMillis());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addMillis(0);\n         assertEquals(8, test.getMillis());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testSetYears() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setYears(10);\n         assertEquals(10, test.getYears());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setYears(-10);\n         assertEquals(-10, test.getYears());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setYears(0);\n         assertEquals(0, test.getYears());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testSetMonths() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setMonths(10);\n         assertEquals(10, test.getMonths());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setMonths(-10);\n         assertEquals(-10, test.getMonths());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setMonths(0);\n         assertEquals(0, test.getMonths());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testSetWeeks() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setWeeks(10);\n         assertEquals(10, test.getWeeks());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setWeeks(-10);\n         assertEquals(-10, test.getWeeks());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setWeeks(0);\n         assertEquals(0, test.getWeeks());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testSetDays() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setDays(10);\n         assertEquals(10, test.getDays());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setDays(-10);\n         assertEquals(-10, test.getDays());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setDays(0);\n         assertEquals(0, test.getDays());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testSetHours() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setHours(10);\n         assertEquals(10, test.getHours());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setHours(-10);\n         assertEquals(-10, test.getHours());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setHours(0);\n         assertEquals(0, test.getHours());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testSetMinutes() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setMinutes(10);\n         assertEquals(10, test.getMinutes());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setMinutes(-10);\n         assertEquals(-10, test.getMinutes());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setMinutes(0);\n         assertEquals(0, test.getMinutes());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testSetSeconds() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setSeconds(10);\n         assertEquals(10, test.getSeconds());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setSeconds(-10);\n         assertEquals(-10, test.getSeconds());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setSeconds(0);\n         assertEquals(0, test.getSeconds());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testSetMillis() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setMillis(10);\n         assertEquals(10, test.getMillis());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setMillis(-10);\n         assertEquals(-10, test.getMillis());\n         \n-        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setMillis(0);\n         assertEquals(0, test.getMillis());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testSetDuration_8ints1() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setDuration(11, 12, 13, 14, 15, 16, 17, 18);\n         assertEquals(11, test.getYears());\n         assertEquals(12, test.getMonths());\n     }\n \n     public void testSetDuration_8ints2() {\n-        MutableDuration test = new MutableDuration(100L, DurationType.getMillisType());\n+        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getMillisType());\n         try {\n             test.setDuration(11, 12, 13, 14, 15, 16, 17, 18);\n             fail();\n     }\n \n     public void testSetDuration_8ints3() {\n-        MutableDuration test = new MutableDuration(100L, DurationType.getMillisType());\n+        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getMillisType());\n         test.setDuration(0, 0, 0, 0, 0, 0, 0, 18);\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testSetDuration_8ints4() {\n-        MutableDuration test = new MutableDuration(0, 0, 0, 0, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(0, 0, 0, 0, 5, 6, 7, 8);\n         assertEquals(true, test.isPrecise());\n         test.setDuration(11, 12, 13, 14, 15, 16, 17, 18);\n         assertEquals(false, test.isPrecise());\n \n     //-----------------------------------------------------------------------\n     public void testSetDuration_RD1() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n-        test.setDuration(new MutableDuration(11, 12, 13, 14, 15, 16, 17, 18));\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test.setDuration(new MutableTimePeriod(11, 12, 13, 14, 15, 16, 17, 18));\n         assertEquals(11, test.getYears());\n         assertEquals(12, test.getMonths());\n         assertEquals(13, test.getWeeks());\n     }\n \n     public void testSetDuration_RD2() {\n-        MutableDuration test = new MutableDuration(100L, DurationType.getMillisType());\n+        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getMillisType());\n         try {\n-            test.setDuration(new MutableDuration(11, 12, 13, 14, 15, 16, 17, 18));\n+            test.setDuration(new MutableTimePeriod(11, 12, 13, 14, 15, 16, 17, 18));\n             fail();\n         } catch (IllegalArgumentException ex) {}\n         assertEquals(0, test.getYears());\n     }\n \n     public void testSetDuration_RD3() {\n-        MutableDuration test = new MutableDuration(100L, DurationType.getMillisType());\n-        test.setDuration(new MutableDuration(0, 0, 0, 0, 0, 0, 0, 18));\n+        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getMillisType());\n+        test.setDuration(new MutableTimePeriod(0, 0, 0, 0, 0, 0, 0, 18));\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     public void testSetDuration_RD4() {\n-        MutableDuration test = new MutableDuration(0, 0, 0, 0, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(0, 0, 0, 0, 5, 6, 7, 8);\n         assertEquals(true, test.isPrecise());\n-        test.setDuration(new MutableDuration(11, 12, 13, 14, 15, 16, 17, 18));\n+        test.setDuration(new MutableTimePeriod(11, 12, 13, 14, 15, 16, 17, 18));\n         assertEquals(false, test.isPrecise());\n         assertEquals(11, test.getYears());\n         assertEquals(12, test.getMonths());\n     }\n \n     public void testSetDuration_RD5() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setDuration(null);\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n \n     //-----------------------------------------------------------------------\n     public void testSetTotalMillis_long_long1() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setTotalMillis(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetTotalMillis_long_long2() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setTotalMillis(dt2.getMillis(), dt1.getMillis());\n     }\n \n     public void testSetTotalMillis_long_long3() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         test.setTotalMillis(dt1.getMillis(), dt1.getMillis());\n         assertEquals(0, test.getYears());\n     }\n \n     public void testSetTotalMillis_long_long_NoYears() {\n-        MutableDuration test = new MutableDuration(DurationType.getAllType().withYearsRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(DurationType.getAllType().withYearsRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setTotalMillis(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetTotalMillis_long_long_NoMonths() {\n-        MutableDuration test = new MutableDuration(DurationType.getAllType().withMonthsRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(DurationType.getAllType().withMonthsRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setTotalMillis(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetTotalMillis_long_long_NoWeeks() {\n-        MutableDuration test = new MutableDuration(DurationType.getAllType().withWeeksRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(DurationType.getAllType().withWeeksRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setTotalMillis(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetTotalMillis_long_long_NoDays() {\n-        MutableDuration test = new MutableDuration(DurationType.getAllType().withDaysRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(DurationType.getAllType().withDaysRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setTotalMillis(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetTotalMillis_long_long_NoHours() {\n-        MutableDuration test = new MutableDuration(DurationType.getAllType().withHoursRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(DurationType.getAllType().withHoursRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setTotalMillis(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetTotalMillis_long_long_NoMinutes() {\n-        MutableDuration test = new MutableDuration(DurationType.getAllType().withMinutesRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(DurationType.getAllType().withMinutesRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setTotalMillis(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetTotalMillis_long_long_NoSeconds() {\n-        MutableDuration test = new MutableDuration(DurationType.getAllType().withSecondsRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(DurationType.getAllType().withSecondsRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setTotalMillis(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetTotalMillis_long_long_NoMillis() {\n-        MutableDuration test = new MutableDuration(DurationType.getAllType().withMillisRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(DurationType.getAllType().withMillisRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setTotalMillis(dt1.getMillis(), dt2.getMillis());\n \n     //-----------------------------------------------------------------------\n     public void testSetTotalMillis_long1() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setTotalMillis(100L);\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testSetTotalMillis_long2() {\n-        MutableDuration test = new MutableDuration(DurationType.getPreciseYearMonthType());\n+        MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearMonthType());\n         test.setTotalMillis(\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n     }\n \n     public void testSetTotalMillis_long3() {\n-        MutableDuration test = new MutableDuration(DurationType.getPreciseYearWeekType());\n+        MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearWeekType());\n         test.setTotalMillis(\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableDuration test = new MutableDuration(DurationType.getPreciseYearMonthType().withYearsRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearMonthType().withYearsRemoved());\n         test.setTotalMillis(ms);\n         assertEquals(0, test.getYears());\n         assertEquals(15, test.getMonths()); // totalDays=365+85=450=15*30\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableDuration test = new MutableDuration(DurationType.getPreciseYearMonthType().withMonthsRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearMonthType().withMonthsRemoved());\n         test.setTotalMillis(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(0, test.getMonths());\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableDuration test = new MutableDuration(DurationType.getPreciseYearWeekType().withWeeksRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearWeekType().withWeeksRemoved());\n         test.setTotalMillis(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(0, test.getMonths());\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableDuration test = new MutableDuration(DurationType.getPreciseYearMonthType().withDaysRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearMonthType().withDaysRemoved());\n         test.setTotalMillis(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableDuration test = new MutableDuration(DurationType.getPreciseYearMonthType().withHoursRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearMonthType().withHoursRemoved());\n         test.setTotalMillis(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableDuration test = new MutableDuration(DurationType.getPreciseYearMonthType().withMinutesRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearMonthType().withMinutesRemoved());\n         test.setTotalMillis(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableDuration test = new MutableDuration(DurationType.getPreciseYearMonthType().withSecondsRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearMonthType().withSecondsRemoved());\n         test.setTotalMillis(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableDuration test = new MutableDuration(DurationType.getPreciseYearMonthType().withMillisRemoved());\n+        MutableTimePeriod test = new MutableTimePeriod(DurationType.getPreciseYearMonthType().withMillisRemoved());\n         test.setTotalMillis(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n \n     //-----------------------------------------------------------------------\n     public void testAdd_long1() {\n-        MutableDuration test = new MutableDuration(100L);\n+        MutableTimePeriod test = new MutableTimePeriod(100L);\n         test.add(100L);\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testAdd_long2() {\n-        MutableDuration test = new MutableDuration(100L, DurationType.getPreciseYearMonthType());\n+        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getPreciseYearMonthType());\n         long ms =\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n     }\n \n     public void testAdd_long3() {\n-        MutableDuration test = new MutableDuration(100L, DurationType.getPreciseYearMonthType());\n+        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getPreciseYearMonthType());\n         long ms =0L;\n         test.add(ms);\n         assertEquals(0, test.getYears());\n     }\n \n     public void testAdd_long4() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         try {\n             test.add(100L);\n             fail();\n \n     //-----------------------------------------------------------------------\n     public void testAdd_RD1() {\n-        MutableDuration test = new MutableDuration(100L);\n-        test.add(new Duration(100L));\n+        MutableTimePeriod test = new MutableTimePeriod(100L);\n+        test.add(new TimePeriod(100L));\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     public void testAdd_RD2() {\n-        MutableDuration test = new MutableDuration(100L, DurationType.getPreciseYearMonthType());\n-        test.add(new Duration(1, 0, 12, 1, 5, 6, 7, 8, DurationType.getPreciseYearWeekType()));\n+        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getPreciseYearMonthType());\n+        test.add(new TimePeriod(1, 0, 12, 1, 5, 6, 7, 8, DurationType.getPreciseYearWeekType()));\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     public void testAdd_RD3() {\n-        MutableDuration test = new MutableDuration(100L, DurationType.getPreciseYearMonthType());\n-        test.add(Duration.ZERO);\n+        MutableTimePeriod test = new MutableTimePeriod(100L, DurationType.getPreciseYearMonthType());\n+        test.add(TimePeriod.ZERO);\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     public void testAdd_RD4() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         try {\n-            test.add(new Duration(100L));\n+            test.add(new TimePeriod(100L));\n             fail();\n         } catch (IllegalStateException ex) {}\n     }\n \n     public void testAdd_RD5() {\n-        MutableDuration test = new MutableDuration(100L);\n+        MutableTimePeriod test = new MutableTimePeriod(100L);\n         try {\n-            test.add(new Duration(1, 2, 3, 4, 5, 6, 7, 8));\n+            test.add(new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8));\n             fail();\n         } catch (IllegalStateException ex) {}\n     }\n \n     public void testAdd_RD6() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.add(null);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n \n     //-----------------------------------------------------------------------\n     public void testNormalize1() {\n-        MutableDuration test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         try {\n             test.normalize();\n             fail();\n     }\n \n     public void testNormalize2() {\n-        MutableDuration test = new MutableDuration(1, 14, 0, 36, 29, 66, 67, 1008, DurationType.getPreciseYearMonthType());\n+        MutableTimePeriod test = new MutableTimePeriod(1, 14, 0, 36, 29, 66, 67, 1008, DurationType.getPreciseYearMonthType());\n         //   365 + 14*30 + 6 days\n         // extra year created from 12 months of 30 days plus 5 extra days\n         // 2*365 +  2*30 + 1 day\n--- a/JodaTime/src/test/org/joda/time/convert/TestConverterManager.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestConverterManager.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.Duration;\n+import org.joda.time.TimePeriod;\n import org.joda.time.DurationType;\n import org.joda.time.Interval;\n import org.joda.time.JodaTimePermission;\n-import org.joda.time.ReadWritableDuration;\n+import org.joda.time.ReadWritableTimePeriod;\n import org.joda.time.ReadWritableInterval;\n import org.joda.time.ReadableDateTime;\n import org.joda.time.ReadableDuration;\n         DurationConverter c = ConverterManager.getInstance().getDurationConverter(new Long(0L));\n         assertEquals(Long.class, c.getSupportedType());\n         \n-        c = ConverterManager.getInstance().getDurationConverter(new Duration(DurationType.getMillisType()));\n+        c = ConverterManager.getInstance().getDurationConverter(new TimePeriod(DurationType.getMillisType()));\n         assertEquals(ReadableDuration.class, c.getSupportedType());\n         \n         c = ConverterManager.getInstance().getDurationConverter(new Interval(0L, 1000L));\n         DurationConverter c = new DurationConverter() {\n             public boolean isPrecise(Object object) {return false;}\n             public long getDurationMillis(Object object) {return 0;}\n-            public void setInto(ReadWritableDuration duration, Object object) {}\n+            public void setInto(ReadWritableTimePeriod duration, Object object) {}\n             public DurationType getDurationType(Object object, boolean tmm) {return null;}\n             public Class getSupportedType() {return Boolean.class;}\n         };\n         DurationConverter c = new DurationConverter() {\n             public boolean isPrecise(Object object) {return false;}\n             public long getDurationMillis(Object object) {return 0;}\n-            public void setInto(ReadWritableDuration duration, Object object) {}\n+            public void setInto(ReadWritableTimePeriod duration, Object object) {}\n             public DurationType getDurationType(Object object, boolean tmm) {return null;}\n             public Class getSupportedType() {return String.class;}\n         };\n         DurationConverter c = new DurationConverter() {\n             public boolean isPrecise(Object object) {return false;}\n             public long getDurationMillis(Object object) {return 0;}\n-            public void setInto(ReadWritableDuration duration, Object object) {}\n+            public void setInto(ReadWritableTimePeriod duration, Object object) {}\n             public DurationType getDurationType(Object object, boolean tmm) {return null;}\n             public Class getSupportedType() {return Boolean.class;}\n         };\n--- a/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n import org.joda.time.DurationType;\n-import org.joda.time.MutableDuration;\n+import org.joda.time.MutableTimePeriod;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.chrono.JulianChronology;\n \n     }\n \n     public void testSetInto_Object() throws Exception {\n-        MutableDuration m = new MutableDuration(DurationType.getMillisType());\n+        MutableTimePeriod m = new MutableTimePeriod(DurationType.getMillisType());\n         LongConverter.INSTANCE.setInto(m, new Long(123L));\n         assertEquals(123L, m.getTotalMillis());\n     }\n--- a/JodaTime/src/test/org/joda/time/convert/TestNullConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestNullConverter.java\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n import org.joda.time.DurationType;\n-import org.joda.time.MutableDuration;\n+import org.joda.time.MutableTimePeriod;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.chrono.JulianChronology;\n \n     }\n \n     public void testSetInto_Object() throws Exception {\n-        MutableDuration m = new MutableDuration(DurationType.getMillisType());\n+        MutableTimePeriod m = new MutableTimePeriod(DurationType.getMillisType());\n         NullConverter.INSTANCE.setInto(m, null);\n         assertEquals(0L, m.getTotalMillis());\n     }\n--- a/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.Duration;\n+import org.joda.time.TimePeriod;\n import org.joda.time.DurationType;\n import org.joda.time.MillisDuration;\n-import org.joda.time.MutableDuration;\n+import org.joda.time.MutableTimePeriod;\n import org.joda.time.ReadableDuration;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.chrono.JulianChronology;\n \n     //-----------------------------------------------------------------------\n     public void testGetDurationMillis_Object() throws Exception {\n-        assertEquals(123L, ReadableDurationConverter.INSTANCE.getDurationMillis(new Duration(123L)));\n+        assertEquals(123L, ReadableDurationConverter.INSTANCE.getDurationMillis(new TimePeriod(123L)));\n         try {\n-            ReadableDurationConverter.INSTANCE.getDurationMillis(new Duration(1, 2, 0, 1, 0, 0, 0, 0));\n+            ReadableDurationConverter.INSTANCE.getDurationMillis(new TimePeriod(1, 2, 0, 1, 0, 0, 0, 0));\n             fail();\n         } catch (IllegalStateException ex) {}\n     }\n     public void testGetDurationType_Object() throws Exception {\n         assertEquals(DurationType.getMillisType(),\n             ReadableDurationConverter.INSTANCE.getDurationType(\n-                new Duration(123L, DurationType.getMillisType()), false));\n+                new TimePeriod(123L, DurationType.getMillisType()), false));\n         assertEquals(DurationType.getAllType(),\n             ReadableDurationConverter.INSTANCE.getDurationType(\n-                new Duration(1, 2, 0, 1, 0, 0, 0, 0), false));\n+                new TimePeriod(1, 2, 0, 1, 0, 0, 0, 0), false));\n         assertEquals(DurationType.getPreciseAllType(),\n             ReadableDurationConverter.INSTANCE.getDurationType(\n                 new MillisDuration(1, 2, 0, 1, 0, 0, 0, 0), true));\n     }\n \n     public void testIsPrecise_Object() throws Exception {\n-        assertEquals(true, ReadableDurationConverter.INSTANCE.isPrecise(new Duration(123L)));\n-        assertEquals(false, ReadableDurationConverter.INSTANCE.isPrecise(new Duration(1, 2, 0, 1, 0, 0, 0, 0)));\n+        assertEquals(true, ReadableDurationConverter.INSTANCE.isPrecise(new TimePeriod(123L)));\n+        assertEquals(false, ReadableDurationConverter.INSTANCE.isPrecise(new TimePeriod(1, 2, 0, 1, 0, 0, 0, 0)));\n     }\n \n     public void testSetInto_Object() throws Exception {\n-        MutableDuration m = new MutableDuration(DurationType.getYearMonthType());\n-        ReadableDurationConverter.INSTANCE.setInto(m, new Duration(1, 2, 0, 3, 0, 0, 0, 0));\n+        MutableTimePeriod m = new MutableTimePeriod(DurationType.getYearMonthType());\n+        ReadableDurationConverter.INSTANCE.setInto(m, new TimePeriod(1, 2, 0, 3, 0, 0, 0, 0));\n         assertEquals(1, m.getYears());\n         assertEquals(2, m.getMonths());\n         assertEquals(0, m.getWeeks());\n--- a/JodaTime/src/test/org/joda/time/convert/TestReadableIntervalConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestReadableIntervalConverter.java\n import org.joda.time.DateTimeZone;\n import org.joda.time.DurationType;\n import org.joda.time.Interval;\n-import org.joda.time.MutableDuration;\n+import org.joda.time.MutableTimePeriod;\n import org.joda.time.MutableInterval;\n import org.joda.time.ReadableInterval;\n import org.joda.time.chrono.ISOChronology;\n \n     public void testSetInto_Object() throws Exception {\n         Interval i = new Interval(0L, 123L);\n-        MutableDuration m = new MutableDuration(DurationType.getMillisType());\n+        MutableTimePeriod m = new MutableTimePeriod(DurationType.getMillisType());\n         ReadableIntervalConverter.INSTANCE.setInto(m, i);\n         assertEquals(0, m.getYears());\n         assertEquals(0, m.getMonths());\n--- a/JodaTime/src/test/org/joda/time/convert/TestStringConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestStringConverter.java\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.DurationType;\n-import org.joda.time.MutableDuration;\n+import org.joda.time.MutableTimePeriod;\n import org.joda.time.MutableInterval;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.chrono.JulianChronology;\n     }\n \n     public void testSetInto_Object() throws Exception {\n-        MutableDuration m = new MutableDuration(DurationType.getYearMonthType());\n+        MutableTimePeriod m = new MutableTimePeriod(DurationType.getYearMonthType());\n         StringConverter.INSTANCE.setInto(m, \"P2Y6M9DT12H24M48S\");\n         assertEquals(2, m.getYears());\n         assertEquals(6, m.getMonths());\n         assertEquals(48, m.getSeconds());\n         assertEquals(0, m.getMillis());\n         \n-        m = new MutableDuration(DurationType.getYearWeekType());\n+        m = new MutableTimePeriod(DurationType.getYearWeekType());\n         StringConverter.INSTANCE.setInto(m, \"P2Y4W3DT12H24M48S\");\n         assertEquals(2, m.getYears());\n         assertEquals(4, m.getWeeks());\n         assertEquals(48, m.getSeconds());\n         assertEquals(0, m.getMillis());\n         \n-        m = new MutableDuration(1, 0, 1, 1, 1, 1, 1, 1, DurationType.getYearWeekType());\n+        m = new MutableTimePeriod(1, 0, 1, 1, 1, 1, 1, 1, DurationType.getYearWeekType());\n         StringConverter.INSTANCE.setInto(m, \"P2Y4W3D\");\n         assertEquals(2, m.getYears());\n         assertEquals(4, m.getWeeks());", "timestamp": 1091491345, "metainfo": ""}