{"sha": "6ca2038820082b2f0b739cc4048d02e3d83b4412", "log": "Add Islamic Chronology   ", "commit": "\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/IslamicChronology.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * Implements the Islamic, or Hijri, calendar system using arithmetic rules.\n+ * <p>\n+ * This calendar is a lunar calendar with a shorter year than ISO.\n+ * Year 1 in the Islamic calendar began on July 16, 622 CE (Julian), thus\n+ * Islamic years do not begin at the same time as Julian years. This chronology\n+ * is not proleptic, as it does not allow dates before the first Islamic year.\n+ * <p>\n+ * There are two basic forms of the Islamic calendar, the tabular and the\n+ * observed. The observed form cannot easily be used by computers as it\n+ * relies on human observation of the new moon.\n+ * The tabular calendar, implemented here, is an arithmetical approximation\n+ * of the observed form that follows relatively simple rules.\n+ * <p>\n+ * The tabular form of the calendar defines 12 months of alternately\n+ * 30 and 29 days. The last month is extended to 30 days in a leap year.\n+ * Leap years occur according to a 30 year cycle. There are four recognised\n+ * patterns of leap years in the 30 year cycle:\n+ * <pre>\n+ * Years 2, 5, 7, 10, 13, 15, 18, 21, 24, 26 & 29 - 15-based, used by Microsoft\n+ * Years 2, 5, 7, 10, 13, 16, 18, 21, 24, 26 & 29 - 16-based, most commonly used\n+ * Years 2, 5, 8, 10, 13, 16, 19, 21, 24, 27 & 29 - Indian\n+ * Years 2, 5, 8, 11, 13, 16, 19, 21, 24, 27 & 30 - Habash al-Hasib\n+ * </pre>\n+ * You can select which pattern to use via the factory methods, or use the\n+ * default (16-based).\n+ * <p>\n+ * This implementation defines a day as midnight to midnight exactly as per\n+ * the ISO chronology. This correct start of day is at sunset on the previous\n+ * day, however this cannot readily be modelled and has been ignored.\n+ * <p>\n+ * IslamicChronology is thread-safe and immutable.\n+ *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Islamic_calendar\">Wikipedia</a>\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.2\n+ */\n+public final class IslamicChronology extends BaseGJChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -3663823829888L;\n+\n+    /**\n+     * Constant value for 'Anno Hegirae', equivalent\n+     * to the value returned for AD/CE.\n+     */\n+    public static final int AH = DateTimeConstants.CE;\n+\n+    /** A singleton era field. */\n+    private static final DateTimeField ERA_FIELD = new BasicSingleEraDateTimeField(\"AH\");\n+\n+    /** Leap year 15-based pattern. */\n+    public static final LeapYearPatternType LEAP_YEAR_15_BASED = new LeapYearPatternType(0, 623158436);\n+    /** Leap year 16-based pattern. */\n+    public static final LeapYearPatternType LEAP_YEAR_16_BASED = new LeapYearPatternType(1, 623191204);\n+    /** Leap year Indian pattern. */\n+    public static final LeapYearPatternType LEAP_YEAR_INDIAN = new LeapYearPatternType(2, 690562340);\n+    /** Leap year Habash al-Hasib pattern. */\n+    public static final LeapYearPatternType LEAP_YEAR_HABASH_AL_HASIB = new LeapYearPatternType(3, 153692453);\n+\n+    /** The lowest year that can be fully supported. */\n+    private static final int MIN_YEAR = -292269337;\n+\n+    /**\n+     * The highest year that can be fully supported.\n+     * Although calculateFirstDayOfYearMillis can go higher without\n+     * overflowing, the getYear method overflows when it adds the\n+     * approximate millis at the epoch.\n+     */\n+    private static final int MAX_YEAR = 292271022;\n+\n+    /** The days in a pair of months. */\n+    private static final int MONTH_PAIR_LENGTH = 59;\n+\n+    /** The length of the long month. */\n+    private static final int LONG_MONTH_LENGTH = 30;\n+\n+    /** The length of the short month. */\n+    private static final int SHORT_MONTH_LENGTH = 29;\n+\n+    /** The length of the long month in millis. */\n+    private static final long MILLIS_PER_MONTH_PAIR = 59L * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    /** The length of the long month in millis. */\n+    private static final long MILLIS_PER_MONTH = (long) (29.53056 * DateTimeConstants.MILLIS_PER_DAY);\n+\n+    /** The length of the long month in millis. */\n+    private static final long MILLIS_PER_LONG_MONTH = 30L * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    /** The typical millis per year. */\n+    private static final long MILLIS_PER_YEAR = (long) (354.36667 * DateTimeConstants.MILLIS_PER_DAY);\n+\n+    /** The typical millis per year. */\n+    private static final long MILLIS_PER_SHORT_YEAR = 354L * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    /** The typical millis per year. */\n+    private static final long MILLIS_PER_LONG_YEAR = 355L * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    /** The millis of 0001-01-01. */\n+    private static final long MILLIS_YEAR_1 = -42521587200000L;\n+                                    //        -42520809600000L;\n+//    long start = 0L - 278L * DateTimeConstants.MILLIS_PER_DAY;\n+//    long cy = 46L * MILLIS_PER_CYCLE;  // 1381-01-01\n+//    long rem = 5L * MILLIS_PER_SHORT_YEAR +\n+//            3L * MILLIS_PER_LONG_YEAR;  // 1389-01-01\n+\n+    /** The length of the cycle of leap years. */\n+    private static final int CYCLE = 30;\n+\n+    /** The millis of a 30 year cycle. */\n+    private static final long MILLIS_PER_CYCLE = ((19L * 354L + 11L * 355L) * DateTimeConstants.MILLIS_PER_DAY);\n+\n+    /** Cache of zone to chronology arrays */\n+    private static final Map cCache = new HashMap();\n+\n+    /** Singleton instance of a UTC CopticChronology */\n+    private static final IslamicChronology INSTANCE_UTC;\n+    static {\n+        // init after static fields\n+        INSTANCE_UTC = getInstance(DateTimeZone.UTC);\n+    }\n+\n+    /** The leap years to use. */\n+    private final LeapYearPatternType iLeapYears;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an instance of the CopticChronology.\n+     * The time zone of the returned instance is UTC.\n+     * \n+     * @return a singleton UTC instance of the chronology\n+     */\n+    public static IslamicChronology getInstanceUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets an instance of the CopticChronology in the default time zone.\n+     * \n+     * @return a chronology in the default time zone\n+     */\n+    public static IslamicChronology getInstance() {\n+        return getInstance(DateTimeZone.getDefault(), LEAP_YEAR_16_BASED);\n+    }\n+\n+    /**\n+     * Gets an instance of the CopticChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @return a chronology in the specified time zone\n+     */\n+    public static IslamicChronology getInstance(DateTimeZone zone) {\n+        return getInstance(zone, LEAP_YEAR_16_BASED);\n+    }\n+\n+    /**\n+     * Gets an instance of the CopticChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @param leapYears  the type defining the leap year pattern\n+     * @return a chronology in the specified time zone\n+     */\n+    public static IslamicChronology getInstance(DateTimeZone zone, LeapYearPatternType leapYears) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        IslamicChronology chrono;\n+        synchronized (cCache) {\n+            IslamicChronology[] chronos = (IslamicChronology[]) cCache.get(zone);\n+            if (chronos == null) {\n+                chronos = new IslamicChronology[4];\n+                cCache.put(zone, chronos);\n+            }\n+            chrono = chronos[leapYears.index];\n+            if (chrono == null) {\n+                if (zone == DateTimeZone.UTC) {\n+                    // First create without a lower limit.\n+                    chrono = new IslamicChronology(null, null, leapYears);\n+                    // Impose lower limit and make another IslamicChronology.\n+                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n+                    chrono = new IslamicChronology(\n+                        LimitChronology.getInstance(chrono, lowerLimit, null),\n+                         null, leapYears);\n+                } else {\n+                    chrono = getInstance(DateTimeZone.UTC, leapYears);\n+                    chrono = new IslamicChronology\n+                        (ZonedChronology.getInstance(chrono, zone), null, leapYears);\n+                }\n+                chronos[leapYears.index] = chrono;\n+            }\n+        }\n+        return chrono;\n+    }\n+\n+    // Constructors and instance variables\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Restricted constructor.\n+     */\n+    IslamicChronology(Chronology base, Object param, LeapYearPatternType leapYears) {\n+        super(base, param, 4);\n+        this.iLeapYears = leapYears;\n+    }\n+\n+    /**\n+     * Serialization singleton.\n+     */\n+    private Object readResolve() {\n+        Chronology base = getBase();\n+        return base == null ? getInstanceUTC() : getInstance(base.getZone());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the leap year pattern type.\n+     *\n+     * @return the pattern type\n+     */\n+    public LeapYearPatternType getLeapYearPatternType() {\n+        return iLeapYears;\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the Chronology in the UTC time zone.\n+     * \n+     * @return the chronology in UTC\n+     */\n+    public Chronology withUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets the Chronology in a specific time zone.\n+     * \n+     * @param zone  the zone to get the chronology in, null is default\n+     * @return the chronology\n+     */\n+    public Chronology withZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getZone()) {\n+            return this;\n+        }\n+        return getInstance(zone);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getYear(long instant) {\n+        long millisIslamic = instant - MILLIS_YEAR_1;\n+        long cycles = millisIslamic / MILLIS_PER_CYCLE;\n+        long cycleRemainder = millisIslamic % MILLIS_PER_CYCLE;\n+        \n+        int year = (int) ((cycles * CYCLE) + 1L);\n+        long yearMillis = (isLeapYear(year) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR);\n+        while (cycleRemainder >= yearMillis) {\n+            cycleRemainder -= yearMillis;\n+            yearMillis = (isLeapYear(++year) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR);\n+        }\n+        return year;\n+    }\n+\n+    long setYear(long instant, int year) {\n+        // optimsed implementation of set, due to fixed months\n+        int thisYear = getYear(instant);\n+        int dayOfYear = getDayOfYear(instant, thisYear);\n+        int millisOfDay = getMillisOfDay(instant);\n+\n+        if (dayOfYear > 354) {\n+            // Current year is leap, and day is leap.\n+            if (!isLeapYear(year)) {\n+                // Moving to a non-leap year, leap day doesn't exist.\n+                dayOfYear--;\n+            }\n+        }\n+\n+        instant = getYearMonthDayMillis(year, 1, dayOfYear);\n+        instant += millisOfDay;\n+        return instant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getYearDifference(long minuendInstant, long subtrahendInstant) {\n+        // optimsed implementation of getDifference, due to fixed months\n+        int minuendYear = getYear(minuendInstant);\n+        int subtrahendYear = getYear(subtrahendInstant);\n+\n+        // Inlined remainder method to avoid duplicate calls to get.\n+        long minuendRem = minuendInstant - getYearMillis(minuendYear);\n+        long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);\n+\n+        int difference = minuendYear - subtrahendYear;\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+        return difference;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getTotalMillisByYearMonth(int year, int month) {\n+        if (--month % 2 == 1) {\n+            month /= 2;\n+            return month * MILLIS_PER_MONTH_PAIR + MILLIS_PER_LONG_MONTH;\n+        } else {\n+            month /= 2;\n+            return month * MILLIS_PER_MONTH_PAIR;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDayOfMonth(long millis) {\n+        // optimised for simple months\n+        int doy = getDayOfYear(millis) - 1;\n+        if (doy == 354) {\n+            return 30;\n+        }\n+        return (doy % MONTH_PAIR_LENGTH) % LONG_MONTH_LENGTH + 1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    boolean isLeapYear(int year) {\n+        return iLeapYears.isLeapYear(year);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInYearMax() {\n+        return 355;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInYear(int year) {\n+        return isLeapYear(year) ? 355 : 354;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInYearMonth(int year, int month) {\n+        if (month == 12 && isLeapYear(year)) {\n+            return LONG_MONTH_LENGTH;\n+        }\n+        return (--month % 2 == 0 ? LONG_MONTH_LENGTH : SHORT_MONTH_LENGTH);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInMonthMax() {\n+        return LONG_MONTH_LENGTH;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInMonthMax(int month) {\n+        if (month == 12) {\n+            return LONG_MONTH_LENGTH;\n+        }\n+        return (--month % 2 == 0 ? LONG_MONTH_LENGTH : SHORT_MONTH_LENGTH);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMonthOfYear(long millis, int year) {\n+        int doyZeroBased = (int) ((millis - getYearMillis(year)) / DateTimeConstants.MILLIS_PER_DAY);\n+        if (doyZeroBased == 354) {\n+            return 12;\n+        }\n+        return ((doyZeroBased * 2) / MONTH_PAIR_LENGTH) + 1;\n+//        return (int) (doyZeroBased / 29.9f) + 1;\n+//        \n+//        int monthPairZeroBased = doyZeroBased / MONTH_PAIR_LENGTH;\n+//        int monthPairRemainder = doyZeroBased % MONTH_PAIR_LENGTH;\n+//        return (monthPairZeroBased * 2) + 1 + (monthPairRemainder >= LONG_MONTH_LENGTH ? 1 : 0);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getAverageMillisPerYear() {\n+        return MILLIS_PER_YEAR;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getAverageMillisPerMonth() {\n+        return MILLIS_PER_MONTH;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long calculateFirstDayOfYearMillis(int year) {\n+        if (year > MAX_YEAR) {\n+            throw new ArithmeticException(\"Year is too large: \" + year + \" > \" + MAX_YEAR);\n+        }\n+        if (year < MIN_YEAR) {\n+            throw new ArithmeticException(\"Year is too small: \" + year + \" < \" + MIN_YEAR);\n+        }\n+\n+        // Java epoch is 1970-01-01 Gregorian which is 0622-07-16 Islamic.\n+        // 0001-01-01 Islamic is -42520809600000L\n+        // would prefer to calculate against year zero, but leap year\n+        // can be in that year so it doesn't work\n+        year--;\n+        long cycle = year / CYCLE;\n+        long millis = MILLIS_YEAR_1 + cycle * MILLIS_PER_CYCLE;\n+        int cycleRemainder = (year % CYCLE) + 1;\n+        \n+        for (int i = 1; i < cycleRemainder; i++) {\n+            millis += (isLeapYear(i) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR);\n+        }\n+        \n+        return millis;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMinYear() {\n+        return 1; //MIN_YEAR;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMaxYear() {\n+        return MAX_YEAR;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getApproxMillisAtEpoch() {\n+        // Epoch 1970-01-01 ISO = 1389-10-22 Islamic\n+        return -MILLIS_YEAR_1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected void assemble(Fields fields) {\n+        if (getBase() == null) {\n+            super.assemble(fields);\n+\n+            fields.era = ERA_FIELD;\n+            fields.monthOfYear = new BasicMonthOfYearDateTimeField(this, 12);\n+            fields.months = fields.monthOfYear.getDurationField();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Leap year patterns for the Islamic Chronology.\n+     */\n+    public static class LeapYearPatternType implements Serializable {\n+        /** Serialization lock */\n+        private static final long serialVersionUID = 26581275372698L;\n+//        /** Leap year raw data encoded into bits. */\n+//        private static final int[][] LEAP_YEARS = {\n+//            {2, 5, 7, 10, 13, 15, 18, 21, 24, 26, 29},  // 623158436\n+//            {2, 5, 7, 10, 13, 16, 18, 21, 24, 26, 29},  // 623191204\n+//            {2, 5, 8, 10, 13, 16, 19, 21, 24, 27, 29},  // 690562340\n+//            {0, 2, 5, 8, 11, 13, 16, 19, 21, 24, 27},   // 153692453\n+//        };\n+        \n+        /** The index. */\n+        final byte index;\n+        /** The leap year pattern, a bit-based 1=true pattern. */\n+        final int pattern;\n+        \n+        /**\n+         * Constructor.\n+         * This constructor takes a bit pattern where bits 0-29 correspond\n+         * to years 0-29 in the 30 year Islamic cycle of years. This allows\n+         * a highly efficient lookup by bit-matching.\n+         *\n+         * @param index  the index\n+         * @param pattern  the bit pattern\n+         */\n+        protected LeapYearPatternType(int index, int pattern) {\n+            super();\n+            this.index = (byte) index;\n+            this.pattern = pattern;\n+        }\n+        \n+        /**\n+         * Is the year a leap year.\n+         * @param year  the year to query\n+         * @return true if leap\n+         */\n+        public boolean isLeapYear(int year) {\n+            int key = 1 << (year % 30);\n+            return ((pattern & key) > 0);\n+        }\n+        \n+        /**\n+         * Ensure a singleton is returned if possible.\n+         * @return the singleton instance\n+         */\n+        private Object readResolve() {\n+            switch (index) {\n+                case 0:\n+                    return LEAP_YEAR_15_BASED;\n+                case 1:\n+                    return LEAP_YEAR_16_BASED;\n+                case 2:\n+                    return LEAP_YEAR_INDIAN;\n+                case 3:\n+                    return LEAP_YEAR_HABASH_AL_HASIB;\n+                default:\n+                    return this;\n+            }\n+        }\n+    }\n+}\n--- a/JodaTime/src/test/org/joda/time/chrono/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/chrono/TestAll.java\n         suite.addTest(TestEthiopicChronology.suite());\n         suite.addTest(TestGJChronology.suite());\n         suite.addTest(TestGregorianChronology.suite());\n+        suite.addTest(TestIslamicChronology.suite());\n         suite.addTest(TestJulianChronology.suite());\n         suite.addTest(TestISOChronology.suite());\n         \n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/TestIslamicChronology.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationFieldType;\n+import org.joda.time.DateTime.Property;\n+\n+/**\n+ * This class is a Junit unit test for IslamicChronology.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestIslamicChronology extends TestCase {\n+\n+    private static long SKIP = 1 * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n+    private static final DateTimeZone TOKYO = DateTimeZone.forID(\"Asia/Tokyo\");\n+    private static final Chronology ISLAMIC_UTC = IslamicChronology.getInstanceUTC();\n+    private static final Chronology JULIAN_UTC = JulianChronology.getInstanceUTC();\n+    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();\n+\n+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365;\n+    // 2002-06-09\n+    private long TEST_TIME_NOW =\n+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    private DateTimeZone originalDateTimeZone = null;\n+    private TimeZone originalTimeZone = null;\n+    private Locale originalLocale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        SKIP = 1 * DateTimeConstants.MILLIS_PER_DAY;\n+        return new TestSuite(TestIslamicChronology.class);\n+    }\n+\n+    public TestIslamicChronology(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        originalDateTimeZone = DateTimeZone.getDefault();\n+        originalTimeZone = TimeZone.getDefault();\n+        originalLocale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n+        Locale.setDefault(Locale.UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(originalDateTimeZone);\n+        TimeZone.setDefault(originalTimeZone);\n+        Locale.setDefault(originalLocale);\n+        originalDateTimeZone = null;\n+        originalTimeZone = null;\n+        originalLocale = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactoryUTC() {\n+        assertEquals(DateTimeZone.UTC, IslamicChronology.getInstanceUTC().getZone());\n+        assertSame(IslamicChronology.class, IslamicChronology.getInstanceUTC().getClass());\n+    }\n+\n+    public void testFactory() {\n+        assertEquals(LONDON, IslamicChronology.getInstance().getZone());\n+        assertSame(IslamicChronology.class, IslamicChronology.getInstance().getClass());\n+    }\n+\n+    public void testFactory_Zone() {\n+        assertEquals(TOKYO, IslamicChronology.getInstance(TOKYO).getZone());\n+        assertEquals(PARIS, IslamicChronology.getInstance(PARIS).getZone());\n+        assertEquals(LONDON, IslamicChronology.getInstance(null).getZone());\n+        assertSame(IslamicChronology.class, IslamicChronology.getInstance(TOKYO).getClass());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEquality() {\n+        assertSame(IslamicChronology.getInstance(TOKYO), IslamicChronology.getInstance(TOKYO));\n+        assertSame(IslamicChronology.getInstance(LONDON), IslamicChronology.getInstance(LONDON));\n+        assertSame(IslamicChronology.getInstance(PARIS), IslamicChronology.getInstance(PARIS));\n+        assertSame(IslamicChronology.getInstanceUTC(), IslamicChronology.getInstanceUTC());\n+        assertSame(IslamicChronology.getInstance(), IslamicChronology.getInstance(LONDON));\n+    }\n+\n+    public void testWithUTC() {\n+        assertSame(IslamicChronology.getInstanceUTC(), IslamicChronology.getInstance(LONDON).withUTC());\n+        assertSame(IslamicChronology.getInstanceUTC(), IslamicChronology.getInstance(TOKYO).withUTC());\n+        assertSame(IslamicChronology.getInstanceUTC(), IslamicChronology.getInstanceUTC().withUTC());\n+        assertSame(IslamicChronology.getInstanceUTC(), IslamicChronology.getInstance().withUTC());\n+    }\n+\n+    public void testWithZone() {\n+        assertSame(IslamicChronology.getInstance(TOKYO), IslamicChronology.getInstance(TOKYO).withZone(TOKYO));\n+        assertSame(IslamicChronology.getInstance(LONDON), IslamicChronology.getInstance(TOKYO).withZone(LONDON));\n+        assertSame(IslamicChronology.getInstance(PARIS), IslamicChronology.getInstance(TOKYO).withZone(PARIS));\n+        assertSame(IslamicChronology.getInstance(LONDON), IslamicChronology.getInstance(TOKYO).withZone(null));\n+        assertSame(IslamicChronology.getInstance(PARIS), IslamicChronology.getInstance().withZone(PARIS));\n+        assertSame(IslamicChronology.getInstance(PARIS), IslamicChronology.getInstanceUTC().withZone(PARIS));\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"IslamicChronology[Europe/London]\", IslamicChronology.getInstance(LONDON).toString());\n+        assertEquals(\"IslamicChronology[Asia/Tokyo]\", IslamicChronology.getInstance(TOKYO).toString());\n+        assertEquals(\"IslamicChronology[Europe/London]\", IslamicChronology.getInstance().toString());\n+        assertEquals(\"IslamicChronology[UTC]\", IslamicChronology.getInstanceUTC().toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDurationFields() {\n+        assertEquals(\"eras\", IslamicChronology.getInstance().eras().getName());\n+        assertEquals(\"centuries\", IslamicChronology.getInstance().centuries().getName());\n+        assertEquals(\"years\", IslamicChronology.getInstance().years().getName());\n+        assertEquals(\"weekyears\", IslamicChronology.getInstance().weekyears().getName());\n+        assertEquals(\"months\", IslamicChronology.getInstance().months().getName());\n+        assertEquals(\"weeks\", IslamicChronology.getInstance().weeks().getName());\n+        assertEquals(\"days\", IslamicChronology.getInstance().days().getName());\n+        assertEquals(\"halfdays\", IslamicChronology.getInstance().halfdays().getName());\n+        assertEquals(\"hours\", IslamicChronology.getInstance().hours().getName());\n+        assertEquals(\"minutes\", IslamicChronology.getInstance().minutes().getName());\n+        assertEquals(\"seconds\", IslamicChronology.getInstance().seconds().getName());\n+        assertEquals(\"millis\", IslamicChronology.getInstance().millis().getName());\n+        \n+        assertEquals(false, IslamicChronology.getInstance().eras().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().centuries().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().years().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().weekyears().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().months().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().weeks().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().days().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().halfdays().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().hours().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().minutes().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().seconds().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().millis().isSupported());\n+        \n+        assertEquals(false, IslamicChronology.getInstance().centuries().isPrecise());\n+        assertEquals(false, IslamicChronology.getInstance().years().isPrecise());\n+        assertEquals(false, IslamicChronology.getInstance().weekyears().isPrecise());\n+        assertEquals(false, IslamicChronology.getInstance().months().isPrecise());\n+        assertEquals(false, IslamicChronology.getInstance().weeks().isPrecise());\n+        assertEquals(false, IslamicChronology.getInstance().days().isPrecise());\n+        assertEquals(false, IslamicChronology.getInstance().halfdays().isPrecise());\n+        assertEquals(true, IslamicChronology.getInstance().hours().isPrecise());\n+        assertEquals(true, IslamicChronology.getInstance().minutes().isPrecise());\n+        assertEquals(true, IslamicChronology.getInstance().seconds().isPrecise());\n+        assertEquals(true, IslamicChronology.getInstance().millis().isPrecise());\n+        \n+        assertEquals(false, IslamicChronology.getInstanceUTC().centuries().isPrecise());\n+        assertEquals(false, IslamicChronology.getInstanceUTC().years().isPrecise());\n+        assertEquals(false, IslamicChronology.getInstanceUTC().weekyears().isPrecise());\n+        assertEquals(false, IslamicChronology.getInstanceUTC().months().isPrecise());\n+        assertEquals(true, IslamicChronology.getInstanceUTC().weeks().isPrecise());\n+        assertEquals(true, IslamicChronology.getInstanceUTC().days().isPrecise());\n+        assertEquals(true, IslamicChronology.getInstanceUTC().halfdays().isPrecise());\n+        assertEquals(true, IslamicChronology.getInstanceUTC().hours().isPrecise());\n+        assertEquals(true, IslamicChronology.getInstanceUTC().minutes().isPrecise());\n+        assertEquals(true, IslamicChronology.getInstanceUTC().seconds().isPrecise());\n+        assertEquals(true, IslamicChronology.getInstanceUTC().millis().isPrecise());\n+    }\n+\n+    public void testDateFields() {\n+        assertEquals(\"era\", IslamicChronology.getInstance().era().getName());\n+        assertEquals(\"centuryOfEra\", IslamicChronology.getInstance().centuryOfEra().getName());\n+        assertEquals(\"yearOfCentury\", IslamicChronology.getInstance().yearOfCentury().getName());\n+        assertEquals(\"yearOfEra\", IslamicChronology.getInstance().yearOfEra().getName());\n+        assertEquals(\"year\", IslamicChronology.getInstance().year().getName());\n+        assertEquals(\"monthOfYear\", IslamicChronology.getInstance().monthOfYear().getName());\n+        assertEquals(\"weekyearOfCentury\", IslamicChronology.getInstance().weekyearOfCentury().getName());\n+        assertEquals(\"weekyear\", IslamicChronology.getInstance().weekyear().getName());\n+        assertEquals(\"weekOfWeekyear\", IslamicChronology.getInstance().weekOfWeekyear().getName());\n+        assertEquals(\"dayOfYear\", IslamicChronology.getInstance().dayOfYear().getName());\n+        assertEquals(\"dayOfMonth\", IslamicChronology.getInstance().dayOfMonth().getName());\n+        assertEquals(\"dayOfWeek\", IslamicChronology.getInstance().dayOfWeek().getName());\n+        \n+        assertEquals(true, IslamicChronology.getInstance().era().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().centuryOfEra().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().yearOfCentury().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().yearOfEra().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().year().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().monthOfYear().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().weekyearOfCentury().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().weekyear().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().weekOfWeekyear().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().dayOfYear().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().dayOfMonth().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().dayOfWeek().isSupported());\n+    }\n+\n+    public void testTimeFields() {\n+        assertEquals(\"halfdayOfDay\", IslamicChronology.getInstance().halfdayOfDay().getName());\n+        assertEquals(\"clockhourOfHalfday\", IslamicChronology.getInstance().clockhourOfHalfday().getName());\n+        assertEquals(\"hourOfHalfday\", IslamicChronology.getInstance().hourOfHalfday().getName());\n+        assertEquals(\"clockhourOfDay\", IslamicChronology.getInstance().clockhourOfDay().getName());\n+        assertEquals(\"hourOfDay\", IslamicChronology.getInstance().hourOfDay().getName());\n+        assertEquals(\"minuteOfDay\", IslamicChronology.getInstance().minuteOfDay().getName());\n+        assertEquals(\"minuteOfHour\", IslamicChronology.getInstance().minuteOfHour().getName());\n+        assertEquals(\"secondOfDay\", IslamicChronology.getInstance().secondOfDay().getName());\n+        assertEquals(\"secondOfMinute\", IslamicChronology.getInstance().secondOfMinute().getName());\n+        assertEquals(\"millisOfDay\", IslamicChronology.getInstance().millisOfDay().getName());\n+        assertEquals(\"millisOfSecond\", IslamicChronology.getInstance().millisOfSecond().getName());\n+        \n+        assertEquals(true, IslamicChronology.getInstance().halfdayOfDay().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().clockhourOfHalfday().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().hourOfHalfday().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().clockhourOfDay().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().hourOfDay().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().minuteOfDay().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().minuteOfHour().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().secondOfDay().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().secondOfMinute().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().millisOfDay().isSupported());\n+        assertEquals(true, IslamicChronology.getInstance().millisOfSecond().isSupported());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEpoch() {\n+        DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, ISLAMIC_UTC);\n+        DateTime expectedEpoch = new DateTime(622, 7, 16, 0, 0, 0, 0, JULIAN_UTC);\n+        assertEquals(expectedEpoch.getMillis(), epoch.getMillis());\n+    }\n+\n+    public void testEra() {\n+        assertEquals(1, IslamicChronology.AH);\n+        try {\n+            new DateTime(-1, 13, 5, 0, 0, 0, 0, ISLAMIC_UTC);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFieldConstructor() {\n+        DateTime date = new DateTime(1364, 12, 6, 0, 0, 0, 0, ISLAMIC_UTC);\n+        DateTime expectedDate = new DateTime(1945, 11, 12, 0, 0, 0, 0, ISO_UTC);\n+        assertEquals(expectedDate.getMillis(), date.getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests era, year, monthOfYear, dayOfMonth and dayOfWeek.\n+     */\n+    public void testCalendar() {\n+        if (TestAll.FAST) {\n+            return;\n+        }\n+        System.out.println(\"\\nTestIslamicChronology.testCalendar\");\n+        DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, ISLAMIC_UTC);\n+        long millis = epoch.getMillis();\n+        long end = new DateTime(3000, 1, 1, 0, 0, 0, 0, ISO_UTC).getMillis();\n+        DateTimeField dayOfWeek = ISLAMIC_UTC.dayOfWeek();\n+        DateTimeField dayOfYear = ISLAMIC_UTC.dayOfYear();\n+        DateTimeField dayOfMonth = ISLAMIC_UTC.dayOfMonth();\n+        DateTimeField monthOfYear = ISLAMIC_UTC.monthOfYear();\n+        DateTimeField year = ISLAMIC_UTC.year();\n+        DateTimeField yearOfEra = ISLAMIC_UTC.yearOfEra();\n+        DateTimeField era = ISLAMIC_UTC.era();\n+        int expectedDOW = new DateTime(622, 7, 16, 0, 0, 0, 0, JULIAN_UTC).getDayOfWeek();\n+        int expectedDOY = 1;\n+        int expectedDay = 1;\n+        int expectedMonth = 1;\n+        int expectedYear = 1;\n+        while (millis < end) {\n+            int dowValue = dayOfWeek.get(millis);\n+            int doyValue = dayOfYear.get(millis);\n+            int dayValue = dayOfMonth.get(millis);\n+            int monthValue = monthOfYear.get(millis);\n+            int yearValue = year.get(millis);\n+            int yearOfEraValue = yearOfEra.get(millis);\n+            int dayOfYearLen = dayOfYear.getMaximumValue(millis);\n+            int monthLen = dayOfMonth.getMaximumValue(millis);\n+            if (monthValue < 1 || monthValue > 12) {\n+                fail(\"Bad month: \" + millis);\n+            }\n+            \n+            // test era\n+            assertEquals(1, era.get(millis));\n+            assertEquals(\"AH\", era.getAsText(millis));\n+            assertEquals(\"AH\", era.getAsShortText(millis));\n+            \n+            // test date\n+            assertEquals(expectedDOY, doyValue);\n+            assertEquals(expectedMonth, monthValue);\n+            assertEquals(expectedDay, dayValue);\n+            assertEquals(expectedDOW, dowValue);\n+            assertEquals(expectedYear, yearValue);\n+            assertEquals(expectedYear, yearOfEraValue);\n+            \n+            // test leap year\n+            boolean leap = ((11 * yearValue + 14) % 30) < 11;\n+            assertEquals(leap, year.isLeap(millis));\n+            \n+            // test month length\n+            switch (monthValue) {\n+                case 1:\n+                case 3:\n+                case 5:\n+                case 7:\n+                case 9:\n+                case 11:\n+                    assertEquals(30, monthLen);\n+                    break;\n+                case 2:\n+                case 4:\n+                case 6:\n+                case 8:\n+                case 10:\n+                    assertEquals(29, monthLen);\n+                    break;\n+                case 12:\n+                    assertEquals((leap ? 30 : 29), monthLen);\n+                    break;\n+            }\n+            \n+            // test year length\n+            assertEquals((leap ? 355 : 354), dayOfYearLen);\n+            \n+            // recalculate date\n+            expectedDOW = (((expectedDOW + 1) - 1) % 7) + 1;\n+            expectedDay++;\n+            expectedDOY++;\n+            if (expectedDay > monthLen) {\n+                expectedDay = 1;\n+                expectedMonth++;\n+                if (expectedMonth == 13) {\n+                    expectedMonth = 1;\n+                    expectedDOY = 1;\n+                    expectedYear++;\n+                }\n+            }\n+            millis += SKIP;\n+        }\n+    }\n+\n+    public void testSampleDate1() {\n+        DateTime dt = new DateTime(1945, 11, 12, 0, 0, 0, 0, ISO_UTC);\n+        dt = dt.withChronology(ISLAMIC_UTC);\n+        assertEquals(IslamicChronology.AH, dt.getEra());\n+        assertEquals(14, dt.getCenturyOfEra());  // TODO confirm\n+        assertEquals(64, dt.getYearOfCentury());\n+        assertEquals(1364, dt.getYearOfEra());\n+        \n+        assertEquals(1364, dt.getYear());\n+        Property fld = dt.year();\n+        assertEquals(false, fld.isLeap());\n+        assertEquals(0, fld.getLeapAmount());\n+        assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType());\n+        assertEquals(new DateTime(1365, 12, 6, 0, 0, 0, 0, ISLAMIC_UTC), fld.addToCopy(1));\n+        \n+        assertEquals(12, dt.getMonthOfYear());\n+        fld = dt.monthOfYear();\n+        assertEquals(false, fld.isLeap());\n+        assertEquals(0, fld.getLeapAmount());\n+        assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType());\n+        assertEquals(1, fld.getMinimumValue());\n+        assertEquals(1, fld.getMinimumValueOverall());\n+        assertEquals(12, fld.getMaximumValue());\n+        assertEquals(12, fld.getMaximumValueOverall());\n+        assertEquals(new DateTime(1365, 1, 6, 0, 0, 0, 0, ISLAMIC_UTC), fld.addToCopy(1));\n+        assertEquals(new DateTime(1364, 1, 6, 0, 0, 0, 0, ISLAMIC_UTC), fld.addWrapFieldToCopy(1));\n+        \n+        assertEquals(6, dt.getDayOfMonth());\n+        fld = dt.dayOfMonth();\n+        assertEquals(false, fld.isLeap());\n+        assertEquals(0, fld.getLeapAmount());\n+        assertEquals(null, fld.getLeapDurationField());\n+        assertEquals(1, fld.getMinimumValue());\n+        assertEquals(1, fld.getMinimumValueOverall());\n+        assertEquals(29, fld.getMaximumValue());\n+        assertEquals(30, fld.getMaximumValueOverall());\n+        assertEquals(new DateTime(1364, 12, 7, 0, 0, 0, 0, ISLAMIC_UTC), fld.addToCopy(1));\n+        \n+        assertEquals(DateTimeConstants.MONDAY, dt.getDayOfWeek());\n+        fld = dt.dayOfWeek();\n+        assertEquals(false, fld.isLeap());\n+        assertEquals(0, fld.getLeapAmount());\n+        assertEquals(null, fld.getLeapDurationField());\n+        assertEquals(1, fld.getMinimumValue());\n+        assertEquals(1, fld.getMinimumValueOverall());\n+        assertEquals(7, fld.getMaximumValue());\n+        assertEquals(7, fld.getMaximumValueOverall());\n+        assertEquals(new DateTime(1364, 12, 7, 0, 0, 0, 0, ISLAMIC_UTC), fld.addToCopy(1));\n+        \n+        assertEquals(6 * 30 + 5 * 29 + 6, dt.getDayOfYear());\n+        fld = dt.dayOfYear();\n+        assertEquals(false, fld.isLeap());\n+        assertEquals(0, fld.getLeapAmount());\n+        assertEquals(null, fld.getLeapDurationField());\n+        assertEquals(1, fld.getMinimumValue());\n+        assertEquals(1, fld.getMinimumValueOverall());\n+        assertEquals(354, fld.getMaximumValue());\n+        assertEquals(355, fld.getMaximumValueOverall());\n+        assertEquals(new DateTime(1364, 12, 7, 0, 0, 0, 0, ISLAMIC_UTC), fld.addToCopy(1));\n+        \n+        assertEquals(0, dt.getHourOfDay());\n+        assertEquals(0, dt.getMinuteOfHour());\n+        assertEquals(0, dt.getSecondOfMinute());\n+        assertEquals(0, dt.getMillisOfSecond());\n+    }\n+\n+    public void testSampleDate2() {\n+        DateTime dt = new DateTime(2005, 11, 26, 0, 0, 0, 0, ISO_UTC);\n+        dt = dt.withChronology(ISLAMIC_UTC);\n+        assertEquals(IslamicChronology.AH, dt.getEra());\n+        assertEquals(15, dt.getCenturyOfEra());  // TODO confirm\n+        assertEquals(26, dt.getYearOfCentury());\n+        assertEquals(1426, dt.getYearOfEra());\n+        \n+        assertEquals(1426, dt.getYear());\n+        Property fld = dt.year();\n+        assertEquals(true, fld.isLeap());\n+        assertEquals(1, fld.getLeapAmount());\n+        assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType());\n+        \n+        assertEquals(10, dt.getMonthOfYear());\n+        fld = dt.monthOfYear();\n+        assertEquals(false, fld.isLeap());\n+        assertEquals(0, fld.getLeapAmount());\n+        assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType());\n+        assertEquals(1, fld.getMinimumValue());\n+        assertEquals(1, fld.getMinimumValueOverall());\n+        assertEquals(12, fld.getMaximumValue());\n+        assertEquals(12, fld.getMaximumValueOverall());\n+        \n+        assertEquals(24, dt.getDayOfMonth());\n+        fld = dt.dayOfMonth();\n+        assertEquals(false, fld.isLeap());\n+        assertEquals(0, fld.getLeapAmount());\n+        assertEquals(null, fld.getLeapDurationField());\n+        assertEquals(1, fld.getMinimumValue());\n+        assertEquals(1, fld.getMinimumValueOverall());\n+        assertEquals(29, fld.getMaximumValue());\n+        assertEquals(30, fld.getMaximumValueOverall());\n+        \n+        assertEquals(DateTimeConstants.SATURDAY, dt.getDayOfWeek());\n+        fld = dt.dayOfWeek();\n+        assertEquals(false, fld.isLeap());\n+        assertEquals(0, fld.getLeapAmount());\n+        assertEquals(null, fld.getLeapDurationField());\n+        assertEquals(1, fld.getMinimumValue());\n+        assertEquals(1, fld.getMinimumValueOverall());\n+        assertEquals(7, fld.getMaximumValue());\n+        assertEquals(7, fld.getMaximumValueOverall());\n+        \n+        assertEquals(5 * 30 + 4 * 29 + 24, dt.getDayOfYear());\n+        fld = dt.dayOfYear();\n+        assertEquals(false, fld.isLeap());\n+        assertEquals(0, fld.getLeapAmount());\n+        assertEquals(null, fld.getLeapDurationField());\n+        assertEquals(1, fld.getMinimumValue());\n+        assertEquals(1, fld.getMinimumValueOverall());\n+        assertEquals(355, fld.getMaximumValue());\n+        assertEquals(355, fld.getMaximumValueOverall());\n+        \n+        assertEquals(0, dt.getHourOfDay());\n+        assertEquals(0, dt.getMinuteOfHour());\n+        assertEquals(0, dt.getSecondOfMinute());\n+        assertEquals(0, dt.getMillisOfSecond());\n+    }\n+\n+    public void testSampleDate3() {\n+        DateTime dt = new DateTime(1426, 12, 24, 0, 0, 0, 0, ISLAMIC_UTC);\n+        assertEquals(IslamicChronology.AH, dt.getEra());\n+        \n+        assertEquals(1426, dt.getYear());\n+        Property fld = dt.year();\n+        assertEquals(true, fld.isLeap());\n+        assertEquals(1, fld.getLeapAmount());\n+        assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType());\n+        \n+        assertEquals(12, dt.getMonthOfYear());\n+        fld = dt.monthOfYear();\n+        assertEquals(true, fld.isLeap());\n+        assertEquals(1, fld.getLeapAmount());\n+        assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType());\n+        assertEquals(1, fld.getMinimumValue());\n+        assertEquals(1, fld.getMinimumValueOverall());\n+        assertEquals(12, fld.getMaximumValue());\n+        assertEquals(12, fld.getMaximumValueOverall());\n+        \n+        assertEquals(24, dt.getDayOfMonth());\n+        fld = dt.dayOfMonth();\n+        assertEquals(false, fld.isLeap());\n+        assertEquals(0, fld.getLeapAmount());\n+        assertEquals(null, fld.getLeapDurationField());\n+        assertEquals(1, fld.getMinimumValue());\n+        assertEquals(1, fld.getMinimumValueOverall());\n+        assertEquals(30, fld.getMaximumValue());\n+        assertEquals(30, fld.getMaximumValueOverall());\n+        \n+        assertEquals(DateTimeConstants.TUESDAY, dt.getDayOfWeek());\n+        fld = dt.dayOfWeek();\n+        assertEquals(false, fld.isLeap());\n+        assertEquals(0, fld.getLeapAmount());\n+        assertEquals(null, fld.getLeapDurationField());\n+        assertEquals(1, fld.getMinimumValue());\n+        assertEquals(1, fld.getMinimumValueOverall());\n+        assertEquals(7, fld.getMaximumValue());\n+        assertEquals(7, fld.getMaximumValueOverall());\n+        \n+        assertEquals(6 * 30 + 5 * 29 + 24, dt.getDayOfYear());\n+        fld = dt.dayOfYear();\n+        assertEquals(false, fld.isLeap());\n+        assertEquals(0, fld.getLeapAmount());\n+        assertEquals(null, fld.getLeapDurationField());\n+        assertEquals(1, fld.getMinimumValue());\n+        assertEquals(1, fld.getMinimumValueOverall());\n+        assertEquals(355, fld.getMaximumValue());\n+        assertEquals(355, fld.getMaximumValueOverall());\n+        \n+        assertEquals(0, dt.getHourOfDay());\n+        assertEquals(0, dt.getMinuteOfHour());\n+        assertEquals(0, dt.getSecondOfMinute());\n+        assertEquals(0, dt.getMillisOfSecond());\n+    }\n+\n+    public void testSampleDateWithZone() {\n+        DateTime dt = new DateTime(2005, 11, 26, 12, 0, 0, 0, PARIS).withChronology(ISLAMIC_UTC);\n+        assertEquals(IslamicChronology.AH, dt.getEra());\n+        assertEquals(1426, dt.getYear());\n+        assertEquals(10, dt.getMonthOfYear());\n+        assertEquals(24, dt.getDayOfMonth());\n+        assertEquals(11, dt.getHourOfDay());  // PARIS is UTC+1 in summer (12-1=11)\n+        assertEquals(0, dt.getMinuteOfHour());\n+        assertEquals(0, dt.getSecondOfMinute());\n+        assertEquals(0, dt.getMillisOfSecond());\n+    }\n+\n+    public void test15BasedLeapYear() {\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(1));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(2));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(3));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(4));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(5));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(6));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(7));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(8));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(9));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(10));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(11));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(12));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(13));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(14));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(15));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(16));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(17));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(18));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(19));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(20));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(21));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(22));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(23));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(24));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(25));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(26));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(27));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(28));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(29));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(30));\n+    }\n+\n+    public void test16BasedLeapYear() {\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(1));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(2));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(3));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(4));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(5));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(6));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(7));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(8));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(9));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(10));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(11));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(12));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(13));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(14));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(15));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(16));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(17));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(18));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(19));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(20));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(21));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(22));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(23));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(24));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(25));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(26));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(27));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(28));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(29));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(30));\n+    }\n+\n+    public void testIndianBasedLeapYear() {\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(1));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(2));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(3));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(4));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(5));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(6));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(7));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(8));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(9));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(10));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(11));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(12));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(13));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(14));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(15));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(16));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(17));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(18));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(19));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(20));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(21));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(22));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(23));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(24));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(25));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(26));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(27));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(28));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(29));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(30));\n+    }\n+\n+    public void testHabashAlHasibBasedLeapYear() {\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(1));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(2));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(3));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(4));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(5));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(6));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(7));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(8));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(9));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(10));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(11));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(12));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(13));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(14));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(15));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(16));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(17));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(18));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(19));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(20));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(21));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(22));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(23));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(24));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(25));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(26));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(27));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(28));\n+        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(29));\n+        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(30));\n+    }\n+\n+}", "timestamp": 1133044703, "metainfo": ""}