{"sha": "76911720755b6300f36426e83a4c7a6fb052ae63", "log": "Avoid supporting invalid fields like hourOfYear   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/LocalTime.java\n+++ b/JodaTime/src/java/org/joda/time/LocalTime.java\n         if (type == null) {\n             return false;\n         }\n-        return isSupported(type.getDurationType());\n+        if (isSupported(type.getDurationType()) == false) {\n+            return false;\n+        }\n+        DurationFieldType range = type.getRangeDurationType();\n+        return (isSupported(range) || range == DurationFieldType.days());\n     }\n \n     /**\n--- a/JodaTime/src/test/org/joda/time/TestLocalTime_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestLocalTime_Basics.java\n import org.joda.time.chrono.BuddhistChronology;\n import org.joda.time.chrono.CopticChronology;\n import org.joda.time.chrono.GregorianChronology;\n-import org.joda.time.chrono.ISOChronology;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n     private static final Chronology COPTIC_LONDON = CopticChronology.getInstance(LONDON);\n     private static final Chronology COPTIC_TOKYO = CopticChronology.getInstance(TOKYO);\n     private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC();\n-    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);\n-    private static final Chronology ISO_LONDON = ISOChronology.getInstance(LONDON);\n-    private static final Chronology ISO_TOKYO = ISOChronology.getInstance(TOKYO);\n-    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();\n-    private static final Chronology BUDDHIST_PARIS = BuddhistChronology.getInstance(PARIS);\n     private static final Chronology BUDDHIST_LONDON = BuddhistChronology.getInstance(LONDON);\n-    private static final Chronology BUDDHIST_TOKYO = BuddhistChronology.getInstance(TOKYO);\n-    private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC();\n \n     private long TEST_TIME_NOW =\n             10L * DateTimeConstants.MILLIS_PER_HOUR\n             + 30L * DateTimeConstants.MILLIS_PER_SECOND\n             + 40L;\n \n-    private long TEST_TIME1 =\n-        1L * DateTimeConstants.MILLIS_PER_HOUR\n-        + 2L * DateTimeConstants.MILLIS_PER_MINUTE\n-        + 3L * DateTimeConstants.MILLIS_PER_SECOND\n-        + 4L;\n+//    private long TEST_TIME1 =\n+//        1L * DateTimeConstants.MILLIS_PER_HOUR\n+//        + 2L * DateTimeConstants.MILLIS_PER_MINUTE\n+//        + 3L * DateTimeConstants.MILLIS_PER_SECOND\n+//        + 4L;\n \n     private long TEST_TIME2 =\n         1L * DateTimeConstants.MILLIS_PER_DAY\n         \n         assertEquals(false, test.isSupported(DateTimeFieldType.dayOfMonth()));\n         assertEquals(false, test.isSupported((DateTimeFieldType) null));\n+        \n+        DateTimeFieldType d = new DateTimeFieldType(\"hours\") {\n+            public DurationFieldType getDurationType() {\n+                return DurationFieldType.hours();\n+            }\n+            public DurationFieldType getRangeDurationType() {\n+                return null;\n+            }\n+            public DateTimeField getField(Chronology chronology) {\n+                return chronology.hourOfDay();\n+            }\n+        };\n+        assertEquals(false, test.isSupported(d));\n+        \n+        d = new DateTimeFieldType(\"hourOfYear\") {\n+            public DurationFieldType getDurationType() {\n+                return DurationFieldType.hours();\n+            }\n+            public DurationFieldType getRangeDurationType() {\n+                return DurationFieldType.years();\n+            }\n+            public DateTimeField getField(Chronology chronology) {\n+                return chronology.hourOfDay();\n+            }\n+        };\n+        assertEquals(false, test.isSupported(d));\n     }\n \n     public void testIsSupported_DurationFieldType() {", "timestamp": 1139872356, "metainfo": ""}