{"sha": "9c0781d414b9eee98f78d168b5db6c2cdda5147d", "log": "Rename BaseGJChronology to BasicChronology, ensuring serialization OK   ", "commit": "\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicChronology.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n+import org.joda.time.field.DividedDateTimeField;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.field.MillisDurationField;\n+import org.joda.time.field.ZeroIsMaxDateTimeField;\n+import org.joda.time.field.OffsetDateTimeField;\n+import org.joda.time.field.PreciseDateTimeField;\n+import org.joda.time.field.PreciseDurationField;\n+import org.joda.time.field.RemainderDateTimeField;\n+\n+/**\n+ * Abstract implementation for calendar systems that use a typical\n+ * day/month/year/leapYear model.\n+ * Most of the utility methods required by subclasses are package-private,\n+ * reflecting the intention that they be defined in the same package.\n+ * <p>\n+ * BasicChronology is thread-safe and immutable, and all subclasses must\n+ * be as well.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @author Guy Allard\n+ * @since 1.2, renamed from BaseGJChronology\n+ */\n+abstract class BasicChronology extends AssembledChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = 8283225332206808863L;\n+\n+    private static final DurationField cMillisField;\n+    private static final DurationField cSecondsField;\n+    private static final DurationField cMinutesField;\n+    private static final DurationField cHoursField;\n+    private static final DurationField cHalfdaysField;\n+    private static final DurationField cDaysField;\n+    private static final DurationField cWeeksField;\n+\n+    private static final DateTimeField cMillisOfSecondField;\n+    private static final DateTimeField cMillisOfDayField;\n+    private static final DateTimeField cSecondOfMinuteField;\n+    private static final DateTimeField cSecondOfDayField;\n+    private static final DateTimeField cMinuteOfHourField;\n+    private static final DateTimeField cMinuteOfDayField;\n+    private static final DateTimeField cHourOfDayField;\n+    private static final DateTimeField cHourOfHalfdayField;\n+    private static final DateTimeField cClockhourOfDayField;\n+    private static final DateTimeField cClockhourOfHalfdayField;\n+    private static final DateTimeField cHalfdayOfDayField;\n+\n+    static {\n+        cMillisField = MillisDurationField.INSTANCE;\n+        cSecondsField = new PreciseDurationField\n+            (DurationFieldType.seconds(), DateTimeConstants.MILLIS_PER_SECOND);\n+        cMinutesField = new PreciseDurationField\n+            (DurationFieldType.minutes(), DateTimeConstants.MILLIS_PER_MINUTE);\n+        cHoursField = new PreciseDurationField\n+            (DurationFieldType.hours(), DateTimeConstants.MILLIS_PER_HOUR);\n+        cHalfdaysField = new PreciseDurationField\n+            (DurationFieldType.halfdays(), DateTimeConstants.MILLIS_PER_DAY / 2);\n+        cDaysField = new PreciseDurationField\n+            (DurationFieldType.days(), DateTimeConstants.MILLIS_PER_DAY);\n+        cWeeksField = new PreciseDurationField\n+            (DurationFieldType.weeks(), DateTimeConstants.MILLIS_PER_WEEK);\n+\n+        cMillisOfSecondField = new PreciseDateTimeField\n+            (DateTimeFieldType.millisOfSecond(), cMillisField, cSecondsField);\n+\n+        cMillisOfDayField = new PreciseDateTimeField\n+            (DateTimeFieldType.millisOfDay(), cMillisField, cDaysField);\n+             \n+        cSecondOfMinuteField = new PreciseDateTimeField\n+            (DateTimeFieldType.secondOfMinute(), cSecondsField, cMinutesField);\n+\n+        cSecondOfDayField = new PreciseDateTimeField\n+            (DateTimeFieldType.secondOfDay(), cSecondsField, cDaysField);\n+\n+        cMinuteOfHourField = new PreciseDateTimeField\n+            (DateTimeFieldType.minuteOfHour(), cMinutesField, cHoursField);\n+\n+        cMinuteOfDayField = new PreciseDateTimeField\n+            (DateTimeFieldType.minuteOfDay(), cMinutesField, cDaysField);\n+\n+        cHourOfDayField = new PreciseDateTimeField\n+            (DateTimeFieldType.hourOfDay(), cHoursField, cDaysField);\n+\n+        cHourOfHalfdayField = new PreciseDateTimeField\n+            (DateTimeFieldType.hourOfHalfday(), cHoursField, cHalfdaysField);\n+\n+        cClockhourOfDayField = new ZeroIsMaxDateTimeField\n+            (cHourOfDayField, DateTimeFieldType.clockhourOfDay());\n+\n+        cClockhourOfHalfdayField = new ZeroIsMaxDateTimeField\n+            (cHourOfHalfdayField, DateTimeFieldType.clockhourOfHalfday());\n+\n+        cHalfdayOfDayField = new HalfdayField();\n+    }\n+\n+    private static final int CACHE_SIZE = 1;\n+    private static final int CACHE_MASK = CACHE_SIZE - 1;\n+\n+    private transient final YearInfo[] iYearInfoCache = new YearInfo[CACHE_SIZE];\n+\n+    private final int iMinDaysInFirstWeek;\n+\n+    BasicChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n+        super(base, param);\n+\n+        if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) {\n+            throw new IllegalArgumentException\n+                (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n+        }\n+\n+        iMinDaysInFirstWeek = minDaysInFirstWeek;\n+    }\n+\n+    public DateTimeZone getZone() {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getZone();\n+        }\n+        return DateTimeZone.UTC;\n+    }\n+\n+    public long getDateTimeMillis(\n+            int year, int monthOfYear, int dayOfMonth, int millisOfDay)\n+            throws IllegalArgumentException {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n+        }\n+\n+        FieldUtils.verifyValueBounds\n+            (DateTimeFieldType.millisOfDay(), millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY);\n+        return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + millisOfDay;\n+    }\n+\n+    public long getDateTimeMillis(\n+            int year, int monthOfYear, int dayOfMonth,\n+            int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond)\n+            throws IllegalArgumentException {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n+                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        }\n+\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23);\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59);\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59);\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999);\n+\n+        return getDateMidnightMillis(year, monthOfYear, dayOfMonth)\n+            + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR\n+            + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE\n+            + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND\n+            + millisOfSecond;\n+    }\n+\n+    public int getMinimumDaysInFirstWeek() {\n+        return iMinDaysInFirstWeek;\n+    }\n+\n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging toString.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        StringBuffer sb = new StringBuffer(60);\n+        String name = getClass().getName();\n+        int index = name.lastIndexOf('.');\n+        if (index >= 0) {\n+            name = name.substring(index + 1);\n+        }\n+        sb.append(name);\n+        sb.append('[');\n+        DateTimeZone zone = getZone();\n+        if (zone != null) {\n+            sb.append(zone.getID());\n+        }\n+        if (getMinimumDaysInFirstWeek() != 4) {\n+            sb.append(\",mdfw=\");\n+            sb.append(getMinimumDaysInFirstWeek());\n+        }\n+        sb.append(']');\n+        return sb.toString();\n+    }\n+\n+    protected void assemble(Fields fields) {\n+        // First copy fields that are the same for all Gregorian and Julian\n+        // chronologies.\n+\n+        fields.millis = cMillisField;\n+        fields.seconds = cSecondsField;\n+        fields.minutes = cMinutesField;\n+        fields.hours = cHoursField;\n+        fields.halfdays = cHalfdaysField;\n+        fields.days = cDaysField;\n+        fields.weeks = cWeeksField;\n+\n+        fields.millisOfSecond = cMillisOfSecondField;\n+        fields.millisOfDay = cMillisOfDayField;\n+        fields.secondOfMinute = cSecondOfMinuteField;\n+        fields.secondOfDay = cSecondOfDayField;\n+        fields.minuteOfHour = cMinuteOfHourField;\n+        fields.minuteOfDay = cMinuteOfDayField;\n+        fields.hourOfDay = cHourOfDayField;\n+        fields.hourOfHalfday = cHourOfHalfdayField;\n+        fields.clockhourOfDay = cClockhourOfDayField;\n+        fields.clockhourOfHalfday = cClockhourOfHalfdayField;\n+        fields.halfdayOfDay = cHalfdayOfDayField;\n+\n+        // Now create fields that have unique behavior for Gregorian and Julian\n+        // chronologies.\n+\n+        fields.year = new BasicYearDateTimeField(this);\n+        fields.yearOfEra = new GJYearOfEraDateTimeField(fields.year, this);\n+\n+        // Define one-based centuryOfEra and yearOfCentury.\n+        DateTimeField field = new OffsetDateTimeField(\n+            fields.yearOfEra, 99);\n+        fields.centuryOfEra = new DividedDateTimeField(\n+            field, DateTimeFieldType.centuryOfEra(), 100);\n+        \n+        field = new RemainderDateTimeField(\n+            (DividedDateTimeField) fields.centuryOfEra);\n+        fields.yearOfCentury = new OffsetDateTimeField(\n+            field, DateTimeFieldType.yearOfCentury(), 1);\n+\n+        fields.era = new GJEraDateTimeField(this);\n+        fields.dayOfWeek = new GJDayOfWeekDateTimeField(this, fields.days);\n+        fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days);\n+        fields.dayOfYear = new BasicDayOfYearDateTimeField(this, fields.days);\n+        fields.monthOfYear = new GJMonthOfYearDateTimeField(this);\n+        fields.weekyear = new BasicWeekyearDateTimeField(this);\n+        fields.weekOfWeekyear = new BasicWeekOfWeekyearDateTimeField(this, fields.weeks);\n+        \n+        field = new RemainderDateTimeField(\n+            fields.weekyear, DateTimeFieldType.weekyearOfCentury(), 100);\n+        fields.weekyearOfCentury = new OffsetDateTimeField(\n+            field, DateTimeFieldType.weekyearOfCentury(), 1);\n+        \n+        // The remaining (imprecise) durations are available from the newly\n+        // created datetime fields.\n+\n+        fields.years = fields.year.getDurationField();\n+        fields.centuries = fields.centuryOfEra.getDurationField();\n+        fields.months = fields.monthOfYear.getDurationField();\n+        fields.weekyears = fields.weekyear.getDurationField();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the number of days in the year.\n+     *\n+     * @return 366\n+     */\n+    int getDaysInYearMax() {\n+        return 366;\n+    }\n+\n+    /**\n+     * Get the number of days in the year.\n+     *\n+     * @param year  the year to use\n+     * @return 366 if a leap year, otherwise 365\n+     */\n+    int getDaysInYear(int year) {\n+        return isLeapYear(year) ? 366 : 365;\n+    }\n+\n+    /**\n+     * Get the number of weeks in the year.\n+     *\n+     * @param year  the year to use\n+     * @return number of weeks in the year\n+     */\n+    int getWeeksInYear(int year) {\n+        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);\n+        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);\n+        return (int) ((firstWeekMillis2 - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK);\n+    }\n+\n+    /**\n+     * Get the millis for the first week of a year.\n+     *\n+     * @param year  the year to use\n+     * @return millis\n+     */\n+    long getFirstWeekOfYearMillis(int year) {\n+        long jan1millis = getYearMillis(year);\n+        int jan1dayOfWeek = getDayOfWeek(jan1millis);\n+        \n+        if (jan1dayOfWeek > (8 - iMinDaysInFirstWeek)) {\n+            // First week is end of previous year because it doesn't have enough days.\n+            return jan1millis + (8 - jan1dayOfWeek)\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+        } else {\n+            // First week is start of this year because it has enough days.\n+            return jan1millis - (jan1dayOfWeek - 1)\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+        }\n+    }\n+\n+    /**\n+     * Get the milliseconds for the start of a year.\n+     *\n+     * @param year The year to use.\n+     * @return millis from 1970-01-01T00:00:00Z\n+     */\n+    long getYearMillis(int year) {\n+        return getYearInfo(year).iFirstDayMillis;\n+    }\n+\n+    /**\n+     * Get the milliseconds for the start of a month.\n+     *\n+     * @param year The year to use.\n+     * @param month The month to use\n+     * @return millis from 1970-01-01T00:00:00Z\n+     */\n+    long getYearMonthMillis(int year, int month) {\n+        long millis = getYearMillis(year);\n+        millis += getTotalMillisByYearMonth(year, month);\n+        return millis;\n+    }\n+\n+    /**\n+     * Get the milliseconds for a particular date.\n+     *\n+     * @param year The year to use.\n+     * @param month The month to use\n+     * @param dayOfMonth The day of the month to use\n+     * @return millis from 1970-01-01T00:00:00Z\n+     */\n+    long getYearMonthDayMillis(int year, int month, int dayOfMonth) {\n+        long millis = getYearMillis(year);\n+        millis += getTotalMillisByYearMonth(year, month);\n+        return millis + (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+    \n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    int getYear(long instant) {\n+        // Get an initial estimate of the year, and the millis value that\n+        // represents the start of that year. Then verify estimate and fix if\n+        // necessary.\n+\n+        long unitMillis = getAverageMillisPerYear();\n+        long i2 = instant + getApproxMillisAtEpoch();\n+        if (i2 < 0) {\n+            i2 = i2 - unitMillis + 1;\n+        }\n+        int year = (int) (i2 / unitMillis);\n+\n+        long yearStart;\n+        try {\n+            yearStart = getYearMillis(year);\n+        } catch (ArithmeticException e) {\n+            if (instant > 0) {\n+                throw new ArithmeticException(\"Instant too large: \" + instant);\n+            } else {\n+                throw new ArithmeticException(\"Instant too small: \" + instant);\n+            }\n+        }\n+\n+        long diff = instant - yearStart;\n+\n+        if (diff < 0) {\n+            year--;\n+        } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {\n+            // One year may need to be added to fix estimate.\n+            long oneYear;\n+            if (isLeapYear(year)) {\n+                oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;\n+            } else {\n+                oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;\n+            }\n+\n+            yearStart += oneYear;\n+\n+            if (yearStart <= instant) {\n+                // Didn't go too far, so actually add one year.\n+                year++;\n+            }\n+        }\n+\n+        return year;\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     */\n+    int getMonthOfYear(long millis) {\n+        return getMonthOfYear(millis, getYear(millis));\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     */\n+    abstract int getMonthOfYear(long millis, int year);\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     */\n+    int getDayOfMonth(long millis) {\n+        int year = getYear(millis);\n+        int month = getMonthOfYear(millis, year);\n+        return getDayOfMonth(millis, year, month);\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     */\n+    int getDayOfMonth(long millis, int year) {\n+        int month = getMonthOfYear(millis, year);\n+        return getDayOfMonth(millis, year, month);\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     * @param month precalculated month of millis\n+     */\n+    int getDayOfMonth(long millis, int year, int month) {\n+        long dateMillis = getYearMillis(year);\n+        dateMillis += getTotalMillisByYearMonth(year, month);\n+        return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    int getDayOfYear(long instant) {\n+        return getDayOfYear(instant, getYear(instant));\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     */\n+    int getDayOfYear(long instant, int year) {\n+        long yearStart = getYearMillis(year);\n+        return (int) ((instant - yearStart) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    int getWeekyear(long instant) {\n+        int year = getYear(instant);\n+        int week = getWeekOfWeekyear(instant, year);\n+        if (week == 1) {\n+            return getYear(instant + DateTimeConstants.MILLIS_PER_WEEK);\n+        } else if (week > 51) {\n+            return getYear(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK));\n+        } else {\n+            return year;\n+        }\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    int getWeekOfWeekyear(long instant) {\n+        return getWeekOfWeekyear(instant, getYear(instant));\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     */\n+    int getWeekOfWeekyear(long instant, int year) {\n+        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);\n+        if (instant < firstWeekMillis1) {\n+            return getWeeksInYear(year - 1);\n+        }\n+        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);\n+        if (instant >= firstWeekMillis2) {\n+            return 1;\n+        }\n+        return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    int getDayOfWeek(long instant) {\n+        // 1970-01-01 is day of week 4, Thursday.\n+\n+        long daysSince19700101;\n+        if (instant >= 0) {\n+            daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY;\n+        } else {\n+            daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1))\n+                / DateTimeConstants.MILLIS_PER_DAY;\n+            if (daysSince19700101 < -3) {\n+                return 7 + (int) ((daysSince19700101 + 4) % 7);\n+            }\n+        }\n+\n+        return 1 + (int) ((daysSince19700101 + 3) % 7);\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    int getMillisOfDay(long instant) {\n+        if (instant >= 0) {\n+            return (int) (instant % DateTimeConstants.MILLIS_PER_DAY);\n+        } else {\n+            return (DateTimeConstants.MILLIS_PER_DAY - 1)\n+                + (int) ((instant + 1) % DateTimeConstants.MILLIS_PER_DAY);\n+        }\n+    }\n+\n+    /**\n+     * Gets the maximum number of days in any month.\n+     * \n+     * @return 31\n+     */\n+    int getDaysInMonthMax() {\n+        return 31;\n+    }\n+\n+    /**\n+     * Gets the maximum number of days in the month specified by the instant.\n+     * \n+     * @param instant  millis from 1970-01-01T00:00:00Z\n+     * @return the maximum number of days in the month\n+     */\n+    int getDaysInMonthMax(long instant) {\n+        int thisYear = getYear(instant);\n+        int thisMonth = getMonthOfYear(instant, thisYear);\n+        return getDaysInYearMonth(thisYear, thisMonth);\n+    }\n+\n+    /**\n+     * Gets the maximum number of days in the month specified by the instant.\n+     * The value represents what the user is trying to set, and can be\n+     * used to optimise this method.\n+     * \n+     * @param instant  millis from 1970-01-01T00:00:00Z\n+     * @param value  the value being set\n+     * @return the maximum number of days in the month\n+     */\n+    int getDaysInMonthMaxForSet(long instant, int value) {\n+        return getDaysInMonthMax(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the milliseconds for a date at midnight.\n+     * \n+     * @param year  the year\n+     * @param monthOfYear  the month\n+     * @param dayOfMonth  the day\n+     * @return the milliseconds\n+     */\n+    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year));\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear));\n+        return getYearMonthDayMillis(year, monthOfYear, dayOfMonth);\n+    }\n+\n+    /**\n+     * Gets the difference between the two instants in years.\n+     * \n+     * @param minuendInstant  the first instant\n+     * @param subtrahendInstant  the second instant\n+     * @return the difference\n+     */\n+    abstract long getYearDifference(long minuendInstant, long subtrahendInstant);\n+\n+    /**\n+     * Is the specified year a leap year?\n+     * \n+     * @param year  the year to test\n+     * @return true if leap\n+     */\n+    abstract boolean isLeapYear(int year);\n+\n+    /**\n+     * Gets the number of days in the specified month and year.\n+     * \n+     * @param year  the year\n+     * @param month  the month\n+     * @return the number of days\n+     */\n+    abstract int getDaysInYearMonth(int year, int month);\n+\n+    /**\n+     * Gets the maximum days in the specified month.\n+     * \n+     * @param month  the month\n+     * @return the max days\n+     */\n+    abstract int getDaysInMonthMax(int month);\n+\n+    /**\n+     * Gets the total number of millis elapsed in this year at the start\n+     * of the specified month, such as zero for month 1.\n+     * \n+     * @param year  the year\n+     * @param month  the month\n+     * @return the elapsed millis at the start of the month\n+     */\n+    abstract long getTotalMillisByYearMonth(int year, int month);\n+\n+    /**\n+     * Gets the millisecond value of the first day of the year.\n+     * \n+     * @return the milliseconds for the first of the year\n+     */\n+    abstract long calculateFirstDayOfYearMillis(int year);\n+\n+    /**\n+     * Gets the minimum supported year.\n+     * \n+     * @return the year\n+     */\n+    abstract int getMinYear();\n+\n+    /**\n+     * Gets the maximum supported year.\n+     * \n+     * @return the year\n+     */\n+    abstract int getMaxYear();\n+\n+    /**\n+     * Gets the maximum month for the specified year.\n+     * This implementation calls getMaxMonth().\n+     * \n+     * @param year  the year\n+     * @return the maximum month value\n+     */\n+    int getMaxMonth(int year) {\n+        return getMaxMonth();\n+    }\n+\n+    /**\n+     * Gets the maximum number of months.\n+     * \n+     * @return 12\n+     */\n+    int getMaxMonth() {\n+        return 12;\n+    }\n+\n+    /**\n+     * Gets an average value for the milliseconds per year.\n+     * \n+     * @return the millis per year\n+     */\n+    abstract long getAverageMillisPerYear();\n+\n+    /**\n+     * Gets an average value for the milliseconds per month.\n+     * \n+     * @return the millis per month\n+     */\n+    abstract long getAverageMillisPerMonth();\n+\n+    /**\n+     * Returns a constant representing the approximate number of milliseconds\n+     * elapsed from year 0 of this chronology. This constant <em>must</em> be\n+     * defined as:\n+     * <pre>\n+     *    yearAtEpoch * averageMillisPerYear + millisOfYearAtEpoch\n+     * <pre>\n+     * where epoch is 1970-01-01 (Gregorian).\n+     */\n+    abstract long getApproxMillisAtEpoch();\n+\n+    /**\n+     * Sets the year from an instant and year.\n+     * \n+     * @param instant  millis from 1970-01-01T00:00:00Z\n+     * @param year  the year to set\n+     * @return the updated millis\n+     */\n+    abstract long setYear(long instant, int year);\n+\n+    //-----------------------------------------------------------------------\n+    // Although accessed by multiple threads, this method doesn't need to be synchronized.\n+    private YearInfo getYearInfo(int year) {\n+        YearInfo info = iYearInfoCache[year & CACHE_MASK];\n+        if (info == null || info.iYear != year) {\n+            info = new YearInfo(year, calculateFirstDayOfYearMillis(year));\n+            iYearInfoCache[year & CACHE_MASK] = info;\n+        }\n+        return info;\n+    }\n+\n+    private static class HalfdayField extends PreciseDateTimeField {\n+        private static final long serialVersionUID = 581601443656929254L;\n+\n+        HalfdayField() {\n+            super(DateTimeFieldType.halfdayOfDay(), cHalfdaysField, cDaysField);\n+        }\n+\n+        public String getAsText(int fieldValue, Locale locale) {\n+            return GJLocaleSymbols.forLocale(locale).halfdayValueToText(fieldValue);\n+        }\n+\n+        public long set(long millis, String text, Locale locale) {\n+            return set(millis, GJLocaleSymbols.forLocale(locale).halfdayTextToValue(text));\n+        }\n+\n+        public int getMaximumTextLength(Locale locale) {\n+            return GJLocaleSymbols.forLocale(locale).getHalfdayMaxTextLength();\n+        }\n+    }\n+\n+    private static class YearInfo {\n+        public final int iYear;\n+        public final long iFirstDayMillis;\n+\n+        YearInfo(int year, long firstDayMillis) {\n+            iYear = year;\n+            iFirstDayMillis = firstDayMillis;\n+        }\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/chrono/BasicDayOfMonthDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicDayOfMonthDateTimeField.java\n \n     private static final long serialVersionUID = -4677223814028011723L;\n \n-    private final BaseGJChronology iChronology;\n+    private final BasicChronology iChronology;\n \n     /**\n      * Restricted constructor.\n      */\n-    BasicDayOfMonthDateTimeField(BaseGJChronology chronology, DurationField days) {\n+    BasicDayOfMonthDateTimeField(BasicChronology chronology, DurationField days) {\n         super(DateTimeFieldType.dayOfMonth(), days);\n         iChronology = chronology;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/BasicDayOfYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicDayOfYearDateTimeField.java\n \n     private static final long serialVersionUID = -6821236822336841037L;\n \n-    private final BaseGJChronology iChronology;\n+    private final BasicChronology iChronology;\n \n     /**\n      * Restricted constructor\n      */\n-    BasicDayOfYearDateTimeField(BaseGJChronology chronology, DurationField days) {\n+    BasicDayOfYearDateTimeField(BasicChronology chronology, DurationField days) {\n         super(DateTimeFieldType.dayOfYear(), days);\n         iChronology = chronology;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/BasicFixedMonthChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicFixedMonthChronology.java\n  * @author Stephen Colebourne\n  * @since 1.2, refactored from CopticChronology\n  */\n-abstract class BasicFixedMonthChronology extends BaseGJChronology {\n+abstract class BasicFixedMonthChronology extends BasicChronology {\n \n     /** Serialization lock */\n     private static final long serialVersionUID = 261387371998L;\n--- a/JodaTime/src/java/org/joda/time/chrono/BasicGJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicGJChronology.java\n  * @author Guy Allard\n  * @since 1.2, refactored from CommonGJChronology\n  */\n-abstract class BasicGJChronology extends BaseGJChronology {\n+abstract class BasicGJChronology extends BasicChronology {\n \n     /** Serialization lock */\n     private static final long serialVersionUID = 538276888268L;\n--- a/JodaTime/src/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n \n     private static final int MIN = DateTimeConstants.JANUARY;\n \n-    private final BaseGJChronology iChronology;\n+    private final BasicChronology iChronology;\n     private final int iMax;\n     private final int iLeapMonth;\n \n      * \n      * @param leapMonth the month of year that leaps\n      */\n-    BasicMonthOfYearDateTimeField(BaseGJChronology chronology, int leapMonth) {\n+    BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\n         super(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\n         iChronology = chronology;\n         iMax = iChronology.getMaxMonth();\n--- a/JodaTime/src/java/org/joda/time/chrono/BasicWeekOfWeekyearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicWeekOfWeekyearDateTimeField.java\n \n     private static final long serialVersionUID = -1587436826395135328L;\n \n-    private final BaseGJChronology iChronology;\n+    private final BasicChronology iChronology;\n \n     /**\n      * Restricted constructor\n      */\n-    BasicWeekOfWeekyearDateTimeField(BaseGJChronology chronology, DurationField weeks) {\n+    BasicWeekOfWeekyearDateTimeField(BasicChronology chronology, DurationField weeks) {\n         super(DateTimeFieldType.weekOfWeekyear(), weeks);\n         iChronology = chronology;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/BasicWeekyearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicWeekyearDateTimeField.java\n \n     private static final long WEEK_53 = (53L - 1) * DateTimeConstants.MILLIS_PER_WEEK;\n \n-    private final BaseGJChronology iChronology;\n+    private final BasicChronology iChronology;\n \n     /**\n      * Restricted constructor\n      */\n-    BasicWeekyearDateTimeField(BaseGJChronology chronology) {\n+    BasicWeekyearDateTimeField(BasicChronology chronology) {\n         super(DateTimeFieldType.weekyear(), chronology.getAverageMillisPerYear());\n         iChronology = chronology;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/BasicYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicYearDateTimeField.java\n     private static final long serialVersionUID = -98628754872287L;\n \n     /** The underlying basic chronology. */\n-    protected final BaseGJChronology iChronology;\n+    protected final BasicChronology iChronology;\n \n     /**\n      * Restricted constructor.\n      * \n      * @param chronology  the chronology this field belogs to\n      */\n-    BasicYearDateTimeField(BaseGJChronology chronology) {\n+    BasicYearDateTimeField(BasicChronology chronology) {\n         super(DateTimeFieldType.year(), chronology.getAverageMillisPerYear());\n         iChronology = chronology;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n      */\n     private Object readResolve() {\n         Chronology base = getBase();\n+        int minDays = getMinimumDaysInFirstWeek();\n+        minDays = (minDays == 0 ? 4 : minDays);  // handle rename of BaseGJChronology\n         return base == null ?\n-                getInstance(DateTimeZone.UTC, getMinimumDaysInFirstWeek()) :\n-                    getInstance(base.getZone(), getMinimumDaysInFirstWeek());\n+                getInstance(DateTimeZone.UTC, minDays) :\n+                    getInstance(base.getZone(), minDays);\n     }\n \n     // Conversion\n--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java\n     /** Serialization version */\n     private static final long serialVersionUID = -3857947176719041436L;\n \n-    private final BaseGJChronology iChronology;\n+    private final BasicChronology iChronology;\n \n     /**\n      * Restricted constructor.\n      */\n-    GJDayOfWeekDateTimeField(BaseGJChronology chronology, DurationField days) {\n+    GJDayOfWeekDateTimeField(BasicChronology chronology, DurationField days) {\n         super(DateTimeFieldType.dayOfWeek(), days);\n         iChronology = chronology;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java\n     /** Serialization version */\n     private static final long serialVersionUID = 4240986525305515528L;\n \n-    private final BaseGJChronology iChronology;\n+    private final BasicChronology iChronology;\n \n     /**\n      * Restricted constructor\n      */\n-    GJEraDateTimeField(BaseGJChronology chronology) {\n+    GJEraDateTimeField(BasicChronology chronology) {\n         super(DateTimeFieldType.era());\n         iChronology = chronology;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java\n     /**\n      * Restricted constructor\n      */\n-    GJMonthOfYearDateTimeField(BaseGJChronology chronology) {\n+    GJMonthOfYearDateTimeField(BasicChronology chronology) {\n         super(chronology, 2);\n     }\n \n--- a/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java\n \n     private static final long serialVersionUID = -5961050944769862059L;\n \n-    private final BaseGJChronology iChronology;\n+    private final BasicChronology iChronology;\n \n     /**\n      * Restricted constructor.\n      */\n-    GJYearOfEraDateTimeField(DateTimeField yearField, BaseGJChronology chronology) {\n+    GJYearOfEraDateTimeField(DateTimeField yearField, BasicChronology chronology) {\n         super(yearField, DateTimeFieldType.yearOfEra());\n         iChronology = chronology;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java\n      */\n     private Object readResolve() {\n         Chronology base = getBase();\n+        int minDays = getMinimumDaysInFirstWeek();\n+        minDays = (minDays == 0 ? 4 : minDays);  // handle rename of BaseGJChronology\n         return base == null ?\n-                getInstance(DateTimeZone.UTC, getMinimumDaysInFirstWeek()) :\n-                    getInstance(base.getZone(), getMinimumDaysInFirstWeek());\n+                getInstance(DateTimeZone.UTC, minDays) :\n+                    getInstance(base.getZone(), minDays);\n     }\n \n     // Conversion\n--- a/JodaTime/src/java/org/joda/time/chrono/IslamicChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/IslamicChronology.java\n  * @author Stephen Colebourne\n  * @since 1.2\n  */\n-public final class IslamicChronology extends BaseGJChronology {\n+public final class IslamicChronology extends BasicChronology {\n \n     /** Serialization lock */\n     private static final long serialVersionUID = -3663823829888L;\n--- a/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n      */\n     private Object readResolve() {\n         Chronology base = getBase();\n+        int minDays = getMinimumDaysInFirstWeek();\n+        minDays = (minDays == 0 ? 4 : minDays);  // handle rename of BaseGJChronology\n         return base == null ?\n-                getInstance(DateTimeZone.UTC, getMinimumDaysInFirstWeek()) :\n-                    getInstance(base.getZone(), getMinimumDaysInFirstWeek());\n+                getInstance(DateTimeZone.UTC, minDays) :\n+                    getInstance(base.getZone(), minDays);\n     }\n \n     // Conversion\n--- a/JodaTime/src/test/org/joda/time/TestSerialization.java\n+++ b/JodaTime/src/test/org/joda/time/TestSerialization.java\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.io.Serializable;\n         inlineCompare(test, true);\n     }\n \n+    public void testSerializedGJChronologyChangedInternals() throws Exception {\n+        GJChronology test = GJChronology.getInstance(PARIS, 123L, 2);\n+        loadAndCompare(test, \"GJChronologyChangedInternals.dat\", true);\n+        inlineCompare(test, true);\n+    }\n+\n     public void testSerializedGregorianChronology() throws Exception {\n         GregorianChronology test = GregorianChronology.getInstance(PARIS);\n         loadAndCompare(test, \"GregorianChronology.dat\", true);\n //        store(test, \"GJChronology.dat\");\n //    }\n //\n+//    // Format changed in v1.2 - min days in first week not deserialized in v1.0/1.1\n+//    public void testStoreSerializedGJChronologyChangedInternals() throws Exception {\n+//        GJChronology test = GJChronology.getInstance(PARIS, 123L, 2);\n+//        store(test, \"GJChronologyChangedInternals.dat\");\n+//    }\n+//\n //    public void testStoreSerializedGregorianChronology() throws Exception {\n //        GregorianChronology test = GregorianChronology.getInstance(PARIS);\n //        store(test, \"GregorianChronology.dat\");\n //        store(test, \"DateMidnightProperty.dat\");\n //    }\n \n-//    private void store(Serializable test, String filename) throws Exception {\n-//        FileOutputStream fos = new FileOutputStream(\"src/testdata/\" + filename);\n-//        ObjectOutputStream oos = new ObjectOutputStream(fos);\n-//        try {\n-//            oos.writeObject(test);\n-//        } finally {\n-//            oos.close();\n-//        }\n-//        oos.close();\n-//    }\n-//\n+    private void store(Serializable test, String filename) throws Exception {\n+        FileOutputStream fos = new FileOutputStream(\"src/testdata/\" + filename);\n+        ObjectOutputStream oos = new ObjectOutputStream(fos);\n+        try {\n+            oos.writeObject(test);\n+        } finally {\n+            oos.close();\n+        }\n+        oos.close();\n+    }\n+\n }", "timestamp": 1133822805, "metainfo": ""}