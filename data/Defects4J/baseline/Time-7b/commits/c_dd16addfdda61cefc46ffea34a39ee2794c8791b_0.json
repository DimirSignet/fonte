{"sha": "dd16addfdda61cefc46ffea34a39ee2794c8791b", "log": "Add ChronologyType, to provide the missing link in the API types   ", "commit": "\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/ChronologyType.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.joda.time.chrono.BuddhistChronology;\n+import org.joda.time.chrono.CopticChronology;\n+import org.joda.time.chrono.GJChronology;\n+import org.joda.time.chrono.GregorianChronology;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.chrono.JulianChronology;\n+\n+/**\n+ * Identifies a type of chronology, which represents the calendar system.\n+ * <p>\n+ * Various chronologies are supported by Joda-Time, including ISO and\n+ * GregorianJulian. This class defines static methods to obtain the\n+ * different kinds of chronology that are supported. Each instance then\n+ * defines methods to obtain a Chronology by specifying the time zone.\n+ * For example, to obtain the coptic chronology in the default zone:\n+ * <pre>\n+ * Chronology c = ChronologyType.coptic().getChronology();\n+ * </pre>\n+ * <p>\n+ * The provided chronology types are:\n+ * <ul>\n+ * <li>ISO - Based on the ISO8601 standard and suitable for use after about 1600\n+ * <li>GJ - Historically accurate calendar with Julian followed by Gregorian\n+ * <li>Gregorian - The Gregorian calendar system used for all time (proleptic)\n+ * <li>Julian - The Julian calendar system used for all time (proleptic)\n+ * <li>Buddhist - The Buddhist calendar system which is an offset in years from GJ\n+ * <li>Coptic - The Coptic calendar system which defines 30 day months\n+ * </ul>\n+ * Hopefully future releases will contain more chronologies.\n+ *\n+ * @see org.joda.time.chrono.ISOChronology\n+ * @see org.joda.time.chrono.GJChronology\n+ * @see org.joda.time.chrono.GregorianChronology\n+ * @see org.joda.time.chrono.JulianChronology\n+ * @see org.joda.time.chrono.CopticChronology\n+ * @see org.joda.time.chrono.BuddhistChronology\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.2\n+ */\n+public abstract class ChronologyType implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 83923682285389L;\n+\n+    /** The map of id to type. */\n+    private static final Map cTypes = Collections.synchronizedMap(new HashMap());\n+\n+    /** Ordinal values for standard chronology types. */\n+    static final byte  // do not change - values matter for serialization\n+        ISO = 1,\n+        GJ = 2,\n+        GREGORIAN = 3,\n+        JULIAN = 4,\n+        BUDDHIST = 5,\n+        COPTIC = 6;\n+\n+    /** The iso chronology type. */\n+    private static final ChronologyType ISO_TYPE = new StandardChronologyType(\"ISO\", ISO);\n+    /** The iso chronology type. */\n+    private static final ChronologyType GJ_TYPE = new StandardChronologyType(\"GJ\", GJ);\n+    /** The iso chronology type. */\n+    private static final ChronologyType GREGORIAN_TYPE = new StandardChronologyType(\"Gregorian\", GREGORIAN);\n+    /** The iso chronology type. */\n+    private static final ChronologyType JULIAN_TYPE = new StandardChronologyType(\"Julian\", JULIAN);\n+    /** The iso chronology type. */\n+    private static final ChronologyType BUDDHIST_TYPE = new StandardChronologyType(\"Buddhist\", BUDDHIST);\n+    /** The iso chronology type. */\n+    private static final ChronologyType COPTIC_TYPE = new StandardChronologyType(\"Coptic\", COPTIC);\n+\n+    /** The id of the field. */\n+    private final String iID;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     * \n+     * @param id  the id to use\n+     */\n+    protected ChronologyType(String id) {\n+        super();\n+        iID = id;\n+        cTypes.put(id, this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a ChronologyType by id.\n+     * <p>\n+     * Note that this method will work with your own subclasses of\n+     * ChronologyType, so long as an instance of the subclass has been\n+     * class-loaded.\n+     *\n+     * @param id  the id to get\n+     * @return the chronology type, null if no known chronology\n+     */\n+    public static ChronologyType forID(String id) {\n+        return (ChronologyType) cTypes.get(id);\n+    }\n+\n+    /**\n+     * Gets all the available ids supported.\n+     * \n+     * @return an unmodifiable Set of String ids\n+     */\n+    public static Set getAvailableIDs() {\n+        return Collections.unmodifiableSet(cTypes.keySet());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the ISO chronology type.\n+     * <p>\n+     * {@link ISOChronology} defines all fields in line with the ISO8601 standard.\n+     * This chronology is the default, and is suitable for all normal datetime processing.\n+     * It is <i>unsuitable</i> for historical datetimes before October 15, 1582\n+     * as it applies the modern Gregorian calendar rules before that date.\n+     *\n+     * @return the ChronologyType constant\n+     */\n+    public static ChronologyType iso() {\n+        return ISO_TYPE;\n+    }\n+\n+    /**\n+     * Get the GJ chronology type.\n+     * <p>\n+     * {@link GJChronology} defines all fields using standard meanings.\n+     * This chronology is intended to be used as a replacement for <code>GregorianCalendar</code>.\n+     * The Gregorian calendar system is used after October 15, 1582, while the\n+     * Julian calendar system is used before.\n+     * <p>\n+     * Unlike <code>GregorianCalendar</code>, this chronology returns a year of -1\n+     * for 1 BCE, -2 for 2 BCE and so on. Thus there is no year zero.\n+     * <p>\n+     * This method uses the standard Julian to Gregorian cutover date of\n+     * October 15th 1582. If you require a cutover on a different date, then use\n+     * the factory methods on <code>GJChronology</code> itself.\n+     * <p>\n+     * When dealing solely with dates in the modern era, from 1600 onwards,\n+     * we recommend using ISOChronology, which is the default.\n+     *\n+     * @return the ChronologyType constant\n+     */\n+    public static ChronologyType gj() {\n+        return GJ_TYPE;\n+    }\n+\n+    /**\n+     * Get the Gregorian chronology type.\n+     * <p>\n+     * {@link GregorianChronology} defines all fields using standard meanings.\n+     * It uses the Gregorian calendar rules <i>for all time</i> (proleptic)\n+     * thus it is NOT a replacement for <code>GregorianCalendar</code>.\n+     * For that purpose, you should use {@link #gj()}.\n+     * <p>\n+     * The Gregorian calendar system defines a leap year every four years,\n+     * except that every 100 years is not leap, but every 400 is leap.\n+     * <p>\n+     * Technically, this chronology is almost identical to the ISO chronology,\n+     * thus we recommend using ISOChronology instead, which is the default.\n+     *\n+     * @return the ChronologyType constant\n+     */\n+    public static ChronologyType gregorian() {\n+        return GREGORIAN_TYPE;\n+    }\n+\n+    /**\n+     * Get the Julian chronology type.\n+     * <p>\n+     * {@link JulianChronology} defines all fields using standard meanings.\n+     * It uses the Julian calendar rules <i>for all time</i> (proleptic).\n+     * The Julian calendar system defines a leap year every four years.\n+     *\n+     * @return the ChronologyType constant\n+     */\n+    public static ChronologyType julian() {\n+        return JULIAN_TYPE;\n+    }\n+\n+    /**\n+     * Get the Buddhist chronology type.\n+     * <p>\n+     * {@link BuddhistChronology} defines all fields using standard meanings,\n+     * however the year is offset by 543. The chronology cannot be used before\n+     * year 1 in the Buddhist calendar.\n+     *\n+     * @return the ChronologyType constant\n+     */\n+    public static ChronologyType buddhist() {\n+        return BUDDHIST_TYPE;\n+    }\n+\n+    /**\n+     * Get the Coptic chronology type.\n+     * <p>\n+     * {@link CopticChronology} defines fields sensibly for the Coptic calendar system.\n+     * The Coptic calendar system defines every fourth year as leap.\n+     * The year is broken down into 12 months, each 30 days in length.\n+     * An extra period at the end of the year is either 5 or 6 days in length\n+     * and is returned as a 13th month.\n+     * Year 1 in the Coptic calendar began on August 29, 284 CE (Julian).\n+     * The chronology cannot be used before the first Coptic year.\n+     *\n+     * @return the ChronologyType constant\n+     */\n+    public static ChronologyType coptic() {\n+        return COPTIC_TYPE;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the id of the chronology.\n+     * \n+     * @return the id of the chronology\n+     */\n+    public String getID() {\n+        return iID;\n+    }\n+\n+    /**\n+     * Get an instance of the Chronology in the default time zone.\n+     * \n+     * @return the Chronology\n+     */\n+    public Chronology getChronology() {\n+        return getChronology(null);\n+    }\n+\n+    /**\n+     * Get an instance of the Chronology in the UTC time zone.\n+     * \n+     * @return the Chronology\n+     */\n+    public Chronology getChronologyUTC() {\n+        return getChronology(DateTimeZone.UTC);\n+    }\n+\n+    /**\n+     * Get an instance of the Chronology in the specified time zone.\n+     * \n+     * @param zone  the time zone, null means default\n+     */\n+    public abstract Chronology getChronology(DateTimeZone zone);\n+\n+    /**\n+     * Gets the chronology as a string, which is simply its id.\n+     *\n+     * @return the id of the chronology\n+     */\n+    public String toString() {\n+        return getID();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private static class StandardChronologyType extends ChronologyType {\n+        /** Serialization version */\n+        private static final long serialVersionUID = -562289176239L;\n+\n+        /** The ordinal of the standard field type, for switch statements */\n+        private final byte iOrdinal;\n+\n+        /**\n+         * Constructor.\n+         */\n+        StandardChronologyType(String id, byte ordinal) {\n+            super(id);\n+            iOrdinal = ordinal;\n+        }\n+\n+        /** @inheritdoc */\n+        public Chronology getChronology(DateTimeZone zone) {\n+            switch (iOrdinal) {\n+                case ISO:\n+                    return ISOChronology.getInstance(zone);\n+                case GJ:\n+                    return GJChronology.getInstance(zone);\n+                case GREGORIAN:\n+                    return GregorianChronology.getInstance(zone);\n+                case JULIAN:\n+                    return JulianChronology.getInstance(zone);\n+                case BUDDHIST:\n+                    return BuddhistChronology.getInstance(zone);\n+                case COPTIC:\n+                    return CopticChronology.getInstance(zone);\n+                default:\n+                    // Shouldn't happen.\n+                    throw new InternalError();\n+            }\n+        }\n+\n+        /**\n+         * Ensure a singleton is returned.\n+         * \n+         * @return the singleton type\n+         */\n+        private Object readResolve() {\n+        \treturn (ChronologyType) forID(getID());\n+        }\n+    }\n+\n+}\n--- a/JodaTime/src/test/org/joda/time/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/TestAll.java\n     public static Test suite() {\n         TestSuite suite = new TestSuite();\n         suite.addTest(TestChronology.suite());\n+        suite.addTest(TestChronologyType.suite());\n         suite.addTest(TestDateTimeFieldType.suite());\n         suite.addTest(TestDurationFieldType.suite());\n         \n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestChronologyType.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Constructor;\n+import java.util.Set;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.BuddhistChronology;\n+import org.joda.time.chrono.CopticChronology;\n+import org.joda.time.chrono.GJChronology;\n+import org.joda.time.chrono.GregorianChronology;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.chrono.JulianChronology;\n+\n+/**\n+ * This class is a Junit unit test for ChronologyType.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestChronologyType extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestChronologyType.class);\n+    }\n+\n+    public TestChronologyType(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+    }\n+\n+    protected void tearDown() throws Exception {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_forName() throws Exception {\n+        assertSame(ChronologyType.iso(), ChronologyType.forID(\"ISO\"));\n+        assertSame(null, ChronologyType.forID(\"rubbish\"));\n+        assertSame(null, ChronologyType.forID(\"\"));\n+        assertSame(null, ChronologyType.forID(null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_getAvailableIDs() throws Exception {\n+        Set set = ChronologyType.getAvailableIDs();\n+        assertEquals(6, set.size());\n+        assertEquals(true, set.contains(\"ISO\"));\n+        assertEquals(true, set.contains(\"GJ\"));\n+        assertEquals(true, set.contains(\"Gregorian\"));\n+        assertEquals(true, set.contains(\"Julian\"));\n+        assertEquals(true, set.contains(\"Buddhist\"));\n+        assertEquals(true, set.contains(\"Coptic\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_iso() throws Exception {\n+        assertEquals(ChronologyType.iso(), ChronologyType.iso());\n+        assertEquals(\"ISO\", ChronologyType.iso().getID());\n+        assertEquals(ISOChronology.getInstance(), ChronologyType.iso().getChronology());\n+        assertEquals(ISOChronology.getInstanceUTC(), ChronologyType.iso().getChronologyUTC());\n+        assertEquals(ISOChronology.getInstance(PARIS), ChronologyType.iso().getChronology(PARIS));\n+        assertEquals(\"ISO\", ChronologyType.iso().toString());\n+        assertSerialization(ChronologyType.iso());\n+    }\n+\n+    public void test_gj() throws Exception {\n+        assertEquals(ChronologyType.gj(), ChronologyType.gj());\n+        assertEquals(\"GJ\", ChronologyType.gj().getID());\n+        assertEquals(GJChronology.getInstance(), ChronologyType.gj().getChronology());\n+        assertEquals(GJChronology.getInstanceUTC(), ChronologyType.gj().getChronologyUTC());\n+        assertEquals(GJChronology.getInstance(PARIS), ChronologyType.gj().getChronology(PARIS));\n+        assertEquals(\"GJ\", ChronologyType.gj().toString());\n+        assertSerialization(ChronologyType.gj());\n+    }\n+\n+    public void test_gregorian() throws Exception {\n+        assertEquals(ChronologyType.gregorian(), ChronologyType.gregorian());\n+        assertEquals(\"Gregorian\", ChronologyType.gregorian().getID());\n+        assertEquals(GregorianChronology.getInstance(), ChronologyType.gregorian().getChronology());\n+        assertEquals(GregorianChronology.getInstanceUTC(), ChronologyType.gregorian().getChronologyUTC());\n+        assertEquals(GregorianChronology.getInstance(PARIS), ChronologyType.gregorian().getChronology(PARIS));\n+        assertEquals(\"Gregorian\", ChronologyType.gregorian().toString());\n+        assertSerialization(ChronologyType.gregorian());\n+    }\n+\n+    public void test_julian() throws Exception {\n+        assertEquals(ChronologyType.julian(), ChronologyType.julian());\n+        assertEquals(\"Julian\", ChronologyType.julian().getID());\n+        assertEquals(JulianChronology.getInstance(), ChronologyType.julian().getChronology());\n+        assertEquals(JulianChronology.getInstanceUTC(), ChronologyType.julian().getChronologyUTC());\n+        assertEquals(JulianChronology.getInstance(PARIS), ChronologyType.julian().getChronology(PARIS));\n+        assertEquals(\"Julian\", ChronologyType.julian().toString());\n+        assertSerialization(ChronologyType.julian());\n+    }\n+\n+    public void test_buddhist() throws Exception {\n+        assertEquals(ChronologyType.buddhist(), ChronologyType.buddhist());\n+        assertEquals(\"Buddhist\", ChronologyType.buddhist().getID());\n+        assertEquals(BuddhistChronology.getInstance(), ChronologyType.buddhist().getChronology());\n+        assertEquals(BuddhistChronology.getInstanceUTC(), ChronologyType.buddhist().getChronologyUTC());\n+        assertEquals(BuddhistChronology.getInstance(PARIS), ChronologyType.buddhist().getChronology(PARIS));\n+        assertEquals(\"Buddhist\", ChronologyType.buddhist().toString());\n+        assertSerialization(ChronologyType.buddhist());\n+    }\n+\n+    public void test_coptic() throws Exception {\n+        assertEquals(ChronologyType.coptic(), ChronologyType.coptic());\n+        assertEquals(\"Coptic\", ChronologyType.coptic().getID());\n+        assertEquals(CopticChronology.getInstance(), ChronologyType.coptic().getChronology());\n+        assertEquals(CopticChronology.getInstanceUTC(), ChronologyType.coptic().getChronologyUTC());\n+        assertEquals(CopticChronology.getInstance(PARIS), ChronologyType.coptic().getChronology(PARIS));\n+        assertEquals(\"Coptic\", ChronologyType.coptic().toString());\n+        assertSerialization(ChronologyType.coptic());\n+    }\n+\n+    public void test_other() throws Exception {\n+        assertEquals(1, ChronologyType.class.getDeclaredClasses().length);\n+        Class cls = ChronologyType.class.getDeclaredClasses()[0];\n+        assertEquals(1, cls.getDeclaredConstructors().length);\n+        Constructor con = cls.getDeclaredConstructors()[0];\n+        Object[] params = new Object[] { \"other\", new Byte((byte) 128) };\n+        ChronologyType type = (ChronologyType) con.newInstance(params);\n+        \n+        assertEquals(\"other\", type.getID());\n+        try {\n+            type.getChronology(PARIS);\n+            fail();\n+        } catch (InternalError ex) {}\n+        assertSerialization(type);   // same because of ID map\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void assertSerialization(ChronologyType type) throws Exception {\n+        ChronologyType result = doSerialization(type);\n+        assertSame(type, result);\n+    }\n+\n+    private ChronologyType doSerialization(ChronologyType type) throws Exception {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(type);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        ChronologyType result = (ChronologyType) ois.readObject();\n+        ois.close();\n+        return result;\n+    }\n+\n+}", "timestamp": 1125782718, "metainfo": ""}